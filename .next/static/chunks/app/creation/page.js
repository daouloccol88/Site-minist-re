/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/creation/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fsaheliandev%2FDesktop%2FPersonnal%2FSite-minist-re%2Fsrc%2Fapp%2Fcreation%2Fpage.jsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!****************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fsaheliandev%2FDesktop%2FPersonnal%2FSite-minist-re%2Fsrc%2Fapp%2Fcreation%2Fpage.jsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \****************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/creation/page.jsx */ \"(app-pages-browser)/./src/app/creation/page.jsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZzYWhlbGlhbmRldiUyRkRlc2t0b3AlMkZQZXJzb25uYWwlMkZTaXRlLW1pbmlzdC1yZSUyRnNyYyUyRmFwcCUyRmNyZWF0aW9uJTJGcGFnZS5qc3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxnTEFBa0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz9jYjIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL3NhaGVsaWFuZGV2L0Rlc2t0b3AvUGVyc29ubmFsL1NpdGUtbWluaXN0LXJlL3NyYy9hcHAvY3JlYXRpb24vcGFnZS5qc3hcIik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fsaheliandev%2FDesktop%2FPersonnal%2FSite-minist-re%2Fsrc%2Fapp%2Fcreation%2Fpage.jsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.dev.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar html = __webpack_require__(/*! @lexical/html */ \"(app-pages-browser)/./node_modules/@lexical/html/LexicalHtml.js\");\nvar selection = __webpack_require__(/*! @lexical/selection */ \"(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @returns a string of HTML content\n */\n\n\nfunction $getHtmlContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n\n  return html.$generateHtmlFromNodes(editor, selection);\n}\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @returns\n */\n\nfunction $getLexicalContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\n\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\n\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch {// Fail silently.\n    }\n  }\n\n  const htmlString = dataTransfer.getData('text/html');\n\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = html.$generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch {// Fail silently.\n    }\n  } // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n\n\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n\n  if (text != null) {\n    if (lexical.$isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      const partsLength = parts.length;\n\n      for (let i = 0; i < partsLength; i++) {\n        const part = parts[i];\n\n        if (part === '\\n' || part === '\\r\\n') {\n          selection.insertParagraph();\n        } else if (part === '\\t') {\n          selection.insertNodes([lexical.$createTabNode()]);\n        } else {\n          selection.insertText(part);\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\n\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\n    return;\n  }\n\n  $basicInsertStrategy(nodes, selection);\n  return;\n}\n\nfunction $basicInsertStrategy(nodes, selection) {\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n  const topLevelBlocks = [];\n  let currentBlock = null;\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = lexical.$isLineBreakNode(node);\n\n    if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        topLevelBlocks.push(currentBlock); // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      topLevelBlocks.push(node);\n      currentBlock = null;\n    }\n  }\n\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(topLevelBlocks);\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n\n    anchorCell.append(...topLevelBlocks);\n  }\n}\n\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\n\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const newGridRowNode = newGridRows[newRowIdx];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n\n    newRowIdx++;\n  }\n\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n\n  const serializedChildren = serializedNode.children;\n\n  if (lexical.$isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n\n  return serializedNode;\n}\n\nfunction $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target); // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n\n  if (lexical.$isTextNode(target)) {\n    const text = target.__text; // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n\n  return shouldInclude;\n} // TODO why $ function with Editor instance?\n\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\n\n\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\n\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = lexical.$parseSerializedNode(serializedNode);\n\n    if (lexical.$isTextNode(node)) {\n      selection.$addNodeStyle(node);\n    }\n\n    nodes.push(node);\n  }\n\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null; // TODO custom selection\n// TODO potentially have a node customizable version for plain text\n\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\n\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical.COPY_COMMAND, secondEvent => {\n      if (utils.objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      } // Block the entire copy flow while we wait for the next ClipboardEvent\n\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL); // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n} // TODO shouldn't pass editor (pass namespace directly)\n\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = getDOMSelection(editor._window);\n\n  if (!domSelection) {\n    return false;\n  }\n\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n\n  if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = lexical.$getSelection();\n\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\n\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\nexports.$getHtmlContent = $getHtmlContent;\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.$insertGeneratedNodes = $insertGeneratedNodes;\nexports.copyToClipboard = copyToClipboard;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jbGlwYm9hcmQvTGV4aWNhbENsaXBib2FyZC5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLHNGQUFlO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLHFHQUFvQjtBQUM1QyxZQUFZLG1CQUFPLENBQUMseUZBQWdCO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2I7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsVUFBVTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixVQUFVO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsNkJBQTZCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLGFBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsS0FBSyxzQ0FBc0M7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEMseUNBQXlDO0FBQ3pDLHVCQUF1QjtBQUN2QiwwQkFBMEI7QUFDMUIsdUNBQXVDO0FBQ3ZDLHNDQUFzQztBQUN0Qyw2QkFBNkI7QUFDN0IsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jbGlwYm9hcmQvTGV4aWNhbENsaXBib2FyZC5kZXYuanM/MWZmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGh0bWwgPSByZXF1aXJlKCdAbGV4aWNhbC9odG1sJyk7XG52YXIgc2VsZWN0aW9uID0gcmVxdWlyZSgnQGxleGljYWwvc2VsZWN0aW9uJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBnZXRET01TZWxlY3Rpb24gPSB0YXJnZXRXaW5kb3cgPT4gQ0FOX1VTRV9ET00gPyAodGFyZ2V0V2luZG93IHx8IHdpbmRvdykuZ2V0U2VsZWN0aW9uKCkgOiBudWxsO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSAqY3VycmVudGx5IHNlbGVjdGVkKiBMZXhpY2FsIGNvbnRlbnQgYXMgYW4gSFRNTCBzdHJpbmcsIHJlbHlpbmcgb24gdGhlXG4gKiBsb2dpYyBkZWZpbmVkIGluIHRoZSBleHBvcnRET00gbWV0aG9kcyBvbiB0aGUgTGV4aWNhbE5vZGUgY2xhc3Nlcy4gTm90ZSB0aGF0XG4gKiB0aGlzIHdpbGwgbm90IHJldHVybiB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBlbnRpcmUgZWRpdG9yICh1bmxlc3MgYWxsIHRoZSBjb250ZW50IGlzIGluY2x1ZGVkXG4gKiBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24pLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgLSBMZXhpY2FsRWRpdG9yIGluc3RhbmNlIHRvIGdldCBIVE1MIGNvbnRlbnQgZnJvbVxuICogQHJldHVybnMgYSBzdHJpbmcgb2YgSFRNTCBjb250ZW50XG4gKi9cblxuXG5mdW5jdGlvbiAkZ2V0SHRtbENvbnRlbnQoZWRpdG9yKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB2YWxpZCBMZXhpY2FsU2VsZWN0aW9uYCk7XG4gICAgfVxuICB9IC8vIElmIHdlIGhhdmVuJ3Qgc2VsZWN0ZWQgYW55dGhpbmdcblxuXG4gIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgc2VsZWN0aW9uLmdldE5vZGVzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIGh0bWwuJGdlbmVyYXRlSHRtbEZyb21Ob2RlcyhlZGl0b3IsIHNlbGVjdGlvbik7XG59XG4vKipcbiAqIFJldHVybnMgdGhlICpjdXJyZW50bHkgc2VsZWN0ZWQqIExleGljYWwgY29udGVudCBhcyBhIEpTT04gc3RyaW5nLCByZWx5aW5nIG9uIHRoZVxuICogbG9naWMgZGVmaW5lZCBpbiB0aGUgZXhwb3J0SlNPTiBtZXRob2RzIG9uIHRoZSBMZXhpY2FsTm9kZSBjbGFzc2VzLiBOb3RlIHRoYXRcbiAqIHRoaXMgd2lsbCBub3QgcmV0dXJuIHRoZSBKU09OIGNvbnRlbnQgb2YgdGhlIGVudGlyZSBlZGl0b3IgKHVubGVzcyBhbGwgdGhlIGNvbnRlbnQgaXMgaW5jbHVkZWRcbiAqIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbikuXG4gKlxuICogQHBhcmFtIGVkaXRvciAgLSBMZXhpY2FsRWRpdG9yIGluc3RhbmNlIHRvIGdldCB0aGUgSlNPTiBjb250ZW50IGZyb21cbiAqIEByZXR1cm5zXG4gKi9cblxuZnVuY3Rpb24gJGdldExleGljYWxDb250ZW50KGVkaXRvcikge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdmFsaWQgTGV4aWNhbFNlbGVjdGlvbmApO1xuICAgIH1cbiAgfSAvLyBJZiB3ZSBoYXZlbid0IHNlbGVjdGVkIGFueXRoaW5nXG5cblxuICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IHNlbGVjdGlvbi5nZXROb2RlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2RlcyhlZGl0b3IsIHNlbGVjdGlvbikpO1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnNlcnQgY29udGVudCBvZiB0aGUgbWltZS10eXBlcyB0ZXh0L3BsYWluIG9yIHRleHQvdXJpLWxpc3QgZnJvbVxuICogdGhlIHByb3ZpZGVkIERhdGFUcmFuc2ZlciBvYmplY3QgaW50byB0aGUgZWRpdG9yIGF0IHRoZSBwcm92aWRlZCBzZWxlY3Rpb24uXG4gKiB0ZXh0L3VyaS1saXN0IGlzIG9ubHkgdXNlZCBpZiB0ZXh0L3BsYWluIGlzIG5vdCBhbHNvIHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSBkYXRhVHJhbnNmZXIgYW4gb2JqZWN0IGNvbmZvcm1pbmcgdG8gdGhlIFtEYXRhVHJhbnNmZXIgaW50ZXJmYWNlXSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG5kLmh0bWwjdGhlLWRhdGF0cmFuc2Zlci1pbnRlcmZhY2UpXG4gKiBAcGFyYW0gc2VsZWN0aW9uIHRoZSBzZWxlY3Rpb24gdG8gdXNlIGFzIHRoZSBpbnNlcnRpb24gcG9pbnQgZm9yIHRoZSBjb250ZW50IGluIHRoZSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gKi9cblxuZnVuY3Rpb24gJGluc2VydERhdGFUcmFuc2ZlckZvclBsYWluVGV4dChkYXRhVHJhbnNmZXIsIHNlbGVjdGlvbikge1xuICBjb25zdCB0ZXh0ID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvcGxhaW4nKSB8fCBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC91cmktbGlzdCcpO1xuXG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dCh0ZXh0KTtcbiAgfVxufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnNlcnQgY29udGVudCBvZiB0aGUgbWltZS10eXBlcyBhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yLCB0ZXh0L2h0bWwsXG4gKiB0ZXh0L3BsYWluLCBvciB0ZXh0L3VyaS1saXN0IChpbiBkZXNjZW5kaW5nIG9yZGVyIG9mIHByaW9yaXR5KSBmcm9tIHRoZSBwcm92aWRlZCBEYXRhVHJhbnNmZXJcbiAqIG9iamVjdCBpbnRvIHRoZSBlZGl0b3IgYXQgdGhlIHByb3ZpZGVkIHNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gZGF0YVRyYW5zZmVyIGFuIG9iamVjdCBjb25mb3JtaW5nIHRvIHRoZSBbRGF0YVRyYW5zZmVyIGludGVyZmFjZV0gKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RuZC5odG1sI3RoZS1kYXRhdHJhbnNmZXItaW50ZXJmYWNlKVxuICogQHBhcmFtIHNlbGVjdGlvbiB0aGUgc2VsZWN0aW9uIHRvIHVzZSBhcyB0aGUgaW5zZXJ0aW9uIHBvaW50IGZvciB0aGUgY29udGVudCBpbiB0aGUgRGF0YVRyYW5zZmVyIG9iamVjdFxuICogQHBhcmFtIGVkaXRvciB0aGUgTGV4aWNhbEVkaXRvciB0aGUgY29udGVudCBpcyBiZWluZyBpbnNlcnRlZCBpbnRvLlxuICovXG5cbmZ1bmN0aW9uICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dChkYXRhVHJhbnNmZXIsIHNlbGVjdGlvbiwgZWRpdG9yKSB7XG4gIGNvbnN0IGxleGljYWxTdHJpbmcgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgnYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvcicpO1xuXG4gIGlmIChsZXhpY2FsU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGxleGljYWxTdHJpbmcpO1xuXG4gICAgICBpZiAocGF5bG9hZC5uYW1lc3BhY2UgPT09IGVkaXRvci5fY29uZmlnLm5hbWVzcGFjZSAmJiBBcnJheS5pc0FycmF5KHBheWxvYWQubm9kZXMpKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gJGdlbmVyYXRlTm9kZXNGcm9tU2VyaWFsaXplZE5vZGVzKHBheWxvYWQubm9kZXMpO1xuICAgICAgICByZXR1cm4gJGluc2VydEdlbmVyYXRlZE5vZGVzKGVkaXRvciwgbm9kZXMsIHNlbGVjdGlvbik7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7Ly8gRmFpbCBzaWxlbnRseS5cbiAgICB9XG4gIH1cblxuICBjb25zdCBodG1sU3RyaW5nID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvaHRtbCcpO1xuXG4gIGlmIChodG1sU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgIGNvbnN0IGRvbSA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoaHRtbFN0cmluZywgJ3RleHQvaHRtbCcpO1xuICAgICAgY29uc3Qgbm9kZXMgPSBodG1sLiRnZW5lcmF0ZU5vZGVzRnJvbURPTShlZGl0b3IsIGRvbSk7XG4gICAgICByZXR1cm4gJGluc2VydEdlbmVyYXRlZE5vZGVzKGVkaXRvciwgbm9kZXMsIHNlbGVjdGlvbik7XG4gICAgfSBjYXRjaCB7Ly8gRmFpbCBzaWxlbnRseS5cbiAgICB9XG4gIH0gLy8gTXVsdGktbGluZSBwbGFpbiB0ZXh0IGluIHJpY2ggdGV4dCBtb2RlIHBhc3RlZCBhcyBzZXBhcmF0ZSBwYXJhZ3JhcGhzXG4gIC8vIGluc3RlYWQgb2Ygc2luZ2xlIHBhcmFncmFwaCB3aXRoIGxpbmVicmVha3MuXG4gIC8vIFdlYmtpdC1zcGVjaWZpYzogU3VwcG9ydHMgcmVhZCAndGV4dC91cmktbGlzdCcgaW4gY2xpcGJvYXJkLlxuXG5cbiAgY29uc3QgdGV4dCA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3BsYWluJykgfHwgZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvdXJpLWxpc3QnKTtcblxuICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgcGFydHMgPSB0ZXh0LnNwbGl0KC8oXFxyP1xcbnxcXHQpLyk7XG4gICAgICBjb25zdCBwYXJ0c0xlbmd0aCA9IHBhcnRzLmxlbmd0aDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICBpZiAocGFydCA9PT0gJ1xcbicgfHwgcGFydCA9PT0gJ1xcclxcbicpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0UGFyYWdyYXBoKCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0Tm9kZXMoW2xleGljYWwuJGNyZWF0ZVRhYk5vZGUoKV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGVjdGlvbi5pbnNlcnRUZXh0KHBhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi5pbnNlcnRSYXdUZXh0KHRleHQpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBJbnNlcnRzIExleGljYWwgbm9kZXMgaW50byB0aGUgZWRpdG9yIHVzaW5nIGRpZmZlcmVudCBzdHJhdGVnaWVzIGRlcGVuZGluZyBvblxuICogc29tZSBzaW1wbGUgc2VsZWN0aW9uLWJhc2VkIGhldXJpc3RpY3MuIElmIHlvdSdyZSBsb29raW5nIGZvciBhIGdlbmVyaWMgd2F5IHRvXG4gKiB0byBpbnNlcnQgbm9kZXMgaW50byB0aGUgZWRpdG9yIGF0IGEgc3BlY2lmaWMgc2VsZWN0aW9uIHBvaW50LCB5b3UgcHJvYmFibHkgd2FudFxuICoge0BsaW5rIGxleGljYWwuJGluc2VydE5vZGVzfVxuICpcbiAqIEBwYXJhbSBlZGl0b3IgTGV4aWNhbEVkaXRvciBpbnN0YW5jZSB0byBpbnNlcnQgdGhlIG5vZGVzIGludG8uXG4gKiBAcGFyYW0gbm9kZXMgVGhlIG5vZGVzIHRvIGluc2VydC5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gVGhlIHNlbGVjdGlvbiB0byBpbnNlcnQgdGhlIG5vZGVzIGludG8uXG4gKi9cblxuZnVuY3Rpb24gJGluc2VydEdlbmVyYXRlZE5vZGVzKGVkaXRvciwgbm9kZXMsIHNlbGVjdGlvbikge1xuICBjb25zdCBpc1NlbGVjdGlvbkluc2lkZU9mR3JpZCA9IGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZENlbGxOb2RlKG4pKSAhPT0gbnVsbCAmJiB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCksIG4gPT4gbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZShuKSkgIT09IG51bGw7XG5cbiAgaWYgKGlzU2VsZWN0aW9uSW5zaWRlT2ZHcmlkICYmIG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZE5vZGUobm9kZXNbMF0pKSB7XG4gICAgJG1lcmdlR3JpZE5vZGVzU3RyYXRlZ3kobm9kZXMsIHNlbGVjdGlvbiwgZmFsc2UsIGVkaXRvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgJGJhc2ljSW5zZXJ0U3RyYXRlZ3kobm9kZXMsIHNlbGVjdGlvbik7XG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gJGJhc2ljSW5zZXJ0U3RyYXRlZ3kobm9kZXMsIHNlbGVjdGlvbikge1xuICAvLyBXcmFwIHRleHQgYW5kIGlubGluZSBub2RlcyBpbiBwYXJhZ3JhcGggbm9kZXMgc28gd2UgaGF2ZSBhbGwgYmxvY2tzIGF0IHRoZSB0b3AtbGV2ZWxcbiAgY29uc3QgdG9wTGV2ZWxCbG9ja3MgPSBbXTtcbiAgbGV0IGN1cnJlbnRCbG9jayA9IG51bGw7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBjb25zdCBpc0xpbmVCcmVha05vZGUgPSBsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUobm9kZSk7XG5cbiAgICBpZiAoaXNMaW5lQnJlYWtOb2RlIHx8IGxleGljYWwuJGlzRGVjb3JhdG9yTm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCkgfHwgbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCkgfHwgbGV4aWNhbC4kaXNUZXh0Tm9kZShub2RlKSB8fCBub2RlLmlzUGFyZW50UmVxdWlyZWQoKSkge1xuICAgICAgaWYgKGN1cnJlbnRCbG9jayA9PT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50QmxvY2sgPSBub2RlLmNyZWF0ZVBhcmVudEVsZW1lbnROb2RlKCk7XG4gICAgICAgIHRvcExldmVsQmxvY2tzLnB1c2goY3VycmVudEJsb2NrKTsgLy8gSW4gdGhlIGNhc2Ugb2YgTGluZUJyZWFrTm9kZSwgd2UganVzdCBuZWVkIHRvXG4gICAgICAgIC8vIGFkZCBhbiBlbXB0eSBQYXJhZ3JhcGhOb2RlIHRvIHRoZSB0b3BMZXZlbEJsb2Nrcy5cblxuICAgICAgICBpZiAoaXNMaW5lQnJlYWtOb2RlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnRCbG9jayAhPT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50QmxvY2suYXBwZW5kKG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0b3BMZXZlbEJsb2Nrcy5wdXNoKG5vZGUpO1xuICAgICAgY3VycmVudEJsb2NrID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgc2VsZWN0aW9uLmluc2VydE5vZGVzKHRvcExldmVsQmxvY2tzKTtcbiAgfSBlbHNlIGlmIChsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgLy8gSWYgdGhlcmUncyBhbiBhY3RpdmUgZ3JpZCBzZWxlY3Rpb24gYW5kIGEgbm9uIGdyaWQgaXMgcGFzdGVkLCBhZGQgdG8gdGhlIGFuY2hvci5cbiAgICBjb25zdCBhbmNob3JDZWxsID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG5cbiAgICBpZiAoIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkQ2VsbE5vZGUoYW5jaG9yQ2VsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIEdyaWQgQ2VsbCBpbiBHcmlkIFNlbGVjdGlvbmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFuY2hvckNlbGwuYXBwZW5kKC4uLnRvcExldmVsQmxvY2tzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiAkbWVyZ2VHcmlkTm9kZXNTdHJhdGVneShub2Rlcywgc2VsZWN0aW9uLCBpc0Zyb21MZXhpY2FsLCBlZGl0b3IpIHtcbiAgaWYgKG5vZGVzLmxlbmd0aCAhPT0gMSB8fCAhbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWROb2RlKG5vZGVzWzBdKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGAkbWVyZ2VHcmlkTm9kZXNTdHJhdGVneTogRXhwZWN0ZWQgR3JpZCBpbnNlcnRpb24uYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbmV3R3JpZCA9IG5vZGVzWzBdO1xuICBjb25zdCBuZXdHcmlkUm93cyA9IG5ld0dyaWQuZ2V0Q2hpbGRyZW4oKTtcbiAgY29uc3QgbmV3Q29sdW1uQ291bnQgPSBuZXdHcmlkLmdldEZpcnN0Q2hpbGRPclRocm93KCkuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gIGNvbnN0IG5ld1Jvd0NvdW50ID0gbmV3R3JpZC5nZXRDaGlsZHJlblNpemUoKTtcbiAgY29uc3QgZ3JpZENlbGxOb2RlID0gdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZENlbGxOb2RlKG4pKTtcbiAgY29uc3QgZ3JpZFJvd05vZGUgPSBncmlkQ2VsbE5vZGUgJiYgdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChncmlkQ2VsbE5vZGUsIG4gPT4gbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlKG4pKTtcbiAgY29uc3QgZ3JpZE5vZGUgPSBncmlkUm93Tm9kZSAmJiB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KGdyaWRSb3dOb2RlLCBuID0+IGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkTm9kZShuKSk7XG5cbiAgaWYgKCFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZENlbGxOb2RlKGdyaWRDZWxsTm9kZSkgfHwgIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkUm93Tm9kZShncmlkUm93Tm9kZSkgfHwgIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkTm9kZShncmlkTm9kZSkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgJG1lcmdlR3JpZE5vZGVzU3RyYXRlZ3k6IEV4cGVjdGVkIHNlbGVjdGlvbiB0byBiZSBpbnNpZGUgb2YgYSBHcmlkLmApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0YXJ0WSA9IGdyaWRSb3dOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gIGNvbnN0IHN0b3BZID0gTWF0aC5taW4oZ3JpZE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgLSAxLCBzdGFydFkgKyBuZXdSb3dDb3VudCAtIDEpO1xuICBjb25zdCBzdGFydFggPSBncmlkQ2VsbE5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgY29uc3Qgc3RvcFggPSBNYXRoLm1pbihncmlkUm93Tm9kZS5nZXRDaGlsZHJlblNpemUoKSAtIDEsIHN0YXJ0WCArIG5ld0NvbHVtbkNvdW50IC0gMSk7XG4gIGNvbnN0IGZyb21YID0gTWF0aC5taW4oc3RhcnRYLCBzdG9wWCk7XG4gIGNvbnN0IGZyb21ZID0gTWF0aC5taW4oc3RhcnRZLCBzdG9wWSk7XG4gIGNvbnN0IHRvWCA9IE1hdGgubWF4KHN0YXJ0WCwgc3RvcFgpO1xuICBjb25zdCB0b1kgPSBNYXRoLm1heChzdGFydFksIHN0b3BZKTtcbiAgY29uc3QgZ3JpZFJvd05vZGVzID0gZ3JpZE5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgbGV0IG5ld1Jvd0lkeCA9IDA7XG4gIGxldCBuZXdBbmNob3JDZWxsS2V5O1xuICBsZXQgbmV3Rm9jdXNDZWxsS2V5O1xuXG4gIGZvciAobGV0IHIgPSBmcm9tWTsgciA8PSB0b1k7IHIrKykge1xuICAgIGNvbnN0IGN1cnJlbnRHcmlkUm93Tm9kZSA9IGdyaWRSb3dOb2Rlc1tyXTtcblxuICAgIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlKGN1cnJlbnRHcmlkUm93Tm9kZSkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYGdldE5vZGVzOiBleHBlY3RlZCB0byBmaW5kIEdyaWRSb3dOb2RlYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbmV3R3JpZFJvd05vZGUgPSBuZXdHcmlkUm93c1tuZXdSb3dJZHhdO1xuXG4gICAgaWYgKCFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFJvd05vZGUobmV3R3JpZFJvd05vZGUpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBnZXROb2RlczogZXhwZWN0ZWQgdG8gZmluZCBHcmlkUm93Tm9kZWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGdyaWRDZWxsTm9kZXMgPSBjdXJyZW50R3JpZFJvd05vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjb25zdCBuZXdHcmlkQ2VsbE5vZGVzID0gbmV3R3JpZFJvd05vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICBsZXQgbmV3Q29sdW1uSWR4ID0gMDtcblxuICAgIGZvciAobGV0IGMgPSBmcm9tWDsgYyA8PSB0b1g7IGMrKykge1xuICAgICAgY29uc3QgY3VycmVudEdyaWRDZWxsTm9kZSA9IGdyaWRDZWxsTm9kZXNbY107XG5cbiAgICAgIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZShjdXJyZW50R3JpZENlbGxOb2RlKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYGdldE5vZGVzOiBleHBlY3RlZCB0byBmaW5kIEdyaWRDZWxsTm9kZWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0dyaWRDZWxsTm9kZSA9IG5ld0dyaWRDZWxsTm9kZXNbbmV3Q29sdW1uSWR4XTtcblxuICAgICAgaWYgKCFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZENlbGxOb2RlKG5ld0dyaWRDZWxsTm9kZSkpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKGBnZXROb2RlczogZXhwZWN0ZWQgdG8gZmluZCBHcmlkQ2VsbE5vZGVgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAociA9PT0gZnJvbVkgJiYgYyA9PT0gZnJvbVgpIHtcbiAgICAgICAgbmV3QW5jaG9yQ2VsbEtleSA9IGN1cnJlbnRHcmlkQ2VsbE5vZGUuZ2V0S2V5KCk7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IHRvWSAmJiBjID09PSB0b1gpIHtcbiAgICAgICAgbmV3Rm9jdXNDZWxsS2V5ID0gY3VycmVudEdyaWRDZWxsTm9kZS5nZXRLZXkoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3JpZ2luYWxDaGlsZHJlbiA9IGN1cnJlbnRHcmlkQ2VsbE5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIG5ld0dyaWRDZWxsTm9kZS5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhOb2RlID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICAgIHBhcmFncmFwaE5vZGUuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICBjdXJyZW50R3JpZENlbGxOb2RlLmFwcGVuZChjaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudEdyaWRDZWxsTm9kZS5hcHBlbmQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9yaWdpbmFsQ2hpbGRyZW4uZm9yRWFjaChuID0+IG4ucmVtb3ZlKCkpO1xuICAgICAgbmV3Q29sdW1uSWR4Kys7XG4gICAgfVxuXG4gICAgbmV3Um93SWR4Kys7XG4gIH1cblxuICBpZiAobmV3QW5jaG9yQ2VsbEtleSAmJiBuZXdGb2N1c0NlbGxLZXkpIHtcbiAgICBjb25zdCBuZXdHcmlkU2VsZWN0aW9uID0gbGV4aWNhbC5ERVBSRUNBVEVEXyRjcmVhdGVHcmlkU2VsZWN0aW9uKCk7XG4gICAgbmV3R3JpZFNlbGVjdGlvbi5zZXQoZ3JpZE5vZGUuZ2V0S2V5KCksIG5ld0FuY2hvckNlbGxLZXksIG5ld0ZvY3VzQ2VsbEtleSk7XG4gICAgbGV4aWNhbC4kc2V0U2VsZWN0aW9uKG5ld0dyaWRTZWxlY3Rpb24pO1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5TRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhwb3J0Tm9kZVRvSlNPTihub2RlKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gbm9kZS5leHBvcnRKU09OKCk7XG4gIGNvbnN0IG5vZGVDbGFzcyA9IG5vZGUuY29uc3RydWN0b3I7IC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETyBSZXBsYWNlIENsYXNzIHV0aWxpdHkgdHlwZSB3aXRoIEluc3RhbmNlVHlwZVxuXG4gIGlmIChzZXJpYWxpemVkTm9kZS50eXBlICE9PSBub2RlQ2xhc3MuZ2V0VHlwZSgpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuZXhwb3J0SlNPTigpLmApO1xuICAgIH1cbiAgfSAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gUmVwbGFjZSBDbGFzcyB1dGlsaXR5IHR5cGUgd2l0aCBJbnN0YW5jZVR5cGVcblxuXG4gIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZHJlbiA9IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuO1xuXG4gIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNlcmlhbGl6ZWRDaGlsZHJlbikpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGlzIGFuIGVsZW1lbnQgYnV0IC5leHBvcnRKU09OKCkgZG9lcyBub3QgaGF2ZSBhIGNoaWxkcmVuIGFycmF5LmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZXJpYWxpemVkTm9kZTtcbn1cblxuZnVuY3Rpb24gJGFwcGVuZE5vZGVzVG9KU09OKGVkaXRvciwgc2VsZWN0aW9uJDEsIGN1cnJlbnROb2RlLCB0YXJnZXRBcnJheSA9IFtdKSB7XG4gIGxldCBzaG91bGRJbmNsdWRlID0gc2VsZWN0aW9uJDEgIT0gbnVsbCA/IGN1cnJlbnROb2RlLmlzU2VsZWN0ZWQoc2VsZWN0aW9uJDEpIDogdHJ1ZTtcbiAgY29uc3Qgc2hvdWxkRXhjbHVkZSA9IGxleGljYWwuJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmIGN1cnJlbnROb2RlLmV4Y2x1ZGVGcm9tQ29weSgnaHRtbCcpO1xuICBsZXQgdGFyZ2V0ID0gY3VycmVudE5vZGU7XG5cbiAgaWYgKHNlbGVjdGlvbiQxICE9PSBudWxsKSB7XG4gICAgbGV0IGNsb25lID0gc2VsZWN0aW9uLiRjbG9uZVdpdGhQcm9wZXJ0aWVzKGN1cnJlbnROb2RlKTtcbiAgICBjbG9uZSA9IGxleGljYWwuJGlzVGV4dE5vZGUoY2xvbmUpICYmIHNlbGVjdGlvbiQxICE9IG51bGwgPyBzZWxlY3Rpb24uJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQoc2VsZWN0aW9uJDEsIGNsb25lKSA6IGNsb25lO1xuICAgIHRhcmdldCA9IGNsb25lO1xuICB9XG5cbiAgY29uc3QgY2hpbGRyZW4gPSBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKHRhcmdldCkgPyB0YXJnZXQuZ2V0Q2hpbGRyZW4oKSA6IFtdO1xuICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IGV4cG9ydE5vZGVUb0pTT04odGFyZ2V0KTsgLy8gVE9ETzogVGV4dE5vZGUgY2FsbHMgZ2V0VGV4dENvbnRlbnQoKSAoTk9UIG5vZGUuX190ZXh0KSB3aXRoaW4gaXQncyBleHBvcnRKU09OIG1ldGhvZFxuICAvLyB3aGljaCB1c2VzIGdldExhdGVzdCgpIHRvIGdldCB0aGUgdGV4dCBmcm9tIHRoZSBvcmlnaW5hbCBub2RlIHdpdGggdGhlIHNhbWUga2V5LlxuICAvLyBUaGlzIGlzIGEgZGVlcGVyIGlzc3VlIHdpdGggdGhlIHdvcmQgXCJjbG9uZVwiIGhlcmUsIGl0J3Mgc3RpbGwgYSByZWZlcmVuY2UgdG8gdGhlXG4gIC8vIHNhbWUgbm9kZSBhcyBmYXIgYXMgdGhlIExleGljYWxFZGl0b3IgaXMgY29uY2VybmVkIHNpbmNlIGl0IHNoYXJlcyBhIGtleS5cbiAgLy8gV2UgbmVlZCBhIHdheSB0byBjcmVhdGUgYSBjbG9uZSBvZiBhIE5vZGUgaW4gbWVtb3J5IHdpdGggaXQncyBvd24ga2V5LCBidXRcbiAgLy8gdW50aWwgdGhlbiB0aGlzIGhhY2sgd2lsbCB3b3JrIGZvciB0aGUgc2VsZWN0ZWQgdGV4dCBleHRyYWN0IHVzZSBjYXNlLlxuXG4gIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKHRhcmdldCkpIHtcbiAgICBjb25zdCB0ZXh0ID0gdGFyZ2V0Ll9fdGV4dDsgLy8gSWYgYW4gdW5jb2xsYXBzZWQgc2VsZWN0aW9uIGVuZHMgb3Igc3RhcnRzIGF0IHRoZSBlbmQgb2YgYSBsaW5lIG9mIHNwZWNpYWxpemVkLFxuICAgIC8vIFRleHROb2Rlcywgc3VjaCBhcyBjb2RlIHRva2Vucywgd2Ugd2lsbCBnZXQgYSAnYmxhbmsnIFRleHROb2RlIGhlcmUsIGkuZS4sIG9uZVxuICAgIC8vIHdpdGggdGV4dCBvZiBsZW5ndGggMC4gV2UgZG9uJ3Qgd2FudCB0aGlzLCBpdCBtYWtlcyBhIGNvbmZ1c2luZyBtZXNzLiBSZXNldCFcblxuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHNlcmlhbGl6ZWROb2RlLnRleHQgPSB0ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRJbmNsdWRlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IHNob3VsZEluY2x1ZGVDaGlsZCA9ICRhcHBlbmROb2Rlc1RvSlNPTihlZGl0b3IsIHNlbGVjdGlvbiQxLCBjaGlsZE5vZGUsIHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuKTtcblxuICAgIGlmICghc2hvdWxkSW5jbHVkZSAmJiBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBzaG91bGRJbmNsdWRlQ2hpbGQgJiYgY3VycmVudE5vZGUuZXh0cmFjdFdpdGhDaGlsZChjaGlsZE5vZGUsIHNlbGVjdGlvbiQxLCAnY2xvbmUnKSkge1xuICAgICAgc2hvdWxkSW5jbHVkZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNob3VsZEluY2x1ZGUgJiYgIXNob3VsZEV4Y2x1ZGUpIHtcbiAgICB0YXJnZXRBcnJheS5wdXNoKHNlcmlhbGl6ZWROb2RlKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VyaWFsaXplZE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZE5vZGUgPSBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIHRhcmdldEFycmF5LnB1c2goc2VyaWFsaXplZENoaWxkTm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNob3VsZEluY2x1ZGU7XG59IC8vIFRPRE8gd2h5ICQgZnVuY3Rpb24gd2l0aCBFZGl0b3IgaW5zdGFuY2U/XG5cbi8qKlxuICogR2V0cyB0aGUgTGV4aWNhbCBKU09OIG9mIHRoZSBub2RlcyBpbnNpZGUgdGhlIHByb3ZpZGVkIFNlbGVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yIExleGljYWxFZGl0b3IgdG8gZ2V0IHRoZSBKU09OIGNvbnRlbnQgZnJvbS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gU2VsZWN0aW9uIHRvIGdldCB0aGUgSlNPTiBjb250ZW50IGZyb20uXG4gKiBAcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZWRpdG9yIG5hbWVzcGFjZSBhbmQgYSBsaXN0IG9mIHNlcmlhbGl6YWJsZSBub2RlcyBhcyBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cblxuXG5mdW5jdGlvbiAkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgY29uc3Qgcm9vdCA9IGxleGljYWwuJGdldFJvb3QoKTtcbiAgY29uc3QgdG9wTGV2ZWxDaGlsZHJlbiA9IHJvb3QuZ2V0Q2hpbGRyZW4oKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvcExldmVsQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b3BMZXZlbE5vZGUgPSB0b3BMZXZlbENoaWxkcmVuW2ldO1xuICAgICRhcHBlbmROb2Rlc1RvSlNPTihlZGl0b3IsIHNlbGVjdGlvbiwgdG9wTGV2ZWxOb2RlLCBub2Rlcyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWVzcGFjZTogZWRpdG9yLl9jb25maWcubmFtZXNwYWNlLFxuICAgIG5vZGVzXG4gIH07XG59XG4vKipcbiAqIFRoaXMgbWV0aG9kIHRha2VzIGFuIGFycmF5IG9mIG9iamVjdHMgY29uZm9ybWluZyB0byB0aGUgQmFzZVNlcmFsaXplZE5vZGUgaW50ZXJmYWNlIGFuZCByZXR1cm5zXG4gKiBhbiBBcnJheSBjb250YWluaW5nIGluc3RhbmNlcyBvZiB0aGUgY29ycmVzcG9uZGluZyBMZXhpY2FsTm9kZSBjbGFzc2VzIHJlZ2lzdGVyZWQgb24gdGhlIGVkaXRvci5cbiAqIE5vcm1hbGx5LCB5b3UnZCBnZXQgYW4gQXJyYXkgb2YgQmFzZVNlcmlhbGl6ZWQgbm9kZXMgZnJvbSB7QGxpbmsgJGdlbmVyYXRlSlNPTkZyb21TZWxlY3RlZE5vZGVzfVxuICpcbiAqIEBwYXJhbSBzZXJpYWxpemVkTm9kZXMgYW4gQXJyYXkgb2Ygb2JqZWN0cyBjb25mb3JtaW5nIHRvIHRoZSBCYXNlU2VyaWFsaXplZE5vZGUgaW50ZXJmYWNlLlxuICogQHJldHVybnMgYW4gQXJyYXkgb2YgTGV4aWNhbCBOb2RlIG9iamVjdHMuXG4gKi9cblxuZnVuY3Rpb24gJGdlbmVyYXRlTm9kZXNGcm9tU2VyaWFsaXplZE5vZGVzKHNlcmlhbGl6ZWROb2Rlcykge1xuICBjb25zdCBub2RlcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VyaWFsaXplZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBzZXJpYWxpemVkTm9kZXNbaV07XG4gICAgY29uc3Qgbm9kZSA9IGxleGljYWwuJHBhcnNlU2VyaWFsaXplZE5vZGUoc2VyaWFsaXplZE5vZGUpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIHNlbGVjdGlvbi4kYWRkTm9kZVN0eWxlKG5vZGUpO1xuICAgIH1cblxuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZXM7XG59XG5jb25zdCBFVkVOVF9MQVRFTkNZID0gNTA7XG5sZXQgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gbnVsbDsgLy8gVE9ETyBjdXN0b20gc2VsZWN0aW9uXG4vLyBUT0RPIHBvdGVudGlhbGx5IGhhdmUgYSBub2RlIGN1c3RvbWl6YWJsZSB2ZXJzaW9uIGZvciBwbGFpbiB0ZXh0XG5cbi8qKlxuICogQ29waWVzIHRoZSBjb250ZW50IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0byB0aGUgY2xpcGJvYXJkIGluXG4gKiB0ZXh0L3BsYWluLCB0ZXh0L2h0bWwsIGFuZCBhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yIChMZXhpY2FsIEpTT04pXG4gKiBmb3JtYXRzLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgdGhlIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gY29weSBjb250ZW50IGZyb21cbiAqIEBwYXJhbSBldmVudCB0aGUgbmF0aXZlIGJyb3dzZXIgQ2xpcGJvYXJkRXZlbnQgdG8gYWRkIHRoZSBjb250ZW50IHRvLlxuICogQHJldHVybnNcbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQoZWRpdG9yLCBldmVudCkge1xuICBpZiAoY2xpcGJvYXJkRXZlbnRUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgLy8gUHJldmVudCB3ZWlyZCByYWNlIGNvbmRpdGlvbnMgdGhhdCBjYW4gaGFwcGVuIHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBydW4gbXVsdGlwbGUgdGltZXNcbiAgICAvLyBzeW5jaHJvbm91c2x5LiBJbiB0aGUgZnV0dXJlLCB3ZSBjYW4gZG8gYmV0dGVyLCB3ZSBjYW4gY2FuY2VsL292ZXJyaWRlIHRoZSBwcmV2aW91c2x5IHJ1bm5pbmcgam9iLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChldmVudCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSgkY29weVRvQ2xpcGJvYXJkRXZlbnQoZWRpdG9yLCBldmVudCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICBjb25zdCB3aW5kb3dEb2N1bWVudCA9IGVkaXRvci5fd2luZG93ID09IG51bGwgPyB3aW5kb3cuZG9jdW1lbnQgOiBlZGl0b3IuX3dpbmRvdy5kb2N1bWVudDtcbiAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcblxuICBpZiAocm9vdEVsZW1lbnQgPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZWxlbWVudCA9IHdpbmRvd0RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOiBmaXhlZDsgdG9wOiAtMTAwMHB4Oyc7XG4gIGVsZW1lbnQuYXBwZW5kKHdpbmRvd0RvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcjJykpO1xuICByb290RWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KGVsZW1lbnQsIDApO1xuICByYW5nZS5zZXRFbmQoZWxlbWVudCwgMSk7XG4gIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgZG9tU2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZW1vdmVMaXN0ZW5lciA9IGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5DT1BZX0NPTU1BTkQsIHNlY29uZEV2ZW50ID0+IHtcbiAgICAgIGlmICh1dGlscy5vYmplY3RLbGFzc0VxdWFscyhzZWNvbmRFdmVudCwgQ2xpcGJvYXJkRXZlbnQpKSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG5cbiAgICAgICAgaWYgKGNsaXBib2FyZEV2ZW50VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoY2xpcGJvYXJkRXZlbnRUaW1lb3V0KTtcbiAgICAgICAgICBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZSgkY29weVRvQ2xpcGJvYXJkRXZlbnQoZWRpdG9yLCBzZWNvbmRFdmVudCkpO1xuICAgICAgfSAvLyBCbG9jayB0aGUgZW50aXJlIGNvcHkgZmxvdyB3aGlsZSB3ZSB3YWl0IGZvciB0aGUgbmV4dCBDbGlwYm9hcmRFdmVudFxuXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCk7IC8vIElmIHRoZSBhYm92ZSBoYWNrIGV4ZWNDb21tYW5kIGhhY2sgd29ya3MsIHRoaXMgdGltZW91dCBjb2RlIHNob3VsZCBuZXZlciBmaXJlLiBPdGhlcndpc2UsXG4gICAgLy8gdGhlIGxpc3RlbmVyIHdpbGwgYmUgcXVpY2tseSBmcmVlZCBzbyB0aGF0IHRoZSB1c2VyIGNhbiByZXVzZSBpdCBhZ2FpblxuXG4gICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgIGNsaXBib2FyZEV2ZW50VGltZW91dCA9IG51bGw7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICB9LCBFVkVOVF9MQVRFTkNZKTtcbiAgICB3aW5kb3dEb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gIH0pO1xufSAvLyBUT0RPIHNob3VsZG4ndCBwYXNzIGVkaXRvciAocGFzcyBuYW1lc3BhY2UgZGlyZWN0bHkpXG5cbmZ1bmN0aW9uICRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIGV2ZW50KSB7XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG5cbiAgaWYgKCFkb21TZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBhbmNob3JET00gPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgY29uc3QgZm9jdXNET00gPSBkb21TZWxlY3Rpb24uZm9jdXNOb2RlO1xuXG4gIGlmIChhbmNob3JET00gIT09IG51bGwgJiYgZm9jdXNET00gIT09IG51bGwgJiYgIWxleGljYWwuaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET00sIGZvY3VzRE9NKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGNvbnN0IGNsaXBib2FyZERhdGEgPSBldmVudC5jbGlwYm9hcmREYXRhO1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoY2xpcGJvYXJkRGF0YSA9PT0gbnVsbCB8fCBzZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBodG1sU3RyaW5nID0gJGdldEh0bWxDb250ZW50KGVkaXRvcik7XG4gIGNvbnN0IGxleGljYWxTdHJpbmcgPSAkZ2V0TGV4aWNhbENvbnRlbnQoZWRpdG9yKTtcbiAgbGV0IHBsYWluU3RyaW5nID0gJyc7XG5cbiAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIHBsYWluU3RyaW5nID0gc2VsZWN0aW9uLmdldFRleHRDb250ZW50KCk7XG4gIH1cblxuICBpZiAoaHRtbFN0cmluZyAhPT0gbnVsbCkge1xuICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9odG1sJywgaHRtbFN0cmluZyk7XG4gIH1cblxuICBpZiAobGV4aWNhbFN0cmluZyAhPT0gbnVsbCkge1xuICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YSgnYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvcicsIGxleGljYWxTdHJpbmcpO1xuICB9XG5cbiAgY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgcGxhaW5TdHJpbmcpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0cy4kZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXMgPSAkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXM7XG5leHBvcnRzLiRnZW5lcmF0ZU5vZGVzRnJvbVNlcmlhbGl6ZWROb2RlcyA9ICRnZW5lcmF0ZU5vZGVzRnJvbVNlcmlhbGl6ZWROb2RlcztcbmV4cG9ydHMuJGdldEh0bWxDb250ZW50ID0gJGdldEh0bWxDb250ZW50O1xuZXhwb3J0cy4kZ2V0TGV4aWNhbENvbnRlbnQgPSAkZ2V0TGV4aWNhbENvbnRlbnQ7XG5leHBvcnRzLiRpbnNlcnREYXRhVHJhbnNmZXJGb3JQbGFpblRleHQgPSAkaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUGxhaW5UZXh0O1xuZXhwb3J0cy4kaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUmljaFRleHQgPSAkaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUmljaFRleHQ7XG5leHBvcnRzLiRpbnNlcnRHZW5lcmF0ZWROb2RlcyA9ICRpbnNlcnRHZW5lcmF0ZWROb2RlcztcbmV4cG9ydHMuY29weVRvQ2xpcGJvYXJkID0gY29weVRvQ2xpcGJvYXJkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/clipboard/LexicalClipboard.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalClipboard =  true ? __webpack_require__(/*! ./LexicalClipboard.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.js\") : 0\nmodule.exports = LexicalClipboard;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jbGlwYm9hcmQvTGV4aWNhbENsaXBib2FyZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLHlCQUF5QixLQUFzQyxHQUFHLG1CQUFPLENBQUMsZ0hBQTJCLElBQUksQ0FBcUM7QUFDOUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2NsaXBib2FyZC9MZXhpY2FsQ2xpcGJvYXJkLmpzPzcxYzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxDbGlwYm9hcmQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbENsaXBib2FyZC5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbENsaXBib2FyZC5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbENsaXBib2FyZDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/clipboard/LexicalClipboard.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/code/LexicalCode.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/code/LexicalCode.dev.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar Prism = __webpack_require__(/*! prismjs */ \"(app-pages-browser)/./node_modules/prismjs/prism.js\");\n__webpack_require__(/*! prismjs/components/prism-clike */ \"(app-pages-browser)/./node_modules/prismjs/components/prism-clike.js\");\n__webpack_require__(/*! prismjs/components/prism-javascript */ \"(app-pages-browser)/./node_modules/prismjs/components/prism-javascript.js\");\n__webpack_require__(/*! prismjs/components/prism-markup */ \"(app-pages-browser)/./node_modules/prismjs/components/prism-markup.js\");\n__webpack_require__(/*! prismjs/components/prism-markdown */ \"(app-pages-browser)/./node_modules/prismjs/components/prism-markdown.js\");\n__webpack_require__(/*! prismjs/components/prism-c */ \"(app-pages-browser)/./node_modules/prismjs/components/prism-c.js\");\n__webpack_require__(/*! prismjs/components/prism-css */ \"(app-pages-browser)/./node_modules/prismjs/components/prism-css.js\");\n__webpack_require__(/*! prismjs/components/prism-objectivec */ \"(app-pages-browser)/./node_modules/prismjs/components/prism-objectivec.js\");\n__webpack_require__(/*! prismjs/components/prism-sql */ \"(app-pages-browser)/./node_modules/prismjs/components/prism-sql.js\");\n__webpack_require__(/*! prismjs/components/prism-python */ \"(app-pages-browser)/./node_modules/prismjs/components/prism-python.js\");\n__webpack_require__(/*! prismjs/components/prism-rust */ \"(app-pages-browser)/./node_modules/prismjs/components/prism-rust.js\");\n__webpack_require__(/*! prismjs/components/prism-swift */ \"(app-pages-browser)/./node_modules/prismjs/components/prism-swift.js\");\n__webpack_require__(/*! prismjs/components/prism-typescript */ \"(app-pages-browser)/./node_modules/prismjs/components/prism-typescript.js\");\n__webpack_require__(/*! prismjs/components/prism-java */ \"(app-pages-browser)/./node_modules/prismjs/components/prism-java.js\");\n__webpack_require__(/*! prismjs/components/prism-cpp */ \"(app-pages-browser)/./node_modules/prismjs/components/prism-cpp.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mapToPrismLanguage = language => {\n  // eslint-disable-next-line no-prototype-builtins\n  return language != null && Prism.languages.hasOwnProperty(language) ? language : undefined;\n};\n\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if (utils.isHTMLElement(child) && child.tagName === tagName) {\n      return true;\n    }\n\n    hasChildDOMNodeTag(child, tagName);\n  }\n\n  return false;\n}\n\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n/** @noInheritDoc */\n\nclass CodeNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'code';\n  }\n\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n\n  constructor(language, key) {\n    super(key);\n    this.__language = mapToPrismLanguage(language);\n  } // View\n\n\n  createDOM(config) {\n    const element = document.createElement('code');\n    utils.addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n    }\n\n    return false;\n  }\n\n  exportDOM() {\n    const element = document.createElement('pre');\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: node => ({\n        conversion: convertDivElement,\n        priority: 1\n      }),\n      pre: node => ({\n        conversion: convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node; // domNode is a <table> since we matched it by nodeName\n\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: convertTableElement,\n            priority: 3\n          };\n        }\n\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n\n        if (isGitHubCodeCell(td)) {\n          return {\n            conversion: convertTableCellElement,\n            priority: 3\n          };\n        }\n\n        if (table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n\n        return null;\n      }\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createCodeNode(serializedNode.language);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      language: this.getLanguage(),\n      type: 'code',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = lexical.$createParagraphNode();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    } // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n\n\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const firstPoint = anchor.isBefore(focus) ? anchor : focus;\n    const firstSelectionNode = firstPoint.getNode();\n\n    if ($isCodeHighlightNode(firstSelectionNode) || lexical.$isTabNode(firstSelectionNode)) {\n      let node = getFirstCodeNodeOfLine(firstSelectionNode);\n      const insertNodes = []; // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        if (lexical.$isTabNode(node)) {\n          insertNodes.push(lexical.$createTabNode());\n          node = node.getNextSibling();\n        } else if ($isCodeHighlightNode(node)) {\n          let spaces = 0;\n          const text = node.getTextContent();\n          const textSize = node.getTextContentSize();\n\n          for (; spaces < textSize && text[spaces] === ' '; spaces++);\n\n          if (spaces !== 0) {\n            insertNodes.push($createCodeHighlightNode(' '.repeat(spaces)));\n          }\n\n          if (spaces !== textSize) {\n            break;\n          }\n\n          node = node.getNextSibling();\n        } else {\n          break;\n        }\n      }\n\n      if (insertNodes.length > 0) {\n        selection.insertNodes([lexical.$createLineBreakNode(), ...insertNodes]);\n        return insertNodes[insertNodes.length - 1];\n      }\n    }\n\n    return null;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = mapToPrismLanguage(language);\n  }\n\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n\n}\nfunction $createCodeNode(language) {\n  return lexical.$applyNodeReplacement(new CodeNode(language));\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\n\nfunction convertPreElement(domNode) {\n  let language;\n\n  if (utils.isHTMLElement(domNode)) {\n    language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);\n  }\n\n  return {\n    node: $createCodeNode(language)\n  };\n}\n\nfunction convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n\n  return {\n    after: childLexicalNodes => {\n      const domParent = domNode.parentNode;\n\n      if (domParent != null && domNode !== domParent.lastChild) {\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n\n      return childLexicalNodes;\n    },\n    node: isCode ? $createCodeNode() : null\n  };\n}\n\nfunction convertTableElement() {\n  return {\n    node: $createCodeNode()\n  };\n}\n\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\n\nfunction convertTableCellElement(domNode) {\n  // domNode is a <td> since we matched it by nodeName\n  const cell = domNode;\n  return {\n    after: childLexicalNodes => {\n      if (cell.parentNode && cell.parentNode.nextSibling) {\n        // Append newline between code lines\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n\n      return childLexicalNodes;\n    },\n    node: null\n  };\n}\n\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\n\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n\n    parent = parent.parentElement;\n  }\n\n  return false;\n}\n\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\n\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(Prism.languages).filter( // Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism.languages[language] !== 'function').sort();\n/** @noInheritDoc */\n\nclass CodeHighlightNode extends lexical.TextNode {\n  /** @internal */\n  constructor(text, highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n\n  static getType() {\n    return 'code-highlight';\n  }\n\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    utils.addClassNamesToElement(element, className);\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        utils.removeClassNamesFromElement(dom, prevClassName);\n      }\n\n      if (nextClassName) {\n        utils.addClassNamesToElement(dom, nextClassName);\n      }\n    }\n\n    return update;\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      highlightType: this.getHighlightType(),\n      type: 'code-highlight',\n      version: 1\n    };\n  } // Prevent formatting (bold, underline, etc)\n\n\n  setFormat(format) {\n    return this;\n  }\n\n  isParentRequired() {\n    return true;\n  }\n\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n\n}\n\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\n\nfunction $createCodeHighlightNode(text, highlightType) {\n  return lexical.$applyNodeReplacement(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction getFirstCodeNodeOfLine(anchor) {\n  let previousNode = anchor;\n  let node = anchor;\n\n  while ($isCodeHighlightNode(node) || lexical.$isTabNode(node)) {\n    previousNode = node;\n    node = node.getPreviousSibling();\n  }\n\n  return previousNode;\n}\nfunction getLastCodeNodeOfLine(anchor) {\n  let nextNode = anchor;\n  let node = anchor;\n\n  while ($isCodeHighlightNode(node) || lexical.$isTabNode(node)) {\n    nextNode = node;\n    node = node.getNextSibling();\n  }\n\n  return nextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PrismTokenizer = {\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n\n  tokenize(code, language) {\n    return Prism.tokenize(code, Prism.languages[language || ''] || Prism.languages[this.defaultLanguage]);\n  }\n\n};\nfunction getStartOfCodeInLine(anchor, offset) {\n  let last = null;\n  let lastNonBlank = null;\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent(); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    if (nodeOffset === 0) {\n      node = node.getPreviousSibling();\n\n      if (node === null) {\n        break;\n      }\n\n      if (!($isCodeHighlightNode(node) || lexical.$isTabNode(node) || lexical.$isLineBreakNode(node))) {\n        throw Error(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);\n      }\n\n      if (lexical.$isLineBreakNode(node)) {\n        last = {\n          node,\n          offset: 1\n        };\n        break;\n      }\n\n      nodeOffset = Math.max(0, node.getTextContentSize() - 1);\n      nodeTextContent = node.getTextContent();\n    } else {\n      nodeOffset--;\n    }\n\n    const character = nodeTextContent[nodeOffset];\n\n    if ($isCodeHighlightNode(node) && character !== ' ') {\n      lastNonBlank = {\n        node,\n        offset: nodeOffset\n      };\n    }\n  } // lastNonBlank !== null: anchor in the middle of code; move to line beginning\n\n\n  if (lastNonBlank !== null) {\n    return lastNonBlank;\n  } // Spaces, tabs or nothing ahead of anchor\n\n\n  let codeCharacterAtAnchorOffset = null;\n\n  if (offset < anchor.getTextContentSize()) {\n    if ($isCodeHighlightNode(anchor)) {\n      codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];\n    }\n  } else {\n    const nextSibling = anchor.getNextSibling();\n\n    if ($isCodeHighlightNode(nextSibling)) {\n      codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];\n    }\n  }\n\n  if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== ' ') {\n    // Borderline whitespace and code, move to line beginning\n    return last;\n  } else {\n    const nextNonBlank = findNextNonBlankInLine(anchor, offset);\n\n    if (nextNonBlank !== null) {\n      return nextNonBlank;\n    } else {\n      return last;\n    }\n  }\n}\n\nfunction findNextNonBlankInLine(anchor, offset) {\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  let nodeTextContentSize = anchor.getTextContentSize(); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {\n      node = node.getNextSibling();\n\n      if (node === null || lexical.$isLineBreakNode(node)) {\n        return null;\n      }\n\n      if ($isCodeHighlightNode(node)) {\n        nodeOffset = 0;\n        nodeTextContent = node.getTextContent();\n        nodeTextContentSize = node.getTextContentSize();\n      }\n    }\n\n    if ($isCodeHighlightNode(node)) {\n      if (nodeTextContent[nodeOffset] !== ' ') {\n        return {\n          node,\n          offset: nodeOffset\n        };\n      }\n\n      nodeOffset++;\n    }\n  }\n}\n\nfunction getEndOfCodeInLine(anchor) {\n  const lastNode = getLastCodeNodeOfLine(anchor);\n\n  if (!!lexical.$isLineBreakNode(lastNode)) {\n    throw Error(`Unexpected lineBreakNode in getEndOfCodeInLine`);\n  }\n\n  return lastNode;\n}\n\nfunction textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace(lexical.$createTextNode(node.__text));\n  }\n}\n\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n\n  if (codeElement === null) {\n    return;\n  }\n\n  const children = node.getChildren();\n  const childrenLength = children.length; // @ts-ignore: internal field\n\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  } // @ts-ignore:: internal field\n\n\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n\n  for (let i = 0; i < childrenLength; i++) {\n    if (lexical.$isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n\n  codeElement.setAttribute('data-gutter', gutter);\n} // Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\n\nconst nodesCurrentlyHighlighting = new Set();\n\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n\n  if (nodesCurrentlyHighlighting.has(nodeKey)) {\n    return;\n  }\n\n  nodesCurrentlyHighlighting.add(nodeKey); // When new code block inserted it might not have language selected\n\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  } // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual codehighlight node to be transformed again as it's already\n  // in its final state\n\n\n  editor.update(() => {\n    updateAndRetainSelection(nodeKey, () => {\n      const currentNode = lexical.$getNodeByKey(nodeKey);\n\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n\n      const code = currentNode.getTextContent();\n      const tokens = tokenizer.tokenize(code, currentNode.getLanguage() || tokenizer.defaultLanguage);\n      const highlightNodes = getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(nodeKey);\n    },\n    skipTransforms: true\n  });\n}\n\nfunction getHighlightNodes(tokens, type) {\n  const nodes = [];\n\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      const partials = token.split(/(\\n|\\t)/);\n      const partialsLength = partials.length;\n\n      for (let i = 0; i < partialsLength; i++) {\n        const part = partials[i];\n\n        if (part === '\\n' || part === '\\r\\n') {\n          nodes.push(lexical.$createLineBreakNode());\n        } else if (part === '\\t') {\n          nodes.push(lexical.$createTabNode());\n        } else if (part.length > 0) {\n          nodes.push($createCodeHighlightNode(part, type));\n        }\n      }\n    } else {\n      const {\n        content\n      } = token;\n\n      if (typeof content === 'string') {\n        nodes.push(...getHighlightNodes([content], token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...getHighlightNodes(content, token.type));\n      }\n    }\n  }\n\n  return nodes;\n} // Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\n\n\nfunction updateAndRetainSelection(nodeKey, updateFn) {\n  const node = lexical.$getNodeByKey(nodeKey);\n\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n\n  const selection = lexical.$getSelection(); // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n\n  if (!lexical.$isRangeSelection(selection)) {\n    updateFn();\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && lexical.$isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0; // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n\n  const hasChanges = updateFn();\n\n  if (!hasChanges) {\n    return;\n  } // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n\n\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  } // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n\n\n  node.getChildren().some(_node => {\n    const isText = lexical.$isTextNode(_node);\n\n    if (isText || lexical.$isLineBreakNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n\n        return true;\n      }\n\n      textOffset -= textContentSize;\n    }\n\n    return false;\n  });\n} // Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\n\n\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n\n    leadingMatch++;\n  }\n\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\n\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code higlight nodes, tabs and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || lexical.$isTabNode(nodeA) && lexical.$isTabNode(nodeB) || lexical.$isLineBreakNode(nodeA) && lexical.$isLineBreakNode(nodeB);\n}\n\nfunction $isSelectionInCode(selection) {\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n\n  const anchorNode = selection.anchor.getNode();\n  const focusNode = selection.focus.getNode();\n\n  if (anchorNode.is(focusNode) && $isCodeNode(anchorNode)) {\n    return true;\n  }\n\n  const anchorParent = anchorNode.getParent();\n  return $isCodeNode(anchorParent) && anchorParent.is(focusNode.getParent());\n}\n\nfunction $getCodeLines(selection) {\n  const nodes = selection.getNodes();\n  const lines = [[]];\n\n  if (nodes.length === 1 && $isCodeNode(nodes[0])) {\n    return lines;\n  }\n\n  let lastLine = lines[0];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (!($isCodeHighlightNode(node) || lexical.$isTabNode(node) || lexical.$isLineBreakNode(node))) {\n      throw Error(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);\n    }\n\n    if (lexical.$isLineBreakNode(node)) {\n      if (i !== 0 && lastLine.length > 0) {\n        lastLine = [];\n        lines.push(lastLine);\n      }\n    } else {\n      lastLine.push(node);\n    }\n  }\n\n  return lines;\n}\n\nfunction handleTab(shiftKey) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return null;\n  }\n\n  const indentOrOutdent = !shiftKey ? lexical.INDENT_CONTENT_COMMAND : lexical.OUTDENT_CONTENT_COMMAND;\n  const tabOrOutdent = !shiftKey ? lexical.INSERT_TAB_COMMAND : lexical.OUTDENT_CONTENT_COMMAND; // 1. If multiple lines selected: indent/outdent\n\n  const codeLines = $getCodeLines(selection);\n\n  if (codeLines.length > 1) {\n    return indentOrOutdent;\n  } // 2. If entire line selected: indent/outdent\n\n\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || lexical.$isTabNode(firstNode) || lexical.$isLineBreakNode(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or TabNode`);\n  }\n\n  if ($isCodeNode(firstNode)) {\n    return indentOrOutdent;\n  }\n\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n  const lastOfLine = getLastCodeNodeOfLine(firstNode);\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  let selectionFirst;\n  let selectionLast;\n\n  if (focus.isBefore(anchor)) {\n    selectionFirst = focus;\n    selectionLast = anchor;\n  } else {\n    selectionFirst = anchor;\n    selectionLast = focus;\n  }\n\n  if (firstOfLine !== null && lastOfLine !== null && selectionFirst.key === firstOfLine.getKey() && selectionFirst.offset === 0 && selectionLast.key === lastOfLine.getKey() && selectionLast.offset === lastOfLine.getTextContentSize()) {\n    return indentOrOutdent;\n  } // 3. Else: tab/outdent\n\n\n  return tabOrOutdent;\n}\n\nfunction handleMultilineIndent(type) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return false;\n  }\n\n  const codeLines = $getCodeLines(selection);\n  const codeLinesLength = codeLines.length; // Multiple lines selection\n\n  if (codeLines.length > 1) {\n    for (let i = 0; i < codeLinesLength; i++) {\n      const line = codeLines[i];\n\n      if (line.length > 0) {\n        let firstOfLine = line[0]; // First and last lines might not be complete\n\n        if (i === 0) {\n          firstOfLine = getFirstCodeNodeOfLine(firstOfLine);\n        }\n\n        if (firstOfLine !== null) {\n          if (type === lexical.INDENT_CONTENT_COMMAND) {\n            firstOfLine.insertBefore(lexical.$createTabNode());\n          } else if (lexical.$isTabNode(firstOfLine)) {\n            firstOfLine.remove();\n          }\n        }\n      }\n    }\n\n    return true;\n  } // Just one line\n\n\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || lexical.$isTabNode(firstNode) || lexical.$isLineBreakNode(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or CodeTabNode`);\n  }\n\n  if ($isCodeNode(firstNode)) {\n    // CodeNode is empty\n    if (type === lexical.INDENT_CONTENT_COMMAND) {\n      selection.insertNodes([lexical.$createTabNode()]);\n    }\n\n    return true;\n  }\n\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n\n  if (!(firstOfLine !== null)) {\n    throw Error(`Expected getFirstCodeNodeOfLine to return a valid Code Node`);\n  }\n\n  if (type === lexical.INDENT_CONTENT_COMMAND) {\n    if (lexical.$isLineBreakNode(firstOfLine)) {\n      firstOfLine.insertAfter(lexical.$createTabNode());\n    } else {\n      firstOfLine.insertBefore(lexical.$createTabNode());\n    }\n  } else if (lexical.$isTabNode(firstOfLine)) {\n    firstOfLine.remove();\n  }\n\n  return true;\n}\n\nfunction handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  } // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === lexical.KEY_ARROW_UP_COMMAND; // Ensure the selection is within the codeblock\n\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || lexical.$isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || lexical.$isTabNode(focusNode))) {\n    return false;\n  }\n\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // sibling thats can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  let start;\n  let end;\n\n  if (anchorNode.isBefore(focusNode)) {\n    start = getFirstCodeNodeOfLine(anchorNode);\n    end = getLastCodeNodeOfLine(focusNode);\n  } else {\n    start = getFirstCodeNodeOfLine(focusNode);\n    end = getLastCodeNodeOfLine(anchorNode);\n  }\n\n  if (start == null || end == null) {\n    return false;\n  }\n\n  const range = start.getNodesBetween(end);\n\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n\n    if (!$isCodeHighlightNode(node) && !lexical.$isTabNode(node) && !lexical.$isLineBreakNode(node)) {\n      return false;\n    }\n  } // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n\n\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n\n  if (!lexical.$isLineBreakNode(linebreak)) {\n    return true;\n  }\n\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n\n  if (sibling == null) {\n    return true;\n  }\n\n  const maybeInsertionPoint = $isCodeHighlightNode(sibling) || lexical.$isTabNode(sibling) || lexical.$isLineBreakNode(sibling) ? arrowIsUp ? getFirstCodeNodeOfLine(sibling) : getLastCodeNodeOfLine(sibling) : null;\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n\n  if (type === lexical.KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\n\nfunction handleMoveTo(type, event) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === lexical.MOVE_TO_START;\n\n  if (!($isCodeHighlightNode(anchorNode) || lexical.$isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || lexical.$isTabNode(focusNode))) {\n    return false;\n  }\n\n  if (isMoveToStart) {\n    const start = getStartOfCodeInLine(focusNode, focus.offset);\n\n    if (start !== null) {\n      const {\n        node,\n        offset\n      } = start;\n\n      if (lexical.$isLineBreakNode(node)) {\n        node.selectNext(0, 0);\n      } else {\n        selection.setTextNodeRange(node, offset, node, offset);\n      }\n    } else {\n      focusNode.getParentOrThrow().selectStart();\n    }\n  } else {\n    const node = getEndOfCodeInLine(focusNode);\n    node.select();\n  }\n\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\n\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n\n  return utils.mergeRegister(editor.registerMutationListener(CodeNode, mutations => {\n    editor.update(() => {\n      for (const [key, type] of mutations) {\n        if (type !== 'destroyed') {\n          const node = lexical.$getNodeByKey(key);\n\n          if (node !== null) {\n            updateCodeGutter(node, editor);\n          }\n        }\n      }\n    });\n  }), editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(lexical.TextNode, node => textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => textNodeTransform(node, editor, tokenizer)), editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\n    const command = handleTab(event.shiftKey);\n\n    if (command === null) {\n      return false;\n    }\n\n    event.preventDefault();\n    editor.dispatchCommand(command, undefined);\n    return true;\n  }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.INSERT_TAB_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n\n    lexical.$insertNodes([lexical.$createTabNode()]);\n    return true;\n  }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.INDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.OUTDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_UP_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_DOWN_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_END, payload => handleMoveTo(lexical.MOVE_TO_END, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_START, payload => handleMoveTo(lexical.MOVE_TO_START, payload), lexical.COMMAND_PRIORITY_LOW));\n}\n\nexports.$createCodeHighlightNode = $createCodeHighlightNode;\nexports.$createCodeNode = $createCodeNode;\nexports.$isCodeHighlightNode = $isCodeHighlightNode;\nexports.$isCodeNode = $isCodeNode;\nexports.CODE_LANGUAGE_FRIENDLY_NAME_MAP = CODE_LANGUAGE_FRIENDLY_NAME_MAP;\nexports.CODE_LANGUAGE_MAP = CODE_LANGUAGE_MAP;\nexports.CodeHighlightNode = CodeHighlightNode;\nexports.CodeNode = CodeNode;\nexports.DEFAULT_CODE_LANGUAGE = DEFAULT_CODE_LANGUAGE;\nexports.PrismTokenizer = PrismTokenizer;\nexports.getCodeLanguages = getCodeLanguages;\nexports.getDefaultCodeLanguage = getDefaultCodeLanguage;\nexports.getEndOfCodeInLine = getEndOfCodeInLine;\nexports.getFirstCodeNodeOfLine = getFirstCodeNodeOfLine;\nexports.getLanguageFriendlyName = getLanguageFriendlyName;\nexports.getLastCodeNodeOfLine = getLastCodeNodeOfLine;\nexports.getStartOfCodeInLine = getStartOfCodeInLine;\nexports.normalizeCodeLang = normalizeCodeLang;\nexports.registerCodeHighlighting = registerCodeHighlighting;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jb2RlL0xleGljYWxDb2RlLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsb0VBQVM7QUFDN0IsbUJBQU8sQ0FBQyw0R0FBZ0M7QUFDeEMsbUJBQU8sQ0FBQyxzSEFBcUM7QUFDN0MsbUJBQU8sQ0FBQyw4R0FBaUM7QUFDekMsbUJBQU8sQ0FBQyxrSEFBbUM7QUFDM0MsbUJBQU8sQ0FBQyxvR0FBNEI7QUFDcEMsbUJBQU8sQ0FBQyx3R0FBOEI7QUFDdEMsbUJBQU8sQ0FBQyxzSEFBcUM7QUFDN0MsbUJBQU8sQ0FBQyx3R0FBOEI7QUFDdEMsbUJBQU8sQ0FBQyw4R0FBaUM7QUFDekMsbUJBQU8sQ0FBQywwR0FBK0I7QUFDdkMsbUJBQU8sQ0FBQyw0R0FBZ0M7QUFDeEMsbUJBQU8sQ0FBQyxzSEFBcUM7QUFDN0MsbUJBQU8sQ0FBQywwR0FBK0I7QUFDdkMsbUJBQU8sQ0FBQyx3R0FBOEI7QUFDdEMsWUFBWSxtQkFBTyxDQUFDLHlGQUFnQjtBQUNwQyxjQUFjLG1CQUFPLENBQUMsc0VBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLGlCQUFpQiwyQ0FBMkM7O0FBRTVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdEQUF3RDs7O0FBRzVEO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0Isb0JBQW9CO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUdBQWlHOztBQUVqRzs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7O0FBRUE7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQSwyQkFBMkI7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIsNEJBQTRCO0FBQzVCLG1CQUFtQjtBQUNuQix1Q0FBdUM7QUFDdkMseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QixnQkFBZ0I7QUFDaEIsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIseUJBQXlCO0FBQ3pCLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY29kZS9MZXhpY2FsQ29kZS5kZXYuanM/YTY4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFByaXNtID0gcmVxdWlyZSgncHJpc21qcycpO1xucmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNsaWtlJyk7XG5yZXF1aXJlKCdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tamF2YXNjcmlwdCcpO1xucmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW1hcmt1cCcpO1xucmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW1hcmtkb3duJyk7XG5yZXF1aXJlKCdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tYycpO1xucmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNzcycpO1xucmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW9iamVjdGl2ZWMnKTtcbnJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1zcWwnKTtcbnJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1weXRob24nKTtcbnJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1ydXN0Jyk7XG5yZXF1aXJlKCdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tc3dpZnQnKTtcbnJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS10eXBlc2NyaXB0Jyk7XG5yZXF1aXJlKCdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tamF2YScpO1xucmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNwcCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQGxleGljYWwvdXRpbHMnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IG1hcFRvUHJpc21MYW5ndWFnZSA9IGxhbmd1YWdlID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICByZXR1cm4gbGFuZ3VhZ2UgIT0gbnVsbCAmJiBQcmlzbS5sYW5ndWFnZXMuaGFzT3duUHJvcGVydHkobGFuZ3VhZ2UpID8gbGFuZ3VhZ2UgOiB1bmRlZmluZWQ7XG59O1xuXG5mdW5jdGlvbiBoYXNDaGlsZERPTU5vZGVUYWcobm9kZSwgdGFnTmFtZSkge1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGROb2Rlcykge1xuICAgIGlmICh1dGlscy5pc0hUTUxFbGVtZW50KGNoaWxkKSAmJiBjaGlsZC50YWdOYW1lID09PSB0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBoYXNDaGlsZERPTU5vZGVUYWcoY2hpbGQsIHRhZ05hbWUpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBMQU5HVUFHRV9EQVRBX0FUVFJJQlVURSA9ICdkYXRhLWhpZ2hsaWdodC1sYW5ndWFnZSc7XG4vKiogQG5vSW5oZXJpdERvYyAqL1xuXG5jbGFzcyBDb2RlTm9kZSBleHRlbmRzIGxleGljYWwuRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnY29kZSc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgQ29kZU5vZGUobm9kZS5fX2xhbmd1YWdlLCBub2RlLl9fa2V5KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGxhbmd1YWdlLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX19sYW5ndWFnZSA9IG1hcFRvUHJpc21MYW5ndWFnZShsYW5ndWFnZSk7XG4gIH0gLy8gVmlld1xuXG5cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJyk7XG4gICAgdXRpbHMuYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjb25maWcudGhlbWUuY29kZSk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCAnZmFsc2UnKTtcbiAgICBjb25zdCBsYW5ndWFnZSA9IHRoaXMuZ2V0TGFuZ3VhZ2UoKTtcblxuICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUsIGxhbmd1YWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBjb25zdCBsYW5ndWFnZSA9IHRoaXMuX19sYW5ndWFnZTtcbiAgICBjb25zdCBwcmV2TGFuZ3VhZ2UgPSBwcmV2Tm9kZS5fX2xhbmd1YWdlO1xuXG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICBpZiAobGFuZ3VhZ2UgIT09IHByZXZMYW5ndWFnZSkge1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKExBTkdVQUdFX0RBVEFfQVRUUklCVVRFLCBsYW5ndWFnZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2TGFuZ3VhZ2UpIHtcbiAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGV4cG9ydERPTSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncHJlJyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCAnZmFsc2UnKTtcbiAgICBjb25zdCBsYW5ndWFnZSA9IHRoaXMuZ2V0TGFuZ3VhZ2UoKTtcblxuICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUsIGxhbmd1YWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBUeXBpY2FsbHkgPHByZT4gaXMgdXNlZCBmb3IgY29kZSBibG9ja3MsIGFuZCA8Y29kZT4gZm9yIGlubGluZSBjb2RlIHN0eWxlc1xuICAgICAgLy8gYnV0IGlmIGl0J3MgYSBtdWx0aSBsaW5lIDxjb2RlPiB3ZSdsbCBjcmVhdGUgYSBibG9jay4gUGFzcyB0aHJvdWdoIHRvXG4gICAgICAvLyBpbmxpbmUgZm9ybWF0IGhhbmRsZWQgYnkgVGV4dE5vZGUgb3RoZXJ3aXNlLlxuICAgICAgY29kZTogbm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IGlzTXVsdGlMaW5lID0gbm9kZS50ZXh0Q29udGVudCAhPSBudWxsICYmICgvXFxyP1xcbi8udGVzdChub2RlLnRleHRDb250ZW50KSB8fCBoYXNDaGlsZERPTU5vZGVUYWcobm9kZSwgJ0JSJykpO1xuICAgICAgICByZXR1cm4gaXNNdWx0aUxpbmUgPyB7XG4gICAgICAgICAgY29udmVyc2lvbjogY29udmVydFByZUVsZW1lbnQsXG4gICAgICAgICAgcHJpb3JpdHk6IDFcbiAgICAgICAgfSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgZGl2OiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnREaXZFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMVxuICAgICAgfSksXG4gICAgICBwcmU6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFByZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHRhYmxlOiBub2RlID0+IHtcbiAgICAgICAgY29uc3QgdGFibGUgPSBub2RlOyAvLyBkb21Ob2RlIGlzIGEgPHRhYmxlPiBzaW5jZSB3ZSBtYXRjaGVkIGl0IGJ5IG5vZGVOYW1lXG5cbiAgICAgICAgaWYgKGlzR2l0SHViQ29kZVRhYmxlKHRhYmxlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGFibGVFbGVtZW50LFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgdGQ6IG5vZGUgPT4ge1xuICAgICAgICAvLyBlbGVtZW50IGlzIGEgPHRkPiBzaW5jZSB3ZSBtYXRjaGVkIGl0IGJ5IG5vZGVOYW1lXG4gICAgICAgIGNvbnN0IHRkID0gbm9kZTtcbiAgICAgICAgY29uc3QgdGFibGUgPSB0ZC5jbG9zZXN0KCd0YWJsZScpO1xuXG4gICAgICAgIGlmIChpc0dpdEh1YkNvZGVDZWxsKHRkKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGFibGVDZWxsRWxlbWVudCxcbiAgICAgICAgICAgIHByaW9yaXR5OiAzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YWJsZSAmJiBpc0dpdEh1YkNvZGVUYWJsZSh0YWJsZSkpIHtcbiAgICAgICAgICAvLyBSZXR1cm4gYSBuby1vcCBpZiBpdCdzIGEgdGFibGUgY2VsbCBpbiBhIGNvZGUgdGFibGUsIGJ1dCBub3QgYSBjb2RlIGxpbmUuXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGl0J2xsIGZhbGwgYmFjayB0byB0aGUgVFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0Q29kZU5vb3AsXG4gICAgICAgICAgICBwcmlvcml0eTogM1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICB0cjogbm9kZSA9PiB7XG4gICAgICAgIC8vIGVsZW1lbnQgaXMgYSA8dHI+IHNpbmNlIHdlIG1hdGNoZWQgaXQgYnkgbm9kZU5hbWVcbiAgICAgICAgY29uc3QgdHIgPSBub2RlO1xuICAgICAgICBjb25zdCB0YWJsZSA9IHRyLmNsb3Nlc3QoJ3RhYmxlJyk7XG5cbiAgICAgICAgaWYgKHRhYmxlICYmIGlzR2l0SHViQ29kZVRhYmxlKHRhYmxlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0Q29kZU5vb3AsXG4gICAgICAgICAgICBwcmlvcml0eTogM1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZUNvZGVOb2RlKHNlcmlhbGl6ZWROb2RlLmxhbmd1YWdlKTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgbGFuZ3VhZ2U6IHRoaXMuZ2V0TGFuZ3VhZ2UoKSxcbiAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9IC8vIE11dGF0aW9uXG5cblxuICBpbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgICBpZiAoY2hpbGRyZW5MZW5ndGggPj0gMiAmJiBjaGlsZHJlbltjaGlsZHJlbkxlbmd0aCAtIDFdLmdldFRleHRDb250ZW50KCkgPT09ICdcXG4nICYmIGNoaWxkcmVuW2NoaWxkcmVuTGVuZ3RoIC0gMl0uZ2V0VGV4dENvbnRlbnQoKSA9PT0gJ1xcbicgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgc2VsZWN0aW9uLmFuY2hvci5rZXkgPT09IHRoaXMuX19rZXkgJiYgc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IGNoaWxkcmVuTGVuZ3RoKSB7XG4gICAgICBjaGlsZHJlbltjaGlsZHJlbkxlbmd0aCAtIDFdLnJlbW92ZSgpO1xuICAgICAgY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAyXS5yZW1vdmUoKTtcbiAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICB0aGlzLmluc2VydEFmdGVyKG5ld0VsZW1lbnQsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gICAgfSAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIHdpdGhpbiB0aGUgY29kZWJsb2NrLCBmaW5kIGFsbCBsZWFkaW5nIHRhYnMgYW5kXG4gICAgLy8gc3BhY2VzIG9mIHRoZSBjdXJyZW50IGxpbmUuIENyZWF0ZSBhIG5ldyBsaW5lIHRoYXQgaGFzIGFsbCB0aG9zZVxuICAgIC8vIHRhYnMgYW5kIHNwYWNlcywgc3VjaCB0aGF0IGxlYWRpbmcgaW5kZW50YXRpb24gaXMgcHJlc2VydmVkLlxuXG5cbiAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBhbmNob3IuaXNCZWZvcmUoZm9jdXMpID8gYW5jaG9yIDogZm9jdXM7XG4gICAgY29uc3QgZmlyc3RTZWxlY3Rpb25Ob2RlID0gZmlyc3RQb2ludC5nZXROb2RlKCk7XG5cbiAgICBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUoZmlyc3RTZWxlY3Rpb25Ob2RlKSB8fCBsZXhpY2FsLiRpc1RhYk5vZGUoZmlyc3RTZWxlY3Rpb25Ob2RlKSkge1xuICAgICAgbGV0IG5vZGUgPSBnZXRGaXJzdENvZGVOb2RlT2ZMaW5lKGZpcnN0U2VsZWN0aW9uTm9kZSk7XG4gICAgICBjb25zdCBpbnNlcnROb2RlcyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChsZXhpY2FsLiRpc1RhYk5vZGUobm9kZSkpIHtcbiAgICAgICAgICBpbnNlcnROb2Rlcy5wdXNoKGxleGljYWwuJGNyZWF0ZVRhYk5vZGUoKSk7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSkge1xuICAgICAgICAgIGxldCBzcGFjZXMgPSAwO1xuICAgICAgICAgIGNvbnN0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgICAgY29uc3QgdGV4dFNpemUgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuXG4gICAgICAgICAgZm9yICg7IHNwYWNlcyA8IHRleHRTaXplICYmIHRleHRbc3BhY2VzXSA9PT0gJyAnOyBzcGFjZXMrKyk7XG5cbiAgICAgICAgICBpZiAoc3BhY2VzICE9PSAwKSB7XG4gICAgICAgICAgICBpbnNlcnROb2Rlcy5wdXNoKCRjcmVhdGVDb2RlSGlnaGxpZ2h0Tm9kZSgnICcucmVwZWF0KHNwYWNlcykpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3BhY2VzICE9PSB0ZXh0U2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5zZXJ0Tm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0Tm9kZXMoW2xleGljYWwuJGNyZWF0ZUxpbmVCcmVha05vZGUoKSwgLi4uaW5zZXJ0Tm9kZXNdKTtcbiAgICAgICAgcmV0dXJuIGluc2VydE5vZGVzW2luc2VydE5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbGxhcHNlQXRTdGFydCgpIHtcbiAgICBjb25zdCBwYXJhZ3JhcGggPSBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBwYXJhZ3JhcGguYXBwZW5kKGNoaWxkKSk7XG4gICAgdGhpcy5yZXBsYWNlKHBhcmFncmFwaCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzZXRMYW5ndWFnZShsYW5ndWFnZSkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fbGFuZ3VhZ2UgPSBtYXBUb1ByaXNtTGFuZ3VhZ2UobGFuZ3VhZ2UpO1xuICB9XG5cbiAgZ2V0TGFuZ3VhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19sYW5ndWFnZTtcbiAgfVxuXG59XG5mdW5jdGlvbiAkY3JlYXRlQ29kZU5vZGUobGFuZ3VhZ2UpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBDb2RlTm9kZShsYW5ndWFnZSkpO1xufVxuZnVuY3Rpb24gJGlzQ29kZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIENvZGVOb2RlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UHJlRWxlbWVudChkb21Ob2RlKSB7XG4gIGxldCBsYW5ndWFnZTtcblxuICBpZiAodXRpbHMuaXNIVE1MRWxlbWVudChkb21Ob2RlKSkge1xuICAgIGxhbmd1YWdlID0gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlQ29kZU5vZGUobGFuZ3VhZ2UpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnREaXZFbGVtZW50KGRvbU5vZGUpIHtcbiAgLy8gZG9tTm9kZSBpcyBhIDxkaXY+IHNpbmNlIHdlIG1hdGNoZWQgaXQgYnkgbm9kZU5hbWVcbiAgY29uc3QgZGl2ID0gZG9tTm9kZTtcbiAgY29uc3QgaXNDb2RlID0gaXNDb2RlRWxlbWVudChkaXYpO1xuXG4gIGlmICghaXNDb2RlICYmICFpc0NvZGVDaGlsZEVsZW1lbnQoZGl2KSkge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6IGNoaWxkTGV4aWNhbE5vZGVzID0+IHtcbiAgICAgIGNvbnN0IGRvbVBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcblxuICAgICAgaWYgKGRvbVBhcmVudCAhPSBudWxsICYmIGRvbU5vZGUgIT09IGRvbVBhcmVudC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY2hpbGRMZXhpY2FsTm9kZXMucHVzaChsZXhpY2FsLiRjcmVhdGVMaW5lQnJlYWtOb2RlKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hpbGRMZXhpY2FsTm9kZXM7XG4gICAgfSxcbiAgICBub2RlOiBpc0NvZGUgPyAkY3JlYXRlQ29kZU5vZGUoKSA6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRhYmxlRWxlbWVudCgpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlQ29kZU5vZGUoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0Q29kZU5vb3AoKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VGFibGVDZWxsRWxlbWVudChkb21Ob2RlKSB7XG4gIC8vIGRvbU5vZGUgaXMgYSA8dGQ+IHNpbmNlIHdlIG1hdGNoZWQgaXQgYnkgbm9kZU5hbWVcbiAgY29uc3QgY2VsbCA9IGRvbU5vZGU7XG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6IGNoaWxkTGV4aWNhbE5vZGVzID0+IHtcbiAgICAgIGlmIChjZWxsLnBhcmVudE5vZGUgJiYgY2VsbC5wYXJlbnROb2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIC8vIEFwcGVuZCBuZXdsaW5lIGJldHdlZW4gY29kZSBsaW5lc1xuICAgICAgICBjaGlsZExleGljYWxOb2Rlcy5wdXNoKGxleGljYWwuJGNyZWF0ZUxpbmVCcmVha05vZGUoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGlsZExleGljYWxOb2RlcztcbiAgICB9LFxuICAgIG5vZGU6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNDb2RlRWxlbWVudChkaXYpIHtcbiAgcmV0dXJuIGRpdi5zdHlsZS5mb250RmFtaWx5Lm1hdGNoKCdtb25vc3BhY2UnKSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNDb2RlQ2hpbGRFbGVtZW50KG5vZGUpIHtcbiAgbGV0IHBhcmVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcblxuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKGlzQ29kZUVsZW1lbnQocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzR2l0SHViQ29kZUNlbGwoY2VsbCkge1xuICByZXR1cm4gY2VsbC5jbGFzc0xpc3QuY29udGFpbnMoJ2pzLWZpbGUtbGluZScpO1xufVxuXG5mdW5jdGlvbiBpc0dpdEh1YkNvZGVUYWJsZSh0YWJsZSkge1xuICByZXR1cm4gdGFibGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdqcy1maWxlLWxpbmUtY29udGFpbmVyJyk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IERFRkFVTFRfQ09ERV9MQU5HVUFHRSA9ICdqYXZhc2NyaXB0JztcbmNvbnN0IENPREVfTEFOR1VBR0VfRlJJRU5ETFlfTkFNRV9NQVAgPSB7XG4gIGM6ICdDJyxcbiAgY2xpa2U6ICdDLWxpa2UnLFxuICBjcHA6ICdDKysnLFxuICBjc3M6ICdDU1MnLFxuICBodG1sOiAnSFRNTCcsXG4gIGphdmE6ICdKYXZhJyxcbiAganM6ICdKYXZhU2NyaXB0JyxcbiAgbWFya2Rvd246ICdNYXJrZG93bicsXG4gIG9iamM6ICdPYmplY3RpdmUtQycsXG4gIHBsYWluOiAnUGxhaW4gVGV4dCcsXG4gIHB5OiAnUHl0aG9uJyxcbiAgcnVzdDogJ1J1c3QnLFxuICBzcWw6ICdTUUwnLFxuICBzd2lmdDogJ1N3aWZ0JyxcbiAgdHlwZXNjcmlwdDogJ1R5cGVTY3JpcHQnLFxuICB4bWw6ICdYTUwnXG59O1xuY29uc3QgQ09ERV9MQU5HVUFHRV9NQVAgPSB7XG4gIGNwcDogJ2NwcCcsXG4gIGphdmE6ICdqYXZhJyxcbiAgamF2YXNjcmlwdDogJ2pzJyxcbiAgbWQ6ICdtYXJrZG93bicsXG4gIHBsYWludGV4dDogJ3BsYWluJyxcbiAgcHl0aG9uOiAncHknLFxuICB0ZXh0OiAncGxhaW4nLFxuICB0czogJ3R5cGVzY3JpcHQnXG59O1xuZnVuY3Rpb24gbm9ybWFsaXplQ29kZUxhbmcobGFuZykge1xuICByZXR1cm4gQ09ERV9MQU5HVUFHRV9NQVBbbGFuZ10gfHwgbGFuZztcbn1cbmZ1bmN0aW9uIGdldExhbmd1YWdlRnJpZW5kbHlOYW1lKGxhbmcpIHtcbiAgY29uc3QgX2xhbmcgPSBub3JtYWxpemVDb2RlTGFuZyhsYW5nKTtcblxuICByZXR1cm4gQ09ERV9MQU5HVUFHRV9GUklFTkRMWV9OQU1FX01BUFtfbGFuZ10gfHwgX2xhbmc7XG59XG5jb25zdCBnZXREZWZhdWx0Q29kZUxhbmd1YWdlID0gKCkgPT4gREVGQVVMVF9DT0RFX0xBTkdVQUdFO1xuY29uc3QgZ2V0Q29kZUxhbmd1YWdlcyA9ICgpID0+IE9iamVjdC5rZXlzKFByaXNtLmxhbmd1YWdlcykuZmlsdGVyKCAvLyBQcmlzbSBoYXMgc2V2ZXJhbCBsYW5ndWFnZSBoZWxwZXJzIG1peGVkIGludG8gbGFuZ3VhZ2VzIG9iamVjdFxuLy8gc28gZmlsdGVyaW5nIHRoZW0gb3V0IGhlcmUgdG8gZ2V0IGxhbmdzIGxpc3Rcbmxhbmd1YWdlID0+IHR5cGVvZiBQcmlzbS5sYW5ndWFnZXNbbGFuZ3VhZ2VdICE9PSAnZnVuY3Rpb24nKS5zb3J0KCk7XG4vKiogQG5vSW5oZXJpdERvYyAqL1xuXG5jbGFzcyBDb2RlSGlnaGxpZ2h0Tm9kZSBleHRlbmRzIGxleGljYWwuVGV4dE5vZGUge1xuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKHRleHQsIGhpZ2hsaWdodFR5cGUsIGtleSkge1xuICAgIHN1cGVyKHRleHQsIGtleSk7XG4gICAgdGhpcy5fX2hpZ2hsaWdodFR5cGUgPSBoaWdobGlnaHRUeXBlO1xuICB9XG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdjb2RlLWhpZ2hsaWdodCc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgQ29kZUhpZ2hsaWdodE5vZGUobm9kZS5fX3RleHQsIG5vZGUuX19oaWdobGlnaHRUeXBlIHx8IHVuZGVmaW5lZCwgbm9kZS5fX2tleSk7XG4gIH1cblxuICBnZXRIaWdobGlnaHRUeXBlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9faGlnaGxpZ2h0VHlwZTtcbiAgfVxuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gc3VwZXIuY3JlYXRlRE9NKGNvbmZpZyk7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gZ2V0SGlnaGxpZ2h0VGhlbWVDbGFzcyhjb25maWcudGhlbWUsIHRoaXMuX19oaWdobGlnaHRUeXBlKTtcbiAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgY29uc3QgdXBkYXRlID0gc3VwZXIudXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZyk7XG4gICAgY29uc3QgcHJldkNsYXNzTmFtZSA9IGdldEhpZ2hsaWdodFRoZW1lQ2xhc3MoY29uZmlnLnRoZW1lLCBwcmV2Tm9kZS5fX2hpZ2hsaWdodFR5cGUpO1xuICAgIGNvbnN0IG5leHRDbGFzc05hbWUgPSBnZXRIaWdobGlnaHRUaGVtZUNsYXNzKGNvbmZpZy50aGVtZSwgdGhpcy5fX2hpZ2hsaWdodFR5cGUpO1xuXG4gICAgaWYgKHByZXZDbGFzc05hbWUgIT09IG5leHRDbGFzc05hbWUpIHtcbiAgICAgIGlmIChwcmV2Q2xhc3NOYW1lKSB7XG4gICAgICAgIHV0aWxzLnJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChkb20sIHByZXZDbGFzc05hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dENsYXNzTmFtZSkge1xuICAgICAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgbmV4dENsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVDb2RlSGlnaGxpZ2h0Tm9kZShzZXJpYWxpemVkTm9kZS50ZXh0LCBzZXJpYWxpemVkTm9kZS5oaWdobGlnaHRUeXBlKTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0RGV0YWlsKHNlcmlhbGl6ZWROb2RlLmRldGFpbCk7XG4gICAgbm9kZS5zZXRNb2RlKHNlcmlhbGl6ZWROb2RlLm1vZGUpO1xuICAgIG5vZGUuc2V0U3R5bGUoc2VyaWFsaXplZE5vZGUuc3R5bGUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4geyAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBoaWdobGlnaHRUeXBlOiB0aGlzLmdldEhpZ2hsaWdodFR5cGUoKSxcbiAgICAgIHR5cGU6ICdjb2RlLWhpZ2hsaWdodCcsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfSAvLyBQcmV2ZW50IGZvcm1hdHRpbmcgKGJvbGQsIHVuZGVybGluZSwgZXRjKVxuXG5cbiAgc2V0Rm9ybWF0KGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaXNQYXJlbnRSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNyZWF0ZVBhcmVudEVsZW1lbnROb2RlKCkge1xuICAgIHJldHVybiAkY3JlYXRlQ29kZU5vZGUoKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGdldEhpZ2hsaWdodFRoZW1lQ2xhc3ModGhlbWUsIGhpZ2hsaWdodFR5cGUpIHtcbiAgcmV0dXJuIGhpZ2hsaWdodFR5cGUgJiYgdGhlbWUgJiYgdGhlbWUuY29kZUhpZ2hsaWdodCAmJiB0aGVtZS5jb2RlSGlnaGxpZ2h0W2hpZ2hsaWdodFR5cGVdO1xufVxuXG5mdW5jdGlvbiAkY3JlYXRlQ29kZUhpZ2hsaWdodE5vZGUodGV4dCwgaGlnaGxpZ2h0VHlwZSkge1xuICByZXR1cm4gbGV4aWNhbC4kYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IENvZGVIaWdobGlnaHROb2RlKHRleHQsIGhpZ2hsaWdodFR5cGUpKTtcbn1cbmZ1bmN0aW9uICRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBDb2RlSGlnaGxpZ2h0Tm9kZTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0Q29kZU5vZGVPZkxpbmUoYW5jaG9yKSB7XG4gIGxldCBwcmV2aW91c05vZGUgPSBhbmNob3I7XG4gIGxldCBub2RlID0gYW5jaG9yO1xuXG4gIHdoaWxlICgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSB8fCBsZXhpY2FsLiRpc1RhYk5vZGUobm9kZSkpIHtcbiAgICBwcmV2aW91c05vZGUgPSBub2RlO1xuICAgIG5vZGUgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICB9XG5cbiAgcmV0dXJuIHByZXZpb3VzTm9kZTtcbn1cbmZ1bmN0aW9uIGdldExhc3RDb2RlTm9kZU9mTGluZShhbmNob3IpIHtcbiAgbGV0IG5leHROb2RlID0gYW5jaG9yO1xuICBsZXQgbm9kZSA9IGFuY2hvcjtcblxuICB3aGlsZSAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkgfHwgbGV4aWNhbC4kaXNUYWJOb2RlKG5vZGUpKSB7XG4gICAgbmV4dE5vZGUgPSBub2RlO1xuICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gIH1cblxuICByZXR1cm4gbmV4dE5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IFByaXNtVG9rZW5pemVyID0ge1xuICBkZWZhdWx0TGFuZ3VhZ2U6IERFRkFVTFRfQ09ERV9MQU5HVUFHRSxcblxuICB0b2tlbml6ZShjb2RlLCBsYW5ndWFnZSkge1xuICAgIHJldHVybiBQcmlzbS50b2tlbml6ZShjb2RlLCBQcmlzbS5sYW5ndWFnZXNbbGFuZ3VhZ2UgfHwgJyddIHx8IFByaXNtLmxhbmd1YWdlc1t0aGlzLmRlZmF1bHRMYW5ndWFnZV0pO1xuICB9XG5cbn07XG5mdW5jdGlvbiBnZXRTdGFydE9mQ29kZUluTGluZShhbmNob3IsIG9mZnNldCkge1xuICBsZXQgbGFzdCA9IG51bGw7XG4gIGxldCBsYXN0Tm9uQmxhbmsgPSBudWxsO1xuICBsZXQgbm9kZSA9IGFuY2hvcjtcbiAgbGV0IG5vZGVPZmZzZXQgPSBvZmZzZXQ7XG4gIGxldCBub2RlVGV4dENvbnRlbnQgPSBhbmNob3IuZ2V0VGV4dENvbnRlbnQoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGVPZmZzZXQgPT09IDApIHtcbiAgICAgIG5vZGUgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuXG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKCEoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkgfHwgbGV4aWNhbC4kaXNUYWJOb2RlKG5vZGUpIHx8IGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShub2RlKSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGEgdmFsaWQgQ29kZSBOb2RlOiBDb2RlSGlnaGxpZ2h0Tm9kZSwgVGFiTm9kZSwgTGluZUJyZWFrTm9kZWApO1xuICAgICAgfVxuXG4gICAgICBpZiAobGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICAgIGxhc3QgPSB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IDFcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG5vZGVPZmZzZXQgPSBNYXRoLm1heCgwLCBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpIC0gMSk7XG4gICAgICBub2RlVGV4dENvbnRlbnQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVPZmZzZXQtLTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFyYWN0ZXIgPSBub2RlVGV4dENvbnRlbnRbbm9kZU9mZnNldF07XG5cbiAgICBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkgJiYgY2hhcmFjdGVyICE9PSAnICcpIHtcbiAgICAgIGxhc3ROb25CbGFuayA9IHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgb2Zmc2V0OiBub2RlT2Zmc2V0XG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBsYXN0Tm9uQmxhbmsgIT09IG51bGw6IGFuY2hvciBpbiB0aGUgbWlkZGxlIG9mIGNvZGU7IG1vdmUgdG8gbGluZSBiZWdpbm5pbmdcblxuXG4gIGlmIChsYXN0Tm9uQmxhbmsgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbGFzdE5vbkJsYW5rO1xuICB9IC8vIFNwYWNlcywgdGFicyBvciBub3RoaW5nIGFoZWFkIG9mIGFuY2hvclxuXG5cbiAgbGV0IGNvZGVDaGFyYWN0ZXJBdEFuY2hvck9mZnNldCA9IG51bGw7XG5cbiAgaWYgKG9mZnNldCA8IGFuY2hvci5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgIGlmICgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShhbmNob3IpKSB7XG4gICAgICBjb2RlQ2hhcmFjdGVyQXRBbmNob3JPZmZzZXQgPSBhbmNob3IuZ2V0VGV4dENvbnRlbnQoKVtvZmZzZXRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IGFuY2hvci5nZXROZXh0U2libGluZygpO1xuXG4gICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgY29kZUNoYXJhY3RlckF0QW5jaG9yT2Zmc2V0ID0gbmV4dFNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKVswXTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29kZUNoYXJhY3RlckF0QW5jaG9yT2Zmc2V0ICE9PSBudWxsICYmIGNvZGVDaGFyYWN0ZXJBdEFuY2hvck9mZnNldCAhPT0gJyAnKSB7XG4gICAgLy8gQm9yZGVybGluZSB3aGl0ZXNwYWNlIGFuZCBjb2RlLCBtb3ZlIHRvIGxpbmUgYmVnaW5uaW5nXG4gICAgcmV0dXJuIGxhc3Q7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbmV4dE5vbkJsYW5rID0gZmluZE5leHROb25CbGFua0luTGluZShhbmNob3IsIG9mZnNldCk7XG5cbiAgICBpZiAobmV4dE5vbkJsYW5rICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV4dE5vbkJsYW5rO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGFzdDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZE5leHROb25CbGFua0luTGluZShhbmNob3IsIG9mZnNldCkge1xuICBsZXQgbm9kZSA9IGFuY2hvcjtcbiAgbGV0IG5vZGVPZmZzZXQgPSBvZmZzZXQ7XG4gIGxldCBub2RlVGV4dENvbnRlbnQgPSBhbmNob3IuZ2V0VGV4dENvbnRlbnQoKTtcbiAgbGV0IG5vZGVUZXh0Q29udGVudFNpemUgPSBhbmNob3IuZ2V0VGV4dENvbnRlbnRTaXplKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkgfHwgbm9kZU9mZnNldCA9PT0gbm9kZVRleHRDb250ZW50U2l6ZSkge1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkpIHtcbiAgICAgICAgbm9kZU9mZnNldCA9IDA7XG4gICAgICAgIG5vZGVUZXh0Q29udGVudCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgbm9kZVRleHRDb250ZW50U2l6ZSA9IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpKSB7XG4gICAgICBpZiAobm9kZVRleHRDb250ZW50W25vZGVPZmZzZXRdICE9PSAnICcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIG9mZnNldDogbm9kZU9mZnNldFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlT2Zmc2V0Kys7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEVuZE9mQ29kZUluTGluZShhbmNob3IpIHtcbiAgY29uc3QgbGFzdE5vZGUgPSBnZXRMYXN0Q29kZU5vZGVPZkxpbmUoYW5jaG9yKTtcblxuICBpZiAoISFsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUobGFzdE5vZGUpKSB7XG4gICAgdGhyb3cgRXJyb3IoYFVuZXhwZWN0ZWQgbGluZUJyZWFrTm9kZSBpbiBnZXRFbmRPZkNvZGVJbkxpbmVgKTtcbiAgfVxuXG4gIHJldHVybiBsYXN0Tm9kZTtcbn1cblxuZnVuY3Rpb24gdGV4dE5vZGVUcmFuc2Zvcm0obm9kZSwgZWRpdG9yLCB0b2tlbml6ZXIpIHtcbiAgLy8gU2luY2UgQ29kZU5vZGUgaGFzIGZsYXQgY2hpbGRyZW4gc3RydWN0dXJlIHdlIG9ubHkgbmVlZCB0byBjaGVja1xuICAvLyBpZiBub2RlJ3MgcGFyZW50IGlzIGEgY29kZSBub2RlIGFuZCBydW4gaGlnaGxpZ2h0aW5nIGlmIHNvXG4gIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuXG4gIGlmICgkaXNDb2RlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIGNvZGVOb2RlVHJhbnNmb3JtKHBhcmVudE5vZGUsIGVkaXRvciwgdG9rZW5pemVyKTtcbiAgfSBlbHNlIGlmICgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSkge1xuICAgIC8vIFdoZW4gY29kZSBibG9jayBjb252ZXJ0ZWQgaW50byBwYXJhZ3JhcGggb3Igb3RoZXIgZWxlbWVudFxuICAgIC8vIGNvZGUgaGlnaGxpZ2h0IG5vZGVzIGNvbnZlcnRlZCBiYWNrIHRvIG5vcm1hbCB0ZXh0XG4gICAgbm9kZS5yZXBsYWNlKGxleGljYWwuJGNyZWF0ZVRleHROb2RlKG5vZGUuX190ZXh0KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29kZUd1dHRlcihub2RlLCBlZGl0b3IpIHtcbiAgY29uc3QgY29kZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KG5vZGUuZ2V0S2V5KCkpO1xuXG4gIGlmIChjb2RlRWxlbWVudCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDsgLy8gQHRzLWlnbm9yZTogaW50ZXJuYWwgZmllbGRcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IGNvZGVFbGVtZW50Ll9fY2FjaGVkQ2hpbGRyZW5MZW5ndGgpIHtcbiAgICAvLyBBdm9pZCB1cGRhdGluZyB0aGUgYXR0cmlidXRlIGlmIHRoZSBjaGlsZHJlbiBsZW5ndGggaGFzbid0IGNoYW5nZWQuXG4gICAgcmV0dXJuO1xuICB9IC8vIEB0cy1pZ25vcmU6OiBpbnRlcm5hbCBmaWVsZFxuXG5cbiAgY29kZUVsZW1lbnQuX19jYWNoZWRDaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuTGVuZ3RoO1xuICBsZXQgZ3V0dGVyID0gJzEnO1xuICBsZXQgY291bnQgPSAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgIGlmIChsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUoY2hpbGRyZW5baV0pKSB7XG4gICAgICBndXR0ZXIgKz0gJ1xcbicgKyArK2NvdW50O1xuICAgIH1cbiAgfVxuXG4gIGNvZGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1ndXR0ZXInLCBndXR0ZXIpO1xufSAvLyBVc2luZyBgc2tpcFRyYW5zZm9ybXNgIHRvIHByZXZlbnQgZXh0cmEgdHJhbnNmb3JtcyBzaW5jZSByZWZvcm1hdHRpbmcgdGhlIGNvZGVcbi8vIHdpbGwgbm90IGFmZmVjdCBjb2RlIGJsb2NrIGNvbnRlbnQgaXRzZWxmLlxuLy9cbi8vIFVzaW5nIGV4dHJhIGNhY2hlIChgbm9kZXNDdXJyZW50bHlIaWdobGlnaHRpbmdgKSBzaW5jZSBib3RoIENvZGVOb2RlIGFuZCBDb2RlSGlnaGxpZ2h0Tm9kZVxuLy8gdHJhbnNmb3JtcyBtaWdodCBiZSBjYWxsZWQgYXQgdGhlIHNhbWUgdGltZSAoZS5nLiBuZXcgQ29kZUhpZ2hsaWdodCBub2RlIGluc2VydGVkKSBhbmRcbi8vIGluIGJvdGggY2FzZXMgd2UnbGwgcmVydW4gd2hvbGUgcmVmb3JtYXR0aW5nIG92ZXIgQ29kZU5vZGUsIHdoaWNoIGlzIHJlZHVuZGFudC5cbi8vIEVzcGVjaWFsbHkgd2hlbiBwYXN0aW5nIGNvZGUgaW50byBDb2RlQmxvY2suXG5cblxuY29uc3Qgbm9kZXNDdXJyZW50bHlIaWdobGlnaHRpbmcgPSBuZXcgU2V0KCk7XG5cbmZ1bmN0aW9uIGNvZGVOb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSB7XG4gIGNvbnN0IG5vZGVLZXkgPSBub2RlLmdldEtleSgpO1xuXG4gIGlmIChub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZy5oYXMobm9kZUtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZy5hZGQobm9kZUtleSk7IC8vIFdoZW4gbmV3IGNvZGUgYmxvY2sgaW5zZXJ0ZWQgaXQgbWlnaHQgbm90IGhhdmUgbGFuZ3VhZ2Ugc2VsZWN0ZWRcblxuICBpZiAobm9kZS5nZXRMYW5ndWFnZSgpID09PSB1bmRlZmluZWQpIHtcbiAgICBub2RlLnNldExhbmd1YWdlKHRva2VuaXplci5kZWZhdWx0TGFuZ3VhZ2UpO1xuICB9IC8vIFVzaW5nIG5lc3RlZCB1cGRhdGUgY2FsbCB0byBwYXNzIGBza2lwVHJhbnNmb3Jtc2Agc2luY2Ugd2UgZG9uJ3Qgd2FudFxuICAvLyBlYWNoIGluZGl2aWR1YWwgY29kZWhpZ2hsaWdodCBub2RlIHRvIGJlIHRyYW5zZm9ybWVkIGFnYWluIGFzIGl0J3MgYWxyZWFkeVxuICAvLyBpbiBpdHMgZmluYWwgc3RhdGVcblxuXG4gIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgIHVwZGF0ZUFuZFJldGFpblNlbGVjdGlvbihub2RlS2V5LCAoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleShub2RlS2V5KTtcblxuICAgICAgaWYgKCEkaXNDb2RlTm9kZShjdXJyZW50Tm9kZSkgfHwgIWN1cnJlbnROb2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvZGUgPSBjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgY29uc3QgdG9rZW5zID0gdG9rZW5pemVyLnRva2VuaXplKGNvZGUsIGN1cnJlbnROb2RlLmdldExhbmd1YWdlKCkgfHwgdG9rZW5pemVyLmRlZmF1bHRMYW5ndWFnZSk7XG4gICAgICBjb25zdCBoaWdobGlnaHROb2RlcyA9IGdldEhpZ2hsaWdodE5vZGVzKHRva2Vucyk7XG4gICAgICBjb25zdCBkaWZmUmFuZ2UgPSBnZXREaWZmUmFuZ2UoY3VycmVudE5vZGUuZ2V0Q2hpbGRyZW4oKSwgaGlnaGxpZ2h0Tm9kZXMpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmcm9tLFxuICAgICAgICB0byxcbiAgICAgICAgbm9kZXNGb3JSZXBsYWNlbWVudFxuICAgICAgfSA9IGRpZmZSYW5nZTtcblxuICAgICAgaWYgKGZyb20gIT09IHRvIHx8IG5vZGVzRm9yUmVwbGFjZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgIG5vZGUuc3BsaWNlKGZyb20sIHRvIC0gZnJvbSwgbm9kZXNGb3JSZXBsYWNlbWVudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH0sIHtcbiAgICBvblVwZGF0ZTogKCkgPT4ge1xuICAgICAgbm9kZXNDdXJyZW50bHlIaWdobGlnaHRpbmcuZGVsZXRlKG5vZGVLZXkpO1xuICAgIH0sXG4gICAgc2tpcFRyYW5zZm9ybXM6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEhpZ2hsaWdodE5vZGVzKHRva2VucywgdHlwZSkge1xuICBjb25zdCBub2RlcyA9IFtdO1xuXG4gIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHBhcnRpYWxzID0gdG9rZW4uc3BsaXQoLyhcXG58XFx0KS8pO1xuICAgICAgY29uc3QgcGFydGlhbHNMZW5ndGggPSBwYXJ0aWFscy5sZW5ndGg7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGlhbHNMZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydGlhbHNbaV07XG5cbiAgICAgICAgaWYgKHBhcnQgPT09ICdcXG4nIHx8IHBhcnQgPT09ICdcXHJcXG4nKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChsZXhpY2FsLiRjcmVhdGVMaW5lQnJlYWtOb2RlKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICdcXHQnKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChsZXhpY2FsLiRjcmVhdGVUYWJOb2RlKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZUNvZGVIaWdobGlnaHROb2RlKHBhcnQsIHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRlbnRcbiAgICAgIH0gPSB0b2tlbjtcblxuICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICBub2Rlcy5wdXNoKC4uLmdldEhpZ2hsaWdodE5vZGVzKFtjb250ZW50XSwgdG9rZW4udHlwZSkpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQpKSB7XG4gICAgICAgIG5vZGVzLnB1c2goLi4uZ2V0SGlnaGxpZ2h0Tm9kZXMoY29udGVudCwgdG9rZW4udHlwZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn0gLy8gV3JhcHBpbmcgdXBkYXRlIGZ1bmN0aW9uIGludG8gc2VsZWN0aW9uIHJldGFpbmVyLCB0aGF0IHRyaWVzIHRvIGtlZXAgY3Vyc29yIGF0IHRoZSBzYW1lXG4vLyBwb3NpdGlvbiBhcyBiZWZvcmUuXG5cblxuZnVuY3Rpb24gdXBkYXRlQW5kUmV0YWluU2VsZWN0aW9uKG5vZGVLZXksIHVwZGF0ZUZuKSB7XG4gIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROb2RlQnlLZXkobm9kZUtleSk7XG5cbiAgaWYgKCEkaXNDb2RlTm9kZShub2RlKSB8fCAhbm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTsgLy8gSWYgaXQncyBub3QgcmFuZ2Ugc2VsZWN0aW9uIChvciBudWxsIHNlbGVjdGlvbikgdGhlcmUncyBubyBuZWVkIHRvIGNoYW5nZSBpdCxcbiAgLy8gYnV0IHdlIGNhbiBzdGlsbCBydW4gaGlnaGxpZ2h0aW5nIGxvZ2ljXG5cbiAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICB1cGRhdGVGbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IGlzTmV3TGluZUFuY2hvciA9IGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgbGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGUuZ2V0Q2hpbGRBdEluZGV4KGFuY2hvci5vZmZzZXQgLSAxKSk7XG4gIGxldCB0ZXh0T2Zmc2V0ID0gMDsgLy8gQ2FsY3VsYXRpbmcgcHJldmlvdXMgdGV4dCBvZmZzZXQgKGFsbCB0ZXh0IG5vZGUgcHJpb3IgdG8gYW5jaG9yICsgYW5jaG9yIG93biB0ZXh0IG9mZnNldClcblxuICBpZiAoIWlzTmV3TGluZUFuY2hvcikge1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIHRleHRPZmZzZXQgPSBhbmNob3JPZmZzZXQgKyBhbmNob3JOb2RlLmdldFByZXZpb3VzU2libGluZ3MoKS5yZWR1Y2UoKG9mZnNldCwgX25vZGUpID0+IHtcbiAgICAgIHJldHVybiBvZmZzZXQgKyBfbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICB9LCAwKTtcbiAgfVxuXG4gIGNvbnN0IGhhc0NoYW5nZXMgPSB1cGRhdGVGbigpO1xuXG4gIGlmICghaGFzQ2hhbmdlcykge1xuICAgIHJldHVybjtcbiAgfSAvLyBOb24tdGV4dCBhbmNob3JzIG9ubHkgaGFwcGVuIGZvciBsaW5lIGJyZWFrcywgb3RoZXJ3aXNlXG4gIC8vIHNlbGVjdGlvbiB3aWxsIGJlIHdpdGhpbiB0ZXh0IG5vZGUgKGNvZGUgaGlnaGxpZ2h0IG5vZGUpXG5cblxuICBpZiAoaXNOZXdMaW5lQW5jaG9yKSB7XG4gICAgYW5jaG9yLmdldE5vZGUoKS5zZWxlY3QoYW5jaG9yT2Zmc2V0LCBhbmNob3JPZmZzZXQpO1xuICAgIHJldHVybjtcbiAgfSAvLyBJZiBpdCB3YXMgbm9uLWVsZW1lbnQgYW5jaG9yIHRoZW4gd2Ugd2FsayB0aHJvdWdoIGNoaWxkIG5vZGVzXG4gIC8vIGFuZCBsb29raW5nIGZvciBhIHBvc2l0aW9uIG9mIG9yaWdpbmFsIHRleHQgb2Zmc2V0XG5cblxuICBub2RlLmdldENoaWxkcmVuKCkuc29tZShfbm9kZSA9PiB7XG4gICAgY29uc3QgaXNUZXh0ID0gbGV4aWNhbC4kaXNUZXh0Tm9kZShfbm9kZSk7XG5cbiAgICBpZiAoaXNUZXh0IHx8IGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShfbm9kZSkpIHtcbiAgICAgIGNvbnN0IHRleHRDb250ZW50U2l6ZSA9IF9ub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuXG4gICAgICBpZiAoaXNUZXh0ICYmIHRleHRDb250ZW50U2l6ZSA+PSB0ZXh0T2Zmc2V0KSB7XG4gICAgICAgIF9ub2RlLnNlbGVjdCh0ZXh0T2Zmc2V0LCB0ZXh0T2Zmc2V0KTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGV4dE9mZnNldCAtPSB0ZXh0Q29udGVudFNpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn0gLy8gRmluZHMgbWluaW1hbCBkaWZmIHJhbmdlIGJldHdlZW4gdHdvIG5vZGVzIGxpc3RzLiBJdCByZXR1cm5zIGZyb20vdG8gcmFuZ2UgYm91bmRhcmllcyBvZiBwcmV2Tm9kZXNcbi8vIHRoYXQgbmVlZHMgdG8gYmUgcmVwbGFjZWQgd2l0aCBgbm9kZXNgIChzdWJzZXQgb2YgbmV4dE5vZGVzKSB0byBtYWtlIHByZXZOb2RlcyBlcXVhbCB0byBuZXh0Tm9kZXMuXG5cblxuZnVuY3Rpb24gZ2V0RGlmZlJhbmdlKHByZXZOb2RlcywgbmV4dE5vZGVzKSB7XG4gIGxldCBsZWFkaW5nTWF0Y2ggPSAwO1xuXG4gIHdoaWxlIChsZWFkaW5nTWF0Y2ggPCBwcmV2Tm9kZXMubGVuZ3RoKSB7XG4gICAgaWYgKCFpc0VxdWFsKHByZXZOb2Rlc1tsZWFkaW5nTWF0Y2hdLCBuZXh0Tm9kZXNbbGVhZGluZ01hdGNoXSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGxlYWRpbmdNYXRjaCsrO1xuICB9XG5cbiAgY29uc3QgcHJldk5vZGVzTGVuZ3RoID0gcHJldk5vZGVzLmxlbmd0aDtcbiAgY29uc3QgbmV4dE5vZGVzTGVuZ3RoID0gbmV4dE5vZGVzLmxlbmd0aDtcbiAgY29uc3QgbWF4VHJhaWxpbmdNYXRjaCA9IE1hdGgubWluKHByZXZOb2Rlc0xlbmd0aCwgbmV4dE5vZGVzTGVuZ3RoKSAtIGxlYWRpbmdNYXRjaDtcbiAgbGV0IHRyYWlsaW5nTWF0Y2ggPSAwO1xuXG4gIHdoaWxlICh0cmFpbGluZ01hdGNoIDwgbWF4VHJhaWxpbmdNYXRjaCkge1xuICAgIHRyYWlsaW5nTWF0Y2grKztcblxuICAgIGlmICghaXNFcXVhbChwcmV2Tm9kZXNbcHJldk5vZGVzTGVuZ3RoIC0gdHJhaWxpbmdNYXRjaF0sIG5leHROb2Rlc1tuZXh0Tm9kZXNMZW5ndGggLSB0cmFpbGluZ01hdGNoXSkpIHtcbiAgICAgIHRyYWlsaW5nTWF0Y2gtLTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGZyb20gPSBsZWFkaW5nTWF0Y2g7XG4gIGNvbnN0IHRvID0gcHJldk5vZGVzTGVuZ3RoIC0gdHJhaWxpbmdNYXRjaDtcbiAgY29uc3Qgbm9kZXNGb3JSZXBsYWNlbWVudCA9IG5leHROb2Rlcy5zbGljZShsZWFkaW5nTWF0Y2gsIG5leHROb2Rlc0xlbmd0aCAtIHRyYWlsaW5nTWF0Y2gpO1xuICByZXR1cm4ge1xuICAgIGZyb20sXG4gICAgbm9kZXNGb3JSZXBsYWNlbWVudCxcbiAgICB0b1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc0VxdWFsKG5vZGVBLCBub2RlQikge1xuICAvLyBPbmx5IGNoZWNraW5nIGZvciBjb2RlIGhpZ2xpZ2h0IG5vZGVzLCB0YWJzIGFuZCBsaW5lYnJlYWtzLiBJZiBpdCdzIHJlZ3VsYXIgdGV4dCBub2RlXG4gIC8vIHJldHVybmluZyBmYWxzZSBzbyB0aGF0IGl0J3MgdHJhbnNmb3JtZWQgaW50byBjb2RlIGhpZ2hsaWdodCBub2RlXG4gIHJldHVybiAkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlQSkgJiYgJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZUIpICYmIG5vZGVBLl9fdGV4dCA9PT0gbm9kZUIuX190ZXh0ICYmIG5vZGVBLl9faGlnaGxpZ2h0VHlwZSA9PT0gbm9kZUIuX19oaWdobGlnaHRUeXBlIHx8IGxleGljYWwuJGlzVGFiTm9kZShub2RlQSkgJiYgbGV4aWNhbC4kaXNUYWJOb2RlKG5vZGVCKSB8fCBsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUobm9kZUEpICYmIGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShub2RlQik7XG59XG5cbmZ1bmN0aW9uICRpc1NlbGVjdGlvbkluQ29kZShzZWxlY3Rpb24pIHtcbiAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG5cbiAgaWYgKGFuY2hvck5vZGUuaXMoZm9jdXNOb2RlKSAmJiAkaXNDb2RlTm9kZShhbmNob3JOb2RlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgYW5jaG9yUGFyZW50ID0gYW5jaG9yTm9kZS5nZXRQYXJlbnQoKTtcbiAgcmV0dXJuICRpc0NvZGVOb2RlKGFuY2hvclBhcmVudCkgJiYgYW5jaG9yUGFyZW50LmlzKGZvY3VzTm9kZS5nZXRQYXJlbnQoKSk7XG59XG5cbmZ1bmN0aW9uICRnZXRDb2RlTGluZXMoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGxpbmVzID0gW1tdXTtcblxuICBpZiAobm9kZXMubGVuZ3RoID09PSAxICYmICRpc0NvZGVOb2RlKG5vZGVzWzBdKSkge1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIGxldCBsYXN0TGluZSA9IGxpbmVzWzBdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAoISgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSB8fCBsZXhpY2FsLiRpc1RhYk5vZGUobm9kZSkgfHwgbGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHNlbGVjdGlvbiB0byBiZSBpbnNpZGUgQ29kZUJsb2NrIGFuZCBjb25zaXN0aW5nIG9mIENvZGVIaWdobGlnaHROb2RlLCBUYWJOb2RlIGFuZCBMaW5lQnJlYWtOb2RlYCk7XG4gICAgfVxuXG4gICAgaWYgKGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShub2RlKSkge1xuICAgICAgaWYgKGkgIT09IDAgJiYgbGFzdExpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICBsYXN0TGluZSA9IFtdO1xuICAgICAgICBsaW5lcy5wdXNoKGxhc3RMaW5lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdExpbmUucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGluZXM7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRhYihzaGlmdEtleSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhJGlzU2VsZWN0aW9uSW5Db2RlKHNlbGVjdGlvbikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGluZGVudE9yT3V0ZGVudCA9ICFzaGlmdEtleSA/IGxleGljYWwuSU5ERU5UX0NPTlRFTlRfQ09NTUFORCA6IGxleGljYWwuT1VUREVOVF9DT05URU5UX0NPTU1BTkQ7XG4gIGNvbnN0IHRhYk9yT3V0ZGVudCA9ICFzaGlmdEtleSA/IGxleGljYWwuSU5TRVJUX1RBQl9DT01NQU5EIDogbGV4aWNhbC5PVVRERU5UX0NPTlRFTlRfQ09NTUFORDsgLy8gMS4gSWYgbXVsdGlwbGUgbGluZXMgc2VsZWN0ZWQ6IGluZGVudC9vdXRkZW50XG5cbiAgY29uc3QgY29kZUxpbmVzID0gJGdldENvZGVMaW5lcyhzZWxlY3Rpb24pO1xuXG4gIGlmIChjb2RlTGluZXMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBpbmRlbnRPck91dGRlbnQ7XG4gIH0gLy8gMi4gSWYgZW50aXJlIGxpbmUgc2VsZWN0ZWQ6IGluZGVudC9vdXRkZW50XG5cblxuICBjb25zdCBzZWxlY3Rpb25Ob2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBmaXJzdE5vZGUgPSBzZWxlY3Rpb25Ob2Rlc1swXTtcblxuICBpZiAoISgkaXNDb2RlTm9kZShmaXJzdE5vZGUpIHx8ICRpc0NvZGVIaWdobGlnaHROb2RlKGZpcnN0Tm9kZSkgfHwgbGV4aWNhbC4kaXNUYWJOb2RlKGZpcnN0Tm9kZSkgfHwgbGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKGZpcnN0Tm9kZSkpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHNlbGVjdGlvbiBmaXJzdE5vZGUgdG8gYmUgQ29kZUhpZ2hsaWdodE5vZGUgb3IgVGFiTm9kZWApO1xuICB9XG5cbiAgaWYgKCRpc0NvZGVOb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICByZXR1cm4gaW5kZW50T3JPdXRkZW50O1xuICB9XG5cbiAgY29uc3QgZmlyc3RPZkxpbmUgPSBnZXRGaXJzdENvZGVOb2RlT2ZMaW5lKGZpcnN0Tm9kZSk7XG4gIGNvbnN0IGxhc3RPZkxpbmUgPSBnZXRMYXN0Q29kZU5vZGVPZkxpbmUoZmlyc3ROb2RlKTtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGxldCBzZWxlY3Rpb25GaXJzdDtcbiAgbGV0IHNlbGVjdGlvbkxhc3Q7XG5cbiAgaWYgKGZvY3VzLmlzQmVmb3JlKGFuY2hvcikpIHtcbiAgICBzZWxlY3Rpb25GaXJzdCA9IGZvY3VzO1xuICAgIHNlbGVjdGlvbkxhc3QgPSBhbmNob3I7XG4gIH0gZWxzZSB7XG4gICAgc2VsZWN0aW9uRmlyc3QgPSBhbmNob3I7XG4gICAgc2VsZWN0aW9uTGFzdCA9IGZvY3VzO1xuICB9XG5cbiAgaWYgKGZpcnN0T2ZMaW5lICE9PSBudWxsICYmIGxhc3RPZkxpbmUgIT09IG51bGwgJiYgc2VsZWN0aW9uRmlyc3Qua2V5ID09PSBmaXJzdE9mTGluZS5nZXRLZXkoKSAmJiBzZWxlY3Rpb25GaXJzdC5vZmZzZXQgPT09IDAgJiYgc2VsZWN0aW9uTGFzdC5rZXkgPT09IGxhc3RPZkxpbmUuZ2V0S2V5KCkgJiYgc2VsZWN0aW9uTGFzdC5vZmZzZXQgPT09IGxhc3RPZkxpbmUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICByZXR1cm4gaW5kZW50T3JPdXRkZW50O1xuICB9IC8vIDMuIEVsc2U6IHRhYi9vdXRkZW50XG5cblxuICByZXR1cm4gdGFiT3JPdXRkZW50O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNdWx0aWxpbmVJbmRlbnQodHlwZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhJGlzU2VsZWN0aW9uSW5Db2RlKHNlbGVjdGlvbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBjb2RlTGluZXMgPSAkZ2V0Q29kZUxpbmVzKHNlbGVjdGlvbik7XG4gIGNvbnN0IGNvZGVMaW5lc0xlbmd0aCA9IGNvZGVMaW5lcy5sZW5ndGg7IC8vIE11bHRpcGxlIGxpbmVzIHNlbGVjdGlvblxuXG4gIGlmIChjb2RlTGluZXMubGVuZ3RoID4gMSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZUxpbmVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBjb2RlTGluZXNbaV07XG5cbiAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IGZpcnN0T2ZMaW5lID0gbGluZVswXTsgLy8gRmlyc3QgYW5kIGxhc3QgbGluZXMgbWlnaHQgbm90IGJlIGNvbXBsZXRlXG5cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBmaXJzdE9mTGluZSA9IGdldEZpcnN0Q29kZU5vZGVPZkxpbmUoZmlyc3RPZkxpbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpcnN0T2ZMaW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IGxleGljYWwuSU5ERU5UX0NPTlRFTlRfQ09NTUFORCkge1xuICAgICAgICAgICAgZmlyc3RPZkxpbmUuaW5zZXJ0QmVmb3JlKGxleGljYWwuJGNyZWF0ZVRhYk5vZGUoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc1RhYk5vZGUoZmlyc3RPZkxpbmUpKSB7XG4gICAgICAgICAgICBmaXJzdE9mTGluZS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBKdXN0IG9uZSBsaW5lXG5cblxuICBjb25zdCBzZWxlY3Rpb25Ob2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBmaXJzdE5vZGUgPSBzZWxlY3Rpb25Ob2Rlc1swXTtcblxuICBpZiAoISgkaXNDb2RlTm9kZShmaXJzdE5vZGUpIHx8ICRpc0NvZGVIaWdobGlnaHROb2RlKGZpcnN0Tm9kZSkgfHwgbGV4aWNhbC4kaXNUYWJOb2RlKGZpcnN0Tm9kZSkgfHwgbGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKGZpcnN0Tm9kZSkpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHNlbGVjdGlvbiBmaXJzdE5vZGUgdG8gYmUgQ29kZUhpZ2hsaWdodE5vZGUgb3IgQ29kZVRhYk5vZGVgKTtcbiAgfVxuXG4gIGlmICgkaXNDb2RlTm9kZShmaXJzdE5vZGUpKSB7XG4gICAgLy8gQ29kZU5vZGUgaXMgZW1wdHlcbiAgICBpZiAodHlwZSA9PT0gbGV4aWNhbC5JTkRFTlRfQ09OVEVOVF9DT01NQU5EKSB7XG4gICAgICBzZWxlY3Rpb24uaW5zZXJ0Tm9kZXMoW2xleGljYWwuJGNyZWF0ZVRhYk5vZGUoKV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgZmlyc3RPZkxpbmUgPSBnZXRGaXJzdENvZGVOb2RlT2ZMaW5lKGZpcnN0Tm9kZSk7XG5cbiAgaWYgKCEoZmlyc3RPZkxpbmUgIT09IG51bGwpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGdldEZpcnN0Q29kZU5vZGVPZkxpbmUgdG8gcmV0dXJuIGEgdmFsaWQgQ29kZSBOb2RlYCk7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gbGV4aWNhbC5JTkRFTlRfQ09OVEVOVF9DT01NQU5EKSB7XG4gICAgaWYgKGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShmaXJzdE9mTGluZSkpIHtcbiAgICAgIGZpcnN0T2ZMaW5lLmluc2VydEFmdGVyKGxleGljYWwuJGNyZWF0ZVRhYk5vZGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0T2ZMaW5lLmluc2VydEJlZm9yZShsZXhpY2FsLiRjcmVhdGVUYWJOb2RlKCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc1RhYk5vZGUoZmlyc3RPZkxpbmUpKSB7XG4gICAgZmlyc3RPZkxpbmUucmVtb3ZlKCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU2hpZnRMaW5lcyh0eXBlLCBldmVudCkge1xuICAvLyBXZSBvbmx5IGNhcmUgYWJvdXQgdGhlIGFsdCthcnJvdyBrZXlzXG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIEknbSBub3QgcXVpdGUgc3VyZSB3aHksIGJ1dCBpdCBzZWVtcyBsaWtlIGNhbGxpbmcgYW5jaG9yLmdldE5vZGUoKSBjb2xsYXBzZXMgdGhlIHNlbGVjdGlvbiBoZXJlXG4gIC8vIFNvIGZpcnN0LCBnZXQgdGhlIGFuY2hvciBhbmQgdGhlIGZvY3VzLCB0aGVuIGdldCB0aGVpciBub2Rlc1xuXG5cbiAgY29uc3Qge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICBjb25zdCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgYXJyb3dJc1VwID0gdHlwZSA9PT0gbGV4aWNhbC5LRVlfQVJST1dfVVBfQ09NTUFORDsgLy8gRW5zdXJlIHRoZSBzZWxlY3Rpb24gaXMgd2l0aGluIHRoZSBjb2RlYmxvY2tcblxuICBpZiAoISRpc1NlbGVjdGlvbkluQ29kZShzZWxlY3Rpb24pIHx8ICEoJGlzQ29kZUhpZ2hsaWdodE5vZGUoYW5jaG9yTm9kZSkgfHwgbGV4aWNhbC4kaXNUYWJOb2RlKGFuY2hvck5vZGUpKSB8fCAhKCRpc0NvZGVIaWdobGlnaHROb2RlKGZvY3VzTm9kZSkgfHwgbGV4aWNhbC4kaXNUYWJOb2RlKGZvY3VzTm9kZSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFldmVudC5hbHRLZXkpIHtcbiAgICAvLyBIYW5kbGUgbW92aW5nIHNlbGVjdGlvbiBvdXQgb2YgdGhlIGNvZGUgYmxvY2ssIGdpdmVuIHRoZXJlIGFyZSBub1xuICAgIC8vIHNpYmxpbmcgdGhhdHMgY2FuIG5hdGl2ZWx5IHRha2UgdGhlIHNlbGVjdGlvbi5cbiAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGNvbnN0IGNvZGVOb2RlID0gYW5jaG9yTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgICAgIGlmIChhcnJvd0lzVXAgJiYgYW5jaG9yT2Zmc2V0ID09PSAwICYmIGFuY2hvck5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29kZU5vZGVTaWJsaW5nID0gY29kZU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICAgICAgaWYgKGNvZGVOb2RlU2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvZGVOb2RlLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghYXJyb3dJc1VwICYmIGFuY2hvck9mZnNldCA9PT0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSAmJiBhbmNob3JOb2RlLmdldE5leHRTaWJsaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29kZU5vZGVTaWJsaW5nID0gY29kZU5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgICBpZiAoY29kZU5vZGVTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgY29kZU5vZGUuc2VsZWN0TmV4dCgpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsZXQgc3RhcnQ7XG4gIGxldCBlbmQ7XG5cbiAgaWYgKGFuY2hvck5vZGUuaXNCZWZvcmUoZm9jdXNOb2RlKSkge1xuICAgIHN0YXJ0ID0gZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZShhbmNob3JOb2RlKTtcbiAgICBlbmQgPSBnZXRMYXN0Q29kZU5vZGVPZkxpbmUoZm9jdXNOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IGdldEZpcnN0Q29kZU5vZGVPZkxpbmUoZm9jdXNOb2RlKTtcbiAgICBlbmQgPSBnZXRMYXN0Q29kZU5vZGVPZkxpbmUoYW5jaG9yTm9kZSk7XG4gIH1cblxuICBpZiAoc3RhcnQgPT0gbnVsbCB8fCBlbmQgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHJhbmdlID0gc3RhcnQuZ2V0Tm9kZXNCZXR3ZWVuKGVuZCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSByYW5nZVtpXTtcblxuICAgIGlmICghJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkgJiYgIWxleGljYWwuJGlzVGFiTm9kZShub2RlKSAmJiAhbGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIEFmdGVyIHRoaXMgcG9pbnQsIHdlIGtub3cgdGhlIHNlbGVjdGlvbiBpcyB3aXRoaW4gdGhlIGNvZGVibG9jay4gV2UgbWF5IG5vdCBiZSBhYmxlIHRvXG4gIC8vIGFjdHVhbGx5IG1vdmUgdGhlIGxpbmVzIGFyb3VuZCwgYnV0IHdlIHdhbnQgdG8gcmV0dXJuIHRydWUgZWl0aGVyIHdheSB0byBwcmV2ZW50XG4gIC8vIHRoZSBldmVudCdzIGRlZmF1bHQgYmVoYXZpb3JcblxuXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyByZXF1aXJlZCB0byBzdG9wIGN1cnNvciBtb3ZlbWVudCB1bmRlciBGaXJlZm94XG5cbiAgY29uc3QgbGluZWJyZWFrID0gYXJyb3dJc1VwID8gc3RhcnQuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBlbmQuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICBpZiAoIWxleGljYWwuJGlzTGluZUJyZWFrTm9kZShsaW5lYnJlYWspKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBzaWJsaW5nID0gYXJyb3dJc1VwID8gbGluZWJyZWFrLmdldFByZXZpb3VzU2libGluZygpIDogbGluZWJyZWFrLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgaWYgKHNpYmxpbmcgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgbWF5YmVJbnNlcnRpb25Qb2ludCA9ICRpc0NvZGVIaWdobGlnaHROb2RlKHNpYmxpbmcpIHx8IGxleGljYWwuJGlzVGFiTm9kZShzaWJsaW5nKSB8fCBsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUoc2libGluZykgPyBhcnJvd0lzVXAgPyBnZXRGaXJzdENvZGVOb2RlT2ZMaW5lKHNpYmxpbmcpIDogZ2V0TGFzdENvZGVOb2RlT2ZMaW5lKHNpYmxpbmcpIDogbnVsbDtcbiAgbGV0IGluc2VydGlvblBvaW50ID0gbWF5YmVJbnNlcnRpb25Qb2ludCAhPSBudWxsID8gbWF5YmVJbnNlcnRpb25Qb2ludCA6IHNpYmxpbmc7XG4gIGxpbmVicmVhay5yZW1vdmUoKTtcbiAgcmFuZ2UuZm9yRWFjaChub2RlID0+IG5vZGUucmVtb3ZlKCkpO1xuXG4gIGlmICh0eXBlID09PSBsZXhpY2FsLktFWV9BUlJPV19VUF9DT01NQU5EKSB7XG4gICAgcmFuZ2UuZm9yRWFjaChub2RlID0+IGluc2VydGlvblBvaW50Lmluc2VydEJlZm9yZShub2RlKSk7XG4gICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QmVmb3JlKGxpbmVicmVhayk7XG4gIH0gZWxzZSB7XG4gICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QWZ0ZXIobGluZWJyZWFrKTtcbiAgICBpbnNlcnRpb25Qb2ludCA9IGxpbmVicmVhaztcbiAgICByYW5nZS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QWZ0ZXIobm9kZSk7XG4gICAgICBpbnNlcnRpb25Qb2ludCA9IG5vZGU7XG4gICAgfSk7XG4gIH1cblxuICBzZWxlY3Rpb24uc2V0VGV4dE5vZGVSYW5nZShhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTW92ZVRvKHR5cGUsIGV2ZW50KSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICBjb25zdCBpc01vdmVUb1N0YXJ0ID0gdHlwZSA9PT0gbGV4aWNhbC5NT1ZFX1RPX1NUQVJUO1xuXG4gIGlmICghKCRpc0NvZGVIaWdobGlnaHROb2RlKGFuY2hvck5vZGUpIHx8IGxleGljYWwuJGlzVGFiTm9kZShhbmNob3JOb2RlKSkgfHwgISgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShmb2N1c05vZGUpIHx8IGxleGljYWwuJGlzVGFiTm9kZShmb2N1c05vZGUpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc01vdmVUb1N0YXJ0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBnZXRTdGFydE9mQ29kZUluTGluZShmb2N1c05vZGUsIGZvY3VzLm9mZnNldCk7XG5cbiAgICBpZiAoc3RhcnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gc3RhcnQ7XG5cbiAgICAgIGlmIChsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUobm9kZSkpIHtcbiAgICAgICAgbm9kZS5zZWxlY3ROZXh0KDAsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2Uobm9kZSwgb2Zmc2V0LCBub2RlLCBvZmZzZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb2N1c05vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdFN0YXJ0KCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5vZGUgPSBnZXRFbmRPZkNvZGVJbkxpbmUoZm9jdXNOb2RlKTtcbiAgICBub2RlLnNlbGVjdCgpO1xuICB9XG5cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckNvZGVIaWdobGlnaHRpbmcoZWRpdG9yLCB0b2tlbml6ZXIpIHtcbiAgaWYgKCFlZGl0b3IuaGFzTm9kZXMoW0NvZGVOb2RlLCBDb2RlSGlnaGxpZ2h0Tm9kZV0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlSGlnaGxpZ2h0UGx1Z2luOiBDb2RlTm9kZSBvciBDb2RlSGlnaGxpZ2h0Tm9kZSBub3QgcmVnaXN0ZXJlZCBvbiBlZGl0b3InKTtcbiAgfVxuXG4gIGlmICh0b2tlbml6ZXIgPT0gbnVsbCkge1xuICAgIHRva2VuaXplciA9IFByaXNtVG9rZW5pemVyO1xuICB9XG5cbiAgcmV0dXJuIHV0aWxzLm1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyTXV0YXRpb25MaXN0ZW5lcihDb2RlTm9kZSwgbXV0YXRpb25zID0+IHtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdHlwZV0gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlICE9PSAnZGVzdHJveWVkJykge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROb2RlQnlLZXkoa2V5KTtcblxuICAgICAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1cGRhdGVDb2RlR3V0dGVyKG5vZGUsIGVkaXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLCBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKENvZGVOb2RlLCBub2RlID0+IGNvZGVOb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0obGV4aWNhbC5UZXh0Tm9kZSwgbm9kZSA9PiB0ZXh0Tm9kZVRyYW5zZm9ybShub2RlLCBlZGl0b3IsIHRva2VuaXplcikpLCBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKENvZGVIaWdobGlnaHROb2RlLCBub2RlID0+IHRleHROb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfVEFCX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBjb21tYW5kID0gaGFuZGxlVGFiKGV2ZW50LnNoaWZ0S2V5KTtcblxuICAgIGlmIChjb21tYW5kID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGNvbW1hbmQsIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuSU5TRVJUX1RBQl9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoISRpc1NlbGVjdGlvbkluQ29kZShzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV4aWNhbC4kaW5zZXJ0Tm9kZXMoW2xleGljYWwuJGNyZWF0ZVRhYk5vZGUoKV0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLklOREVOVF9DT05URU5UX0NPTU1BTkQsIHBheWxvYWQgPT4gaGFuZGxlTXVsdGlsaW5lSW5kZW50KGxleGljYWwuSU5ERU5UX0NPTlRFTlRfQ09NTUFORCksIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuT1VUREVOVF9DT05URU5UX0NPTU1BTkQsIHBheWxvYWQgPT4gaGFuZGxlTXVsdGlsaW5lSW5kZW50KGxleGljYWwuT1VUREVOVF9DT05URU5UX0NPTU1BTkQpLCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9BUlJPV19VUF9DT01NQU5ELCBwYXlsb2FkID0+IGhhbmRsZVNoaWZ0TGluZXMobGV4aWNhbC5LRVlfQVJST1dfVVBfQ09NTUFORCwgcGF5bG9hZCksIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgcGF5bG9hZCA9PiBoYW5kbGVTaGlmdExpbmVzKGxleGljYWwuS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgcGF5bG9hZCksIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuTU9WRV9UT19FTkQsIHBheWxvYWQgPT4gaGFuZGxlTW92ZVRvKGxleGljYWwuTU9WRV9UT19FTkQsIHBheWxvYWQpLCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLk1PVkVfVE9fU1RBUlQsIHBheWxvYWQgPT4gaGFuZGxlTW92ZVRvKGxleGljYWwuTU9WRV9UT19TVEFSVCwgcGF5bG9hZCksIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpKTtcbn1cblxuZXhwb3J0cy4kY3JlYXRlQ29kZUhpZ2hsaWdodE5vZGUgPSAkY3JlYXRlQ29kZUhpZ2hsaWdodE5vZGU7XG5leHBvcnRzLiRjcmVhdGVDb2RlTm9kZSA9ICRjcmVhdGVDb2RlTm9kZTtcbmV4cG9ydHMuJGlzQ29kZUhpZ2hsaWdodE5vZGUgPSAkaXNDb2RlSGlnaGxpZ2h0Tm9kZTtcbmV4cG9ydHMuJGlzQ29kZU5vZGUgPSAkaXNDb2RlTm9kZTtcbmV4cG9ydHMuQ09ERV9MQU5HVUFHRV9GUklFTkRMWV9OQU1FX01BUCA9IENPREVfTEFOR1VBR0VfRlJJRU5ETFlfTkFNRV9NQVA7XG5leHBvcnRzLkNPREVfTEFOR1VBR0VfTUFQID0gQ09ERV9MQU5HVUFHRV9NQVA7XG5leHBvcnRzLkNvZGVIaWdobGlnaHROb2RlID0gQ29kZUhpZ2hsaWdodE5vZGU7XG5leHBvcnRzLkNvZGVOb2RlID0gQ29kZU5vZGU7XG5leHBvcnRzLkRFRkFVTFRfQ09ERV9MQU5HVUFHRSA9IERFRkFVTFRfQ09ERV9MQU5HVUFHRTtcbmV4cG9ydHMuUHJpc21Ub2tlbml6ZXIgPSBQcmlzbVRva2VuaXplcjtcbmV4cG9ydHMuZ2V0Q29kZUxhbmd1YWdlcyA9IGdldENvZGVMYW5ndWFnZXM7XG5leHBvcnRzLmdldERlZmF1bHRDb2RlTGFuZ3VhZ2UgPSBnZXREZWZhdWx0Q29kZUxhbmd1YWdlO1xuZXhwb3J0cy5nZXRFbmRPZkNvZGVJbkxpbmUgPSBnZXRFbmRPZkNvZGVJbkxpbmU7XG5leHBvcnRzLmdldEZpcnN0Q29kZU5vZGVPZkxpbmUgPSBnZXRGaXJzdENvZGVOb2RlT2ZMaW5lO1xuZXhwb3J0cy5nZXRMYW5ndWFnZUZyaWVuZGx5TmFtZSA9IGdldExhbmd1YWdlRnJpZW5kbHlOYW1lO1xuZXhwb3J0cy5nZXRMYXN0Q29kZU5vZGVPZkxpbmUgPSBnZXRMYXN0Q29kZU5vZGVPZkxpbmU7XG5leHBvcnRzLmdldFN0YXJ0T2ZDb2RlSW5MaW5lID0gZ2V0U3RhcnRPZkNvZGVJbkxpbmU7XG5leHBvcnRzLm5vcm1hbGl6ZUNvZGVMYW5nID0gbm9ybWFsaXplQ29kZUxhbmc7XG5leHBvcnRzLnJlZ2lzdGVyQ29kZUhpZ2hsaWdodGluZyA9IHJlZ2lzdGVyQ29kZUhpZ2hsaWdodGluZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/code/LexicalCode.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/code/LexicalCode.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/code/LexicalCode.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalCode =  true ? __webpack_require__(/*! ./LexicalCode.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/code/LexicalCode.dev.js\") : 0\nmodule.exports = LexicalCode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jb2RlL0xleGljYWxDb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osb0JBQW9CLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxpR0FBc0IsSUFBSSxDQUFnQztBQUMvSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY29kZS9MZXhpY2FsQ29kZS5qcz9mNmY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsQ29kZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsQ29kZS5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbENvZGUucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxDb2RlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/code/LexicalCode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/dragon/LexicalDragon.dev.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lexical/dragon/LexicalDragon.dev.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/dragon */\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n\n    const rootElement = editor.getRootElement();\n\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n\n    const data = event.data;\n\n    if (typeof data === 'string') {\n      let parsedData;\n\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args; // TODO: we should probably handle formatCommand somehow?\n            editor.update(() => {\n              const selection = lexical.$getSelection();\n\n              if (lexical.$isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength; // If the offset is more than the end, make it the end\n\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize(); // If the offset is more than the end, make it the end\n\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                } // block the chrome extension from handling this event\n\n\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\nexports.registerDragonSupport = registerDragonSupport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9kcmFnb24vTGV4aWNhbERyYWdvbi5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHNFQUFTOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjs7QUFFaEY7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOzs7QUFHbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9kcmFnb24vTGV4aWNhbERyYWdvbi5kZXYuanM/NTQ1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG5cbi8qKiBAbW9kdWxlIEBsZXhpY2FsL2RyYWdvbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJEcmFnb25TdXBwb3J0KGVkaXRvcikge1xuICBjb25zdCBvcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuXG4gIGNvbnN0IGhhbmRsZXIgPSBldmVudCA9PiB7XG4gICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gb3JpZ2luKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcblxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSByb290RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IHBhcnNlZERhdGE7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJzZWREYXRhICYmIHBhcnNlZERhdGEucHJvdG9jb2wgPT09ICdudWFucmlhX21lc3NhZ2luZycgJiYgcGFyc2VkRGF0YS50eXBlID09PSAncmVxdWVzdCcpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHBhcnNlZERhdGEucGF5bG9hZDtcblxuICAgICAgICBpZiAocGF5bG9hZCAmJiBwYXlsb2FkLmZ1bmN0aW9uSWQgPT09ICdtYWtlQ2hhbmdlcycpIHtcbiAgICAgICAgICBjb25zdCBhcmdzID0gcGF5bG9hZC5hcmdzO1xuXG4gICAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IFtlbGVtZW50U3RhcnQsIGVsZW1lbnRMZW5ndGgsIHRleHQsIHNlbFN0YXJ0LCBzZWxMZW5ndGgsIGZvcm1hdENvbW1hbmRdID0gYXJnczsgLy8gVE9ETzogd2Ugc2hvdWxkIHByb2JhYmx5IGhhbmRsZSBmb3JtYXRDb21tYW5kIHNvbWVob3c/XG4gICAgICAgICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgICAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgICAgICAgICAgbGV0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIGxldCBzZXRTZWxTdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgbGV0IHNldFNlbEVuZCA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgLy8gc2V0IGluaXRpYWwgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFN0YXJ0ID49IDAgJiYgZWxlbWVudExlbmd0aCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFNlbFN0YXJ0ID0gZWxlbWVudFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBzZXRTZWxFbmQgPSBlbGVtZW50U3RhcnQgKyBlbGVtZW50TGVuZ3RoOyAvLyBJZiB0aGUgb2Zmc2V0IGlzIG1vcmUgdGhhbiB0aGUgZW5kLCBtYWtlIGl0IHRoZSBlbmRcblxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc2V0VGV4dE5vZGVSYW5nZShhbmNob3JOb2RlLCBzZXRTZWxTdGFydCwgYW5jaG9yTm9kZSwgc2V0U2VsRW5kKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0U2VsU3RhcnQgIT09IHNldFNlbEVuZCB8fCB0ZXh0ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmluc2VydFJhd1RleHQodGV4dCk7XG4gICAgICAgICAgICAgICAgICBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgLy8gc2V0IGZpbmFsIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgc2V0U2VsU3RhcnQgPSBzZWxTdGFydDtcbiAgICAgICAgICAgICAgICAgIHNldFNlbEVuZCA9IHNlbFN0YXJ0ICsgc2VsTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yTm9kZVRleHRMZW5ndGggPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpOyAvLyBJZiB0aGUgb2Zmc2V0IGlzIG1vcmUgdGhhbiB0aGUgZW5kLCBtYWtlIGl0IHRoZSBlbmRcblxuICAgICAgICAgICAgICAgICAgc2V0U2VsU3RhcnQgPSBzZXRTZWxTdGFydCA+IGFuY2hvck5vZGVUZXh0TGVuZ3RoID8gYW5jaG9yTm9kZVRleHRMZW5ndGggOiBzZXRTZWxTdGFydDtcbiAgICAgICAgICAgICAgICAgIHNldFNlbEVuZCA9IHNldFNlbEVuZCA+IGFuY2hvck5vZGVUZXh0TGVuZ3RoID8gYW5jaG9yTm9kZVRleHRMZW5ndGggOiBzZXRTZWxFbmQ7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uc2V0VGV4dE5vZGVSYW5nZShhbmNob3JOb2RlLCBzZXRTZWxTdGFydCwgYW5jaG9yTm9kZSwgc2V0U2VsRW5kKTtcbiAgICAgICAgICAgICAgICB9IC8vIGJsb2NrIHRoZSBjaHJvbWUgZXh0ZW5zaW9uIGZyb20gaGFuZGxpbmcgdGhpcyBldmVudFxuXG5cbiAgICAgICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlciwgdHJ1ZSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgfTtcbn1cblxuZXhwb3J0cy5yZWdpc3RlckRyYWdvblN1cHBvcnQgPSByZWdpc3RlckRyYWdvblN1cHBvcnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/dragon/LexicalDragon.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/dragon/LexicalDragon.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/dragon/LexicalDragon.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalDragon =  true ? __webpack_require__(/*! ./LexicalDragon.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/dragon/LexicalDragon.dev.js\") : 0\nmodule.exports = LexicalDragon;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9kcmFnb24vTGV4aWNhbERyYWdvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLHNCQUFzQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsdUdBQXdCLElBQUksQ0FBa0M7QUFDckkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2RyYWdvbi9MZXhpY2FsRHJhZ29uLmpzPzkzYjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxEcmFnb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbERyYWdvbi5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbERyYWdvbi5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbERyYWdvbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/dragon/LexicalDragon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/history/LexicalHistory.dev.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/history/LexicalHistory.dev.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/history */\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\n\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n\n    if (dirtyElement !== undefined && !lexical.$isRootNode(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n\n  return nodes;\n}\n\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n\n  if (!lexical.$isRangeSelection(nextSelection) || !lexical.$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  } // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n\n\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && lexical.$isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n\n    return OTHER;\n  }\n\n  const nextDirtyNode = dirtyNodes[0];\n\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n\n  if (!lexical.$isTextNode(prevDirtyNode) || !lexical.$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n\n  if (prevText === nextText) {\n    return OTHER;\n  }\n\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n\n  return OTHER;\n}\n\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n\n  const nextNode = nextEditorState._nodeMap.get(key);\n\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  let isDeletingLine = false;\n\n  if (lexical.$isRangeSelection(prevSelection) && lexical.$isRangeSelection(nextSelection)) {\n    isDeletingLine = prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  }\n\n  if (!isDeletingLine && lexical.$isTextNode(prevNode) && lexical.$isTextNode(nextNode)) {\n    return prevNode.__type === nextNode.__type && prevNode.__text === nextNode.__text && prevNode.__mode === nextNode.__mode && prevNode.__detail === nextNode.__detail && prevNode.__style === nextNode.__style && prevNode.__format === nextNode.__format && prevNode.__parent === nextNode.__parent;\n  }\n\n  return false;\n}\n\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now(); // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\n\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      } // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n\n\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n\n      return HISTORY_PUSH;\n    })();\n\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\n\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\n    }\n\n    const historyStateEntry = redoStack.pop();\n\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n    }\n\n    historyState.current = historyStateEntry || null;\n\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\n\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, true);\n    }\n\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\n    }\n\n    historyState.current = historyStateEntry || null;\n\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\n\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\n\n\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n      }\n\n      if (current !== null) {\n        undoStack.push({ ...current\n        });\n        editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    } // Else we merge\n\n\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n\n  const unregisterCommandListener = utils.mergeRegister(editor.registerCommand(lexical.UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  const unregisterUpdateListener = editor.registerUpdateListener(applyChange);\n  return () => {\n    unregisterCommandListener();\n    unregisterUpdateListener();\n  };\n}\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\n\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\nexports.createEmptyHistoryState = createEmptyHistoryState;\nexports.registerHistory = registerHistory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9oaXN0b3J5L0xleGljYWxIaXN0b3J5LmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMseUZBQWdCO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QixTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0IsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9oaXN0b3J5L0xleGljYWxIaXN0b3J5LmRldi5qcz85Yjk5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG5cbi8qKiBAbW9kdWxlIEBsZXhpY2FsL2hpc3RvcnkgKi9cbmNvbnN0IEhJU1RPUllfTUVSR0UgPSAwO1xuY29uc3QgSElTVE9SWV9QVVNIID0gMTtcbmNvbnN0IERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEUgPSAyO1xuY29uc3QgT1RIRVIgPSAwO1xuY29uc3QgQ09NUE9TSU5HX0NIQVJBQ1RFUiA9IDE7XG5jb25zdCBJTlNFUlRfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTiA9IDI7XG5jb25zdCBERUxFVEVfQ0hBUkFDVEVSX0JFRk9SRV9TRUxFQ1RJT04gPSAzO1xuY29uc3QgREVMRVRFX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT04gPSA0O1xuXG5mdW5jdGlvbiBnZXREaXJ0eU5vZGVzKGVkaXRvclN0YXRlLCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cykge1xuICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IG5vZGVzID0gW107XG5cbiAgZm9yIChjb25zdCBkaXJ0eUxlYWZLZXkgb2YgZGlydHlMZWF2ZXMpIHtcbiAgICBjb25zdCBkaXJ0eUxlYWYgPSBub2RlTWFwLmdldChkaXJ0eUxlYWZLZXkpO1xuXG4gICAgaWYgKGRpcnR5TGVhZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBub2Rlcy5wdXNoKGRpcnR5TGVhZik7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBbZGlydHlFbGVtZW50S2V5LCBpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eV0gb2YgZGlydHlFbGVtZW50cykge1xuICAgIGlmICghaW50ZW50aW9uYWxseU1hcmtlZEFzRGlydHkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGRpcnR5RWxlbWVudCA9IG5vZGVNYXAuZ2V0KGRpcnR5RWxlbWVudEtleSk7XG5cbiAgICBpZiAoZGlydHlFbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgIWxleGljYWwuJGlzUm9vdE5vZGUoZGlydHlFbGVtZW50KSkge1xuICAgICAgbm9kZXMucHVzaChkaXJ0eUVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn1cblxuZnVuY3Rpb24gZ2V0Q2hhbmdlVHlwZShwcmV2RWRpdG9yU3RhdGUsIG5leHRFZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXNTZXQsIGRpcnR5RWxlbWVudHNTZXQsIGlzQ29tcG9zaW5nKSB7XG4gIGlmIChwcmV2RWRpdG9yU3RhdGUgPT09IG51bGwgfHwgZGlydHlMZWF2ZXNTZXQuc2l6ZSA9PT0gMCAmJiBkaXJ0eUVsZW1lbnRzU2V0LnNpemUgPT09IDAgJiYgIWlzQ29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG5cbiAgY29uc3QgbmV4dFNlbGVjdGlvbiA9IG5leHRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBwcmV2U2VsZWN0aW9uID0gcHJldkVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG5cbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIENPTVBPU0lOR19DSEFSQUNURVI7XG4gIH1cblxuICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24obmV4dFNlbGVjdGlvbikgfHwgIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgfHwgIXByZXZTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCAhbmV4dFNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG5cbiAgY29uc3QgZGlydHlOb2RlcyA9IGdldERpcnR5Tm9kZXMobmV4dEVkaXRvclN0YXRlLCBkaXJ0eUxlYXZlc1NldCwgZGlydHlFbGVtZW50c1NldCk7XG5cbiAgaWYgKGRpcnR5Tm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9IC8vIENhdGNoaW5nIHRoZSBjYXNlIHdoZW4gaW5zZXJ0aW5nIG5ldyB0ZXh0IG5vZGUgaW50byBhbiBlbGVtZW50IChlLmcuIGZpcnN0IGNoYXIgaW4gcGFyYWdyYXBoL2xpc3QpLFxuICAvLyBvciBhZnRlciBleGlzdGluZyBub2RlLlxuXG5cbiAgaWYgKGRpcnR5Tm9kZXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG5leHROb2RlTWFwID0gbmV4dEVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICAgIGNvbnN0IG5leHRBbmNob3JOb2RlID0gbmV4dE5vZGVNYXAuZ2V0KG5leHRTZWxlY3Rpb24uYW5jaG9yLmtleSk7XG4gICAgY29uc3QgcHJldkFuY2hvck5vZGUgPSBuZXh0Tm9kZU1hcC5nZXQocHJldlNlbGVjdGlvbi5hbmNob3Iua2V5KTtcblxuICAgIGlmIChuZXh0QW5jaG9yTm9kZSAmJiBwcmV2QW5jaG9yTm9kZSAmJiAhcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwLmhhcyhuZXh0QW5jaG9yTm9kZS5fX2tleSkgJiYgbGV4aWNhbC4kaXNUZXh0Tm9kZShuZXh0QW5jaG9yTm9kZSkgJiYgbmV4dEFuY2hvck5vZGUuX190ZXh0Lmxlbmd0aCA9PT0gMSAmJiBuZXh0U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDEpIHtcbiAgICAgIHJldHVybiBJTlNFUlRfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTjtcbiAgICB9XG5cbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cblxuICBjb25zdCBuZXh0RGlydHlOb2RlID0gZGlydHlOb2Rlc1swXTtcblxuICBjb25zdCBwcmV2RGlydHlOb2RlID0gcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChuZXh0RGlydHlOb2RlLl9fa2V5KTtcblxuICBpZiAoIWxleGljYWwuJGlzVGV4dE5vZGUocHJldkRpcnR5Tm9kZSkgfHwgIWxleGljYWwuJGlzVGV4dE5vZGUobmV4dERpcnR5Tm9kZSkgfHwgcHJldkRpcnR5Tm9kZS5fX21vZGUgIT09IG5leHREaXJ0eU5vZGUuX19tb2RlKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG5cbiAgY29uc3QgcHJldlRleHQgPSBwcmV2RGlydHlOb2RlLl9fdGV4dDtcbiAgY29uc3QgbmV4dFRleHQgPSBuZXh0RGlydHlOb2RlLl9fdGV4dDtcblxuICBpZiAocHJldlRleHQgPT09IG5leHRUZXh0KSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG5cbiAgY29uc3QgbmV4dEFuY2hvciA9IG5leHRTZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBwcmV2QW5jaG9yID0gcHJldlNlbGVjdGlvbi5hbmNob3I7XG5cbiAgaWYgKG5leHRBbmNob3Iua2V5ICE9PSBwcmV2QW5jaG9yLmtleSB8fCBuZXh0QW5jaG9yLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuXG4gIGNvbnN0IG5leHRBbmNob3JPZmZzZXQgPSBuZXh0QW5jaG9yLm9mZnNldDtcbiAgY29uc3QgcHJldkFuY2hvck9mZnNldCA9IHByZXZBbmNob3Iub2Zmc2V0O1xuICBjb25zdCB0ZXh0RGlmZiA9IG5leHRUZXh0Lmxlbmd0aCAtIHByZXZUZXh0Lmxlbmd0aDtcblxuICBpZiAodGV4dERpZmYgPT09IDEgJiYgcHJldkFuY2hvck9mZnNldCA9PT0gbmV4dEFuY2hvck9mZnNldCAtIDEpIHtcbiAgICByZXR1cm4gSU5TRVJUX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT047XG4gIH1cblxuICBpZiAodGV4dERpZmYgPT09IC0xICYmIHByZXZBbmNob3JPZmZzZXQgPT09IG5leHRBbmNob3JPZmZzZXQgKyAxKSB7XG4gICAgcmV0dXJuIERFTEVURV9DSEFSQUNURVJfQkVGT1JFX1NFTEVDVElPTjtcbiAgfVxuXG4gIGlmICh0ZXh0RGlmZiA9PT0gLTEgJiYgcHJldkFuY2hvck9mZnNldCA9PT0gbmV4dEFuY2hvck9mZnNldCkge1xuICAgIHJldHVybiBERUxFVEVfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTjtcbiAgfVxuXG4gIHJldHVybiBPVEhFUjtcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZVVuY2hhbmdlZChrZXksIHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IHByZXZOb2RlID0gcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChrZXkpO1xuXG4gIGNvbnN0IG5leHROb2RlID0gbmV4dEVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChrZXkpO1xuXG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBwcmV2RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgY29uc3QgbmV4dFNlbGVjdGlvbiA9IG5leHRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBsZXQgaXNEZWxldGluZ0xpbmUgPSBmYWxzZTtcblxuICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKG5leHRTZWxlY3Rpb24pKSB7XG4gICAgaXNEZWxldGluZ0xpbmUgPSBwcmV2U2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgcHJldlNlbGVjdGlvbi5mb2N1cy50eXBlID09PSAnZWxlbWVudCcgJiYgbmV4dFNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ3RleHQnICYmIG5leHRTZWxlY3Rpb24uZm9jdXMudHlwZSA9PT0gJ3RleHQnO1xuICB9XG5cbiAgaWYgKCFpc0RlbGV0aW5nTGluZSAmJiBsZXhpY2FsLiRpc1RleHROb2RlKHByZXZOb2RlKSAmJiBsZXhpY2FsLiRpc1RleHROb2RlKG5leHROb2RlKSkge1xuICAgIHJldHVybiBwcmV2Tm9kZS5fX3R5cGUgPT09IG5leHROb2RlLl9fdHlwZSAmJiBwcmV2Tm9kZS5fX3RleHQgPT09IG5leHROb2RlLl9fdGV4dCAmJiBwcmV2Tm9kZS5fX21vZGUgPT09IG5leHROb2RlLl9fbW9kZSAmJiBwcmV2Tm9kZS5fX2RldGFpbCA9PT0gbmV4dE5vZGUuX19kZXRhaWwgJiYgcHJldk5vZGUuX19zdHlsZSA9PT0gbmV4dE5vZGUuX19zdHlsZSAmJiBwcmV2Tm9kZS5fX2Zvcm1hdCA9PT0gbmV4dE5vZGUuX19mb3JtYXQgJiYgcHJldk5vZGUuX19wYXJlbnQgPT09IG5leHROb2RlLl9fcGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNZXJnZUFjdGlvbkdldHRlcihlZGl0b3IsIGRlbGF5KSB7XG4gIGxldCBwcmV2Q2hhbmdlVGltZSA9IERhdGUubm93KCk7XG4gIGxldCBwcmV2Q2hhbmdlVHlwZSA9IE9USEVSO1xuICByZXR1cm4gKHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlLCBjdXJyZW50SGlzdG9yeUVudHJ5LCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cywgdGFncykgPT4ge1xuICAgIGNvbnN0IGNoYW5nZVRpbWUgPSBEYXRlLm5vdygpOyAvLyBJZiBhcHBseWluZyBjaGFuZ2VzIGZyb20gaGlzdG9yeSBzdGFjayB0aGVyZSdzIG5vIG5lZWRcbiAgICAvLyB0byBydW4gaGlzdG9yeSBsb2dpYyBhZ2FpbiwgYXMgaGlzdG9yeSBlbnRyaWVzIGFscmVhZHkgY2FsY3VsYXRlZFxuXG4gICAgaWYgKHRhZ3MuaGFzKCdoaXN0b3JpYycpKSB7XG4gICAgICBwcmV2Q2hhbmdlVHlwZSA9IE9USEVSO1xuICAgICAgcHJldkNoYW5nZVRpbWUgPSBjaGFuZ2VUaW1lO1xuICAgICAgcmV0dXJuIERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEU7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbmdlVHlwZSA9IGdldENoYW5nZVR5cGUocHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzLCBkaXJ0eUVsZW1lbnRzLCBlZGl0b3IuaXNDb21wb3NpbmcoKSk7XG5cbiAgICBjb25zdCBtZXJnZUFjdGlvbiA9ICgoKSA9PiB7XG4gICAgICBjb25zdCBpc1NhbWVFZGl0b3IgPSBjdXJyZW50SGlzdG9yeUVudHJ5ID09PSBudWxsIHx8IGN1cnJlbnRIaXN0b3J5RW50cnkuZWRpdG9yID09PSBlZGl0b3I7XG4gICAgICBjb25zdCBzaG91bGRQdXNoSGlzdG9yeSA9IHRhZ3MuaGFzKCdoaXN0b3J5LXB1c2gnKTtcbiAgICAgIGNvbnN0IHNob3VsZE1lcmdlSGlzdG9yeSA9ICFzaG91bGRQdXNoSGlzdG9yeSAmJiBpc1NhbWVFZGl0b3IgJiYgdGFncy5oYXMoJ2hpc3RvcnktbWVyZ2UnKTtcblxuICAgICAgaWYgKHNob3VsZE1lcmdlSGlzdG9yeSkge1xuICAgICAgICByZXR1cm4gSElTVE9SWV9NRVJHRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gSElTVE9SWV9QVVNIO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBuZXh0RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgICAgIGNvbnN0IGhhc0RpcnR5Tm9kZXMgPSBkaXJ0eUxlYXZlcy5zaXplID4gMCB8fCBkaXJ0eUVsZW1lbnRzLnNpemUgPiAwO1xuXG4gICAgICBpZiAoIWhhc0RpcnR5Tm9kZXMpIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBISVNUT1JZX01FUkdFO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRQdXNoSGlzdG9yeSA9PT0gZmFsc2UgJiYgY2hhbmdlVHlwZSAhPT0gT1RIRVIgJiYgY2hhbmdlVHlwZSA9PT0gcHJldkNoYW5nZVR5cGUgJiYgY2hhbmdlVGltZSA8IHByZXZDaGFuZ2VUaW1lICsgZGVsYXkgJiYgaXNTYW1lRWRpdG9yKSB7XG4gICAgICAgIHJldHVybiBISVNUT1JZX01FUkdFO1xuICAgICAgfSAvLyBBIHNpbmdsZSBub2RlIG1pZ2h0IGhhdmUgYmVlbiBtYXJrZWQgYXMgZGlydHksIGJ1dCBub3QgaGF2ZSBjaGFuZ2VkXG4gICAgICAvLyBkdWUgdG8gc29tZSBub2RlIHRyYW5zZm9ybSByZXZlcnRpbmcgdGhlIGNoYW5nZS5cblxuXG4gICAgICBpZiAoZGlydHlMZWF2ZXMuc2l6ZSA9PT0gMSkge1xuICAgICAgICBjb25zdCBkaXJ0eUxlYWZLZXkgPSBBcnJheS5mcm9tKGRpcnR5TGVhdmVzKVswXTtcblxuICAgICAgICBpZiAoaXNUZXh0Tm9kZVVuY2hhbmdlZChkaXJ0eUxlYWZLZXksIHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlKSkge1xuICAgICAgICAgIHJldHVybiBISVNUT1JZX01FUkdFO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBISVNUT1JZX1BVU0g7XG4gICAgfSkoKTtcblxuICAgIHByZXZDaGFuZ2VUaW1lID0gY2hhbmdlVGltZTtcbiAgICBwcmV2Q2hhbmdlVHlwZSA9IGNoYW5nZVR5cGU7XG4gICAgcmV0dXJuIG1lcmdlQWN0aW9uO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZWRvKGVkaXRvciwgaGlzdG9yeVN0YXRlKSB7XG4gIGNvbnN0IHJlZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2s7XG4gIGNvbnN0IHVuZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS51bmRvU3RhY2s7XG5cbiAgaWYgKHJlZG9TdGFjay5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBjdXJyZW50ID0gaGlzdG9yeVN0YXRlLmN1cnJlbnQ7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdW5kb1N0YWNrLnB1c2goY3VycmVudCk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuQ0FOX1VORE9fQ09NTUFORCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGlzdG9yeVN0YXRlRW50cnkgPSByZWRvU3RhY2sucG9wKCk7XG5cbiAgICBpZiAocmVkb1N0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLkNBTl9SRURPX0NPTU1BTkQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBoaXN0b3J5U3RhdGUuY3VycmVudCA9IGhpc3RvcnlTdGF0ZUVudHJ5IHx8IG51bGw7XG5cbiAgICBpZiAoaGlzdG9yeVN0YXRlRW50cnkpIHtcbiAgICAgIGhpc3RvcnlTdGF0ZUVudHJ5LmVkaXRvci5zZXRFZGl0b3JTdGF0ZShoaXN0b3J5U3RhdGVFbnRyeS5lZGl0b3JTdGF0ZSwge1xuICAgICAgICB0YWc6ICdoaXN0b3JpYydcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1bmRvKGVkaXRvciwgaGlzdG9yeVN0YXRlKSB7XG4gIGNvbnN0IHJlZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2s7XG4gIGNvbnN0IHVuZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS51bmRvU3RhY2s7XG4gIGNvbnN0IHVuZG9TdGFja0xlbmd0aCA9IHVuZG9TdGFjay5sZW5ndGg7XG5cbiAgaWYgKHVuZG9TdGFja0xlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBoaXN0b3J5U3RhdGUuY3VycmVudDtcbiAgICBjb25zdCBoaXN0b3J5U3RhdGVFbnRyeSA9IHVuZG9TdGFjay5wb3AoKTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICByZWRvU3RhY2sucHVzaChjdXJyZW50KTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5DQU5fUkVET19DT01NQU5ELCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAodW5kb1N0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLkNBTl9VTkRPX0NPTU1BTkQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBoaXN0b3J5U3RhdGUuY3VycmVudCA9IGhpc3RvcnlTdGF0ZUVudHJ5IHx8IG51bGw7XG5cbiAgICBpZiAoaGlzdG9yeVN0YXRlRW50cnkpIHtcbiAgICAgIGhpc3RvcnlTdGF0ZUVudHJ5LmVkaXRvci5zZXRFZGl0b3JTdGF0ZShoaXN0b3J5U3RhdGVFbnRyeS5lZGl0b3JTdGF0ZSwge1xuICAgICAgICB0YWc6ICdoaXN0b3JpYydcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhckhpc3RvcnkoaGlzdG9yeVN0YXRlKSB7XG4gIGhpc3RvcnlTdGF0ZS51bmRvU3RhY2sgPSBbXTtcbiAgaGlzdG9yeVN0YXRlLnJlZG9TdGFjayA9IFtdO1xuICBoaXN0b3J5U3RhdGUuY3VycmVudCA9IG51bGw7XG59XG4vKipcbiAqIFJlZ2lzdGVycyBuZWNlc3NhcnkgbGlzdGVuZXJzIHRvIG1hbmFnZSB1bmRvL3JlZG8gaGlzdG9yeSBzdGFjayBhbmQgcmVsYXRlZCBlZGl0b3IgY29tbWFuZHMuXG4gKiBJdCByZXR1cm5zIGB1bnJlZ2lzdGVyYCBjYWxsYmFjayB0aGF0IGNsZWFucyB1cCBhbGwgbGlzdGVuZXJzIGFuZCBzaG91bGQgYmUgY2FsbGVkIG9uIGVkaXRvciB1bm1vdW50LlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBoaXN0b3J5U3RhdGUgLSBUaGUgaGlzdG9yeSBzdGF0ZSwgY29udGFpbmluZyB0aGUgY3VycmVudCBzdGF0ZSBhbmQgdGhlIHVuZG8vcmVkbyBzdGFjay5cbiAqIEBwYXJhbSBkZWxheSAtIFRoZSB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRoZSBlZGl0b3Igc2hvdWxkIGRlbGF5IGdlbmVyYXRpbmcgYSBuZXcgaGlzdG9yeSBzdGFjayxcbiAqIGluc3RlYWQgb2YgbWVyZ2luZyB0aGUgY3VycmVudCBjaGFuZ2VzIHdpdGggdGhlIGN1cnJlbnQgc3RhY2suXG4gKiBAcmV0dXJucyBUaGUgbGlzdGVuZXJzIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cblxuXG5mdW5jdGlvbiByZWdpc3Rlckhpc3RvcnkoZWRpdG9yLCBoaXN0b3J5U3RhdGUsIGRlbGF5KSB7XG4gIGNvbnN0IGdldE1lcmdlQWN0aW9uID0gY3JlYXRlTWVyZ2VBY3Rpb25HZXR0ZXIoZWRpdG9yLCBkZWxheSk7XG5cbiAgY29uc3QgYXBwbHlDaGFuZ2UgPSAoe1xuICAgIGVkaXRvclN0YXRlLFxuICAgIHByZXZFZGl0b3JTdGF0ZSxcbiAgICBkaXJ0eUxlYXZlcyxcbiAgICBkaXJ0eUVsZW1lbnRzLFxuICAgIHRhZ3NcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBoaXN0b3J5U3RhdGUuY3VycmVudDtcbiAgICBjb25zdCByZWRvU3RhY2sgPSBoaXN0b3J5U3RhdGUucmVkb1N0YWNrO1xuICAgIGNvbnN0IHVuZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS51bmRvU3RhY2s7XG4gICAgY29uc3QgY3VycmVudEVkaXRvclN0YXRlID0gY3VycmVudCA9PT0gbnVsbCA/IG51bGwgOiBjdXJyZW50LmVkaXRvclN0YXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgZWRpdG9yU3RhdGUgPT09IGN1cnJlbnRFZGl0b3JTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1lcmdlQWN0aW9uID0gZ2V0TWVyZ2VBY3Rpb24ocHJldkVkaXRvclN0YXRlLCBlZGl0b3JTdGF0ZSwgY3VycmVudCwgZGlydHlMZWF2ZXMsIGRpcnR5RWxlbWVudHMsIHRhZ3MpO1xuXG4gICAgaWYgKG1lcmdlQWN0aW9uID09PSBISVNUT1JZX1BVU0gpIHtcbiAgICAgIGlmIChyZWRvU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2sgPSBbXTtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLkNBTl9SRURPX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgdW5kb1N0YWNrLnB1c2goeyAuLi5jdXJyZW50XG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuQ0FOX1VORE9fQ09NTUFORCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtZXJnZUFjdGlvbiA9PT0gRElTQ0FSRF9ISVNUT1JZX0NBTkRJREFURSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRWxzZSB3ZSBtZXJnZVxuXG5cbiAgICBoaXN0b3J5U3RhdGUuY3VycmVudCA9IHtcbiAgICAgIGVkaXRvcixcbiAgICAgIGVkaXRvclN0YXRlXG4gICAgfTtcbiAgfTtcblxuICBjb25zdCB1bnJlZ2lzdGVyQ29tbWFuZExpc3RlbmVyID0gdXRpbHMubWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuVU5ET19DT01NQU5ELCAoKSA9PiB7XG4gICAgdW5kbyhlZGl0b3IsIGhpc3RvcnlTdGF0ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuUkVET19DT01NQU5ELCAoKSA9PiB7XG4gICAgcmVkbyhlZGl0b3IsIGhpc3RvcnlTdGF0ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuQ0xFQVJfRURJVE9SX0NPTU1BTkQsICgpID0+IHtcbiAgICBjbGVhckhpc3RvcnkoaGlzdG9yeVN0YXRlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuQ0xFQVJfSElTVE9SWV9DT01NQU5ELCAoKSA9PiB7XG4gICAgY2xlYXJIaXN0b3J5KGhpc3RvcnlTdGF0ZSk7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLkNBTl9SRURPX0NPTU1BTkQsIGZhbHNlKTtcbiAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuQ0FOX1VORE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoYXBwbHlDaGFuZ2UpKTtcbiAgY29uc3QgdW5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyID0gZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoYXBwbHlDaGFuZ2UpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHVucmVnaXN0ZXJDb21tYW5kTGlzdGVuZXIoKTtcbiAgICB1bnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKTtcbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBlbXB0eSBoaXN0b3J5IHN0YXRlLlxuICogQHJldHVybnMgLSBUaGUgZW1wdHkgaGlzdG9yeSBzdGF0ZSwgYXMgYW4gb2JqZWN0LlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5SGlzdG9yeVN0YXRlKCkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IG51bGwsXG4gICAgcmVkb1N0YWNrOiBbXSxcbiAgICB1bmRvU3RhY2s6IFtdXG4gIH07XG59XG5cbmV4cG9ydHMuY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUgPSBjcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZTtcbmV4cG9ydHMucmVnaXN0ZXJIaXN0b3J5ID0gcmVnaXN0ZXJIaXN0b3J5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/history/LexicalHistory.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/history/LexicalHistory.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lexical/history/LexicalHistory.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHistory =  true ? __webpack_require__(/*! ./LexicalHistory.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/history/LexicalHistory.dev.js\") : 0\nmodule.exports = LexicalHistory;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9oaXN0b3J5L0xleGljYWxIaXN0b3J5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osdUJBQXVCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQywwR0FBeUIsSUFBSSxDQUFtQztBQUN4SSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaGlzdG9yeS9MZXhpY2FsSGlzdG9yeS5qcz9lZmNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsSGlzdG9yeSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsSGlzdG9yeS5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbEhpc3RvcnkucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxIaXN0b3J5OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/history/LexicalHistory.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/html/LexicalHtml.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/html/LexicalHtml.dev.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar selection = __webpack_require__(/*! @lexical/selection */ \"(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/html */\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivilant library and pass in the document here.\n */\n\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n\n  return container.innerHTML;\n}\n\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const {\n    element,\n    after\n  } = target.exportDOM(editor);\n\n  if (!element) {\n    return false;\n  }\n\n  const fragment = document.createDocumentFragment();\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    element.append(fragment);\n    parentElement.append(element);\n\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n\n  return shouldInclude;\n}\n\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n\n  let currentConversion = null;\n\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\n\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\n\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  } // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n\n\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode));\n  }\n\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n\n  return lexicalNodes;\n}\n\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9odG1sL0xleGljYWxIdG1sLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQyxxR0FBb0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLHNFQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7O0FBRUEsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUIsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9odG1sL0xleGljYWxIdG1sLmRldi5qcz8xNTQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2VsZWN0aW9uID0gcmVxdWlyZSgnQGxleGljYWwvc2VsZWN0aW9uJyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcblxuLyoqIEBtb2R1bGUgQGxleGljYWwvaHRtbCAqL1xuLyoqXG4gKiBIb3cgeW91IHBhcnNlIHlvdXIgaHRtbCBzdHJpbmcgdG8gZ2V0IGEgZG9jdW1lbnQgaXMgbGVmdCB1cCB0byB5b3UuIEluIHRoZSBicm93c2VyIHlvdSBjYW4gdXNlIHRoZSBuYXRpdmVcbiAqIERPTVBhcnNlciBBUEkgdG8gZ2VuZXJhdGUgYSBkb2N1bWVudCAoc2VlIGNsaXBib2FyZC50cyksIGJ1dCB0byB1c2UgaW4gYSBoZWFkbGVzcyBlbnZpcm9ubWVudCB5b3UgY2FuIHVzZSBKU0RvbVxuICogb3IgYW4gZXF1aXZpbGFudCBsaWJyYXJ5IGFuZCBwYXNzIGluIHRoZSBkb2N1bWVudCBoZXJlLlxuICovXG5cbmZ1bmN0aW9uICRnZW5lcmF0ZU5vZGVzRnJvbURPTShlZGl0b3IsIGRvbSkge1xuICBjb25zdCBlbGVtZW50cyA9IGRvbS5ib2R5ID8gZG9tLmJvZHkuY2hpbGROb2RlcyA6IFtdO1xuICBsZXQgbGV4aWNhbE5vZGVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcblxuICAgIGlmICghSUdOT1JFX1RBR1MuaGFzKGVsZW1lbnQubm9kZU5hbWUpKSB7XG4gICAgICBjb25zdCBsZXhpY2FsTm9kZSA9ICRjcmVhdGVOb2Rlc0Zyb21ET00oZWxlbWVudCwgZWRpdG9yKTtcblxuICAgICAgaWYgKGxleGljYWxOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGxleGljYWxOb2RlcyA9IGxleGljYWxOb2Rlcy5jb25jYXQobGV4aWNhbE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsZXhpY2FsTm9kZXM7XG59XG5mdW5jdGlvbiAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzKGVkaXRvciwgc2VsZWN0aW9uKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUbyB1c2UgJGdlbmVyYXRlSHRtbEZyb21Ob2RlcyBpbiBoZWFkbGVzcyBtb2RlIHBsZWFzZSBpbml0aWFsaXplIGEgaGVhZGxlc3MgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBzdWNoIGFzIEpTRG9tIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uJyk7XG4gIH1cblxuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29uc3Qgcm9vdCA9IGxleGljYWwuJGdldFJvb3QoKTtcbiAgY29uc3QgdG9wTGV2ZWxDaGlsZHJlbiA9IHJvb3QuZ2V0Q2hpbGRyZW4oKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvcExldmVsQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b3BMZXZlbE5vZGUgPSB0b3BMZXZlbENoaWxkcmVuW2ldO1xuICAgICRhcHBlbmROb2Rlc1RvSFRNTChlZGl0b3IsIHRvcExldmVsTm9kZSwgY29udGFpbmVyLCBzZWxlY3Rpb24pO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG59XG5cbmZ1bmN0aW9uICRhcHBlbmROb2Rlc1RvSFRNTChlZGl0b3IsIGN1cnJlbnROb2RlLCBwYXJlbnRFbGVtZW50LCBzZWxlY3Rpb24kMSA9IG51bGwpIHtcbiAgbGV0IHNob3VsZEluY2x1ZGUgPSBzZWxlY3Rpb24kMSAhPSBudWxsID8gY3VycmVudE5vZGUuaXNTZWxlY3RlZChzZWxlY3Rpb24kMSkgOiB0cnVlO1xuICBjb25zdCBzaG91bGRFeGNsdWRlID0gbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgY3VycmVudE5vZGUuZXhjbHVkZUZyb21Db3B5KCdodG1sJyk7XG4gIGxldCB0YXJnZXQgPSBjdXJyZW50Tm9kZTtcblxuICBpZiAoc2VsZWN0aW9uJDEgIT09IG51bGwpIHtcbiAgICBsZXQgY2xvbmUgPSBzZWxlY3Rpb24uJGNsb25lV2l0aFByb3BlcnRpZXMoY3VycmVudE5vZGUpO1xuICAgIGNsb25lID0gbGV4aWNhbC4kaXNUZXh0Tm9kZShjbG9uZSkgJiYgc2VsZWN0aW9uJDEgIT0gbnVsbCA/IHNlbGVjdGlvbi4kc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudChzZWxlY3Rpb24kMSwgY2xvbmUpIDogY2xvbmU7XG4gICAgdGFyZ2V0ID0gY2xvbmU7XG4gIH1cblxuICBjb25zdCBjaGlsZHJlbiA9IGxleGljYWwuJGlzRWxlbWVudE5vZGUodGFyZ2V0KSA/IHRhcmdldC5nZXRDaGlsZHJlbigpIDogW107XG4gIGNvbnN0IHtcbiAgICBlbGVtZW50LFxuICAgIGFmdGVyXG4gIH0gPSB0YXJnZXQuZXhwb3J0RE9NKGVkaXRvcik7XG5cbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IHNob3VsZEluY2x1ZGVDaGlsZCA9ICRhcHBlbmROb2Rlc1RvSFRNTChlZGl0b3IsIGNoaWxkTm9kZSwgZnJhZ21lbnQsIHNlbGVjdGlvbiQxKTtcblxuICAgIGlmICghc2hvdWxkSW5jbHVkZSAmJiBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBzaG91bGRJbmNsdWRlQ2hpbGQgJiYgY3VycmVudE5vZGUuZXh0cmFjdFdpdGhDaGlsZChjaGlsZE5vZGUsIHNlbGVjdGlvbiQxLCAnaHRtbCcpKSB7XG4gICAgICBzaG91bGRJbmNsdWRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2hvdWxkSW5jbHVkZSAmJiAhc2hvdWxkRXhjbHVkZSkge1xuICAgIGVsZW1lbnQuYXBwZW5kKGZyYWdtZW50KTtcbiAgICBwYXJlbnRFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcblxuICAgIGlmIChhZnRlcikge1xuICAgICAgY29uc3QgbmV3RWxlbWVudCA9IGFmdGVyLmNhbGwodGFyZ2V0LCBlbGVtZW50KTtcbiAgICAgIGlmIChuZXdFbGVtZW50KSBlbGVtZW50LnJlcGxhY2VXaXRoKG5ld0VsZW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRFbGVtZW50LmFwcGVuZChmcmFnbWVudCk7XG4gIH1cblxuICByZXR1cm4gc2hvdWxkSW5jbHVkZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udmVyc2lvbkZ1bmN0aW9uKGRvbU5vZGUsIGVkaXRvcikge1xuICBjb25zdCB7XG4gICAgbm9kZU5hbWVcbiAgfSA9IGRvbU5vZGU7XG5cbiAgY29uc3QgY2FjaGVkQ29udmVyc2lvbnMgPSBlZGl0b3IuX2h0bWxDb252ZXJzaW9ucy5nZXQobm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG5cbiAgbGV0IGN1cnJlbnRDb252ZXJzaW9uID0gbnVsbDtcblxuICBpZiAoY2FjaGVkQ29udmVyc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAoY29uc3QgY2FjaGVkQ29udmVyc2lvbiBvZiBjYWNoZWRDb252ZXJzaW9ucykge1xuICAgICAgY29uc3QgZG9tQ29udmVyc2lvbiA9IGNhY2hlZENvbnZlcnNpb24oZG9tTm9kZSk7XG5cbiAgICAgIGlmIChkb21Db252ZXJzaW9uICE9PSBudWxsICYmIChjdXJyZW50Q29udmVyc2lvbiA9PT0gbnVsbCB8fCBjdXJyZW50Q29udmVyc2lvbi5wcmlvcml0eSA8IGRvbUNvbnZlcnNpb24ucHJpb3JpdHkpKSB7XG4gICAgICAgIGN1cnJlbnRDb252ZXJzaW9uID0gZG9tQ29udmVyc2lvbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VycmVudENvbnZlcnNpb24gIT09IG51bGwgPyBjdXJyZW50Q29udmVyc2lvbi5jb252ZXJzaW9uIDogbnVsbDtcbn1cblxuY29uc3QgSUdOT1JFX1RBR1MgPSBuZXcgU2V0KFsnU1RZTEUnLCAnU0NSSVBUJ10pO1xuXG5mdW5jdGlvbiAkY3JlYXRlTm9kZXNGcm9tRE9NKG5vZGUsIGVkaXRvciwgZm9yQ2hpbGRNYXAgPSBuZXcgTWFwKCksIHBhcmVudExleGljYWxOb2RlKSB7XG4gIGxldCBsZXhpY2FsTm9kZXMgPSBbXTtcblxuICBpZiAoSUdOT1JFX1RBR1MuaGFzKG5vZGUubm9kZU5hbWUpKSB7XG4gICAgcmV0dXJuIGxleGljYWxOb2RlcztcbiAgfVxuXG4gIGxldCBjdXJyZW50TGV4aWNhbE5vZGUgPSBudWxsO1xuICBjb25zdCB0cmFuc2Zvcm1GdW5jdGlvbiA9IGdldENvbnZlcnNpb25GdW5jdGlvbihub2RlLCBlZGl0b3IpO1xuICBjb25zdCB0cmFuc2Zvcm1PdXRwdXQgPSB0cmFuc2Zvcm1GdW5jdGlvbiA/IHRyYW5zZm9ybUZ1bmN0aW9uKG5vZGUpIDogbnVsbDtcbiAgbGV0IHBvc3RUcmFuc2Zvcm0gPSBudWxsO1xuXG4gIGlmICh0cmFuc2Zvcm1PdXRwdXQgIT09IG51bGwpIHtcbiAgICBwb3N0VHJhbnNmb3JtID0gdHJhbnNmb3JtT3V0cHV0LmFmdGVyO1xuICAgIGNvbnN0IHRyYW5zZm9ybU5vZGVzID0gdHJhbnNmb3JtT3V0cHV0Lm5vZGU7XG4gICAgY3VycmVudExleGljYWxOb2RlID0gQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1Ob2RlcykgPyB0cmFuc2Zvcm1Ob2Rlc1t0cmFuc2Zvcm1Ob2Rlcy5sZW5ndGggLSAxXSA6IHRyYW5zZm9ybU5vZGVzO1xuXG4gICAgaWYgKGN1cnJlbnRMZXhpY2FsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBbLCBmb3JDaGlsZEZ1bmN0aW9uXSBvZiBmb3JDaGlsZE1hcCkge1xuICAgICAgICBjdXJyZW50TGV4aWNhbE5vZGUgPSBmb3JDaGlsZEZ1bmN0aW9uKGN1cnJlbnRMZXhpY2FsTm9kZSwgcGFyZW50TGV4aWNhbE5vZGUpO1xuXG4gICAgICAgIGlmICghY3VycmVudExleGljYWxOb2RlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnRMZXhpY2FsTm9kZSkge1xuICAgICAgICBsZXhpY2FsTm9kZXMucHVzaCguLi4oQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1Ob2RlcykgPyB0cmFuc2Zvcm1Ob2RlcyA6IFtjdXJyZW50TGV4aWNhbE5vZGVdKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybU91dHB1dC5mb3JDaGlsZCAhPSBudWxsKSB7XG4gICAgICBmb3JDaGlsZE1hcC5zZXQobm9kZS5ub2RlTmFtZSwgdHJhbnNmb3JtT3V0cHV0LmZvckNoaWxkKTtcbiAgICB9XG4gIH0gLy8gSWYgdGhlIERPTSBub2RlIGRvZXNuJ3QgaGF2ZSBhIHRyYW5zZm9ybWVyLCB3ZSBkb24ndCBrbm93IHdoYXRcbiAgLy8gdG8gZG8gd2l0aCBpdCBidXQgd2Ugc3RpbGwgbmVlZCB0byBwcm9jZXNzIGFueSBjaGlsZE5vZGVzLlxuXG5cbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gIGxldCBjaGlsZExleGljYWxOb2RlcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjaGlsZExleGljYWxOb2Rlcy5wdXNoKC4uLiRjcmVhdGVOb2Rlc0Zyb21ET00oY2hpbGRyZW5baV0sIGVkaXRvciwgbmV3IE1hcChmb3JDaGlsZE1hcCksIGN1cnJlbnRMZXhpY2FsTm9kZSkpO1xuICB9XG5cbiAgaWYgKHBvc3RUcmFuc2Zvcm0gIT0gbnVsbCkge1xuICAgIGNoaWxkTGV4aWNhbE5vZGVzID0gcG9zdFRyYW5zZm9ybShjaGlsZExleGljYWxOb2Rlcyk7XG4gIH1cblxuICBpZiAoY3VycmVudExleGljYWxOb2RlID09IG51bGwpIHtcbiAgICAvLyBJZiBpdCBoYXNuJ3QgYmVlbiBjb252ZXJ0ZWQgdG8gYSBMZXhpY2FsTm9kZSwgd2UgaG9pc3QgaXRzIGNoaWxkcmVuXG4gICAgLy8gdXAgdG8gdGhlIHNhbWUgbGV2ZWwgYXMgaXQuXG4gICAgbGV4aWNhbE5vZGVzID0gbGV4aWNhbE5vZGVzLmNvbmNhdChjaGlsZExleGljYWxOb2Rlcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUoY3VycmVudExleGljYWxOb2RlKSkge1xuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgbm9kZSBpcyBhIEVsZW1lbnROb2RlIGFmdGVyIGNvbnZlcnNpb24sXG4gICAgICAvLyB3ZSBjYW4gYXBwZW5kIGFsbCB0aGUgY2hpbGRyZW4gdG8gaXQuXG4gICAgICBjdXJyZW50TGV4aWNhbE5vZGUuYXBwZW5kKC4uLmNoaWxkTGV4aWNhbE5vZGVzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGV4aWNhbE5vZGVzO1xufVxuXG5leHBvcnRzLiRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMgPSAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzO1xuZXhwb3J0cy4kZ2VuZXJhdGVOb2Rlc0Zyb21ET00gPSAkZ2VuZXJhdGVOb2Rlc0Zyb21ET007XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/html/LexicalHtml.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/html/LexicalHtml.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/html/LexicalHtml.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHtml =  true ? __webpack_require__(/*! ./LexicalHtml.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/html/LexicalHtml.dev.js\") : 0\nmodule.exports = LexicalHtml;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9odG1sL0xleGljYWxIdG1sLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osb0JBQW9CLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxpR0FBc0IsSUFBSSxDQUFnQztBQUMvSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaHRtbC9MZXhpY2FsSHRtbC5qcz9kNGVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsSHRtbCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsSHRtbC5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbEh0bWwucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxIdG1sOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/html/LexicalHtml.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/link/LexicalLink.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/link/LexicalLink.dev.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/link */\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n/** @noInheritDoc */\n\nclass LinkNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'link';\n  }\n\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n\n  constructor(url, attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.sanitizeUrl(this.__url);\n\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n\n    if (this.__title !== null) {\n      element.title = this.__title;\n    }\n\n    utils.addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n\n  updateDOM(prevNode, anchor, config) {\n    const url = this.__url;\n    const target = this.__target;\n    const rel = this.__rel;\n    const title = this.__title;\n\n    if (url !== prevNode.__url) {\n      anchor.href = url;\n    }\n\n    if (target !== prevNode.__target) {\n      if (target) {\n        anchor.target = target;\n      } else {\n        anchor.removeAttribute('target');\n      }\n    }\n\n    if (rel !== prevNode.__rel) {\n      if (rel) {\n        anchor.rel = rel;\n      } else {\n        anchor.removeAttribute('rel');\n      }\n    }\n\n    if (title !== prevNode.__title) {\n      if (title) {\n        anchor.title = title;\n      } else {\n        anchor.removeAttribute('title');\n      }\n    }\n\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  sanitizeUrl(url) {\n    try {\n      const parsedUrl = new URL(url); // eslint-disable-next-line no-script-url\n\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch {\n      return url;\n    }\n\n    return url;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      type: 'link',\n      url: this.getURL(),\n      version: 1\n    };\n  }\n\n  getURL() {\n    return this.getLatest().__url;\n  }\n\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n  }\n\n  getTarget() {\n    return this.getLatest().__target;\n  }\n\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n  }\n\n  getRel() {\n    return this.getLatest().__rel;\n  }\n\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n  }\n\n  getTitle() {\n    return this.getLatest().__title;\n  }\n\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n  }\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createLinkNode(this.__url, {\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n\n    return null;\n  }\n\n  canInsertTextBefore() {\n    return false;\n  }\n\n  canInsertTextAfter() {\n    return false;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  isInline() {\n    return true;\n  }\n\n  extractWithChild(child, selection, destination) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n\n}\n\nfunction convertAnchorElement(domNode) {\n  let node = null;\n\n  if (utils.isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n\n    if (content !== null && content !== '') {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n\n  return {\n    node\n  };\n}\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes { target, rel, title }\n * @returns The LinkNode.\n */\n\n\nfunction $createLinkNode(url, attributes) {\n  return lexical.$applyNodeReplacement(new LinkNode(url, attributes));\n}\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\n\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  static getType() {\n    return 'autolink';\n  }\n\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createAutoLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'autolink',\n      version: 1\n    };\n  }\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        rel: this._rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n\n    return null;\n  }\n\n}\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. { target, rel, title }\n * @returns The LinkNode.\n */\n\nfunction $createAutoLinkNode(url, attributes) {\n  return lexical.$applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\n\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = lexical.createCommand('TOGGLE_LINK_COMMAND');\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. { target, rel, title }\n */\n\nfunction toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n\n  const nodes = selection.extract();\n\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parent = node.getParent();\n\n      if ($isLinkNode(parent)) {\n        const children = parent.getChildren();\n\n        for (let i = 0; i < children.length; i++) {\n          parent.insertBefore(children[i]);\n        }\n\n        parent.remove();\n      }\n    });\n  } else {\n    // Add or merge LinkNodes\n    if (nodes.length === 1) {\n      const firstNode = nodes[0]; // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n\n      const linkNode = $isLinkNode(firstNode) ? firstNode : $getLinkAncestor(firstNode);\n\n      if (linkNode !== null) {\n        linkNode.setURL(url);\n\n        if (target !== undefined) {\n          linkNode.setTarget(target);\n        }\n\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n\n        return;\n      }\n    }\n\n    let prevParent = null;\n    let linkNode = null;\n    nodes.forEach(node => {\n      const parent = node.getParent();\n\n      if (parent === linkNode || parent === null || lexical.$isElementNode(node) && !node.isInline()) {\n        return;\n      }\n\n      if ($isLinkNode(parent)) {\n        linkNode = parent;\n        parent.setURL(url);\n\n        if (target !== undefined) {\n          parent.setTarget(target);\n        }\n\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n\n        return;\n      }\n\n      if (!parent.is(prevParent)) {\n        prevParent = parent;\n        linkNode = $createLinkNode(url, {\n          rel,\n          target\n        });\n\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode);\n          } else {\n            parent.insertAfter(linkNode);\n          }\n        } else {\n          node.insertBefore(linkNode);\n        }\n      }\n\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return;\n        }\n\n        if (linkNode !== null) {\n          const children = node.getChildren();\n\n          for (let i = 0; i < children.length; i++) {\n            linkNode.append(children[i]);\n          }\n        }\n\n        node.remove();\n        return;\n      }\n\n      if (linkNode !== null) {\n        linkNode.append(node);\n      }\n    });\n  }\n}\n\nfunction $getLinkAncestor(node) {\n  return $getAncestor(node, $isLinkNode);\n}\n\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n\n  while (parent !== null && (parent = parent.getParent()) !== null && !predicate(parent));\n\n  return parent;\n}\n\nexports.$createAutoLinkNode = $createAutoLinkNode;\nexports.$createLinkNode = $createLinkNode;\nexports.$isAutoLinkNode = $isAutoLinkNode;\nexports.$isLinkNode = $isLinkNode;\nexports.AutoLinkNode = AutoLinkNode;\nexports.LinkNode = LinkNode;\nexports.TOGGLE_LINK_COMMAND = TOGGLE_LINK_COMMAND;\nexports.toggleLink = toggleLink;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9saW5rL0xleGljYWxMaW5rLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMseUZBQWdCO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUzs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEIsMkJBQTJCO0FBQzNCLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGluay9MZXhpY2FsTGluay5kZXYuanM/NzY0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnQGxleGljYWwvdXRpbHMnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xuXG4vKiogQG1vZHVsZSBAbGV4aWNhbC9saW5rICovXG5jb25zdCBTVVBQT1JURURfVVJMX1BST1RPQ09MUyA9IG5ldyBTZXQoWydodHRwOicsICdodHRwczonLCAnbWFpbHRvOicsICdzbXM6JywgJ3RlbDonXSk7XG4vKiogQG5vSW5oZXJpdERvYyAqL1xuXG5jbGFzcyBMaW5rTm9kZSBleHRlbmRzIGxleGljYWwuRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnbGluayc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgTGlua05vZGUobm9kZS5fX3VybCwge1xuICAgICAgcmVsOiBub2RlLl9fcmVsLFxuICAgICAgdGFyZ2V0OiBub2RlLl9fdGFyZ2V0LFxuICAgICAgdGl0bGU6IG5vZGUuX190aXRsZVxuICAgIH0sIG5vZGUuX19rZXkpO1xuICB9XG5cbiAgY29uc3RydWN0b3IodXJsLCBhdHRyaWJ1dGVzID0ge30sIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0ID0gbnVsbCxcbiAgICAgIHJlbCA9IG51bGwsXG4gICAgICB0aXRsZSA9IG51bGxcbiAgICB9ID0gYXR0cmlidXRlcztcbiAgICB0aGlzLl9fdXJsID0gdXJsO1xuICAgIHRoaXMuX190YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fX3JlbCA9IHJlbDtcbiAgICB0aGlzLl9fdGl0bGUgPSB0aXRsZTtcbiAgfVxuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGVsZW1lbnQuaHJlZiA9IHRoaXMuc2FuaXRpemVVcmwodGhpcy5fX3VybCk7XG5cbiAgICBpZiAodGhpcy5fX3RhcmdldCAhPT0gbnVsbCkge1xuICAgICAgZWxlbWVudC50YXJnZXQgPSB0aGlzLl9fdGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9fcmVsICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnJlbCA9IHRoaXMuX19yZWw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX190aXRsZSAhPT0gbnVsbCkge1xuICAgICAgZWxlbWVudC50aXRsZSA9IHRoaXMuX190aXRsZTtcbiAgICB9XG5cbiAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS5saW5rKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgYW5jaG9yLCBjb25maWcpIHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLl9fdXJsO1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX190YXJnZXQ7XG4gICAgY29uc3QgcmVsID0gdGhpcy5fX3JlbDtcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMuX190aXRsZTtcblxuICAgIGlmICh1cmwgIT09IHByZXZOb2RlLl9fdXJsKSB7XG4gICAgICBhbmNob3IuaHJlZiA9IHVybDtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0ICE9PSBwcmV2Tm9kZS5fX3RhcmdldCkge1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBhbmNob3IudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yLnJlbW92ZUF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbCAhPT0gcHJldk5vZGUuX19yZWwpIHtcbiAgICAgIGlmIChyZWwpIHtcbiAgICAgICAgYW5jaG9yLnJlbCA9IHJlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvci5yZW1vdmVBdHRyaWJ1dGUoJ3JlbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aXRsZSAhPT0gcHJldk5vZGUuX190aXRsZSkge1xuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIGFuY2hvci50aXRsZSA9IHRpdGxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yLnJlbW92ZUF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRBbmNob3JFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMVxuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZUxpbmtOb2RlKHNlcmlhbGl6ZWROb2RlLnVybCwge1xuICAgICAgcmVsOiBzZXJpYWxpemVkTm9kZS5yZWwsXG4gICAgICB0YXJnZXQ6IHNlcmlhbGl6ZWROb2RlLnRhcmdldCxcbiAgICAgIHRpdGxlOiBzZXJpYWxpemVkTm9kZS50aXRsZVxuICAgIH0pO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgc2FuaXRpemVVcmwodXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNjcmlwdC11cmxcblxuICAgICAgaWYgKCFTVVBQT1JURURfVVJMX1BST1RPQ09MUy5oYXMocGFyc2VkVXJsLnByb3RvY29sKSkge1xuICAgICAgICByZXR1cm4gJ2Fib3V0OmJsYW5rJztcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgcmVsOiB0aGlzLmdldFJlbCgpLFxuICAgICAgdGFyZ2V0OiB0aGlzLmdldFRhcmdldCgpLFxuICAgICAgdGl0bGU6IHRoaXMuZ2V0VGl0bGUoKSxcbiAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgIHVybDogdGhpcy5nZXRVUkwoKSxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG5cbiAgZ2V0VVJMKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fdXJsO1xuICB9XG5cbiAgc2V0VVJMKHVybCkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fdXJsID0gdXJsO1xuICB9XG5cbiAgZ2V0VGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fdGFyZ2V0O1xuICB9XG5cbiAgc2V0VGFyZ2V0KHRhcmdldCkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fdGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG5cbiAgZ2V0UmVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fcmVsO1xuICB9XG5cbiAgc2V0UmVsKHJlbCkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fcmVsID0gcmVsO1xuICB9XG5cbiAgZ2V0VGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX190aXRsZTtcbiAgfVxuXG4gIHNldFRpdGxlKHRpdGxlKSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX190aXRsZSA9IHRpdGxlO1xuICB9XG5cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5pbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24pO1xuXG4gICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUoZWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IGxpbmtOb2RlID0gJGNyZWF0ZUxpbmtOb2RlKHRoaXMuX191cmwsIHtcbiAgICAgICAgcmVsOiB0aGlzLl9fcmVsLFxuICAgICAgICB0YXJnZXQ6IHRoaXMuX190YXJnZXQsXG4gICAgICAgIHRpdGxlOiB0aGlzLl9fdGl0bGVcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5hcHBlbmQobGlua05vZGUpO1xuICAgICAgcmV0dXJuIGxpbmtOb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbiwgZGVzdGluYXRpb24pIHtcbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIHJldHVybiB0aGlzLmlzUGFyZW50T2YoYW5jaG9yTm9kZSkgJiYgdGhpcy5pc1BhcmVudE9mKGZvY3VzTm9kZSkgJiYgc2VsZWN0aW9uLmdldFRleHRDb250ZW50KCkubGVuZ3RoID4gMDtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRBbmNob3JFbGVtZW50KGRvbU5vZGUpIHtcbiAgbGV0IG5vZGUgPSBudWxsO1xuXG4gIGlmICh1dGlscy5pc0hUTUxBbmNob3JFbGVtZW50KGRvbU5vZGUpKSB7XG4gICAgY29uc3QgY29udGVudCA9IGRvbU5vZGUudGV4dENvbnRlbnQ7XG5cbiAgICBpZiAoY29udGVudCAhPT0gbnVsbCAmJiBjb250ZW50ICE9PSAnJykge1xuICAgICAgbm9kZSA9ICRjcmVhdGVMaW5rTm9kZShkb21Ob2RlLmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8ICcnLCB7XG4gICAgICAgIHJlbDogZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3JlbCcpLFxuICAgICAgICB0YXJnZXQ6IGRvbU5vZGUuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSxcbiAgICAgICAgdGl0bGU6IGRvbU5vZGUuZ2V0QXR0cmlidXRlKCd0aXRsZScpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5vZGVcbiAgfTtcbn1cbi8qKlxuICogVGFrZXMgYSBVUkwgYW5kIGNyZWF0ZXMgYSBMaW5rTm9kZS5cbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRoZSBMaW5rTm9kZSBzaG91bGQgZGlyZWN0IHRvLlxuICogQHBhcmFtIGF0dHJpYnV0ZXMgLSBPcHRpb25hbCBIVE1MIGEgdGFnIGF0dHJpYnV0ZXMgeyB0YXJnZXQsIHJlbCwgdGl0bGUgfVxuICogQHJldHVybnMgVGhlIExpbmtOb2RlLlxuICovXG5cblxuZnVuY3Rpb24gJGNyZWF0ZUxpbmtOb2RlKHVybCwgYXR0cmlidXRlcykge1xuICByZXR1cm4gbGV4aWNhbC4kYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IExpbmtOb2RlKHVybCwgYXR0cmlidXRlcykpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIG5vZGUgaXMgYSBMaW5rTm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIHRydWUgaWYgbm9kZSBpcyBhIExpbmtOb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gJGlzTGlua05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIExpbmtOb2RlO1xufVxuLy8gQ3VzdG9tIG5vZGUgdHlwZSB0byBvdmVycmlkZSBgY2FuSW5zZXJ0VGV4dEFmdGVyYCB0aGF0IHdpbGxcbi8vIGFsbG93IHR5cGluZyB3aXRoaW4gdGhlIGxpbmtcbmNsYXNzIEF1dG9MaW5rTm9kZSBleHRlbmRzIExpbmtOb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdhdXRvbGluayc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgQXV0b0xpbmtOb2RlKG5vZGUuX191cmwsIHtcbiAgICAgIHJlbDogbm9kZS5fX3JlbCxcbiAgICAgIHRhcmdldDogbm9kZS5fX3RhcmdldCxcbiAgICAgIHRpdGxlOiBub2RlLl9fdGl0bGVcbiAgICB9LCBub2RlLl9fa2V5KTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVBdXRvTGlua05vZGUoc2VyaWFsaXplZE5vZGUudXJsLCB7XG4gICAgICByZWw6IHNlcmlhbGl6ZWROb2RlLnJlbCxcbiAgICAgIHRhcmdldDogc2VyaWFsaXplZE5vZGUudGFyZ2V0LFxuICAgICAgdGl0bGU6IHNlcmlhbGl6ZWROb2RlLnRpdGxlXG4gICAgfSk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldEluZGVudChzZXJpYWxpemVkTm9kZS5pbmRlbnQpO1xuICAgIG5vZGUuc2V0RGlyZWN0aW9uKHNlcmlhbGl6ZWROb2RlLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIC8vIFRPRE86IFNob3VsZCBsaW5rIG5vZGUgc2hvdWxkIGhhbmRsZSB0aGUgaW1wb3J0IG92ZXIgYXV0b2xpbms/XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHR5cGU6ICdhdXRvbGluaycsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIGluc2VydE5ld0FmdGVyKHNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBsaW5rTm9kZSA9ICRjcmVhdGVBdXRvTGlua05vZGUodGhpcy5fX3VybCwge1xuICAgICAgICByZWw6IHRoaXMuX3JlbCxcbiAgICAgICAgdGFyZ2V0OiB0aGlzLl9fdGFyZ2V0LFxuICAgICAgICB0aXRsZTogdGhpcy5fX3RpdGxlXG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuYXBwZW5kKGxpbmtOb2RlKTtcbiAgICAgIHJldHVybiBsaW5rTm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG59XG4vKipcbiAqIFRha2VzIGEgVVJMIGFuZCBjcmVhdGVzIGFuIEF1dG9MaW5rTm9kZS4gQXV0b0xpbmtOb2RlcyBhcmUgZ2VuZXJhbGx5IGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkXG4gKiBkdXJpbmcgdHlwaW5nLCB3aGljaCBpcyBlc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIGEgYnV0dG9uIHRvIGdlbmVyYXRlIGEgTGlua05vZGUgaXMgbm90IHByYWN0aWNhbC5cbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRoZSBMaW5rTm9kZSBzaG91bGQgZGlyZWN0IHRvLlxuICogQHBhcmFtIGF0dHJpYnV0ZXMgLSBPcHRpb25hbCBIVE1MIGEgdGFnIGF0dHJpYnV0ZXMuIHsgdGFyZ2V0LCByZWwsIHRpdGxlIH1cbiAqIEByZXR1cm5zIFRoZSBMaW5rTm9kZS5cbiAqL1xuXG5mdW5jdGlvbiAkY3JlYXRlQXV0b0xpbmtOb2RlKHVybCwgYXR0cmlidXRlcykge1xuICByZXR1cm4gbGV4aWNhbC4kYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IEF1dG9MaW5rTm9kZSh1cmwsIGF0dHJpYnV0ZXMpKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBub2RlIGlzIGFuIEF1dG9MaW5rTm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIHRydWUgaWYgbm9kZSBpcyBhbiBBdXRvTGlua05vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiAkaXNBdXRvTGlua05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEF1dG9MaW5rTm9kZTtcbn1cbmNvbnN0IFRPR0dMRV9MSU5LX0NPTU1BTkQgPSBsZXhpY2FsLmNyZWF0ZUNvbW1hbmQoJ1RPR0dMRV9MSU5LX0NPTU1BTkQnKTtcbi8qKlxuICogR2VuZXJhdGVzIG9yIHVwZGF0ZXMgYSBMaW5rTm9kZS4gSXQgY2FuIGFsc28gZGVsZXRlIGEgTGlua05vZGUgaWYgdGhlIFVSTCBpcyBudWxsLFxuICogYnV0IHNhdmVzIGFueSBjaGlsZHJlbiBhbmQgYnJpbmdzIHRoZW0gdXAgdG8gdGhlIHBhcmVudCBub2RlLlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdGhlIGxpbmsgZGlyZWN0cyB0by5cbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIC0gT3B0aW9uYWwgSFRNTCBhIHRhZyBhdHRyaWJ1dGVzLiB7IHRhcmdldCwgcmVsLCB0aXRsZSB9XG4gKi9cblxuZnVuY3Rpb24gdG9nZ2xlTGluayh1cmwsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdGFyZ2V0LFxuICAgIHRpdGxlXG4gIH0gPSBhdHRyaWJ1dGVzO1xuICBjb25zdCByZWwgPSBhdHRyaWJ1dGVzLnJlbCA9PT0gdW5kZWZpbmVkID8gJ25vcmVmZXJyZXInIDogYXR0cmlidXRlcy5yZWw7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZXh0cmFjdCgpO1xuXG4gIGlmICh1cmwgPT09IG51bGwpIHtcbiAgICAvLyBSZW1vdmUgTGlua05vZGVzXG4gICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgICAgIGlmICgkaXNMaW5rTm9kZShwYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50LmdldENoaWxkcmVuKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50LnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIEFkZCBvciBtZXJnZSBMaW5rTm9kZXNcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBmaXJzdE5vZGUgPSBub2Rlc1swXTsgLy8gaWYgdGhlIGZpcnN0IG5vZGUgaXMgYSBMaW5rTm9kZSBvciBpZiBpdHNcbiAgICAgIC8vIHBhcmVudCBpcyBhIExpbmtOb2RlLCB3ZSB1cGRhdGUgdGhlIFVSTCwgdGFyZ2V0IGFuZCByZWwuXG5cbiAgICAgIGNvbnN0IGxpbmtOb2RlID0gJGlzTGlua05vZGUoZmlyc3ROb2RlKSA/IGZpcnN0Tm9kZSA6ICRnZXRMaW5rQW5jZXN0b3IoZmlyc3ROb2RlKTtcblxuICAgICAgaWYgKGxpbmtOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGxpbmtOb2RlLnNldFVSTCh1cmwpO1xuXG4gICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxpbmtOb2RlLnNldFRhcmdldCh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbCAhPT0gbnVsbCkge1xuICAgICAgICAgIGxpbmtOb2RlLnNldFJlbChyZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpdGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaW5rTm9kZS5zZXRUaXRsZSh0aXRsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHByZXZQYXJlbnQgPSBudWxsO1xuICAgIGxldCBsaW5rTm9kZSA9IG51bGw7XG4gICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgICAgIGlmIChwYXJlbnQgPT09IGxpbmtOb2RlIHx8IHBhcmVudCA9PT0gbnVsbCB8fCBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGlzTGlua05vZGUocGFyZW50KSkge1xuICAgICAgICBsaW5rTm9kZSA9IHBhcmVudDtcbiAgICAgICAgcGFyZW50LnNldFVSTCh1cmwpO1xuXG4gICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcmVudC5zZXRUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWwgIT09IG51bGwpIHtcbiAgICAgICAgICBsaW5rTm9kZS5zZXRSZWwocmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aXRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGlua05vZGUuc2V0VGl0bGUodGl0bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcmVudC5pcyhwcmV2UGFyZW50KSkge1xuICAgICAgICBwcmV2UGFyZW50ID0gcGFyZW50O1xuICAgICAgICBsaW5rTm9kZSA9ICRjcmVhdGVMaW5rTm9kZSh1cmwsIHtcbiAgICAgICAgICByZWwsXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICgkaXNMaW5rTm9kZShwYXJlbnQpKSB7XG4gICAgICAgICAgaWYgKG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobGlua05vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QWZ0ZXIobGlua05vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmluc2VydEJlZm9yZShsaW5rTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCRpc0xpbmtOb2RlKG5vZGUpKSB7XG4gICAgICAgIGlmIChub2RlLmlzKGxpbmtOb2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW5rTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlua05vZGUuYXBwZW5kKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW5rTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBsaW5rTm9kZS5hcHBlbmQobm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gJGdldExpbmtBbmNlc3Rvcihub2RlKSB7XG4gIHJldHVybiAkZ2V0QW5jZXN0b3Iobm9kZSwgJGlzTGlua05vZGUpO1xufVxuXG5mdW5jdGlvbiAkZ2V0QW5jZXN0b3Iobm9kZSwgcHJlZGljYXRlKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgKHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKSkgIT09IG51bGwgJiYgIXByZWRpY2F0ZShwYXJlbnQpKTtcblxuICByZXR1cm4gcGFyZW50O1xufVxuXG5leHBvcnRzLiRjcmVhdGVBdXRvTGlua05vZGUgPSAkY3JlYXRlQXV0b0xpbmtOb2RlO1xuZXhwb3J0cy4kY3JlYXRlTGlua05vZGUgPSAkY3JlYXRlTGlua05vZGU7XG5leHBvcnRzLiRpc0F1dG9MaW5rTm9kZSA9ICRpc0F1dG9MaW5rTm9kZTtcbmV4cG9ydHMuJGlzTGlua05vZGUgPSAkaXNMaW5rTm9kZTtcbmV4cG9ydHMuQXV0b0xpbmtOb2RlID0gQXV0b0xpbmtOb2RlO1xuZXhwb3J0cy5MaW5rTm9kZSA9IExpbmtOb2RlO1xuZXhwb3J0cy5UT0dHTEVfTElOS19DT01NQU5EID0gVE9HR0xFX0xJTktfQ09NTUFORDtcbmV4cG9ydHMudG9nZ2xlTGluayA9IHRvZ2dsZUxpbms7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/link/LexicalLink.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/link/LexicalLink.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/link/LexicalLink.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalLink =  true ? __webpack_require__(/*! ./LexicalLink.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/link/LexicalLink.dev.js\") : 0\nmodule.exports = LexicalLink;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9saW5rL0xleGljYWxMaW5rLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osb0JBQW9CLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxpR0FBc0IsSUFBSSxDQUFnQztBQUMvSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGluay9MZXhpY2FsTGluay5qcz9mMTNiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsTGluayA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsTGluay5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbExpbmsucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxMaW5rOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/link/LexicalLink.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/list/LexicalList.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/list/LexicalList.dev.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\n\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n\n    return depth;\n  }\n\n  return depth;\n}\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\n\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n\n  let parent = list;\n\n  while (parent !== null) {\n    parent = parent.getParent();\n\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n\n  return list;\n}\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\n\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n\n  return listItemNodes;\n}\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\n\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\n\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n\n    emptyListPtr = parent;\n  }\n\n  emptyListPtr.remove();\n}\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\n\nfunction wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\nfunction $getListItemValue(listItem) {\n  const list = listItem.getParent();\n  let value = 1;\n\n  if (list != null) {\n    if (!$isListNode(list)) {\n      {\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\n      }\n    } else {\n      value = list.getStart();\n    }\n  }\n\n  const siblings = listItem.getPreviousSiblings();\n\n  for (let i = 0; i < siblings.length; i++) {\n    const sibling = siblings[i];\n\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n      value++;\n    }\n  }\n\n  return value;\n}\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\n\n\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n\n          if (lexical.$isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n\n        return;\n      } else {\n        const handled = new Set();\n\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\n            createListOrMerge(node, listType);\n            continue;\n          }\n\n          if (lexical.$isLeafNode(node)) {\n            let parent = node.getParent();\n\n            while (parent != null) {\n              const parentKey = parent.getKey();\n\n              if ($isListNode(parent)) {\n                if (!handled.has(parentKey)) {\n                  const newListNode = $createListNode(listType);\n                  append(newListNode, parent.getChildren());\n                  parent.replace(newListNode);\n                  updateChildrenListItemValue(newListNode);\n                  handled.add(parentKey);\n                }\n\n                break;\n              } else {\n                const nextParent = parent.getParent();\n\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                  handled.add(parentKey);\n                  createListOrMerge(parent, listType);\n                  break;\n                }\n\n                parent = nextParent;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\n\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove(); // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    updateChildrenListItemValue(list);\n    return list;\n  }\n}\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\n\n\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n\n  const toMerge = list2.getChildren();\n\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n    updateChildrenListItemValue(list1);\n  }\n\n  list2.remove();\n}\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\n\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isLeafNode(node)) {\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n\n        for (const listItemNode of listItems) {\n          const paragraph = lexical.$createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph; // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n\n          listItemNode.remove();\n        }\n\n        listNode.remove();\n      }\n    }\n  });\n}\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. If only certain children should be updated, they\n * can be passed optionally in an array.\n * @param list - The list whose children are updated.\n * @param children - An array of the children to be updated.\n */\n\nfunction updateChildrenListItemValue(list, children) {\n  const childrenOrExisting = children || list.getChildren();\n\n  if (childrenOrExisting !== undefined) {\n    for (let i = 0; i < childrenOrExisting.length; i++) {\n      const child = childrenOrExisting[i];\n\n      if ($isListItemNode(child)) {\n        const prevValue = child.getValue();\n        const nextValue = $getListItemValue(child);\n\n        if (prevValue !== nextValue) {\n          child.setValue(nextValue);\n        }\n      }\n    }\n  }\n}\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\n\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n\n  const parent = listItemNode.getParent(); // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling(); // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      updateChildrenListItemValue(innerList);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n\n      updateChildrenListItemValue(newList);\n    }\n  }\n\n  if ($isListNode(parent)) {\n    updateChildrenListItemValue(parent);\n  }\n}\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\n\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined; // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      } // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings()); // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem); // replace the grandparent list item (now between the siblings) with the outdented list item.\n\n      grandparentListItem.replace(listItemNode);\n    }\n\n    updateChildrenListItemValue(parentList);\n    updateChildrenListItemValue(greatGrandparentList);\n  }\n}\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\n\nfunction $handleListInsertParagraph() {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  } // Only run this code on empty list items\n\n\n  const anchor = selection.anchor.getNode();\n\n  if (!$isListItemNode(anchor) || anchor.getTextContent() !== '') {\n    return false;\n  }\n\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n\n  const grandparent = parent.getParent();\n  let replacementNode;\n\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\n    replacementNode = lexical.$createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n\n    if (lexical.$isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  } // Don't leave hanging nested empty lists\n\n\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'listitem';\n  }\n\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    } // @ts-expect-error - this is always HTMLListItemElement\n\n\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static transform() {\n    return node => {\n      const parent = node.getParent();\n\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createListItemNode();\n    node.setChecked(serializedNode.checked);\n    node.setValue(serializedNode.value);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n\n    return this;\n  }\n\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) return replaceWithNode;\n\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n\n    if (includeChildren) {\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n\n    this.remove();\n\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n\n    return replaceWithNode;\n  }\n\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n\n    const siblings = this.getNextSiblings();\n\n    if ($isListItemNode(node)) {\n      const after = super.insertAfter(node, restoreSelection);\n      const afterListNode = node.getParentOrThrow();\n\n      if ($isListNode(afterListNode)) {\n        updateChildrenListItemValue(afterListNode);\n      }\n\n      return after;\n    } // Attempt to merge if the list is of the same type.\n\n\n    if ($isListNode(node)) {\n      let child = node;\n      const children = node.getChildren();\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        child = children[i];\n        this.insertAfter(child, restoreSelection);\n      }\n\n      return child;\n    } // Otherwise, split the list\n    // Split the lists and insert the node in between them\n\n\n    listNode.insertAfter(node, restoreSelection);\n\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n\n    return node;\n  }\n\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    } else if (nextSibling) {\n      const parent = nextSibling.getParent();\n\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n      }\n    }\n  }\n\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart(selection) {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove(); // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n\n    return true;\n  }\n\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return this.getLatest().__indent;\n    } // ListItemNode should always have a ListNode for a parent.\n\n\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n\n    return indentLevel;\n  }\n\n  setIndent(indent) {\n    if (!(typeof indent === 'number' && indent > -1)) {\n      throw Error(`Invalid indent value.`);\n    }\n\n    let currentIndent = this.getIndent();\n\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n\n    return this;\n  }\n\n  insertBefore(nodeToInsert) {\n    if ($isListItemNode(nodeToInsert)) {\n      const parent = this.getParentOrThrow();\n\n      if ($isListNode(parent)) {\n        const siblings = this.getNextSiblings();\n        updateChildrenListItemValue(parent, siblings);\n      }\n    }\n\n    return super.insertBefore(nodeToInsert);\n  }\n\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n\n  canMergeWith(node) {\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\n  }\n\n  extractWithChild(child, selection) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n\n  isParentRequired() {\n    return true;\n  }\n\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n\n}\n\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n\n  if (listItemClassName !== undefined) {\n    const listItemClasses = listItemClassName.split(' ');\n    classesToAdd.push(...listItemClasses);\n  }\n\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\n\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\n\nfunction convertListItemElement(domNode) {\n  const checked = utils.isHTMLElement(domNode) && domNode.getAttribute('aria-checked') === 'true';\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\n\n\nfunction $createListItemNode(checked) {\n  return lexical.$applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\n\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'list';\n  }\n\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n\n  constructor(listType, start, key) {\n    super(key);\n\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n\n  getTag() {\n    return this.__tag;\n  }\n\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n  }\n\n  getListType() {\n    return this.__listType;\n  }\n\n  getStart() {\n    return this.__start;\n  } // View\n\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    } // @ts-expect-error Internal field.\n\n\n    dom.__lexicalListType = this.__listType;\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if (lexical.$isElementNode(currentNode)) {\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n\n        super.append(listItemNode);\n      }\n    }\n\n    updateChildrenListItemValue(this);\n    return this;\n  }\n\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n\n}\n\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n\n    if (listLevelClassName !== undefined) {\n      const listItemClasses = listLevelClassName.split(' ');\n      classesToAdd.push(...listItemClasses);\n\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = nestedListClassName.split(' ');\n\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\n\n\nfunction normalizeChildren(nodes) {\n  const normalizedListItems = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push(wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push(wrapInListItem(node));\n    }\n  }\n\n  return normalizedListItems;\n}\n\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (utils.isHTMLElement(domNode) && domNode.getAttribute('__lexicallisttype') === 'check') {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n\n  return {\n    after: normalizeChildren,\n    node\n  };\n}\n\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\n\nfunction $createListNode(listType, start = 1) {\n  return lexical.$applyNodeReplacement(new ListNode(listType, start));\n}\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\n\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/** @module @lexical/list */\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = lexical.createCommand('REMOVE_LIST_COMMAND');\n\nexports.$createListItemNode = $createListItemNode;\nexports.$createListNode = $createListNode;\nexports.$getListDepth = $getListDepth;\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\nexports.$isListItemNode = $isListItemNode;\nexports.$isListNode = $isListNode;\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\nexports.ListItemNode = ListItemNode;\nexports.ListNode = ListNode;\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\nexports.insertList = insertList;\nexports.removeList = removeList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9saXN0L0xleGljYWxMaXN0LmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsc0VBQVM7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLHlGQUFnQjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSx3QkFBd0Isa0JBQWtCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLGtCQUFrQjtBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixrQ0FBa0M7QUFDbEMsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQixpQ0FBaUM7QUFDakMsbUNBQW1DO0FBQ25DLHFDQUFxQztBQUNyQyxvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCLDJCQUEyQjtBQUMzQixrQkFBa0I7QUFDbEIsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9saXN0L0xleGljYWxMaXN0LmRldi5qcz82MGI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbi8qKlxuICogQ2hlY2tzIHRoZSBkZXB0aCBvZiBsaXN0Tm9kZSBmcm9tIHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0gbGlzdE5vZGUgLSBUaGUgTGlzdE5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIFRoZSBkZXB0aCBvZiB0aGUgTGlzdE5vZGUuXG4gKi9cblxuZnVuY3Rpb24gJGdldExpc3REZXB0aChsaXN0Tm9kZSkge1xuICBsZXQgZGVwdGggPSAxO1xuICBsZXQgcGFyZW50ID0gbGlzdE5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShwYXJlbnQpKSB7XG4gICAgICBjb25zdCBwYXJlbnRMaXN0ID0gcGFyZW50LmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50TGlzdCkpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgICAgcGFyZW50ID0gcGFyZW50TGlzdC5nZXRQYXJlbnQoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEEgTGlzdEl0ZW1Ob2RlIG11c3QgaGF2ZSBhIExpc3ROb2RlIGZvciBhIHBhcmVudC5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVwdGg7XG4gIH1cblxuICByZXR1cm4gZGVwdGg7XG59XG4vKipcbiAqIEZpbmRzIHRoZSBuZWFyZXN0IGFuY2VzdHJhbCBMaXN0Tm9kZSBhbmQgcmV0dXJucyBpdCwgdGhyb3dzIGFuIGludmFyaWFudCBpZiBsaXN0SXRlbSBpcyBub3QgYSBMaXN0SXRlbU5vZGUuXG4gKiBAcGFyYW0gbGlzdEl0ZW0gLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVGhlIExpc3ROb2RlIGZvdW5kLlxuICovXG5cbmZ1bmN0aW9uICRnZXRUb3BMaXN0Tm9kZShsaXN0SXRlbSkge1xuICBsZXQgbGlzdCA9IGxpc3RJdGVtLmdldFBhcmVudCgpO1xuXG4gIGlmICghJGlzTGlzdE5vZGUobGlzdCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgQSBMaXN0SXRlbU5vZGUgbXVzdCBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LmApO1xuICAgIH1cbiAgfVxuXG4gIGxldCBwYXJlbnQgPSBsaXN0O1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgbGlzdCA9IHBhcmVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn1cbi8qKlxuICogQSByZWN1cnNpdmUgRGVwdGgtRmlyc3QgU2VhcmNoIChQb3N0b3JkZXIgVHJhdmVyc2FsKSB0aGF0IGZpbmRzIGFsbCBvZiBhIG5vZGUncyBjaGlsZHJlblxuICogdGhhdCBhcmUgb2YgdHlwZSBMaXN0SXRlbU5vZGUgYW5kIHJldHVybnMgdGhlbSBpbiBhbiBhcnJheS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIExpc3ROb2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2guXG4gKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGFsbCBub2RlcyBvZiB0eXBlIExpc3RJdGVtTm9kZSBmb3VuZC5cbiAqL1xuLy8gVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgJGdldEFsbENoaWxkcmVuT2ZUeXBlXG5cbmZ1bmN0aW9uICRnZXRBbGxMaXN0SXRlbXMobm9kZSkge1xuICBsZXQgbGlzdEl0ZW1Ob2RlcyA9IFtdO1xuICBjb25zdCBsaXN0Q2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCkuZmlsdGVyKCRpc0xpc3RJdGVtTm9kZSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsaXN0SXRlbU5vZGUgPSBsaXN0Q2hpbGRyZW5baV07XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IGxpc3RJdGVtTm9kZS5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICBpZiAoJGlzTGlzdE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgIGxpc3RJdGVtTm9kZXMgPSBsaXN0SXRlbU5vZGVzLmNvbmNhdCgkZ2V0QWxsTGlzdEl0ZW1zKGZpcnN0Q2hpbGQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdEl0ZW1Ob2Rlcy5wdXNoKGxpc3RJdGVtTm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxpc3RJdGVtTm9kZXM7XG59XG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHBhc3NlZCBub2RlIGlzIGEgTGlzdEl0ZW1Ob2RlIGFuZCBoYXMgYSBMaXN0Tm9kZSBhcyBhIGNoaWxkLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIExpc3RJdGVtTm9kZSBhbmQgaGFzIGEgTGlzdE5vZGUgY2hpbGQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc05lc3RlZExpc3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShub2RlKSAmJiAkaXNMaXN0Tm9kZShub2RlLmdldEZpcnN0Q2hpbGQoKSk7XG59XG4vKipcbiAqIFRha2VzIGEgZGVlcGx5IG5lc3RlZCBMaXN0Tm9kZSBvciBMaXN0SXRlbU5vZGUgYW5kIHRyYXZlcnNlcyB1cCB0aGUgYnJhbmNoIHRvIGRlbGV0ZSB0aGUgZmlyc3RcbiAqIGFuY2VzdHJhbCBMaXN0Tm9kZSAod2hpY2ggY291bGQgYmUgdGhlIHJvb3QgTGlzdE5vZGUpIG9yIExpc3RJdGVtTm9kZSB3aXRoIHNpYmxpbmdzLCBlc3NlbnRpYWxseVxuICogYnJpbmdpbmcgdGhlIGRlZXBseSBuZXN0ZWQgbm9kZSB1cCB0aGUgYnJhbmNoIG9uY2UuIFdvdWxkIHJlbW92ZSBzdWJsaXN0IGlmIGl0IGhhcyBzaWJsaW5ncy5cbiAqIFNob3VsZCBub3QgYnJlYWsgTGlzdEl0ZW0gLT4gTGlzdCAtPiBMaXN0SXRlbSBjaGFpbiBhcyBlbXB0eSBMaXN0L0l0ZW1Ob2RlcyBzaG91bGQgYmUgcmVtb3ZlZCBvbiAucmVtb3ZlKCkuXG4gKiBAcGFyYW0gc3VibGlzdCAtIFRoZSBuZXN0ZWQgTGlzdE5vZGUgb3IgTGlzdEl0ZW1Ob2RlIHRvIGJlIGJyb3VnaHQgdXAgdGhlIGJyYW5jaC5cbiAqL1xuXG5mdW5jdGlvbiAkcmVtb3ZlSGlnaGVzdEVtcHR5TGlzdFBhcmVudChzdWJsaXN0KSB7XG4gIC8vIE5vZGVzIG1heSBiZSByZXBlYXRlZGx5IGluZGVudGVkLCB0byBjcmVhdGUgZGVlcGx5IG5lc3RlZCBsaXN0cyB0aGF0IGVhY2hcbiAgLy8gY29udGFpbiBqdXN0IG9uZSBidWxsZXQuXG4gIC8vIE91ciBnb2FsIGlzIHRvIHJlbW92ZSB0aGVzZSAoZW1wdHkpIGRlZXBseSBuZXN0ZWQgbGlzdHMuIFRoZSBlYXNpZXN0XG4gIC8vIHdheSB0byBkbyB0aGF0IGlzIGNyYXdsIGJhY2sgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIG5vZGUgdGhhdCBoYXMgc2libGluZ3NcbiAgLy8gKGUuZy4gaXMgYWN0dWFsbHkgcGFydCBvZiB0aGUgbGlzdCBjb250ZW50cykgYW5kIGRlbGV0ZSB0aGF0LCBvciBkZWxldGVcbiAgLy8gdGhlIHJvb3Qgb2YgdGhlIGxpc3QgKGlmIG5vIGxpc3Qgbm9kZXMgaGF2ZSBzaWJsaW5ncy4pXG4gIGxldCBlbXB0eUxpc3RQdHIgPSBzdWJsaXN0O1xuXG4gIHdoaWxlIChlbXB0eUxpc3RQdHIuZ2V0TmV4dFNpYmxpbmcoKSA9PSBudWxsICYmIGVtcHR5TGlzdFB0ci5nZXRQcmV2aW91c1NpYmxpbmcoKSA9PSBudWxsKSB7XG4gICAgY29uc3QgcGFyZW50ID0gZW1wdHlMaXN0UHRyLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKHBhcmVudCA9PSBudWxsIHx8ICEoJGlzTGlzdEl0ZW1Ob2RlKGVtcHR5TGlzdFB0cikgfHwgJGlzTGlzdE5vZGUoZW1wdHlMaXN0UHRyKSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGVtcHR5TGlzdFB0ciA9IHBhcmVudDtcbiAgfVxuXG4gIGVtcHR5TGlzdFB0ci5yZW1vdmUoKTtcbn1cbi8qKlxuICogV3JhcHMgYSBub2RlIGludG8gYSBMaXN0SXRlbU5vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIHdyYXBwZWQgaW50byBhIExpc3RJdGVtTm9kZVxuICogQHJldHVybnMgVGhlIExpc3RJdGVtTm9kZSB3aGljaCB0aGUgcGFzc2VkIG5vZGUgaXMgd3JhcHBlZCBpbi5cbiAqL1xuXG5mdW5jdGlvbiB3cmFwSW5MaXN0SXRlbShub2RlKSB7XG4gIGNvbnN0IGxpc3RJdGVtV3JhcHBlciA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgcmV0dXJuIGxpc3RJdGVtV3JhcHBlci5hcHBlbmQobm9kZSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJGlzU2VsZWN0aW5nRW1wdHlMaXN0SXRlbShhbmNob3JOb2RlLCBub2Rlcykge1xuICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKGFuY2hvck5vZGUpICYmIChub2Rlcy5sZW5ndGggPT09IDAgfHwgbm9kZXMubGVuZ3RoID09PSAxICYmIGFuY2hvck5vZGUuaXMobm9kZXNbMF0pICYmIGFuY2hvck5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApO1xufVxuXG5mdW5jdGlvbiAkZ2V0TGlzdEl0ZW1WYWx1ZShsaXN0SXRlbSkge1xuICBjb25zdCBsaXN0ID0gbGlzdEl0ZW0uZ2V0UGFyZW50KCk7XG4gIGxldCB2YWx1ZSA9IDE7XG5cbiAgaWYgKGxpc3QgIT0gbnVsbCkge1xuICAgIGlmICghJGlzTGlzdE5vZGUobGlzdCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYCRnZXRMaXN0SXRlbVZhbHVlOiBsaXN0IG5vZGUgaXMgbm90IHBhcmVudCBvZiBsaXN0IGl0ZW0gbm9kZWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGxpc3QuZ2V0U3RhcnQoKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzaWJsaW5ncyA9IGxpc3RJdGVtLmdldFByZXZpb3VzU2libGluZ3MoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpYmxpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2libGluZyA9IHNpYmxpbmdzW2ldO1xuXG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShzaWJsaW5nKSAmJiAhJGlzTGlzdE5vZGUoc2libGluZy5nZXRGaXJzdENoaWxkKCkpKSB7XG4gICAgICB2YWx1ZSsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogSW5zZXJ0cyBhIG5ldyBMaXN0Tm9kZS4gSWYgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBub2RlIGlzIGFuIGVtcHR5IExpc3RJdGVtTm9kZSBhbmQgaXMgYSBjaGlsZCBvZlxuICogdGhlIHJvb3Qvc2hhZG93IHJvb3QsIGl0IHdpbGwgcmVwbGFjZSB0aGUgTGlzdEl0ZW1Ob2RlIHdpdGggYSBMaXN0Tm9kZSBhbmQgdGhlIG9sZCBMaXN0SXRlbU5vZGUuXG4gKiBPdGhlcndpc2UgaXQgd2lsbCByZXBsYWNlIGl0cyBwYXJlbnQgd2l0aCBhIG5ldyBMaXN0Tm9kZSBhbmQgcmUtaW5zZXJ0IHRoZSBMaXN0SXRlbU5vZGUgYW5kIGFueSBwcmV2aW91cyBjaGlsZHJlbi5cbiAqIElmIHRoZSBzZWxlY3Rpb24ncyBhbmNob3Igbm9kZSBpcyBub3QgYW4gZW1wdHkgTGlzdEl0ZW1Ob2RlLCBpdCB3aWxsIGFkZCBhIG5ldyBMaXN0Tm9kZSBvciBtZXJnZSBhbiBleGlzdGluZyBMaXN0Tm9kZSxcbiAqIHVubGVzcyB0aGUgdGhlIG5vZGUgaXMgYSBsZWFmIG5vZGUsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBhdHRlbXB0IHRvIGZpbmQgYSBMaXN0Tm9kZSB1cCB0aGUgYnJhbmNoIGFuZCByZXBsYWNlIGl0IHdpdGhcbiAqIGEgbmV3IExpc3ROb2RlLCBvciBjcmVhdGUgYSBuZXcgTGlzdE5vZGUgYXQgdGhlIG5lYXJlc3Qgcm9vdC9zaGFkb3cgcm9vdC5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gbGlzdFR5cGUgLSBUaGUgdHlwZSBvZiBsaXN0LCBcIm51bWJlclwiIHwgXCJidWxsZXRcIiB8IFwiY2hlY2tcIi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydExpc3QoZWRpdG9yLCBsaXN0VHlwZSkge1xuICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGVQYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAoJGlzU2VsZWN0aW5nRW1wdHlMaXN0SXRlbShhbmNob3JOb2RlLCBub2RlcykpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG5cbiAgICAgICAgaWYgKGxleGljYWwuJGlzUm9vdE9yU2hhZG93Um9vdChhbmNob3JOb2RlUGFyZW50KSkge1xuICAgICAgICAgIGFuY2hvck5vZGUucmVwbGFjZShsaXN0KTtcbiAgICAgICAgICBjb25zdCBsaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcblxuICAgICAgICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICBsaXN0SXRlbS5zZXRGb3JtYXQoYW5jaG9yTm9kZS5nZXRGb3JtYXRUeXBlKCkpO1xuICAgICAgICAgICAgbGlzdEl0ZW0uc2V0SW5kZW50KGFuY2hvck5vZGUuZ2V0SW5kZW50KCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3QuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICAgICAgfSBlbHNlIGlmICgkaXNMaXN0SXRlbU5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgICBhcHBlbmQobGlzdCwgcGFyZW50LmdldENoaWxkcmVuKCkpO1xuICAgICAgICAgIHBhcmVudC5yZXBsYWNlKGxpc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaGFuZGxlZCA9IG5ldyBTZXQoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICAgICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0VtcHR5KCkgJiYgIWhhbmRsZWQuaGFzKG5vZGUuZ2V0S2V5KCkpKSB7XG4gICAgICAgICAgICBjcmVhdGVMaXN0T3JNZXJnZShub2RlLCBsaXN0VHlwZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGV4aWNhbC4kaXNMZWFmTm9kZShub2RlKSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJlbnRLZXkgPSBwYXJlbnQuZ2V0S2V5KCk7XG5cbiAgICAgICAgICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZWQuaGFzKHBhcmVudEtleSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpc3ROb2RlID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICAgICAgICAgICAgICAgIGFwcGVuZChuZXdMaXN0Tm9kZSwgcGFyZW50LmdldENoaWxkcmVuKCkpO1xuICAgICAgICAgICAgICAgICAgcGFyZW50LnJlcGxhY2UobmV3TGlzdE5vZGUpO1xuICAgICAgICAgICAgICAgICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKG5ld0xpc3ROb2RlKTtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZWQuYWRkKHBhcmVudEtleSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChsZXhpY2FsLiRpc1Jvb3RPclNoYWRvd1Jvb3QobmV4dFBhcmVudCkgJiYgIWhhbmRsZWQuaGFzKHBhcmVudEtleSkpIHtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZWQuYWRkKHBhcmVudEtleSk7XG4gICAgICAgICAgICAgICAgICBjcmVhdGVMaXN0T3JNZXJnZShwYXJlbnQsIGxpc3RUeXBlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5leHRQYXJlbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhcHBlbmQobm9kZSwgbm9kZXNUb0FwcGVuZCkge1xuICBub2RlLnNwbGljZShub2RlLmdldENoaWxkcmVuU2l6ZSgpLCAwLCBub2Rlc1RvQXBwZW5kKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlzdE9yTWVyZ2Uobm9kZSwgbGlzdFR5cGUpIHtcbiAgaWYgKCRpc0xpc3ROb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgY29uc3QgbGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gIGxpc3RJdGVtLnNldEZvcm1hdChub2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gIGxpc3RJdGVtLnNldEluZGVudChub2RlLmdldEluZGVudCgpKTtcbiAgYXBwZW5kKGxpc3RJdGVtLCBub2RlLmdldENoaWxkcmVuKCkpO1xuXG4gIGlmICgkaXNMaXN0Tm9kZShwcmV2aW91c1NpYmxpbmcpICYmIGxpc3RUeXBlID09PSBwcmV2aW91c1NpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgIHByZXZpb3VzU2libGluZy5hcHBlbmQobGlzdEl0ZW0pO1xuICAgIG5vZGUucmVtb3ZlKCk7IC8vIGlmIHRoZSBzYW1lIHR5cGUgb2YgbGlzdCBpcyBvbiBib3RoIHNpZGVzLCBtZXJnZSB0aGVtLlxuXG4gICAgaWYgKCRpc0xpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBsaXN0VHlwZSA9PT0gbmV4dFNpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgICAgYXBwZW5kKHByZXZpb3VzU2libGluZywgbmV4dFNpYmxpbmcuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICBuZXh0U2libGluZy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJldmlvdXNTaWJsaW5nO1xuICB9IGVsc2UgaWYgKCRpc0xpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBsaXN0VHlwZSA9PT0gbmV4dFNpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgIG5leHRTaWJsaW5nLmdldEZpcnN0Q2hpbGRPclRocm93KCkuaW5zZXJ0QmVmb3JlKGxpc3RJdGVtKTtcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIHJldHVybiBuZXh0U2libGluZztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICBsaXN0LmFwcGVuZChsaXN0SXRlbSk7XG4gICAgbm9kZS5yZXBsYWNlKGxpc3QpO1xuICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShsaXN0KTtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxufVxuLyoqXG4gKiBBIHJlY3Vyc2l2ZSBmdW5jdGlvbiB0aGF0IGdvZXMgdGhyb3VnaCBlYWNoIGxpc3QgYW5kIHRoZWlyIGNoaWxkcmVuLCBpbmNsdWRpbmcgbmVzdGVkIGxpc3RzLFxuICogYXBwZW5kaW5nIGxpc3QyIGNoaWxkcmVuIGFmdGVyIGxpc3QxIGNoaWxkcmVuIGFuZCB1cGRhdGluZyBMaXN0SXRlbU5vZGUgdmFsdWVzLlxuICogQHBhcmFtIGxpc3QxIC0gVGhlIGZpcnN0IGxpc3QgdG8gYmUgbWVyZ2VkLlxuICogQHBhcmFtIGxpc3QyIC0gVGhlIHNlY29uZCBsaXN0IHRvIGJlIG1lcmdlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlTGlzdHMobGlzdDEsIGxpc3QyKSB7XG4gIGNvbnN0IGxpc3RJdGVtMSA9IGxpc3QxLmdldExhc3RDaGlsZCgpO1xuICBjb25zdCBsaXN0SXRlbTIgPSBsaXN0Mi5nZXRGaXJzdENoaWxkKCk7XG5cbiAgaWYgKGxpc3RJdGVtMSAmJiBsaXN0SXRlbTIgJiYgaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbTEpICYmIGlzTmVzdGVkTGlzdE5vZGUobGlzdEl0ZW0yKSkge1xuICAgIG1lcmdlTGlzdHMobGlzdEl0ZW0xLmdldEZpcnN0Q2hpbGQoKSwgbGlzdEl0ZW0yLmdldEZpcnN0Q2hpbGQoKSk7XG4gICAgbGlzdEl0ZW0yLnJlbW92ZSgpO1xuICB9XG5cbiAgY29uc3QgdG9NZXJnZSA9IGxpc3QyLmdldENoaWxkcmVuKCk7XG5cbiAgaWYgKHRvTWVyZ2UubGVuZ3RoID4gMCkge1xuICAgIGxpc3QxLmFwcGVuZCguLi50b01lcmdlKTtcbiAgICB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUobGlzdDEpO1xuICB9XG5cbiAgbGlzdDIucmVtb3ZlKCk7XG59XG4vKipcbiAqIFNlYXJjaGVzIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RyYWwgTGlzdE5vZGUgYW5kIHJlbW92ZXMgaXQuIElmIHNlbGVjdGlvbiBpcyBhbiBlbXB0eSBMaXN0SXRlbU5vZGVcbiAqIGl0IHdpbGwgcmVtb3ZlIHRoZSB3aG9sZSBsaXN0LCBpbmNsdWRpbmcgdGhlIExpc3RJdGVtTm9kZS4gRm9yIGVhY2ggTGlzdEl0ZW1Ob2RlIGluIHRoZSBMaXN0Tm9kZSxcbiAqIHJlbW92ZUxpc3Qgd2lsbCBhbHNvIGdlbmVyYXRlIG5ldyBQYXJhZ3JhcGhOb2RlcyBpbiB0aGUgcmVtb3ZlZCBMaXN0Tm9kZSdzIHBsYWNlLiBBbnkgY2hpbGQgbm9kZVxuICogaW5zaWRlIGEgTGlzdEl0ZW1Ob2RlIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIG5ldyBQYXJhZ3JhcGhOb2Rlcy5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlTGlzdChlZGl0b3IpIHtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBsaXN0Tm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuXG4gICAgICBpZiAoJGlzU2VsZWN0aW5nRW1wdHlMaXN0SXRlbShhbmNob3JOb2RlLCBub2RlcykpIHtcbiAgICAgICAgbGlzdE5vZGVzLmFkZCgkZ2V0VG9wTGlzdE5vZGUoYW5jaG9yTm9kZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgICAgIGlmIChsZXhpY2FsLiRpc0xlYWZOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0SXRlbU5vZGUgPSB1dGlscy4kZ2V0TmVhcmVzdE5vZGVPZlR5cGUobm9kZSwgTGlzdEl0ZW1Ob2RlKTtcblxuICAgICAgICAgICAgaWYgKGxpc3RJdGVtTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGxpc3ROb2Rlcy5hZGQoJGdldFRvcExpc3ROb2RlKGxpc3RJdGVtTm9kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGxpc3ROb2RlIG9mIGxpc3ROb2Rlcykge1xuICAgICAgICBsZXQgaW5zZXJ0aW9uUG9pbnQgPSBsaXN0Tm9kZTtcbiAgICAgICAgY29uc3QgbGlzdEl0ZW1zID0gJGdldEFsbExpc3RJdGVtcyhsaXN0Tm9kZSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBsaXN0SXRlbU5vZGUgb2YgbGlzdEl0ZW1zKSB7XG4gICAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICAgIGFwcGVuZChwYXJhZ3JhcGgsIGxpc3RJdGVtTm9kZS5nZXRDaGlsZHJlbigpKTtcbiAgICAgICAgICBpbnNlcnRpb25Qb2ludC5pbnNlcnRBZnRlcihwYXJhZ3JhcGgpO1xuICAgICAgICAgIGluc2VydGlvblBvaW50ID0gcGFyYWdyYXBoOyAvLyBXaGVuIHRoZSBhbmNob3IgYW5kIGZvY3VzIGZhbGwgb24gdGhlIHRleHROb2RlXG4gICAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgdGhlIHNlbGVjdGlvbiBiZWNhdXNlIHRoZSB0ZXh0Tm9kZSB3aWxsIGJlIGFwcGVuZGVkIHRvXG4gICAgICAgICAgLy8gdGhlIG5ld2x5IGdlbmVyYXRlZCBwYXJhZ3JhcGguXG4gICAgICAgICAgLy8gV2hlbiBzZWxlY3Rpb24gaXMgaW4gZW1wdHkgbmVzdGVkIGxpc3QgaXRlbSwgc2VsZWN0aW9uIGlzIGFjdHVhbGx5IG9uIHRoZSBsaXN0SXRlbU5vZGUuXG4gICAgICAgICAgLy8gV2hlbiB0aGUgY29ycmVzcG9uZGluZyBsaXN0SXRlbU5vZGUgaXMgZGVsZXRlZCBhbmQgcmVwbGFjZWQgYnkgdGhlIG5ld2x5IGdlbmVyYXRlZCBwYXJhZ3JhcGhcbiAgICAgICAgICAvLyB3ZSBzaG91bGQgbWFudWFsbHkgc2V0IHRoZSBzZWxlY3Rpb24ncyBmb2N1cyBhbmQgYW5jaG9yIHRvIHRoZSBuZXdseSBnZW5lcmF0ZWQgcGFyYWdyYXBoLlxuXG4gICAgICAgICAgaWYgKGxpc3RJdGVtTm9kZS5fX2tleSA9PT0gc2VsZWN0aW9uLmFuY2hvci5rZXkpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hbmNob3Iuc2V0KHBhcmFncmFwaC5nZXRLZXkoKSwgMCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGlzdEl0ZW1Ob2RlLl9fa2V5ID09PSBzZWxlY3Rpb24uZm9jdXMua2V5KSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXMuc2V0KHBhcmFncmFwaC5nZXRLZXkoKSwgMCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0SXRlbU5vZGUucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBUYWtlcyB0aGUgdmFsdWUgb2YgYSBjaGlsZCBMaXN0SXRlbU5vZGUgYW5kIG1ha2VzIGl0IHRoZSB2YWx1ZSB0aGUgTGlzdEl0ZW1Ob2RlXG4gKiBzaG91bGQgYmUgaWYgaXQgaXNuJ3QgYWxyZWFkeS4gSWYgb25seSBjZXJ0YWluIGNoaWxkcmVuIHNob3VsZCBiZSB1cGRhdGVkLCB0aGV5XG4gKiBjYW4gYmUgcGFzc2VkIG9wdGlvbmFsbHkgaW4gYW4gYXJyYXkuXG4gKiBAcGFyYW0gbGlzdCAtIFRoZSBsaXN0IHdob3NlIGNoaWxkcmVuIGFyZSB1cGRhdGVkLlxuICogQHBhcmFtIGNoaWxkcmVuIC0gQW4gYXJyYXkgb2YgdGhlIGNoaWxkcmVuIHRvIGJlIHVwZGF0ZWQuXG4gKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKGxpc3QsIGNoaWxkcmVuKSB7XG4gIGNvbnN0IGNoaWxkcmVuT3JFeGlzdGluZyA9IGNoaWxkcmVuIHx8IGxpc3QuZ2V0Q2hpbGRyZW4oKTtcblxuICBpZiAoY2hpbGRyZW5PckV4aXN0aW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuT3JFeGlzdGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbk9yRXhpc3RpbmdbaV07XG5cbiAgICAgIGlmICgkaXNMaXN0SXRlbU5vZGUoY2hpbGQpKSB7XG4gICAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IGNoaWxkLmdldFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9ICRnZXRMaXN0SXRlbVZhbHVlKGNoaWxkKTtcblxuICAgICAgICBpZiAocHJldlZhbHVlICE9PSBuZXh0VmFsdWUpIHtcbiAgICAgICAgICBjaGlsZC5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEFkZHMgYW4gZW1wdHkgTGlzdE5vZGUvTGlzdEl0ZW1Ob2RlIGNoYWluIGF0IGxpc3RJdGVtTm9kZSwgc28gYXMgdG9cbiAqIGNyZWF0ZSBhbiBpbmRlbnQgZWZmZWN0LiBXb24ndCBpbmRlbnQgTGlzdEl0ZW1Ob2RlcyB0aGF0IGhhdmUgYSBMaXN0Tm9kZSBhc1xuICogYSBjaGlsZCwgYnV0IGRvZXMgbWVyZ2Ugc2libGluZyBMaXN0SXRlbU5vZGVzIGlmIG9uZSBoYXMgYSBuZXN0ZWQgTGlzdE5vZGUuXG4gKiBAcGFyYW0gbGlzdEl0ZW1Ob2RlIC0gVGhlIExpc3RJdGVtTm9kZSB0byBiZSBpbmRlbnRlZC5cbiAqL1xuXG5mdW5jdGlvbiAkaGFuZGxlSW5kZW50KGxpc3RJdGVtTm9kZSkge1xuICAvLyBnbyB0aHJvdWdoIGVhY2ggbm9kZSBhbmQgZGVjaWRlIHdoZXJlIHRvIG1vdmUgaXQuXG4gIGNvbnN0IHJlbW92ZWQgPSBuZXcgU2V0KCk7XG5cbiAgaWYgKGlzTmVzdGVkTGlzdE5vZGUobGlzdEl0ZW1Ob2RlKSB8fCByZW1vdmVkLmhhcyhsaXN0SXRlbU5vZGUuZ2V0S2V5KCkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGFyZW50ID0gbGlzdEl0ZW1Ob2RlLmdldFBhcmVudCgpOyAvLyBXZSBjYW4gY2FzdCBib3RoIG9mIHRoZSBiZWxvdyBgaXNOZXN0ZWRMaXN0Tm9kZWAgb25seSByZXR1cm5zIGEgYm9vbGVhbiB0eXBlIGluc3RlYWQgb2YgYSB1c2VyLWRlZmluZWQgdHlwZSBndWFyZHNcblxuICBjb25zdCBuZXh0U2libGluZyA9IGxpc3RJdGVtTm9kZS5nZXROZXh0U2libGluZygpO1xuICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBsaXN0SXRlbU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7IC8vIGlmIHRoZXJlIGFyZSBuZXN0ZWQgbGlzdHMgb24gZWl0aGVyIHNpZGUsIG1lcmdlIHRoZW0gYWxsIHRvZ2V0aGVyLlxuXG4gIGlmIChpc05lc3RlZExpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBpc05lc3RlZExpc3ROb2RlKHByZXZpb3VzU2libGluZykpIHtcbiAgICBjb25zdCBpbm5lckxpc3QgPSBwcmV2aW91c1NpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgaWYgKCRpc0xpc3ROb2RlKGlubmVyTGlzdCkpIHtcbiAgICAgIGlubmVyTGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGNvbnN0IG5leHRJbm5lckxpc3QgPSBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICAgIGlmICgkaXNMaXN0Tm9kZShuZXh0SW5uZXJMaXN0KSkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5leHRJbm5lckxpc3QuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgYXBwZW5kKGlubmVyTGlzdCwgY2hpbGRyZW4pO1xuICAgICAgICBuZXh0U2libGluZy5yZW1vdmUoKTtcbiAgICAgICAgcmVtb3ZlZC5hZGQobmV4dFNpYmxpbmcuZ2V0S2V5KCkpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUoaW5uZXJMaXN0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAvLyBpZiB0aGUgTGlzdEl0ZW1Ob2RlIGlzIG5leHQgdG8gYSBuZXN0ZWQgTGlzdE5vZGUsIG1lcmdlIHRoZW1cbiAgICBjb25zdCBpbm5lckxpc3QgPSBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICBpZiAoJGlzTGlzdE5vZGUoaW5uZXJMaXN0KSkge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGlubmVyTGlzdC5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKGxpc3RJdGVtTm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShpbm5lckxpc3QpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc05lc3RlZExpc3ROb2RlKHByZXZpb3VzU2libGluZykpIHtcbiAgICBjb25zdCBpbm5lckxpc3QgPSBwcmV2aW91c1NpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgaWYgKCRpc0xpc3ROb2RlKGlubmVyTGlzdCkpIHtcbiAgICAgIGlubmVyTGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShpbm5lckxpc3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UsIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IG5lc3RlZCBMaXN0Tm9kZVxuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICBjb25zdCBuZXdMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgIGNvbnN0IG5ld0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUocGFyZW50LmdldExpc3RUeXBlKCkpO1xuICAgICAgbmV3TGlzdEl0ZW0uYXBwZW5kKG5ld0xpc3QpO1xuICAgICAgbmV3TGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcblxuICAgICAgaWYgKHByZXZpb3VzU2libGluZykge1xuICAgICAgICBwcmV2aW91c1NpYmxpbmcuaW5zZXJ0QWZ0ZXIobmV3TGlzdEl0ZW0pO1xuICAgICAgfSBlbHNlIGlmIChuZXh0U2libGluZykge1xuICAgICAgICBuZXh0U2libGluZy5pbnNlcnRCZWZvcmUobmV3TGlzdEl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50LmFwcGVuZChuZXdMaXN0SXRlbSk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShuZXdMaXN0KTtcbiAgICB9XG4gIH1cblxuICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShwYXJlbnQpO1xuICB9XG59XG4vKipcbiAqIFJlbW92ZXMgYW4gaW5kZW50IGJ5IHJlbW92aW5nIGFuIGVtcHR5IExpc3ROb2RlL0xpc3RJdGVtTm9kZSBjaGFpbi4gQW4gaW5kZW50ZWQgTGlzdEl0ZW1Ob2RlXG4gKiBoYXMgYSBncmVhdCBncmFuZHBhcmVudCBub2RlIG9mIHR5cGUgTGlzdE5vZGUsIHdoaWNoIGlzIHdoZXJlIHRoZSBMaXN0SXRlbU5vZGUgd2lsbCByZXNpZGVcbiAqIHdpdGhpbiBhcyBhIGNoaWxkLlxuICogQHBhcmFtIGxpc3RJdGVtTm9kZSAtIFRoZSBMaXN0SXRlbU5vZGUgdG8gcmVtb3ZlIHRoZSBpbmRlbnQgKG91dGRlbnQpLlxuICovXG5cbmZ1bmN0aW9uICRoYW5kbGVPdXRkZW50KGxpc3RJdGVtTm9kZSkge1xuICAvLyBnbyB0aHJvdWdoIGVhY2ggbm9kZSBhbmQgZGVjaWRlIHdoZXJlIHRvIG1vdmUgaXQuXG4gIGlmIChpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtTm9kZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYXJlbnRMaXN0ID0gbGlzdEl0ZW1Ob2RlLmdldFBhcmVudCgpO1xuICBjb25zdCBncmFuZHBhcmVudExpc3RJdGVtID0gcGFyZW50TGlzdCA/IHBhcmVudExpc3QuZ2V0UGFyZW50KCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGdyZWF0R3JhbmRwYXJlbnRMaXN0ID0gZ3JhbmRwYXJlbnRMaXN0SXRlbSA/IGdyYW5kcGFyZW50TGlzdEl0ZW0uZ2V0UGFyZW50KCkgOiB1bmRlZmluZWQ7IC8vIElmIGl0IGRvZXNuJ3QgaGF2ZSB0aGVzZSBhbmNlc3RvcnMsIGl0J3Mgbm90IGluZGVudGVkLlxuXG4gIGlmICgkaXNMaXN0Tm9kZShncmVhdEdyYW5kcGFyZW50TGlzdCkgJiYgJGlzTGlzdEl0ZW1Ob2RlKGdyYW5kcGFyZW50TGlzdEl0ZW0pICYmICRpc0xpc3ROb2RlKHBhcmVudExpc3QpKSB7XG4gICAgLy8gaWYgaXQncyB0aGUgZmlyc3QgY2hpbGQgaW4gaXQncyBwYXJlbnQgbGlzdCwgaW5zZXJ0IGl0IGludG8gdGhlXG4gICAgLy8gZ3JlYXQgZ3JhbmRwYXJlbnQgbGlzdCBiZWZvcmUgdGhlIGdyYW5kcGFyZW50XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IHBhcmVudExpc3QgPyBwYXJlbnRMaXN0LmdldEZpcnN0Q2hpbGQoKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBsYXN0Q2hpbGQgPSBwYXJlbnRMaXN0ID8gcGFyZW50TGlzdC5nZXRMYXN0Q2hpbGQoKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChsaXN0SXRlbU5vZGUuaXMoZmlyc3RDaGlsZCkpIHtcbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QmVmb3JlKGxpc3RJdGVtTm9kZSk7XG5cbiAgICAgIGlmIChwYXJlbnRMaXN0LmlzRW1wdHkoKSkge1xuICAgICAgICBncmFuZHBhcmVudExpc3RJdGVtLnJlbW92ZSgpO1xuICAgICAgfSAvLyBpZiBpdCdzIHRoZSBsYXN0IGNoaWxkIGluIGl0J3MgcGFyZW50IGxpc3QsIGluc2VydCBpdCBpbnRvIHRoZVxuICAgICAgLy8gZ3JlYXQgZ3JhbmRwYXJlbnQgbGlzdCBhZnRlciB0aGUgZ3JhbmRwYXJlbnQuXG5cbiAgICB9IGVsc2UgaWYgKGxpc3RJdGVtTm9kZS5pcyhsYXN0Q2hpbGQpKSB7XG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLmluc2VydEFmdGVyKGxpc3RJdGVtTm9kZSk7XG5cbiAgICAgIGlmIChwYXJlbnRMaXN0LmlzRW1wdHkoKSkge1xuICAgICAgICBncmFuZHBhcmVudExpc3RJdGVtLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UsIHdlIG5lZWQgdG8gc3BsaXQgdGhlIHNpYmxpbmdzIGludG8gdHdvIG5ldyBuZXN0ZWQgbGlzdHNcbiAgICAgIGNvbnN0IGxpc3RUeXBlID0gcGFyZW50TGlzdC5nZXRMaXN0VHlwZSgpO1xuICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nc0xpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nc0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgICAgcHJldmlvdXNTaWJsaW5nc0xpc3RJdGVtLmFwcGVuZChwcmV2aW91c1NpYmxpbmdzTGlzdCk7XG4gICAgICBsaXN0SXRlbU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5ncygpLmZvckVhY2goc2libGluZyA9PiBwcmV2aW91c1NpYmxpbmdzTGlzdC5hcHBlbmQoc2libGluZykpO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmdzTGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgICBjb25zdCBuZXh0U2libGluZ3NMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICAgIG5leHRTaWJsaW5nc0xpc3RJdGVtLmFwcGVuZChuZXh0U2libGluZ3NMaXN0KTtcbiAgICAgIGFwcGVuZChuZXh0U2libGluZ3NMaXN0LCBsaXN0SXRlbU5vZGUuZ2V0TmV4dFNpYmxpbmdzKCkpOyAvLyBwdXQgdGhlIHNpYmxpbmcgbmVzdGVkIGxpc3RzIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBncmFuZHBhcmVudCBsaXN0IGl0ZW0gaW4gdGhlIGdyZWF0IGdyYW5kcGFyZW50LlxuXG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLmluc2VydEJlZm9yZShwcmV2aW91c1NpYmxpbmdzTGlzdEl0ZW0pO1xuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5pbnNlcnRBZnRlcihuZXh0U2libGluZ3NMaXN0SXRlbSk7IC8vIHJlcGxhY2UgdGhlIGdyYW5kcGFyZW50IGxpc3QgaXRlbSAobm93IGJldHdlZW4gdGhlIHNpYmxpbmdzKSB3aXRoIHRoZSBvdXRkZW50ZWQgbGlzdCBpdGVtLlxuXG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLnJlcGxhY2UobGlzdEl0ZW1Ob2RlKTtcbiAgICB9XG5cbiAgICB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUocGFyZW50TGlzdCk7XG4gICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKGdyZWF0R3JhbmRwYXJlbnRMaXN0KTtcbiAgfVxufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBpbnNlcnQgYSBQYXJhZ3JhcGhOb2RlIGF0IHNlbGVjdGlvbiBhbmQgc2VsZWN0cyB0aGUgbmV3IG5vZGUuIFRoZSBzZWxlY3Rpb24gbXVzdCBjb250YWluIGEgTGlzdEl0ZW1Ob2RlXG4gKiBvciBhIG5vZGUgdGhhdCBkb2VzIG5vdCBhbHJlYWR5IGNvbnRhaW4gdGV4dC4gSWYgaXRzIGdyYW5kcGFyZW50IGlzIHRoZSByb290L3NoYWRvdyByb290LCBpdCB3aWxsIGdldCB0aGUgTGlzdE5vZGVcbiAqICh3aGljaCBzaG91bGQgYmUgdGhlIHBhcmVudCBub2RlKSBhbmQgaW5zZXJ0IHRoZSBQYXJhZ3JhcGhOb2RlIGFzIGEgc2libGluZyB0byB0aGUgTGlzdE5vZGUuIElmIHRoZSBMaXN0Tm9kZSBpc1xuICogbmVzdGVkIGluIGEgTGlzdEl0ZW1Ob2RlIGluc3RlYWQsIGl0IHdpbGwgYWRkIHRoZSBQYXJhZ3JhcGhOb2RlIGFmdGVyIHRoZSBncmFuZHBhcmVudCBMaXN0SXRlbU5vZGUuXG4gKiBUaHJvd3MgYW4gaW52YXJpYW50IGlmIHRoZSBzZWxlY3Rpb24gaXMgbm90IGEgY2hpbGQgb2YgYSBMaXN0Tm9kZS5cbiAqIEByZXR1cm5zIHRydWUgaWYgYSBQYXJhZ3JhcGhOb2RlIHdhcyBpbnNlcnRlZCBzdWNjZXNmdWxseSwgZmFsc2UgaWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uXG4gKiBvciB0aGUgc2VsZWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gYSBMaXN0SXRlbU5vZGUgb3IgdGhlIG5vZGUgYWxyZWFkeSBob2xkcyB0ZXh0LlxuICovXG5cbmZ1bmN0aW9uICRoYW5kbGVMaXN0SW5zZXJ0UGFyYWdyYXBoKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gT25seSBydW4gdGhpcyBjb2RlIG9uIGVtcHR5IGxpc3QgaXRlbXNcblxuXG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuXG4gIGlmICghJGlzTGlzdEl0ZW1Ob2RlKGFuY2hvcikgfHwgYW5jaG9yLmdldFRleHRDb250ZW50KCkgIT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgdG9wTGlzdE5vZGUgPSAkZ2V0VG9wTGlzdE5vZGUoYW5jaG9yKTtcbiAgY29uc3QgcGFyZW50ID0gYW5jaG9yLmdldFBhcmVudCgpO1xuXG4gIGlmICghJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgIHRocm93IEVycm9yKGBBIExpc3RJdGVtTm9kZSBtdXN0IGhhdmUgYSBMaXN0Tm9kZSBmb3IgYSBwYXJlbnQuYCk7XG4gIH1cblxuICBjb25zdCBncmFuZHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgbGV0IHJlcGxhY2VtZW50Tm9kZTtcblxuICBpZiAobGV4aWNhbC4kaXNSb290T3JTaGFkb3dSb290KGdyYW5kcGFyZW50KSkge1xuICAgIHJlcGxhY2VtZW50Tm9kZSA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICB0b3BMaXN0Tm9kZS5pbnNlcnRBZnRlcihyZXBsYWNlbWVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCRpc0xpc3RJdGVtTm9kZShncmFuZHBhcmVudCkpIHtcbiAgICByZXBsYWNlbWVudE5vZGUgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgZ3JhbmRwYXJlbnQuaW5zZXJ0QWZ0ZXIocmVwbGFjZW1lbnROb2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXBsYWNlbWVudE5vZGUuc2VsZWN0KCk7XG4gIGNvbnN0IG5leHRTaWJsaW5ncyA9IGFuY2hvci5nZXROZXh0U2libGluZ3MoKTtcblxuICBpZiAobmV4dFNpYmxpbmdzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBuZXdMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKHBhcmVudC5nZXRMaXN0VHlwZSgpKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1BhcmFncmFwaE5vZGUocmVwbGFjZW1lbnROb2RlKSkge1xuICAgICAgcmVwbGFjZW1lbnROb2RlLmluc2VydEFmdGVyKG5ld0xpc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXdMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgIG5ld0xpc3RJdGVtLmFwcGVuZChuZXdMaXN0KTtcbiAgICAgIHJlcGxhY2VtZW50Tm9kZS5pbnNlcnRBZnRlcihuZXdMaXN0SXRlbSk7XG4gICAgfVxuXG4gICAgbmV4dFNpYmxpbmdzLmZvckVhY2goc2libGluZyA9PiB7XG4gICAgICBzaWJsaW5nLnJlbW92ZSgpO1xuICAgICAgbmV3TGlzdC5hcHBlbmQoc2libGluZyk7XG4gICAgfSk7XG4gIH0gLy8gRG9uJ3QgbGVhdmUgaGFuZ2luZyBuZXN0ZWQgZW1wdHkgbGlzdHNcblxuXG4gICRyZW1vdmVIaWdoZXN0RW1wdHlMaXN0UGFyZW50KGFuY2hvcik7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBMaXN0SXRlbU5vZGUgZXh0ZW5kcyBsZXhpY2FsLkVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdsaXN0aXRlbSc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgTGlzdEl0ZW1Ob2RlKG5vZGUuX192YWx1ZSwgbm9kZS5fX2NoZWNrZWQsIG5vZGUuX19rZXkpO1xuICB9XG5cbiAgY29uc3RydWN0b3IodmFsdWUsIGNoZWNrZWQsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX3ZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IDEgOiB2YWx1ZTtcbiAgICB0aGlzLl9fY2hlY2tlZCA9IGNoZWNrZWQ7XG4gIH1cblxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcblxuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpICYmIHBhcmVudC5nZXRMaXN0VHlwZSgpID09PSAnY2hlY2snKSB7XG4gICAgICB1cGRhdGVMaXN0SXRlbUNoZWNrZWQoZWxlbWVudCwgdGhpcywgbnVsbCk7XG4gICAgfVxuXG4gICAgZWxlbWVudC52YWx1ZSA9IHRoaXMuX192YWx1ZTtcbiAgICAkc2V0TGlzdEl0ZW1UaGVtZUNsYXNzTmFtZXMoZWxlbWVudCwgY29uZmlnLnRoZW1lLCB0aGlzKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkgJiYgcGFyZW50LmdldExpc3RUeXBlKCkgPT09ICdjaGVjaycpIHtcbiAgICAgIHVwZGF0ZUxpc3RJdGVtQ2hlY2tlZChkb20sIHRoaXMsIHByZXZOb2RlKTtcbiAgICB9IC8vIEB0cy1leHBlY3QtZXJyb3IgLSB0aGlzIGlzIGFsd2F5cyBIVE1MTGlzdEl0ZW1FbGVtZW50XG5cblxuICAgIGRvbS52YWx1ZSA9IHRoaXMuX192YWx1ZTtcbiAgICAkc2V0TGlzdEl0ZW1UaGVtZUNsYXNzTmFtZXMoZG9tLCBjb25maWcudGhlbWUsIHRoaXMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyB0cmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIG5vZGUgPT4ge1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcblxuICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKHBhcmVudCk7XG5cbiAgICAgICAgaWYgKHBhcmVudC5nZXRMaXN0VHlwZSgpICE9PSAnY2hlY2snICYmIG5vZGUuZ2V0Q2hlY2tlZCgpICE9IG51bGwpIHtcbiAgICAgICAgICBub2RlLnNldENoZWNrZWQodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaTogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0TGlzdEl0ZW1FbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgIG5vZGUuc2V0Q2hlY2tlZChzZXJpYWxpemVkTm9kZS5jaGVja2VkKTtcbiAgICBub2RlLnNldFZhbHVlKHNlcmlhbGl6ZWROb2RlLnZhbHVlKTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0RGlyZWN0aW9uKHNlcmlhbGl6ZWROb2RlLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGNoZWNrZWQ6IHRoaXMuZ2V0Q2hlY2tlZCgpLFxuICAgICAgdHlwZTogJ2xpc3RpdGVtJyxcbiAgICAgIHZhbHVlOiB0aGlzLmdldFZhbHVlKCksXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIGFwcGVuZCguLi5ub2Rlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgdGhpcy5jYW5NZXJnZVdpdGgobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuYXBwZW5kKC4uLmNoaWxkcmVuKTtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlcGxhY2UocmVwbGFjZVdpdGhOb2RlLCBpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKHJlcGxhY2VXaXRoTm9kZSkpIHtcbiAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKHJlcGxhY2VXaXRoTm9kZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRJbmRlbnQoMCk7XG4gICAgY29uc3QgbGlzdCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGlmICghJGlzTGlzdE5vZGUobGlzdCkpIHJldHVybiByZXBsYWNlV2l0aE5vZGU7XG5cbiAgICBpZiAobGlzdC5fX2ZpcnN0ID09PSB0aGlzLmdldEtleSgpKSB7XG4gICAgICBsaXN0Lmluc2VydEJlZm9yZShyZXBsYWNlV2l0aE5vZGUpO1xuICAgIH0gZWxzZSBpZiAobGlzdC5fX2xhc3QgPT09IHRoaXMuZ2V0S2V5KCkpIHtcbiAgICAgIGxpc3QuaW5zZXJ0QWZ0ZXIocmVwbGFjZVdpdGhOb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3BsaXQgdGhlIGxpc3RcbiAgICAgIGNvbnN0IG5ld0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdC5nZXRMaXN0VHlwZSgpKTtcbiAgICAgIGxldCBuZXh0U2libGluZyA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgd2hpbGUgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgIGNvbnN0IG5vZGVUb0FwcGVuZCA9IG5leHRTaWJsaW5nO1xuICAgICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIG5ld0xpc3QuYXBwZW5kKG5vZGVUb0FwcGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGxpc3QuaW5zZXJ0QWZ0ZXIocmVwbGFjZVdpdGhOb2RlKTtcbiAgICAgIHJlcGxhY2VXaXRoTm9kZS5pbnNlcnRBZnRlcihuZXdMaXN0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgICB0aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIHJlcGxhY2VXaXRoTm9kZS5hcHBlbmQoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmUoKTtcblxuICAgIGlmIChsaXN0LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBsaXN0LnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXBsYWNlV2l0aE5vZGU7XG4gIH1cblxuICBpbnNlcnRBZnRlcihub2RlLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGxpc3ROb2RlID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgICBpZiAoISRpc0xpc3ROb2RlKGxpc3ROb2RlKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0QWZ0ZXI6IGxpc3Qgbm9kZSBpcyBub3QgcGFyZW50IG9mIGxpc3QgaXRlbSBub2RlYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLmdldE5leHRTaWJsaW5ncygpO1xuXG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShub2RlKSkge1xuICAgICAgY29uc3QgYWZ0ZXIgPSBzdXBlci5pbnNlcnRBZnRlcihub2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICAgIGNvbnN0IGFmdGVyTGlzdE5vZGUgPSBub2RlLmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgICAgaWYgKCRpc0xpc3ROb2RlKGFmdGVyTGlzdE5vZGUpKSB7XG4gICAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShhZnRlckxpc3ROb2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFmdGVyO1xuICAgIH0gLy8gQXR0ZW1wdCB0byBtZXJnZSBpZiB0aGUgbGlzdCBpcyBvZiB0aGUgc2FtZSB0eXBlLlxuXG5cbiAgICBpZiAoJGlzTGlzdE5vZGUobm9kZSkpIHtcbiAgICAgIGxldCBjaGlsZCA9IG5vZGU7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcblxuICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIHRoaXMuaW5zZXJ0QWZ0ZXIoY2hpbGQsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSAvLyBPdGhlcndpc2UsIHNwbGl0IHRoZSBsaXN0XG4gICAgLy8gU3BsaXQgdGhlIGxpc3RzIGFuZCBpbnNlcnQgdGhlIG5vZGUgaW4gYmV0d2VlbiB0aGVtXG5cblxuICAgIGxpc3ROb2RlLmluc2VydEFmdGVyKG5vZGUsIHJlc3RvcmVTZWxlY3Rpb24pO1xuXG4gICAgaWYgKHNpYmxpbmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3QgbmV3TGlzdE5vZGUgPSAkY3JlYXRlTGlzdE5vZGUobGlzdE5vZGUuZ2V0TGlzdFR5cGUoKSk7XG4gICAgICBzaWJsaW5ncy5mb3JFYWNoKHNpYmxpbmcgPT4gbmV3TGlzdE5vZGUuYXBwZW5kKHNpYmxpbmcpKTtcbiAgICAgIG5vZGUuaW5zZXJ0QWZ0ZXIobmV3TGlzdE5vZGUsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmVtb3ZlKHByZXNlcnZlRW1wdHlQYXJlbnQpIHtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSB0aGlzLmdldE5leHRTaWJsaW5nKCk7XG4gICAgc3VwZXIucmVtb3ZlKHByZXNlcnZlRW1wdHlQYXJlbnQpO1xuXG4gICAgaWYgKHByZXZTaWJsaW5nICYmIG5leHRTaWJsaW5nICYmIGlzTmVzdGVkTGlzdE5vZGUocHJldlNpYmxpbmcpICYmIGlzTmVzdGVkTGlzdE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICBtZXJnZUxpc3RzKHByZXZTaWJsaW5nLmdldEZpcnN0Q2hpbGQoKSwgbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpKTtcbiAgICAgIG5leHRTaWJsaW5nLnJlbW92ZSgpO1xuICAgIH0gZWxzZSBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG5leHRTaWJsaW5nLmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgICB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUocGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpbnNlcnROZXdBZnRlcihfLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKHRoaXMuX19jaGVja2VkID09IG51bGwgPyB1bmRlZmluZWQgOiBmYWxzZSk7XG4gICAgdGhpcy5pbnNlcnRBZnRlcihuZXdFbGVtZW50LCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuXG4gIGNvbGxhcHNlQXRTdGFydChzZWxlY3Rpb24pIHtcbiAgICBjb25zdCBwYXJhZ3JhcGggPSBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBwYXJhZ3JhcGguYXBwZW5kKGNoaWxkKSk7XG4gICAgY29uc3QgbGlzdE5vZGUgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBjb25zdCBsaXN0Tm9kZVBhcmVudCA9IGxpc3ROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBjb25zdCBpc0luZGVudGVkID0gJGlzTGlzdEl0ZW1Ob2RlKGxpc3ROb2RlUGFyZW50KTtcblxuICAgIGlmIChsaXN0Tm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSkge1xuICAgICAgaWYgKGlzSW5kZW50ZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGxpc3Qgbm9kZSBpcyBuZXN0ZWQsIHdlIGp1c3Qgd2FudCB0byByZW1vdmUgaXQsXG4gICAgICAgIC8vIGVmZmVjdGl2ZWx5IHVuaW5kZW50aW5nIGl0LlxuICAgICAgICBsaXN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgICAgbGlzdE5vZGVQYXJlbnQuc2VsZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0Tm9kZS5pbnNlcnRCZWZvcmUocGFyYWdyYXBoKTtcbiAgICAgICAgbGlzdE5vZGUucmVtb3ZlKCk7IC8vIElmIHdlIGhhdmUgc2VsZWN0aW9uIG9uIHRoZSBsaXN0IGl0ZW0sIHdlJ2xsIG5lZWQgdG8gbW92ZSBpdFxuICAgICAgICAvLyB0byB0aGUgcGFyYWdyYXBoXG5cbiAgICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgICAgIGNvbnN0IGtleSA9IHBhcmFncmFwaC5nZXRLZXkoKTtcblxuICAgICAgICBpZiAoYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBhbmNob3IuZ2V0Tm9kZSgpLmlzKHRoaXMpKSB7XG4gICAgICAgICAgYW5jaG9yLnNldChrZXksIGFuY2hvci5vZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGZvY3VzLmdldE5vZGUoKS5pcyh0aGlzKSkge1xuICAgICAgICAgIGZvY3VzLnNldChrZXksIGZvY3VzLm9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0Tm9kZS5pbnNlcnRCZWZvcmUocGFyYWdyYXBoKTtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX3ZhbHVlO1xuICB9XG5cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX192YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0Q2hlY2tlZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2NoZWNrZWQ7XG4gIH1cblxuICBzZXRDaGVja2VkKGNoZWNrZWQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19jaGVja2VkID0gY2hlY2tlZDtcbiAgfVxuXG4gIHRvZ2dsZUNoZWNrZWQoKSB7XG4gICAgdGhpcy5zZXRDaGVja2VkKCF0aGlzLl9fY2hlY2tlZCk7XG4gIH1cblxuICBnZXRJbmRlbnQoKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHBhcmVudCwgd2UgYXJlIGxpa2VseSBzZXJpYWxpemluZ1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2luZGVudDtcbiAgICB9IC8vIExpc3RJdGVtTm9kZSBzaG91bGQgYWx3YXlzIGhhdmUgYSBMaXN0Tm9kZSBmb3IgYSBwYXJlbnQuXG5cblxuICAgIGxldCBsaXN0Tm9kZVBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgbGV0IGluZGVudExldmVsID0gMDtcblxuICAgIHdoaWxlICgkaXNMaXN0SXRlbU5vZGUobGlzdE5vZGVQYXJlbnQpKSB7XG4gICAgICBsaXN0Tm9kZVBhcmVudCA9IGxpc3ROb2RlUGFyZW50LmdldFBhcmVudE9yVGhyb3coKS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBpbmRlbnRMZXZlbCsrO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRlbnRMZXZlbDtcbiAgfVxuXG4gIHNldEluZGVudChpbmRlbnQpIHtcbiAgICBpZiAoISh0eXBlb2YgaW5kZW50ID09PSAnbnVtYmVyJyAmJiBpbmRlbnQgPiAtMSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIGluZGVudCB2YWx1ZS5gKTtcbiAgICB9XG5cbiAgICBsZXQgY3VycmVudEluZGVudCA9IHRoaXMuZ2V0SW5kZW50KCk7XG5cbiAgICB3aGlsZSAoY3VycmVudEluZGVudCAhPT0gaW5kZW50KSB7XG4gICAgICBpZiAoY3VycmVudEluZGVudCA8IGluZGVudCkge1xuICAgICAgICAkaGFuZGxlSW5kZW50KHRoaXMpO1xuICAgICAgICBjdXJyZW50SW5kZW50Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkaGFuZGxlT3V0ZGVudCh0aGlzKTtcbiAgICAgICAgY3VycmVudEluZGVudC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaW5zZXJ0QmVmb3JlKG5vZGVUb0luc2VydCkge1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobm9kZVRvSW5zZXJ0KSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gdGhpcy5nZXROZXh0U2libGluZ3MoKTtcbiAgICAgICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKHBhcmVudCwgc2libGluZ3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5pbnNlcnRCZWZvcmUobm9kZVRvSW5zZXJ0KTtcbiAgfVxuXG4gIGNhbkluc2VydEFmdGVyKG5vZGUpIHtcbiAgICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpO1xuICB9XG5cbiAgY2FuUmVwbGFjZVdpdGgocmVwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKHJlcGxhY2VtZW50KTtcbiAgfVxuXG4gIGNhbk1lcmdlV2l0aChub2RlKSB7XG4gICAgcmV0dXJuIGxleGljYWwuJGlzUGFyYWdyYXBoTm9kZShub2RlKSB8fCAkaXNMaXN0SXRlbU5vZGUobm9kZSk7XG4gIH1cblxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIHJldHVybiB0aGlzLmlzUGFyZW50T2YoYW5jaG9yTm9kZSkgJiYgdGhpcy5pc1BhcmVudE9mKGZvY3VzTm9kZSkgJiYgdGhpcy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aCA9PT0gc2VsZWN0aW9uLmdldFRleHRDb250ZW50KCkubGVuZ3RoO1xuICB9XG5cbiAgaXNQYXJlbnRSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNyZWF0ZVBhcmVudEVsZW1lbnROb2RlKCkge1xuICAgIHJldHVybiAkY3JlYXRlTGlzdE5vZGUoJ2J1bGxldCcpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gJHNldExpc3RJdGVtVGhlbWVDbGFzc05hbWVzKGRvbSwgZWRpdG9yVGhlbWVDbGFzc2VzLCBub2RlKSB7XG4gIGNvbnN0IGNsYXNzZXNUb0FkZCA9IFtdO1xuICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBbXTtcbiAgY29uc3QgbGlzdFRoZW1lID0gZWRpdG9yVGhlbWVDbGFzc2VzLmxpc3Q7XG4gIGNvbnN0IGxpc3RJdGVtQ2xhc3NOYW1lID0gbGlzdFRoZW1lID8gbGlzdFRoZW1lLmxpc3RpdGVtIDogdW5kZWZpbmVkO1xuICBsZXQgbmVzdGVkTGlzdEl0ZW1DbGFzc05hbWU7XG5cbiAgaWYgKGxpc3RUaGVtZSAmJiBsaXN0VGhlbWUubmVzdGVkKSB7XG4gICAgbmVzdGVkTGlzdEl0ZW1DbGFzc05hbWUgPSBsaXN0VGhlbWUubmVzdGVkLmxpc3RpdGVtO1xuICB9XG5cbiAgaWYgKGxpc3RJdGVtQ2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBsaXN0SXRlbUNsYXNzZXMgPSBsaXN0SXRlbUNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLmxpc3RJdGVtQ2xhc3Nlcyk7XG4gIH1cblxuICBpZiAobGlzdFRoZW1lKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgY29uc3QgaXNDaGVja0xpc3QgPSAkaXNMaXN0Tm9kZShwYXJlbnROb2RlKSAmJiBwYXJlbnROb2RlLmdldExpc3RUeXBlKCkgPT09ICdjaGVjayc7XG4gICAgY29uc3QgY2hlY2tlZCA9IG5vZGUuZ2V0Q2hlY2tlZCgpO1xuXG4gICAgaWYgKCFpc0NoZWNrTGlzdCB8fCBjaGVja2VkKSB7XG4gICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaChsaXN0VGhlbWUubGlzdGl0ZW1VbmNoZWNrZWQpO1xuICAgIH1cblxuICAgIGlmICghaXNDaGVja0xpc3QgfHwgIWNoZWNrZWQpIHtcbiAgICAgIGNsYXNzZXNUb1JlbW92ZS5wdXNoKGxpc3RUaGVtZS5saXN0aXRlbUNoZWNrZWQpO1xuICAgIH1cblxuICAgIGlmIChpc0NoZWNrTGlzdCkge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goY2hlY2tlZCA/IGxpc3RUaGVtZS5saXN0aXRlbUNoZWNrZWQgOiBsaXN0VGhlbWUubGlzdGl0ZW1VbmNoZWNrZWQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChuZXN0ZWRMaXN0SXRlbUNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbmVzdGVkTGlzdEl0ZW1DbGFzc2VzID0gbmVzdGVkTGlzdEl0ZW1DbGFzc05hbWUuc3BsaXQoJyAnKTtcblxuICAgIGlmIChub2RlLmdldENoaWxkcmVuKCkuc29tZShjaGlsZCA9PiAkaXNMaXN0Tm9kZShjaGlsZCkpKSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjbGFzc2VzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgIHV0aWxzLnJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChkb20sIC4uLmNsYXNzZXNUb1JlbW92ZSk7XG4gIH1cblxuICBpZiAoY2xhc3Nlc1RvQWRkLmxlbmd0aCA+IDApIHtcbiAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgLi4uY2xhc3Nlc1RvQWRkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0SXRlbUNoZWNrZWQoZG9tLCBsaXN0SXRlbU5vZGUsIHByZXZMaXN0SXRlbU5vZGUsIGxpc3ROb2RlKSB7XG4gIC8vIE9ubHkgYWRkIGF0dHJpYnV0ZXMgZm9yIGxlYWYgbGlzdCBpdGVtc1xuICBpZiAoJGlzTGlzdE5vZGUobGlzdEl0ZW1Ob2RlLmdldEZpcnN0Q2hpbGQoKSkpIHtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnKTtcbiAgfSBlbHNlIHtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2NoZWNrYm94Jyk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAnLTEnKTtcblxuICAgIGlmICghcHJldkxpc3RJdGVtTm9kZSB8fCBsaXN0SXRlbU5vZGUuX19jaGVja2VkICE9PSBwcmV2TGlzdEl0ZW1Ob2RlLl9fY2hlY2tlZCkge1xuICAgICAgZG9tLnNldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJywgbGlzdEl0ZW1Ob2RlLmdldENoZWNrZWQoKSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0TGlzdEl0ZW1FbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgY2hlY2tlZCA9IHV0aWxzLmlzSFRNTEVsZW1lbnQoZG9tTm9kZSkgJiYgZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcpID09PSAndHJ1ZSc7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUxpc3RJdGVtTm9kZShjaGVja2VkKVxuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IExpc3QgSXRlbSBub2RlLCBwYXNzaW5nIHRydWUvZmFsc2Ugd2lsbCBjb252ZXJ0IGl0IHRvIGEgY2hlY2tib3ggaW5wdXQuXG4gKiBAcGFyYW0gY2hlY2tlZCAtIElzIHRoZSBMaXN0IEl0ZW0gYSBjaGVja2JveCBhbmQsIGlmIHNvLCBpcyBpdCBjaGVja2VkPyB1bmRlZmluZWQvbnVsbDogbm90IGEgY2hlY2tib3gsIHRydWUvZmFsc2UgaXMgYSBjaGVja2JveCBhbmQgY2hlY2tlZC91bmNoZWNrZWQsIHJlc3BlY3RpdmVseS5cbiAqIEByZXR1cm5zIFRoZSBuZXcgTGlzdCBJdGVtLlxuICovXG5cblxuZnVuY3Rpb24gJGNyZWF0ZUxpc3RJdGVtTm9kZShjaGVja2VkKSB7XG4gIHJldHVybiBsZXhpY2FsLiRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgTGlzdEl0ZW1Ob2RlKHVuZGVmaW5lZCwgY2hlY2tlZCkpO1xufVxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBub2RlIGlzIGEgTGlzdEl0ZW1Ob2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIExpc3RJdGVtTm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uICRpc0xpc3RJdGVtTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgTGlzdEl0ZW1Ob2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBMaXN0Tm9kZSBleHRlbmRzIGxleGljYWwuRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdsaXN0JztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgY29uc3QgbGlzdFR5cGUgPSBub2RlLl9fbGlzdFR5cGUgfHwgVEFHX1RPX0xJU1RfVFlQRVtub2RlLl9fdGFnXTtcbiAgICByZXR1cm4gbmV3IExpc3ROb2RlKGxpc3RUeXBlLCBub2RlLl9fc3RhcnQsIG5vZGUuX19rZXkpO1xuICB9XG5cbiAgY29uc3RydWN0b3IobGlzdFR5cGUsIHN0YXJ0LCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuXG4gICAgY29uc3QgX2xpc3RUeXBlID0gVEFHX1RPX0xJU1RfVFlQRVtsaXN0VHlwZV0gfHwgbGlzdFR5cGU7XG5cbiAgICB0aGlzLl9fbGlzdFR5cGUgPSBfbGlzdFR5cGU7XG4gICAgdGhpcy5fX3RhZyA9IF9saXN0VHlwZSA9PT0gJ251bWJlcicgPyAnb2wnIDogJ3VsJztcbiAgICB0aGlzLl9fc3RhcnQgPSBzdGFydDtcbiAgfVxuXG4gIGdldFRhZygpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RhZztcbiAgfVxuXG4gIHNldExpc3RUeXBlKHR5cGUpIHtcbiAgICBjb25zdCB3cml0YWJsZSA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICB3cml0YWJsZS5fX2xpc3RUeXBlID0gdHlwZTtcbiAgICB3cml0YWJsZS5fX3RhZyA9IHR5cGUgPT09ICdudW1iZXInID8gJ29sJyA6ICd1bCc7XG4gIH1cblxuICBnZXRMaXN0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2xpc3RUeXBlO1xuICB9XG5cbiAgZ2V0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19zdGFydDtcbiAgfSAvLyBWaWV3XG5cblxuICBjcmVhdGVET00oY29uZmlnLCBfZWRpdG9yKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5fX3RhZztcbiAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG5cbiAgICBpZiAodGhpcy5fX3N0YXJ0ICE9PSAxKSB7XG4gICAgICBkb20uc2V0QXR0cmlidXRlKCdzdGFydCcsIFN0cmluZyh0aGlzLl9fc3RhcnQpKTtcbiAgICB9IC8vIEB0cy1leHBlY3QtZXJyb3IgSW50ZXJuYWwgZmllbGQuXG5cblxuICAgIGRvbS5fX2xleGljYWxMaXN0VHlwZSA9IHRoaXMuX19saXN0VHlwZTtcbiAgICBzZXRMaXN0VGhlbWVDbGFzc05hbWVzKGRvbSwgY29uZmlnLnRoZW1lLCB0aGlzKTtcbiAgICByZXR1cm4gZG9tO1xuICB9XG5cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIGlmIChwcmV2Tm9kZS5fX3RhZyAhPT0gdGhpcy5fX3RhZykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc2V0TGlzdFRoZW1lQ2xhc3NOYW1lcyhkb20sIGNvbmZpZy50aGVtZSwgdGhpcyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb2w6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydExpc3ROb2RlLFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICB1bDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0TGlzdE5vZGUsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlTGlzdE5vZGUoc2VyaWFsaXplZE5vZGUubGlzdFR5cGUsIHNlcmlhbGl6ZWROb2RlLnN0YXJ0KTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50XG4gICAgfSA9IHN1cGVyLmV4cG9ydERPTShlZGl0b3IpO1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhcnQgIT09IDEpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0YXJ0JywgU3RyaW5nKHRoaXMuX19zdGFydCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fX2xpc3RUeXBlID09PSAnY2hlY2snKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdfX2xleGljYWxMaXN0VHlwZScsICdjaGVjaycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgbGlzdFR5cGU6IHRoaXMuZ2V0TGlzdFR5cGUoKSxcbiAgICAgIHN0YXJ0OiB0aGlzLmdldFN0YXJ0KCksXG4gICAgICB0YWc6IHRoaXMuZ2V0VGFnKCksXG4gICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIGNhbkJlRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGFwcGVuZCguLi5ub2Rlc1RvQXBwZW5kKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc1RvQXBwZW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IG5vZGVzVG9BcHBlbmRbaV07XG5cbiAgICAgIGlmICgkaXNMaXN0SXRlbU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIHN1cGVyLmFwcGVuZChjdXJyZW50Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsaXN0SXRlbU5vZGUgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG5cbiAgICAgICAgaWYgKCRpc0xpc3ROb2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgIGxpc3RJdGVtTm9kZS5hcHBlbmQoY3VycmVudE5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBsZXhpY2FsLiRjcmVhdGVUZXh0Tm9kZShjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICAgICAgICBsaXN0SXRlbU5vZGUuYXBwZW5kKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0SXRlbU5vZGUuYXBwZW5kKGN1cnJlbnROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLmFwcGVuZChsaXN0SXRlbU5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQpIHtcbiAgICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKGNoaWxkKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHNldExpc3RUaGVtZUNsYXNzTmFtZXMoZG9tLCBlZGl0b3JUaGVtZUNsYXNzZXMsIG5vZGUpIHtcbiAgY29uc3QgY2xhc3Nlc1RvQWRkID0gW107XG4gIGNvbnN0IGNsYXNzZXNUb1JlbW92ZSA9IFtdO1xuICBjb25zdCBsaXN0VGhlbWUgPSBlZGl0b3JUaGVtZUNsYXNzZXMubGlzdDtcblxuICBpZiAobGlzdFRoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBsaXN0TGV2ZWxzQ2xhc3NOYW1lcyA9IGxpc3RUaGVtZVtgJHtub2RlLl9fdGFnfURlcHRoYF0gfHwgW107XG4gICAgY29uc3QgbGlzdERlcHRoID0gJGdldExpc3REZXB0aChub2RlKSAtIDE7XG4gICAgY29uc3Qgbm9ybWFsaXplZExpc3REZXB0aCA9IGxpc3REZXB0aCAlIGxpc3RMZXZlbHNDbGFzc05hbWVzLmxlbmd0aDtcbiAgICBjb25zdCBsaXN0TGV2ZWxDbGFzc05hbWUgPSBsaXN0TGV2ZWxzQ2xhc3NOYW1lc1tub3JtYWxpemVkTGlzdERlcHRoXTtcbiAgICBjb25zdCBsaXN0Q2xhc3NOYW1lID0gbGlzdFRoZW1lW25vZGUuX190YWddO1xuICAgIGxldCBuZXN0ZWRMaXN0Q2xhc3NOYW1lO1xuICAgIGNvbnN0IG5lc3RlZExpc3RUaGVtZSA9IGxpc3RUaGVtZS5uZXN0ZWQ7XG5cbiAgICBpZiAobmVzdGVkTGlzdFRoZW1lICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkTGlzdFRoZW1lLmxpc3QpIHtcbiAgICAgIG5lc3RlZExpc3RDbGFzc05hbWUgPSBuZXN0ZWRMaXN0VGhlbWUubGlzdDtcbiAgICB9XG5cbiAgICBpZiAobGlzdENsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaChsaXN0Q2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAobGlzdExldmVsQ2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGxpc3RJdGVtQ2xhc3NlcyA9IGxpc3RMZXZlbENsYXNzTmFtZS5zcGxpdCgnICcpO1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goLi4ubGlzdEl0ZW1DbGFzc2VzKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0TGV2ZWxzQ2xhc3NOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSAhPT0gbm9ybWFsaXplZExpc3REZXB0aCkge1xuICAgICAgICAgIGNsYXNzZXNUb1JlbW92ZS5wdXNoKG5vZGUuX190YWcgKyBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXN0ZWRMaXN0Q2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG5lc3RlZExpc3RJdGVtQ2xhc3NlcyA9IG5lc3RlZExpc3RDbGFzc05hbWUuc3BsaXQoJyAnKTtcblxuICAgICAgaWYgKGxpc3REZXB0aCA+IDEpIHtcbiAgICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goLi4ubmVzdGVkTGlzdEl0ZW1DbGFzc2VzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsYXNzZXNUb1JlbW92ZS5wdXNoKC4uLm5lc3RlZExpc3RJdGVtQ2xhc3Nlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGNsYXNzZXNUb1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgdXRpbHMucmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgLi4uY2xhc3Nlc1RvUmVtb3ZlKTtcbiAgfVxuXG4gIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9BZGQpO1xuICB9XG59XG4vKlxuICogVGhpcyBmdW5jdGlvbiBub3JtYWxpemVzIHRoZSBjaGlsZHJlbiBvZiBhIExpc3ROb2RlIGFmdGVyIHRoZSBjb252ZXJzaW9uIGZyb20gSFRNTCxcbiAqIGVuc3VyaW5nIHRoYXQgdGhleSBhcmUgYWxsIExpc3RJdGVtTm9kZXMgYW5kIGNvbnRhaW4gZWl0aGVyIGEgc2luZ2xlIG5lc3RlZCBMaXN0Tm9kZVxuICogb3Igc29tZSBvdGhlciBpbmxpbmUgY29udGVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuKG5vZGVzKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRMaXN0SXRlbXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShub2RlKSkge1xuICAgICAgbm9ybWFsaXplZExpc3RJdGVtcy5wdXNoKG5vZGUpO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG5cbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgIGlmICgkaXNMaXN0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRMaXN0SXRlbXMucHVzaCh3cmFwSW5MaXN0SXRlbShjaGlsZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWRMaXN0SXRlbXMucHVzaCh3cmFwSW5MaXN0SXRlbShub2RlKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWRMaXN0SXRlbXM7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRMaXN0Tm9kZShkb21Ob2RlKSB7XG4gIGNvbnN0IG5vZGVOYW1lID0gZG9tTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBsZXQgbm9kZSA9IG51bGw7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnb2wnKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHN0YXJ0ID0gZG9tTm9kZS5zdGFydDtcbiAgICBub2RlID0gJGNyZWF0ZUxpc3ROb2RlKCdudW1iZXInLCBzdGFydCk7XG4gIH0gZWxzZSBpZiAobm9kZU5hbWUgPT09ICd1bCcpIHtcbiAgICBpZiAodXRpbHMuaXNIVE1MRWxlbWVudChkb21Ob2RlKSAmJiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgnX19sZXhpY2FsbGlzdHR5cGUnKSA9PT0gJ2NoZWNrJykge1xuICAgICAgbm9kZSA9ICRjcmVhdGVMaXN0Tm9kZSgnY2hlY2snKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9ICRjcmVhdGVMaXN0Tm9kZSgnYnVsbGV0Jyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZnRlcjogbm9ybWFsaXplQ2hpbGRyZW4sXG4gICAgbm9kZVxuICB9O1xufVxuXG5jb25zdCBUQUdfVE9fTElTVF9UWVBFID0ge1xuICBvbDogJ251bWJlcicsXG4gIHVsOiAnYnVsbGV0J1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIExpc3ROb2RlIG9mIGxpc3RUeXBlLlxuICogQHBhcmFtIGxpc3RUeXBlIC0gVGhlIHR5cGUgb2YgbGlzdCB0byBiZSBjcmVhdGVkLiBDYW4gYmUgJ251bWJlcicsICdidWxsZXQnLCBvciAnY2hlY2snLlxuICogQHBhcmFtIHN0YXJ0IC0gV2hlcmUgYW4gb3JkZXJlZCBsaXN0IHN0YXJ0cyBpdHMgY291bnQsIHN0YXJ0ID0gMSBpZiBsZWZ0IHVuZGVmaW5lZC5cbiAqIEByZXR1cm5zIFRoZSBuZXcgTGlzdE5vZGVcbiAqL1xuXG5mdW5jdGlvbiAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUsIHN0YXJ0ID0gMSkge1xuICByZXR1cm4gbGV4aWNhbC4kYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IExpc3ROb2RlKGxpc3RUeXBlLCBzdGFydCkpO1xufVxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBub2RlIGlzIGEgTGlzdE5vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGEgTGlzdE5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiAkaXNMaXN0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgTGlzdE5vZGU7XG59XG5cbi8qKiBAbW9kdWxlIEBsZXhpY2FsL2xpc3QgKi9cbmNvbnN0IElOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5EID0gbGV4aWNhbC5jcmVhdGVDb21tYW5kKCdJTlNFUlRfVU5PUkRFUkVEX0xJU1RfQ09NTUFORCcpO1xuY29uc3QgSU5TRVJUX09SREVSRURfTElTVF9DT01NQU5EID0gbGV4aWNhbC5jcmVhdGVDb21tYW5kKCdJTlNFUlRfT1JERVJFRF9MSVNUX0NPTU1BTkQnKTtcbmNvbnN0IElOU0VSVF9DSEVDS19MSVNUX0NPTU1BTkQgPSBsZXhpY2FsLmNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9DSEVDS19MSVNUX0NPTU1BTkQnKTtcbmNvbnN0IFJFTU9WRV9MSVNUX0NPTU1BTkQgPSBsZXhpY2FsLmNyZWF0ZUNvbW1hbmQoJ1JFTU9WRV9MSVNUX0NPTU1BTkQnKTtcblxuZXhwb3J0cy4kY3JlYXRlTGlzdEl0ZW1Ob2RlID0gJGNyZWF0ZUxpc3RJdGVtTm9kZTtcbmV4cG9ydHMuJGNyZWF0ZUxpc3ROb2RlID0gJGNyZWF0ZUxpc3ROb2RlO1xuZXhwb3J0cy4kZ2V0TGlzdERlcHRoID0gJGdldExpc3REZXB0aDtcbmV4cG9ydHMuJGhhbmRsZUxpc3RJbnNlcnRQYXJhZ3JhcGggPSAkaGFuZGxlTGlzdEluc2VydFBhcmFncmFwaDtcbmV4cG9ydHMuJGlzTGlzdEl0ZW1Ob2RlID0gJGlzTGlzdEl0ZW1Ob2RlO1xuZXhwb3J0cy4kaXNMaXN0Tm9kZSA9ICRpc0xpc3ROb2RlO1xuZXhwb3J0cy5JTlNFUlRfQ0hFQ0tfTElTVF9DT01NQU5EID0gSU5TRVJUX0NIRUNLX0xJU1RfQ09NTUFORDtcbmV4cG9ydHMuSU5TRVJUX09SREVSRURfTElTVF9DT01NQU5EID0gSU5TRVJUX09SREVSRURfTElTVF9DT01NQU5EO1xuZXhwb3J0cy5JTlNFUlRfVU5PUkRFUkVEX0xJU1RfQ09NTUFORCA9IElOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5EO1xuZXhwb3J0cy5MaXN0SXRlbU5vZGUgPSBMaXN0SXRlbU5vZGU7XG5leHBvcnRzLkxpc3ROb2RlID0gTGlzdE5vZGU7XG5leHBvcnRzLlJFTU9WRV9MSVNUX0NPTU1BTkQgPSBSRU1PVkVfTElTVF9DT01NQU5EO1xuZXhwb3J0cy5pbnNlcnRMaXN0ID0gaW5zZXJ0TGlzdDtcbmV4cG9ydHMucmVtb3ZlTGlzdCA9IHJlbW92ZUxpc3Q7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/list/LexicalList.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/list/LexicalList.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/list/LexicalList.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalList =  true ? __webpack_require__(/*! ./LexicalList.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/list/LexicalList.dev.js\") : 0\nmodule.exports = LexicalList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9saXN0L0xleGljYWxMaXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osb0JBQW9CLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxpR0FBc0IsSUFBSSxDQUFnQztBQUMvSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGlzdC9MZXhpY2FsTGlzdC5qcz9mMDE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsTGlzdCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsTGlzdC5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbExpc3QucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxMaXN0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/list/LexicalList.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/mark/LexicalMark.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/mark/LexicalMark.dev.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass MarkNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'mark';\n  }\n\n  static clone(node) {\n    return new MarkNode(Array.from(node.__ids), node.__key);\n  }\n\n  static importDOM() {\n    return null;\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createMarkNode(serializedNode.ids);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      ids: this.getIDs(),\n      type: 'mark',\n      version: 1\n    };\n  }\n\n  constructor(ids, key) {\n    super(key);\n    this.__ids = ids || [];\n  }\n\n  createDOM(config) {\n    const element = document.createElement('mark');\n    utils.addClassNamesToElement(element, config.theme.mark);\n\n    if (this.__ids.length > 1) {\n      utils.addClassNamesToElement(element, config.theme.markOverlap);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          utils.addClassNamesToElement(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        utils.removeClassNamesFromElement(element, overlapTheme);\n      }\n    }\n\n    return false;\n  }\n\n  hasID(id) {\n    const ids = this.getIDs();\n\n    for (let i = 0; i < ids.length; i++) {\n      if (id === ids[i]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  getIDs() {\n    const self = this.getLatest();\n    return $isMarkNode(self) ? self.__ids : [];\n  }\n\n  addID(id) {\n    const self = this.getWritable();\n\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n\n      for (let i = 0; i < ids.length; i++) {\n        // If we already have it, don't add again\n        if (id === ids[i]) return;\n      }\n\n      ids.push(id);\n    }\n  }\n\n  deleteID(id) {\n    const self = this.getWritable();\n\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n\n      for (let i = 0; i < ids.length; i++) {\n        if (id === ids[i]) {\n          ids.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n\n    if (lexical.$isElementNode(element)) {\n      const markNode = $createMarkNode(this.__ids);\n      element.append(markNode);\n      return markNode;\n    }\n\n    return null;\n  }\n\n  canInsertTextBefore() {\n    return false;\n  }\n\n  canInsertTextAfter() {\n    return false;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  isInline() {\n    return true;\n  }\n\n  extractWithChild(child, selection, destination) {\n    if (!lexical.$isRangeSelection(selection) || destination === 'html') {\n      return false;\n    }\n\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n\n}\nfunction $createMarkNode(ids) {\n  return lexical.$applyNodeReplacement(new MarkNode(ids));\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/** @module @lexical/mark */\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n\n    target = child;\n  }\n\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {\n  const nodes = selection.getNodes();\n  const anchorOffset = selection.anchor.offset;\n  const focusOffset = selection.focus.offset;\n  const nodesLength = nodes.length;\n  const startOffset = isBackward ? focusOffset : anchorOffset;\n  const endOffset = isBackward ? anchorOffset : focusOffset;\n  let currentNodeParent;\n  let lastCreatedMarkNode; // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n\n    const isFirstNode = i === 0;\n    const isLastNode = i === nodesLength - 1;\n    let targetNode = null;\n\n    if (lexical.$isTextNode(node)) {\n      // Case 1: The node is a text node and we can split it\n      const textContentSize = node.getTextContentSize();\n      const startTextOffset = isFirstNode ? startOffset : 0;\n      const endTextOffset = isLastNode ? endOffset : textContentSize;\n\n      if (startTextOffset === 0 && endTextOffset === 0) {\n        continue;\n      }\n\n      const splitNodes = node.splitText(startTextOffset, endTextOffset);\n      targetNode = splitNodes.length > 1 && (splitNodes.length === 3 || isFirstNode && !isLastNode || endTextOffset === textContentSize) ? splitNodes[1] : splitNodes[0];\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may utlimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n      continue;\n    } else if (lexical.$isElementNode(node) && node.isInline()) {\n      // Case 3: inline element nodes can be added in their entirety to the new\n      // mark\n      targetNode = node;\n    }\n\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n\n      const parentNode = targetNode.getParent();\n\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n\n      currentNodeParent = parentNode;\n\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        const createMarkNode = createNode || $createMarkNode;\n        lastCreatedMarkNode = createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      } // Add the target node to be wrapped in the latest created mark node\n\n\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  } // Make selection collapsed at the end\n\n\n  if (lexical.$isElementNode(lastCreatedMarkNode)) {\n    // eslint-disable-next-line no-unused-expressions\n    isBackward ? lastCreatedMarkNode.selectStart() : lastCreatedMarkNode.selectEnd();\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if (lexical.$isTextNode(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n\n    currentNode = currentNode.getParent();\n  }\n\n  return null;\n}\n\nexports.$createMarkNode = $createMarkNode;\nexports.$getMarkIDs = $getMarkIDs;\nexports.$isMarkNode = $isMarkNode;\nexports.$unwrapMarkNode = $unwrapMarkNode;\nexports.$wrapSelectionInMarkNode = $wrapSelectionInMarkNode;\nexports.MarkNode = MarkNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9tYXJrL0xleGljYWxNYXJrLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsc0VBQVM7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLHlGQUFnQjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLGdDQUFnQztBQUNoQyxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL21hcmsvTGV4aWNhbE1hcmsuZGV2LmpzPzc5MTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQGxleGljYWwvdXRpbHMnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgTWFya05vZGUgZXh0ZW5kcyBsZXhpY2FsLkVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ21hcmsnO1xuICB9XG5cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtOb2RlKEFycmF5LmZyb20obm9kZS5fX2lkcyksIG5vZGUuX19rZXkpO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVNYXJrTm9kZShzZXJpYWxpemVkTm9kZS5pZHMpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4geyAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBpZHM6IHRoaXMuZ2V0SURzKCksXG4gICAgICB0eXBlOiAnbWFyaycsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGlkcywga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9faWRzID0gaWRzIHx8IFtdO1xuICB9XG5cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtYXJrJyk7XG4gICAgdXRpbHMuYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjb25maWcudGhlbWUubWFyayk7XG5cbiAgICBpZiAodGhpcy5fX2lkcy5sZW5ndGggPiAxKSB7XG4gICAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS5tYXJrT3ZlcmxhcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICB1cGRhdGVET00ocHJldk5vZGUsIGVsZW1lbnQsIGNvbmZpZykge1xuICAgIGNvbnN0IHByZXZJRHMgPSBwcmV2Tm9kZS5fX2lkcztcbiAgICBjb25zdCBuZXh0SURzID0gdGhpcy5fX2lkcztcbiAgICBjb25zdCBwcmV2SURzQ291bnQgPSBwcmV2SURzLmxlbmd0aDtcbiAgICBjb25zdCBuZXh0SURzQ291bnQgPSBuZXh0SURzLmxlbmd0aDtcbiAgICBjb25zdCBvdmVybGFwVGhlbWUgPSBjb25maWcudGhlbWUubWFya092ZXJsYXA7XG5cbiAgICBpZiAocHJldklEc0NvdW50ICE9PSBuZXh0SURzQ291bnQpIHtcbiAgICAgIGlmIChwcmV2SURzQ291bnQgPT09IDEpIHtcbiAgICAgICAgaWYgKG5leHRJRHNDb3VudCA9PT0gMikge1xuICAgICAgICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgb3ZlcmxhcFRoZW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXh0SURzQ291bnQgPT09IDEpIHtcbiAgICAgICAgdXRpbHMucmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGVsZW1lbnQsIG92ZXJsYXBUaGVtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFzSUQoaWQpIHtcbiAgICBjb25zdCBpZHMgPSB0aGlzLmdldElEcygpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpZCA9PT0gaWRzW2ldKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldElEcygpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gJGlzTWFya05vZGUoc2VsZikgPyBzZWxmLl9faWRzIDogW107XG4gIH1cblxuICBhZGRJRChpZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG5cbiAgICBpZiAoJGlzTWFya05vZGUoc2VsZikpIHtcbiAgICAgIGNvbnN0IGlkcyA9IHNlbGYuX19pZHM7XG4gICAgICBzZWxmLl9faWRzID0gaWRzO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgaXQsIGRvbid0IGFkZCBhZ2FpblxuICAgICAgICBpZiAoaWQgPT09IGlkc1tpXSkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZHMucHVzaChpZCk7XG4gICAgfVxuICB9XG5cbiAgZGVsZXRlSUQoaWQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuXG4gICAgaWYgKCRpc01hcmtOb2RlKHNlbGYpKSB7XG4gICAgICBjb25zdCBpZHMgPSBzZWxmLl9faWRzO1xuICAgICAgc2VsZi5fX2lkcyA9IGlkcztcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlkID09PSBpZHNbaV0pIHtcbiAgICAgICAgICBpZHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluc2VydE5ld0FmdGVyKHNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBtYXJrTm9kZSA9ICRjcmVhdGVNYXJrTm9kZSh0aGlzLl9faWRzKTtcbiAgICAgIGVsZW1lbnQuYXBwZW5kKG1hcmtOb2RlKTtcbiAgICAgIHJldHVybiBtYXJrTm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNhbkluc2VydFRleHRCZWZvcmUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2FuSW5zZXJ0VGV4dEFmdGVyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNhbkJlRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkLCBzZWxlY3Rpb24sIGRlc3RpbmF0aW9uKSB7XG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgZGVzdGluYXRpb24gPT09ICdodG1sJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICAgIGNvbnN0IHNlbGVjdGlvbkxlbmd0aCA9IGlzQmFja3dhcmQgPyBhbmNob3Iub2Zmc2V0IC0gZm9jdXMub2Zmc2V0IDogZm9jdXMub2Zmc2V0IC0gYW5jaG9yLm9mZnNldDtcbiAgICByZXR1cm4gdGhpcy5pc1BhcmVudE9mKGFuY2hvck5vZGUpICYmIHRoaXMuaXNQYXJlbnRPZihmb2N1c05vZGUpICYmIHRoaXMuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGggPT09IHNlbGVjdGlvbkxlbmd0aDtcbiAgfVxuXG4gIGV4Y2x1ZGVGcm9tQ29weShkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBkZXN0aW5hdGlvbiAhPT0gJ2Nsb25lJztcbiAgfVxuXG59XG5mdW5jdGlvbiAkY3JlYXRlTWFya05vZGUoaWRzKSB7XG4gIHJldHVybiBsZXhpY2FsLiRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgTWFya05vZGUoaWRzKSk7XG59XG5mdW5jdGlvbiAkaXNNYXJrTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgTWFya05vZGU7XG59XG5cbi8qKiBAbW9kdWxlIEBsZXhpY2FsL21hcmsgKi9cbmZ1bmN0aW9uICR1bndyYXBNYXJrTm9kZShub2RlKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICBsZXQgdGFyZ2V0ID0gbnVsbDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKGNoaWxkKTtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBjaGlsZDtcbiAgfVxuXG4gIG5vZGUucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiAkd3JhcFNlbGVjdGlvbkluTWFya05vZGUoc2VsZWN0aW9uLCBpc0JhY2t3YXJkLCBpZCwgY3JlYXRlTm9kZSkge1xuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXMub2Zmc2V0O1xuICBjb25zdCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcbiAgY29uc3Qgc3RhcnRPZmZzZXQgPSBpc0JhY2t3YXJkID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gIGNvbnN0IGVuZE9mZnNldCA9IGlzQmFja3dhcmQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgbGV0IGN1cnJlbnROb2RlUGFyZW50O1xuICBsZXQgbGFzdENyZWF0ZWRNYXJrTm9kZTsgLy8gV2Ugb25seSB3YW50IHdyYXAgYWRqYWNlbnQgdGV4dCBub2RlcywgbGluZSBicmVhayBub2Rlc1xuICAvLyBhbmQgaW5saW5lIGVsZW1lbnQgbm9kZXMuIEZvciBkZWNvcmF0b3Igbm9kZXMgYW5kIGJsb2NrXG4gIC8vIGVsZW1lbnQgbm9kZXMsIHdlIHN0ZXAgb3V0IG9mIHRoZWlyIGJvdW5kYXJ5IGFuZCBzdGFydFxuICAvLyBhZ2FpbiBhZnRlciwgaWYgdGhlcmUgYXJlIG1vcmUgbm9kZXMuXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobGFzdENyZWF0ZWRNYXJrTm9kZSkgJiYgbGFzdENyZWF0ZWRNYXJrTm9kZS5pc1BhcmVudE9mKG5vZGUpKSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBub2RlIGlzIGEgY2hpbGQgb2YgdGhlIGxhc3QgY3JlYXRlZCBtYXJrIG5vZGUsIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8gaGVyZVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgaXNGaXJzdE5vZGUgPSBpID09PSAwO1xuICAgIGNvbnN0IGlzTGFzdE5vZGUgPSBpID09PSBub2Rlc0xlbmd0aCAtIDE7XG4gICAgbGV0IHRhcmdldE5vZGUgPSBudWxsO1xuXG4gICAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIC8vIENhc2UgMTogVGhlIG5vZGUgaXMgYSB0ZXh0IG5vZGUgYW5kIHdlIGNhbiBzcGxpdCBpdFxuICAgICAgY29uc3QgdGV4dENvbnRlbnRTaXplID0gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIGNvbnN0IHN0YXJ0VGV4dE9mZnNldCA9IGlzRmlyc3ROb2RlID8gc3RhcnRPZmZzZXQgOiAwO1xuICAgICAgY29uc3QgZW5kVGV4dE9mZnNldCA9IGlzTGFzdE5vZGUgPyBlbmRPZmZzZXQgOiB0ZXh0Q29udGVudFNpemU7XG5cbiAgICAgIGlmIChzdGFydFRleHRPZmZzZXQgPT09IDAgJiYgZW5kVGV4dE9mZnNldCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3BsaXROb2RlcyA9IG5vZGUuc3BsaXRUZXh0KHN0YXJ0VGV4dE9mZnNldCwgZW5kVGV4dE9mZnNldCk7XG4gICAgICB0YXJnZXROb2RlID0gc3BsaXROb2Rlcy5sZW5ndGggPiAxICYmIChzcGxpdE5vZGVzLmxlbmd0aCA9PT0gMyB8fCBpc0ZpcnN0Tm9kZSAmJiAhaXNMYXN0Tm9kZSB8fCBlbmRUZXh0T2Zmc2V0ID09PSB0ZXh0Q29udGVudFNpemUpID8gc3BsaXROb2Rlc1sxXSA6IHNwbGl0Tm9kZXNbMF07XG4gICAgfSBlbHNlIGlmICgkaXNNYXJrTm9kZShub2RlKSkge1xuICAgICAgLy8gQ2FzZSAyOiB0aGUgbm9kZSBpcyBhIG1hcmsgbm9kZSBhbmQgd2UgY2FuIGlnbm9yZSBpdCBhcyBhIHRhcmdldCxcbiAgICAgIC8vIG1vdmluZyBvbiB0byBpdHMgY2hpbGRyZW4uIE5vdGUgdGhhdCB3aGVuIHdlIG1ha2UgYSBtYXJrIGluc2lkZVxuICAgICAgLy8gYW5vdGhlciBtYXJrLCBpdCBtYXkgdXRsaW1hdGVseSBiZSB1bm5lc3RlZCBieSBhIGNhbGwgdG9cbiAgICAgIC8vIGByZWdpc3Rlck5lc3RlZEVsZW1lbnRSZXNvbHZlcjxNYXJrTm9kZT5gIHNvbWV3aGVyZSBlbHNlIGluIHRoZVxuICAgICAgLy8gY29kZWJhc2UuXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAvLyBDYXNlIDM6IGlubGluZSBlbGVtZW50IG5vZGVzIGNhbiBiZSBhZGRlZCBpbiB0aGVpciBlbnRpcmV0eSB0byB0aGUgbmV3XG4gICAgICAvLyBtYXJrXG4gICAgICB0YXJnZXROb2RlID0gbm9kZTtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgLy8gTm93IHRoYXQgd2UgaGF2ZSBhIHRhcmdldCBub2RlIGZvciB3cmFwcGluZyB3aXRoIGEgbWFyaywgd2UgY2FuIHJ1blxuICAgICAgLy8gdGhyb3VnaCBzcGVjaWFsIGNhc2VzLlxuICAgICAgaWYgKHRhcmdldE5vZGUgJiYgdGFyZ2V0Tm9kZS5pcyhjdXJyZW50Tm9kZVBhcmVudCkpIHtcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgbm9kZSBpcyBhIGNoaWxkIG9mIHRoZSB0YXJnZXQgbm9kZSB0byBiZSB3cmFwcGVkLCB0aGVyZVxuICAgICAgICAvLyBpcyBub3RoaW5nIHRvIGRvIGhlcmUuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gdGFyZ2V0Tm9kZS5nZXRQYXJlbnQoKTtcblxuICAgICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCB8fCAhcGFyZW50Tm9kZS5pcyhjdXJyZW50Tm9kZVBhcmVudCkpIHtcbiAgICAgICAgLy8gSWYgdGhlIHBhcmVudCBub2RlIGlzIG5vdCB0aGUgY3VycmVudCBub2RlJ3MgcGFyZW50IG5vZGUsIHdlIGNhblxuICAgICAgICAvLyBjbGVhciB0aGUgbGFzdCBjcmVhdGVkIG1hcmsgbm9kZS5cbiAgICAgICAgbGFzdENyZWF0ZWRNYXJrTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgY3VycmVudE5vZGVQYXJlbnQgPSBwYXJlbnROb2RlO1xuXG4gICAgICBpZiAobGFzdENyZWF0ZWRNYXJrTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjcmVhdGVkIG1hcmsgbm9kZSwgd2UgY2FuIG1ha2Ugb25lXG4gICAgICAgIGNvbnN0IGNyZWF0ZU1hcmtOb2RlID0gY3JlYXRlTm9kZSB8fCAkY3JlYXRlTWFya05vZGU7XG4gICAgICAgIGxhc3RDcmVhdGVkTWFya05vZGUgPSBjcmVhdGVNYXJrTm9kZShbaWRdKTtcbiAgICAgICAgdGFyZ2V0Tm9kZS5pbnNlcnRCZWZvcmUobGFzdENyZWF0ZWRNYXJrTm9kZSk7XG4gICAgICB9IC8vIEFkZCB0aGUgdGFyZ2V0IG5vZGUgdG8gYmUgd3JhcHBlZCBpbiB0aGUgbGF0ZXN0IGNyZWF0ZWQgbWFyayBub2RlXG5cblxuICAgICAgbGFzdENyZWF0ZWRNYXJrTm9kZS5hcHBlbmQodGFyZ2V0Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSB0YXJnZXQgbm9kZSB0byB3cmFwIHdlIGNhbiBjbGVhciBvdXIgc3RhdGUgYW5kXG4gICAgICAvLyBjb250aW51ZSBvbiB3aXRoIHRoZSBuZXh0IG5vZGVcbiAgICAgIGN1cnJlbnROb2RlUGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgbGFzdENyZWF0ZWRNYXJrTm9kZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gLy8gTWFrZSBzZWxlY3Rpb24gY29sbGFwc2VkIGF0IHRoZSBlbmRcblxuXG4gIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGxhc3RDcmVhdGVkTWFya05vZGUpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgIGlzQmFja3dhcmQgPyBsYXN0Q3JlYXRlZE1hcmtOb2RlLnNlbGVjdFN0YXJ0KCkgOiBsYXN0Q3JlYXRlZE1hcmtOb2RlLnNlbGVjdEVuZCgpO1xuICB9XG59XG5mdW5jdGlvbiAkZ2V0TWFya0lEcyhub2RlLCBvZmZzZXQpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcblxuICB3aGlsZSAoY3VycmVudE5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAoJGlzTWFya05vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGUuZ2V0SURzKCk7XG4gICAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGN1cnJlbnROb2RlKSAmJiBvZmZzZXQgPT09IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICBjb25zdCBuZXh0U2libGluZyA9IGN1cnJlbnROb2RlLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICAgIGlmICgkaXNNYXJrTm9kZShuZXh0U2libGluZykpIHtcbiAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nLmdldElEcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy4kY3JlYXRlTWFya05vZGUgPSAkY3JlYXRlTWFya05vZGU7XG5leHBvcnRzLiRnZXRNYXJrSURzID0gJGdldE1hcmtJRHM7XG5leHBvcnRzLiRpc01hcmtOb2RlID0gJGlzTWFya05vZGU7XG5leHBvcnRzLiR1bndyYXBNYXJrTm9kZSA9ICR1bndyYXBNYXJrTm9kZTtcbmV4cG9ydHMuJHdyYXBTZWxlY3Rpb25Jbk1hcmtOb2RlID0gJHdyYXBTZWxlY3Rpb25Jbk1hcmtOb2RlO1xuZXhwb3J0cy5NYXJrTm9kZSA9IE1hcmtOb2RlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/mark/LexicalMark.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/mark/LexicalMark.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/mark/LexicalMark.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalMark =  true ? __webpack_require__(/*! ./LexicalMark.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/mark/LexicalMark.dev.js\") : 0\nmodule.exports = LexicalMark;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9tYXJrL0xleGljYWxNYXJrLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osb0JBQW9CLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxpR0FBc0IsSUFBSSxDQUFnQztBQUMvSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFyay9MZXhpY2FsTWFyay5qcz81MTU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsTWFyayA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsTWFyay5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbE1hcmsucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxNYXJrOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/mark/LexicalMark.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/markdown/LexicalMarkdown.dev.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/markdown/LexicalMarkdown.dev.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\nvar code = __webpack_require__(/*! @lexical/code */ \"(app-pages-browser)/./node_modules/@lexical/code/LexicalCode.js\");\nvar list = __webpack_require__(/*! @lexical/list */ \"(app-pages-browser)/./node_modules/@lexical/list/LexicalList.js\");\nvar richText = __webpack_require__(/*! @lexical/rich-text */ \"(app-pages-browser)/./node_modules/@lexical/rich-text/LexicalRichText.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar link = __webpack_require__(/*! @lexical/link */ \"(app-pages-browser)/./node_modules/@lexical/link/LexicalLink.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n\n  for (const item of list) {\n    const key = callback(item);\n\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createMarkdownExport(transformers) {\n  const byType = transformersByType(transformers); // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1);\n  return node => {\n    const output = [];\n    const children = (node || lexical.$getRoot()).getChildren();\n\n    for (const child of children) {\n      const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);\n\n      if (result != null) {\n        output.push(result);\n      }\n    }\n\n    return output.join('\\n\\n');\n  };\n}\n\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n\n    if (result != null) {\n      return result;\n    }\n  }\n\n  if (lexical.$isElementNode(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if (lexical.$isDecoratorNode(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\n\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers) {\n  const output = [];\n  const children = node.getChildren();\n\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));\n\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n\n    if (lexical.$isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if (lexical.$isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));\n    } else if (lexical.$isElementNode(child)) {\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));\n    } else if (lexical.$isDecoratorNode(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n\n  return output.join('');\n}\n\nfunction exportTextFormat(node, textContent, textTransformers) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // We instead want to trim the whitespace out, apply formatting, and then\n  // bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n  const frozenString = textContent.trim();\n  let output = frozenString;\n  const applied = new Set();\n\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format); // Prevent adding opening tag is already opened by the previous sibling\n\n      const previousNode = getTextSibling(node, true);\n\n      if (!hasFormat(previousNode, format)) {\n        output = tag + output;\n      } // Prevent adding closing tag if next sibling will do it\n\n\n      const nextNode = getTextSibling(node, false);\n\n      if (!hasFormat(nextNode, format)) {\n        output += tag;\n      }\n    }\n  } // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n\n\n  return textContent.replace(frozenString, output);\n} // Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\n\n\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  while (sibling) {\n    if (lexical.$isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n\n      if (lexical.$isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n\n    if (lexical.$isTextNode(sibling)) {\n      return sibling;\n    }\n\n    if (!lexical.$isElementNode(sibling)) {\n      return null;\n    }\n  }\n\n  return null;\n}\n\nfunction hasFormat(node, format) {\n  return lexical.$isTextNode(node) && node.hasFormat(format);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nconst CODE_BLOCK_REG_EXP = /^```(\\w{1,10})?\\s?$/;\nfunction createMarkdownImport(transformers) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = node || lexical.$getRoot();\n    root.clear();\n\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i]; // Codeblocks are processed first as anything inside such block\n      // is ignored for further processing\n      // TODO:\n      // Abstract it to be dynamic as other transformers (add multiline match option)\n\n      const [codeBlockNode, shiftedIndex] = importCodeBlock(lines, i, root);\n\n      if (codeBlockNode != null) {\n        i = shiftedIndex;\n        continue;\n      }\n\n      importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);\n    } // Removing empty paragraphs as md does not really\n    // allow empty lines and uses them as dilimiter\n\n\n    const children = root.getChildren();\n\n    for (const child of children) {\n      if (isEmptyParagraph(child)) {\n        child.remove();\n      }\n    }\n\n    if (lexical.$getSelection() !== null) {\n      root.selectEnd();\n    }\n  };\n}\n\nfunction isEmptyParagraph(node) {\n  if (!lexical.$isParagraphNode(node)) {\n    return false;\n  }\n\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\n\nfunction importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {\n  const lineTextTrimmed = lineText.trim();\n  const textNode = lexical.$createTextNode(lineTextTrimmed);\n  const elementNode = lexical.$createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      replace(elementNode, [textNode], match, true);\n      break;\n    }\n  }\n\n  importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers); // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n\n  if (elementNode.isAttached() && lineTextTrimmed.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n\n    if (lexical.$isParagraphNode(previousNode) || richText.$isQuoteNode(previousNode) || list.$isListNode(previousNode)) {\n      let targetNode = previousNode;\n\n      if (list.$isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = utils.$findMatchingParent(lastDescendant, list.$isListItemNode);\n        }\n      }\n\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\n\nfunction importCodeBlock(lines, startLineIndex, rootNode) {\n  const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);\n\n  if (openMatch) {\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n\n    while (++endLineIndex < linesLength) {\n      const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);\n\n      if (closeMatch) {\n        const codeBlockNode = code.$createCodeNode(openMatch[1]);\n        const textNode = lexical.$createTextNode(lines.slice(startLineIndex + 1, endLineIndex).join('\\n'));\n        codeBlockNode.append(textNode);\n        rootNode.append(codeBlockNode);\n        return [codeBlockNode, endLineIndex];\n      }\n    }\n  }\n\n  return [null, startLineIndex];\n} // Processing text content and replaces text format tags.\n// It takes outermost tag match and its content, creates text node with\n// format based on tag and then recursively executed over node's content\n//\n// E.g. for \"*Hello **world**!*\" string it will create text node with\n// \"Hello **world**!\" content and italic format and run recursively over\n// its content to transform \"**world**\" part\n\n\nfunction importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n\n  if (!match) {\n    // Once text format processing is done run text match transformers, as it\n    // only can span within single text node (unline formats that can cover multiple nodes)\n    importTextMatchTransformers(textNode, textMatchTransformers);\n    return;\n  }\n\n  let currentNode, remainderNode, leadingNode; // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n\n  if (match[0] === textContent) {\n    currentNode = textNode;\n  } else {\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n\n    if (startIndex === 0) {\n      [currentNode, remainderNode] = textNode.splitText(endIndex);\n    } else {\n      [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n\n  currentNode.setTextContent(match[2]);\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!currentNode.hasFormat(format)) {\n        currentNode.toggleFormat(format);\n      }\n    }\n  } // Recursively run over inner text if it's not inline code\n\n\n  if (!currentNode.hasFormat('code')) {\n    importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);\n  } // Run over leading/remaining text if any\n\n\n  if (leadingNode) {\n    importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n\n  if (remainderNode) {\n    importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n}\n\nfunction importTextMatchTransformers(textNode_, textMatchTransformers) {\n  let textNode = textNode_;\n\n  mainLoop: while (textNode) {\n    for (const transformer of textMatchTransformers) {\n      const match = textNode.getTextContent().match(transformer.importRegExp);\n\n      if (!match) {\n        continue;\n      }\n\n      const startIndex = match.index || 0;\n      const endIndex = startIndex + match[0].length;\n      let replaceNode, leftTextNode, rightTextNode;\n\n      if (startIndex === 0) {\n        [replaceNode, textNode] = textNode.splitText(endIndex);\n      } else {\n        [leftTextNode, replaceNode, rightTextNode] = textNode.splitText(startIndex, endIndex);\n      }\n\n      if (leftTextNode) {\n        importTextMatchTransformers(leftTextNode, textMatchTransformers);\n      }\n\n      if (rightTextNode) {\n        textNode = rightTextNode;\n      }\n\n      transformer.replace(replaceNode, match);\n      continue mainLoop;\n    }\n\n    break;\n  }\n} // Finds first \"<tag>content<tag>\" match that is not nested into another tag\n\n\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n\n  if (openTagsMatch == null) {\n    return null;\n  }\n\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      } // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n\n\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n\n    if (IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\\\s])(.*?[^${tagRegExp}\\\\s])${tagRegExp}(?!${tagRegExp})`);\n    } else {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    }\n  }\n\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Reg exp to find opening tags\n    openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? '' : `${escapeRegExp}`) + '(' + openTagsRegExp.join('|') + ')', 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n\n  if (!lexical.$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n\n  const textContent = anchorNode.getTextContent(); // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n\n    if (match && match[0].length === anchorOffset) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      leadingNode.remove();\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      replace(parentNode, siblings, match, false);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n\n  if (transformers == null) {\n    return false;\n  } // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n\n\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n\n  for (const transformer of transformers) {\n    const match = textContent.match(transformer.regExp);\n\n    if (match === null) {\n      continue;\n    }\n\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n\n  return false;\n}\n\nfunction runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex]; // Quick check if we're possibly at the end of inline markdown style\n\n  const matchers = textFormatTransformers[closeChar];\n\n  if (!matchers) {\n    return false;\n  }\n\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1; // If tag is not single char check if rest of it matches with text content\n\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    } // Space before closing tag cancels inline markdown\n\n\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    } // Some tags can not be used within words, hence should have newline/space/punctuation after it\n\n\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag); // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n\n    let sibling = openNode;\n\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if (lexical.$isLineBreakNode(sibling)) {\n        break;\n      }\n\n      if (lexical.$isTextNode(sibling)) {\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    } // Opening tag is not found\n\n\n    if (openTagStartIndex < 0) {\n      continue;\n    } // No content between opening and closing tag\n\n\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    } // Checking longer tags for repeating chars (e.g. *** vs **)\n\n\n    const prevOpenNodeText = openNode.getTextContent();\n\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    } // Some tags can not be used within words, hence should have newline/space/punctuation before it\n\n\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    } // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n\n\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = lexical.$getSelection();\n    const nextSelection = lexical.$createRangeSelection();\n    lexical.$setSelection(nextSelection); // Adjust offset based on deleted chars\n\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text'); // Apply formatting to selected text\n\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    } // Collapse selection up to the focus point\n\n\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type); // Remove formatting from collapsed selection\n\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n\n    if (lexical.$isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) && // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n\n  return -1;\n}\n\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersIndex = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n\n  for (const transformer of transformers) {\n    const type = transformer.type;\n\n    if (type === 'element' || type === 'text-match') {\n      const dependencies = transformer.dependencies;\n\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          {\n            throw Error(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n  }\n\n  const transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {\n      return;\n    }\n\n    runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);\n  };\n\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from undo/redo (as changes already calculated)\n    if (tags.has('historic')) {\n      return;\n    } // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n\n\n    if (editor.isComposing()) {\n      return;\n    }\n\n    const selection = editorState.read(lexical.$getSelection);\n    const prevSelection = prevEditorState.read(lexical.$getSelection);\n\n    if (!lexical.$isRangeSelection(prevSelection) || !lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return;\n    }\n\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n\n    if (!lexical.$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {\n      return;\n    }\n\n    editor.update(() => {\n      // Markdown is not available inside code\n      if (anchorNode.hasFormat('code')) {\n        return;\n      }\n\n      const parentNode = anchorNode.getParent();\n\n      if (parentNode === null || code.$isCodeNode(parentNode)) {\n        return;\n      }\n\n      transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst createBlockNode = createNode => {\n  return (parentNode, children, match) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  };\n}; // Amount of spaces that define indentation level\n// TODO: should be an option\n\n\nconst LIST_INDENT_SIZE = 4;\n\nconst listReplace = listType => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const nextNode = parentNode.getNextSibling();\n    const listItem = list.$createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n\n    if (list.$isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild();\n\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem);\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem);\n      }\n\n      parentNode.remove();\n    } else if (list.$isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list$1 = list.$createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list$1.append(listItem);\n      parentNode.replace(list$1);\n    }\n\n    listItem.append(...children);\n    listItem.select(0, 0);\n    const indent = Math.floor(match[1].length / LIST_INDENT_SIZE);\n\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\n\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n\n  for (const listItemNode of children) {\n    if (list.$isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n\n        if (list.$isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n\n  return output.join('\\n');\n};\n\nconst HEADING = {\n  dependencies: [richText.HeadingNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isHeadingNode(node)) {\n      return null;\n    }\n\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: /^(#{1,6})\\s/,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return richText.$createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [richText.QuoteNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isQuoteNode(node)) {\n      return null;\n    }\n\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n\n    return output.join('\\n');\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n\n      if (richText.$isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...children]);\n        previousNode.select(0, 0);\n        parentNode.remove();\n        return;\n      }\n    }\n\n    const node = richText.$createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [code.CodeNode],\n  export: node => {\n    if (!code.$isCodeNode(node)) {\n      return null;\n    }\n\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExp: /^```(\\w{1,10})?\\s/,\n  replace: createBlockNode(match => {\n    return code.$createCodeNode(match ? match[1] : undefined);\n  }),\n  type: 'element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(\\d{1,})\\.\\s/,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n}; // Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\n\nconst LINK = {\n  dependencies: [link.LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!link.$isLinkNode(node)) {\n      return null;\n    }\n\n    const title = node.getTitle();\n    const linkContent = title ? `[${node.getTextContent()}](${node.getURL()} \"${title}\")` : `[${node.getTextContent()}](${node.getURL()})`;\n    const firstChild = node.getFirstChild(); // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n\n    if (node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild)) {\n      return exportFormat(firstChild, linkContent);\n    } else {\n      return linkContent;\n    }\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl, linkTitle] = match;\n    const linkNode = link.$createLinkNode(linkUrl, {\n      title: linkTitle\n    });\n    const linkTextNode = lexical.$createTextNode(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n  },\n  trigger: ')',\n  type: 'text-match'\n};\n\n/** @module @lexical/markdown */\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, CODE, UNORDERED_LIST, ORDERED_LIST]; // Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\n\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\n\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node) {\n  const importMarkdown = createMarkdownImport(transformers);\n  return importMarkdown(markdown, node);\n}\n\nfunction $convertToMarkdownString(transformers = TRANSFORMERS, node) {\n  const exportMarkdown = createMarkdownExport(transformers);\n  return exportMarkdown(node);\n}\n\nexports.$convertFromMarkdownString = $convertFromMarkdownString;\nexports.$convertToMarkdownString = $convertToMarkdownString;\nexports.BOLD_ITALIC_STAR = BOLD_ITALIC_STAR;\nexports.BOLD_ITALIC_UNDERSCORE = BOLD_ITALIC_UNDERSCORE;\nexports.BOLD_STAR = BOLD_STAR;\nexports.BOLD_UNDERSCORE = BOLD_UNDERSCORE;\nexports.CHECK_LIST = CHECK_LIST;\nexports.CODE = CODE;\nexports.ELEMENT_TRANSFORMERS = ELEMENT_TRANSFORMERS;\nexports.HEADING = HEADING;\nexports.HIGHLIGHT = HIGHLIGHT;\nexports.INLINE_CODE = INLINE_CODE;\nexports.ITALIC_STAR = ITALIC_STAR;\nexports.ITALIC_UNDERSCORE = ITALIC_UNDERSCORE;\nexports.LINK = LINK;\nexports.ORDERED_LIST = ORDERED_LIST;\nexports.QUOTE = QUOTE;\nexports.STRIKETHROUGH = STRIKETHROUGH;\nexports.TEXT_FORMAT_TRANSFORMERS = TEXT_FORMAT_TRANSFORMERS;\nexports.TEXT_MATCH_TRANSFORMERS = TEXT_MATCH_TRANSFORMERS;\nexports.TRANSFORMERS = TRANSFORMERS;\nexports.UNORDERED_LIST = UNORDERED_LIST;\nexports.registerMarkdownShortcuts = registerMarkdownShortcuts;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9tYXJrZG93bi9MZXhpY2FsTWFya2Rvd24uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUztBQUMvQixXQUFXLG1CQUFPLENBQUMsc0ZBQWU7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLHNGQUFlO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyxvR0FBb0I7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLHlGQUFnQjtBQUNwQyxXQUFXLG1CQUFPLENBQUMsc0ZBQWU7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRzs7QUFFQSwrRUFBK0U7O0FBRS9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLElBQUk7QUFDN0Msb0NBQW9DLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEZBQThGO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxVQUFVLE9BQU8sVUFBVSxhQUFhLFVBQVUsT0FBTyxVQUFVLEtBQUssVUFBVTtBQUNuSSxNQUFNO0FBQ04seURBQXlELFVBQVUsS0FBSyxVQUFVLFNBQVMsVUFBVSxTQUFTLFVBQVUsV0FBVyxVQUFVLCtCQUErQixVQUFVLFdBQVcsVUFBVTtBQUMzTTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGFBQWE7QUFDOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBLGlFQUFpRTs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTiw2R0FBNkc7O0FBRTdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixnQkFBZ0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGdCQUFnQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELDRCQUE0QixtQ0FBbUMsc0NBQXNDO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZSxJQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUJBQXFCLEdBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLHNCQUFzQixJQUFJLGVBQWUsR0FBRyxNQUFNLFVBQVUsc0JBQXNCLElBQUksY0FBYztBQUN4SSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEMsZ0NBQWdDO0FBQ2hDLHdCQUF3QjtBQUN4Qiw4QkFBOEI7QUFDOUIsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2QixrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLDRCQUE0QjtBQUM1QixlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIseUJBQXlCO0FBQ3pCLFlBQVk7QUFDWixvQkFBb0I7QUFDcEIsYUFBYTtBQUNiLHFCQUFxQjtBQUNyQixnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CLG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9tYXJrZG93bi9MZXhpY2FsTWFya2Rvd24uZGV2LmpzP2QwOTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIGNvZGUgPSByZXF1aXJlKCdAbGV4aWNhbC9jb2RlJyk7XG52YXIgbGlzdCA9IHJlcXVpcmUoJ0BsZXhpY2FsL2xpc3QnKTtcbnZhciByaWNoVGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JpY2gtdGV4dCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQGxleGljYWwvdXRpbHMnKTtcbnZhciBsaW5rID0gcmVxdWlyZSgnQGxleGljYWwvbGluaycpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGluZGV4QnkobGlzdCwgY2FsbGJhY2spIHtcbiAgY29uc3QgaW5kZXggPSB7fTtcblxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbGlzdCkge1xuICAgIGNvbnN0IGtleSA9IGNhbGxiYWNrKGl0ZW0pO1xuXG4gICAgaWYgKGluZGV4W2tleV0pIHtcbiAgICAgIGluZGV4W2tleV0ucHVzaChpdGVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXhba2V5XSA9IFtpdGVtXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1lcnNCeVR5cGUodHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IGJ5VHlwZSA9IGluZGV4QnkodHJhbnNmb3JtZXJzLCB0ID0+IHQudHlwZSk7XG4gIHJldHVybiB7XG4gICAgZWxlbWVudDogYnlUeXBlLmVsZW1lbnQgfHwgW10sXG4gICAgdGV4dEZvcm1hdDogYnlUeXBlWyd0ZXh0LWZvcm1hdCddIHx8IFtdLFxuICAgIHRleHRNYXRjaDogYnlUeXBlWyd0ZXh0LW1hdGNoJ10gfHwgW11cbiAgfTtcbn1cbmNvbnN0IFBVTkNUVUFUSU9OX09SX1NQQUNFID0gL1shLS86LUBbLWB7LX5cXHNdLztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFya2Rvd25FeHBvcnQodHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IGJ5VHlwZSA9IHRyYW5zZm9ybWVyc0J5VHlwZSh0cmFuc2Zvcm1lcnMpOyAvLyBFeHBvcnQgb25seSB1c2VzIHRleHQgZm9ybWF0cyB0aGF0IGFyZSByZXNwb25zaWJsZSBmb3Igc2luZ2xlIGZvcm1hdFxuICAvLyBlLmcuIGl0IHdpbGwgZmlsdGVyIG91dCAqKiogKGJvbGQsIGl0YWxpYykgYW5kIGluc3RlYWQgdXNlIHNlcGFyYXRlICoqIGFuZCAqXG5cbiAgY29uc3QgdGV4dEZvcm1hdFRyYW5zZm9ybWVycyA9IGJ5VHlwZS50ZXh0Rm9ybWF0LmZpbHRlcih0cmFuc2Zvcm1lciA9PiB0cmFuc2Zvcm1lci5mb3JtYXQubGVuZ3RoID09PSAxKTtcbiAgcmV0dXJuIG5vZGUgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gKG5vZGUgfHwgbGV4aWNhbC4kZ2V0Um9vdCgpKS5nZXRDaGlsZHJlbigpO1xuXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZXhwb3J0VG9wTGV2ZWxFbGVtZW50cyhjaGlsZCwgYnlUeXBlLmVsZW1lbnQsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnMsIGJ5VHlwZS50ZXh0TWF0Y2gpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgb3V0cHV0LnB1c2gocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oJ1xcblxcbicpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHBvcnRUb3BMZXZlbEVsZW1lbnRzKG5vZGUsIGVsZW1lbnRUcmFuc2Zvcm1lcnMsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgZWxlbWVudFRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zZm9ybWVyLmV4cG9ydChub2RlLCBfbm9kZSA9PiBleHBvcnRDaGlsZHJlbihfbm9kZSwgdGV4dFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpKTtcblxuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIHJldHVybiBleHBvcnRDaGlsZHJlbihub2RlLCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7XG4gIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNEZWNvcmF0b3JOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBvcnRDaGlsZHJlbihub2RlLCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycykge1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG5cbiAgbWFpbkxvb3A6IGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRleHRNYXRjaFRyYW5zZm9ybWVycykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdHJhbnNmb3JtZXIuZXhwb3J0KGNoaWxkLCBwYXJlbnROb2RlID0+IGV4cG9ydENoaWxkcmVuKHBhcmVudE5vZGUsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSwgKHRleHROb2RlLCB0ZXh0Q29udGVudCkgPT4gZXhwb3J0VGV4dEZvcm1hdCh0ZXh0Tm9kZSwgdGV4dENvbnRlbnQsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCkpO1xuXG4gICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgb3V0cHV0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgY29udGludWUgbWFpbkxvb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShjaGlsZCkpIHtcbiAgICAgIG91dHB1dC5wdXNoKCdcXG4nKTtcbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICBvdXRwdXQucHVzaChleHBvcnRUZXh0Rm9ybWF0KGNoaWxkLCBjaGlsZC5nZXRUZXh0Q29udGVudCgpLCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgpKTtcbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICBvdXRwdXQucHVzaChleHBvcnRDaGlsZHJlbihjaGlsZCwgdGV4dFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpKTtcbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzRGVjb3JhdG9yTm9kZShjaGlsZCkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGNoaWxkLmdldFRleHRDb250ZW50KCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGV4cG9ydFRleHRGb3JtYXQobm9kZSwgdGV4dENvbnRlbnQsIHRleHRUcmFuc2Zvcm1lcnMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoZSBjYXNlIG9mIGEgc3RyaW5nIGxvb2tpbmcgbGlrZSB0aGlzOiBcIiAgIGZvbyAgIFwiXG4gIC8vIFdoZXJlIGl0IHdvdWxkIGJlIGludmFsaWQgbWFya2Rvd24gdG8gZ2VuZXJhdGU6IFwiKiogICBmb28gICAqKlwiXG4gIC8vIFdlIGluc3RlYWQgd2FudCB0byB0cmltIHRoZSB3aGl0ZXNwYWNlIG91dCwgYXBwbHkgZm9ybWF0dGluZywgYW5kIHRoZW5cbiAgLy8gYnJpbmcgdGhlIHdoaXRlc3BhY2UgYmFjay4gU28gb3VyIHJldHVybmVkIHN0cmluZyBsb29rcyBsaWtlIHRoaXM6IFwiICAgKipmb28qKiAgIFwiXG4gIGNvbnN0IGZyb3plblN0cmluZyA9IHRleHRDb250ZW50LnRyaW0oKTtcbiAgbGV0IG91dHB1dCA9IGZyb3plblN0cmluZztcbiAgY29uc3QgYXBwbGllZCA9IG5ldyBTZXQoKTtcblxuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRleHRUcmFuc2Zvcm1lcnMpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0cmFuc2Zvcm1lci5mb3JtYXRbMF07XG4gICAgY29uc3QgdGFnID0gdHJhbnNmb3JtZXIudGFnO1xuXG4gICAgaWYgKGhhc0Zvcm1hdChub2RlLCBmb3JtYXQpICYmICFhcHBsaWVkLmhhcyhmb3JtYXQpKSB7XG4gICAgICAvLyBNdWx0aXBsZSB0YWdzIG1pZ2h0IGJlIHVzZWQgZm9yIHRoZSBzYW1lIGZvcm1hdCAoKiwgXylcbiAgICAgIGFwcGxpZWQuYWRkKGZvcm1hdCk7IC8vIFByZXZlbnQgYWRkaW5nIG9wZW5pbmcgdGFnIGlzIGFscmVhZHkgb3BlbmVkIGJ5IHRoZSBwcmV2aW91cyBzaWJsaW5nXG5cbiAgICAgIGNvbnN0IHByZXZpb3VzTm9kZSA9IGdldFRleHRTaWJsaW5nKG5vZGUsIHRydWUpO1xuXG4gICAgICBpZiAoIWhhc0Zvcm1hdChwcmV2aW91c05vZGUsIGZvcm1hdCkpIHtcbiAgICAgICAgb3V0cHV0ID0gdGFnICsgb3V0cHV0O1xuICAgICAgfSAvLyBQcmV2ZW50IGFkZGluZyBjbG9zaW5nIHRhZyBpZiBuZXh0IHNpYmxpbmcgd2lsbCBkbyBpdFxuXG5cbiAgICAgIGNvbnN0IG5leHROb2RlID0gZ2V0VGV4dFNpYmxpbmcobm9kZSwgZmFsc2UpO1xuXG4gICAgICBpZiAoIWhhc0Zvcm1hdChuZXh0Tm9kZSwgZm9ybWF0KSkge1xuICAgICAgICBvdXRwdXQgKz0gdGFnO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZXBsYWNlIHRyaW1tZWQgdmVyc2lvbiBvZiB0ZXh0Q29udGVudCBlbnN1cmluZyBzdXJyb3VuZGluZyB3aGl0ZXNwYWNlIGlzIG5vdCBtb2RpZmllZFxuXG5cbiAgcmV0dXJuIHRleHRDb250ZW50LnJlcGxhY2UoZnJvemVuU3RyaW5nLCBvdXRwdXQpO1xufSAvLyBHZXQgbmV4dCBvciBwcmV2aW91cyB0ZXh0IHNpYmxpbmcgYSB0ZXh0IG5vZGUsIGluY2x1ZGluZyBjYXNlc1xuLy8gd2hlbiBpdCdzIGEgY2hpbGQgb2YgaW5saW5lIGVsZW1lbnQgKGUuZy4gbGluaylcblxuXG5mdW5jdGlvbiBnZXRUZXh0U2libGluZyhub2RlLCBiYWNrd2FyZCkge1xuICBsZXQgc2libGluZyA9IGJhY2t3YXJkID8gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICBpZiAoIXNpYmxpbmcpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgIGlmIChwYXJlbnQuaXNJbmxpbmUoKSkge1xuICAgICAgc2libGluZyA9IGJhY2t3YXJkID8gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpIDogcGFyZW50LmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHNpYmxpbmcpIHtcbiAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgICAgaWYgKCFzaWJsaW5nLmlzSW5saW5lKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlc2NlbmRhbnQgPSBiYWNrd2FyZCA/IHNpYmxpbmcuZ2V0TGFzdERlc2NlbmRhbnQoKSA6IHNpYmxpbmcuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG5cbiAgICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGRlc2NlbmRhbnQpKSB7XG4gICAgICAgIHJldHVybiBkZXNjZW5kYW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2libGluZyA9IGJhY2t3YXJkID8gc2libGluZy5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IHNpYmxpbmcuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShzaWJsaW5nKSkge1xuICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKCFsZXhpY2FsLiRpc0VsZW1lbnROb2RlKHNpYmxpbmcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaGFzRm9ybWF0KG5vZGUsIGZvcm1hdCkge1xuICByZXR1cm4gbGV4aWNhbC4kaXNUZXh0Tm9kZShub2RlKSAmJiBub2RlLmhhc0Zvcm1hdChmb3JtYXQpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IGRvY3VtZW50TW9kZSA9IENBTl9VU0VfRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogbnVsbDtcbkNBTl9VU0VfRE9NICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuQ0FOX1VTRV9ET00gJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3gpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuQ0FOX1VTRV9ET00gJiYgJ0lucHV0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlID8gJ2dldFRhcmdldFJhbmdlcycgaW4gbmV3IHdpbmRvdy5JbnB1dEV2ZW50KCdpbnB1dCcpIDogZmFsc2U7XG5jb25zdCBJU19TQUZBUkkgPSBDQU5fVVNFX0RPTSAmJiAvVmVyc2lvblxcL1tcXGQuXSsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0lPUyA9IENBTl9VU0VfRE9NICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07IC8vIEtlZXAgdGhlc2UgaW4gY2FzZSB3ZSBuZWVkIHRvIHVzZSB0aGVtIGluIHRoZSBmdXR1cmUuXG4vLyBleHBvcnQgY29uc3QgSVNfV0lORE9XUzogYm9vbGVhbiA9IENBTl9VU0VfRE9NICYmIC9XaW4vLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcblxuY29uc3QgSVNfQ0hST01FID0gQ0FOX1VTRV9ET00gJiYgL14oPz0uKkNocm9tZSkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIGV4cG9ydCBjb25zdCBjYW5Vc2VUZXh0SW5wdXRFdmVudDogYm9vbGVhbiA9IENBTl9VU0VfRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlO1xuXG5jb25zdCBJU19BUFBMRV9XRUJLSVQgPSBDQU5fVVNFX0RPTSAmJiAvQXBwbGVXZWJLaXRcXC9bXFxkLl0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFJU19DSFJPTUU7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IE1BUktET1dOX0VNUFRZX0xJTkVfUkVHX0VYUCA9IC9eXFxzezAsM30kLztcbmNvbnN0IENPREVfQkxPQ0tfUkVHX0VYUCA9IC9eYGBgKFxcd3sxLDEwfSk/XFxzPyQvO1xuZnVuY3Rpb24gY3JlYXRlTWFya2Rvd25JbXBvcnQodHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IGJ5VHlwZSA9IHRyYW5zZm9ybWVyc0J5VHlwZSh0cmFuc2Zvcm1lcnMpO1xuICBjb25zdCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXggPSBjcmVhdGVUZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgoYnlUeXBlLnRleHRGb3JtYXQpO1xuICByZXR1cm4gKG1hcmtkb3duU3RyaW5nLCBub2RlKSA9PiB7XG4gICAgY29uc3QgbGluZXMgPSBtYXJrZG93blN0cmluZy5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3QgbGluZXNMZW5ndGggPSBsaW5lcy5sZW5ndGg7XG4gICAgY29uc3Qgcm9vdCA9IG5vZGUgfHwgbGV4aWNhbC4kZ2V0Um9vdCgpO1xuICAgIHJvb3QuY2xlYXIoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXNMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZVRleHQgPSBsaW5lc1tpXTsgLy8gQ29kZWJsb2NrcyBhcmUgcHJvY2Vzc2VkIGZpcnN0IGFzIGFueXRoaW5nIGluc2lkZSBzdWNoIGJsb2NrXG4gICAgICAvLyBpcyBpZ25vcmVkIGZvciBmdXJ0aGVyIHByb2Nlc3NpbmdcbiAgICAgIC8vIFRPRE86XG4gICAgICAvLyBBYnN0cmFjdCBpdCB0byBiZSBkeW5hbWljIGFzIG90aGVyIHRyYW5zZm9ybWVycyAoYWRkIG11bHRpbGluZSBtYXRjaCBvcHRpb24pXG5cbiAgICAgIGNvbnN0IFtjb2RlQmxvY2tOb2RlLCBzaGlmdGVkSW5kZXhdID0gaW1wb3J0Q29kZUJsb2NrKGxpbmVzLCBpLCByb290KTtcblxuICAgICAgaWYgKGNvZGVCbG9ja05vZGUgIT0gbnVsbCkge1xuICAgICAgICBpID0gc2hpZnRlZEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaW1wb3J0QmxvY2tzKGxpbmVUZXh0LCByb290LCBieVR5cGUuZWxlbWVudCwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCBieVR5cGUudGV4dE1hdGNoKTtcbiAgICB9IC8vIFJlbW92aW5nIGVtcHR5IHBhcmFncmFwaHMgYXMgbWQgZG9lcyBub3QgcmVhbGx5XG4gICAgLy8gYWxsb3cgZW1wdHkgbGluZXMgYW5kIHVzZXMgdGhlbSBhcyBkaWxpbWl0ZXJcblxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSByb290LmdldENoaWxkcmVuKCk7XG5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoaXNFbXB0eVBhcmFncmFwaChjaGlsZCkpIHtcbiAgICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxleGljYWwuJGdldFNlbGVjdGlvbigpICE9PSBudWxsKSB7XG4gICAgICByb290LnNlbGVjdEVuZCgpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eVBhcmFncmFwaChub2RlKSB7XG4gIGlmICghbGV4aWNhbC4kaXNQYXJhZ3JhcGhOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICByZXR1cm4gZmlyc3RDaGlsZCA9PSBudWxsIHx8IG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDEgJiYgbGV4aWNhbC4kaXNUZXh0Tm9kZShmaXJzdENoaWxkKSAmJiBNQVJLRE9XTl9FTVBUWV9MSU5FX1JFR19FWFAudGVzdChmaXJzdENoaWxkLmdldFRleHRDb250ZW50KCkpO1xufVxuXG5mdW5jdGlvbiBpbXBvcnRCbG9ja3MobGluZVRleHQsIHJvb3ROb2RlLCBlbGVtZW50VHJhbnNmb3JtZXJzLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycykge1xuICBjb25zdCBsaW5lVGV4dFRyaW1tZWQgPSBsaW5lVGV4dC50cmltKCk7XG4gIGNvbnN0IHRleHROb2RlID0gbGV4aWNhbC4kY3JlYXRlVGV4dE5vZGUobGluZVRleHRUcmltbWVkKTtcbiAgY29uc3QgZWxlbWVudE5vZGUgPSBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gIGVsZW1lbnROb2RlLmFwcGVuZCh0ZXh0Tm9kZSk7XG4gIHJvb3ROb2RlLmFwcGVuZChlbGVtZW50Tm9kZSk7XG5cbiAgZm9yIChjb25zdCB7XG4gICAgcmVnRXhwLFxuICAgIHJlcGxhY2VcbiAgfSBvZiBlbGVtZW50VHJhbnNmb3JtZXJzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBsaW5lVGV4dC5tYXRjaChyZWdFeHApO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB0ZXh0Tm9kZS5zZXRUZXh0Q29udGVudChsaW5lVGV4dC5zbGljZShtYXRjaFswXS5sZW5ndGgpKTtcbiAgICAgIHJlcGxhY2UoZWxlbWVudE5vZGUsIFt0ZXh0Tm9kZV0sIG1hdGNoLCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGltcG9ydFRleHRGb3JtYXRUcmFuc2Zvcm1lcnModGV4dE5vZGUsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKTsgLy8gSWYgbm8gdHJhbnNmb3JtZXIgZm91bmQgYW5kIHdlIGxlZnQgd2l0aCBvcmlnaW5hbCBwYXJhZ3JhcGggbm9kZVxuICAvLyBjYW4gY2hlY2sgaWYgaXRzIGNvbnRlbnQgY2FuIGJlIGFwcGVuZGVkIHRvIHRoZSBwcmV2aW91cyBub2RlXG4gIC8vIGlmIGl0J3MgYSBwYXJhZ3JhcGgsIHF1b3RlIG9yIGxpc3RcblxuICBpZiAoZWxlbWVudE5vZGUuaXNBdHRhY2hlZCgpICYmIGxpbmVUZXh0VHJpbW1lZC5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcHJldmlvdXNOb2RlID0gZWxlbWVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNQYXJhZ3JhcGhOb2RlKHByZXZpb3VzTm9kZSkgfHwgcmljaFRleHQuJGlzUXVvdGVOb2RlKHByZXZpb3VzTm9kZSkgfHwgbGlzdC4kaXNMaXN0Tm9kZShwcmV2aW91c05vZGUpKSB7XG4gICAgICBsZXQgdGFyZ2V0Tm9kZSA9IHByZXZpb3VzTm9kZTtcblxuICAgICAgaWYgKGxpc3QuJGlzTGlzdE5vZGUocHJldmlvdXNOb2RlKSkge1xuICAgICAgICBjb25zdCBsYXN0RGVzY2VuZGFudCA9IHByZXZpb3VzTm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpO1xuXG4gICAgICAgIGlmIChsYXN0RGVzY2VuZGFudCA9PSBudWxsKSB7XG4gICAgICAgICAgdGFyZ2V0Tm9kZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0Tm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQobGFzdERlc2NlbmRhbnQsIGxpc3QuJGlzTGlzdEl0ZW1Ob2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0Tm9kZSAhPSBudWxsICYmIHRhcmdldE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgPiAwKSB7XG4gICAgICAgIHRhcmdldE5vZGUuc3BsaWNlKHRhcmdldE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksIDAsIFtsZXhpY2FsLiRjcmVhdGVMaW5lQnJlYWtOb2RlKCksIC4uLmVsZW1lbnROb2RlLmdldENoaWxkcmVuKCldKTtcbiAgICAgICAgZWxlbWVudE5vZGUucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGltcG9ydENvZGVCbG9jayhsaW5lcywgc3RhcnRMaW5lSW5kZXgsIHJvb3ROb2RlKSB7XG4gIGNvbnN0IG9wZW5NYXRjaCA9IGxpbmVzW3N0YXJ0TGluZUluZGV4XS5tYXRjaChDT0RFX0JMT0NLX1JFR19FWFApO1xuXG4gIGlmIChvcGVuTWF0Y2gpIHtcbiAgICBsZXQgZW5kTGluZUluZGV4ID0gc3RhcnRMaW5lSW5kZXg7XG4gICAgY29uc3QgbGluZXNMZW5ndGggPSBsaW5lcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytlbmRMaW5lSW5kZXggPCBsaW5lc0xlbmd0aCkge1xuICAgICAgY29uc3QgY2xvc2VNYXRjaCA9IGxpbmVzW2VuZExpbmVJbmRleF0ubWF0Y2goQ09ERV9CTE9DS19SRUdfRVhQKTtcblxuICAgICAgaWYgKGNsb3NlTWF0Y2gpIHtcbiAgICAgICAgY29uc3QgY29kZUJsb2NrTm9kZSA9IGNvZGUuJGNyZWF0ZUNvZGVOb2RlKG9wZW5NYXRjaFsxXSk7XG4gICAgICAgIGNvbnN0IHRleHROb2RlID0gbGV4aWNhbC4kY3JlYXRlVGV4dE5vZGUobGluZXMuc2xpY2Uoc3RhcnRMaW5lSW5kZXggKyAxLCBlbmRMaW5lSW5kZXgpLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgY29kZUJsb2NrTm9kZS5hcHBlbmQodGV4dE5vZGUpO1xuICAgICAgICByb290Tm9kZS5hcHBlbmQoY29kZUJsb2NrTm9kZSk7XG4gICAgICAgIHJldHVybiBbY29kZUJsb2NrTm9kZSwgZW5kTGluZUluZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gW251bGwsIHN0YXJ0TGluZUluZGV4XTtcbn0gLy8gUHJvY2Vzc2luZyB0ZXh0IGNvbnRlbnQgYW5kIHJlcGxhY2VzIHRleHQgZm9ybWF0IHRhZ3MuXG4vLyBJdCB0YWtlcyBvdXRlcm1vc3QgdGFnIG1hdGNoIGFuZCBpdHMgY29udGVudCwgY3JlYXRlcyB0ZXh0IG5vZGUgd2l0aFxuLy8gZm9ybWF0IGJhc2VkIG9uIHRhZyBhbmQgdGhlbiByZWN1cnNpdmVseSBleGVjdXRlZCBvdmVyIG5vZGUncyBjb250ZW50XG4vL1xuLy8gRS5nLiBmb3IgXCIqSGVsbG8gKip3b3JsZCoqISpcIiBzdHJpbmcgaXQgd2lsbCBjcmVhdGUgdGV4dCBub2RlIHdpdGhcbi8vIFwiSGVsbG8gKip3b3JsZCoqIVwiIGNvbnRlbnQgYW5kIGl0YWxpYyBmb3JtYXQgYW5kIHJ1biByZWN1cnNpdmVseSBvdmVyXG4vLyBpdHMgY29udGVudCB0byB0cmFuc2Zvcm0gXCIqKndvcmxkKipcIiBwYXJ0XG5cblxuZnVuY3Rpb24gaW1wb3J0VGV4dEZvcm1hdFRyYW5zZm9ybWVycyh0ZXh0Tm9kZSwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgdGV4dENvbnRlbnQgPSB0ZXh0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICBjb25zdCBtYXRjaCA9IGZpbmRPdXRlcm1vc3RNYXRjaCh0ZXh0Q29udGVudCwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4KTtcblxuICBpZiAoIW1hdGNoKSB7XG4gICAgLy8gT25jZSB0ZXh0IGZvcm1hdCBwcm9jZXNzaW5nIGlzIGRvbmUgcnVuIHRleHQgbWF0Y2ggdHJhbnNmb3JtZXJzLCBhcyBpdFxuICAgIC8vIG9ubHkgY2FuIHNwYW4gd2l0aGluIHNpbmdsZSB0ZXh0IG5vZGUgKHVubGluZSBmb3JtYXRzIHRoYXQgY2FuIGNvdmVyIG11bHRpcGxlIG5vZGVzKVxuICAgIGltcG9ydFRleHRNYXRjaFRyYW5zZm9ybWVycyh0ZXh0Tm9kZSwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgY3VycmVudE5vZGUsIHJlbWFpbmRlck5vZGUsIGxlYWRpbmdOb2RlOyAvLyBJZiBtYXRjaGluZyBmdWxsIGNvbnRlbnQgdGhlcmUncyBubyBuZWVkIHRvIHJ1biBzcGxpdFRleHQgYW5kIGNhbiByZXVzZSBleGlzdGluZyB0ZXh0Tm9kZVxuICAvLyB0byB1cGRhdGUgaXRzIGNvbnRlbnQgYW5kIGFwcGx5IGZvcm1hdC4gRS5nLiBmb3IgKipfSGVsbG9fKiogc3RyaW5nIGFmdGVyIGFwcGx5aW5nIGJvbGRcbiAgLy8gZm9ybWF0ICgqKikgaXQgd2lsbCByZXVzZSB0aGUgc2FtZSB0ZXh0IG5vZGUgdG8gYXBwbHkgaXRhbGljIChfKVxuXG4gIGlmIChtYXRjaFswXSA9PT0gdGV4dENvbnRlbnQpIHtcbiAgICBjdXJyZW50Tm9kZSA9IHRleHROb2RlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBtYXRjaC5pbmRleCB8fCAwO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcblxuICAgIGlmIChzdGFydEluZGV4ID09PSAwKSB7XG4gICAgICBbY3VycmVudE5vZGUsIHJlbWFpbmRlck5vZGVdID0gdGV4dE5vZGUuc3BsaXRUZXh0KGVuZEluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgW2xlYWRpbmdOb2RlLCBjdXJyZW50Tm9kZSwgcmVtYWluZGVyTm9kZV0gPSB0ZXh0Tm9kZS5zcGxpdFRleHQoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnROb2RlLnNldFRleHRDb250ZW50KG1hdGNoWzJdKTtcbiAgY29uc3QgdHJhbnNmb3JtZXIgPSB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgudHJhbnNmb3JtZXJzQnlUYWdbbWF0Y2hbMV1dO1xuXG4gIGlmICh0cmFuc2Zvcm1lcikge1xuICAgIGZvciAoY29uc3QgZm9ybWF0IG9mIHRyYW5zZm9ybWVyLmZvcm1hdCkge1xuICAgICAgaWYgKCFjdXJyZW50Tm9kZS5oYXNGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICBjdXJyZW50Tm9kZS50b2dnbGVGb3JtYXQoZm9ybWF0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmVjdXJzaXZlbHkgcnVuIG92ZXIgaW5uZXIgdGV4dCBpZiBpdCdzIG5vdCBpbmxpbmUgY29kZVxuXG5cbiAgaWYgKCFjdXJyZW50Tm9kZS5oYXNGb3JtYXQoJ2NvZGUnKSkge1xuICAgIGltcG9ydFRleHRGb3JtYXRUcmFuc2Zvcm1lcnMoY3VycmVudE5vZGUsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKTtcbiAgfSAvLyBSdW4gb3ZlciBsZWFkaW5nL3JlbWFpbmluZyB0ZXh0IGlmIGFueVxuXG5cbiAgaWYgKGxlYWRpbmdOb2RlKSB7XG4gICAgaW1wb3J0VGV4dEZvcm1hdFRyYW5zZm9ybWVycyhsZWFkaW5nTm9kZSwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuICB9XG5cbiAgaWYgKHJlbWFpbmRlck5vZGUpIHtcbiAgICBpbXBvcnRUZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKHJlbWFpbmRlck5vZGUsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbXBvcnRUZXh0TWF0Y2hUcmFuc2Zvcm1lcnModGV4dE5vZGVfLCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpIHtcbiAgbGV0IHRleHROb2RlID0gdGV4dE5vZGVfO1xuXG4gIG1haW5Mb29wOiB3aGlsZSAodGV4dE5vZGUpIHtcbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRleHRNYXRjaFRyYW5zZm9ybWVycykge1xuICAgICAgY29uc3QgbWF0Y2ggPSB0ZXh0Tm9kZS5nZXRUZXh0Q29udGVudCgpLm1hdGNoKHRyYW5zZm9ybWVyLmltcG9ydFJlZ0V4cCk7XG5cbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBtYXRjaC5pbmRleCB8fCAwO1xuICAgICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgbGV0IHJlcGxhY2VOb2RlLCBsZWZ0VGV4dE5vZGUsIHJpZ2h0VGV4dE5vZGU7XG5cbiAgICAgIGlmIChzdGFydEluZGV4ID09PSAwKSB7XG4gICAgICAgIFtyZXBsYWNlTm9kZSwgdGV4dE5vZGVdID0gdGV4dE5vZGUuc3BsaXRUZXh0KGVuZEluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFtsZWZ0VGV4dE5vZGUsIHJlcGxhY2VOb2RlLCByaWdodFRleHROb2RlXSA9IHRleHROb2RlLnNwbGl0VGV4dChzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZWZ0VGV4dE5vZGUpIHtcbiAgICAgICAgaW1wb3J0VGV4dE1hdGNoVHJhbnNmb3JtZXJzKGxlZnRUZXh0Tm9kZSwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJpZ2h0VGV4dE5vZGUpIHtcbiAgICAgICAgdGV4dE5vZGUgPSByaWdodFRleHROb2RlO1xuICAgICAgfVxuXG4gICAgICB0cmFuc2Zvcm1lci5yZXBsYWNlKHJlcGxhY2VOb2RlLCBtYXRjaCk7XG4gICAgICBjb250aW51ZSBtYWluTG9vcDtcbiAgICB9XG5cbiAgICBicmVhaztcbiAgfVxufSAvLyBGaW5kcyBmaXJzdCBcIjx0YWc+Y29udGVudDx0YWc+XCIgbWF0Y2ggdGhhdCBpcyBub3QgbmVzdGVkIGludG8gYW5vdGhlciB0YWdcblxuXG5mdW5jdGlvbiBmaW5kT3V0ZXJtb3N0TWF0Y2godGV4dENvbnRlbnQsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCkge1xuICBjb25zdCBvcGVuVGFnc01hdGNoID0gdGV4dENvbnRlbnQubWF0Y2godGV4dFRyYW5zZm9ybWVyc0luZGV4Lm9wZW5UYWdzUmVnRXhwKTtcblxuICBpZiAob3BlblRhZ3NNYXRjaCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmb3IgKGNvbnN0IG1hdGNoIG9mIG9wZW5UYWdzTWF0Y2gpIHtcbiAgICAvLyBPcGVuIHRhZ3MgcmVnIGV4cCBtaWdodCBjYXB0dXJlIGxlYWRpbmcgc3BhY2Ugc28gcmVtb3ZpbmcgaXRcbiAgICAvLyBiZWZvcmUgdXNpbmcgbWF0Y2ggdG8gZmluZCB0cmFuc2Zvcm1lclxuICAgIGNvbnN0IHRhZyA9IG1hdGNoLnJlcGxhY2UoL15cXHMvLCAnJyk7XG4gICAgY29uc3QgZnVsbE1hdGNoUmVnRXhwID0gdGV4dFRyYW5zZm9ybWVyc0luZGV4LmZ1bGxNYXRjaFJlZ0V4cEJ5VGFnW3RhZ107XG5cbiAgICBpZiAoZnVsbE1hdGNoUmVnRXhwID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bGxNYXRjaCA9IHRleHRDb250ZW50Lm1hdGNoKGZ1bGxNYXRjaFJlZ0V4cCk7XG4gICAgY29uc3QgdHJhbnNmb3JtZXIgPSB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgudHJhbnNmb3JtZXJzQnlUYWdbdGFnXTtcblxuICAgIGlmIChmdWxsTWF0Y2ggIT0gbnVsbCAmJiB0cmFuc2Zvcm1lciAhPSBudWxsKSB7XG4gICAgICBpZiAodHJhbnNmb3JtZXIuaW50cmF3b3JkICE9PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZnVsbE1hdGNoO1xuICAgICAgfSAvLyBGb3Igbm9uLWludHJhd29yZCB0cmFuc2Zvcm1lcnMgY2hlY2tpbmcgaWYgaXQncyB3aXRoaW4gYSB3b3JkXG4gICAgICAvLyBvciBzdXJyb3VuZGVkIHdpdGggc3BhY2UvcHVuY3R1YXRpb24vbmV3bGluZVxuXG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5kZXggPSAwXG4gICAgICB9ID0gZnVsbE1hdGNoO1xuICAgICAgY29uc3QgYmVmb3JlQ2hhciA9IHRleHRDb250ZW50W2luZGV4IC0gMV07XG4gICAgICBjb25zdCBhZnRlckNoYXIgPSB0ZXh0Q29udGVudFtpbmRleCArIGZ1bGxNYXRjaFswXS5sZW5ndGhdO1xuXG4gICAgICBpZiAoKCFiZWZvcmVDaGFyIHx8IFBVTkNUVUFUSU9OX09SX1NQQUNFLnRlc3QoYmVmb3JlQ2hhcikpICYmICghYWZ0ZXJDaGFyIHx8IFBVTkNUVUFUSU9OX09SX1NQQUNFLnRlc3QoYWZ0ZXJDaGFyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGxNYXRjaDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4KHRleHRUcmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgdHJhbnNmb3JtZXJzQnlUYWcgPSB7fTtcbiAgY29uc3QgZnVsbE1hdGNoUmVnRXhwQnlUYWcgPSB7fTtcbiAgY29uc3Qgb3BlblRhZ3NSZWdFeHAgPSBbXTtcbiAgY29uc3QgZXNjYXBlUmVnRXhwID0gYCg/PCFbXFxcXFxcXFxdKWA7XG5cbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0ZXh0VHJhbnNmb3JtZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFnXG4gICAgfSA9IHRyYW5zZm9ybWVyO1xuICAgIHRyYW5zZm9ybWVyc0J5VGFnW3RhZ10gPSB0cmFuc2Zvcm1lcjtcbiAgICBjb25zdCB0YWdSZWdFeHAgPSB0YWcucmVwbGFjZSgvKFxcKnxcXF58XFwrKS9nLCAnXFxcXCQxJyk7XG4gICAgb3BlblRhZ3NSZWdFeHAucHVzaCh0YWdSZWdFeHApO1xuXG4gICAgaWYgKElTX1NBRkFSSSB8fCBJU19JT1MgfHwgSVNfQVBQTEVfV0VCS0lUKSB7XG4gICAgICBmdWxsTWF0Y2hSZWdFeHBCeVRhZ1t0YWddID0gbmV3IFJlZ0V4cChgKCR7dGFnUmVnRXhwfSkoPyFbJHt0YWdSZWdFeHB9XFxcXHNdKSguKj9bXiR7dGFnUmVnRXhwfVxcXFxzXSkke3RhZ1JlZ0V4cH0oPyEke3RhZ1JlZ0V4cH0pYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGxNYXRjaFJlZ0V4cEJ5VGFnW3RhZ10gPSBuZXcgUmVnRXhwKGAoPzwhW1xcXFxcXFxcJHt0YWdSZWdFeHB9XSkoJHt0YWdSZWdFeHB9KSgoXFxcXFxcXFwke3RhZ1JlZ0V4cH0pPy4qP1teJHt0YWdSZWdFeHB9XFxcXHNdKFxcXFxcXFxcJHt0YWdSZWdFeHB9KT8pKCg/PCFcXFxcXFxcXCl8KD88PVxcXFxcXFxcXFxcXFxcXFwpKSgke3RhZ1JlZ0V4cH0pKD8hW1xcXFxcXFxcJHt0YWdSZWdFeHB9XSlgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIFJlZyBleHAgdG8gZmluZCBvcGVuIHRhZyArIGNvbnRlbnQgKyBjbG9zZSB0YWdcbiAgICBmdWxsTWF0Y2hSZWdFeHBCeVRhZyxcbiAgICAvLyBSZWcgZXhwIHRvIGZpbmQgb3BlbmluZyB0YWdzXG4gICAgb3BlblRhZ3NSZWdFeHA6IG5ldyBSZWdFeHAoKElTX1NBRkFSSSB8fCBJU19JT1MgfHwgSVNfQVBQTEVfV0VCS0lUID8gJycgOiBgJHtlc2NhcGVSZWdFeHB9YCkgKyAnKCcgKyBvcGVuVGFnc1JlZ0V4cC5qb2luKCd8JykgKyAnKScsICdnJyksXG4gICAgdHJhbnNmb3JtZXJzQnlUYWdcbiAgfTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBydW5FbGVtZW50VHJhbnNmb3JtZXJzKHBhcmVudE5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZWxlbWVudFRyYW5zZm9ybWVycykge1xuICBjb25zdCBncmFuZFBhcmVudE5vZGUgPSBwYXJlbnROb2RlLmdldFBhcmVudCgpO1xuXG4gIGlmICghbGV4aWNhbC4kaXNSb290T3JTaGFkb3dSb290KGdyYW5kUGFyZW50Tm9kZSkgfHwgcGFyZW50Tm9kZS5nZXRGaXJzdENoaWxkKCkgIT09IGFuY2hvck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCB0ZXh0Q29udGVudCA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnQoKTsgLy8gQ2hlY2tpbmcgZm9yIGFuY2hvck9mZnNldCBwb3NpdGlvbiB0byBwcmV2ZW50IGFueSBjaGVja3MgZm9yIGNhc2VzIHdoZW4gY2FyZXQgaXMgdG9vIGZhclxuICAvLyBmcm9tIGEgbGluZSBzdGFydCB0byBiZSBhIHBhcnQgb2YgYmxvY2stbGV2ZWwgbWFya2Rvd24gdHJpZ2dlci5cbiAgLy9cbiAgLy8gVE9ETzpcbiAgLy8gQ2FuIGhhdmUgYSBxdWljayBjaGVjayBpZiBjYXJldCBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nIChlLmcuIG9mZnNldCBsZXNzIHRoYW4gMTAtMjApXG4gIC8vIHNpbmNlIG90aGVyd2lzZSBpdCB3b24ndCBiZSBhIG1hcmtkb3duIHNob3J0Y3V0LCBidXQgdGFibGVzIGFyZSBleGNlcHRpb25cblxuICBpZiAodGV4dENvbnRlbnRbYW5jaG9yT2Zmc2V0IC0gMV0gIT09ICcgJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3Qge1xuICAgIHJlZ0V4cCxcbiAgICByZXBsYWNlXG4gIH0gb2YgZWxlbWVudFRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IG1hdGNoID0gdGV4dENvbnRlbnQubWF0Y2gocmVnRXhwKTtcblxuICAgIGlmIChtYXRjaCAmJiBtYXRjaFswXS5sZW5ndGggPT09IGFuY2hvck9mZnNldCkge1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmdzID0gYW5jaG9yTm9kZS5nZXROZXh0U2libGluZ3MoKTtcbiAgICAgIGNvbnN0IFtsZWFkaW5nTm9kZSwgcmVtYWluZGVyTm9kZV0gPSBhbmNob3JOb2RlLnNwbGl0VGV4dChhbmNob3JPZmZzZXQpO1xuICAgICAgbGVhZGluZ05vZGUucmVtb3ZlKCk7XG4gICAgICBjb25zdCBzaWJsaW5ncyA9IHJlbWFpbmRlck5vZGUgPyBbcmVtYWluZGVyTm9kZSwgLi4ubmV4dFNpYmxpbmdzXSA6IG5leHRTaWJsaW5ncztcbiAgICAgIHJlcGxhY2UocGFyZW50Tm9kZSwgc2libGluZ3MsIG1hdGNoLCBmYWxzZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJ1blRleHRNYXRjaFRyYW5zZm9ybWVycyhhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIHRyYW5zZm9ybWVyc0J5VHJpZ2dlcikge1xuICBsZXQgdGV4dENvbnRlbnQgPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IGxhc3RDaGFyID0gdGV4dENvbnRlbnRbYW5jaG9yT2Zmc2V0IC0gMV07XG4gIGNvbnN0IHRyYW5zZm9ybWVycyA9IHRyYW5zZm9ybWVyc0J5VHJpZ2dlcltsYXN0Q2hhcl07XG5cbiAgaWYgKHRyYW5zZm9ybWVycyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElmIHR5cGluZyBpbiB0aGUgbWlkZGxlIG9mIGNvbnRlbnQsIHJlbW92ZSB0aGUgdGFpbCB0byBkb1xuICAvLyByZWcgZXhwIG1hdGNoIHVwIHRvIGEgc3RyaW5nIGVuZCAoY2FyZXQgcG9zaXRpb24pXG5cblxuICBpZiAoYW5jaG9yT2Zmc2V0IDwgdGV4dENvbnRlbnQubGVuZ3RoKSB7XG4gICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgwLCBhbmNob3JPZmZzZXQpO1xuICB9XG5cbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpIHtcbiAgICBjb25zdCBtYXRjaCA9IHRleHRDb250ZW50Lm1hdGNoKHRyYW5zZm9ybWVyLnJlZ0V4cCk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBtYXRjaC5pbmRleCB8fCAwO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICBsZXQgcmVwbGFjZU5vZGU7XG5cbiAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCkge1xuICAgICAgW3JlcGxhY2VOb2RlXSA9IGFuY2hvck5vZGUuc3BsaXRUZXh0KGVuZEluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgWywgcmVwbGFjZU5vZGVdID0gYW5jaG9yTm9kZS5zcGxpdFRleHQoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgIH1cblxuICAgIHJlcGxhY2VOb2RlLnNlbGVjdE5leHQoMCwgMCk7XG4gICAgdHJhbnNmb3JtZXIucmVwbGFjZShyZXBsYWNlTm9kZSwgbWF0Y2gpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBydW5UZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgdGV4dEZvcm1hdFRyYW5zZm9ybWVycykge1xuICBjb25zdCB0ZXh0Q29udGVudCA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgY29uc3QgY2xvc2VUYWdFbmRJbmRleCA9IGFuY2hvck9mZnNldCAtIDE7XG4gIGNvbnN0IGNsb3NlQ2hhciA9IHRleHRDb250ZW50W2Nsb3NlVGFnRW5kSW5kZXhdOyAvLyBRdWljayBjaGVjayBpZiB3ZSdyZSBwb3NzaWJseSBhdCB0aGUgZW5kIG9mIGlubGluZSBtYXJrZG93biBzdHlsZVxuXG4gIGNvbnN0IG1hdGNoZXJzID0gdGV4dEZvcm1hdFRyYW5zZm9ybWVyc1tjbG9zZUNoYXJdO1xuXG4gIGlmICghbWF0Y2hlcnMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IG1hdGNoZXIgb2YgbWF0Y2hlcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YWdcbiAgICB9ID0gbWF0Y2hlcjtcbiAgICBjb25zdCB0YWdMZW5ndGggPSB0YWcubGVuZ3RoO1xuICAgIGNvbnN0IGNsb3NlVGFnU3RhcnRJbmRleCA9IGNsb3NlVGFnRW5kSW5kZXggLSB0YWdMZW5ndGggKyAxOyAvLyBJZiB0YWcgaXMgbm90IHNpbmdsZSBjaGFyIGNoZWNrIGlmIHJlc3Qgb2YgaXQgbWF0Y2hlcyB3aXRoIHRleHQgY29udGVudFxuXG4gICAgaWYgKHRhZ0xlbmd0aCA+IDEpIHtcbiAgICAgIGlmICghaXNFcXVhbFN1YlN0cmluZyh0ZXh0Q29udGVudCwgY2xvc2VUYWdTdGFydEluZGV4LCB0YWcsIDAsIHRhZ0xlbmd0aCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSAvLyBTcGFjZSBiZWZvcmUgY2xvc2luZyB0YWcgY2FuY2VscyBpbmxpbmUgbWFya2Rvd25cblxuXG4gICAgaWYgKHRleHRDb250ZW50W2Nsb3NlVGFnU3RhcnRJbmRleCAtIDFdID09PSAnICcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gU29tZSB0YWdzIGNhbiBub3QgYmUgdXNlZCB3aXRoaW4gd29yZHMsIGhlbmNlIHNob3VsZCBoYXZlIG5ld2xpbmUvc3BhY2UvcHVuY3R1YXRpb24gYWZ0ZXIgaXRcblxuXG4gICAgY29uc3QgYWZ0ZXJDbG9zZVRhZ0NoYXIgPSB0ZXh0Q29udGVudFtjbG9zZVRhZ0VuZEluZGV4ICsgMV07XG5cbiAgICBpZiAobWF0Y2hlci5pbnRyYXdvcmQgPT09IGZhbHNlICYmIGFmdGVyQ2xvc2VUYWdDaGFyICYmICFQVU5DVFVBVElPTl9PUl9TUEFDRS50ZXN0KGFmdGVyQ2xvc2VUYWdDaGFyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgY2xvc2VOb2RlID0gYW5jaG9yTm9kZTtcbiAgICBsZXQgb3Blbk5vZGUgPSBjbG9zZU5vZGU7XG4gICAgbGV0IG9wZW5UYWdTdGFydEluZGV4ID0gZ2V0T3BlblRhZ1N0YXJ0SW5kZXgodGV4dENvbnRlbnQsIGNsb3NlVGFnU3RhcnRJbmRleCwgdGFnKTsgLy8gR28gdGhyb3VnaCB0ZXh0IG5vZGUgc2libGluZ3MgYW5kIHNlYXJjaCBmb3Igb3BlbmluZyB0YWdcbiAgICAvLyBpZiBoYXZlbid0IGZvdW5kIGl0IHdpdGhpbiB0aGUgc2FtZSB0ZXh0IG5vZGUgYXMgY2xvc2luZyB0YWdcblxuICAgIGxldCBzaWJsaW5nID0gb3Blbk5vZGU7XG5cbiAgICB3aGlsZSAob3BlblRhZ1N0YXJ0SW5kZXggPCAwICYmIChzaWJsaW5nID0gc2libGluZy5nZXRQcmV2aW91c1NpYmxpbmcoKSkpIHtcbiAgICAgIGlmIChsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUoc2libGluZykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKHNpYmxpbmcpKSB7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdUZXh0Q29udGVudCA9IHNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgb3Blbk5vZGUgPSBzaWJsaW5nO1xuICAgICAgICBvcGVuVGFnU3RhcnRJbmRleCA9IGdldE9wZW5UYWdTdGFydEluZGV4KHNpYmxpbmdUZXh0Q29udGVudCwgc2libGluZ1RleHRDb250ZW50Lmxlbmd0aCwgdGFnKTtcbiAgICAgIH1cbiAgICB9IC8vIE9wZW5pbmcgdGFnIGlzIG5vdCBmb3VuZFxuXG5cbiAgICBpZiAob3BlblRhZ1N0YXJ0SW5kZXggPCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIE5vIGNvbnRlbnQgYmV0d2VlbiBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ1xuXG5cbiAgICBpZiAob3Blbk5vZGUgPT09IGNsb3NlTm9kZSAmJiBvcGVuVGFnU3RhcnRJbmRleCArIHRhZ0xlbmd0aCA9PT0gY2xvc2VUYWdTdGFydEluZGV4KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIENoZWNraW5nIGxvbmdlciB0YWdzIGZvciByZXBlYXRpbmcgY2hhcnMgKGUuZy4gKioqIHZzICoqKVxuXG5cbiAgICBjb25zdCBwcmV2T3Blbk5vZGVUZXh0ID0gb3Blbk5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcblxuICAgIGlmIChvcGVuVGFnU3RhcnRJbmRleCA+IDAgJiYgcHJldk9wZW5Ob2RlVGV4dFtvcGVuVGFnU3RhcnRJbmRleCAtIDFdID09PSBjbG9zZUNoYXIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gU29tZSB0YWdzIGNhbiBub3QgYmUgdXNlZCB3aXRoaW4gd29yZHMsIGhlbmNlIHNob3VsZCBoYXZlIG5ld2xpbmUvc3BhY2UvcHVuY3R1YXRpb24gYmVmb3JlIGl0XG5cblxuICAgIGNvbnN0IGJlZm9yZU9wZW5UYWdDaGFyID0gcHJldk9wZW5Ob2RlVGV4dFtvcGVuVGFnU3RhcnRJbmRleCAtIDFdO1xuXG4gICAgaWYgKG1hdGNoZXIuaW50cmF3b3JkID09PSBmYWxzZSAmJiBiZWZvcmVPcGVuVGFnQ2hhciAmJiAhUFVOQ1RVQVRJT05fT1JfU1BBQ0UudGVzdChiZWZvcmVPcGVuVGFnQ2hhcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gQ2xlYW4gdGV4dCBmcm9tIG9wZW5pbmcgYW5kIGNsb3NpbmcgdGFncyAoc3RhcnRpbmcgZnJvbSBjbG9zaW5nIHRhZ1xuICAgIC8vIHRvIHByZXZlbnQgYW55IG9mZnNldCBzaGlmdHMgaWYgd2Ugc3RhcnQgZnJvbSBvcGVuaW5nIG9uZSlcblxuXG4gICAgY29uc3QgcHJldkNsb3NlTm9kZVRleHQgPSBjbG9zZU5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBjb25zdCBjbG9zZU5vZGVUZXh0ID0gcHJldkNsb3NlTm9kZVRleHQuc2xpY2UoMCwgY2xvc2VUYWdTdGFydEluZGV4KSArIHByZXZDbG9zZU5vZGVUZXh0LnNsaWNlKGNsb3NlVGFnRW5kSW5kZXggKyAxKTtcbiAgICBjbG9zZU5vZGUuc2V0VGV4dENvbnRlbnQoY2xvc2VOb2RlVGV4dCk7XG4gICAgY29uc3Qgb3Blbk5vZGVUZXh0ID0gb3Blbk5vZGUgPT09IGNsb3NlTm9kZSA/IGNsb3NlTm9kZVRleHQgOiBwcmV2T3Blbk5vZGVUZXh0O1xuICAgIG9wZW5Ob2RlLnNldFRleHRDb250ZW50KG9wZW5Ob2RlVGV4dC5zbGljZSgwLCBvcGVuVGFnU3RhcnRJbmRleCkgKyBvcGVuTm9kZVRleHQuc2xpY2Uob3BlblRhZ1N0YXJ0SW5kZXggKyB0YWdMZW5ndGgpKTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbGV4aWNhbC4kY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKTtcbiAgICBsZXhpY2FsLiRzZXRTZWxlY3Rpb24obmV4dFNlbGVjdGlvbik7IC8vIEFkanVzdCBvZmZzZXQgYmFzZWQgb24gZGVsZXRlZCBjaGFyc1xuXG4gICAgY29uc3QgbmV3T2Zmc2V0ID0gY2xvc2VUYWdFbmRJbmRleCAtIHRhZ0xlbmd0aCAqIChvcGVuTm9kZSA9PT0gY2xvc2VOb2RlID8gMiA6IDEpICsgMTtcbiAgICBuZXh0U2VsZWN0aW9uLmFuY2hvci5zZXQob3Blbk5vZGUuX19rZXksIG9wZW5UYWdTdGFydEluZGV4LCAndGV4dCcpO1xuICAgIG5leHRTZWxlY3Rpb24uZm9jdXMuc2V0KGNsb3NlTm9kZS5fX2tleSwgbmV3T2Zmc2V0LCAndGV4dCcpOyAvLyBBcHBseSBmb3JtYXR0aW5nIHRvIHNlbGVjdGVkIHRleHRcblxuICAgIGZvciAoY29uc3QgZm9ybWF0IG9mIG1hdGNoZXIuZm9ybWF0KSB7XG4gICAgICBpZiAoIW5leHRTZWxlY3Rpb24uaGFzRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgbmV4dFNlbGVjdGlvbi5mb3JtYXRUZXh0KGZvcm1hdCk7XG4gICAgICB9XG4gICAgfSAvLyBDb2xsYXBzZSBzZWxlY3Rpb24gdXAgdG8gdGhlIGZvY3VzIHBvaW50XG5cblxuICAgIG5leHRTZWxlY3Rpb24uYW5jaG9yLnNldChuZXh0U2VsZWN0aW9uLmZvY3VzLmtleSwgbmV4dFNlbGVjdGlvbi5mb2N1cy5vZmZzZXQsIG5leHRTZWxlY3Rpb24uZm9jdXMudHlwZSk7IC8vIFJlbW92ZSBmb3JtYXR0aW5nIGZyb20gY29sbGFwc2VkIHNlbGVjdGlvblxuXG4gICAgZm9yIChjb25zdCBmb3JtYXQgb2YgbWF0Y2hlci5mb3JtYXQpIHtcbiAgICAgIGlmIChuZXh0U2VsZWN0aW9uLmhhc0Zvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIG5leHRTZWxlY3Rpb24udG9nZ2xlRm9ybWF0KGZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgbmV4dFNlbGVjdGlvbi5mb3JtYXQgPSBzZWxlY3Rpb24uZm9ybWF0O1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRPcGVuVGFnU3RhcnRJbmRleChzdHJpbmcsIG1heEluZGV4LCB0YWcpIHtcbiAgY29uc3QgdGFnTGVuZ3RoID0gdGFnLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gbWF4SW5kZXg7IGkgPj0gdGFnTGVuZ3RoOyBpLS0pIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gaSAtIHRhZ0xlbmd0aDtcblxuICAgIGlmIChpc0VxdWFsU3ViU3RyaW5nKHN0cmluZywgc3RhcnRJbmRleCwgdGFnLCAwLCB0YWdMZW5ndGgpICYmIC8vIFNwYWNlIGFmdGVyIG9wZW5pbmcgdGFnIGNhbmNlbHMgdHJhbnNmb3JtYXRpb25cbiAgICBzdHJpbmdbc3RhcnRJbmRleCArIHRhZ0xlbmd0aF0gIT09ICcgJykge1xuICAgICAgcmV0dXJuIHN0YXJ0SW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBpc0VxdWFsU3ViU3RyaW5nKHN0cmluZ0EsIGFTdGFydCwgc3RyaW5nQiwgYlN0YXJ0LCBsZW5ndGgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHJpbmdBW2FTdGFydCArIGldICE9PSBzdHJpbmdCW2JTdGFydCArIGldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTWFya2Rvd25TaG9ydGN1dHMoZWRpdG9yLCB0cmFuc2Zvcm1lcnMgPSBUUkFOU0ZPUk1FUlMpIHtcbiAgY29uc3QgYnlUeXBlID0gdHJhbnNmb3JtZXJzQnlUeXBlKHRyYW5zZm9ybWVycyk7XG4gIGNvbnN0IHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCA9IGluZGV4QnkoYnlUeXBlLnRleHRGb3JtYXQsICh7XG4gICAgdGFnXG4gIH0pID0+IHRhZ1t0YWcubGVuZ3RoIC0gMV0pO1xuICBjb25zdCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnNJbmRleCA9IGluZGV4QnkoYnlUeXBlLnRleHRNYXRjaCwgKHtcbiAgICB0cmlnZ2VyXG4gIH0pID0+IHRyaWdnZXIpO1xuXG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKSB7XG4gICAgY29uc3QgdHlwZSA9IHRyYW5zZm9ybWVyLnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2VsZW1lbnQnIHx8IHR5cGUgPT09ICd0ZXh0LW1hdGNoJykge1xuICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gdHJhbnNmb3JtZXIuZGVwZW5kZW5jaWVzO1xuXG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGlmICghZWRpdG9yLmhhc05vZGUobm9kZSkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgTWFya2Rvd25TaG9ydGN1dHM6IG1pc3NpbmcgZGVwZW5kZW5jeSAke25vZGUuZ2V0VHlwZSgpfSBmb3IgdHJhbnNmb3JtZXIuIEVuc3VyZSBub2RlIGRlcGVuZGVuY3kgaXMgaW5jbHVkZWQgaW4gZWRpdG9yIGluaXRpYWwgY29uZmlnLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRyYW5zZm9ybSA9IChwYXJlbnROb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpID0+IHtcbiAgICBpZiAocnVuRWxlbWVudFRyYW5zZm9ybWVycyhwYXJlbnROb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGJ5VHlwZS5lbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChydW5UZXh0TWF0Y2hUcmFuc2Zvcm1lcnMoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnNJbmRleCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBydW5UZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4KTtcbiAgfTtcblxuICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHtcbiAgICB0YWdzLFxuICAgIGRpcnR5TGVhdmVzLFxuICAgIGVkaXRvclN0YXRlLFxuICAgIHByZXZFZGl0b3JTdGF0ZVxuICB9KSA9PiB7XG4gICAgLy8gSWdub3JlIHVwZGF0ZXMgZnJvbSB1bmRvL3JlZG8gKGFzIGNoYW5nZXMgYWxyZWFkeSBjYWxjdWxhdGVkKVxuICAgIGlmICh0YWdzLmhhcygnaGlzdG9yaWMnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgZWRpdG9yIGlzIHN0aWxsIGNvbXBvc2luZyAoaS5lLiBiYWNrdGlja3MpIHdlIG11c3Qgd2FpdCBiZWZvcmUgdGhlIHVzZXIgY29uZmlybXMgdGhlIGtleVxuXG5cbiAgICBpZiAoZWRpdG9yLmlzQ29tcG9zaW5nKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5yZWFkKGxleGljYWwuJGdldFNlbGVjdGlvbik7XG4gICAgY29uc3QgcHJldlNlbGVjdGlvbiA9IHByZXZFZGl0b3JTdGF0ZS5yZWFkKGxleGljYWwuJGdldFNlbGVjdGlvbik7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgfHwgIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmNob3JLZXkgPSBzZWxlY3Rpb24uYW5jaG9yLmtleTtcbiAgICBjb25zdCBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcblxuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQoYW5jaG9yS2V5KTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNUZXh0Tm9kZShhbmNob3JOb2RlKSB8fCAhZGlydHlMZWF2ZXMuaGFzKGFuY2hvcktleSkgfHwgYW5jaG9yT2Zmc2V0ICE9PSAxICYmIGFuY2hvck9mZnNldCA+IHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCArIDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIC8vIE1hcmtkb3duIGlzIG5vdCBhdmFpbGFibGUgaW5zaWRlIGNvZGVcbiAgICAgIGlmIChhbmNob3JOb2RlLmhhc0Zvcm1hdCgnY29kZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGFuY2hvck5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBudWxsIHx8IGNvZGUuJGlzQ29kZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cmFuc2Zvcm0ocGFyZW50Tm9kZSwgYW5jaG9yTm9kZSwgc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBjcmVhdGVCbG9ja05vZGUgPSBjcmVhdGVOb2RlID0+IHtcbiAgcmV0dXJuIChwYXJlbnROb2RlLCBjaGlsZHJlbiwgbWF0Y2gpID0+IHtcbiAgICBjb25zdCBub2RlID0gY3JlYXRlTm9kZShtYXRjaCk7XG4gICAgbm9kZS5hcHBlbmQoLi4uY2hpbGRyZW4pO1xuICAgIHBhcmVudE5vZGUucmVwbGFjZShub2RlKTtcbiAgICBub2RlLnNlbGVjdCgwLCAwKTtcbiAgfTtcbn07IC8vIEFtb3VudCBvZiBzcGFjZXMgdGhhdCBkZWZpbmUgaW5kZW50YXRpb24gbGV2ZWxcbi8vIFRPRE86IHNob3VsZCBiZSBhbiBvcHRpb25cblxuXG5jb25zdCBMSVNUX0lOREVOVF9TSVpFID0gNDtcblxuY29uc3QgbGlzdFJlcGxhY2UgPSBsaXN0VHlwZSA9PiB7XG4gIHJldHVybiAocGFyZW50Tm9kZSwgY2hpbGRyZW4sIG1hdGNoKSA9PiB7XG4gICAgY29uc3QgcHJldmlvdXNOb2RlID0gcGFyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBuZXh0Tm9kZSA9IHBhcmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBjb25zdCBsaXN0SXRlbSA9IGxpc3QuJGNyZWF0ZUxpc3RJdGVtTm9kZShsaXN0VHlwZSA9PT0gJ2NoZWNrJyA/IG1hdGNoWzNdID09PSAneCcgOiB1bmRlZmluZWQpO1xuXG4gICAgaWYgKGxpc3QuJGlzTGlzdE5vZGUobmV4dE5vZGUpICYmIG5leHROb2RlLmdldExpc3RUeXBlKCkgPT09IGxpc3RUeXBlKSB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkID0gbmV4dE5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShsaXN0SXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgbGV0J3MgaGFuZGxlIGdyYWNlZnVsbHksIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgbmV4dE5vZGUuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICAgIH1cblxuICAgICAgcGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICB9IGVsc2UgaWYgKGxpc3QuJGlzTGlzdE5vZGUocHJldmlvdXNOb2RlKSAmJiBwcmV2aW91c05vZGUuZ2V0TGlzdFR5cGUoKSA9PT0gbGlzdFR5cGUpIHtcbiAgICAgIHByZXZpb3VzTm9kZS5hcHBlbmQobGlzdEl0ZW0pO1xuICAgICAgcGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGlzdCQxID0gbGlzdC4kY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUsIGxpc3RUeXBlID09PSAnbnVtYmVyJyA/IE51bWJlcihtYXRjaFsyXSkgOiB1bmRlZmluZWQpO1xuICAgICAgbGlzdCQxLmFwcGVuZChsaXN0SXRlbSk7XG4gICAgICBwYXJlbnROb2RlLnJlcGxhY2UobGlzdCQxKTtcbiAgICB9XG5cbiAgICBsaXN0SXRlbS5hcHBlbmQoLi4uY2hpbGRyZW4pO1xuICAgIGxpc3RJdGVtLnNlbGVjdCgwLCAwKTtcbiAgICBjb25zdCBpbmRlbnQgPSBNYXRoLmZsb29yKG1hdGNoWzFdLmxlbmd0aCAvIExJU1RfSU5ERU5UX1NJWkUpO1xuXG4gICAgaWYgKGluZGVudCkge1xuICAgICAgbGlzdEl0ZW0uc2V0SW5kZW50KGluZGVudCk7XG4gICAgfVxuICB9O1xufTtcblxuY29uc3QgbGlzdEV4cG9ydCA9IChsaXN0Tm9kZSwgZXhwb3J0Q2hpbGRyZW4sIGRlcHRoKSA9PiB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBjb25zdCBjaGlsZHJlbiA9IGxpc3ROb2RlLmdldENoaWxkcmVuKCk7XG4gIGxldCBpbmRleCA9IDA7XG5cbiAgZm9yIChjb25zdCBsaXN0SXRlbU5vZGUgb2YgY2hpbGRyZW4pIHtcbiAgICBpZiAobGlzdC4kaXNMaXN0SXRlbU5vZGUobGlzdEl0ZW1Ob2RlKSkge1xuICAgICAgaWYgKGxpc3RJdGVtTm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSkge1xuICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gbGlzdEl0ZW1Ob2RlLmdldEZpcnN0Q2hpbGQoKTtcblxuICAgICAgICBpZiAobGlzdC4kaXNMaXN0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKGxpc3RFeHBvcnQoZmlyc3RDaGlsZCwgZXhwb3J0Q2hpbGRyZW4sIGRlcHRoICsgMSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluZGVudCA9ICcgJy5yZXBlYXQoZGVwdGggKiBMSVNUX0lOREVOVF9TSVpFKTtcbiAgICAgIGNvbnN0IGxpc3RUeXBlID0gbGlzdE5vZGUuZ2V0TGlzdFR5cGUoKTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGxpc3RUeXBlID09PSAnbnVtYmVyJyA/IGAke2xpc3ROb2RlLmdldFN0YXJ0KCkgKyBpbmRleH0uIGAgOiBsaXN0VHlwZSA9PT0gJ2NoZWNrJyA/IGAtIFske2xpc3RJdGVtTm9kZS5nZXRDaGVja2VkKCkgPyAneCcgOiAnICd9XSBgIDogJy0gJztcbiAgICAgIG91dHB1dC5wdXNoKGluZGVudCArIHByZWZpeCArIGV4cG9ydENoaWxkcmVuKGxpc3RJdGVtTm9kZSkpO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0LmpvaW4oJ1xcbicpO1xufTtcblxuY29uc3QgSEVBRElORyA9IHtcbiAgZGVwZW5kZW5jaWVzOiBbcmljaFRleHQuSGVhZGluZ05vZGVdLFxuICBleHBvcnQ6IChub2RlLCBleHBvcnRDaGlsZHJlbikgPT4ge1xuICAgIGlmICghcmljaFRleHQuJGlzSGVhZGluZ05vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGxldmVsID0gTnVtYmVyKG5vZGUuZ2V0VGFnKCkuc2xpY2UoMSkpO1xuICAgIHJldHVybiAnIycucmVwZWF0KGxldmVsKSArICcgJyArIGV4cG9ydENoaWxkcmVuKG5vZGUpO1xuICB9LFxuICByZWdFeHA6IC9eKCN7MSw2fSlcXHMvLFxuICByZXBsYWNlOiBjcmVhdGVCbG9ja05vZGUobWF0Y2ggPT4ge1xuICAgIGNvbnN0IHRhZyA9ICdoJyArIG1hdGNoWzFdLmxlbmd0aDtcbiAgICByZXR1cm4gcmljaFRleHQuJGNyZWF0ZUhlYWRpbmdOb2RlKHRhZyk7XG4gIH0pLFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBRVU9URSA9IHtcbiAgZGVwZW5kZW5jaWVzOiBbcmljaFRleHQuUXVvdGVOb2RlXSxcbiAgZXhwb3J0OiAobm9kZSwgZXhwb3J0Q2hpbGRyZW4pID0+IHtcbiAgICBpZiAoIXJpY2hUZXh0LiRpc1F1b3RlTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbGluZXMgPSBleHBvcnRDaGlsZHJlbihub2RlKS5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIG91dHB1dC5wdXNoKCc+ICcgKyBsaW5lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oJ1xcbicpO1xuICB9LFxuICByZWdFeHA6IC9ePlxccy8sXG4gIHJlcGxhY2U6IChwYXJlbnROb2RlLCBjaGlsZHJlbiwgX21hdGNoLCBpc0ltcG9ydCkgPT4ge1xuICAgIGlmIChpc0ltcG9ydCkge1xuICAgICAgY29uc3QgcHJldmlvdXNOb2RlID0gcGFyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgICAgaWYgKHJpY2hUZXh0LiRpc1F1b3RlTm9kZShwcmV2aW91c05vZGUpKSB7XG4gICAgICAgIHByZXZpb3VzTm9kZS5zcGxpY2UocHJldmlvdXNOb2RlLmdldENoaWxkcmVuU2l6ZSgpLCAwLCBbbGV4aWNhbC4kY3JlYXRlTGluZUJyZWFrTm9kZSgpLCAuLi5jaGlsZHJlbl0pO1xuICAgICAgICBwcmV2aW91c05vZGUuc2VsZWN0KDAsIDApO1xuICAgICAgICBwYXJlbnROb2RlLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IHJpY2hUZXh0LiRjcmVhdGVRdW90ZU5vZGUoKTtcbiAgICBub2RlLmFwcGVuZCguLi5jaGlsZHJlbik7XG4gICAgcGFyZW50Tm9kZS5yZXBsYWNlKG5vZGUpO1xuICAgIG5vZGUuc2VsZWN0KDAsIDApO1xuICB9LFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBDT0RFID0ge1xuICBkZXBlbmRlbmNpZXM6IFtjb2RlLkNvZGVOb2RlXSxcbiAgZXhwb3J0OiBub2RlID0+IHtcbiAgICBpZiAoIWNvZGUuJGlzQ29kZU5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIHJldHVybiAnYGBgJyArIChub2RlLmdldExhbmd1YWdlKCkgfHwgJycpICsgKHRleHRDb250ZW50ID8gJ1xcbicgKyB0ZXh0Q29udGVudCA6ICcnKSArICdcXG4nICsgJ2BgYCc7XG4gIH0sXG4gIHJlZ0V4cDogL15gYGAoXFx3ezEsMTB9KT9cXHMvLFxuICByZXBsYWNlOiBjcmVhdGVCbG9ja05vZGUobWF0Y2ggPT4ge1xuICAgIHJldHVybiBjb2RlLiRjcmVhdGVDb2RlTm9kZShtYXRjaCA/IG1hdGNoWzFdIDogdW5kZWZpbmVkKTtcbiAgfSksXG4gIHR5cGU6ICdlbGVtZW50J1xufTtcbmNvbnN0IFVOT1JERVJFRF9MSVNUID0ge1xuICBkZXBlbmRlbmNpZXM6IFtsaXN0Lkxpc3ROb2RlLCBsaXN0Lkxpc3RJdGVtTm9kZV0sXG4gIGV4cG9ydDogKG5vZGUsIGV4cG9ydENoaWxkcmVuKSA9PiB7XG4gICAgcmV0dXJuIGxpc3QuJGlzTGlzdE5vZGUobm9kZSkgPyBsaXN0RXhwb3J0KG5vZGUsIGV4cG9ydENoaWxkcmVuLCAwKSA6IG51bGw7XG4gIH0sXG4gIHJlZ0V4cDogL14oXFxzKilbLSorXVxccy8sXG4gIHJlcGxhY2U6IGxpc3RSZXBsYWNlKCdidWxsZXQnKSxcbiAgdHlwZTogJ2VsZW1lbnQnXG59O1xuY29uc3QgQ0hFQ0tfTElTVCA9IHtcbiAgZGVwZW5kZW5jaWVzOiBbbGlzdC5MaXN0Tm9kZSwgbGlzdC5MaXN0SXRlbU5vZGVdLFxuICBleHBvcnQ6IChub2RlLCBleHBvcnRDaGlsZHJlbikgPT4ge1xuICAgIHJldHVybiBsaXN0LiRpc0xpc3ROb2RlKG5vZGUpID8gbGlzdEV4cG9ydChub2RlLCBleHBvcnRDaGlsZHJlbiwgMCkgOiBudWxsO1xuICB9LFxuICByZWdFeHA6IC9eKFxccyopKD86LVxccyk/XFxzPyhcXFsoXFxzfHgpP1xcXSlcXHMvaSxcbiAgcmVwbGFjZTogbGlzdFJlcGxhY2UoJ2NoZWNrJyksXG4gIHR5cGU6ICdlbGVtZW50J1xufTtcbmNvbnN0IE9SREVSRURfTElTVCA9IHtcbiAgZGVwZW5kZW5jaWVzOiBbbGlzdC5MaXN0Tm9kZSwgbGlzdC5MaXN0SXRlbU5vZGVdLFxuICBleHBvcnQ6IChub2RlLCBleHBvcnRDaGlsZHJlbikgPT4ge1xuICAgIHJldHVybiBsaXN0LiRpc0xpc3ROb2RlKG5vZGUpID8gbGlzdEV4cG9ydChub2RlLCBleHBvcnRDaGlsZHJlbiwgMCkgOiBudWxsO1xuICB9LFxuICByZWdFeHA6IC9eKFxccyopKFxcZHsxLH0pXFwuXFxzLyxcbiAgcmVwbGFjZTogbGlzdFJlcGxhY2UoJ251bWJlcicpLFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBJTkxJTkVfQ09ERSA9IHtcbiAgZm9ybWF0OiBbJ2NvZGUnXSxcbiAgdGFnOiAnYCcsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBISUdITElHSFQgPSB7XG4gIGZvcm1hdDogWydoaWdobGlnaHQnXSxcbiAgdGFnOiAnPT0nLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuY29uc3QgQk9MRF9JVEFMSUNfU1RBUiA9IHtcbiAgZm9ybWF0OiBbJ2JvbGQnLCAnaXRhbGljJ10sXG4gIHRhZzogJyoqKicsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBCT0xEX0lUQUxJQ19VTkRFUlNDT1JFID0ge1xuICBmb3JtYXQ6IFsnYm9sZCcsICdpdGFsaWMnXSxcbiAgaW50cmF3b3JkOiBmYWxzZSxcbiAgdGFnOiAnX19fJyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTtcbmNvbnN0IEJPTERfU1RBUiA9IHtcbiAgZm9ybWF0OiBbJ2JvbGQnXSxcbiAgdGFnOiAnKionLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuY29uc3QgQk9MRF9VTkRFUlNDT1JFID0ge1xuICBmb3JtYXQ6IFsnYm9sZCddLFxuICBpbnRyYXdvcmQ6IGZhbHNlLFxuICB0YWc6ICdfXycsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBTVFJJS0VUSFJPVUdIID0ge1xuICBmb3JtYXQ6IFsnc3RyaWtldGhyb3VnaCddLFxuICB0YWc6ICd+ficsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBJVEFMSUNfU1RBUiA9IHtcbiAgZm9ybWF0OiBbJ2l0YWxpYyddLFxuICB0YWc6ICcqJyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTtcbmNvbnN0IElUQUxJQ19VTkRFUlNDT1JFID0ge1xuICBmb3JtYXQ6IFsnaXRhbGljJ10sXG4gIGludHJhd29yZDogZmFsc2UsXG4gIHRhZzogJ18nLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59OyAvLyBPcmRlciBvZiB0ZXh0IHRyYW5zZm9ybWVycyBtYXR0ZXJzOlxuLy9cbi8vIC0gY29kZSBzaG91bGQgZ28gZmlyc3QgYXMgaXQgcHJldmVudHMgYW55IHRyYW5zZm9ybWF0aW9ucyBpbnNpZGVcbi8vIC0gdGhlbiBsb25nZXIgdGFncyBtYXRjaCAoZS5nLiAqKiBvciBfXyBzaG91bGQgZ28gYmVmb3JlICogb3IgXylcblxuY29uc3QgTElOSyA9IHtcbiAgZGVwZW5kZW5jaWVzOiBbbGluay5MaW5rTm9kZV0sXG4gIGV4cG9ydDogKG5vZGUsIGV4cG9ydENoaWxkcmVuLCBleHBvcnRGb3JtYXQpID0+IHtcbiAgICBpZiAoIWxpbmsuJGlzTGlua05vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHRpdGxlID0gbm9kZS5nZXRUaXRsZSgpO1xuICAgIGNvbnN0IGxpbmtDb250ZW50ID0gdGl0bGUgPyBgWyR7bm9kZS5nZXRUZXh0Q29udGVudCgpfV0oJHtub2RlLmdldFVSTCgpfSBcIiR7dGl0bGV9XCIpYCA6IGBbJHtub2RlLmdldFRleHRDb250ZW50KCl9XSgke25vZGUuZ2V0VVJMKCl9KWA7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpOyAvLyBBZGQgdGV4dCBzdHlsZXMgb25seSBpZiBsaW5rIGhhcyBzaW5nbGUgdGV4dCBub2RlIGluc2lkZS4gSWYgaXQncyBtb3JlXG4gICAgLy8gdGhlbiBvbmUgd2UgaWdub3JlIGl0IGFzIG1hcmtkb3duIGRvZXMgbm90IHN1cHBvcnQgbmVzdGVkIHN0eWxlcyBmb3IgbGlua3NcblxuICAgIGlmIChub2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAxICYmIGxleGljYWwuJGlzVGV4dE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgIHJldHVybiBleHBvcnRGb3JtYXQoZmlyc3RDaGlsZCwgbGlua0NvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGlua0NvbnRlbnQ7XG4gICAgfVxuICB9LFxuICBpbXBvcnRSZWdFeHA6IC8oPzpcXFsoW15bXSspXFxdKSg/OlxcKCg/OihbXigpXFxzXSspKD86XFxzXCIoKD86W15cIl0qXFxcXFwiKSpbXlwiXSopXCJcXHMqKT8pXFwpKS8sXG4gIHJlZ0V4cDogLyg/OlxcWyhbXltdKylcXF0pKD86XFwoKD86KFteKClcXHNdKykoPzpcXHNcIigoPzpbXlwiXSpcXFxcXCIpKlteXCJdKilcIlxccyopPylcXCkpJC8sXG4gIHJlcGxhY2U6ICh0ZXh0Tm9kZSwgbWF0Y2gpID0+IHtcbiAgICBjb25zdCBbLCBsaW5rVGV4dCwgbGlua1VybCwgbGlua1RpdGxlXSA9IG1hdGNoO1xuICAgIGNvbnN0IGxpbmtOb2RlID0gbGluay4kY3JlYXRlTGlua05vZGUobGlua1VybCwge1xuICAgICAgdGl0bGU6IGxpbmtUaXRsZVxuICAgIH0pO1xuICAgIGNvbnN0IGxpbmtUZXh0Tm9kZSA9IGxleGljYWwuJGNyZWF0ZVRleHROb2RlKGxpbmtUZXh0KTtcbiAgICBsaW5rVGV4dE5vZGUuc2V0Rm9ybWF0KHRleHROb2RlLmdldEZvcm1hdCgpKTtcbiAgICBsaW5rTm9kZS5hcHBlbmQobGlua1RleHROb2RlKTtcbiAgICB0ZXh0Tm9kZS5yZXBsYWNlKGxpbmtOb2RlKTtcbiAgfSxcbiAgdHJpZ2dlcjogJyknLFxuICB0eXBlOiAndGV4dC1tYXRjaCdcbn07XG5cbi8qKiBAbW9kdWxlIEBsZXhpY2FsL21hcmtkb3duICovXG5jb25zdCBFTEVNRU5UX1RSQU5TRk9STUVSUyA9IFtIRUFESU5HLCBRVU9URSwgQ09ERSwgVU5PUkRFUkVEX0xJU1QsIE9SREVSRURfTElTVF07IC8vIE9yZGVyIG9mIHRleHQgZm9ybWF0IHRyYW5zZm9ybWVycyBtYXR0ZXJzOlxuLy9cbi8vIC0gY29kZSBzaG91bGQgZ28gZmlyc3QgYXMgaXQgcHJldmVudHMgYW55IHRyYW5zZm9ybWF0aW9ucyBpbnNpZGVcbi8vIC0gdGhlbiBsb25nZXIgdGFncyBtYXRjaCAoZS5nLiAqKiBvciBfXyBzaG91bGQgZ28gYmVmb3JlICogb3IgXylcblxuY29uc3QgVEVYVF9GT1JNQVRfVFJBTlNGT1JNRVJTID0gW0lOTElORV9DT0RFLCBCT0xEX0lUQUxJQ19TVEFSLCBCT0xEX0lUQUxJQ19VTkRFUlNDT1JFLCBCT0xEX1NUQVIsIEJPTERfVU5ERVJTQ09SRSwgSElHSExJR0hULCBJVEFMSUNfU1RBUiwgSVRBTElDX1VOREVSU0NPUkUsIFNUUklLRVRIUk9VR0hdO1xuY29uc3QgVEVYVF9NQVRDSF9UUkFOU0ZPUk1FUlMgPSBbTElOS107XG5jb25zdCBUUkFOU0ZPUk1FUlMgPSBbLi4uRUxFTUVOVF9UUkFOU0ZPUk1FUlMsIC4uLlRFWFRfRk9STUFUX1RSQU5TRk9STUVSUywgLi4uVEVYVF9NQVRDSF9UUkFOU0ZPUk1FUlNdO1xuXG5mdW5jdGlvbiAkY29udmVydEZyb21NYXJrZG93blN0cmluZyhtYXJrZG93biwgdHJhbnNmb3JtZXJzID0gVFJBTlNGT1JNRVJTLCBub2RlKSB7XG4gIGNvbnN0IGltcG9ydE1hcmtkb3duID0gY3JlYXRlTWFya2Rvd25JbXBvcnQodHJhbnNmb3JtZXJzKTtcbiAgcmV0dXJuIGltcG9ydE1hcmtkb3duKG1hcmtkb3duLCBub2RlKTtcbn1cblxuZnVuY3Rpb24gJGNvbnZlcnRUb01hcmtkb3duU3RyaW5nKHRyYW5zZm9ybWVycyA9IFRSQU5TRk9STUVSUywgbm9kZSkge1xuICBjb25zdCBleHBvcnRNYXJrZG93biA9IGNyZWF0ZU1hcmtkb3duRXhwb3J0KHRyYW5zZm9ybWVycyk7XG4gIHJldHVybiBleHBvcnRNYXJrZG93bihub2RlKTtcbn1cblxuZXhwb3J0cy4kY29udmVydEZyb21NYXJrZG93blN0cmluZyA9ICRjb252ZXJ0RnJvbU1hcmtkb3duU3RyaW5nO1xuZXhwb3J0cy4kY29udmVydFRvTWFya2Rvd25TdHJpbmcgPSAkY29udmVydFRvTWFya2Rvd25TdHJpbmc7XG5leHBvcnRzLkJPTERfSVRBTElDX1NUQVIgPSBCT0xEX0lUQUxJQ19TVEFSO1xuZXhwb3J0cy5CT0xEX0lUQUxJQ19VTkRFUlNDT1JFID0gQk9MRF9JVEFMSUNfVU5ERVJTQ09SRTtcbmV4cG9ydHMuQk9MRF9TVEFSID0gQk9MRF9TVEFSO1xuZXhwb3J0cy5CT0xEX1VOREVSU0NPUkUgPSBCT0xEX1VOREVSU0NPUkU7XG5leHBvcnRzLkNIRUNLX0xJU1QgPSBDSEVDS19MSVNUO1xuZXhwb3J0cy5DT0RFID0gQ09ERTtcbmV4cG9ydHMuRUxFTUVOVF9UUkFOU0ZPUk1FUlMgPSBFTEVNRU5UX1RSQU5TRk9STUVSUztcbmV4cG9ydHMuSEVBRElORyA9IEhFQURJTkc7XG5leHBvcnRzLkhJR0hMSUdIVCA9IEhJR0hMSUdIVDtcbmV4cG9ydHMuSU5MSU5FX0NPREUgPSBJTkxJTkVfQ09ERTtcbmV4cG9ydHMuSVRBTElDX1NUQVIgPSBJVEFMSUNfU1RBUjtcbmV4cG9ydHMuSVRBTElDX1VOREVSU0NPUkUgPSBJVEFMSUNfVU5ERVJTQ09SRTtcbmV4cG9ydHMuTElOSyA9IExJTks7XG5leHBvcnRzLk9SREVSRURfTElTVCA9IE9SREVSRURfTElTVDtcbmV4cG9ydHMuUVVPVEUgPSBRVU9URTtcbmV4cG9ydHMuU1RSSUtFVEhST1VHSCA9IFNUUklLRVRIUk9VR0g7XG5leHBvcnRzLlRFWFRfRk9STUFUX1RSQU5TRk9STUVSUyA9IFRFWFRfRk9STUFUX1RSQU5TRk9STUVSUztcbmV4cG9ydHMuVEVYVF9NQVRDSF9UUkFOU0ZPUk1FUlMgPSBURVhUX01BVENIX1RSQU5TRk9STUVSUztcbmV4cG9ydHMuVFJBTlNGT1JNRVJTID0gVFJBTlNGT1JNRVJTO1xuZXhwb3J0cy5VTk9SREVSRURfTElTVCA9IFVOT1JERVJFRF9MSVNUO1xuZXhwb3J0cy5yZWdpc3Rlck1hcmtkb3duU2hvcnRjdXRzID0gcmVnaXN0ZXJNYXJrZG93blNob3J0Y3V0cztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/markdown/LexicalMarkdown.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/markdown/LexicalMarkdown.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lexical/markdown/LexicalMarkdown.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalMarkdown =  true ? __webpack_require__(/*! ./LexicalMarkdown.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/markdown/LexicalMarkdown.dev.js\") : 0\nmodule.exports = LexicalMarkdown;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9tYXJrZG93bi9MZXhpY2FsTWFya2Rvd24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWix3QkFBd0IsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLDZHQUEwQixJQUFJLENBQW9DO0FBQzNJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9tYXJrZG93bi9MZXhpY2FsTWFya2Rvd24uanM/ZGMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbE1hcmtkb3duID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxNYXJrZG93bi5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbE1hcmtkb3duLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsTWFya2Rvd247Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/markdown/LexicalMarkdown.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction AutoFocusPlugin({\n  defaultSelection\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    editor.focus(() => {\n      // If we try and move selection to the same point with setBaseAndExtent, it won't\n      // trigger a re-focus on the element. So in the case this occurs, we'll need to correct it.\n      // Normally this is fine, Selection API !== Focus API, but fore the intents of the naming\n      // of this plugin, which should preserve focus too.\n      const activeElement = document.activeElement;\n      const rootElement = editor.getRootElement();\n\n      if (rootElement !== null && (activeElement === null || !rootElement.contains(activeElement))) {\n        // Note: preventScroll won't work in Webkit.\n        rootElement.focus({\n          preventScroll: true\n        });\n      }\n    }, {\n      defaultSelection\n    });\n  }, [defaultSelection, editor]);\n  return null;\n}\n\nexports.AutoFocusPlugin = AutoFocusPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQXV0b0ZvY3VzUGx1Z2luLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQywwSEFBdUM7QUFDNUUsWUFBWSxtQkFBTyxDQUFDLG1GQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEF1dG9Gb2N1c1BsdWdpbi5kZXYuanM/NzgwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBBdXRvRm9jdXNQbHVnaW4oe1xuICBkZWZhdWx0U2VsZWN0aW9uXG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIHJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZWRpdG9yLmZvY3VzKCgpID0+IHtcbiAgICAgIC8vIElmIHdlIHRyeSBhbmQgbW92ZSBzZWxlY3Rpb24gdG8gdGhlIHNhbWUgcG9pbnQgd2l0aCBzZXRCYXNlQW5kRXh0ZW50LCBpdCB3b24ndFxuICAgICAgLy8gdHJpZ2dlciBhIHJlLWZvY3VzIG9uIHRoZSBlbGVtZW50LiBTbyBpbiB0aGUgY2FzZSB0aGlzIG9jY3Vycywgd2UnbGwgbmVlZCB0byBjb3JyZWN0IGl0LlxuICAgICAgLy8gTm9ybWFsbHkgdGhpcyBpcyBmaW5lLCBTZWxlY3Rpb24gQVBJICE9PSBGb2N1cyBBUEksIGJ1dCBmb3JlIHRoZSBpbnRlbnRzIG9mIHRoZSBuYW1pbmdcbiAgICAgIC8vIG9mIHRoaXMgcGx1Z2luLCB3aGljaCBzaG91bGQgcHJlc2VydmUgZm9jdXMgdG9vLlxuICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuXG4gICAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwgJiYgKGFjdGl2ZUVsZW1lbnQgPT09IG51bGwgfHwgIXJvb3RFbGVtZW50LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSkge1xuICAgICAgICAvLyBOb3RlOiBwcmV2ZW50U2Nyb2xsIHdvbid0IHdvcmsgaW4gV2Via2l0LlxuICAgICAgICByb290RWxlbWVudC5mb2N1cyh7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBkZWZhdWx0U2VsZWN0aW9uXG4gICAgfSk7XG4gIH0sIFtkZWZhdWx0U2VsZWN0aW9uLCBlZGl0b3JdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydHMuQXV0b0ZvY3VzUGx1Z2luID0gQXV0b0ZvY3VzUGx1Z2luO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalAutoFocusPlugin.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalAutoFocusPlugin =  true ? __webpack_require__(/*! ./LexicalAutoFocusPlugin.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js\") : 0\nmodule.exports = LexicalAutoFocusPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQXV0b0ZvY3VzUGx1Z2luLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osK0JBQStCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyx3SEFBaUMsSUFBSSxDQUEyQztBQUNoSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEF1dG9Gb2N1c1BsdWdpbi5qcz85ZGUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsQXV0b0ZvY3VzUGx1Z2luID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxBdXRvRm9jdXNQbHVnaW4uZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxBdXRvRm9jdXNQbHVnaW4ucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxBdXRvRm9jdXNQbHVnaW47Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalComposer.dev.js":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposer.dev.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\nvar React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst HISTORY_MERGE_OPTIONS = {\n  tag: 'history-merge'\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = React.useMemo(() => {\n    const {\n      theme,\n      namespace,\n      editor__DEPRECATED: initialEditor,\n      nodes,\n      onError,\n      editorState: initialEditorState\n    } = initialConfig;\n    const context = LexicalComposerContext.createLexicalComposerContext(null, theme);\n    let editor = initialEditor || null;\n\n    if (editor === null) {\n      const newEditor = lexical.createEditor({\n        editable: initialConfig.editable,\n        namespace,\n        nodes,\n        onError: error => onError(error, newEditor),\n        theme\n      });\n      initializeEditor(newEditor, initialEditorState);\n      editor = newEditor;\n    }\n\n    return [editor, context];\n  }, // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffect(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true); // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/React.createElement(LexicalComposerContext.LexicalComposerContext.Provider, {\n    value: composerContext\n  }, children);\n}\n\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = lexical.$getRoot();\n\n      if (root.isEmpty()) {\n        const paragraph = lexical.$createParagraphNode();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n\n        if (lexical.$getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n\n      case 'function':\n        {\n          editor.update(() => {\n            const root = lexical.$getRoot();\n\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\n\nexports.LexicalComposer = LexicalComposer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXIuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLDBIQUF1QztBQUM1RSxjQUFjLG1CQUFPLENBQUMsc0VBQVM7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLG1GQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3Nlci5kZXYuanM/N2ExNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgdXNlTGF5b3V0RWZmZWN0SW1wbCA9IENBTl9VU0VfRE9NID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xudmFyIHVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdEltcGw7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IEhJU1RPUllfTUVSR0VfT1BUSU9OUyA9IHtcbiAgdGFnOiAnaGlzdG9yeS1tZXJnZSdcbn07XG5mdW5jdGlvbiBMZXhpY2FsQ29tcG9zZXIoe1xuICBpbml0aWFsQ29uZmlnLFxuICBjaGlsZHJlblxufSkge1xuICBjb25zdCBjb21wb3NlckNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB0aGVtZSxcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIGVkaXRvcl9fREVQUkVDQVRFRDogaW5pdGlhbEVkaXRvcixcbiAgICAgIG5vZGVzLFxuICAgICAgb25FcnJvcixcbiAgICAgIGVkaXRvclN0YXRlOiBpbml0aWFsRWRpdG9yU3RhdGVcbiAgICB9ID0gaW5pdGlhbENvbmZpZztcbiAgICBjb25zdCBjb250ZXh0ID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC5jcmVhdGVMZXhpY2FsQ29tcG9zZXJDb250ZXh0KG51bGwsIHRoZW1lKTtcbiAgICBsZXQgZWRpdG9yID0gaW5pdGlhbEVkaXRvciB8fCBudWxsO1xuXG4gICAgaWYgKGVkaXRvciA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgbmV3RWRpdG9yID0gbGV4aWNhbC5jcmVhdGVFZGl0b3Ioe1xuICAgICAgICBlZGl0YWJsZTogaW5pdGlhbENvbmZpZy5lZGl0YWJsZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBub2RlcyxcbiAgICAgICAgb25FcnJvcjogZXJyb3IgPT4gb25FcnJvcihlcnJvciwgbmV3RWRpdG9yKSxcbiAgICAgICAgdGhlbWVcbiAgICAgIH0pO1xuICAgICAgaW5pdGlhbGl6ZUVkaXRvcihuZXdFZGl0b3IsIGluaXRpYWxFZGl0b3JTdGF0ZSk7XG4gICAgICBlZGl0b3IgPSBuZXdFZGl0b3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtlZGl0b3IsIGNvbnRleHRdO1xuICB9LCAvLyBXZSBvbmx5IGRvIHRoaXMgZm9yIGluaXRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbXSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaXNFZGl0YWJsZSA9IGluaXRpYWxDb25maWcuZWRpdGFibGU7XG4gICAgY29uc3QgW2VkaXRvcl0gPSBjb21wb3NlckNvbnRleHQ7XG4gICAgZWRpdG9yLnNldEVkaXRhYmxlKGlzRWRpdGFibGUgIT09IHVuZGVmaW5lZCA/IGlzRWRpdGFibGUgOiB0cnVlKTsgLy8gV2Ugb25seSBkbyB0aGlzIGZvciBpbml0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMZXhpY2FsQ29tcG9zZXJDb250ZXh0LkxleGljYWxDb21wb3NlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29tcG9zZXJDb250ZXh0XG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUVkaXRvcihlZGl0b3IsIGluaXRpYWxFZGl0b3JTdGF0ZSkge1xuICBpZiAoaW5pdGlhbEVkaXRvclN0YXRlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGluaXRpYWxFZGl0b3JTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCByb290ID0gbGV4aWNhbC4kZ2V0Um9vdCgpO1xuXG4gICAgICBpZiAocm9vdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICByb290LmFwcGVuZChwYXJhZ3JhcGgpO1xuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gQ0FOX1VTRV9ET00gPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IDogbnVsbDtcblxuICAgICAgICBpZiAobGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCkgIT09IG51bGwgfHwgYWN0aXZlRWxlbWVudCAhPT0gbnVsbCAmJiBhY3RpdmVFbGVtZW50ID09PSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKSkge1xuICAgICAgICAgIHBhcmFncmFwaC5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIEhJU1RPUllfTUVSR0VfT1BUSU9OUyk7XG4gIH0gZWxzZSBpZiAoaW5pdGlhbEVkaXRvclN0YXRlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgaW5pdGlhbEVkaXRvclN0YXRlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkRWRpdG9yU3RhdGUgPSBlZGl0b3IucGFyc2VFZGl0b3JTdGF0ZShpbml0aWFsRWRpdG9yU3RhdGUpO1xuICAgICAgICAgIGVkaXRvci5zZXRFZGl0b3JTdGF0ZShwYXJzZWRFZGl0b3JTdGF0ZSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICB7XG4gICAgICAgICAgZWRpdG9yLnNldEVkaXRvclN0YXRlKGluaXRpYWxFZGl0b3JTdGF0ZSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBsZXhpY2FsLiRnZXRSb290KCk7XG5cbiAgICAgICAgICAgIGlmIChyb290LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICBpbml0aWFsRWRpdG9yU3RhdGUoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBISVNUT1JZX01FUkdFX09QVElPTlMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuTGV4aWNhbENvbXBvc2VyID0gTGV4aWNhbENvbXBvc2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalComposer.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalComposer.js":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposer.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalComposer =  true ? __webpack_require__(/*! ./LexicalComposer.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposer.dev.js\") : 0\nmodule.exports = LexicalComposer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWix3QkFBd0IsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLDBHQUEwQixJQUFJLENBQW9DO0FBQzNJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXIuanM/ODIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbENvbXBvc2VyID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxDb21wb3Nlci5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbENvbXBvc2VyLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsQ29tcG9zZXI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalComposer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposerContext.dev.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst LexicalComposerContext = /*#__PURE__*/react.createContext(null);\nfunction createLexicalComposerContext(parent, theme) {\n  let parentContext = null;\n\n  if (parent != null) {\n    parentContext = parent[1];\n  }\n\n  function getTheme() {\n    if (theme != null) {\n      return theme;\n    }\n\n    return parentContext != null ? parentContext.getTheme() : null;\n  }\n\n  return {\n    getTheme\n  };\n}\nfunction useLexicalComposerContext() {\n  const composerContext = react.useContext(LexicalComposerContext);\n\n  if (composerContext == null) {\n    {\n      throw Error(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);\n    }\n  }\n\n  return composerContext;\n}\n\nexports.LexicalComposerContext = LexicalComposerContext;\nexports.createLexicalComposerContext = createLexicalComposerContext;\nexports.useLexicalComposerContext = useLexicalComposerContext;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0LmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsbUZBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLG9DQUFvQztBQUNwQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQuZGV2LmpzPzA2NjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IExleGljYWxDb21wb3NlckNvbnRleHQgPSAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIGNyZWF0ZUxleGljYWxDb21wb3NlckNvbnRleHQocGFyZW50LCB0aGVtZSkge1xuICBsZXQgcGFyZW50Q29udGV4dCA9IG51bGw7XG5cbiAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgcGFyZW50Q29udGV4dCA9IHBhcmVudFsxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRoZW1lKCkge1xuICAgIGlmICh0aGVtZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhlbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQgIT0gbnVsbCA/IHBhcmVudENvbnRleHQuZ2V0VGhlbWUoKSA6IG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldFRoZW1lXG4gIH07XG59XG5mdW5jdGlvbiB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCkge1xuICBjb25zdCBjb21wb3NlckNvbnRleHQgPSByZWFjdC51c2VDb250ZXh0KExleGljYWxDb21wb3NlckNvbnRleHQpO1xuXG4gIGlmIChjb21wb3NlckNvbnRleHQgPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQ6IGNhbm5vdCBmaW5kIGEgTGV4aWNhbENvbXBvc2VyQ29udGV4dGApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb21wb3NlckNvbnRleHQ7XG59XG5cbmV4cG9ydHMuTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IExleGljYWxDb21wb3NlckNvbnRleHQ7XG5leHBvcnRzLmNyZWF0ZUxleGljYWxDb21wb3NlckNvbnRleHQgPSBjcmVhdGVMZXhpY2FsQ29tcG9zZXJDb250ZXh0O1xuZXhwb3J0cy51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposerContext.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalComposerContext =  true ? __webpack_require__(/*! ./LexicalComposerContext.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.dev.js\") : 0\nmodule.exports = LexicalComposerContext;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osK0JBQStCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyx3SEFBaUMsSUFBSSxDQUEyQztBQUNoSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dC5qcz81ZGRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxDb21wb3NlckNvbnRleHQuZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxDb21wb3NlckNvbnRleHQucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxDb21wb3NlckNvbnRleHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalContentEditable.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalContentEditable.dev.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\nfunction ContentEditable({\n  ariaActiveDescendant,\n  ariaAutoComplete,\n  ariaControls,\n  ariaDescribedBy,\n  ariaExpanded,\n  ariaLabel,\n  ariaLabelledBy,\n  ariaMultiline,\n  ariaOwns,\n  ariaRequired,\n  autoCapitalize,\n  className,\n  id,\n  role = 'textbox',\n  spellCheck = true,\n  style,\n  tabIndex,\n  'data-testid': testid,\n  ...rest\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isEditable, setEditable] = React.useState(false);\n  const ref = React.useCallback(rootElement => {\n    editor.setRootElement(rootElement);\n  }, [editor]);\n  useLayoutEffect(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({}, rest, {\n    \"aria-activedescendant\": !isEditable ? undefined : ariaActiveDescendant,\n    \"aria-autocomplete\": !isEditable ? 'none' : ariaAutoComplete,\n    \"aria-controls\": !isEditable ? undefined : ariaControls,\n    \"aria-describedby\": ariaDescribedBy,\n    \"aria-expanded\": !isEditable ? undefined : role === 'combobox' ? !!ariaExpanded : undefined,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-multiline\": ariaMultiline,\n    \"aria-owns\": !isEditable ? undefined : ariaOwns,\n    \"aria-readonly\": !isEditable ? true : undefined,\n    \"aria-required\": ariaRequired,\n    autoCapitalize: autoCapitalize,\n    className: className,\n    contentEditable: isEditable,\n    \"data-testid\": testid,\n    id: id,\n    ref: ref,\n    role: role,\n    spellCheck: spellCheck,\n    style: style,\n    tabIndex: tabIndex\n  }));\n}\n\nexports.ContentEditable = ContentEditable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29udGVudEVkaXRhYmxlLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQywwSEFBdUM7QUFDNUUsWUFBWSxtQkFBTyxDQUFDLG1GQUFPOztBQUUzQjtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSx1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb250ZW50RWRpdGFibGUuZGV2LmpzPzNkZTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IHVzZUxheW91dEVmZmVjdEltcGwgPSBDQU5fVVNFX0RPTSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbnZhciB1c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3RJbXBsO1xuXG5mdW5jdGlvbiBDb250ZW50RWRpdGFibGUoe1xuICBhcmlhQWN0aXZlRGVzY2VuZGFudCxcbiAgYXJpYUF1dG9Db21wbGV0ZSxcbiAgYXJpYUNvbnRyb2xzLFxuICBhcmlhRGVzY3JpYmVkQnksXG4gIGFyaWFFeHBhbmRlZCxcbiAgYXJpYUxhYmVsLFxuICBhcmlhTGFiZWxsZWRCeSxcbiAgYXJpYU11bHRpbGluZSxcbiAgYXJpYU93bnMsXG4gIGFyaWFSZXF1aXJlZCxcbiAgYXV0b0NhcGl0YWxpemUsXG4gIGNsYXNzTmFtZSxcbiAgaWQsXG4gIHJvbGUgPSAndGV4dGJveCcsXG4gIHNwZWxsQ2hlY2sgPSB0cnVlLFxuICBzdHlsZSxcbiAgdGFiSW5kZXgsXG4gICdkYXRhLXRlc3RpZCc6IHRlc3RpZCxcbiAgLi4ucmVzdFxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICBjb25zdCBbaXNFZGl0YWJsZSwgc2V0RWRpdGFibGVdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VDYWxsYmFjayhyb290RWxlbWVudCA9PiB7XG4gICAgZWRpdG9yLnNldFJvb3RFbGVtZW50KHJvb3RFbGVtZW50KTtcbiAgfSwgW2VkaXRvcl0pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHNldEVkaXRhYmxlKGVkaXRvci5pc0VkaXRhYmxlKCkpO1xuICAgIHJldHVybiBlZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKGN1cnJlbnRJc0VkaXRhYmxlID0+IHtcbiAgICAgIHNldEVkaXRhYmxlKGN1cnJlbnRJc0VkaXRhYmxlKTtcbiAgICB9KTtcbiAgfSwgW2VkaXRvcl0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiAhaXNFZGl0YWJsZSA/IHVuZGVmaW5lZCA6IGFyaWFBY3RpdmVEZXNjZW5kYW50LFxuICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogIWlzRWRpdGFibGUgPyAnbm9uZScgOiBhcmlhQXV0b0NvbXBsZXRlLFxuICAgIFwiYXJpYS1jb250cm9sc1wiOiAhaXNFZGl0YWJsZSA/IHVuZGVmaW5lZCA6IGFyaWFDb250cm9scyxcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZEJ5LFxuICAgIFwiYXJpYS1leHBhbmRlZFwiOiAhaXNFZGl0YWJsZSA/IHVuZGVmaW5lZCA6IHJvbGUgPT09ICdjb21ib2JveCcgPyAhIWFyaWFFeHBhbmRlZCA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsLFxuICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFyaWFMYWJlbGxlZEJ5LFxuICAgIFwiYXJpYS1tdWx0aWxpbmVcIjogYXJpYU11bHRpbGluZSxcbiAgICBcImFyaWEtb3duc1wiOiAhaXNFZGl0YWJsZSA/IHVuZGVmaW5lZCA6IGFyaWFPd25zLFxuICAgIFwiYXJpYS1yZWFkb25seVwiOiAhaXNFZGl0YWJsZSA/IHRydWUgOiB1bmRlZmluZWQsXG4gICAgXCJhcmlhLXJlcXVpcmVkXCI6IGFyaWFSZXF1aXJlZCxcbiAgICBhdXRvQ2FwaXRhbGl6ZTogYXV0b0NhcGl0YWxpemUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgY29udGVudEVkaXRhYmxlOiBpc0VkaXRhYmxlLFxuICAgIFwiZGF0YS10ZXN0aWRcIjogdGVzdGlkLFxuICAgIGlkOiBpZCxcbiAgICByZWY6IHJlZixcbiAgICByb2xlOiByb2xlLFxuICAgIHNwZWxsQ2hlY2s6IHNwZWxsQ2hlY2ssXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIHRhYkluZGV4OiB0YWJJbmRleFxuICB9KSk7XG59XG5cbmV4cG9ydHMuQ29udGVudEVkaXRhYmxlID0gQ29udGVudEVkaXRhYmxlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalContentEditable.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalContentEditable.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalContentEditable.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalContentEditable =  true ? __webpack_require__(/*! ./LexicalContentEditable.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalContentEditable.dev.js\") : 0\nmodule.exports = LexicalContentEditable;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29udGVudEVkaXRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osK0JBQStCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyx3SEFBaUMsSUFBSSxDQUEyQztBQUNoSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5qcz85NjA3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsQ29udGVudEVkaXRhYmxlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxDb250ZW50RWRpdGFibGUuZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxDb250ZW50RWRpdGFibGUucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxDb250ZW50RWRpdGFibGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalContentEditable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalErrorBoundary.dev.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n\nvar changedArray = function changedArray(a, b) {\n  if (a === void 0) {\n    a = [];\n  }\n\n  if (b === void 0) {\n    b = [];\n  }\n\n  return a.length !== b.length || a.some(function (item, index) {\n    return !Object.is(item, b[index]);\n  });\n};\n\nvar initialState = {\n  error: null\n};\n\nvar ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n    _this.state = initialState;\n\n    _this.resetErrorBoundary = function () {\n      var _this$props;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n      _this.reset();\n    };\n\n    return _this;\n  }\n\n  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  };\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.reset = function reset() {\n    this.setState(initialState);\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n\n    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var error = this.state.error;\n    var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n    // happens to *also* be in the resetKeys array, we'd end up resetting\n    // the error boundary immediately. This would likely trigger a second\n    // error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call\n    // of cDU after the error is set\n\n    if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onResetKe, _this$props3;\n\n      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n      this.reset();\n    }\n  };\n\n  _proto.render = function render() {\n    var error = this.state.error;\n    var _this$props4 = this.props,\n        fallbackRender = _this$props4.fallbackRender,\n        FallbackComponent = _this$props4.FallbackComponent,\n        fallback = _this$props4.fallback;\n\n    if (error !== null) {\n      var _props = {\n        error: error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n\n      if ( /*#__PURE__*/React.isValidElement(fallback)) {\n        return fallback;\n      } else if (typeof fallbackRender === 'function') {\n        return fallbackRender(_props);\n      } else if (FallbackComponent) {\n        return /*#__PURE__*/React.createElement(FallbackComponent, _props);\n      } else {\n        throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n      }\n    }\n\n    return this.props.children;\n  };\n\n  return ErrorBoundary;\n}(React.Component);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction LexicalErrorBoundary({\n  children,\n  onError\n}) {\n  return /*#__PURE__*/React.createElement(ErrorBoundary, {\n    fallback: /*#__PURE__*/React.createElement(\"div\", {\n      style: {\n        border: '1px solid #f00',\n        color: '#f00',\n        padding: '8px'\n      }\n    }, \"An error was thrown.\"),\n    onError: onError\n  }, children);\n}\n\nmodule.exports = LexicalErrorBoundary;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsRXJyb3JCb3VuZGFyeS5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLG1GQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUVBQXlFLGFBQWE7QUFDdEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkVBQTZFLGVBQWU7QUFDNUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsRXJyb3JCb3VuZGFyeS5kZXYuanM/OWExOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbnZhciBjaGFuZ2VkQXJyYXkgPSBmdW5jdGlvbiBjaGFuZ2VkQXJyYXkoYSwgYikge1xuICBpZiAoYSA9PT0gdm9pZCAwKSB7XG4gICAgYSA9IFtdO1xuICB9XG5cbiAgaWYgKGIgPT09IHZvaWQgMCkge1xuICAgIGIgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBhLmxlbmd0aCAhPT0gYi5sZW5ndGggfHwgYS5zb21lKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiAhT2JqZWN0LmlzKGl0ZW0sIGJbaW5kZXhdKTtcbiAgfSk7XG59O1xuXG52YXIgaW5pdGlhbFN0YXRlID0ge1xuICBlcnJvcjogbnVsbFxufTtcblxudmFyIEVycm9yQm91bmRhcnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoRXJyb3JCb3VuZGFyeSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRXJyb3JCb3VuZGFyeSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgX2FyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBfYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KF9hcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcblxuICAgIF90aGlzLnJlc2V0RXJyb3JCb3VuZGFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcztcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMucHJvcHMub25SZXNldCA9PSBudWxsID8gdm9pZCAwIDogKF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMpLm9uUmVzZXQuYXBwbHkoX3RoaXMkcHJvcHMsIGFyZ3MpO1xuXG4gICAgICBfdGhpcy5yZXNldCgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBFcnJvckJvdW5kYXJ5LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogZXJyb3JcbiAgICB9O1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBFcnJvckJvdW5kYXJ5LnByb3RvdHlwZTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLnNldFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGluZm8pIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMkb25FcnJvciwgX3RoaXMkcHJvcHMyO1xuXG4gICAgKF90aGlzJHByb3BzJG9uRXJyb3IgPSAoX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcykub25FcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHByb3BzJG9uRXJyb3IuY2FsbChfdGhpcyRwcm9wczIsIGVycm9yLCBpbmZvKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICB2YXIgcmVzZXRLZXlzID0gdGhpcy5wcm9wcy5yZXNldEtleXM7IC8vIFRoZXJlJ3MgYW4gZWRnZSBjYXNlIHdoZXJlIGlmIHRoZSB0aGluZyB0aGF0IHRyaWdnZXJlZCB0aGUgZXJyb3JcbiAgICAvLyBoYXBwZW5zIHRvICphbHNvKiBiZSBpbiB0aGUgcmVzZXRLZXlzIGFycmF5LCB3ZSdkIGVuZCB1cCByZXNldHRpbmdcbiAgICAvLyB0aGUgZXJyb3IgYm91bmRhcnkgaW1tZWRpYXRlbHkuIFRoaXMgd291bGQgbGlrZWx5IHRyaWdnZXIgYSBzZWNvbmRcbiAgICAvLyBlcnJvciB0byBiZSB0aHJvd24uXG4gICAgLy8gU28gd2UgbWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgY2hlY2sgdGhlIHJlc2V0S2V5cyBvbiB0aGUgZmlyc3QgY2FsbFxuICAgIC8vIG9mIGNEVSBhZnRlciB0aGUgZXJyb3IgaXMgc2V0XG5cbiAgICBpZiAoZXJyb3IgIT09IG51bGwgJiYgcHJldlN0YXRlLmVycm9yICE9PSBudWxsICYmIGNoYW5nZWRBcnJheShwcmV2UHJvcHMucmVzZXRLZXlzLCByZXNldEtleXMpKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMkb25SZXNldEtlLCBfdGhpcyRwcm9wczM7XG5cbiAgICAgIChfdGhpcyRwcm9wcyRvblJlc2V0S2UgPSAoX3RoaXMkcHJvcHMzID0gdGhpcy5wcm9wcykub25SZXNldEtleXNDaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwcm9wcyRvblJlc2V0S2UuY2FsbChfdGhpcyRwcm9wczMsIHByZXZQcm9wcy5yZXNldEtleXMsIHJlc2V0S2V5cyk7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIGVycm9yID0gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgICB2YXIgX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcyxcbiAgICAgICAgZmFsbGJhY2tSZW5kZXIgPSBfdGhpcyRwcm9wczQuZmFsbGJhY2tSZW5kZXIsXG4gICAgICAgIEZhbGxiYWNrQ29tcG9uZW50ID0gX3RoaXMkcHJvcHM0LkZhbGxiYWNrQ29tcG9uZW50LFxuICAgICAgICBmYWxsYmFjayA9IF90aGlzJHByb3BzNC5mYWxsYmFjaztcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9wcm9wcyA9IHtcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICByZXNldEVycm9yQm91bmRhcnk6IHRoaXMucmVzZXRFcnJvckJvdW5kYXJ5XG4gICAgICB9O1xuXG4gICAgICBpZiAoIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChmYWxsYmFjaykpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmFsbGJhY2tSZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUmVuZGVyKF9wcm9wcyk7XG4gICAgICB9IGVsc2UgaWYgKEZhbGxiYWNrQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGYWxsYmFja0NvbXBvbmVudCwgX3Byb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVhY3QtZXJyb3ItYm91bmRhcnkgcmVxdWlyZXMgZWl0aGVyIGEgZmFsbGJhY2ssIGZhbGxiYWNrUmVuZGVyLCBvciBGYWxsYmFja0NvbXBvbmVudCBwcm9wJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH07XG5cbiAgcmV0dXJuIEVycm9yQm91bmRhcnk7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIExleGljYWxFcnJvckJvdW5kYXJ5KHtcbiAgY2hpbGRyZW4sXG4gIG9uRXJyb3Jcbn0pIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIHtcbiAgICBmYWxsYmFjazogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICNmMDAnLFxuICAgICAgICBjb2xvcjogJyNmMDAnLFxuICAgICAgICBwYWRkaW5nOiAnOHB4J1xuICAgICAgfVxuICAgIH0sIFwiQW4gZXJyb3Igd2FzIHRocm93bi5cIiksXG4gICAgb25FcnJvcjogb25FcnJvclxuICB9LCBjaGlsZHJlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbEVycm9yQm91bmRhcnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalErrorBoundary.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalErrorBoundary.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalErrorBoundary =  true ? __webpack_require__(/*! ./LexicalErrorBoundary.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.js\") : 0\nmodule.exports = LexicalErrorBoundary;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsRXJyb3JCb3VuZGFyeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLDZCQUE2QixLQUFzQyxHQUFHLG1CQUFPLENBQUMsb0hBQStCLElBQUksQ0FBeUM7QUFDMUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxFcnJvckJvdW5kYXJ5LmpzP2VmZDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxFcnJvckJvdW5kYXJ5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxFcnJvckJvdW5kYXJ5LmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsRXJyb3JCb3VuZGFyeS5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbEVycm9yQm91bmRhcnk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalErrorBoundary.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar history = __webpack_require__(/*! @lexical/history */ \"(app-pages-browser)/./node_modules/@lexical/history/LexicalHistory.js\");\nvar react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useHistory(editor, externalHistoryState, delay = 1000) {\n  const historyState = react.useMemo(() => externalHistoryState || history.createEmptyHistoryState(), [externalHistoryState]);\n  react.useEffect(() => {\n    return history.registerHistory(editor, historyState, delay);\n  }, [delay, editor, historyState]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction HistoryPlugin({\n  externalHistoryState\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useHistory(editor, externalHistoryState);\n  return null;\n}\n\nexports.createEmptyHistoryState = history.createEmptyHistoryState;\nexports.HistoryPlugin = HistoryPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsSGlzdG9yeVBsdWdpbi5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsMEhBQXVDO0FBQzVFLGNBQWMsbUJBQU8sQ0FBQywrRkFBa0I7QUFDeEMsWUFBWSxtQkFBTyxDQUFDLG1GQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0IscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsSGlzdG9yeVBsdWdpbi5kZXYuanM/M2Q4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgaGlzdG9yeSA9IHJlcXVpcmUoJ0BsZXhpY2FsL2hpc3RvcnknKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIHVzZUhpc3RvcnkoZWRpdG9yLCBleHRlcm5hbEhpc3RvcnlTdGF0ZSwgZGVsYXkgPSAxMDAwKSB7XG4gIGNvbnN0IGhpc3RvcnlTdGF0ZSA9IHJlYWN0LnVzZU1lbW8oKCkgPT4gZXh0ZXJuYWxIaXN0b3J5U3RhdGUgfHwgaGlzdG9yeS5jcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSgpLCBbZXh0ZXJuYWxIaXN0b3J5U3RhdGVdKTtcbiAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gaGlzdG9yeS5yZWdpc3Rlckhpc3RvcnkoZWRpdG9yLCBoaXN0b3J5U3RhdGUsIGRlbGF5KTtcbiAgfSwgW2RlbGF5LCBlZGl0b3IsIGhpc3RvcnlTdGF0ZV0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBIaXN0b3J5UGx1Z2luKHtcbiAgZXh0ZXJuYWxIaXN0b3J5U3RhdGVcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgdXNlSGlzdG9yeShlZGl0b3IsIGV4dGVybmFsSGlzdG9yeVN0YXRlKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydHMuY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUgPSBoaXN0b3J5LmNyZWF0ZUVtcHR5SGlzdG9yeVN0YXRlO1xuZXhwb3J0cy5IaXN0b3J5UGx1Z2luID0gSGlzdG9yeVBsdWdpbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalHistoryPlugin.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHistoryPlugin.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHistoryPlugin =  true ? __webpack_require__(/*! ./LexicalHistoryPlugin.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js\") : 0\nmodule.exports = LexicalHistoryPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsSGlzdG9yeVBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLDZCQUE2QixLQUFzQyxHQUFHLG1CQUFPLENBQUMsb0hBQStCLElBQUksQ0FBeUM7QUFDMUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxIaXN0b3J5UGx1Z2luLmpzPzkzZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxIaXN0b3J5UGx1Z2luID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxIaXN0b3J5UGx1Z2luLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsSGlzdG9yeVBsdWdpbi5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbEhpc3RvcnlQbHVnaW47Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalHistoryPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar useLexicalNodeSelection = __webpack_require__(/*! @lexical/react/useLexicalNodeSelection */ \"(app-pages-browser)/./node_modules/@lexical/react/useLexicalNodeSelection.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\nvar React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst INSERT_HORIZONTAL_RULE_COMMAND = lexical.createCommand('INSERT_HORIZONTAL_RULE_COMMAND');\n\nfunction HorizontalRuleComponent({\n  nodeKey\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection.useLexicalNodeSelection(nodeKey);\n  const onDelete = React.useCallback(event => {\n    if (isSelected && lexical.$isNodeSelection(lexical.$getSelection())) {\n      event.preventDefault();\n      const node = lexical.$getNodeByKey(nodeKey);\n\n      if ($isHorizontalRuleNode(node)) {\n        node.remove();\n      }\n    }\n\n    return false;\n  }, [isSelected, nodeKey]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, event => {\n      const hrElem = editor.getElementByKey(nodeKey);\n\n      if (event.target === hrElem) {\n        if (!event.shiftKey) {\n          clearSelection();\n        }\n\n        setSelected(!isSelected);\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_DELETE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW));\n  }, [clearSelection, editor, isSelected, nodeKey, onDelete, setSelected]);\n  React.useEffect(() => {\n    const hrElem = editor.getElementByKey(nodeKey);\n\n    if (hrElem !== null) {\n      hrElem.className = isSelected ? 'selected' : '';\n    }\n  }, [editor, isSelected, nodeKey]);\n  return null;\n}\n\nclass HorizontalRuleNode extends lexical.DecoratorNode {\n  static getType() {\n    return 'horizontalrule';\n  }\n\n  static clone(node) {\n    return new HorizontalRuleNode(node.__key);\n  }\n\n  static importJSON(serializedNode) {\n    return $createHorizontalRuleNode();\n  }\n\n  static importDOM() {\n    return {\n      hr: () => ({\n        conversion: convertHorizontalRuleElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportJSON() {\n    return {\n      type: 'horizontalrule',\n      version: 1\n    };\n  }\n\n  exportDOM() {\n    return {\n      element: document.createElement('hr')\n    };\n  }\n\n  createDOM() {\n    return document.createElement('hr');\n  }\n\n  getTextContent() {\n    return '\\n';\n  }\n\n  isInline() {\n    return false;\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  decorate() {\n    return /*#__PURE__*/React.createElement(HorizontalRuleComponent, {\n      nodeKey: this.__key\n    });\n  }\n\n}\n\nfunction convertHorizontalRuleElement() {\n  return {\n    node: $createHorizontalRuleNode()\n  };\n}\n\nfunction $createHorizontalRuleNode() {\n  return lexical.$applyNodeReplacement(new HorizontalRuleNode());\n}\nfunction $isHorizontalRuleNode(node) {\n  return node instanceof HorizontalRuleNode;\n}\n\nexports.$createHorizontalRuleNode = $createHorizontalRuleNode;\nexports.$isHorizontalRuleNode = $isHorizontalRuleNode;\nexports.HorizontalRuleNode = HorizontalRuleNode;\nexports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsSG9yaXpvbnRhbFJ1bGVOb2RlLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQywwSEFBdUM7QUFDNUUsOEJBQThCLG1CQUFPLENBQUMsNEhBQXdDO0FBQzlFLFlBQVksbUJBQU8sQ0FBQyx5RkFBZ0I7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLHNFQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyxtRkFBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsSG9yaXpvbnRhbFJ1bGVOb2RlLmRldi5qcz8yYjQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciB1c2VMZXhpY2FsTm9kZVNlbGVjdGlvbiA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L3VzZUxleGljYWxOb2RlU2VsZWN0aW9uJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBJTlNFUlRfSE9SSVpPTlRBTF9SVUxFX0NPTU1BTkQgPSBsZXhpY2FsLmNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9IT1JJWk9OVEFMX1JVTEVfQ09NTUFORCcpO1xuXG5mdW5jdGlvbiBIb3Jpem9udGFsUnVsZUNvbXBvbmVudCh7XG4gIG5vZGVLZXlcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgW2lzU2VsZWN0ZWQsIHNldFNlbGVjdGVkLCBjbGVhclNlbGVjdGlvbl0gPSB1c2VMZXhpY2FsTm9kZVNlbGVjdGlvbi51c2VMZXhpY2FsTm9kZVNlbGVjdGlvbihub2RlS2V5KTtcbiAgY29uc3Qgb25EZWxldGUgPSBSZWFjdC51c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgaWYgKGlzU2VsZWN0ZWQgJiYgbGV4aWNhbC4kaXNOb2RlU2VsZWN0aW9uKGxleGljYWwuJGdldFNlbGVjdGlvbigpKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROb2RlQnlLZXkobm9kZUtleSk7XG5cbiAgICAgIGlmICgkaXNIb3Jpem9udGFsUnVsZU5vZGUobm9kZSkpIHtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIFtpc1NlbGVjdGVkLCBub2RlS2V5XSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHV0aWxzLm1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkNMSUNLX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGhyRWxlbSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkobm9kZUtleSk7XG5cbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGhyRWxlbSkge1xuICAgICAgICBpZiAoIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFNlbGVjdGVkKCFpc1NlbGVjdGVkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9ERUxFVEVfQ09NTUFORCwgb25EZWxldGUsIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCBvbkRlbGV0ZSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVykpO1xuICB9LCBbY2xlYXJTZWxlY3Rpb24sIGVkaXRvciwgaXNTZWxlY3RlZCwgbm9kZUtleSwgb25EZWxldGUsIHNldFNlbGVjdGVkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaHJFbGVtID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShub2RlS2V5KTtcblxuICAgIGlmIChockVsZW0gIT09IG51bGwpIHtcbiAgICAgIGhyRWxlbS5jbGFzc05hbWUgPSBpc1NlbGVjdGVkID8gJ3NlbGVjdGVkJyA6ICcnO1xuICAgIH1cbiAgfSwgW2VkaXRvciwgaXNTZWxlY3RlZCwgbm9kZUtleV0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuY2xhc3MgSG9yaXpvbnRhbFJ1bGVOb2RlIGV4dGVuZHMgbGV4aWNhbC5EZWNvcmF0b3JOb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdob3Jpem9udGFscnVsZSc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgSG9yaXpvbnRhbFJ1bGVOb2RlKG5vZGUuX19rZXkpO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUhvcml6b250YWxSdWxlTm9kZSgpO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaHI6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRIb3Jpem9udGFsUnVsZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnaG9yaXpvbnRhbHJ1bGUnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cblxuICBleHBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2hyJylcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlRE9NKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdocicpO1xuICB9XG5cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgcmV0dXJuICdcXG4nO1xuICB9XG5cbiAgaXNJbmxpbmUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdXBkYXRlRE9NKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGRlY29yYXRlKCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChIb3Jpem9udGFsUnVsZUNvbXBvbmVudCwge1xuICAgICAgbm9kZUtleTogdGhpcy5fX2tleVxuICAgIH0pO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gY29udmVydEhvcml6b250YWxSdWxlRWxlbWVudCgpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlSG9yaXpvbnRhbFJ1bGVOb2RlKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gJGNyZWF0ZUhvcml6b250YWxSdWxlTm9kZSgpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBIb3Jpem9udGFsUnVsZU5vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNIb3Jpem9udGFsUnVsZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEhvcml6b250YWxSdWxlTm9kZTtcbn1cblxuZXhwb3J0cy4kY3JlYXRlSG9yaXpvbnRhbFJ1bGVOb2RlID0gJGNyZWF0ZUhvcml6b250YWxSdWxlTm9kZTtcbmV4cG9ydHMuJGlzSG9yaXpvbnRhbFJ1bGVOb2RlID0gJGlzSG9yaXpvbnRhbFJ1bGVOb2RlO1xuZXhwb3J0cy5Ib3Jpem9udGFsUnVsZU5vZGUgPSBIb3Jpem9udGFsUnVsZU5vZGU7XG5leHBvcnRzLklOU0VSVF9IT1JJWk9OVEFMX1JVTEVfQ09NTUFORCA9IElOU0VSVF9IT1JJWk9OVEFMX1JVTEVfQ09NTUFORDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHorizontalRuleNode.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHorizontalRuleNode =  true ? __webpack_require__(/*! ./LexicalHorizontalRuleNode.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js\") : 0\nmodule.exports = LexicalHorizontalRuleNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsSG9yaXpvbnRhbFJ1bGVOb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osa0NBQWtDLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyw4SEFBb0MsSUFBSSxDQUE4QztBQUN6SyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZS5qcz82N2IyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsSG9yaXpvbnRhbFJ1bGVOb2RlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxIb3Jpem9udGFsUnVsZU5vZGUuZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxIb3Jpem9udGFsUnVsZU5vZGUucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxIb3Jpem9udGFsUnVsZU5vZGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalLinkPlugin.dev.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalLinkPlugin.dev.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar link = __webpack_require__(/*! @lexical/link */ \"(app-pages-browser)/./node_modules/@lexical/link/LexicalLink.js\");\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\nvar react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction LinkPlugin({\n  validateUrl\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    if (!editor.hasNodes([link.LinkNode])) {\n      throw new Error('LinkPlugin: LinkNode not registered on editor');\n    }\n\n    return utils.mergeRegister(editor.registerCommand(link.TOGGLE_LINK_COMMAND, payload => {\n      if (payload === null) {\n        link.toggleLink(payload);\n        return true;\n      } else if (typeof payload === 'string') {\n        if (validateUrl === undefined || validateUrl(payload)) {\n          link.toggleLink(payload);\n          return true;\n        }\n\n        return false;\n      } else {\n        const {\n          url,\n          target,\n          rel,\n          title\n        } = payload;\n        link.toggleLink(url, {\n          rel,\n          target,\n          title\n        });\n        return true;\n      }\n    }, lexical.COMMAND_PRIORITY_LOW), validateUrl !== undefined ? editor.registerCommand(lexical.PASTE_COMMAND, event => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.$isRangeSelection(selection) || selection.isCollapsed() || !(event instanceof ClipboardEvent) || event.clipboardData == null) {\n        return false;\n      }\n\n      const clipboardText = event.clipboardData.getData('text');\n\n      if (!validateUrl(clipboardText)) {\n        return false;\n      } // If we select nodes that are elements then avoid applying the link.\n\n\n      if (!selection.getNodes().some(node => lexical.$isElementNode(node))) {\n        editor.dispatchCommand(link.TOGGLE_LINK_COMMAND, clipboardText);\n        event.preventDefault();\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW) : () => {// Don't paste arbritrary text as a link when there's no validate function\n    });\n  }, [editor, validateUrl]);\n  return null;\n}\n\nexports.LinkPlugin = LinkPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsTGlua1BsdWdpbi5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLHNGQUFlO0FBQ2xDLDZCQUE2QixtQkFBTyxDQUFDLDBIQUF1QztBQUM1RSxZQUFZLG1CQUFPLENBQUMseUZBQWdCO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsbUZBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLHlDQUF5QztBQUM5QyxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUEsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsTGlua1BsdWdpbi5kZXYuanM/ZjljNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxpbmsgPSByZXF1aXJlKCdAbGV4aWNhbC9saW5rJyk7XG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIExpbmtQbHVnaW4oe1xuICB2YWxpZGF0ZVVybFxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICByZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZWRpdG9yLmhhc05vZGVzKFtsaW5rLkxpbmtOb2RlXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTGlua1BsdWdpbjogTGlua05vZGUgbm90IHJlZ2lzdGVyZWQgb24gZWRpdG9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0aWxzLm1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsaW5rLlRPR0dMRV9MSU5LX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgICAgaWYgKHBheWxvYWQgPT09IG51bGwpIHtcbiAgICAgICAgbGluay50b2dnbGVMaW5rKHBheWxvYWQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh2YWxpZGF0ZVVybCA9PT0gdW5kZWZpbmVkIHx8IHZhbGlkYXRlVXJsKHBheWxvYWQpKSB7XG4gICAgICAgICAgbGluay50b2dnbGVMaW5rKHBheWxvYWQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgcmVsLFxuICAgICAgICAgIHRpdGxlXG4gICAgICAgIH0gPSBwYXlsb2FkO1xuICAgICAgICBsaW5rLnRvZ2dsZUxpbmsodXJsLCB7XG4gICAgICAgICAgcmVsLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICB0aXRsZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIHZhbGlkYXRlVXJsICE9PSB1bmRlZmluZWQgPyBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuUEFTVEVfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8ICEoZXZlbnQgaW5zdGFuY2VvZiBDbGlwYm9hcmRFdmVudCkgfHwgZXZlbnQuY2xpcGJvYXJkRGF0YSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2xpcGJvYXJkVGV4dCA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dCcpO1xuXG4gICAgICBpZiAoIXZhbGlkYXRlVXJsKGNsaXBib2FyZFRleHQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gSWYgd2Ugc2VsZWN0IG5vZGVzIHRoYXQgYXJlIGVsZW1lbnRzIHRoZW4gYXZvaWQgYXBwbHlpbmcgdGhlIGxpbmsuXG5cblxuICAgICAgaWYgKCFzZWxlY3Rpb24uZ2V0Tm9kZXMoKS5zb21lKG5vZGUgPT4gbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSkpIHtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsaW5rLlRPR0dMRV9MSU5LX0NPTU1BTkQsIGNsaXBib2FyZFRleHQpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpIDogKCkgPT4gey8vIERvbid0IHBhc3RlIGFyYnJpdHJhcnkgdGV4dCBhcyBhIGxpbmsgd2hlbiB0aGVyZSdzIG5vIHZhbGlkYXRlIGZ1bmN0aW9uXG4gICAgfSk7XG4gIH0sIFtlZGl0b3IsIHZhbGlkYXRlVXJsXSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLkxpbmtQbHVnaW4gPSBMaW5rUGx1Z2luO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalLinkPlugin.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalLinkPlugin.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalLinkPlugin.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalLinkPlugin =  true ? __webpack_require__(/*! ./LexicalLinkPlugin.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalLinkPlugin.dev.js\") : 0\nmodule.exports = LexicalLinkPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsTGlua1BsdWdpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLDBCQUEwQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsOEdBQTRCLElBQUksQ0FBc0M7QUFDakoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxMaW5rUGx1Z2luLmpzP2M5N2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxMaW5rUGx1Z2luID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxMaW5rUGx1Z2luLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsTGlua1BsdWdpbi5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbExpbmtQbHVnaW47Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalLinkPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalListPlugin.dev.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalListPlugin.dev.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar list = __webpack_require__(/*! @lexical/list */ \"(app-pages-browser)/./node_modules/@lexical/list/LexicalList.js\");\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useList(editor) {\n  react.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(list.INSERT_ORDERED_LIST_COMMAND, () => {\n      list.insertList(editor, 'number');\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(list.INSERT_UNORDERED_LIST_COMMAND, () => {\n      list.insertList(editor, 'bullet');\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(list.REMOVE_LIST_COMMAND, () => {\n      list.removeList(editor);\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n      const hasHandledInsertParagraph = list.$handleListInsertParagraph();\n\n      if (hasHandledInsertParagraph) {\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW));\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction ListPlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    if (!editor.hasNodes([list.ListNode, list.ListItemNode])) {\n      throw new Error('ListPlugin: ListNode and/or ListItemNode not registered on editor');\n    }\n  }, [editor]);\n  useList(editor);\n  return null;\n}\n\nexports.ListPlugin = ListPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsTGlzdFBsdWdpbi5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLHNGQUFlO0FBQ2xDLDZCQUE2QixtQkFBTyxDQUFDLDBIQUF1QztBQUM1RSxZQUFZLG1CQUFPLENBQUMsbUZBQU87QUFDM0IsWUFBWSxtQkFBTyxDQUFDLHlGQUFnQjtBQUNwQyxjQUFjLG1CQUFPLENBQUMsc0VBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsTGlzdFBsdWdpbi5kZXYuanM/ZjI5MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxpc3QgPSByZXF1aXJlKCdAbGV4aWNhbC9saXN0Jyk7XG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIHVzZUxpc3QoZWRpdG9yKSB7XG4gIHJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHV0aWxzLm1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsaXN0LklOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCwgKCkgPT4ge1xuICAgICAgbGlzdC5pbnNlcnRMaXN0KGVkaXRvciwgJ251bWJlcicpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGlzdC5JTlNFUlRfVU5PUkRFUkVEX0xJU1RfQ09NTUFORCwgKCkgPT4ge1xuICAgICAgbGlzdC5pbnNlcnRMaXN0KGVkaXRvciwgJ2J1bGxldCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGlzdC5SRU1PVkVfTElTVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgICBsaXN0LnJlbW92ZUxpc3QoZWRpdG9yKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAoKSA9PiB7XG4gICAgICBjb25zdCBoYXNIYW5kbGVkSW5zZXJ0UGFyYWdyYXBoID0gbGlzdC4kaGFuZGxlTGlzdEluc2VydFBhcmFncmFwaCgpO1xuXG4gICAgICBpZiAoaGFzSGFuZGxlZEluc2VydFBhcmFncmFwaCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpKTtcbiAgfSwgW2VkaXRvcl0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBMaXN0UGx1Z2luKCkge1xuICBjb25zdCBbZWRpdG9yXSA9IExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICByZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZWRpdG9yLmhhc05vZGVzKFtsaXN0Lkxpc3ROb2RlLCBsaXN0Lkxpc3RJdGVtTm9kZV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpc3RQbHVnaW46IExpc3ROb2RlIGFuZC9vciBMaXN0SXRlbU5vZGUgbm90IHJlZ2lzdGVyZWQgb24gZWRpdG9yJyk7XG4gICAgfVxuICB9LCBbZWRpdG9yXSk7XG4gIHVzZUxpc3QoZWRpdG9yKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydHMuTGlzdFBsdWdpbiA9IExpc3RQbHVnaW47XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalListPlugin.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalListPlugin.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalListPlugin.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalListPlugin =  true ? __webpack_require__(/*! ./LexicalListPlugin.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalListPlugin.dev.js\") : 0\nmodule.exports = LexicalListPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsTGlzdFBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLDBCQUEwQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsOEdBQTRCLElBQUksQ0FBc0M7QUFDakoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxMaXN0UGx1Z2luLmpzP2RmODgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxMaXN0UGx1Z2luID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxMaXN0UGx1Z2luLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsTGlzdFBsdWdpbi5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbExpc3RQbHVnaW47Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalListPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar markdown = __webpack_require__(/*! @lexical/markdown */ \"(app-pages-browser)/./node_modules/@lexical/markdown/LexicalMarkdown.js\");\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar LexicalHorizontalRuleNode = __webpack_require__(/*! @lexical/react/LexicalHorizontalRuleNode */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.js\");\nvar react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst HR = {\n  dependencies: [LexicalHorizontalRuleNode.HorizontalRuleNode],\n  export: node => {\n    return LexicalHorizontalRuleNode.$isHorizontalRuleNode(node) ? '***' : null;\n  },\n  regExp: /^(---|\\*\\*\\*|___)\\s?$/,\n  replace: (parentNode, _1, _2, isImport) => {\n    const line = LexicalHorizontalRuleNode.$createHorizontalRuleNode(); // TODO: Get rid of isImport flag\n\n    if (isImport || parentNode.getNextSibling() != null) {\n      parentNode.replace(line);\n    } else {\n      parentNode.insertBefore(line);\n    }\n\n    line.selectNext();\n  },\n  type: 'element'\n};\nconst DEFAULT_TRANSFORMERS = [HR, ...markdown.TRANSFORMERS];\nfunction MarkdownShortcutPlugin({\n  transformers = DEFAULT_TRANSFORMERS\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    return markdown.registerMarkdownShortcuts(editor, transformers);\n  }, [editor, transformers]);\n  return null;\n}\n\nexports.DEFAULT_TRANSFORMERS = DEFAULT_TRANSFORMERS;\nexports.MarkdownShortcutPlugin = MarkdownShortcutPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsTWFya2Rvd25TaG9ydGN1dFBsdWdpbi5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLGtHQUFtQjtBQUMxQyw2QkFBNkIsbUJBQU8sQ0FBQywwSEFBdUM7QUFDNUUsZ0NBQWdDLG1CQUFPLENBQUMsZ0lBQTBDO0FBQ2xGLFlBQVksbUJBQU8sQ0FBQyxtRkFBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0VBQXdFOztBQUV4RTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsTWFya2Rvd25TaG9ydGN1dFBsdWdpbi5kZXYuanM/Y2Y2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIG1hcmtkb3duID0gcmVxdWlyZSgnQGxleGljYWwvbWFya2Rvd24nKTtcbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIExleGljYWxIb3Jpem9udGFsUnVsZU5vZGUgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsSG9yaXpvbnRhbFJ1bGVOb2RlJyk7XG52YXIgcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBIUiA9IHtcbiAgZGVwZW5kZW5jaWVzOiBbTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZS5Ib3Jpem9udGFsUnVsZU5vZGVdLFxuICBleHBvcnQ6IG5vZGUgPT4ge1xuICAgIHJldHVybiBMZXhpY2FsSG9yaXpvbnRhbFJ1bGVOb2RlLiRpc0hvcml6b250YWxSdWxlTm9kZShub2RlKSA/ICcqKionIDogbnVsbDtcbiAgfSxcbiAgcmVnRXhwOiAvXigtLS18XFwqXFwqXFwqfF9fXylcXHM/JC8sXG4gIHJlcGxhY2U6IChwYXJlbnROb2RlLCBfMSwgXzIsIGlzSW1wb3J0KSA9PiB7XG4gICAgY29uc3QgbGluZSA9IExleGljYWxIb3Jpem9udGFsUnVsZU5vZGUuJGNyZWF0ZUhvcml6b250YWxSdWxlTm9kZSgpOyAvLyBUT0RPOiBHZXQgcmlkIG9mIGlzSW1wb3J0IGZsYWdcblxuICAgIGlmIChpc0ltcG9ydCB8fCBwYXJlbnROb2RlLmdldE5leHRTaWJsaW5nKCkgIT0gbnVsbCkge1xuICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlKGxpbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShsaW5lKTtcbiAgICB9XG5cbiAgICBsaW5lLnNlbGVjdE5leHQoKTtcbiAgfSxcbiAgdHlwZTogJ2VsZW1lbnQnXG59O1xuY29uc3QgREVGQVVMVF9UUkFOU0ZPUk1FUlMgPSBbSFIsIC4uLm1hcmtkb3duLlRSQU5TRk9STUVSU107XG5mdW5jdGlvbiBNYXJrZG93blNob3J0Y3V0UGx1Z2luKHtcbiAgdHJhbnNmb3JtZXJzID0gREVGQVVMVF9UUkFOU0ZPUk1FUlNcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gbWFya2Rvd24ucmVnaXN0ZXJNYXJrZG93blNob3J0Y3V0cyhlZGl0b3IsIHRyYW5zZm9ybWVycyk7XG4gIH0sIFtlZGl0b3IsIHRyYW5zZm9ybWVyc10pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5ERUZBVUxUX1RSQU5TRk9STUVSUyA9IERFRkFVTFRfVFJBTlNGT1JNRVJTO1xuZXhwb3J0cy5NYXJrZG93blNob3J0Y3V0UGx1Z2luID0gTWFya2Rvd25TaG9ydGN1dFBsdWdpbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalMarkdownShortcutPlugin =  true ? __webpack_require__(/*! ./LexicalMarkdownShortcutPlugin.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js\") : 0\nmodule.exports = LexicalMarkdownShortcutPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsTWFya2Rvd25TaG9ydGN1dFBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLHNDQUFzQyxLQUFzQyxHQUFHLG1CQUFPLENBQUMsc0lBQXdDLElBQUksQ0FBa0Q7QUFDckwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxNYXJrZG93blNob3J0Y3V0UGx1Z2luLmpzPzRjNmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxNYXJrZG93blNob3J0Y3V0UGx1Z2luID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxNYXJrZG93blNob3J0Y3V0UGx1Z2luLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsTWFya2Rvd25TaG9ydGN1dFBsdWdpbi5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbE1hcmtkb3duU2hvcnRjdXRQbHVnaW47Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalOnChangePlugin.dev.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalOnChangePlugin.dev.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? react.useLayoutEffect : react.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction OnChangePlugin({\n  ignoreHistoryMergeTagChange = true,\n  ignoreSelectionChange = false,\n  onChange\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useLayoutEffect(() => {\n    if (onChange) {\n      return editor.registerUpdateListener(({\n        editorState,\n        dirtyElements,\n        dirtyLeaves,\n        prevEditorState,\n        tags\n      }) => {\n        if (ignoreSelectionChange && dirtyElements.size === 0 && dirtyLeaves.size === 0 || ignoreHistoryMergeTagChange && tags.has('history-merge') || prevEditorState.isEmpty()) {\n          return;\n        }\n\n        onChange(editorState, editor, tags);\n      });\n    }\n  }, [editor, ignoreHistoryMergeTagChange, ignoreSelectionChange, onChange]);\n  return null;\n}\n\nexports.OnChangePlugin = OnChangePlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsT25DaGFuZ2VQbHVnaW4uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLDBIQUF1QztBQUM1RSxZQUFZLG1CQUFPLENBQUMsbUZBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLHNCQUFzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE9uQ2hhbmdlUGx1Z2luLmRldi5qcz83NGJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgdXNlTGF5b3V0RWZmZWN0SW1wbCA9IENBTl9VU0VfRE9NID8gcmVhY3QudXNlTGF5b3V0RWZmZWN0IDogcmVhY3QudXNlRWZmZWN0O1xudmFyIHVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdEltcGw7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIE9uQ2hhbmdlUGx1Z2luKHtcbiAgaWdub3JlSGlzdG9yeU1lcmdlVGFnQ2hhbmdlID0gdHJ1ZSxcbiAgaWdub3JlU2VsZWN0aW9uQ2hhbmdlID0gZmFsc2UsXG4gIG9uQ2hhbmdlXG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHtcbiAgICAgICAgZWRpdG9yU3RhdGUsXG4gICAgICAgIGRpcnR5RWxlbWVudHMsXG4gICAgICAgIGRpcnR5TGVhdmVzLFxuICAgICAgICBwcmV2RWRpdG9yU3RhdGUsXG4gICAgICAgIHRhZ3NcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZVNlbGVjdGlvbkNoYW5nZSAmJiBkaXJ0eUVsZW1lbnRzLnNpemUgPT09IDAgJiYgZGlydHlMZWF2ZXMuc2l6ZSA9PT0gMCB8fCBpZ25vcmVIaXN0b3J5TWVyZ2VUYWdDaGFuZ2UgJiYgdGFncy5oYXMoJ2hpc3RvcnktbWVyZ2UnKSB8fCBwcmV2RWRpdG9yU3RhdGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgb25DaGFuZ2UoZWRpdG9yU3RhdGUsIGVkaXRvciwgdGFncyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtlZGl0b3IsIGlnbm9yZUhpc3RvcnlNZXJnZVRhZ0NoYW5nZSwgaWdub3JlU2VsZWN0aW9uQ2hhbmdlLCBvbkNoYW5nZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5PbkNoYW5nZVBsdWdpbiA9IE9uQ2hhbmdlUGx1Z2luO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalOnChangePlugin.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalOnChangePlugin.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalOnChangePlugin.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalOnChangePlugin =  true ? __webpack_require__(/*! ./LexicalOnChangePlugin.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalOnChangePlugin.dev.js\") : 0\nmodule.exports = LexicalOnChangePlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsT25DaGFuZ2VQbHVnaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWiw4QkFBOEIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLHNIQUFnQyxJQUFJLENBQTBDO0FBQzdKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsT25DaGFuZ2VQbHVnaW4uanM/NjJhMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbE9uQ2hhbmdlUGx1Z2luID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxPbkNoYW5nZVBsdWdpbi5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbE9uQ2hhbmdlUGx1Z2luLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsT25DaGFuZ2VQbHVnaW47Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalOnChangePlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar useLexicalEditable = __webpack_require__(/*! @lexical/react/useLexicalEditable */ \"(app-pages-browser)/./node_modules/@lexical/react/useLexicalEditable.js\");\nvar React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar text = __webpack_require__(/*! @lexical/text */ \"(app-pages-browser)/./node_modules/@lexical/text/LexicalText.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar reactDom = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\nvar dragon = __webpack_require__(/*! @lexical/dragon */ \"(app-pages-browser)/./node_modules/@lexical/dragon/LexicalDragon.js\");\nvar richText = __webpack_require__(/*! @lexical/rich-text */ \"(app-pages-browser)/./node_modules/@lexical/rich-text/LexicalRichText.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read(text.$canShowPlaceholderCurry(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\n\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = React.useState(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffect(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n\n    resetCanShowPlaceholder();\n    return utils.mergeRegister(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useDecorators(editor, ErrorBoundary) {\n  const [decorators, setDecorators] = React.useState(() => editor.getDecorators()); // Subscribe to changes\n\n  useLayoutEffect(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      reactDom.flushSync(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]);\n  React.useEffect(() => {\n    // If the content editable mounts before the subscription is added, then\n    // nothing will be rendered on initial pass. We can get around that by\n    // ensuring that we set the value.\n    setDecorators(editor.getDecorators());\n  }, [editor]); // Return decorators defined as React Portals\n\n  return React.useMemo(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = /*#__PURE__*/React.createElement(ErrorBoundary, {\n        onError: e => editor._onError(e)\n      }, /*#__PURE__*/React.createElement(React.Suspense, {\n        fallback: null\n      }, decorators[nodeKey]));\n      const element = editor.getElementByKey(nodeKey);\n\n      if (element !== null) {\n        decoratedPortals.push( /*#__PURE__*/reactDom.createPortal(reactDecorator, element, nodeKey));\n      }\n    }\n\n    return decoratedPortals;\n  }, [ErrorBoundary, decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useRichTextSetup(editor) {\n  useLayoutEffect(() => {\n    return utils.mergeRegister(richText.registerRichText(editor), dragon.registerDragonSupport(editor)); // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction RichTextPlugin({\n  contentEditable,\n  placeholder,\n  ErrorBoundary\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const decorators = useDecorators(editor, ErrorBoundary);\n  useRichTextSetup(editor);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, contentEditable, /*#__PURE__*/React.createElement(Placeholder, {\n    content: placeholder\n  }), decorators);\n}\n\nfunction Placeholder({\n  content\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const editable = useLexicalEditable();\n\n  if (!showPlaceholder) {\n    return null;\n  }\n\n  if (typeof content === 'function') {\n    return content(editable);\n  } else {\n    return content;\n  }\n}\n\nexports.RichTextPlugin = RichTextPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsUmljaFRleHRQbHVnaW4uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLDBIQUF1QztBQUM1RSx5QkFBeUIsbUJBQU8sQ0FBQyxrSEFBbUM7QUFDcEUsWUFBWSxtQkFBTyxDQUFDLG1GQUFPO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxzRkFBZTtBQUNsQyxZQUFZLG1CQUFPLENBQUMseUZBQWdCO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQywyRkFBVztBQUNsQyxhQUFhLG1CQUFPLENBQUMsNEZBQWlCO0FBQ3RDLGVBQWUsbUJBQU8sQ0FBQyxvR0FBb0I7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GOztBQUVwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGFBQWE7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUc7QUFDekc7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxSaWNoVGV4dFBsdWdpbi5kZXYuanM/OGU2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgdXNlTGV4aWNhbEVkaXRhYmxlID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC90ZXh0Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIHJlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIgZHJhZ29uID0gcmVxdWlyZSgnQGxleGljYWwvZHJhZ29uJyk7XG52YXIgcmljaFRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yaWNoLXRleHQnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCB1c2VMYXlvdXRFZmZlY3RJbXBsID0gQ0FOX1VTRV9ET00gPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG52YXIgdXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0SW1wbDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBjYW5TaG93UGxhY2Vob2xkZXJGcm9tQ3VycmVudEVkaXRvclN0YXRlKGVkaXRvcikge1xuICBjb25zdCBjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyID0gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCh0ZXh0LiRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeShlZGl0b3IuaXNDb21wb3NpbmcoKSkpO1xuICByZXR1cm4gY3VycmVudENhblNob3dQbGFjZWhvbGRlcjtcbn1cblxuZnVuY3Rpb24gdXNlQ2FuU2hvd1BsYWNlaG9sZGVyKGVkaXRvcikge1xuICBjb25zdCBbY2FuU2hvd1BsYWNlaG9sZGVyLCBzZXRDYW5TaG93UGxhY2Vob2xkZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY2FuU2hvd1BsYWNlaG9sZGVyRnJvbUN1cnJlbnRFZGl0b3JTdGF0ZShlZGl0b3IpKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBmdW5jdGlvbiByZXNldENhblNob3dQbGFjZWhvbGRlcigpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXIgPSBjYW5TaG93UGxhY2Vob2xkZXJGcm9tQ3VycmVudEVkaXRvclN0YXRlKGVkaXRvcik7XG4gICAgICBzZXRDYW5TaG93UGxhY2Vob2xkZXIoY3VycmVudENhblNob3dQbGFjZWhvbGRlcik7XG4gICAgfVxuXG4gICAgcmVzZXRDYW5TaG93UGxhY2Vob2xkZXIoKTtcbiAgICByZXR1cm4gdXRpbHMubWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICByZXNldENhblNob3dQbGFjZWhvbGRlcigpO1xuICAgIH0pLCBlZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCk7XG4gICAgfSkpO1xuICB9LCBbZWRpdG9yXSk7XG4gIHJldHVybiBjYW5TaG93UGxhY2Vob2xkZXI7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIHVzZURlY29yYXRvcnMoZWRpdG9yLCBFcnJvckJvdW5kYXJ5KSB7XG4gIGNvbnN0IFtkZWNvcmF0b3JzLCBzZXREZWNvcmF0b3JzXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGVkaXRvci5nZXREZWNvcmF0b3JzKCkpOyAvLyBTdWJzY3JpYmUgdG8gY2hhbmdlc1xuXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlckRlY29yYXRvckxpc3RlbmVyKG5leHREZWNvcmF0b3JzID0+IHtcbiAgICAgIHJlYWN0RG9tLmZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgIHNldERlY29yYXRvcnMobmV4dERlY29yYXRvcnMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJZiB0aGUgY29udGVudCBlZGl0YWJsZSBtb3VudHMgYmVmb3JlIHRoZSBzdWJzY3JpcHRpb24gaXMgYWRkZWQsIHRoZW5cbiAgICAvLyBub3RoaW5nIHdpbGwgYmUgcmVuZGVyZWQgb24gaW5pdGlhbCBwYXNzLiBXZSBjYW4gZ2V0IGFyb3VuZCB0aGF0IGJ5XG4gICAgLy8gZW5zdXJpbmcgdGhhdCB3ZSBzZXQgdGhlIHZhbHVlLlxuICAgIHNldERlY29yYXRvcnMoZWRpdG9yLmdldERlY29yYXRvcnMoKSk7XG4gIH0sIFtlZGl0b3JdKTsgLy8gUmV0dXJuIGRlY29yYXRvcnMgZGVmaW5lZCBhcyBSZWFjdCBQb3J0YWxzXG5cbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGRlY29yYXRlZFBvcnRhbHMgPSBbXTtcbiAgICBjb25zdCBkZWNvcmF0b3JLZXlzID0gT2JqZWN0LmtleXMoZGVjb3JhdG9ycyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29yYXRvcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGVLZXkgPSBkZWNvcmF0b3JLZXlzW2ldO1xuICAgICAgY29uc3QgcmVhY3REZWNvcmF0b3IgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIG9uRXJyb3I6IGUgPT4gZWRpdG9yLl9vbkVycm9yKGUpXG4gICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5TdXNwZW5zZSwge1xuICAgICAgICBmYWxsYmFjazogbnVsbFxuICAgICAgfSwgZGVjb3JhdG9yc1tub2RlS2V5XSkpO1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkobm9kZUtleSk7XG5cbiAgICAgIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGRlY29yYXRlZFBvcnRhbHMucHVzaCggLyojX19QVVJFX18qL3JlYWN0RG9tLmNyZWF0ZVBvcnRhbChyZWFjdERlY29yYXRvciwgZWxlbWVudCwgbm9kZUtleSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZWNvcmF0ZWRQb3J0YWxzO1xuICB9LCBbRXJyb3JCb3VuZGFyeSwgZGVjb3JhdG9ycywgZWRpdG9yXSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIHVzZVJpY2hUZXh0U2V0dXAoZWRpdG9yKSB7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHV0aWxzLm1lcmdlUmVnaXN0ZXIocmljaFRleHQucmVnaXN0ZXJSaWNoVGV4dChlZGl0b3IpLCBkcmFnb24ucmVnaXN0ZXJEcmFnb25TdXBwb3J0KGVkaXRvcikpOyAvLyBXZSBvbmx5IGRvIHRoaXMgZm9yIGluaXRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtlZGl0b3JdKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gUmljaFRleHRQbHVnaW4oe1xuICBjb250ZW50RWRpdGFibGUsXG4gIHBsYWNlaG9sZGVyLFxuICBFcnJvckJvdW5kYXJ5XG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IGRlY29yYXRvcnMgPSB1c2VEZWNvcmF0b3JzKGVkaXRvciwgRXJyb3JCb3VuZGFyeSk7XG4gIHVzZVJpY2hUZXh0U2V0dXAoZWRpdG9yKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjb250ZW50RWRpdGFibGUsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFBsYWNlaG9sZGVyLCB7XG4gICAgY29udGVudDogcGxhY2Vob2xkZXJcbiAgfSksIGRlY29yYXRvcnMpO1xufVxuXG5mdW5jdGlvbiBQbGFjZWhvbGRlcih7XG4gIGNvbnRlbnRcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3Qgc2hvd1BsYWNlaG9sZGVyID0gdXNlQ2FuU2hvd1BsYWNlaG9sZGVyKGVkaXRvcik7XG4gIGNvbnN0IGVkaXRhYmxlID0gdXNlTGV4aWNhbEVkaXRhYmxlKCk7XG5cbiAgaWYgKCFzaG93UGxhY2Vob2xkZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjb250ZW50KGVkaXRhYmxlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxufVxuXG5leHBvcnRzLlJpY2hUZXh0UGx1Z2luID0gUmljaFRleHRQbHVnaW47XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalRichTextPlugin.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalRichTextPlugin.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalRichTextPlugin =  true ? __webpack_require__(/*! ./LexicalRichTextPlugin.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js\") : 0\nmodule.exports = LexicalRichTextPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsUmljaFRleHRQbHVnaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWiw4QkFBOEIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLHNIQUFnQyxJQUFJLENBQTBDO0FBQzdKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsUmljaFRleHRQbHVnaW4uanM/NDk4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbFJpY2hUZXh0UGx1Z2luID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxSaWNoVGV4dFBsdWdpbi5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbFJpY2hUZXh0UGx1Z2luLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsUmljaFRleHRQbHVnaW47Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalRichTextPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalTreeView.dev.js":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTreeView.dev.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar html = __webpack_require__(/*! @lexical/html */ \"(app-pages-browser)/./node_modules/@lexical/html/LexicalHtml.js\");\nvar link = __webpack_require__(/*! @lexical/link */ \"(app-pages-browser)/./node_modules/@lexical/link/LexicalLink.js\");\nvar mark = __webpack_require__(/*! @lexical/mark */ \"(app-pages-browser)/./node_modules/@lexical/mark/LexicalMark.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\nvar React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({\n  '\\t': '\\\\t',\n  '\\n': '\\\\n'\n});\nconst NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join('|'), 'g');\nconst SYMBOLS = Object.freeze({\n  ancestorHasNextSibling: '|',\n  ancestorIsLastChild: ' ',\n  hasNextSibling: '├',\n  isLastChild: '└',\n  selectedChar: '^',\n  selectedLine: '>'\n});\nfunction TreeView({\n  treeTypeButtonClassName,\n  timeTravelButtonClassName,\n  timeTravelPanelSliderClassName,\n  timeTravelPanelButtonClassName,\n  viewClassName,\n  timeTravelPanelClassName,\n  editor\n}) {\n  const [timeStampedEditorStates, setTimeStampedEditorStates] = React.useState([]);\n  const [content, setContent] = React.useState('');\n  const [timeTravelEnabled, setTimeTravelEnabled] = React.useState(false);\n  const [showExportDOM, setShowExportDOM] = React.useState(false);\n  const playingIndexRef = React.useRef(0);\n  const treeElementRef = React.useRef(null);\n  const inputRef = React.useRef(null);\n  const [isPlaying, setIsPlaying] = React.useState(false);\n  const [isLimited, setIsLimited] = React.useState(false);\n  const [showLimited, setShowLimited] = React.useState(false);\n  const lastEditorStateRef = React.useRef(null);\n  const commandsLog = useLexicalCommandsLog(editor);\n  const generateTree = React.useCallback(editorState => {\n    const treeText = generateContent(editor, commandsLog, showExportDOM);\n    setContent(treeText);\n\n    if (!timeTravelEnabled) {\n      setTimeStampedEditorStates(currentEditorStates => [...currentEditorStates, [Date.now(), editorState]]);\n    }\n  }, [commandsLog, editor, timeTravelEnabled, showExportDOM]);\n  React.useEffect(() => {\n    const editorState = editor.getEditorState();\n\n    if (!showLimited && editorState._nodeMap.size < 1000) {\n      setContent(generateContent(editor, commandsLog, showExportDOM));\n    }\n  }, [commandsLog, editor, showLimited, showExportDOM]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerUpdateListener(({\n      editorState\n    }) => {\n      if (!showLimited && editorState._nodeMap.size > 1000) {\n        lastEditorStateRef.current = editorState;\n        setIsLimited(true);\n\n        if (!showLimited) {\n          return;\n        }\n      }\n\n      generateTree(editorState);\n    }), editor.registerEditableListener(() => {\n      const treeText = generateContent(editor, commandsLog, showExportDOM);\n      setContent(treeText);\n    }));\n  }, [commandsLog, editor, showExportDOM, isLimited, generateTree, showLimited]);\n  const totalEditorStates = timeStampedEditorStates.length;\n  React.useEffect(() => {\n    if (isPlaying) {\n      let timeoutId;\n\n      const play = () => {\n        const currentIndex = playingIndexRef.current;\n\n        if (currentIndex === totalEditorStates - 1) {\n          setIsPlaying(false);\n          return;\n        }\n\n        const currentTime = timeStampedEditorStates[currentIndex][0];\n        const nextTime = timeStampedEditorStates[currentIndex + 1][0];\n        const timeDiff = nextTime - currentTime;\n        timeoutId = setTimeout(() => {\n          playingIndexRef.current++;\n          const index = playingIndexRef.current;\n          const input = inputRef.current;\n\n          if (input !== null) {\n            input.value = String(index);\n          }\n\n          editor.setEditorState(timeStampedEditorStates[index][1]);\n          play();\n        }, timeDiff);\n      };\n\n      play();\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    }\n  }, [timeStampedEditorStates, isPlaying, editor, totalEditorStates]);\n  React.useEffect(() => {\n    const element = treeElementRef.current;\n\n    if (element !== null) {\n      // @ts-ignore Internal field\n      element.__lexicalEditor = editor;\n      return () => {\n        // @ts-ignore Internal field\n        element.__lexicalEditor = null;\n      };\n    }\n  }, [editor]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: viewClassName\n  }, !showLimited && isLimited ? /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      padding: 20\n    }\n  }, /*#__PURE__*/React.createElement(\"span\", {\n    style: {\n      marginRight: 20\n    }\n  }, \"Detected large EditorState, this can impact debugging performance.\"), /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => {\n      setShowLimited(true);\n      const editorState = lastEditorStateRef.current;\n\n      if (editorState !== null) {\n        lastEditorStateRef.current = null;\n        generateTree(editorState);\n      }\n    },\n    style: {\n      background: 'transparent',\n      border: '1px solid white',\n      color: 'white',\n      cursor: 'pointer',\n      padding: 5\n    }\n  }, \"Show full tree\")) : null, !showLimited ? /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => setShowExportDOM(!showExportDOM),\n    className: treeTypeButtonClassName,\n    type: \"button\"\n  }, showExportDOM ? 'Tree' : 'Export DOM') : null, !timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2 && /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => {\n      const rootElement = editor.getRootElement();\n\n      if (rootElement !== null) {\n        rootElement.contentEditable = 'false';\n        playingIndexRef.current = totalEditorStates - 1;\n        setTimeTravelEnabled(true);\n      }\n    },\n    className: timeTravelButtonClassName,\n    type: \"button\"\n  }, \"Time Travel\"), (showLimited || !isLimited) && /*#__PURE__*/React.createElement(\"pre\", {\n    ref: treeElementRef\n  }, content), timeTravelEnabled && (showLimited || !isLimited) && /*#__PURE__*/React.createElement(\"div\", {\n    className: timeTravelPanelClassName\n  }, /*#__PURE__*/React.createElement(\"button\", {\n    className: timeTravelPanelButtonClassName,\n    onClick: () => {\n      if (playingIndexRef.current === totalEditorStates - 1) {\n        playingIndexRef.current = 1;\n      }\n\n      setIsPlaying(!isPlaying);\n    },\n    type: \"button\"\n  }, isPlaying ? 'Pause' : 'Play'), /*#__PURE__*/React.createElement(\"input\", {\n    className: timeTravelPanelSliderClassName,\n    ref: inputRef,\n    onChange: event => {\n      const editorStateIndex = Number(event.target.value);\n      const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];\n\n      if (timeStampedEditorState) {\n        playingIndexRef.current = editorStateIndex;\n        editor.setEditorState(timeStampedEditorState[1]);\n      }\n    },\n    type: \"range\",\n    min: \"1\",\n    max: totalEditorStates - 1\n  }), /*#__PURE__*/React.createElement(\"button\", {\n    className: timeTravelPanelButtonClassName,\n    onClick: () => {\n      const rootElement = editor.getRootElement();\n\n      if (rootElement !== null) {\n        rootElement.contentEditable = 'true';\n        const index = timeStampedEditorStates.length - 1;\n        const timeStampedEditorState = timeStampedEditorStates[index];\n        editor.setEditorState(timeStampedEditorState[1]);\n        const input = inputRef.current;\n\n        if (input !== null) {\n          input.value = String(index);\n        }\n\n        setTimeTravelEnabled(false);\n        setIsPlaying(false);\n      }\n    },\n    type: \"button\"\n  }, \"Exit\")));\n}\n\nfunction useLexicalCommandsLog(editor) {\n  const [loggedCommands, setLoggedCommands] = React.useState([]);\n  React.useEffect(() => {\n    const unregisterCommandListeners = new Set();\n\n    for (const [command] of editor._commands) {\n      unregisterCommandListeners.add(editor.registerCommand(command, payload => {\n        setLoggedCommands(state => {\n          const newState = [...state];\n          newState.push({\n            payload,\n            type: command.type ? command.type : 'UNKNOWN'\n          });\n\n          if (newState.length > 10) {\n            newState.shift();\n          }\n\n          return newState;\n        });\n        return false;\n      }, lexical.COMMAND_PRIORITY_HIGH));\n    }\n\n    return () => unregisterCommandListeners.forEach(unregister => unregister());\n  }, [editor]);\n  return React.useMemo(() => loggedCommands, [loggedCommands]);\n}\n\nfunction printRangeSelection(selection) {\n  let res = '';\n  const formatText = printFormatProperties(selection);\n  res += `: range ${formatText !== '' ? `{ ${formatText} }` : ''} ${selection.style !== '' ? `{ style: ${selection.style} } ` : ''}`;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  res += `\\n  ├ anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? 'null' : anchorOffset}, type: ${anchor.type} }`;\n  res += `\\n  └ focus { key: ${focus.key}, offset: ${focusOffset === null ? 'null' : focusOffset}, type: ${focus.type} }`;\n  return res;\n}\n\nfunction printNodeSelection(selection) {\n  return `: node\\n  └ [${Array.from(selection._nodes).join(', ')}]`;\n}\n\nfunction printGridSelection(selection) {\n  return `: grid\\n  └ { grid: ${selection.gridKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;\n}\n\nfunction generateContent(editor, commandsLog, exportDOM) {\n  const editorState = editor.getEditorState();\n  const editorConfig = editor._config;\n  const compositionKey = editor._compositionKey;\n  const editable = editor._editable;\n\n  if (exportDOM) {\n    let htmlString = '';\n    editorState.read(() => {\n      htmlString = printPrettyHTML(html.$generateHtmlFromNodes(editor));\n    });\n    return htmlString;\n  }\n\n  let res = ' root\\n';\n  const selectionString = editorState.read(() => {\n    const selection = lexical.$getSelection();\n    visitTree(lexical.$getRoot(), (node, indent) => {\n      const nodeKey = node.getKey();\n      const nodeKeyDisplay = `(${nodeKey})`;\n      const typeDisplay = node.getType() || '';\n      const isSelected = node.isSelected();\n      const idsDisplay = mark.$isMarkNode(node) ? ` id: [ ${node.getIDs().join(', ')} ] ` : '';\n      res += `${isSelected ? SYMBOLS.selectedLine : ' '} ${indent.join(' ')} ${nodeKeyDisplay} ${typeDisplay} ${idsDisplay} ${printNode(node)}\\n`;\n      res += printSelectedCharsLine({\n        indent,\n        isSelected,\n        node,\n        nodeKeyDisplay,\n        selection,\n        typeDisplay\n      });\n    });\n    return selection === null ? ': null' : lexical.$isRangeSelection(selection) ? printRangeSelection(selection) : lexical.DEPRECATED_$isGridSelection(selection) ? printGridSelection(selection) : printNodeSelection(selection);\n  });\n  res += '\\n selection' + selectionString;\n  res += '\\n\\n commands:';\n\n  if (commandsLog.length) {\n    for (const {\n      type,\n      payload\n    } of commandsLog) {\n      res += `\\n  └ { type: ${type}, payload: ${payload instanceof Event ? payload.constructor.name : payload} }`;\n    }\n  } else {\n    res += '\\n  └ None dispatched.';\n  }\n\n  res += '\\n\\n editor:';\n  res += `\\n  └ namespace ${editorConfig.namespace}`;\n\n  if (compositionKey !== null) {\n    res += `\\n  └ compositionKey ${compositionKey}`;\n  }\n\n  res += `\\n  └ editable ${String(editable)}`;\n  return res;\n}\n\nfunction visitTree(currentNode, visitor, indent = []) {\n  const childNodes = currentNode.getChildren();\n  const childNodesLength = childNodes.length;\n  childNodes.forEach((childNode, i) => {\n    visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));\n\n    if (lexical.$isElementNode(childNode)) {\n      visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));\n    }\n  });\n}\n\nfunction normalize(text) {\n  return Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, [key, value]) => acc.replace(new RegExp(key, 'g'), String(value)), text);\n} // TODO Pass via props to allow customizability\n\n\nfunction printNode(node) {\n  if (lexical.$isTextNode(node)) {\n    const text = node.getTextContent();\n    const title = text.length === 0 ? '(empty)' : `\"${normalize(text)}\"`;\n    const properties = printAllTextNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if (link.$isLinkNode(node)) {\n    const link = node.getURL();\n    const title = link.length === 0 ? '(empty)' : `\"${normalize(link)}\"`;\n    const properties = printAllLinkNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else {\n    return '';\n  }\n}\n\nconst FORMAT_PREDICATES = [node => node.hasFormat('bold') && 'Bold', node => node.hasFormat('code') && 'Code', node => node.hasFormat('italic') && 'Italic', node => node.hasFormat('strikethrough') && 'Strikethrough', node => node.hasFormat('subscript') && 'Subscript', node => node.hasFormat('superscript') && 'Superscript', node => node.hasFormat('underline') && 'Underline'];\nconst DETAIL_PREDICATES = [node => node.isDirectionless() && 'Directionless', node => node.isUnmergeable() && 'Unmergeable'];\nconst MODE_PREDICATES = [node => node.isToken() && 'Token', node => node.isSegmented() && 'Segmented'];\n\nfunction printAllTextNodeProperties(node) {\n  return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node)].filter(Boolean).join(', ');\n}\n\nfunction printAllLinkNodeProperties(node) {\n  return [printTargetProperties(node), printRelProperties(node), printTitleProperties(node)].filter(Boolean).join(', ');\n}\n\nfunction printDetailProperties(nodeOrSelection) {\n  let str = DETAIL_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n\n  if (str !== '') {\n    str = 'detail: ' + str;\n  }\n\n  return str;\n}\n\nfunction printModeProperties(nodeOrSelection) {\n  let str = MODE_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n\n  if (str !== '') {\n    str = 'mode: ' + str;\n  }\n\n  return str;\n}\n\nfunction printFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n\n  return str;\n}\n\nfunction printTargetProperties(node) {\n  let str = node.getTarget(); // TODO Fix nullish on LinkNode\n\n  if (str != null) {\n    str = 'target: ' + str;\n  }\n\n  return str;\n}\n\nfunction printRelProperties(node) {\n  let str = node.getRel(); // TODO Fix nullish on LinkNode\n\n  if (str != null) {\n    str = 'rel: ' + str;\n  }\n\n  return str;\n}\n\nfunction printTitleProperties(node) {\n  let str = node.getTitle(); // TODO Fix nullish on LinkNode\n\n  if (str != null) {\n    str = 'title: ' + str;\n  }\n\n  return str;\n}\n\nfunction printSelectedCharsLine({\n  indent,\n  isSelected,\n  node,\n  nodeKeyDisplay,\n  selection,\n  typeDisplay\n}) {\n  // No selection or node is not selected.\n  if (!lexical.$isTextNode(node) || !lexical.$isRangeSelection(selection) || !isSelected || lexical.$isElementNode(node)) {\n    return '';\n  } // No selected characters.\n\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n\n  if (node.getTextContent() === '' || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {\n    return '';\n  }\n\n  const [start, end] = $getSelectionStartEnd(node, selection);\n\n  if (start === end) {\n    return '';\n  }\n\n  const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;\n  const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];\n  const unselectedChars = Array(start + 1).fill(' ');\n  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);\n  const paddingLength = typeDisplay.length + 3; // 2 for the spaces around + 1 for the double quote.\n\n  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(' ');\n  return [SYMBOLS.selectedLine, indentionChars.join(' '), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join('')].join(' ') + '\\n';\n}\n\nfunction printPrettyHTML(str) {\n  const div = document.createElement('div');\n  div.innerHTML = str.trim();\n  return prettifyHTML(div, 0).innerHTML;\n}\n\nfunction prettifyHTML(node, level) {\n  const indentBefore = new Array(level++ + 1).join('  ');\n  const indentAfter = new Array(level - 1).join('  ');\n  let textNode;\n\n  for (let i = 0; i < node.children.length; i++) {\n    textNode = document.createTextNode('\\n' + indentBefore);\n    node.insertBefore(textNode, node.children[i]);\n    prettifyHTML(node.children[i], level);\n\n    if (node.lastElementChild === node.children[i]) {\n      textNode = document.createTextNode('\\n' + indentAfter);\n      node.appendChild(textNode);\n    }\n  }\n\n  return node;\n}\n\nfunction $getSelectionStartEnd(node, selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const textContent = node.getTextContent();\n  const textLength = textContent.length;\n  let start = -1;\n  let end = -1; // Only one node is being selected.\n\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n\n    if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {\n      [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];\n    } else if (node === anchorNode) {\n      [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];\n    } else if (node === focusNode) {\n      [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];\n    } else {\n      // Node is within selection but not the anchor nor focus.\n      [start, end] = [0, textLength];\n    }\n  } // Account for non-single width characters.\n\n\n  const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];\n}\n\nexports.TreeView = TreeView;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsVHJlZVZpZXcuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxzRkFBZTtBQUNsQyxXQUFXLG1CQUFPLENBQUMsc0ZBQWU7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLHNGQUFlO0FBQ2xDLFlBQVksbUJBQU8sQ0FBQyx5RkFBZ0I7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLHNFQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyxtRkFBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCLEVBQUUsYUFBYSxRQUFRLEVBQUUsNEJBQTRCLFNBQVMsbUJBQW1CLE9BQU87QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyxXQUFXLFlBQVksOENBQThDLFVBQVUsY0FBYztBQUM3SCx3QkFBd0IsT0FBTyxVQUFVLFlBQVksNENBQTRDLFVBQVUsYUFBYTtBQUN4SDtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHdDQUF3QztBQUNqRTs7QUFFQTtBQUNBLHdCQUF3QixRQUFRLGtCQUFrQixnQkFBZ0IscUJBQXFCLGVBQWUsc0JBQXNCO0FBQzVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBLDREQUE0RCwwQkFBMEI7QUFDdEYsZ0JBQWdCLHlDQUF5QyxFQUFFLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLGFBQWEsRUFBRSxZQUFZLEVBQUUsZ0JBQWdCO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixRQUFRLEtBQUssYUFBYSxnRUFBZ0U7QUFDaEg7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qix1QkFBdUI7O0FBRW5EO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7O0FBRUEsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0JBQWdCO0FBQ3RFO0FBQ0EsZ0RBQWdELEVBQUUsYUFBYTtBQUMvRCxJQUFJO0FBQ0o7QUFDQSxzREFBc0QsZ0JBQWdCO0FBQ3RFO0FBQ0EsZ0RBQWdELEVBQUUsYUFBYTtBQUMvRCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsVHJlZVZpZXcuZGV2LmpzPzM5NTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBodG1sID0gcmVxdWlyZSgnQGxleGljYWwvaHRtbCcpO1xudmFyIGxpbmsgPSByZXF1aXJlKCdAbGV4aWNhbC9saW5rJyk7XG52YXIgbWFyayA9IHJlcXVpcmUoJ0BsZXhpY2FsL21hcmsnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVQTEFDRU1FTlQgPSBPYmplY3QuZnJlZXplKHtcbiAgJ1xcdCc6ICdcXFxcdCcsXG4gICdcXG4nOiAnXFxcXG4nXG59KTtcbmNvbnN0IE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVHRVggPSBuZXcgUmVnRXhwKE9iamVjdC5rZXlzKE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVQTEFDRU1FTlQpLmpvaW4oJ3wnKSwgJ2cnKTtcbmNvbnN0IFNZTUJPTFMgPSBPYmplY3QuZnJlZXplKHtcbiAgYW5jZXN0b3JIYXNOZXh0U2libGluZzogJ3wnLFxuICBhbmNlc3RvcklzTGFzdENoaWxkOiAnICcsXG4gIGhhc05leHRTaWJsaW5nOiAn4pScJyxcbiAgaXNMYXN0Q2hpbGQ6ICfilJQnLFxuICBzZWxlY3RlZENoYXI6ICdeJyxcbiAgc2VsZWN0ZWRMaW5lOiAnPidcbn0pO1xuZnVuY3Rpb24gVHJlZVZpZXcoe1xuICB0cmVlVHlwZUJ1dHRvbkNsYXNzTmFtZSxcbiAgdGltZVRyYXZlbEJ1dHRvbkNsYXNzTmFtZSxcbiAgdGltZVRyYXZlbFBhbmVsU2xpZGVyQ2xhc3NOYW1lLFxuICB0aW1lVHJhdmVsUGFuZWxCdXR0b25DbGFzc05hbWUsXG4gIHZpZXdDbGFzc05hbWUsXG4gIHRpbWVUcmF2ZWxQYW5lbENsYXNzTmFtZSxcbiAgZWRpdG9yXG59KSB7XG4gIGNvbnN0IFt0aW1lU3RhbXBlZEVkaXRvclN0YXRlcywgc2V0VGltZVN0YW1wZWRFZGl0b3JTdGF0ZXNdID0gUmVhY3QudXNlU3RhdGUoW10pO1xuICBjb25zdCBbY29udGVudCwgc2V0Q29udGVudF0gPSBSZWFjdC51c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFt0aW1lVHJhdmVsRW5hYmxlZCwgc2V0VGltZVRyYXZlbEVuYWJsZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd0V4cG9ydERPTSwgc2V0U2hvd0V4cG9ydERPTV0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHBsYXlpbmdJbmRleFJlZiA9IFJlYWN0LnVzZVJlZigwKTtcbiAgY29uc3QgdHJlZUVsZW1lbnRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGlucHV0UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBbaXNQbGF5aW5nLCBzZXRJc1BsYXlpbmddID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNMaW1pdGVkLCBzZXRJc0xpbWl0ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd0xpbWl0ZWQsIHNldFNob3dMaW1pdGVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgbGFzdEVkaXRvclN0YXRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBjb21tYW5kc0xvZyA9IHVzZUxleGljYWxDb21tYW5kc0xvZyhlZGl0b3IpO1xuICBjb25zdCBnZW5lcmF0ZVRyZWUgPSBSZWFjdC51c2VDYWxsYmFjayhlZGl0b3JTdGF0ZSA9PiB7XG4gICAgY29uc3QgdHJlZVRleHQgPSBnZW5lcmF0ZUNvbnRlbnQoZWRpdG9yLCBjb21tYW5kc0xvZywgc2hvd0V4cG9ydERPTSk7XG4gICAgc2V0Q29udGVudCh0cmVlVGV4dCk7XG5cbiAgICBpZiAoIXRpbWVUcmF2ZWxFbmFibGVkKSB7XG4gICAgICBzZXRUaW1lU3RhbXBlZEVkaXRvclN0YXRlcyhjdXJyZW50RWRpdG9yU3RhdGVzID0+IFsuLi5jdXJyZW50RWRpdG9yU3RhdGVzLCBbRGF0ZS5ub3coKSwgZWRpdG9yU3RhdGVdXSk7XG4gICAgfVxuICB9LCBbY29tbWFuZHNMb2csIGVkaXRvciwgdGltZVRyYXZlbEVuYWJsZWQsIHNob3dFeHBvcnRET01dKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBlZGl0b3JTdGF0ZSA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpO1xuXG4gICAgaWYgKCFzaG93TGltaXRlZCAmJiBlZGl0b3JTdGF0ZS5fbm9kZU1hcC5zaXplIDwgMTAwMCkge1xuICAgICAgc2V0Q29udGVudChnZW5lcmF0ZUNvbnRlbnQoZWRpdG9yLCBjb21tYW5kc0xvZywgc2hvd0V4cG9ydERPTSkpO1xuICAgIH1cbiAgfSwgW2NvbW1hbmRzTG9nLCBlZGl0b3IsIHNob3dMaW1pdGVkLCBzaG93RXhwb3J0RE9NXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHV0aWxzLm1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHtcbiAgICAgIGVkaXRvclN0YXRlXG4gICAgfSkgPT4ge1xuICAgICAgaWYgKCFzaG93TGltaXRlZCAmJiBlZGl0b3JTdGF0ZS5fbm9kZU1hcC5zaXplID4gMTAwMCkge1xuICAgICAgICBsYXN0RWRpdG9yU3RhdGVSZWYuY3VycmVudCA9IGVkaXRvclN0YXRlO1xuICAgICAgICBzZXRJc0xpbWl0ZWQodHJ1ZSk7XG5cbiAgICAgICAgaWYgKCFzaG93TGltaXRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW5lcmF0ZVRyZWUoZWRpdG9yU3RhdGUpO1xuICAgIH0pLCBlZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIGNvbnN0IHRyZWVUZXh0ID0gZ2VuZXJhdGVDb250ZW50KGVkaXRvciwgY29tbWFuZHNMb2csIHNob3dFeHBvcnRET00pO1xuICAgICAgc2V0Q29udGVudCh0cmVlVGV4dCk7XG4gICAgfSkpO1xuICB9LCBbY29tbWFuZHNMb2csIGVkaXRvciwgc2hvd0V4cG9ydERPTSwgaXNMaW1pdGVkLCBnZW5lcmF0ZVRyZWUsIHNob3dMaW1pdGVkXSk7XG4gIGNvbnN0IHRvdGFsRWRpdG9yU3RhdGVzID0gdGltZVN0YW1wZWRFZGl0b3JTdGF0ZXMubGVuZ3RoO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc1BsYXlpbmcpIHtcbiAgICAgIGxldCB0aW1lb3V0SWQ7XG5cbiAgICAgIGNvbnN0IHBsYXkgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHBsYXlpbmdJbmRleFJlZi5jdXJyZW50O1xuXG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IHRvdGFsRWRpdG9yU3RhdGVzIC0gMSkge1xuICAgICAgICAgIHNldElzUGxheWluZyhmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB0aW1lU3RhbXBlZEVkaXRvclN0YXRlc1tjdXJyZW50SW5kZXhdWzBdO1xuICAgICAgICBjb25zdCBuZXh0VGltZSA9IHRpbWVTdGFtcGVkRWRpdG9yU3RhdGVzW2N1cnJlbnRJbmRleCArIDFdWzBdO1xuICAgICAgICBjb25zdCB0aW1lRGlmZiA9IG5leHRUaW1lIC0gY3VycmVudFRpbWU7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHBsYXlpbmdJbmRleFJlZi5jdXJyZW50Kys7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBwbGF5aW5nSW5kZXhSZWYuY3VycmVudDtcbiAgICAgICAgICBjb25zdCBpbnB1dCA9IGlucHV0UmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgICBpZiAoaW5wdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gU3RyaW5nKGluZGV4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlZGl0b3Iuc2V0RWRpdG9yU3RhdGUodGltZVN0YW1wZWRFZGl0b3JTdGF0ZXNbaW5kZXhdWzFdKTtcbiAgICAgICAgICBwbGF5KCk7XG4gICAgICAgIH0sIHRpbWVEaWZmKTtcbiAgICAgIH07XG5cbiAgICAgIHBsYXkoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFt0aW1lU3RhbXBlZEVkaXRvclN0YXRlcywgaXNQbGF5aW5nLCBlZGl0b3IsIHRvdGFsRWRpdG9yU3RhdGVzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRyZWVFbGVtZW50UmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gQHRzLWlnbm9yZSBJbnRlcm5hbCBmaWVsZFxuICAgICAgZWxlbWVudC5fX2xleGljYWxFZGl0b3IgPSBlZGl0b3I7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAvLyBAdHMtaWdub3JlIEludGVybmFsIGZpZWxkXG4gICAgICAgIGVsZW1lbnQuX19sZXhpY2FsRWRpdG9yID0gbnVsbDtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZWRpdG9yXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lXG4gIH0sICFzaG93TGltaXRlZCAmJiBpc0xpbWl0ZWQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmc6IDIwXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBtYXJnaW5SaWdodDogMjBcbiAgICB9XG4gIH0sIFwiRGV0ZWN0ZWQgbGFyZ2UgRWRpdG9yU3RhdGUsIHRoaXMgY2FuIGltcGFjdCBkZWJ1Z2dpbmcgcGVyZm9ybWFuY2UuXCIpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgc2V0U2hvd0xpbWl0ZWQodHJ1ZSk7XG4gICAgICBjb25zdCBlZGl0b3JTdGF0ZSA9IGxhc3RFZGl0b3JTdGF0ZVJlZi5jdXJyZW50O1xuXG4gICAgICBpZiAoZWRpdG9yU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgbGFzdEVkaXRvclN0YXRlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBnZW5lcmF0ZVRyZWUoZWRpdG9yU3RhdGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgd2hpdGUnLFxuICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgIHBhZGRpbmc6IDVcbiAgICB9XG4gIH0sIFwiU2hvdyBmdWxsIHRyZWVcIikpIDogbnVsbCwgIXNob3dMaW1pdGVkID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIG9uQ2xpY2s6ICgpID0+IHNldFNob3dFeHBvcnRET00oIXNob3dFeHBvcnRET00pLFxuICAgIGNsYXNzTmFtZTogdHJlZVR5cGVCdXR0b25DbGFzc05hbWUsXG4gICAgdHlwZTogXCJidXR0b25cIlxuICB9LCBzaG93RXhwb3J0RE9NID8gJ1RyZWUnIDogJ0V4cG9ydCBET00nKSA6IG51bGwsICF0aW1lVHJhdmVsRW5hYmxlZCAmJiAoc2hvd0xpbWl0ZWQgfHwgIWlzTGltaXRlZCkgJiYgdG90YWxFZGl0b3JTdGF0ZXMgPiAyICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuXG4gICAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgcm9vdEVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gJ2ZhbHNlJztcbiAgICAgICAgcGxheWluZ0luZGV4UmVmLmN1cnJlbnQgPSB0b3RhbEVkaXRvclN0YXRlcyAtIDE7XG4gICAgICAgIHNldFRpbWVUcmF2ZWxFbmFibGVkKHRydWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xhc3NOYW1lOiB0aW1lVHJhdmVsQnV0dG9uQ2xhc3NOYW1lLFxuICAgIHR5cGU6IFwiYnV0dG9uXCJcbiAgfSwgXCJUaW1lIFRyYXZlbFwiKSwgKHNob3dMaW1pdGVkIHx8ICFpc0xpbWl0ZWQpICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIHtcbiAgICByZWY6IHRyZWVFbGVtZW50UmVmXG4gIH0sIGNvbnRlbnQpLCB0aW1lVHJhdmVsRW5hYmxlZCAmJiAoc2hvd0xpbWl0ZWQgfHwgIWlzTGltaXRlZCkgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogdGltZVRyYXZlbFBhbmVsQ2xhc3NOYW1lXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICBjbGFzc05hbWU6IHRpbWVUcmF2ZWxQYW5lbEJ1dHRvbkNsYXNzTmFtZSxcbiAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICBpZiAocGxheWluZ0luZGV4UmVmLmN1cnJlbnQgPT09IHRvdGFsRWRpdG9yU3RhdGVzIC0gMSkge1xuICAgICAgICBwbGF5aW5nSW5kZXhSZWYuY3VycmVudCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHNldElzUGxheWluZyghaXNQbGF5aW5nKTtcbiAgICB9LFxuICAgIHR5cGU6IFwiYnV0dG9uXCJcbiAgfSwgaXNQbGF5aW5nID8gJ1BhdXNlJyA6ICdQbGF5JyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwge1xuICAgIGNsYXNzTmFtZTogdGltZVRyYXZlbFBhbmVsU2xpZGVyQ2xhc3NOYW1lLFxuICAgIHJlZjogaW5wdXRSZWYsXG4gICAgb25DaGFuZ2U6IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGVkaXRvclN0YXRlSW5kZXggPSBOdW1iZXIoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgIGNvbnN0IHRpbWVTdGFtcGVkRWRpdG9yU3RhdGUgPSB0aW1lU3RhbXBlZEVkaXRvclN0YXRlc1tlZGl0b3JTdGF0ZUluZGV4XTtcblxuICAgICAgaWYgKHRpbWVTdGFtcGVkRWRpdG9yU3RhdGUpIHtcbiAgICAgICAgcGxheWluZ0luZGV4UmVmLmN1cnJlbnQgPSBlZGl0b3JTdGF0ZUluZGV4O1xuICAgICAgICBlZGl0b3Iuc2V0RWRpdG9yU3RhdGUodGltZVN0YW1wZWRFZGl0b3JTdGF0ZVsxXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0eXBlOiBcInJhbmdlXCIsXG4gICAgbWluOiBcIjFcIixcbiAgICBtYXg6IHRvdGFsRWRpdG9yU3RhdGVzIC0gMVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIGNsYXNzTmFtZTogdGltZVRyYXZlbFBhbmVsQnV0dG9uQ2xhc3NOYW1lLFxuICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG5cbiAgICAgIGlmIChyb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICByb290RWxlbWVudC5jb250ZW50RWRpdGFibGUgPSAndHJ1ZSc7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGltZVN0YW1wZWRFZGl0b3JTdGF0ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgdGltZVN0YW1wZWRFZGl0b3JTdGF0ZSA9IHRpbWVTdGFtcGVkRWRpdG9yU3RhdGVzW2luZGV4XTtcbiAgICAgICAgZWRpdG9yLnNldEVkaXRvclN0YXRlKHRpbWVTdGFtcGVkRWRpdG9yU3RhdGVbMV0pO1xuICAgICAgICBjb25zdCBpbnB1dCA9IGlucHV0UmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKGlucHV0ICE9PSBudWxsKSB7XG4gICAgICAgICAgaW5wdXQudmFsdWUgPSBTdHJpbmcoaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZVRyYXZlbEVuYWJsZWQoZmFsc2UpO1xuICAgICAgICBzZXRJc1BsYXlpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdHlwZTogXCJidXR0b25cIlxuICB9LCBcIkV4aXRcIikpKTtcbn1cblxuZnVuY3Rpb24gdXNlTGV4aWNhbENvbW1hbmRzTG9nKGVkaXRvcikge1xuICBjb25zdCBbbG9nZ2VkQ29tbWFuZHMsIHNldExvZ2dlZENvbW1hbmRzXSA9IFJlYWN0LnVzZVN0YXRlKFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1bnJlZ2lzdGVyQ29tbWFuZExpc3RlbmVycyA9IG5ldyBTZXQoKTtcblxuICAgIGZvciAoY29uc3QgW2NvbW1hbmRdIG9mIGVkaXRvci5fY29tbWFuZHMpIHtcbiAgICAgIHVucmVnaXN0ZXJDb21tYW5kTGlzdGVuZXJzLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGNvbW1hbmQsIHBheWxvYWQgPT4ge1xuICAgICAgICBzZXRMb2dnZWRDb21tYW5kcyhzdGF0ZSA9PiB7XG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBbLi4uc3RhdGVdO1xuICAgICAgICAgIG5ld1N0YXRlLnB1c2goe1xuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgIHR5cGU6IGNvbW1hbmQudHlwZSA/IGNvbW1hbmQudHlwZSA6ICdVTktOT1dOJ1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKG5ld1N0YXRlLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICBuZXdTdGF0ZS5zaGlmdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHVucmVnaXN0ZXJDb21tYW5kTGlzdGVuZXJzLmZvckVhY2godW5yZWdpc3RlciA9PiB1bnJlZ2lzdGVyKCkpO1xuICB9LCBbZWRpdG9yXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGxvZ2dlZENvbW1hbmRzLCBbbG9nZ2VkQ29tbWFuZHNdKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBjb25zdCBmb3JtYXRUZXh0ID0gcHJpbnRGb3JtYXRQcm9wZXJ0aWVzKHNlbGVjdGlvbik7XG4gIHJlcyArPSBgOiByYW5nZSAke2Zvcm1hdFRleHQgIT09ICcnID8gYHsgJHtmb3JtYXRUZXh0fSB9YCA6ICcnfSAke3NlbGVjdGlvbi5zdHlsZSAhPT0gJycgPyBgeyBzdHlsZTogJHtzZWxlY3Rpb24uc3R5bGV9IH0gYCA6ICcnfWA7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgcmVzICs9IGBcXG4gIOKUnCBhbmNob3IgeyBrZXk6ICR7YW5jaG9yLmtleX0sIG9mZnNldDogJHthbmNob3JPZmZzZXQgPT09IG51bGwgPyAnbnVsbCcgOiBhbmNob3JPZmZzZXR9LCB0eXBlOiAke2FuY2hvci50eXBlfSB9YDtcbiAgcmVzICs9IGBcXG4gIOKUlCBmb2N1cyB7IGtleTogJHtmb2N1cy5rZXl9LCBvZmZzZXQ6ICR7Zm9jdXNPZmZzZXQgPT09IG51bGwgPyAnbnVsbCcgOiBmb2N1c09mZnNldH0sIHR5cGU6ICR7Zm9jdXMudHlwZX0gfWA7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHByaW50Tm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgcmV0dXJuIGA6IG5vZGVcXG4gIOKUlCBbJHtBcnJheS5mcm9tKHNlbGVjdGlvbi5fbm9kZXMpLmpvaW4oJywgJyl9XWA7XG59XG5cbmZ1bmN0aW9uIHByaW50R3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgcmV0dXJuIGA6IGdyaWRcXG4gIOKUlCB7IGdyaWQ6ICR7c2VsZWN0aW9uLmdyaWRLZXl9LCBhbmNob3JDZWxsOiAke3NlbGVjdGlvbi5hbmNob3Iua2V5fSwgZm9jdXNDZWxsOiAke3NlbGVjdGlvbi5mb2N1cy5rZXl9IH1gO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnQoZWRpdG9yLCBjb21tYW5kc0xvZywgZXhwb3J0RE9NKSB7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gZWRpdG9yLmdldEVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IGVkaXRvckNvbmZpZyA9IGVkaXRvci5fY29uZmlnO1xuICBjb25zdCBjb21wb3NpdGlvbktleSA9IGVkaXRvci5fY29tcG9zaXRpb25LZXk7XG4gIGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLl9lZGl0YWJsZTtcblxuICBpZiAoZXhwb3J0RE9NKSB7XG4gICAgbGV0IGh0bWxTdHJpbmcgPSAnJztcbiAgICBlZGl0b3JTdGF0ZS5yZWFkKCgpID0+IHtcbiAgICAgIGh0bWxTdHJpbmcgPSBwcmludFByZXR0eUhUTUwoaHRtbC4kZ2VuZXJhdGVIdG1sRnJvbU5vZGVzKGVkaXRvcikpO1xuICAgIH0pO1xuICAgIHJldHVybiBodG1sU3RyaW5nO1xuICB9XG5cbiAgbGV0IHJlcyA9ICcgcm9vdFxcbic7XG4gIGNvbnN0IHNlbGVjdGlvblN0cmluZyA9IGVkaXRvclN0YXRlLnJlYWQoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuICAgIHZpc2l0VHJlZShsZXhpY2FsLiRnZXRSb290KCksIChub2RlLCBpbmRlbnQpID0+IHtcbiAgICAgIGNvbnN0IG5vZGVLZXkgPSBub2RlLmdldEtleSgpO1xuICAgICAgY29uc3Qgbm9kZUtleURpc3BsYXkgPSBgKCR7bm9kZUtleX0pYDtcbiAgICAgIGNvbnN0IHR5cGVEaXNwbGF5ID0gbm9kZS5nZXRUeXBlKCkgfHwgJyc7XG4gICAgICBjb25zdCBpc1NlbGVjdGVkID0gbm9kZS5pc1NlbGVjdGVkKCk7XG4gICAgICBjb25zdCBpZHNEaXNwbGF5ID0gbWFyay4kaXNNYXJrTm9kZShub2RlKSA/IGAgaWQ6IFsgJHtub2RlLmdldElEcygpLmpvaW4oJywgJyl9IF0gYCA6ICcnO1xuICAgICAgcmVzICs9IGAke2lzU2VsZWN0ZWQgPyBTWU1CT0xTLnNlbGVjdGVkTGluZSA6ICcgJ30gJHtpbmRlbnQuam9pbignICcpfSAke25vZGVLZXlEaXNwbGF5fSAke3R5cGVEaXNwbGF5fSAke2lkc0Rpc3BsYXl9ICR7cHJpbnROb2RlKG5vZGUpfVxcbmA7XG4gICAgICByZXMgKz0gcHJpbnRTZWxlY3RlZENoYXJzTGluZSh7XG4gICAgICAgIGluZGVudCxcbiAgICAgICAgaXNTZWxlY3RlZCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZUtleURpc3BsYXksXG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgdHlwZURpc3BsYXlcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzZWxlY3Rpb24gPT09IG51bGwgPyAnOiBudWxsJyA6IGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSA/IHByaW50UmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSA6IGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikgPyBwcmludEdyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSA6IHByaW50Tm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICB9KTtcbiAgcmVzICs9ICdcXG4gc2VsZWN0aW9uJyArIHNlbGVjdGlvblN0cmluZztcbiAgcmVzICs9ICdcXG5cXG4gY29tbWFuZHM6JztcblxuICBpZiAoY29tbWFuZHNMb2cubGVuZ3RoKSB7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgcGF5bG9hZFxuICAgIH0gb2YgY29tbWFuZHNMb2cpIHtcbiAgICAgIHJlcyArPSBgXFxuICDilJQgeyB0eXBlOiAke3R5cGV9LCBwYXlsb2FkOiAke3BheWxvYWQgaW5zdGFuY2VvZiBFdmVudCA/IHBheWxvYWQuY29uc3RydWN0b3IubmFtZSA6IHBheWxvYWR9IH1gO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMgKz0gJ1xcbiAg4pSUIE5vbmUgZGlzcGF0Y2hlZC4nO1xuICB9XG5cbiAgcmVzICs9ICdcXG5cXG4gZWRpdG9yOic7XG4gIHJlcyArPSBgXFxuICDilJQgbmFtZXNwYWNlICR7ZWRpdG9yQ29uZmlnLm5hbWVzcGFjZX1gO1xuXG4gIGlmIChjb21wb3NpdGlvbktleSAhPT0gbnVsbCkge1xuICAgIHJlcyArPSBgXFxuICDilJQgY29tcG9zaXRpb25LZXkgJHtjb21wb3NpdGlvbktleX1gO1xuICB9XG5cbiAgcmVzICs9IGBcXG4gIOKUlCBlZGl0YWJsZSAke1N0cmluZyhlZGl0YWJsZSl9YDtcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gdmlzaXRUcmVlKGN1cnJlbnROb2RlLCB2aXNpdG9yLCBpbmRlbnQgPSBbXSkge1xuICBjb25zdCBjaGlsZE5vZGVzID0gY3VycmVudE5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgY29uc3QgY2hpbGROb2Rlc0xlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICBjaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSwgaSkgPT4ge1xuICAgIHZpc2l0b3IoY2hpbGROb2RlLCBpbmRlbnQuY29uY2F0KGkgPT09IGNoaWxkTm9kZXNMZW5ndGggLSAxID8gU1lNQk9MUy5pc0xhc3RDaGlsZCA6IFNZTUJPTFMuaGFzTmV4dFNpYmxpbmcpKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGNoaWxkTm9kZSkpIHtcbiAgICAgIHZpc2l0VHJlZShjaGlsZE5vZGUsIHZpc2l0b3IsIGluZGVudC5jb25jYXQoaSA9PT0gY2hpbGROb2Rlc0xlbmd0aCAtIDEgPyBTWU1CT0xTLmFuY2VzdG9ySXNMYXN0Q2hpbGQgOiBTWU1CT0xTLmFuY2VzdG9ySGFzTmV4dFNpYmxpbmcpKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUodGV4dCkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoTk9OX1NJTkdMRV9XSURUSF9DSEFSU19SRVBMQUNFTUVOVCkucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4gYWNjLnJlcGxhY2UobmV3IFJlZ0V4cChrZXksICdnJyksIFN0cmluZyh2YWx1ZSkpLCB0ZXh0KTtcbn0gLy8gVE9ETyBQYXNzIHZpYSBwcm9wcyB0byBhbGxvdyBjdXN0b21pemFiaWxpdHlcblxuXG5mdW5jdGlvbiBwcmludE5vZGUobm9kZSkge1xuICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgY29uc3QgdGl0bGUgPSB0ZXh0Lmxlbmd0aCA9PT0gMCA/ICcoZW1wdHkpJyA6IGBcIiR7bm9ybWFsaXplKHRleHQpfVwiYDtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gcHJpbnRBbGxUZXh0Tm9kZVByb3BlcnRpZXMobm9kZSk7XG4gICAgcmV0dXJuIFt0aXRsZSwgcHJvcGVydGllcy5sZW5ndGggIT09IDAgPyBgeyAke3Byb3BlcnRpZXN9IH1gIDogbnVsbF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKS50cmltKCk7XG4gIH0gZWxzZSBpZiAobGluay4kaXNMaW5rTm9kZShub2RlKSkge1xuICAgIGNvbnN0IGxpbmsgPSBub2RlLmdldFVSTCgpO1xuICAgIGNvbnN0IHRpdGxlID0gbGluay5sZW5ndGggPT09IDAgPyAnKGVtcHR5KScgOiBgXCIke25vcm1hbGl6ZShsaW5rKX1cImA7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IHByaW50QWxsTGlua05vZGVQcm9wZXJ0aWVzKG5vZGUpO1xuICAgIHJldHVybiBbdGl0bGUsIHByb3BlcnRpZXMubGVuZ3RoICE9PSAwID8gYHsgJHtwcm9wZXJ0aWVzfSB9YCA6IG51bGxdLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJykudHJpbSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5jb25zdCBGT1JNQVRfUFJFRElDQVRFUyA9IFtub2RlID0+IG5vZGUuaGFzRm9ybWF0KCdib2xkJykgJiYgJ0JvbGQnLCBub2RlID0+IG5vZGUuaGFzRm9ybWF0KCdjb2RlJykgJiYgJ0NvZGUnLCBub2RlID0+IG5vZGUuaGFzRm9ybWF0KCdpdGFsaWMnKSAmJiAnSXRhbGljJywgbm9kZSA9PiBub2RlLmhhc0Zvcm1hdCgnc3RyaWtldGhyb3VnaCcpICYmICdTdHJpa2V0aHJvdWdoJywgbm9kZSA9PiBub2RlLmhhc0Zvcm1hdCgnc3Vic2NyaXB0JykgJiYgJ1N1YnNjcmlwdCcsIG5vZGUgPT4gbm9kZS5oYXNGb3JtYXQoJ3N1cGVyc2NyaXB0JykgJiYgJ1N1cGVyc2NyaXB0Jywgbm9kZSA9PiBub2RlLmhhc0Zvcm1hdCgndW5kZXJsaW5lJykgJiYgJ1VuZGVybGluZSddO1xuY29uc3QgREVUQUlMX1BSRURJQ0FURVMgPSBbbm9kZSA9PiBub2RlLmlzRGlyZWN0aW9ubGVzcygpICYmICdEaXJlY3Rpb25sZXNzJywgbm9kZSA9PiBub2RlLmlzVW5tZXJnZWFibGUoKSAmJiAnVW5tZXJnZWFibGUnXTtcbmNvbnN0IE1PREVfUFJFRElDQVRFUyA9IFtub2RlID0+IG5vZGUuaXNUb2tlbigpICYmICdUb2tlbicsIG5vZGUgPT4gbm9kZS5pc1NlZ21lbnRlZCgpICYmICdTZWdtZW50ZWQnXTtcblxuZnVuY3Rpb24gcHJpbnRBbGxUZXh0Tm9kZVByb3BlcnRpZXMobm9kZSkge1xuICByZXR1cm4gW3ByaW50Rm9ybWF0UHJvcGVydGllcyhub2RlKSwgcHJpbnREZXRhaWxQcm9wZXJ0aWVzKG5vZGUpLCBwcmludE1vZGVQcm9wZXJ0aWVzKG5vZGUpXS5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRBbGxMaW5rTm9kZVByb3BlcnRpZXMobm9kZSkge1xuICByZXR1cm4gW3ByaW50VGFyZ2V0UHJvcGVydGllcyhub2RlKSwgcHJpbnRSZWxQcm9wZXJ0aWVzKG5vZGUpLCBwcmludFRpdGxlUHJvcGVydGllcyhub2RlKV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJyk7XG59XG5cbmZ1bmN0aW9uIHByaW50RGV0YWlsUHJvcGVydGllcyhub2RlT3JTZWxlY3Rpb24pIHtcbiAgbGV0IHN0ciA9IERFVEFJTF9QUkVESUNBVEVTLm1hcChwcmVkaWNhdGUgPT4gcHJlZGljYXRlKG5vZGVPclNlbGVjdGlvbikpLmZpbHRlcihCb29sZWFuKS5qb2luKCcsICcpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHN0ciAhPT0gJycpIHtcbiAgICBzdHIgPSAnZGV0YWlsOiAnICsgc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gcHJpbnRNb2RlUHJvcGVydGllcyhub2RlT3JTZWxlY3Rpb24pIHtcbiAgbGV0IHN0ciA9IE1PREVfUFJFRElDQVRFUy5tYXAocHJlZGljYXRlID0+IHByZWRpY2F0ZShub2RlT3JTZWxlY3Rpb24pKS5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuXG4gIGlmIChzdHIgIT09ICcnKSB7XG4gICAgc3RyID0gJ21vZGU6ICcgKyBzdHI7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBwcmludEZvcm1hdFByb3BlcnRpZXMobm9kZU9yU2VsZWN0aW9uKSB7XG4gIGxldCBzdHIgPSBGT1JNQVRfUFJFRElDQVRFUy5tYXAocHJlZGljYXRlID0+IHByZWRpY2F0ZShub2RlT3JTZWxlY3Rpb24pKS5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuXG4gIGlmIChzdHIgIT09ICcnKSB7XG4gICAgc3RyID0gJ2Zvcm1hdDogJyArIHN0cjtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHByaW50VGFyZ2V0UHJvcGVydGllcyhub2RlKSB7XG4gIGxldCBzdHIgPSBub2RlLmdldFRhcmdldCgpOyAvLyBUT0RPIEZpeCBudWxsaXNoIG9uIExpbmtOb2RlXG5cbiAgaWYgKHN0ciAhPSBudWxsKSB7XG4gICAgc3RyID0gJ3RhcmdldDogJyArIHN0cjtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHByaW50UmVsUHJvcGVydGllcyhub2RlKSB7XG4gIGxldCBzdHIgPSBub2RlLmdldFJlbCgpOyAvLyBUT0RPIEZpeCBudWxsaXNoIG9uIExpbmtOb2RlXG5cbiAgaWYgKHN0ciAhPSBudWxsKSB7XG4gICAgc3RyID0gJ3JlbDogJyArIHN0cjtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHByaW50VGl0bGVQcm9wZXJ0aWVzKG5vZGUpIHtcbiAgbGV0IHN0ciA9IG5vZGUuZ2V0VGl0bGUoKTsgLy8gVE9ETyBGaXggbnVsbGlzaCBvbiBMaW5rTm9kZVxuXG4gIGlmIChzdHIgIT0gbnVsbCkge1xuICAgIHN0ciA9ICd0aXRsZTogJyArIHN0cjtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHByaW50U2VsZWN0ZWRDaGFyc0xpbmUoe1xuICBpbmRlbnQsXG4gIGlzU2VsZWN0ZWQsXG4gIG5vZGUsXG4gIG5vZGVLZXlEaXNwbGF5LFxuICBzZWxlY3Rpb24sXG4gIHR5cGVEaXNwbGF5XG59KSB7XG4gIC8vIE5vIHNlbGVjdGlvbiBvciBub2RlIGlzIG5vdCBzZWxlY3RlZC5cbiAgaWYgKCFsZXhpY2FsLiRpc1RleHROb2RlKG5vZGUpIHx8ICFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgIWlzU2VsZWN0ZWQgfHwgbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIHJldHVybiAnJztcbiAgfSAvLyBObyBzZWxlY3RlZCBjaGFyYWN0ZXJzLlxuXG5cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG5cbiAgaWYgKG5vZGUuZ2V0VGV4dENvbnRlbnQoKSA9PT0gJycgfHwgYW5jaG9yLmdldE5vZGUoKSA9PT0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKSAmJiBhbmNob3Iub2Zmc2V0ID09PSBmb2N1cy5vZmZzZXQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBjb25zdCBbc3RhcnQsIGVuZF0gPSAkZ2V0U2VsZWN0aW9uU3RhcnRFbmQobm9kZSwgc2VsZWN0aW9uKTtcblxuICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdGlvbkxhc3RJbmRlbnQgPSBpbmRlbnRbaW5kZW50Lmxlbmd0aCAtIDFdID09PSBTWU1CT0xTLmhhc05leHRTaWJsaW5nID8gU1lNQk9MUy5hbmNlc3Rvckhhc05leHRTaWJsaW5nIDogU1lNQk9MUy5hbmNlc3RvcklzTGFzdENoaWxkO1xuICBjb25zdCBpbmRlbnRpb25DaGFycyA9IFsuLi5pbmRlbnQuc2xpY2UoMCwgaW5kZW50Lmxlbmd0aCAtIDEpLCBzZWxlY3Rpb25MYXN0SW5kZW50XTtcbiAgY29uc3QgdW5zZWxlY3RlZENoYXJzID0gQXJyYXkoc3RhcnQgKyAxKS5maWxsKCcgJyk7XG4gIGNvbnN0IHNlbGVjdGVkQ2hhcnMgPSBBcnJheShlbmQgLSBzdGFydCkuZmlsbChTWU1CT0xTLnNlbGVjdGVkQ2hhcik7XG4gIGNvbnN0IHBhZGRpbmdMZW5ndGggPSB0eXBlRGlzcGxheS5sZW5ndGggKyAzOyAvLyAyIGZvciB0aGUgc3BhY2VzIGFyb3VuZCArIDEgZm9yIHRoZSBkb3VibGUgcXVvdGUuXG5cbiAgY29uc3Qgbm9kZVByaW50U3BhY2VzID0gQXJyYXkobm9kZUtleURpc3BsYXkubGVuZ3RoICsgcGFkZGluZ0xlbmd0aCkuZmlsbCgnICcpO1xuICByZXR1cm4gW1NZTUJPTFMuc2VsZWN0ZWRMaW5lLCBpbmRlbnRpb25DaGFycy5qb2luKCcgJyksIFsuLi5ub2RlUHJpbnRTcGFjZXMsIC4uLnVuc2VsZWN0ZWRDaGFycywgLi4uc2VsZWN0ZWRDaGFyc10uam9pbignJyldLmpvaW4oJyAnKSArICdcXG4nO1xufVxuXG5mdW5jdGlvbiBwcmludFByZXR0eUhUTUwoc3RyKSB7XG4gIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gc3RyLnRyaW0oKTtcbiAgcmV0dXJuIHByZXR0aWZ5SFRNTChkaXYsIDApLmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gcHJldHRpZnlIVE1MKG5vZGUsIGxldmVsKSB7XG4gIGNvbnN0IGluZGVudEJlZm9yZSA9IG5ldyBBcnJheShsZXZlbCsrICsgMSkuam9pbignICAnKTtcbiAgY29uc3QgaW5kZW50QWZ0ZXIgPSBuZXcgQXJyYXkobGV2ZWwgLSAxKS5qb2luKCcgICcpO1xuICBsZXQgdGV4dE5vZGU7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFxuJyArIGluZGVudEJlZm9yZSk7XG4gICAgbm9kZS5pbnNlcnRCZWZvcmUodGV4dE5vZGUsIG5vZGUuY2hpbGRyZW5baV0pO1xuICAgIHByZXR0aWZ5SFRNTChub2RlLmNoaWxkcmVuW2ldLCBsZXZlbCk7XG5cbiAgICBpZiAobm9kZS5sYXN0RWxlbWVudENoaWxkID09PSBub2RlLmNoaWxkcmVuW2ldKSB7XG4gICAgICB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXG4nICsgaW5kZW50QWZ0ZXIpO1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uICRnZXRTZWxlY3Rpb25TdGFydEVuZChub2RlLCBzZWxlY3Rpb24pIHtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IHRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICBjb25zdCB0ZXh0TGVuZ3RoID0gdGV4dENvbnRlbnQubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IC0xOyAvLyBPbmx5IG9uZSBub2RlIGlzIGJlaW5nIHNlbGVjdGVkLlxuXG4gIGlmIChhbmNob3IudHlwZSA9PT0gJ3RleHQnICYmIGZvY3VzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcblxuICAgIGlmIChhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiYgbm9kZSA9PT0gYW5jaG9yTm9kZSAmJiBhbmNob3Iub2Zmc2V0ICE9PSBmb2N1cy5vZmZzZXQpIHtcbiAgICAgIFtzdGFydCwgZW5kXSA9IGFuY2hvci5vZmZzZXQgPCBmb2N1cy5vZmZzZXQgPyBbYW5jaG9yLm9mZnNldCwgZm9jdXMub2Zmc2V0XSA6IFtmb2N1cy5vZmZzZXQsIGFuY2hvci5vZmZzZXRdO1xuICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gYW5jaG9yTm9kZSkge1xuICAgICAgW3N0YXJ0LCBlbmRdID0gYW5jaG9yTm9kZS5pc0JlZm9yZShmb2N1c05vZGUpID8gW2FuY2hvci5vZmZzZXQsIHRleHRMZW5ndGhdIDogWzAsIGFuY2hvci5vZmZzZXRdO1xuICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gZm9jdXNOb2RlKSB7XG4gICAgICBbc3RhcnQsIGVuZF0gPSBmb2N1c05vZGUuaXNCZWZvcmUoYW5jaG9yTm9kZSkgPyBbZm9jdXMub2Zmc2V0LCB0ZXh0TGVuZ3RoXSA6IFswLCBmb2N1cy5vZmZzZXRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb2RlIGlzIHdpdGhpbiBzZWxlY3Rpb24gYnV0IG5vdCB0aGUgYW5jaG9yIG5vciBmb2N1cy5cbiAgICAgIFtzdGFydCwgZW5kXSA9IFswLCB0ZXh0TGVuZ3RoXTtcbiAgICB9XG4gIH0gLy8gQWNjb3VudCBmb3Igbm9uLXNpbmdsZSB3aWR0aCBjaGFyYWN0ZXJzLlxuXG5cbiAgY29uc3QgbnVtTm9uU2luZ2xlV2lkdGhDaGFyQmVmb3JlU2VsZWN0aW9uID0gKHRleHRDb250ZW50LnNsaWNlKDAsIHN0YXJ0KS5tYXRjaChOT05fU0lOR0xFX1dJRFRIX0NIQVJTX1JFR0VYKSB8fCBbXSkubGVuZ3RoO1xuICBjb25zdCBudW1Ob25TaW5nbGVXaWR0aENoYXJJblNlbGVjdGlvbiA9ICh0ZXh0Q29udGVudC5zbGljZShzdGFydCwgZW5kKS5tYXRjaChOT05fU0lOR0xFX1dJRFRIX0NIQVJTX1JFR0VYKSB8fCBbXSkubGVuZ3RoO1xuICByZXR1cm4gW3N0YXJ0ICsgbnVtTm9uU2luZ2xlV2lkdGhDaGFyQmVmb3JlU2VsZWN0aW9uLCBlbmQgKyBudW1Ob25TaW5nbGVXaWR0aENoYXJCZWZvcmVTZWxlY3Rpb24gKyBudW1Ob25TaW5nbGVXaWR0aENoYXJJblNlbGVjdGlvbl07XG59XG5cbmV4cG9ydHMuVHJlZVZpZXcgPSBUcmVlVmlldztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalTreeView.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/LexicalTreeView.js":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTreeView.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalTreeView =  true ? __webpack_require__(/*! ./LexicalTreeView.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalTreeView.dev.js\") : 0\nmodule.exports = LexicalTreeView;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsVHJlZVZpZXcuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWix3QkFBd0IsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLDBHQUEwQixJQUFJLENBQW9DO0FBQzNJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsVHJlZVZpZXcuanM/MzBjYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbFRyZWVWaWV3ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxUcmVlVmlldy5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbFRyZWVWaWV3LnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsVHJlZVZpZXc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/LexicalTreeView.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/useLexicalEditable.dev.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalEditable.dev.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? react.useLayoutEffect : react.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Shortcut to Lexical subscriptions when values are used for render.\n */\nfunction useLexicalSubscription(subscription) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const initializedSubscription = react.useMemo(() => subscription(editor), [editor, subscription]);\n  const valueRef = react.useRef(initializedSubscription.initialValueFn());\n  const [value, setValue] = react.useState(valueRef.current);\n  useLayoutEffect(() => {\n    const {\n      initialValueFn,\n      subscribe\n    } = initializedSubscription;\n    const currentValue = initialValueFn();\n\n    if (valueRef.current !== currentValue) {\n      valueRef.current = currentValue;\n      setValue(currentValue);\n    }\n\n    return subscribe(newValue => {\n      valueRef.current = newValue;\n      setValue(newValue);\n    });\n  }, [initializedSubscription, subscription]);\n  return value;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction subscription(editor) {\n  return {\n    initialValueFn: () => editor.isEditable(),\n    subscribe: callback => {\n      return editor.registerEditableListener(callback);\n    }\n  };\n}\n\nfunction useLexicalEditable() {\n  return useLexicalSubscription(subscription);\n}\n\nmodule.exports = useLexicalEditable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsRWRpdGFibGUuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLDBIQUF1QztBQUM1RSxZQUFZLG1CQUFPLENBQUMsbUZBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L3VzZUxleGljYWxFZGl0YWJsZS5kZXYuanM/ZDlhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IHVzZUxheW91dEVmZmVjdEltcGwgPSBDQU5fVVNFX0RPTSA/IHJlYWN0LnVzZUxheW91dEVmZmVjdCA6IHJlYWN0LnVzZUVmZmVjdDtcbnZhciB1c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3RJbXBsO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogU2hvcnRjdXQgdG8gTGV4aWNhbCBzdWJzY3JpcHRpb25zIHdoZW4gdmFsdWVzIGFyZSB1c2VkIGZvciByZW5kZXIuXG4gKi9cbmZ1bmN0aW9uIHVzZUxleGljYWxTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IGluaXRpYWxpemVkU3Vic2NyaXB0aW9uID0gcmVhY3QudXNlTWVtbygoKSA9PiBzdWJzY3JpcHRpb24oZWRpdG9yKSwgW2VkaXRvciwgc3Vic2NyaXB0aW9uXSk7XG4gIGNvbnN0IHZhbHVlUmVmID0gcmVhY3QudXNlUmVmKGluaXRpYWxpemVkU3Vic2NyaXB0aW9uLmluaXRpYWxWYWx1ZUZuKCkpO1xuICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IHJlYWN0LnVzZVN0YXRlKHZhbHVlUmVmLmN1cnJlbnQpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGluaXRpYWxWYWx1ZUZuLFxuICAgICAgc3Vic2NyaWJlXG4gICAgfSA9IGluaXRpYWxpemVkU3Vic2NyaXB0aW9uO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGluaXRpYWxWYWx1ZUZuKCk7XG5cbiAgICBpZiAodmFsdWVSZWYuY3VycmVudCAhPT0gY3VycmVudFZhbHVlKSB7XG4gICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gY3VycmVudFZhbHVlO1xuICAgICAgc2V0VmFsdWUoY3VycmVudFZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Vic2NyaWJlKG5ld1ZhbHVlID0+IHtcbiAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXdWYWx1ZTtcbiAgICAgIHNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICB9KTtcbiAgfSwgW2luaXRpYWxpemVkU3Vic2NyaXB0aW9uLCBzdWJzY3JpcHRpb25dKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHN1YnNjcmlwdGlvbihlZGl0b3IpIHtcbiAgcmV0dXJuIHtcbiAgICBpbml0aWFsVmFsdWVGbjogKCkgPT4gZWRpdG9yLmlzRWRpdGFibGUoKSxcbiAgICBzdWJzY3JpYmU6IGNhbGxiYWNrID0+IHtcbiAgICAgIHJldHVybiBlZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZUxleGljYWxFZGl0YWJsZSgpIHtcbiAgcmV0dXJuIHVzZUxleGljYWxTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1c2VMZXhpY2FsRWRpdGFibGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/useLexicalEditable.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/useLexicalEditable.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalEditable.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst useLexicalEditable =  true ? __webpack_require__(/*! ./useLexicalEditable.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/useLexicalEditable.dev.js\") : 0\nmodule.exports = useLexicalEditable;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsRWRpdGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWiwyQkFBMkIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLGdIQUE2QixJQUFJLENBQXVDO0FBQ3BKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsRWRpdGFibGUuanM/NDE4MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgdXNlTGV4aWNhbEVkaXRhYmxlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL3VzZUxleGljYWxFZGl0YWJsZS5kZXYuanMnKSA6IHJlcXVpcmUoJy4vdXNlTGV4aWNhbEVkaXRhYmxlLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSB1c2VMZXhpY2FsRWRpdGFibGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/useLexicalEditable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/useLexicalNodeSelection.dev.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalNodeSelection.dev.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\nvar react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction isNodeSelected(editor, key) {\n  return editor.getEditorState().read(() => {\n    const node = lexical.$getNodeByKey(key);\n\n    if (node === null) {\n      return false;\n    }\n\n    return node.isSelected();\n  });\n}\n\nfunction useLexicalNodeSelection(key) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isSelected, setIsSelected] = react.useState(() => isNodeSelected(editor, key));\n  react.useEffect(() => {\n    let isMounted = true;\n    const unregister = editor.registerUpdateListener(() => {\n      if (isMounted) {\n        setIsSelected(isNodeSelected(editor, key));\n      }\n    });\n    return () => {\n      isMounted = false;\n      unregister();\n    };\n  }, [editor, key]);\n  const setSelected = react.useCallback(selected => {\n    editor.update(() => {\n      let selection = lexical.$getSelection();\n\n      if (!lexical.$isNodeSelection(selection)) {\n        selection = lexical.$createNodeSelection();\n        lexical.$setSelection(selection);\n      }\n\n      if (selected) {\n        selection.add(key);\n      } else {\n        selection.delete(key);\n      }\n    });\n  }, [editor, key]);\n  const clearSelected = react.useCallback(() => {\n    editor.update(() => {\n      const selection = lexical.$getSelection();\n\n      if (lexical.$isNodeSelection(selection)) {\n        selection.clear();\n      }\n    });\n  }, [editor]);\n  return [isSelected, setSelected, clearSelected];\n}\n\nexports.useLexicalNodeSelection = useLexicalNodeSelection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsTm9kZVNlbGVjdGlvbi5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsMEhBQXVDO0FBQzVFLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsbUZBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUEsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsTm9kZVNlbGVjdGlvbi5kZXYuanM/ODhlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gaXNOb2RlU2VsZWN0ZWQoZWRpdG9yLCBrZXkpIHtcbiAgcmV0dXJuIGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoKCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROb2RlQnlLZXkoa2V5KTtcblxuICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGUuaXNTZWxlY3RlZCgpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24oa2V5KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IFtpc1NlbGVjdGVkLCBzZXRJc1NlbGVjdGVkXSA9IHJlYWN0LnVzZVN0YXRlKCgpID0+IGlzTm9kZVNlbGVjdGVkKGVkaXRvciwga2V5KSk7XG4gIHJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlzTW91bnRlZCA9IHRydWU7XG4gICAgY29uc3QgdW5yZWdpc3RlciA9IGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgc2V0SXNTZWxlY3RlZChpc05vZGVTZWxlY3RlZChlZGl0b3IsIGtleSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHVucmVnaXN0ZXIoKTtcbiAgICB9O1xuICB9LCBbZWRpdG9yLCBrZXldKTtcbiAgY29uc3Qgc2V0U2VsZWN0ZWQgPSByZWFjdC51c2VDYWxsYmFjayhzZWxlY3RlZCA9PiB7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBsZXQgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmICghbGV4aWNhbC4kaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgc2VsZWN0aW9uID0gbGV4aWNhbC4kY3JlYXRlTm9kZVNlbGVjdGlvbigpO1xuICAgICAgICBsZXhpY2FsLiRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgIHNlbGVjdGlvbi5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvbi5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2VkaXRvciwga2V5XSk7XG4gIGNvbnN0IGNsZWFyU2VsZWN0ZWQgPSByZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKGxleGljYWwuJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIHNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbZWRpdG9yXSk7XG4gIHJldHVybiBbaXNTZWxlY3RlZCwgc2V0U2VsZWN0ZWQsIGNsZWFyU2VsZWN0ZWRdO1xufVxuXG5leHBvcnRzLnVzZUxleGljYWxOb2RlU2VsZWN0aW9uID0gdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/useLexicalNodeSelection.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/react/useLexicalNodeSelection.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalNodeSelection.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst useLexicalNodeSelection =  true ? __webpack_require__(/*! ./useLexicalNodeSelection.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/react/useLexicalNodeSelection.dev.js\") : 0\nmodule.exports = useLexicalNodeSelection;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsTm9kZVNlbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLGdDQUFnQyxLQUFzQyxHQUFHLG1CQUFPLENBQUMsMEhBQWtDLElBQUksQ0FBNEM7QUFDbksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L3VzZUxleGljYWxOb2RlU2VsZWN0aW9uLmpzPzdjY2MiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IHVzZUxleGljYWxOb2RlU2VsZWN0aW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL3VzZUxleGljYWxOb2RlU2VsZWN0aW9uLmRldi5qcycpIDogcmVxdWlyZSgnLi91c2VMZXhpY2FsTm9kZVNlbGVjdGlvbi5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb247Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/react/useLexicalNodeSelection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/rich-text/LexicalRichText.dev.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/rich-text/LexicalRichText.dev.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar clipboard = __webpack_require__(/*! @lexical/clipboard */ \"(app-pages-browser)/./node_modules/@lexical/clipboard/LexicalClipboard.js\");\nvar selection = __webpack_require__(/*! @lexical/selection */ \"(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n\n    if (range === null) {\n      return null;\n    }\n\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    }; // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n\n    if (range === null) {\n      return null;\n    }\n\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/** @module @lexical/rich-text */\nconst DRAG_DROP_PASTE = lexical.createCommand('DRAG_DROP_PASTE_FILE');\n\n/** @noInheritDoc */\nclass QuoteNode extends lexical.ElementNode {\n  static getType() {\n    return 'quote';\n  }\n\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n\n  constructor(key) {\n    super(key);\n  } // View\n\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    utils.addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element && this.isEmpty()) {\n      element.append(document.createElement('br'));\n    }\n\n    if (element) {\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'quote'\n    };\n  } // Mutation\n\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n}\nfunction $createQuoteNode() {\n  return lexical.$applyNodeReplacement(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n\n/** @noInheritDoc */\nclass HeadingNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'heading';\n  }\n\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n\n  getTag() {\n    return this.__tag;\n  } // View\n\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      utils.addClassNamesToElement(element, className);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n\n        return null;\n      }\n    };\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element && this.isEmpty()) {\n      element.append(document.createElement('br'));\n    }\n\n    if (element) {\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const newElement = anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n\n  extractWithChild() {\n    return true;\n  }\n\n}\n\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n\n  return false;\n}\n\nfunction convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n\n    if (element.style !== null) {\n      node.setFormat(element.style.textAlign);\n    }\n  }\n\n  return {\n    node\n  };\n}\n\nfunction convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n  }\n\n  return {\n    node\n  };\n}\n\nfunction $createHeadingNode(headingTag) {\n  return lexical.$applyNodeReplacement(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\n\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;\n\n    if (clipboardData != null && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n      clipboard.$insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\n\nasync function onCutForRichText(event, editor) {\n  await clipboard.copyToClipboard(editor, utils.objectKlassEquals(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      selection.removeText();\n    } else if (lexical.$isNodeSelection(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n} // Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain ocassions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\n\n\nfunction eventFiles(event) {\n  let dataTransfer = null;\n\n  if (event instanceof DragEvent) {\n    dataTransfer = event.dataTransfer;\n  } else if (event instanceof ClipboardEvent) {\n    dataTransfer = event.clipboardData;\n  }\n\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\n\nfunction handleIndentAndOutdent(indentOrOutdent) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n\n    const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);\n    const parentKey = parentBlock.getKey();\n\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n\n  return alreadyHandled.size > 0;\n}\n\nfunction $isTargetWithinDecorator(target) {\n  const node = lexical.$getNearestNodeFromDOMNode(target);\n  return lexical.$isDecoratorNode(node);\n}\n\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === lexical.$getRoot().getChildrenSize();\n}\n\nfunction registerRichText(editor) {\n  const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n\n    return false;\n  }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = lexical.$getSelection();\n\n    if (typeof eventOrText === 'string') {\n      if (lexical.$isRangeSelection(selection)) {\n        selection.insertText(eventOrText);\n      } else if (lexical.DEPRECATED_$isGridSelection(selection)) ;\n    } else {\n      if (!lexical.$isRangeSelection(selection) && !lexical.DEPRECATED_$isGridSelection(selection)) {\n        return false;\n      }\n\n      const dataTransfer = eventOrText.dataTransfer;\n\n      if (dataTransfer != null) {\n        clipboard.$insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if (lexical.$isRangeSelection(selection)) {\n        const data = eventOrText.data;\n\n        if (data) {\n          selection.insertText(data);\n        }\n\n        return true;\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.removeText();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.formatText(format);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection) && !lexical.$isNodeSelection(selection)) {\n      return false;\n    }\n\n    const nodes = selection.getNodes();\n\n    for (const node of nodes) {\n      const element = utils.$findMatchingParent(node, parentNode => lexical.$isElementNode(parentNode) && !parentNode.isInline());\n\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertParagraph();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_TAB_COMMAND, () => {\n    lexical.$insertNodes([lexical.$createTabNode()]);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {\n    return handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {\n    return handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n\n      if (indent > 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if (lexical.$isRangeSelection(selection)) {\n      const possibleNode = lexical.$getAdjacentNode(selection.focus, true);\n\n      if (!event.shiftKey && lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if (lexical.$isRangeSelection(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n\n      const possibleNode = lexical.$getAdjacentNode(selection.focus, false);\n\n      if (!event.shiftKey && lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection$1)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, true);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection$1) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    const isHoldingShift = event.shiftKey;\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, false);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n\n    if (selection.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);\n\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n\n      event.preventDefault();\n\n      if (event.shiftKey) {\n        return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n\n    return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, undefined);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    editor.blur();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = lexical.$getNearestNodeFromDOMNode(domNode);\n\n        if (node !== null) {\n          const selection = lexical.$createRangeSelection();\n\n          if (lexical.$isTextNode(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n\n          const normalizedSelection = lexical.$normalizeSelection__EXPERIMENTAL(selection);\n          lexical.$setSelection(normalizedSelection);\n        }\n\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n\n      event.preventDefault();\n      return true;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = lexical.$getSelection();\n\n    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = lexical.$getSelection();\n\n    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n\n    if (eventRange !== null) {\n      const node = lexical.$getNearestNodeFromDOMNode(eventRange.node);\n\n      if (lexical.$isDecoratorNode(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, event => {\n    clipboard.copyToClipboard(editor, utils.objectKlassEquals(event, ClipboardEvent) ? event : null);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    } // if inputs then paste within the input ignore creating a new node on paste event\n\n\n    if (lexical.isSelectionCapturedInDecoratorInput(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\nexports.$createHeadingNode = $createHeadingNode;\nexports.$createQuoteNode = $createQuoteNode;\nexports.$isHeadingNode = $isHeadingNode;\nexports.$isQuoteNode = $isQuoteNode;\nexports.DRAG_DROP_PASTE = DRAG_DROP_PASTE;\nexports.HeadingNode = HeadingNode;\nexports.QuoteNode = QuoteNode;\nexports.eventFiles = eventFiles;\nexports.registerRichText = registerRichText;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yaWNoLXRleHQvTGV4aWNhbFJpY2hUZXh0LmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQyxxR0FBb0I7QUFDNUMsZ0JBQWdCLG1CQUFPLENBQUMscUdBQW9CO0FBQzVDLFlBQVksbUJBQU8sQ0FBQyx5RkFBZ0I7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLHNFQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRzs7QUFFQSwrRUFBK0U7O0FBRS9FOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmljaC10ZXh0L0xleGljYWxSaWNoVGV4dC5kZXYuanM/NzYwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNsaXBib2FyZCA9IHJlcXVpcmUoJ0BsZXhpY2FsL2NsaXBib2FyZCcpO1xudmFyIHNlbGVjdGlvbiA9IHJlcXVpcmUoJ0BsZXhpY2FsL3NlbGVjdGlvbicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQGxleGljYWwvdXRpbHMnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBjYXJldEZyb21Qb2ludCh4LCB5KSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG5cbiAgICBpZiAocmFuZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBub2RlOiByYW5nZS5zdGFydENvbnRhaW5lcixcbiAgICAgIG9mZnNldDogcmFuZ2Uuc3RhcnRPZmZzZXRcbiAgICB9OyAvLyBAdHMtaWdub3JlXG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBAdHMtaWdub3JlIEZGIC0gbm8gdHlwZXNcbiAgICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG5cbiAgICBpZiAocmFuZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBub2RlOiByYW5nZS5vZmZzZXROb2RlLFxuICAgICAgb2Zmc2V0OiByYW5nZS5vZmZzZXRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIEdyYWNlZnVsbHkgaGFuZGxlIElFXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IG51bGw7XG5DQU5fVVNFX0RPTSAmJiAvTWFjfGlQb2R8aVBob25lfGlQYWQvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbkNBTl9VU0VfRE9NICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94KS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IENBTl9VU0VfQkVGT1JFX0lOUFVUID0gQ0FOX1VTRV9ET00gJiYgJ0lucHV0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlID8gJ2dldFRhcmdldFJhbmdlcycgaW4gbmV3IHdpbmRvdy5JbnB1dEV2ZW50KCdpbnB1dCcpIDogZmFsc2U7XG5jb25zdCBJU19TQUZBUkkgPSBDQU5fVVNFX0RPTSAmJiAvVmVyc2lvblxcL1tcXGQuXSsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0lPUyA9IENBTl9VU0VfRE9NICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07IC8vIEtlZXAgdGhlc2UgaW4gY2FzZSB3ZSBuZWVkIHRvIHVzZSB0aGVtIGluIHRoZSBmdXR1cmUuXG4vLyBleHBvcnQgY29uc3QgSVNfV0lORE9XUzogYm9vbGVhbiA9IENBTl9VU0VfRE9NICYmIC9XaW4vLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcblxuY29uc3QgSVNfQ0hST01FID0gQ0FOX1VTRV9ET00gJiYgL14oPz0uKkNocm9tZSkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIGV4cG9ydCBjb25zdCBjYW5Vc2VUZXh0SW5wdXRFdmVudDogYm9vbGVhbiA9IENBTl9VU0VfRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlO1xuXG5jb25zdCBJU19BUFBMRV9XRUJLSVQgPSBDQU5fVVNFX0RPTSAmJiAvQXBwbGVXZWJLaXRcXC9bXFxkLl0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFJU19DSFJPTUU7XG5cbi8qKiBAbW9kdWxlIEBsZXhpY2FsL3JpY2gtdGV4dCAqL1xuY29uc3QgRFJBR19EUk9QX1BBU1RFID0gbGV4aWNhbC5jcmVhdGVDb21tYW5kKCdEUkFHX0RST1BfUEFTVEVfRklMRScpO1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgUXVvdGVOb2RlIGV4dGVuZHMgbGV4aWNhbC5FbGVtZW50Tm9kZSB7XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAncXVvdGUnO1xuICB9XG5cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFF1b3RlTm9kZShub2RlLl9fa2V5KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gIH0gLy8gVmlld1xuXG5cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdibG9ja3F1b3RlJyk7XG4gICAgdXRpbHMuYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjb25maWcudGhlbWUucXVvdGUpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBibG9ja3F1b3RlOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRCbG9ja3F1b3RlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50XG4gICAgfSA9IHN1cGVyLmV4cG9ydERPTShlZGl0b3IpO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIGVsZW1lbnQuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJykpO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBjb25zdCBmb3JtYXRUeXBlID0gdGhpcy5nZXRGb3JtYXRUeXBlKCk7XG4gICAgICBlbGVtZW50LnN0eWxlLnRleHRBbGlnbiA9IGZvcm1hdFR5cGU7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldERpcmVjdGlvbigpO1xuXG4gICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGVsZW1lbnQuZGlyID0gZGlyZWN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVRdW90ZU5vZGUoKTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgdHlwZTogJ3F1b3RlJ1xuICAgIH07XG4gIH0gLy8gTXV0YXRpb25cblxuXG4gIGluc2VydE5ld0FmdGVyKF8sIHJlc3RvcmVTZWxlY3Rpb24pIHtcbiAgICBjb25zdCBuZXdCbG9jayA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldERpcmVjdGlvbigpO1xuICAgIG5ld0Jsb2NrLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobmV3QmxvY2ssIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIHJldHVybiBuZXdCbG9jaztcbiAgfVxuXG4gIGNvbGxhcHNlQXRTdGFydCgpIHtcbiAgICBjb25zdCBwYXJhZ3JhcGggPSBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBwYXJhZ3JhcGguYXBwZW5kKGNoaWxkKSk7XG4gICAgdGhpcy5yZXBsYWNlKHBhcmFncmFwaCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufVxuZnVuY3Rpb24gJGNyZWF0ZVF1b3RlTm9kZSgpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBRdW90ZU5vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNRdW90ZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFF1b3RlTm9kZTtcbn1cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIEhlYWRpbmdOb2RlIGV4dGVuZHMgbGV4aWNhbC5FbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdoZWFkaW5nJztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBIZWFkaW5nTm9kZShub2RlLl9fdGFnLCBub2RlLl9fa2V5KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHRhZywga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fdGFnID0gdGFnO1xuICB9XG5cbiAgZ2V0VGFnKCkge1xuICAgIHJldHVybiB0aGlzLl9fdGFnO1xuICB9IC8vIFZpZXdcblxuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLl9fdGFnO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgY29uc3QgdGhlbWUgPSBjb25maWcudGhlbWU7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IHRoZW1lLmhlYWRpbmc7XG5cbiAgICBpZiAoY2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc05hbWVzW3RhZ107XG4gICAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGgxOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDI6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoMzogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0SGVhZGluZ0VsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIGg0OiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDU6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoNjogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0SGVhZGluZ0VsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHA6IG5vZGUgPT4ge1xuICAgICAgICAvLyBkb21Ob2RlIGlzIGEgPHA+IHNpbmNlIHdlIG1hdGNoZWQgaXQgYnkgbm9kZU5hbWVcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gbm9kZTtcbiAgICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IHBhcmFncmFwaC5maXJzdENoaWxkO1xuXG4gICAgICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsICYmIGlzR29vZ2xlRG9jc1RpdGxlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb246ICgpID0+ICh7XG4gICAgICAgICAgICAgIG5vZGU6IG51bGxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgc3Bhbjogbm9kZSA9PiB7XG4gICAgICAgIGlmIChpc0dvb2dsZURvY3NUaXRsZShub2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzaW9uOiBkb21Ob2RlID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBub2RlOiAkY3JlYXRlSGVhZGluZ05vZGUoJ2gxJylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmlvcml0eTogM1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG5cbiAgICBpZiAoZWxlbWVudCAmJiB0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgZWxlbWVudC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKSk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGZvcm1hdFR5cGUgPSB0aGlzLmdldEZvcm1hdFR5cGUoKTtcbiAgICAgIGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gZm9ybWF0VHlwZTtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCk7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgZWxlbWVudC5kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZUhlYWRpbmdOb2RlKHNlcmlhbGl6ZWROb2RlLnRhZyk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldEluZGVudChzZXJpYWxpemVkTm9kZS5pbmRlbnQpO1xuICAgIG5vZGUuc2V0RGlyZWN0aW9uKHNlcmlhbGl6ZWROb2RlLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHRhZzogdGhpcy5nZXRUYWcoKSxcbiAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9IC8vIE11dGF0aW9uXG5cblxuICBpbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgYW5jaG9yT2ZmZXQgPSBzZWxlY3Rpb24gPyBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA6IDA7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9IGFuY2hvck9mZmV0ID4gMCAmJiBhbmNob3JPZmZldCA8IHRoaXMuZ2V0VGV4dENvbnRlbnRTaXplKCkgPyAkY3JlYXRlSGVhZGluZ05vZGUodGhpcy5nZXRUYWcoKSkgOiBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICBuZXdFbGVtZW50LnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobmV3RWxlbWVudCwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cblxuICBjb2xsYXBzZUF0U3RhcnQoKSB7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9ICF0aGlzLmlzRW1wdHkoKSA/ICRjcmVhdGVIZWFkaW5nTm9kZSh0aGlzLmdldFRhZygpKSA6IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IG5ld0VsZW1lbnQuYXBwZW5kKGNoaWxkKSk7XG4gICAgdGhpcy5yZXBsYWNlKG5ld0VsZW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZXh0cmFjdFdpdGhDaGlsZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGlzR29vZ2xlRG9jc1RpdGxlKGRvbU5vZGUpIHtcbiAgaWYgKGRvbU5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NwYW4nKSB7XG4gICAgcmV0dXJuIGRvbU5vZGUuc3R5bGUuZm9udFNpemUgPT09ICcyNnB0JztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29udmVydEhlYWRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGxldCBub2RlID0gbnVsbDtcblxuICBpZiAobm9kZU5hbWUgPT09ICdoMScgfHwgbm9kZU5hbWUgPT09ICdoMicgfHwgbm9kZU5hbWUgPT09ICdoMycgfHwgbm9kZU5hbWUgPT09ICdoNCcgfHwgbm9kZU5hbWUgPT09ICdoNScgfHwgbm9kZU5hbWUgPT09ICdoNicpIHtcbiAgICBub2RlID0gJGNyZWF0ZUhlYWRpbmdOb2RlKG5vZGVOYW1lKTtcblxuICAgIGlmIChlbGVtZW50LnN0eWxlICE9PSBudWxsKSB7XG4gICAgICBub2RlLnNldEZvcm1hdChlbGVtZW50LnN0eWxlLnRleHRBbGlnbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRCbG9ja3F1b3RlRWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IG5vZGUgPSAkY3JlYXRlUXVvdGVOb2RlKCk7XG5cbiAgaWYgKGVsZW1lbnQuc3R5bGUgIT09IG51bGwpIHtcbiAgICBub2RlLnNldEZvcm1hdChlbGVtZW50LnN0eWxlLnRleHRBbGlnbik7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5vZGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gJGNyZWF0ZUhlYWRpbmdOb2RlKGhlYWRpbmdUYWcpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBIZWFkaW5nTm9kZShoZWFkaW5nVGFnKSk7XG59XG5mdW5jdGlvbiAkaXNIZWFkaW5nTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgSGVhZGluZ05vZGU7XG59XG5cbmZ1bmN0aW9uIG9uUGFzdGVGb3JSaWNoVGV4dChldmVudCwgZWRpdG9yKSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IGNsaXBib2FyZERhdGEgPSBldmVudCBpbnN0YW5jZW9mIElucHV0RXZlbnQgfHwgZXZlbnQgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50ID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG5cbiAgICBpZiAoY2xpcGJvYXJkRGF0YSAhPSBudWxsICYmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICAgIGNsaXBib2FyZC4kaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUmljaFRleHQoY2xpcGJvYXJkRGF0YSwgc2VsZWN0aW9uLCBlZGl0b3IpO1xuICAgIH1cbiAgfSwge1xuICAgIHRhZzogJ3Bhc3RlJ1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gb25DdXRGb3JSaWNoVGV4dChldmVudCwgZWRpdG9yKSB7XG4gIGF3YWl0IGNsaXBib2FyZC5jb3B5VG9DbGlwYm9hcmQoZWRpdG9yLCB1dGlscy5vYmplY3RLbGFzc0VxdWFscyhldmVudCwgQ2xpcGJvYXJkRXZlbnQpID8gZXZlbnQgOiBudWxsKTtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBzZWxlY3Rpb24ucmVtb3ZlVGV4dCgpO1xuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5nZXROb2RlcygpLmZvckVhY2gobm9kZSA9PiBub2RlLnJlbW92ZSgpKTtcbiAgICB9XG4gIH0pO1xufSAvLyBDbGlwYm9hcmQgbWF5IGNvbnRhaW4gZmlsZXMgdGhhdCB3ZSBhcmVuJ3QgYWxsb3dlZCB0byByZWFkLiBXaGlsZSB0aGUgZXZlbnQgaXMgYXJndWFibHkgdXNlbGVzcyxcbi8vIGluIGNlcnRhaW4gb2Nhc3Npb25zLCB3ZSB3YW50IHRvIGtub3cgd2hldGhlciBpdCB3YXMgYSBmaWxlIHRyYW5zZmVyLCBhcyBvcHBvc2VkIHRvIHRleHQuIFdlXG4vLyBjb250cm9sIHRoaXMgd2l0aCB0aGUgZmlyc3QgYm9vbGVhbiBmbGFnLlxuXG5cbmZ1bmN0aW9uIGV2ZW50RmlsZXMoZXZlbnQpIHtcbiAgbGV0IGRhdGFUcmFuc2ZlciA9IG51bGw7XG5cbiAgaWYgKGV2ZW50IGluc3RhbmNlb2YgRHJhZ0V2ZW50KSB7XG4gICAgZGF0YVRyYW5zZmVyID0gZXZlbnQuZGF0YVRyYW5zZmVyO1xuICB9IGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgQ2xpcGJvYXJkRXZlbnQpIHtcbiAgICBkYXRhVHJhbnNmZXIgPSBldmVudC5jbGlwYm9hcmREYXRhO1xuICB9XG5cbiAgaWYgKGRhdGFUcmFuc2ZlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbZmFsc2UsIFtdLCBmYWxzZV07XG4gIH1cblxuICBjb25zdCB0eXBlcyA9IGRhdGFUcmFuc2Zlci50eXBlcztcbiAgY29uc3QgaGFzRmlsZXMgPSB0eXBlcy5pbmNsdWRlcygnRmlsZXMnKTtcbiAgY29uc3QgaGFzQ29udGVudCA9IHR5cGVzLmluY2x1ZGVzKCd0ZXh0L2h0bWwnKSB8fCB0eXBlcy5pbmNsdWRlcygndGV4dC9wbGFpbicpO1xuICByZXR1cm4gW2hhc0ZpbGVzLCBBcnJheS5mcm9tKGRhdGFUcmFuc2Zlci5maWxlcyksIGhhc0NvbnRlbnRdO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVJbmRlbnRBbmRPdXRkZW50KGluZGVudE9yT3V0ZGVudCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGFscmVhZHlIYW5kbGVkID0gbmV3IFNldCgpO1xuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgY29uc3Qga2V5ID0gbm9kZS5nZXRLZXkoKTtcblxuICAgIGlmIChhbHJlYWR5SGFuZGxlZC5oYXMoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50QmxvY2sgPSB1dGlscy4kZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdyhub2RlKTtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBwYXJlbnRCbG9jay5nZXRLZXkoKTtcblxuICAgIGlmIChwYXJlbnRCbG9jay5jYW5JbmRlbnQoKSAmJiAhYWxyZWFkeUhhbmRsZWQuaGFzKHBhcmVudEtleSkpIHtcbiAgICAgIGFscmVhZHlIYW5kbGVkLmFkZChwYXJlbnRLZXkpO1xuICAgICAgaW5kZW50T3JPdXRkZW50KHBhcmVudEJsb2NrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYWxyZWFkeUhhbmRsZWQuc2l6ZSA+IDA7XG59XG5cbmZ1bmN0aW9uICRpc1RhcmdldFdpdGhpbkRlY29yYXRvcih0YXJnZXQpIHtcbiAgY29uc3Qgbm9kZSA9IGxleGljYWwuJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUodGFyZ2V0KTtcbiAgcmV0dXJuIGxleGljYWwuJGlzRGVjb3JhdG9yTm9kZShub2RlKTtcbn1cblxuZnVuY3Rpb24gJGlzU2VsZWN0aW9uQXRFbmRPZlJvb3Qoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICByZXR1cm4gZm9jdXMua2V5ID09PSAncm9vdCcgJiYgZm9jdXMub2Zmc2V0ID09PSBsZXhpY2FsLiRnZXRSb290KCkuZ2V0Q2hpbGRyZW5TaXplKCk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmljaFRleHQoZWRpdG9yKSB7XG4gIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gdXRpbHMubWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuQ0xJQ0tfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCAwKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkRFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgaXNCYWNrd2FyZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNlbGVjdGlvbi5kZWxldGVDaGFyYWN0ZXIoaXNCYWNrd2FyZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuREVMRVRFX1dPUkRfQ09NTUFORCwgaXNCYWNrd2FyZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNlbGVjdGlvbi5kZWxldGVXb3JkKGlzQmFja3dhcmQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkRFTEVURV9MSU5FX0NPTU1BTkQsIGlzQmFja3dhcmQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3Rpb24uZGVsZXRlTGluZShpc0JhY2t3YXJkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5DT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIGV2ZW50T3JUZXh0ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICh0eXBlb2YgZXZlbnRPclRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIHNlbGVjdGlvbi5pbnNlcnRUZXh0KGV2ZW50T3JUZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkgO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAhbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGV2ZW50T3JUZXh0LmRhdGFUcmFuc2ZlcjtcblxuICAgICAgaWYgKGRhdGFUcmFuc2ZlciAhPSBudWxsKSB7XG4gICAgICAgIGNsaXBib2FyZC4kaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUmljaFRleHQoZGF0YVRyYW5zZmVyLCBzZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBkYXRhID0gZXZlbnRPclRleHQuZGF0YTtcblxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIHNlbGVjdGlvbi5pbnNlcnRUZXh0KGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuUkVNT1ZFX1RFWFRfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3Rpb24ucmVtb3ZlVGV4dCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkZPUk1BVF9URVhUX0NPTU1BTkQsIGZvcm1hdCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNlbGVjdGlvbi5mb3JtYXRUZXh0KGZvcm1hdCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuRk9STUFUX0VMRU1FTlRfQ09NTUFORCwgZm9ybWF0ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmICFsZXhpY2FsLiRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG5cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KG5vZGUsIHBhcmVudE5vZGUgPT4gbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShwYXJlbnROb2RlKSAmJiAhcGFyZW50Tm9kZS5pc0lubGluZSgpKTtcblxuICAgICAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5JTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBzZWxlY3RTdGFydCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNlbGVjdGlvbi5pbnNlcnRMaW5lQnJlYWsoc2VsZWN0U3RhcnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLklOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3Rpb24uaW5zZXJ0UGFyYWdyYXBoKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuSU5TRVJUX1RBQl9DT01NQU5ELCAoKSA9PiB7XG4gICAgbGV4aWNhbC4kaW5zZXJ0Tm9kZXMoW2xleGljYWwuJGNyZWF0ZVRhYk5vZGUoKV0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLklOREVOVF9DT05URU5UX0NPTU1BTkQsICgpID0+IHtcbiAgICByZXR1cm4gaGFuZGxlSW5kZW50QW5kT3V0ZGVudChibG9jayA9PiB7XG4gICAgICBjb25zdCBpbmRlbnQgPSBibG9jay5nZXRJbmRlbnQoKTtcbiAgICAgIGJsb2NrLnNldEluZGVudChpbmRlbnQgKyAxKTtcbiAgICB9KTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5PVVRERU5UX0NPTlRFTlRfQ09NTUFORCwgKCkgPT4ge1xuICAgIHJldHVybiBoYW5kbGVJbmRlbnRBbmRPdXRkZW50KGJsb2NrID0+IHtcbiAgICAgIGNvbnN0IGluZGVudCA9IGJsb2NrLmdldEluZGVudCgpO1xuXG4gICAgICBpZiAoaW5kZW50ID4gMCkge1xuICAgICAgICBibG9jay5zZXRJbmRlbnQoaW5kZW50IC0gMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0FSUk9XX1VQX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAhJGlzVGFyZ2V0V2l0aGluRGVjb3JhdG9yKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBvbiBhIG5vZGUsIGxldCdzIHRyeSBhbmQgbW92ZSBzZWxlY3Rpb25cbiAgICAgIC8vIGJhY2sgdG8gYmVpbmcgYSByYW5nZSBzZWxlY3Rpb24uXG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuXG4gICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBub2Rlc1swXS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgcG9zc2libGVOb2RlID0gbGV4aWNhbC4kZ2V0QWRqYWNlbnROb2RlKHNlbGVjdGlvbi5mb2N1cywgdHJ1ZSk7XG5cbiAgICAgIGlmICghZXZlbnQuc2hpZnRLZXkgJiYgbGV4aWNhbC4kaXNEZWNvcmF0b3JOb2RlKHBvc3NpYmxlTm9kZSkgJiYgIXBvc3NpYmxlTm9kZS5pc0lzb2xhdGVkKCkgJiYgIXBvc3NpYmxlTm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAgIHBvc3NpYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAvLyBJZiBzZWxlY3Rpb24gaXMgb24gYSBub2RlLCBsZXQncyB0cnkgYW5kIG1vdmUgc2VsZWN0aW9uXG4gICAgICAvLyBiYWNrIHRvIGJlaW5nIGEgcmFuZ2Ugc2VsZWN0aW9uLlxuICAgICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcblxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbm9kZXNbMF0uc2VsZWN0TmV4dCgwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGlmICgkaXNTZWxlY3Rpb25BdEVuZE9mUm9vdChzZWxlY3Rpb24pKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwb3NzaWJsZU5vZGUgPSBsZXhpY2FsLiRnZXRBZGphY2VudE5vZGUoc2VsZWN0aW9uLmZvY3VzLCBmYWxzZSk7XG5cbiAgICAgIGlmICghZXZlbnQuc2hpZnRLZXkgJiYgbGV4aWNhbC4kaXNEZWNvcmF0b3JOb2RlKHBvc3NpYmxlTm9kZSkgJiYgIXBvc3NpYmxlTm9kZS5pc0lzb2xhdGVkKCkgJiYgIXBvc3NpYmxlTm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAgIHBvc3NpYmxlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQVJST1dfTEVGVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uJDEgPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uJDEpKSB7XG4gICAgICAvLyBJZiBzZWxlY3Rpb24gaXMgb24gYSBub2RlLCBsZXQncyB0cnkgYW5kIG1vdmUgc2VsZWN0aW9uXG4gICAgICAvLyBiYWNrIHRvIGJlaW5nIGEgcmFuZ2Ugc2VsZWN0aW9uLlxuICAgICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24kMS5nZXROb2RlcygpO1xuXG4gICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBub2Rlc1swXS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uJDEpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGlvbi4kc2hvdWxkT3ZlcnJpZGVEZWZhdWx0Q2hhcmFjdGVyU2VsZWN0aW9uKHNlbGVjdGlvbiQxLCB0cnVlKSkge1xuICAgICAgY29uc3QgaXNIb2xkaW5nU2hpZnQgPSBldmVudC5zaGlmdEtleTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzZWxlY3Rpb24uJG1vdmVDaGFyYWN0ZXIoc2VsZWN0aW9uJDEsIGlzSG9sZGluZ1NoaWZ0LCB0cnVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQVJST1dfUklHSFRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiQxID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbiQxKSAmJiAhJGlzVGFyZ2V0V2l0aGluRGVjb3JhdG9yKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBvbiBhIG5vZGUsIGxldCdzIHRyeSBhbmQgbW92ZSBzZWxlY3Rpb25cbiAgICAgIC8vIGJhY2sgdG8gYmVpbmcgYSByYW5nZSBzZWxlY3Rpb24uXG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbiQxLmdldE5vZGVzKCk7XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG5vZGVzWzBdLnNlbGVjdE5leHQoMCwgMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24kMSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0hvbGRpbmdTaGlmdCA9IGV2ZW50LnNoaWZ0S2V5O1xuXG4gICAgaWYgKHNlbGVjdGlvbi4kc2hvdWxkT3ZlcnJpZGVEZWZhdWx0Q2hhcmFjdGVyU2VsZWN0aW9uKHNlbGVjdGlvbiQxLCBmYWxzZSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzZWxlY3Rpb24uJG1vdmVDaGFyYWN0ZXIoc2VsZWN0aW9uJDEsIGlzSG9sZGluZ1NoaWZ0LCBmYWxzZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgaWYgKCRpc1RhcmdldFdpdGhpbkRlY29yYXRvcihldmVudC50YXJnZXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9yXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcblxuICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBhbmNob3Iub2Zmc2V0ID09PSAwICYmICFsZXhpY2FsLiRpc1Jvb3ROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdXRpbHMuJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3coYW5jaG9yTm9kZSk7XG5cbiAgICAgIGlmIChlbGVtZW50LmdldEluZGVudCgpID4gMCkge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLk9VVERFTlRfQ09OVEVOVF9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCB0cnVlKTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfREVMRVRFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBpZiAoJGlzVGFyZ2V0V2l0aGluRGVjb3JhdG9yKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLkRFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgZmFsc2UpO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9FTlRFUl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChldmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBiZWZvcmVpbnB1dCwgdGhlbiB3ZSBjYW4gYXZvaWQgYmxvY2tpbmdcbiAgICAgIC8vIHRoZSBkZWZhdWx0IGJlaGF2aW9yLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgaU9TIGNhblxuICAgICAgLy8gaW50ZXJjZXB0IHRoYXQgd2UncmUgYWN0dWFsbHkgaW5zZXJ0aW5nIGEgcGFyYWdyYXBoLFxuICAgICAgLy8gYW5kIGF1dG9jb21wbGV0ZSwgYXV0b2NhcGl0YWxpemUgZXRjIHdvcmsgYXMgaW50ZW5kZWQuXG4gICAgICAvLyBUaGlzIGNhbiBhbHNvIGNhdXNlIGEgc3RyYW5nZSBwZXJmb3JtYW5jZSBpc3N1ZSBpblxuICAgICAgLy8gU2FmYXJpLCB3aGVyZSB0aGVyZSBpcyBhIG5vdGljZWFibGUgcGF1c2UgZHVlIHRvXG4gICAgICAvLyBwcmV2ZW50aW5nIHRoZSBrZXkgZG93biBvZiBlbnRlci5cbiAgICAgIGlmICgoSVNfSU9TIHx8IElTX1NBRkFSSSB8fCBJU19BUFBMRV9XRUJLSVQpICYmIENBTl9VU0VfQkVGT1JFX0lOUFVUKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCB1bmRlZmluZWQpO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9FU0NBUEVfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBlZGl0b3IuYmx1cigpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkRST1BfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IFssIGZpbGVzXSA9IGV2ZW50RmlsZXMoZXZlbnQpO1xuXG4gICAgaWYgKGZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHggPSBldmVudC5jbGllbnRYO1xuICAgICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICBjb25zdCBldmVudFJhbmdlID0gY2FyZXRGcm9tUG9pbnQoeCwgeSk7XG5cbiAgICAgIGlmIChldmVudFJhbmdlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBvZmZzZXQ6IGRvbU9mZnNldCxcbiAgICAgICAgICBub2RlOiBkb21Ob2RlXG4gICAgICAgIH0gPSBldmVudFJhbmdlO1xuICAgICAgICBjb25zdCBub2RlID0gbGV4aWNhbC4kZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShkb21Ob2RlKTtcblxuICAgICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uLmFuY2hvci5zZXQobm9kZS5nZXRLZXkoKSwgZG9tT2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLmZvY3VzLnNldChub2RlLmdldEtleSgpLCBkb21PZmZzZXQsICd0ZXh0Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEtleSA9IG5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLmdldEtleSgpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgMTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hbmNob3Iuc2V0KHBhcmVudEtleSwgb2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLmZvY3VzLnNldChwYXJlbnRLZXksIG9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBub3JtYWxpemVkU2VsZWN0aW9uID0gbGV4aWNhbC4kbm9ybWFsaXplU2VsZWN0aW9uX19FWFBFUklNRU5UQUwoc2VsZWN0aW9uKTtcbiAgICAgICAgICBsZXhpY2FsLiRzZXRTZWxlY3Rpb24obm9ybWFsaXplZFNlbGVjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKERSQUdfRFJPUF9QQVNURSwgZmlsZXMpO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuRFJBR1NUQVJUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBbaXNGaWxlVHJhbnNmZXJdID0gZXZlbnRGaWxlcyhldmVudCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoaXNGaWxlVHJhbnNmZXIgJiYgIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkRSQUdPVkVSX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBbaXNGaWxlVHJhbnNmZXJdID0gZXZlbnRGaWxlcyhldmVudCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoaXNGaWxlVHJhbnNmZXIgJiYgIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHggPSBldmVudC5jbGllbnRYO1xuICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZO1xuICAgIGNvbnN0IGV2ZW50UmFuZ2UgPSBjYXJldEZyb21Qb2ludCh4LCB5KTtcblxuICAgIGlmIChldmVudFJhbmdlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBub2RlID0gbGV4aWNhbC4kZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShldmVudFJhbmdlLm5vZGUpO1xuXG4gICAgICBpZiAobGV4aWNhbC4kaXNEZWNvcmF0b3JOb2RlKG5vZGUpKSB7XG4gICAgICAgIC8vIFNob3cgYnJvd3NlciBjYXJldCBhcyB0aGUgdXNlciBpcyBkcmFnZ2luZyB0aGUgbWVkaWEgYWNyb3NzIHRoZSBzY3JlZW4uIFdvbid0IHdvcmtcbiAgICAgICAgLy8gZm9yIERlY29yYXRvck5vZGUgbm9yIGl0J3MgcmVsZXZhbnQuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuQ09QWV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY2xpcGJvYXJkLmNvcHlUb0NsaXBib2FyZChlZGl0b3IsIHV0aWxzLm9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBDbGlwYm9hcmRFdmVudCkgPyBldmVudCA6IG51bGwpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkNVVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgb25DdXRGb3JSaWNoVGV4dChldmVudCwgZWRpdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5QQVNURV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3QgWywgZmlsZXMsIGhhc1RleHRDb250ZW50XSA9IGV2ZW50RmlsZXMoZXZlbnQpO1xuXG4gICAgaWYgKGZpbGVzLmxlbmd0aCA+IDAgJiYgIWhhc1RleHRDb250ZW50KSB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKERSQUdfRFJPUF9QQVNURSwgZmlsZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBpZiBpbnB1dHMgdGhlbiBwYXN0ZSB3aXRoaW4gdGhlIGlucHV0IGlnbm9yZSBjcmVhdGluZyBhIG5ldyBub2RlIG9uIHBhc3RlIGV2ZW50XG5cblxuICAgIGlmIChsZXhpY2FsLmlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcklucHV0KGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgb25QYXN0ZUZvclJpY2hUZXh0KGV2ZW50LCBlZGl0b3IpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSk7XG4gIHJldHVybiByZW1vdmVMaXN0ZW5lcjtcbn1cblxuZXhwb3J0cy4kY3JlYXRlSGVhZGluZ05vZGUgPSAkY3JlYXRlSGVhZGluZ05vZGU7XG5leHBvcnRzLiRjcmVhdGVRdW90ZU5vZGUgPSAkY3JlYXRlUXVvdGVOb2RlO1xuZXhwb3J0cy4kaXNIZWFkaW5nTm9kZSA9ICRpc0hlYWRpbmdOb2RlO1xuZXhwb3J0cy4kaXNRdW90ZU5vZGUgPSAkaXNRdW90ZU5vZGU7XG5leHBvcnRzLkRSQUdfRFJPUF9QQVNURSA9IERSQUdfRFJPUF9QQVNURTtcbmV4cG9ydHMuSGVhZGluZ05vZGUgPSBIZWFkaW5nTm9kZTtcbmV4cG9ydHMuUXVvdGVOb2RlID0gUXVvdGVOb2RlO1xuZXhwb3J0cy5ldmVudEZpbGVzID0gZXZlbnRGaWxlcztcbmV4cG9ydHMucmVnaXN0ZXJSaWNoVGV4dCA9IHJlZ2lzdGVyUmljaFRleHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/rich-text/LexicalRichText.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/rich-text/LexicalRichText.js":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/rich-text/LexicalRichText.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalRichText =  true ? __webpack_require__(/*! ./LexicalRichText.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/rich-text/LexicalRichText.dev.js\") : 0\nmodule.exports = LexicalRichText;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yaWNoLXRleHQvTGV4aWNhbFJpY2hUZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osd0JBQXdCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyw4R0FBMEIsSUFBSSxDQUFvQztBQUMzSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmljaC10ZXh0L0xleGljYWxSaWNoVGV4dC5qcz8wYmE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsUmljaFRleHQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFJpY2hUZXh0LmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsUmljaFRleHQucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxSaWNoVGV4dDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/rich-text/LexicalRichText.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.dev.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n\n    node = node.firstChild;\n  }\n\n  return null;\n}\n\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\n\n\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n\n  if (lexical.$isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n\n  if (lexical.$isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n\n  const firstChild = anchorDOM.firstChild;\n\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n\n  return range;\n}\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\n\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n\n  if (rootElement === null) {\n    return [];\n  }\n\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length; //sort rects from top left to bottom right.\n\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top; // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n\n    return top;\n  });\n  let prevRect;\n\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i]; // Exclude rects that overlap preceding Rects in the sorted list.\n\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left; // Exclude selections that span the entire element\n\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n\n    prevRect = selectionRect;\n  }\n\n  return selectionRects;\n}\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\n\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n\n      styleObject[key.trim()] = value.trim();\n    }\n  }\n\n  return styleObject;\n}\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\n\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n\n  return value;\n}\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\n\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $updateElementNodeProperties(target, source) {\n  target.__first = source.__first;\n  target.__last = source.__last;\n  target.__size = source.__size;\n  target.__format = source.__format;\n  target.__indent = source.__indent;\n  target.__dir = source.__dir;\n  return target;\n}\n\nfunction $updateTextNodeProperties(target, source) {\n  target.__format = source.__format;\n  target.__style = source.__style;\n  target.__mode = source.__mode;\n  target.__detail = source.__detail;\n  return target;\n}\n/**\n * Returns a copy of a node, but generates a new key for the copy.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\n\n\nfunction $cloneWithProperties(node) {\n  const latest = node.getLatest();\n  const constructor = latest.constructor; // @ts-expect-error\n\n  const clone = constructor.clone(latest);\n  clone.__parent = latest.__parent;\n  clone.__next = latest.__next;\n  clone.__prev = latest.__prev;\n\n  if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {\n    return $updateElementNodeProperties(clone, latest);\n  }\n\n  if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {\n    return $updateTextNodeProperties(clone, latest);\n  }\n\n  return clone;\n}\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\n\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n\n    if (isAnchor || isFocus) {\n      const isBackward = selection.isBackward();\n      const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n\n  return textNode;\n}\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\n\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n\n  return point.offset === point.getNode().getChildrenSize();\n}\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\n\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n\n  if (lexical.$isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n\n  while (remaining > 0 && currentNode !== null) {\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n\n      while (parentSibling === null) {\n        parent = parent.getParent();\n\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n\n        parentSibling = parent.getPreviousSibling();\n      }\n\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n\n        if (lexical.$isElementNode(parentSibling)) {\n          nextNode = parentSibling.getLastDescendant();\n        } else {\n          nextNode = parentSibling;\n        }\n      }\n    }\n\n    let text = currentNode.getTextContent(); // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n\n    if (text === '' && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n\n    const currentNodeSize = currentNode.getTextContentSize();\n\n    if (!lexical.$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n\n      if (parent != null && parent.getChildrenSize() === 0 && !lexical.$isRootNode(parent)) {\n        parent.remove();\n      }\n\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey(); // See if we can just revert it to what was in the last editor state\n\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = lexical.$getNodeByKey(key);\n\n        if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = lexical.$getPreviousSelection();\n        let target = currentNode;\n\n        if (!currentNode.isSimpleText()) {\n          const textNode = lexical.$createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n\n        if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset; // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = lexical.$createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n\n      remaining = 0;\n    }\n  }\n}\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\n\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n\n    return styles;\n  }, { ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. { CSSProperty: value }\n */\n\n\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n\n  if (selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key; // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n\n  if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n\n    if (lexical.$isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  } // This is the case where we only selected a single node\n\n\n  if (selectedNodes.length === 1) {\n    if (lexical.$isTextNode(firstNode)) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset; // No actual text is selected, so do nothing.\n\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n\n  } else {\n    if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n      }\n\n      $patchStyle(firstNode, patch);\n    }\n\n    if (lexical.$isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length; // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      } // if the entire last node isn't selected, split it\n\n\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n\n      if (endOffset !== 0) {\n        $patchStyle(lastNode, patch);\n      }\n    } // style all the text nodes in between\n\n\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n\n      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\n\nfunction $setBlocksType(selection, createElement) {\n  if (selection.anchor.key === 'root') {\n    const element = createElement();\n    const root = lexical.$getRoot();\n    const firstChild = root.getFirstChild();\n\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n\n    return;\n  }\n\n  const nodes = selection.getNodes();\n  let maybeBlock = selection.anchor.getNode().getParentOrThrow();\n\n  if (nodes.indexOf(maybeBlock) === -1) {\n    nodes.push(maybeBlock);\n  }\n\n  if (maybeBlock.isInline()) {\n    maybeBlock = maybeBlock.getParentOrThrow();\n\n    if (nodes.indexOf(maybeBlock) === -1) {\n      nodes.push(maybeBlock);\n    }\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (!isBlock(node)) {\n      continue;\n    }\n\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\n\nfunction isBlock(node) {\n  if (!lexical.$isElementNode(node) || lexical.$isRootOrShadowRoot(node)) {\n    return false;\n  }\n\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || lexical.$isLineBreakNode(firstChild) || lexical.$isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\n\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\n\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n\n  while (node !== null && !lexical.$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n\n    node = parentNode;\n  }\n}\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\n\n\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  const anchor = selection.anchor;\n\n  if (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n\n    target.replace(element);\n    return;\n  }\n\n  let topLevelNode = null;\n  let descendants = [];\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i]; // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n\n    if (lexical.$isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\n\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = []; // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n\n  let targetIsPrevSibling = false;\n\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n\n    target = target.getParentOrThrow();\n\n    if (lexical.$isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n\n  const emptyElements = new Set(); // Find any top level empty elements\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n\n  const movedNodes = new Set(); // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n\n    if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement); // Move node and its siblings to the new\n        // element.\n\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n\n          if (lexical.$isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n\n  let lastElement = null; // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n\n  if (lexical.$isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n\n      if (lexical.$isElementNode(firstChild)) {\n        target = firstChild;\n      }\n\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n\n  const prevSelection = lexical.$getPreviousSelection();\n\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    lexical.$setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\n\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\n\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\n\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\n\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n/**\n * Expands the current Selection to cover all of the content in the editor.\n * @param selection - The current selection.\n */\n\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n\n  if (lexical.$isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n\n  if (lexical.$isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\n\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n\n  return defaultValue;\n}\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\n\n\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n\n  if (selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]; // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n\n    if (lexical.$isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n\n  return styleValue === null ? defaultValue : styleValue;\n}\n\nexports.$addNodeStyle = $addNodeStyle;\nexports.$cloneWithProperties = $cloneWithProperties;\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\nexports.$isAtNodeEnd = $isAtNodeEnd;\nexports.$isParentElementRTL = $isParentElementRTL;\nexports.$moveCaretSelection = $moveCaretSelection;\nexports.$moveCharacter = $moveCharacter;\nexports.$patchStyleText = $patchStyleText;\nexports.$selectAll = $selectAll;\nexports.$setBlocksType = $setBlocksType;\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\nexports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;\nexports.$wrapNodes = $wrapNodes;\nexports.createDOMRange = createDOMRange;\nexports.createRectsFromDOMRange = createRectsFromDOMRange;\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\nexports.trimTextContentFromAnchor = trimTextContentFromAnchor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9zZWxlY3Rpb24vTGV4aWNhbFNlbGVjdGlvbi5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHNFQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsa0JBQWtCLDBCQUEwQjtBQUM1Qyw2Q0FBNkM7O0FBRTdDLDBMQUEwTDs7QUFFMUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixNQUFNLElBQUksZUFBZTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdDQUF3Qzs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLElBQUk7QUFDUCxJQUFJLEtBQUs7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EseUhBQXlIOztBQUV6SDtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTixvQkFBb0IsZUFBZTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DLGtCQUFrQixpQkFBaUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQywyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLDRCQUE0QjtBQUM1QiwwQ0FBMEM7QUFDMUMsb0JBQW9CO0FBQ3BCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0Isc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2QixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLGdEQUFnRDtBQUNoRCxxQ0FBcUM7QUFDckMsa0JBQWtCO0FBQ2xCLHNCQUFzQjtBQUN0QiwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBQzdCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2LmpzPzJkOTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBDU1NfVE9fU1RZTEVTID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGdldERPTVRleHROb2RlKGVsZW1lbnQpIHtcbiAgbGV0IG5vZGUgPSBlbGVtZW50O1xuXG4gIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQobm9kZSkge1xuICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG5cbiAgaWYgKHBhcmVudCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbmV2ZXIgaGFwcGVuJyk7XG4gIH1cblxuICByZXR1cm4gW3BhcmVudCwgQXJyYXkuZnJvbShwYXJlbnQuY2hpbGROb2RlcykuaW5kZXhPZihub2RlKV07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBzZWxlY3Rpb24gcmFuZ2UgZm9yIHRoZSBET00uXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICogQHBhcmFtIGFuY2hvck5vZGUgLSBUaGUgYW5jaG9yIG5vZGUgb2YgYSBzZWxlY3Rpb24uXG4gKiBAcGFyYW0gX2FuY2hvck9mZnNldCAtIFRoZSBhbW91bnQgb2Ygc3BhY2Ugb2Zmc2V0IGZyb20gdGhlIGFuY2hvciB0byB0aGUgZm9jdXMuXG4gKiBAcGFyYW0gZm9jdXNOb2RlIC0gVGhlIGN1cnJlbnQgZm9jdXMuXG4gKiBAcGFyYW0gX2ZvY3VzT2Zmc2V0IC0gVGhlIGFtb3VudCBvZiBzcGFjZSBvZmZzZXQgZnJvbSB0aGUgZm9jdXMgdG8gdGhlIGFuY2hvci5cbiAqIEByZXR1cm5zIFRoZSByYW5nZSBvZiBzZWxlY3Rpb24gZm9yIHRoZSBET00gdGhhdCB3YXMgY3JlYXRlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZURPTVJhbmdlKGVkaXRvciwgYW5jaG9yTm9kZSwgX2FuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBfZm9jdXNPZmZzZXQpIHtcbiAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yTm9kZS5nZXRLZXkoKTtcbiAgY29uc3QgZm9jdXNLZXkgPSBmb2N1c05vZGUuZ2V0S2V5KCk7XG4gIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgbGV0IGFuY2hvckRPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yS2V5KTtcbiAgbGV0IGZvY3VzRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShmb2N1c0tleSk7XG4gIGxldCBhbmNob3JPZmZzZXQgPSBfYW5jaG9yT2Zmc2V0O1xuICBsZXQgZm9jdXNPZmZzZXQgPSBfZm9jdXNPZmZzZXQ7XG5cbiAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICBhbmNob3JET00gPSBnZXRET01UZXh0Tm9kZShhbmNob3JET00pO1xuICB9XG5cbiAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoZm9jdXNOb2RlKSkge1xuICAgIGZvY3VzRE9NID0gZ2V0RE9NVGV4dE5vZGUoZm9jdXNET00pO1xuICB9XG5cbiAgaWYgKGFuY2hvck5vZGUgPT09IHVuZGVmaW5lZCB8fCBmb2N1c05vZGUgPT09IHVuZGVmaW5lZCB8fCBhbmNob3JET00gPT09IG51bGwgfHwgZm9jdXNET00gPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChhbmNob3JET00ubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICBbYW5jaG9yRE9NLCBhbmNob3JPZmZzZXRdID0gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQoYW5jaG9yRE9NKTtcbiAgfVxuXG4gIGlmIChmb2N1c0RPTS5ub2RlTmFtZSA9PT0gJ0JSJykge1xuICAgIFtmb2N1c0RPTSwgZm9jdXNPZmZzZXRdID0gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQoZm9jdXNET00pO1xuICB9XG5cbiAgY29uc3QgZmlyc3RDaGlsZCA9IGFuY2hvckRPTS5maXJzdENoaWxkO1xuXG4gIGlmIChhbmNob3JET00gPT09IGZvY3VzRE9NICYmIGZpcnN0Q2hpbGQgIT0gbnVsbCAmJiBmaXJzdENoaWxkLm5vZGVOYW1lID09PSAnQlInICYmIGFuY2hvck9mZnNldCA9PT0gMCAmJiBmb2N1c09mZnNldCA9PT0gMCkge1xuICAgIGZvY3VzT2Zmc2V0ID0gMTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yRE9NLCBhbmNob3JPZmZzZXQpO1xuICAgIHJhbmdlLnNldEVuZChmb2N1c0RPTSwgZm9jdXNPZmZzZXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocmFuZ2UuY29sbGFwc2VkICYmIChhbmNob3JPZmZzZXQgIT09IGZvY3VzT2Zmc2V0IHx8IGFuY2hvcktleSAhPT0gZm9jdXNLZXkpKSB7XG4gICAgLy8gUmFuZ2UgaXMgYmFja3dhcmRzLCB3ZSBuZWVkIHRvIHJldmVyc2UgaXRcbiAgICByYW5nZS5zZXRTdGFydChmb2N1c0RPTSwgZm9jdXNPZmZzZXQpO1xuICAgIHJhbmdlLnNldEVuZChhbmNob3JET00sIGFuY2hvck9mZnNldCk7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59XG4vKipcbiAqIENyZWF0ZXMgRE9NUmVjdHMsIGdlbmVyYWxseSB1c2VkIHRvIGhlbHAgdGhlIGVkaXRvciBmaW5kIGEgc3BlY2lmaWMgbG9jYXRpb24gb24gdGhlIHNjcmVlbi5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3JcbiAqIEBwYXJhbSByYW5nZSAtIEEgZnJhZ21lbnQgb2YgYSBkb2N1bWVudCB0aGF0IGNhbiBjb250YWluIG5vZGVzIGFuZCBwYXJ0cyBvZiB0ZXh0IG5vZGVzLlxuICogQHJldHVybnMgVGhlIHNlbGVjdGlvblJlY3RzIGFzIGFuIGFycmF5LlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcblxuICBpZiAocm9vdEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCByb290UmVjdCA9IHJvb3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShyb290RWxlbWVudCk7XG4gIGNvbnN0IHJvb3RQYWRkaW5nID0gcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0KSArIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpO1xuICBjb25zdCBzZWxlY3Rpb25SZWN0cyA9IEFycmF5LmZyb20ocmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKSk7XG4gIGxldCBzZWxlY3Rpb25SZWN0c0xlbmd0aCA9IHNlbGVjdGlvblJlY3RzLmxlbmd0aDsgLy9zb3J0IHJlY3RzIGZyb20gdG9wIGxlZnQgdG8gYm90dG9tIHJpZ2h0LlxuXG4gIHNlbGVjdGlvblJlY3RzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB0b3AgPSBhLnRvcCAtIGIudG9wOyAvLyBTb21lIHJlY3RzIG1hdGNoIHBvc2l0aW9uIGNsb3NlbHksIGJ1dCBub3QgcGVyZmVjdGx5LFxuICAgIC8vIHNvIHdlIGdpdmUgYSAzcHggdG9sZXJhbmNlLlxuXG4gICAgaWYgKE1hdGguYWJzKHRvcCkgPD0gMykge1xuICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9wO1xuICB9KTtcbiAgbGV0IHByZXZSZWN0O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0aW9uUmVjdHNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlbGVjdGlvblJlY3QgPSBzZWxlY3Rpb25SZWN0c1tpXTsgLy8gRXhjbHVkZSByZWN0cyB0aGF0IG92ZXJsYXAgcHJlY2VkaW5nIFJlY3RzIGluIHRoZSBzb3J0ZWQgbGlzdC5cblxuICAgIGNvbnN0IGlzT3ZlcmxhcHBpbmdSZWN0ID0gcHJldlJlY3QgJiYgcHJldlJlY3QudG9wIDw9IHNlbGVjdGlvblJlY3QudG9wICYmIHByZXZSZWN0LnRvcCArIHByZXZSZWN0LmhlaWdodCA+IHNlbGVjdGlvblJlY3QudG9wICYmIHByZXZSZWN0LmxlZnQgKyBwcmV2UmVjdC53aWR0aCA+IHNlbGVjdGlvblJlY3QubGVmdDsgLy8gRXhjbHVkZSBzZWxlY3Rpb25zIHRoYXQgc3BhbiB0aGUgZW50aXJlIGVsZW1lbnRcblxuICAgIGNvbnN0IHNlbGVjdGlvblNwYW5zRWxlbWVudCA9IHNlbGVjdGlvblJlY3Qud2lkdGggKyByb290UGFkZGluZyA9PT0gcm9vdFJlY3Qud2lkdGg7XG5cbiAgICBpZiAoaXNPdmVybGFwcGluZ1JlY3QgfHwgc2VsZWN0aW9uU3BhbnNFbGVtZW50KSB7XG4gICAgICBzZWxlY3Rpb25SZWN0cy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIHNlbGVjdGlvblJlY3RzTGVuZ3RoLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwcmV2UmVjdCA9IHNlbGVjdGlvblJlY3Q7XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uUmVjdHM7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcyBwcm92aWRlZCBpbiB0aGUgQ1NTIHN0cmluZy5cbiAqIEBwYXJhbSBjc3MgLSBUaGUgQ1NTIHN0cmluZyBvZiBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcy5cbiAqIEByZXR1cm5zIFRoZSBzdHlsZU9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gZ2V0U3R5bGVPYmplY3RGcm9tUmF3Q1NTKGNzcykge1xuICBjb25zdCBzdHlsZU9iamVjdCA9IHt9O1xuICBjb25zdCBzdHlsZXMgPSBjc3Muc3BsaXQoJzsnKTtcblxuICBmb3IgKGNvbnN0IHN0eWxlIG9mIHN0eWxlcykge1xuICAgIGlmIChzdHlsZSAhPT0gJycpIHtcbiAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHN0eWxlLnNwbGl0KC86KFteXSspLyk7IC8vIHNwbGl0IG9uIGZpcnN0IGNvbG9uXG5cbiAgICAgIHN0eWxlT2JqZWN0W2tleS50cmltKCldID0gdmFsdWUudHJpbSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZU9iamVjdDtcbn1cbi8qKlxuICogR2l2ZW4gYSBDU1Mgc3RyaW5nLCByZXR1cm5zIGFuIG9iamVjdCBmcm9tIHRoZSBzdHlsZSBjYWNoZS5cbiAqIEBwYXJhbSBjc3MgLSBUaGUgQ1NTIHByb3BlcnR5IGFzIGEgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBDU1MgcHJvcGVydHkuXG4gKi9cblxuZnVuY3Rpb24gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKGNzcykge1xuICBsZXQgdmFsdWUgPSBDU1NfVE9fU1RZTEVTLmdldChjc3MpO1xuXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBnZXRTdHlsZU9iamVjdEZyb21SYXdDU1MoY3NzKTtcbiAgICBDU1NfVE9fU1RZTEVTLnNldChjc3MsIHZhbHVlKTtcbiAgfVxuXG4gIHtcbiAgICAvLyBGcmVlemUgdGhlIHZhbHVlIGluIERFViB0byBwcmV2ZW50IGFjY2lkZW50YWwgbXV0YXRpb25zXG4gICAgT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEdldHMgdGhlIENTUyBzdHlsZXMgZnJvbSB0aGUgc3R5bGUgb2JqZWN0LlxuICogQHBhcmFtIHN0eWxlcyAtIFRoZSBzdHlsZSBvYmplY3QgY29udGFpbmluZyB0aGUgc3R5bGVzIHRvIGdldC5cbiAqIEByZXR1cm5zIEEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIENTUyBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRDU1NGcm9tU3R5bGVPYmplY3Qoc3R5bGVzKSB7XG4gIGxldCBjc3MgPSAnJztcblxuICBmb3IgKGNvbnN0IHN0eWxlIGluIHN0eWxlcykge1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgY3NzICs9IGAke3N0eWxlfTogJHtzdHlsZXNbc3R5bGVdfTtgO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjc3M7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJHVwZGF0ZUVsZW1lbnROb2RlUHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSkge1xuICB0YXJnZXQuX19maXJzdCA9IHNvdXJjZS5fX2ZpcnN0O1xuICB0YXJnZXQuX19sYXN0ID0gc291cmNlLl9fbGFzdDtcbiAgdGFyZ2V0Ll9fc2l6ZSA9IHNvdXJjZS5fX3NpemU7XG4gIHRhcmdldC5fX2Zvcm1hdCA9IHNvdXJjZS5fX2Zvcm1hdDtcbiAgdGFyZ2V0Ll9faW5kZW50ID0gc291cmNlLl9faW5kZW50O1xuICB0YXJnZXQuX19kaXIgPSBzb3VyY2UuX19kaXI7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uICR1cGRhdGVUZXh0Tm9kZVByb3BlcnRpZXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgdGFyZ2V0Ll9fZm9ybWF0ID0gc291cmNlLl9fZm9ybWF0O1xuICB0YXJnZXQuX19zdHlsZSA9IHNvdXJjZS5fX3N0eWxlO1xuICB0YXJnZXQuX19tb2RlID0gc291cmNlLl9fbW9kZTtcbiAgdGFyZ2V0Ll9fZGV0YWlsID0gc291cmNlLl9fZGV0YWlsO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgY29weSBvZiBhIG5vZGUsIGJ1dCBnZW5lcmF0ZXMgYSBuZXcga2V5IGZvciB0aGUgY29weS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2xvbmVkLlxuICogQHJldHVybnMgVGhlIGNsb25lIG9mIHRoZSBub2RlLlxuICovXG5cblxuZnVuY3Rpb24gJGNsb25lV2l0aFByb3BlcnRpZXMobm9kZSkge1xuICBjb25zdCBsYXRlc3QgPSBub2RlLmdldExhdGVzdCgpO1xuICBjb25zdCBjb25zdHJ1Y3RvciA9IGxhdGVzdC5jb25zdHJ1Y3RvcjsgLy8gQHRzLWV4cGVjdC1lcnJvclxuXG4gIGNvbnN0IGNsb25lID0gY29uc3RydWN0b3IuY2xvbmUobGF0ZXN0KTtcbiAgY2xvbmUuX19wYXJlbnQgPSBsYXRlc3QuX19wYXJlbnQ7XG4gIGNsb25lLl9fbmV4dCA9IGxhdGVzdC5fX25leHQ7XG4gIGNsb25lLl9fcHJldiA9IGxhdGVzdC5fX3ByZXY7XG5cbiAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobGF0ZXN0KSAmJiBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGNsb25lKSkge1xuICAgIHJldHVybiAkdXBkYXRlRWxlbWVudE5vZGVQcm9wZXJ0aWVzKGNsb25lLCBsYXRlc3QpO1xuICB9XG5cbiAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUobGF0ZXN0KSAmJiBsZXhpY2FsLiRpc1RleHROb2RlKGNsb25lKSkge1xuICAgIHJldHVybiAkdXBkYXRlVGV4dE5vZGVQcm9wZXJ0aWVzKGNsb25lLCBsYXRlc3QpO1xuICB9XG5cbiAgcmV0dXJuIGNsb25lO1xufVxuLyoqXG4gKiBHZW5lcmFsbHkgdXNlZCB0byBhcHBlbmQgdGV4dCBjb250ZW50IHRvIEhUTUwgYW5kIEpTT04uIEdyYWJzIHRoZSB0ZXh0IGNvbnRlbnQgYW5kIFwic2xpY2VzXCJcbiAqIGl0IHRvIGJlIGdlbmVyYXRlZCBpbnRvIHRoZSBuZXcgVGV4dE5vZGUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBjb250YWluaW5nIHRoZSBub2RlIHdob3NlIFRleHROb2RlIGlzIHRvIGJlIGVkaXRlZC5cbiAqIEBwYXJhbSB0ZXh0Tm9kZSAtIFRoZSBUZXh0Tm9kZSB0byBiZSBlZGl0ZWQuXG4gKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBUZXh0Tm9kZS5cbiAqL1xuXG5mdW5jdGlvbiAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudChzZWxlY3Rpb24sIHRleHROb2RlKSB7XG4gIGlmICh0ZXh0Tm9kZS5pc1NlbGVjdGVkKCkgJiYgIXRleHROb2RlLmlzU2VnbWVudGVkKCkgJiYgIXRleHROb2RlLmlzVG9rZW4oKSAmJiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgaXNBbmNob3IgPSB0ZXh0Tm9kZS5pcyhhbmNob3JOb2RlKTtcbiAgICBjb25zdCBpc0ZvY3VzID0gdGV4dE5vZGUuaXMoZm9jdXNOb2RlKTtcblxuICAgIGlmIChpc0FuY2hvciB8fCBpc0ZvY3VzKSB7XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICAgIGNvbnN0IFthbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0XSA9IHNlbGVjdGlvbi5nZXRDaGFyYWN0ZXJPZmZzZXRzKCk7XG4gICAgICBjb25zdCBpc1NhbWUgPSBhbmNob3JOb2RlLmlzKGZvY3VzTm9kZSk7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gdGV4dE5vZGUuaXMoaXNCYWNrd2FyZCA/IGZvY3VzTm9kZSA6IGFuY2hvck5vZGUpO1xuICAgICAgY29uc3QgaXNMYXN0ID0gdGV4dE5vZGUuaXMoaXNCYWNrd2FyZCA/IGFuY2hvck5vZGUgOiBmb2N1c05vZGUpO1xuICAgICAgbGV0IHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgIGxldCBlbmRPZmZzZXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc1NhbWUpIHtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBlbmRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGVuZE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICBlbmRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIHRleHROb2RlLl9fdGV4dCA9IHRleHROb2RlLl9fdGV4dC5zbGljZShzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgIHJldHVybiB0ZXh0Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGV4dE5vZGU7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGF0IHRoZSBlbmQgb2YgdGhlIG5vZGUuXG4gKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgb2YgdGhlIHNlbGVjdGlvbiB0byB0ZXN0LlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcG9pbnQgb2Zmc2V0IGlzIGluIHRoZSBsYXN0IHBvc3NpYmxlIHBvc2l0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gJGlzQXROb2RlRW5kKHBvaW50KSB7XG4gIGlmIChwb2ludC50eXBlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4gcG9pbnQub2Zmc2V0ID09PSBwb2ludC5nZXROb2RlKCkuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gIH1cblxuICByZXR1cm4gcG9pbnQub2Zmc2V0ID09PSBwb2ludC5nZXROb2RlKCkuZ2V0Q2hpbGRyZW5TaXplKCk7XG59XG4vKipcbiAqIFRyaW1zIHRleHQgZnJvbSBhIG5vZGUgaW4gb3JkZXIgdG8gc2hvcnRlbiBpdCwgZWcuIHRvIGVuZm9yY2UgYSB0ZXh0J3MgbWF4IGxlbmd0aC4gSWYgaXQgZGVsZXRlcyB0ZXh0XG4gKiB0aGF0IGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBhbmNob3IgdGhlbiBpdCB3aWxsIGxlYXZlIDIgaW5kZW50cywgb3RoZXJ3aXNlLCBpZiBubyB0ZXh0IGNvbnRlbnQgZXhpc3RzLCBpdCBkZWxldGVzXG4gKiB0aGUgVGV4dE5vZGUuIEl0IHdpbGwgbW92ZSB0aGUgZm9jdXMgdG8gZWl0aGVyIHRoZSBlbmQgb2YgYW55IGxlZnQgb3ZlciB0ZXh0IG9yIGJlZ2lubmluZyBvZiBhIG5ldyBUZXh0Tm9kZS5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gYW5jaG9yIC0gVGhlIGFuY2hvciBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24sIHdoZXJlIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIHBvaW50aW5nLlxuICogQHBhcmFtIGRlbENvdW50IC0gVGhlIGFtb3VudCBvZiBjaGFyYWN0ZXJzIHRvIGRlbGV0ZS4gVXNlZnVsIGFzIGEgZHluYW1pYyB2YXJpYWJsZSBlZy4gdGV4dENvbnRlbnRTaXplIC0gbWF4TGVuZ3RoO1xuICovXG5cbmZ1bmN0aW9uIHRyaW1UZXh0Q29udGVudEZyb21BbmNob3IoZWRpdG9yLCBhbmNob3IsIGRlbENvdW50KSB7XG4gIC8vIFdvcmsgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5jaG9yIHBvaW50XG4gIGxldCBjdXJyZW50Tm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGxldCByZW1haW5pbmcgPSBkZWxDb3VudDtcblxuICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBkZXNjZW5kYW50Tm9kZSA9IGN1cnJlbnROb2RlLmdldERlc2NlbmRhbnRCeUluZGV4KGFuY2hvci5vZmZzZXQpO1xuXG4gICAgaWYgKGRlc2NlbmRhbnROb2RlICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGRlc2NlbmRhbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChyZW1haW5pbmcgPiAwICYmIGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgbGV0IG5leHROb2RlID0gY3VycmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgbGV0IGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZSA9IDA7XG5cbiAgICBpZiAobmV4dE5vZGUgPT09IG51bGwpIHtcbiAgICAgIGxldCBwYXJlbnQgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBsZXQgcGFyZW50U2libGluZyA9IHBhcmVudC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgICAgd2hpbGUgKHBhcmVudFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuXG4gICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZSA9IHBhcmVudC5pc0lubGluZSgpID8gMCA6IDI7XG5cbiAgICAgICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUocGFyZW50U2libGluZykpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IHBhcmVudFNpYmxpbmcuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IHBhcmVudFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgdGV4dCA9IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50KCk7IC8vIElmIHRoZSB0ZXh0IGlzIGVtcHR5LCB3ZSBuZWVkIHRvIGNvbnNpZGVyIGFkZGluZyBpbiB0d28gbGluZSBicmVha3MgdG8gbWF0Y2hcbiAgICAvLyB0aGUgY29udGVudCBpZiB3ZSB3ZXJlIHRvIGdldCBpdCBmcm9tIGl0cyBwYXJlbnQuXG5cbiAgICBpZiAodGV4dCA9PT0gJycgJiYgbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgIWN1cnJlbnROb2RlLmlzSW5saW5lKCkpIHtcbiAgICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIGhhbmRsZWQgaW4gY29yZT9cbiAgICAgIHRleHQgPSAnXFxuXFxuJztcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50Tm9kZVNpemUgPSBjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNUZXh0Tm9kZShjdXJyZW50Tm9kZSkgfHwgcmVtYWluaW5nID49IGN1cnJlbnROb2RlU2l6ZSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gY3VycmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBjdXJyZW50Tm9kZS5yZW1vdmUoKTtcblxuICAgICAgaWYgKHBhcmVudCAhPSBudWxsICYmIHBhcmVudC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCAmJiAhbGV4aWNhbC4kaXNSb290Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgcmVtYWluaW5nIC09IGN1cnJlbnROb2RlU2l6ZSArIGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZTtcbiAgICAgIGN1cnJlbnROb2RlID0gbmV4dE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleSA9IGN1cnJlbnROb2RlLmdldEtleSgpOyAvLyBTZWUgaWYgd2UgY2FuIGp1c3QgcmV2ZXJ0IGl0IHRvIHdoYXQgd2FzIGluIHRoZSBsYXN0IGVkaXRvciBzdGF0ZVxuXG4gICAgICBjb25zdCBwcmV2VGV4dENvbnRlbnQgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldk5vZGUgPSBsZXhpY2FsLiRnZXROb2RlQnlLZXkoa2V5KTtcblxuICAgICAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShwcmV2Tm9kZSkgJiYgcHJldk5vZGUuaXNTaW1wbGVUZXh0KCkpIHtcbiAgICAgICAgICByZXR1cm4gcHJldk5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBjdXJyZW50Tm9kZVNpemUgLSByZW1haW5pbmc7XG4gICAgICBjb25zdCBzbGljZWRUZXh0ID0gdGV4dC5zbGljZSgwLCBvZmZzZXQpO1xuXG4gICAgICBpZiAocHJldlRleHRDb250ZW50ICE9PSBudWxsICYmIHByZXZUZXh0Q29udGVudCAhPT0gdGV4dCkge1xuICAgICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IGN1cnJlbnROb2RlO1xuXG4gICAgICAgIGlmICghY3VycmVudE5vZGUuaXNTaW1wbGVUZXh0KCkpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IGxleGljYWwuJGNyZWF0ZVRleHROb2RlKHByZXZUZXh0Q29udGVudCk7XG4gICAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gdGV4dE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE5vZGUuc2V0VGV4dENvbnRlbnQocHJldlRleHRDb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIHByZXZTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICAgIGNvbnN0IHByZXZPZmZzZXQgPSBwcmV2U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQ7XG4gICAgICAgICAgdGFyZ2V0LnNlbGVjdChwcmV2T2Zmc2V0LCBwcmV2T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50Tm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgICAvLyBTcGxpdCB0ZXh0XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBhbmNob3Iua2V5ID09PSBrZXk7XG4gICAgICAgIGxldCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0OyAvLyBNb3ZlIG9mZnNldCB0byBlbmQgaWYgaXQncyBsZXNzIHRoYW4gdGhlIHJlbWFpbmluZyBudW1iZXIsIG90aGVyd2lzZVxuICAgICAgICAvLyB3ZSdsbCBoYXZlIGEgbmVnYXRpdmUgc3BsaXRTdGFydC5cblxuICAgICAgICBpZiAoYW5jaG9yT2Zmc2V0IDwgcmVtYWluaW5nKSB7XG4gICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gY3VycmVudE5vZGVTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3BsaXRTdGFydCA9IGlzU2VsZWN0ZWQgPyBhbmNob3JPZmZzZXQgLSByZW1haW5pbmcgOiAwO1xuICAgICAgICBjb25zdCBzcGxpdEVuZCA9IGlzU2VsZWN0ZWQgPyBhbmNob3JPZmZzZXQgOiBvZmZzZXQ7XG5cbiAgICAgICAgaWYgKGlzU2VsZWN0ZWQgJiYgc3BsaXRTdGFydCA9PT0gMCkge1xuICAgICAgICAgIGNvbnN0IFtleGNlc3NOb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChzcGxpdFN0YXJ0LCBzcGxpdEVuZCk7XG4gICAgICAgICAgZXhjZXNzTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBbLCBleGNlc3NOb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChzcGxpdFN0YXJ0LCBzcGxpdEVuZCk7XG4gICAgICAgICAgZXhjZXNzTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBsZXhpY2FsLiRjcmVhdGVUZXh0Tm9kZShzbGljZWRUZXh0KTtcbiAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJlbWFpbmluZyA9IDA7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdldHMgdGhlIFRleHROb2RlJ3Mgc3R5bGUgb2JqZWN0IGFuZCBhZGRzIHRoZSBzdHlsZXMgdG8gdGhlIENTUy5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIFRleHROb2RlIHRvIGFkZCBzdHlsZXMgdG8uXG4gKi9cblxuZnVuY3Rpb24gJGFkZE5vZGVTdHlsZShub2RlKSB7XG4gIGNvbnN0IENTU1RleHQgPSBub2RlLmdldFN0eWxlKCk7XG4gIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlT2JqZWN0RnJvbVJhd0NTUyhDU1NUZXh0KTtcbiAgQ1NTX1RPX1NUWUxFUy5zZXQoQ1NTVGV4dCwgc3R5bGVzKTtcbn1cblxuZnVuY3Rpb24gJHBhdGNoU3R5bGUodGFyZ2V0LCBwYXRjaCkge1xuICBjb25zdCBwcmV2U3R5bGVzID0gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKCdnZXRTdHlsZScgaW4gdGFyZ2V0ID8gdGFyZ2V0LmdldFN0eWxlKCkgOiB0YXJnZXQuc3R5bGUpO1xuICBjb25zdCBuZXdTdHlsZXMgPSBPYmplY3QuZW50cmllcyhwYXRjaCkucmVkdWNlKChzdHlsZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgZGVsZXRlIHN0eWxlc1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZXM7XG4gIH0sIHsgLi4ucHJldlN0eWxlc1xuICB9IHx8IHt9KTtcbiAgY29uc3QgbmV3Q1NTVGV4dCA9IGdldENTU0Zyb21TdHlsZU9iamVjdChuZXdTdHlsZXMpO1xuICB0YXJnZXQuc2V0U3R5bGUobmV3Q1NTVGV4dCk7XG4gIENTU19UT19TVFlMRVMuc2V0KG5ld0NTU1RleHQsIG5ld1N0eWxlcyk7XG59XG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb3ZpZGVkIHN0eWxlcyB0byB0aGUgVGV4dE5vZGVzIGluIHRoZSBwcm92aWRlZCBTZWxlY3Rpb24uXG4gKiBXaWxsIHVwZGF0ZSBwYXJ0aWFsbHkgc2VsZWN0ZWQgVGV4dE5vZGVzIGJ5IHNwbGl0dGluZyB0aGUgVGV4dE5vZGUgYW5kIGFwcGx5aW5nXG4gKiB0aGUgc3R5bGVzIHRvIHRoZSBhcHByb3ByaWF0ZSBvbmUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGVkIG5vZGUocykgdG8gdXBkYXRlLlxuICogQHBhcmFtIHBhdGNoIC0gVGhlIHBhdGNoIHRvIGFwcGx5LCB3aGljaCBjYW4gaW5jbHVkZSBtdWx0aXBsZSBzdHlsZXMuIHsgQ1NTUHJvcGVydHk6IHZhbHVlIH1cbiAqL1xuXG5cbmZ1bmN0aW9uICRwYXRjaFN0eWxlVGV4dChzZWxlY3Rpb24sIHBhdGNoKSB7XG4gIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3Qgc2VsZWN0ZWROb2Rlc0xlbmd0aCA9IHNlbGVjdGVkTm9kZXMubGVuZ3RoO1xuICBjb25zdCBsYXN0SW5kZXggPSBzZWxlY3RlZE5vZGVzTGVuZ3RoIC0gMTtcbiAgbGV0IGZpcnN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbMF07XG4gIGxldCBsYXN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbbGFzdEluZGV4XTtcblxuICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAkcGF0Y2hTdHlsZShzZWxlY3Rpb24sIHBhdGNoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgZmlyc3ROb2RlVGV4dCA9IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICBjb25zdCBmaXJzdE5vZGVUZXh0TGVuZ3RoID0gZmlyc3ROb2RlVGV4dC5sZW5ndGg7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICBsZXQgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgaXNCZWZvcmUgPSBhbmNob3IuaXNCZWZvcmUoZm9jdXMpO1xuICBsZXQgc3RhcnRPZmZzZXQgPSBpc0JlZm9yZSA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICBsZXQgZW5kT2Zmc2V0ID0gaXNCZWZvcmUgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgY29uc3Qgc3RhcnRUeXBlID0gaXNCZWZvcmUgPyBhbmNob3IudHlwZSA6IGZvY3VzLnR5cGU7XG4gIGNvbnN0IGVuZFR5cGUgPSBpc0JlZm9yZSA/IGZvY3VzLnR5cGUgOiBhbmNob3IudHlwZTtcbiAgY29uc3QgZW5kS2V5ID0gaXNCZWZvcmUgPyBmb2N1cy5rZXkgOiBhbmNob3Iua2V5OyAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZXJlIHRoZSB1c2VyIG9ubHkgc2VsZWN0ZWQgdGhlIHZlcnkgZW5kIG9mIHRoZVxuICAvLyBmaXJzdCBub2RlIHNvIHdlIGRvbid0IHdhbnQgdG8gaW5jbHVkZSBpdCBpbiB0aGUgZm9ybWF0dGluZyBjaGFuZ2UuXG5cbiAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSAmJiBzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlVGV4dExlbmd0aCkge1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gZmlyc3ROb2RlLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIC8vIHdlIGJhc2ljYWxseSBtYWtlIHRoZSBzZWNvbmQgbm9kZSB0aGUgZmlyc3ROb2RlLCBjaGFuZ2luZyBvZmZzZXRzIGFjY29yZGluZ2x5XG4gICAgICBhbmNob3JPZmZzZXQgPSAwO1xuICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgZmlyc3ROb2RlID0gbmV4dFNpYmxpbmc7XG4gICAgfVxuICB9IC8vIFRoaXMgaXMgdGhlIGNhc2Ugd2hlcmUgd2Ugb25seSBzZWxlY3RlZCBhIHNpbmdsZSBub2RlXG5cblxuICBpZiAoc2VsZWN0ZWROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShmaXJzdE5vZGUpKSB7XG4gICAgICBzdGFydE9mZnNldCA9IHN0YXJ0VHlwZSA9PT0gJ2VsZW1lbnQnID8gMCA6IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgICBlbmRPZmZzZXQgPSBlbmRUeXBlID09PSAnZWxlbWVudCcgPyBmaXJzdE5vZGVUZXh0TGVuZ3RoIDogYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDsgLy8gTm8gYWN0dWFsIHRleHQgaXMgc2VsZWN0ZWQsIHNvIGRvIG5vdGhpbmcuXG5cbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gZW5kT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gVGhlIGVudGlyZSBub2RlIGlzIHNlbGVjdGVkLCBzbyBqdXN0IGZvcm1hdCBpdFxuXG5cbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgPT09IGZpcnN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgICAgJHBhdGNoU3R5bGUoZmlyc3ROb2RlLCBwYXRjaCk7XG4gICAgICAgIGZpcnN0Tm9kZS5zZWxlY3Qoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgbm9kZSBpcyBwYXJ0aWFsbHkgc2VsZWN0ZWQsIHNvIHNwbGl0IGl0IGludG8gdHdvIG5vZGVzXG4gICAgICAgIC8vIGFuZCBzdHlsZSB0aGUgc2VsZWN0ZWQgb25lLlxuICAgICAgICBjb25zdCBzcGxpdE5vZGVzID0gZmlyc3ROb2RlLnNwbGl0VGV4dChzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBzdGFydE9mZnNldCA9PT0gMCA/IHNwbGl0Tm9kZXNbMF0gOiBzcGxpdE5vZGVzWzFdO1xuICAgICAgICAkcGF0Y2hTdHlsZShyZXBsYWNlbWVudCwgcGF0Y2gpO1xuICAgICAgICByZXBsYWNlbWVudC5zZWxlY3QoMCwgZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQpO1xuICAgICAgfVxuICAgIH0gLy8gbXVsdGlwbGUgbm9kZXMgc2VsZWN0ZWQuXG5cbiAgfSBlbHNlIHtcbiAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShmaXJzdE5vZGUpICYmIHN0YXJ0T2Zmc2V0IDwgZmlyc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICBpZiAoc3RhcnRPZmZzZXQgIT09IDApIHtcbiAgICAgICAgLy8gdGhlIGVudGlyZSBmaXJzdCBub2RlIGlzbid0IHNlbGVjdGVkLCBzbyBzcGxpdCBpdFxuICAgICAgICBmaXJzdE5vZGUgPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0KVsxXTtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgfVxuXG4gICAgICAkcGF0Y2hTdHlsZShmaXJzdE5vZGUsIHBhdGNoKTtcbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShsYXN0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGxhc3ROb2RlVGV4dCA9IGxhc3ROb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCBsYXN0Tm9kZVRleHRMZW5ndGggPSBsYXN0Tm9kZVRleHQubGVuZ3RoOyAvLyBUaGUgbGFzdCBub2RlIG1pZ2h0IG5vdCBhY3R1YWxseSBiZSB0aGUgZW5kIG5vZGVcbiAgICAgIC8vXG4gICAgICAvLyBJZiBub3QsIGFzc3VtZSB0aGUgbGFzdCBub2RlIGlzIGZ1bGx5LXNlbGVjdGVkIHVubGVzcyB0aGUgZW5kIG9mZnNldCBpc1xuICAgICAgLy8gemVyby5cblxuICAgICAgaWYgKGxhc3ROb2RlLl9fa2V5ICE9PSBlbmRLZXkgJiYgZW5kT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgIGVuZE9mZnNldCA9IGxhc3ROb2RlVGV4dExlbmd0aDtcbiAgICAgIH0gLy8gaWYgdGhlIGVudGlyZSBsYXN0IG5vZGUgaXNuJ3Qgc2VsZWN0ZWQsIHNwbGl0IGl0XG5cblxuICAgICAgaWYgKGVuZE9mZnNldCAhPT0gbGFzdE5vZGVUZXh0TGVuZ3RoKSB7XG4gICAgICAgIFtsYXN0Tm9kZV0gPSBsYXN0Tm9kZS5zcGxpdFRleHQoZW5kT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZE9mZnNldCAhPT0gMCkge1xuICAgICAgICAkcGF0Y2hTdHlsZShsYXN0Tm9kZSwgcGF0Y2gpO1xuICAgICAgfVxuICAgIH0gLy8gc3R5bGUgYWxsIHRoZSB0ZXh0IG5vZGVzIGluIGJldHdlZW5cblxuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gc2VsZWN0ZWROb2Rlc1tpXTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZUtleSA9IHNlbGVjdGVkTm9kZS5nZXRLZXkoKTtcblxuICAgICAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoc2VsZWN0ZWROb2RlKSAmJiBzZWxlY3RlZE5vZGVLZXkgIT09IGZpcnN0Tm9kZS5nZXRLZXkoKSAmJiBzZWxlY3RlZE5vZGVLZXkgIT09IGxhc3ROb2RlLmdldEtleSgpICYmICFzZWxlY3RlZE5vZGUuaXNUb2tlbigpKSB7XG4gICAgICAgICRwYXRjaFN0eWxlKHNlbGVjdGVkTm9kZSwgcGF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG4vKipcbiAqIENvbnZlcnRzIGFsbCBub2RlcyBpbiB0aGUgc2VsZWN0aW9uIHRoYXQgYXJlIG9mIG9uZSBibG9jayB0eXBlIHRvIGFub3RoZXIuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGVkIGJsb2NrcyB0byBiZSBjb252ZXJ0ZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIFRoZSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIG5vZGUuIGVnLiAkY3JlYXRlUGFyYWdyYXBoTm9kZS5cbiAqL1xuXG5mdW5jdGlvbiAkc2V0QmxvY2tzVHlwZShzZWxlY3Rpb24sIGNyZWF0ZUVsZW1lbnQpIHtcbiAgaWYgKHNlbGVjdGlvbi5hbmNob3Iua2V5ID09PSAncm9vdCcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgIGNvbnN0IHJvb3QgPSBsZXhpY2FsLiRnZXRSb290KCk7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IHJvb3QuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgIGZpcnN0Q2hpbGQucmVwbGFjZShlbGVtZW50LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5hcHBlbmQoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgbGV0IG1heWJlQmxvY2sgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKS5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgaWYgKG5vZGVzLmluZGV4T2YobWF5YmVCbG9jaykgPT09IC0xKSB7XG4gICAgbm9kZXMucHVzaChtYXliZUJsb2NrKTtcbiAgfVxuXG4gIGlmIChtYXliZUJsb2NrLmlzSW5saW5lKCkpIHtcbiAgICBtYXliZUJsb2NrID0gbWF5YmVCbG9jay5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgICBpZiAobm9kZXMuaW5kZXhPZihtYXliZUJsb2NrKSA9PT0gLTEpIHtcbiAgICAgIG5vZGVzLnB1c2gobWF5YmVCbG9jayk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmICghaXNCbG9jayhub2RlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICB0YXJnZXRFbGVtZW50LnNldEZvcm1hdChub2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gICAgdGFyZ2V0RWxlbWVudC5zZXRJbmRlbnQobm9kZS5nZXRJbmRlbnQoKSk7XG4gICAgbm9kZS5yZXBsYWNlKHRhcmdldEVsZW1lbnQsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQmxvY2sobm9kZSkge1xuICBpZiAoIWxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkgfHwgbGV4aWNhbC4kaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICBjb25zdCBpc0xlYWZFbGVtZW50ID0gZmlyc3RDaGlsZCA9PT0gbnVsbCB8fCBsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUoZmlyc3RDaGlsZCkgfHwgbGV4aWNhbC4kaXNUZXh0Tm9kZShmaXJzdENoaWxkKSB8fCBmaXJzdENoaWxkLmlzSW5saW5lKCk7XG4gIHJldHVybiAhbm9kZS5pc0lubGluZSgpICYmIG5vZGUuY2FuQmVFbXB0eSgpICE9PSBmYWxzZSAmJiBpc0xlYWZFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1BvaW50QXR0YWNoZWQocG9pbnQpIHtcbiAgcmV0dXJuIHBvaW50LmdldE5vZGUoKS5pc0F0dGFjaGVkKCk7XG59XG5cbmZ1bmN0aW9uICRyZW1vdmVQYXJlbnRFbXB0eUVsZW1lbnRzKHN0YXJ0aW5nTm9kZSkge1xuICBsZXQgbm9kZSA9IHN0YXJ0aW5nTm9kZTtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiAhbGV4aWNhbC4kaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgY29uc3QgbGF0ZXN0ID0gbm9kZS5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChsYXRlc3QuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgIG5vZGUucmVtb3ZlKHRydWUpO1xuICAgIH1cblxuICAgIG5vZGUgPSBwYXJlbnROb2RlO1xuICB9XG59XG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBXcmFwcyBhbGwgbm9kZXMgaW4gdGhlIHNlbGVjdGlvbiBpbnRvIGFub3RoZXIgbm9kZSBvZiB0aGUgdHlwZSByZXR1cm5lZCBieSBjcmVhdGVFbGVtZW50LlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gb2Ygbm9kZXMgdG8gYmUgd3JhcHBlZC5cbiAqIEBwYXJhbSBjcmVhdGVFbGVtZW50IC0gQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIHdyYXBwaW5nIEVsZW1lbnROb2RlLiBlZy4gJGNyZWF0ZVBhcmFncmFwaE5vZGUuXG4gKiBAcGFyYW0gd3JhcHBpbmdFbGVtZW50IC0gQW4gZWxlbWVudCB0byBhcHBlbmQgdGhlIHdyYXBwZWQgc2VsZWN0aW9uIGFuZCBpdHMgY2hpbGRyZW4gdG8uXG4gKi9cblxuXG5mdW5jdGlvbiAkd3JhcE5vZGVzKHNlbGVjdGlvbiwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcblxuICBpZiAobm9kZXNMZW5ndGggPT09IDAgfHwgbm9kZXNMZW5ndGggPT09IDEgJiYgYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBhbmNob3IuZ2V0Tm9kZSgpLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gYW5jaG9yLnR5cGUgPT09ICd0ZXh0JyA/IGFuY2hvci5nZXROb2RlKCkuZ2V0UGFyZW50T3JUaHJvdygpIDogYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRhcmdldC5nZXRDaGlsZHJlbigpO1xuICAgIGxldCBlbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgIGVsZW1lbnQuc2V0Rm9ybWF0KHRhcmdldC5nZXRGb3JtYXRUeXBlKCkpO1xuICAgIGVsZW1lbnQuc2V0SW5kZW50KHRhcmdldC5nZXRJbmRlbnQoKSk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBlbGVtZW50LmFwcGVuZChjaGlsZCkpO1xuXG4gICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IHdyYXBwaW5nRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgdGFyZ2V0LnJlcGxhY2UoZWxlbWVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHRvcExldmVsTm9kZSA9IG51bGw7XG4gIGxldCBkZXNjZW5kYW50cyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTsgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgd3JhcHBpbmcgaGFzIHRvIGJlIGJyb2tlbiBkb3duIGludG8gbXVsdGlwbGUgY2h1bmtzLiBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlXG4gICAgLy8gdXNlciBzZWxlY3RlZCBtdWx0aXBsZSBSb290LWxpa2Ugbm9kZXMgdGhhdCBoYXZlIHRvIGJlIHRyZWF0ZWQgc2VwYXJhdGVseSBhcyBpZiB0aGV5IGFyZVxuICAgIC8vIHRoZWlyIG93biBicmFuY2guIEkuZS4geW91IGRvbid0IHdhbnQgdG8gd3JhcCBhIHdob2xlIHRhYmxlLCBidXQgcmF0aGVyIHRoZSBjb250ZW50cyBvZiBlYWNoXG4gICAgLy8gb2YgZWFjaCBvZiB0aGUgY2VsbCBub2Rlcy5cblxuICAgIGlmIChsZXhpY2FsLiRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICAgICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzLmxlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIGRlc2NlbmRhbnRzID0gW107XG4gICAgICB0b3BMZXZlbE5vZGUgPSBub2RlO1xuICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxOb2RlID09PSBudWxsIHx8IHRvcExldmVsTm9kZSAhPT0gbnVsbCAmJiBsZXhpY2FsLiRoYXNBbmNlc3Rvcihub2RlLCB0b3BMZXZlbE5vZGUpKSB7XG4gICAgICBkZXNjZW5kYW50cy5wdXNoKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICBkZXNjZW5kYW50cyA9IFtub2RlXTtcbiAgICB9XG4gIH1cblxuICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG59XG4vKipcbiAqIFdyYXBzIGVhY2ggbm9kZSBpbnRvIGEgbmV3IEVsZW1lbnROb2RlLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gb2Ygbm9kZXMgdG8gd3JhcC5cbiAqIEBwYXJhbSBub2RlcyAtIEFuIGFycmF5IG9mIG5vZGVzLCBnZW5lcmFsbHkgdGhlIGRlc2NlbmRhbnRzIG9mIHRoZSBzZWxlY3Rpb24uXG4gKiBAcGFyYW0gbm9kZXNMZW5ndGggLSBUaGUgbGVuZ3RoIG9mIG5vZGVzLlxuICogQHBhcmFtIGNyZWF0ZUVsZW1lbnQgLSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBpbmcgRWxlbWVudE5vZGUuIGVnLiAkY3JlYXRlUGFyYWdyYXBoTm9kZS5cbiAqIEBwYXJhbSB3cmFwcGluZ0VsZW1lbnQgLSBBbiBlbGVtZW50IHRvIHdyYXAgYWxsIHRoZSBub2RlcyBpbnRvLlxuICogQHJldHVybnNcbiAqL1xuXG5mdW5jdGlvbiAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIG5vZGVzLCBub2Rlc0xlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZmlyc3ROb2RlID0gbm9kZXNbMF07XG4gIGNvbnN0IGVsZW1lbnRNYXBwaW5nID0gbmV3IE1hcCgpO1xuICBjb25zdCBlbGVtZW50cyA9IFtdOyAvLyBUaGUgYmVsb3cgbG9naWMgaXMgdG8gZmluZCB0aGUgcmlnaHQgdGFyZ2V0IGZvciB1cyB0b1xuICAvLyBlaXRoZXIgaW5zZXJ0QWZ0ZXIvaW5zZXJ0QmVmb3JlL2FwcGVuZCB0aGUgY29ycmVzcG9uZGluZ1xuICAvLyBlbGVtZW50cyB0by4gVGhpcyBpcyBtYWRlIG1vcmUgY29tcGxpY2F0ZWQgZHVlIHRvIG5lc3RlZFxuICAvLyBzdHJ1Y3R1cmVzLlxuXG4gIGxldCB0YXJnZXQgPSBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGZpcnN0Tm9kZSkgPyBmaXJzdE5vZGUgOiBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gIGlmICh0YXJnZXQuaXNJbmxpbmUoKSkge1xuICAgIHRhcmdldCA9IHRhcmdldC5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cblxuICBsZXQgdGFyZ2V0SXNQcmV2U2libGluZyA9IGZhbHNlO1xuXG4gIHdoaWxlICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRhcmdldC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgdGFyZ2V0ID0gcHJldlNpYmxpbmc7XG4gICAgICB0YXJnZXRJc1ByZXZTaWJsaW5nID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRhcmdldCA9IHRhcmdldC5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNSb290T3JTaGFkb3dSb290KHRhcmdldCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVtcHR5RWxlbWVudHMgPSBuZXcgU2V0KCk7IC8vIEZpbmQgYW55IHRvcCBsZXZlbCBlbXB0eSBlbGVtZW50c1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgIGVtcHR5RWxlbWVudHMuYWRkKG5vZGUuZ2V0S2V5KCkpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1vdmVkTm9kZXMgPSBuZXcgU2V0KCk7IC8vIE1vdmUgb3V0IGFsbCBsZWFmIG5vZGVzIGludG8gb3VyIGVsZW1lbnRzIGFycmF5LlxuICAvLyBJZiB3ZSBmaW5kIGEgdG9wIGxldmVsIGVtcHR5IGVsZW1lbnQsIGFsc28gbW92ZSBtYWtlXG4gIC8vIGFuIGVsZW1lbnQgZm9yIHRoYXQuXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGxldCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuaXNJbmxpbmUoKSkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQgIT09IG51bGwgJiYgbGV4aWNhbC4kaXNMZWFmTm9kZShub2RlKSAmJiAhbW92ZWROb2Rlcy5oYXMobm9kZS5nZXRLZXkoKSkpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IHBhcmVudC5nZXRLZXkoKTtcblxuICAgICAgaWYgKGVsZW1lbnRNYXBwaW5nLmdldChwYXJlbnRLZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRGb3JtYXQocGFyZW50LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KHBhcmVudC5nZXRJbmRlbnQoKSk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2godGFyZ2V0RWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnRNYXBwaW5nLnNldChwYXJlbnRLZXksIHRhcmdldEVsZW1lbnQpOyAvLyBNb3ZlIG5vZGUgYW5kIGl0cyBzaWJsaW5ncyB0byB0aGUgbmV3XG4gICAgICAgIC8vIGVsZW1lbnQuXG5cbiAgICAgICAgcGFyZW50LmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgdGFyZ2V0RWxlbWVudC5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgIG1vdmVkTm9kZXMuYWRkKGNoaWxkLmdldEtleSgpKTtcblxuICAgICAgICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgLy8gU2tpcCBuZXN0ZWQgbGVhZiBub2RlcyBpZiB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gbW92ZWRcbiAgICAgICAgICAgIGNoaWxkLmdldENoaWxkcmVuS2V5cygpLmZvckVhY2goa2V5ID0+IG1vdmVkTm9kZXMuYWRkKGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRyZW1vdmVQYXJlbnRFbXB0eUVsZW1lbnRzKHBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbXB0eUVsZW1lbnRzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgIHRhcmdldEVsZW1lbnQuc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KG5vZGUuZ2V0SW5kZW50KCkpO1xuICAgICAgZWxlbWVudHMucHVzaCh0YXJnZXRFbGVtZW50KTtcbiAgICAgIG5vZGUucmVtb3ZlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICB3cmFwcGluZ0VsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBsYXN0RWxlbWVudCA9IG51bGw7IC8vIElmIG91ciB0YXJnZXQgaXMgUm9vdC1saWtlLCBsZXQncyBzZWUgaWYgd2UgY2FuIHJlLWFkanVzdFxuICAvLyBzbyB0aGF0IHRoZSB0YXJnZXQgaXMgdGhlIGZpcnN0IGNoaWxkIGluc3RlYWQuXG5cbiAgaWYgKGxleGljYWwuJGlzUm9vdE9yU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgaWYgKHRhcmdldElzUHJldlNpYmxpbmcpIHtcbiAgICAgIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gZWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0YXJnZXQuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgICB0YXJnZXQgPSBmaXJzdENoaWxkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAod3JhcHBpbmdFbGVtZW50KSB7XG4gICAgICAgICAgdGFyZ2V0LmFwcGVuZCh3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgIHRhcmdldC5hcHBlbmQoZWxlbWVudCk7XG4gICAgICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAod3JhcHBpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUod3JhcHBpbmdFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShlbGVtZW50KTtcbiAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgIHRhcmdldC5pbnNlcnRBZnRlcihlbGVtZW50KTtcbiAgICAgICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuXG4gIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIGlzUG9pbnRBdHRhY2hlZChwcmV2U2VsZWN0aW9uLmFuY2hvcikgJiYgaXNQb2ludEF0dGFjaGVkKHByZXZTZWxlY3Rpb24uZm9jdXMpKSB7XG4gICAgbGV4aWNhbC4kc2V0U2VsZWN0aW9uKHByZXZTZWxlY3Rpb24uY2xvbmUoKSk7XG4gIH0gZWxzZSBpZiAobGFzdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICBsYXN0RWxlbWVudC5zZWxlY3RFbmQoKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICB9XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGRlZmF1bHQgY2hhcmFjdGVyIHNlbGVjdGlvbiBzaG91bGQgYmUgb3ZlcnJpZGRlbi4gVXNlZCB3aXRoIERlY29yYXRvck5vZGVzXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB3aG9zZSBkZWZhdWx0IGNoYXJhY3RlciBzZWxlY3Rpb24gbWF5IG5lZWQgdG8gYmUgb3ZlcnJpZGRlbi5cbiAqIEBwYXJhbSBpc0JhY2t3YXJkIC0gSXMgdGhlIHNlbGVjdGlvbiBiYWNrd2FyZHMgKHRoZSBmb2N1cyBjb21lcyBiZWZvcmUgdGhlIGFuY2hvcik/XG4gKiBAcmV0dXJucyB0cnVlIGlmIGl0IHNob3VsZCBiZSBvdmVycmlkZGVuLCBmYWxzZSBpZiBub3QuXG4gKi9cblxuZnVuY3Rpb24gJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbihzZWxlY3Rpb24sIGlzQmFja3dhcmQpIHtcbiAgY29uc3QgcG9zc2libGVOb2RlID0gbGV4aWNhbC4kZ2V0QWRqYWNlbnROb2RlKHNlbGVjdGlvbi5mb2N1cywgaXNCYWNrd2FyZCk7XG4gIHJldHVybiBsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSB8fCBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKHBvc3NpYmxlTm9kZSkgJiYgIXBvc3NpYmxlTm9kZS5pc0lubGluZSgpICYmICFwb3NzaWJsZU5vZGUuY2FuQmVFbXB0eSgpO1xufVxuLyoqXG4gKiBNb3ZlcyB0aGUgc2VsZWN0aW9uIGFjY29yZGluZyB0byB0aGUgYXJndW1lbnRzLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3RlZCB0ZXh0IG9yIG5vZGVzLlxuICogQHBhcmFtIGlzSG9sZGluZ1NoaWZ0IC0gSXMgdGhlIHNoaWZ0IGtleSBiZWluZyBoZWxkIGRvd24gZHVyaW5nIHRoZSBvcGVyYXRpb24uXG4gKiBAcGFyYW0gaXNCYWNrd2FyZCAtIElzIHRoZSBzZWxlY3Rpb24gc2VsZWN0ZWQgYmFja3dhcmRzICh0aGUgZm9jdXMgY29tZXMgYmVmb3JlIHRoZSBhbmNob3IpP1xuICogQHBhcmFtIGdyYW51bGFyaXR5IC0gVGhlIGRpc3RhbmNlIHRvIGFkanVzdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gJG1vdmVDYXJldFNlbGVjdGlvbihzZWxlY3Rpb24sIGlzSG9sZGluZ1NoaWZ0LCBpc0JhY2t3YXJkLCBncmFudWxhcml0eSkge1xuICBzZWxlY3Rpb24ubW9kaWZ5KGlzSG9sZGluZ1NoaWZ0ID8gJ2V4dGVuZCcgOiAnbW92ZScsIGlzQmFja3dhcmQsIGdyYW51bGFyaXR5KTtcbn1cbi8qKlxuICogVGVzdHMgYSBwYXJlbnQgZWxlbWVudCBmb3IgcmlnaHQgdG8gbGVmdCBkaXJlY3Rpb24uXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB3aG9zZSBwYXJlbnQgaXMgdG8gYmUgdGVzdGVkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc2VsZWN0aW9ucycgcGFyZW50IGVsZW1lbnQgaGFzIGEgZGlyZWN0aW9uIG9mICdydGwnIChyaWdodCB0byBsZWZ0KSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uICRpc1BhcmVudEVsZW1lbnRSVEwoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgcGFyZW50ID0gbGV4aWNhbC4kaXNSb290Tm9kZShhbmNob3JOb2RlKSA/IGFuY2hvck5vZGUgOiBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgcmV0dXJuIHBhcmVudC5nZXREaXJlY3Rpb24oKSA9PT0gJ3J0bCc7XG59XG4vKipcbiAqIE1vdmVzIHNlbGVjdGlvbiBieSBjaGFyYWN0ZXIgYWNjb3JkaW5nIHRvIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIHRoZSBjaGFyYWN0ZXJzIHRvIG1vdmUuXG4gKiBAcGFyYW0gaXNIb2xkaW5nU2hpZnQgLSBJcyB0aGUgc2hpZnQga2V5IGJlaW5nIGhlbGQgZG93biBkdXJpbmcgdGhlIG9wZXJhdGlvbi5cbiAqIEBwYXJhbSBpc0JhY2t3YXJkIC0gSXMgdGhlIHNlbGVjdGlvbiBiYWNrd2FyZCAodGhlIGZvY3VzIGNvbWVzIGJlZm9yZSB0aGUgYW5jaG9yKT9cbiAqL1xuXG5mdW5jdGlvbiAkbW92ZUNoYXJhY3RlcihzZWxlY3Rpb24sIGlzSG9sZGluZ1NoaWZ0LCBpc0JhY2t3YXJkKSB7XG4gIGNvbnN0IGlzUlRMID0gJGlzUGFyZW50RWxlbWVudFJUTChzZWxlY3Rpb24pO1xuICAkbW92ZUNhcmV0U2VsZWN0aW9uKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGlzQmFja3dhcmQgPyAhaXNSVEwgOiBpc1JUTCwgJ2NoYXJhY3RlcicpO1xufVxuLyoqXG4gKiBFeHBhbmRzIHRoZSBjdXJyZW50IFNlbGVjdGlvbiB0byBjb3ZlciBhbGwgb2YgdGhlIGNvbnRlbnQgaW4gdGhlIGVkaXRvci5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gJHNlbGVjdEFsbChzZWxlY3Rpb24pIHtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCB0b3BQYXJlbnQgPSBhbmNob3JOb2RlLmdldFRvcExldmVsRWxlbWVudE9yVGhyb3coKTtcbiAgY29uc3Qgcm9vdCA9IHRvcFBhcmVudC5nZXRQYXJlbnRPclRocm93KCk7XG4gIGxldCBmaXJzdE5vZGUgPSByb290LmdldEZpcnN0RGVzY2VuZGFudCgpO1xuICBsZXQgbGFzdE5vZGUgPSByb290LmdldExhc3REZXNjZW5kYW50KCk7XG4gIGxldCBmaXJzdFR5cGUgPSAnZWxlbWVudCc7XG4gIGxldCBsYXN0VHlwZSA9ICdlbGVtZW50JztcbiAgbGV0IGxhc3RPZmZzZXQgPSAwO1xuXG4gIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICBmaXJzdFR5cGUgPSAndGV4dCc7XG4gIH0gZWxzZSBpZiAoIWxleGljYWwuJGlzRWxlbWVudE5vZGUoZmlyc3ROb2RlKSAmJiBmaXJzdE5vZGUgIT09IG51bGwpIHtcbiAgICBmaXJzdE5vZGUgPSBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG5cbiAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUobGFzdE5vZGUpKSB7XG4gICAgbGFzdFR5cGUgPSAndGV4dCc7XG4gICAgbGFzdE9mZnNldCA9IGxhc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICB9IGVsc2UgaWYgKCFsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGxhc3ROb2RlKSAmJiBsYXN0Tm9kZSAhPT0gbnVsbCkge1xuICAgIGxhc3ROb2RlID0gbGFzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG5cbiAgaWYgKGZpcnN0Tm9kZSAmJiBsYXN0Tm9kZSkge1xuICAgIGFuY2hvci5zZXQoZmlyc3ROb2RlLmdldEtleSgpLCAwLCBmaXJzdFR5cGUpO1xuICAgIGZvY3VzLnNldChsYXN0Tm9kZS5nZXRLZXkoKSwgbGFzdE9mZnNldCwgbGFzdFR5cGUpO1xuICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBDU1MgcHJvcGVydHkgZm9yIE5vZGVzLCBpZiBzZXQuIElmIG5vdCBzZXQsIGl0IHJldHVybnMgdGhlIGRlZmF1bHRWYWx1ZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgd2hvc2Ugc3R5bGUgdmFsdWUgdG8gZ2V0LlxuICogQHBhcmFtIHN0eWxlUHJvcGVydHkgLSBUaGUgQ1NTIHN0eWxlIHByb3BlcnR5LlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgcHJvcGVydHkuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGZvciBub2RlLlxuICovXG5cbmZ1bmN0aW9uICRnZXROb2RlU3R5bGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHN0eWxlUHJvcGVydHksIGRlZmF1bHRWYWx1ZSkge1xuICBjb25zdCBjc3MgPSBub2RlLmdldFN0eWxlKCk7XG4gIGNvbnN0IHN0eWxlT2JqZWN0ID0gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKGNzcyk7XG5cbiAgaWYgKHN0eWxlT2JqZWN0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0W3N0eWxlUHJvcGVydHldIHx8IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0VmFsdWU7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBDU1MgcHJvcGVydHkgZm9yIFRleHROb2RlcyBpbiB0aGUgU2VsZWN0aW9uLCBpZiBzZXQuIElmIG5vdCBzZXQsIGl0IHJldHVybnMgdGhlIGRlZmF1bHRWYWx1ZS5cbiAqIElmIGFsbCBUZXh0Tm9kZXMgZG8gbm90IGhhdmUgdGhlIHNhbWUgdmFsdWUsIGl0IHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gb2YgVGV4dE5vZGVzIHdob3NlIHZhbHVlIHRvIGZpbmQuXG4gKiBAcGFyYW0gc3R5bGVQcm9wZXJ0eSAtIFRoZSBDU1Mgc3R5bGUgcHJvcGVydHkuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBwcm9wZXJ0eSwgZGVmYXVsdHMgdG8gYW4gZW1wdHkgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBmb3IgdGhlIHNlbGVjdGVkIFRleHROb2Rlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uICRnZXRTZWxlY3Rpb25TdHlsZVZhbHVlRm9yUHJvcGVydHkoc2VsZWN0aW9uLCBzdHlsZVByb3BlcnR5LCBkZWZhdWx0VmFsdWUgPSAnJykge1xuICBsZXQgc3R5bGVWYWx1ZSA9IG51bGw7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgY29uc3QgZW5kT2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGZvY3VzLm9mZnNldCA6IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IGVuZE5vZGUgPSBpc0JhY2t3YXJkID8gZm9jdXMuZ2V0Tm9kZSgpIDogYW5jaG9yLmdldE5vZGUoKTtcblxuICBpZiAoc2VsZWN0aW9uLnN0eWxlICE9PSAnJykge1xuICAgIGNvbnN0IGNzcyA9IHNlbGVjdGlvbi5zdHlsZTtcbiAgICBjb25zdCBzdHlsZU9iamVjdCA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUyhjc3MpO1xuXG4gICAgaWYgKHN0eWxlT2JqZWN0ICE9PSBudWxsICYmIHN0eWxlUHJvcGVydHkgaW4gc3R5bGVPYmplY3QpIHtcbiAgICAgIHJldHVybiBzdHlsZU9iamVjdFtzdHlsZVByb3BlcnR5XTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldOyAvLyBpZiBubyBhY3R1YWwgY2hhcmFjdGVycyBpbiB0aGUgZW5kIG5vZGUgYXJlIHNlbGVjdGVkLCB3ZSBkb24ndFxuICAgIC8vIGluY2x1ZGUgaXQgaW4gdGhlIHNlbGVjdGlvbiBmb3IgcHVycG9zZXMgb2YgZGV0ZXJtaW5pbmcgc3R5bGVcbiAgICAvLyB2YWx1ZVxuXG4gICAgaWYgKGkgIT09IDAgJiYgZW5kT2Zmc2V0ID09PSAwICYmIG5vZGUuaXMoZW5kTm9kZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICBjb25zdCBub2RlU3R5bGVWYWx1ZSA9ICRnZXROb2RlU3R5bGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHN0eWxlUHJvcGVydHksIGRlZmF1bHRWYWx1ZSk7XG5cbiAgICAgIGlmIChzdHlsZVZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHN0eWxlVmFsdWUgPSBub2RlU3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGVWYWx1ZSAhPT0gbm9kZVN0eWxlVmFsdWUpIHtcbiAgICAgICAgLy8gbXVsdGlwbGUgdGV4dCBub2RlcyBhcmUgaW4gdGhlIHNlbGVjdGlvbiBhbmQgdGhleSBkb24ndCBhbGxcbiAgICAgICAgLy8gaGF2ZSB0aGUgc2FtZSBzdHlsZS5cbiAgICAgICAgc3R5bGVWYWx1ZSA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGVWYWx1ZSA9PT0gbnVsbCA/IGRlZmF1bHRWYWx1ZSA6IHN0eWxlVmFsdWU7XG59XG5cbmV4cG9ydHMuJGFkZE5vZGVTdHlsZSA9ICRhZGROb2RlU3R5bGU7XG5leHBvcnRzLiRjbG9uZVdpdGhQcm9wZXJ0aWVzID0gJGNsb25lV2l0aFByb3BlcnRpZXM7XG5leHBvcnRzLiRnZXRTZWxlY3Rpb25TdHlsZVZhbHVlRm9yUHJvcGVydHkgPSAkZ2V0U2VsZWN0aW9uU3R5bGVWYWx1ZUZvclByb3BlcnR5O1xuZXhwb3J0cy4kaXNBdE5vZGVFbmQgPSAkaXNBdE5vZGVFbmQ7XG5leHBvcnRzLiRpc1BhcmVudEVsZW1lbnRSVEwgPSAkaXNQYXJlbnRFbGVtZW50UlRMO1xuZXhwb3J0cy4kbW92ZUNhcmV0U2VsZWN0aW9uID0gJG1vdmVDYXJldFNlbGVjdGlvbjtcbmV4cG9ydHMuJG1vdmVDaGFyYWN0ZXIgPSAkbW92ZUNoYXJhY3RlcjtcbmV4cG9ydHMuJHBhdGNoU3R5bGVUZXh0ID0gJHBhdGNoU3R5bGVUZXh0O1xuZXhwb3J0cy4kc2VsZWN0QWxsID0gJHNlbGVjdEFsbDtcbmV4cG9ydHMuJHNldEJsb2Nrc1R5cGUgPSAkc2V0QmxvY2tzVHlwZTtcbmV4cG9ydHMuJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbiA9ICRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb247XG5leHBvcnRzLiRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50ID0gJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQ7XG5leHBvcnRzLiR3cmFwTm9kZXMgPSAkd3JhcE5vZGVzO1xuZXhwb3J0cy5jcmVhdGVET01SYW5nZSA9IGNyZWF0ZURPTVJhbmdlO1xuZXhwb3J0cy5jcmVhdGVSZWN0c0Zyb21ET01SYW5nZSA9IGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlO1xuZXhwb3J0cy5nZXRTdHlsZU9iamVjdEZyb21DU1MgPSBnZXRTdHlsZU9iamVjdEZyb21DU1M7XG5leHBvcnRzLnRyaW1UZXh0Q29udGVudEZyb21BbmNob3IgPSB0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalSelection =  true ? __webpack_require__(/*! ./LexicalSelection.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.dev.js\") : 0\nmodule.exports = LexicalSelection;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9zZWxlY3Rpb24vTGV4aWNhbFNlbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLHlCQUF5QixLQUFzQyxHQUFHLG1CQUFPLENBQUMsZ0hBQTJCLElBQUksQ0FBcUM7QUFDOUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3NlbGVjdGlvbi9MZXhpY2FsU2VsZWN0aW9uLmpzP2ExYWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxTZWxlY3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFNlbGVjdGlvbi5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbFNlbGVjdGlvbi5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbFNlbGVjdGlvbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/table/LexicalTable.dev.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lexical/table/LexicalTable.dev.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n\n/** @noInheritDoc */\nclass TableCellNode extends lexical.DEPRECATED_GridCellNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'tablecell';\n  }\n\n  static clone(node) {\n    const cellNode = new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n    cellNode.__rowSpan = node.__rowSpan;\n    cellNode.__backgroundColor = node.__backgroundColor;\n    return cellNode;\n  }\n\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const colSpan = serializedNode.colSpan || 1;\n    const rowSpan = serializedNode.rowSpan || 1;\n    const cellNode = $createTableCellNode(serializedNode.headerState, colSpan, serializedNode.width || undefined);\n    cellNode.__rowSpan = rowSpan;\n    cellNode.__backgroundColor = serializedNode.backgroundColor || null;\n    return cellNode;\n  }\n\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(colSpan, key);\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n\n    utils.addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element) {\n      const element_ = element;\n      const maxWidth = 700;\n      const colCount = this.getParentOrThrow().getChildrenSize();\n      element_.style.border = '1px solid black';\n\n      if (this.__colSpan > 1) {\n        element_.colSpan = this.__colSpan;\n      }\n\n      if (this.__rowSpan > 1) {\n        element_.rowSpan = this.__rowSpan;\n      }\n\n      element_.style.width = `${this.getWidth() || Math.max(90, maxWidth / colCount)}px`;\n      element_.style.verticalAlign = 'top';\n      element_.style.textAlign = 'start';\n      const backgroundColor = this.getBackgroundColor();\n\n      if (backgroundColor !== null) {\n        element_.style.backgroundColor = backgroundColor;\n      } else if (this.hasHeader()) {\n        element_.style.backgroundColor = '#f2f3f5';\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      headerState: this.__headerState,\n      type: 'tablecell',\n      width: this.getWidth()\n    };\n  }\n\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n\n  setHeaderStyles(headerState) {\n    const self = this.getWritable();\n    self.__headerState = headerState;\n    return this.__headerState;\n  }\n\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return this.__width;\n  }\n\n  getWidth() {\n    return this.getLatest().__width;\n  }\n\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n\n  setBackgroundColor(newBackgroundColor) {\n    this.getWritable().__backgroundColor = newBackgroundColor;\n  }\n\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n\n    return self;\n  }\n\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n\n  isShadowRoot() {\n    return true;\n  }\n\n  collapseAtStart() {\n    return true;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n}\nfunction convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n\n  return {\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !lexical.$isElementNode(lexicalNode)) {\n        const paragraphNode = lexical.$createParagraphNode();\n\n        if (lexical.$isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState, colSpan = 1, width) {\n  return lexical.$applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends lexical.DEPRECATED_GridRowNode {\n  /** @internal */\n  static getType() {\n    return 'tablerow';\n  }\n\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    return $createTableRowNode(serializedNode.height);\n  }\n\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'tablerow',\n      version: 1\n    };\n  }\n\n  createDOM(config) {\n    const element = document.createElement('tr');\n\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n\n    utils.addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n\n  isShadowRoot() {\n    return true;\n  }\n\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n\n  getHeight() {\n    return this.getLatest().__height;\n  }\n\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n}\nfunction convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n\n  return {\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return lexical.$applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n\nclass TableSelection {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.grid = {\n      cells: [],\n      columns: 0,\n      rows: 0\n    };\n    this.gridSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTableGrid();\n  }\n\n  getGrid() {\n    return this.grid;\n  }\n\n  removeListeners() {\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n  }\n\n  trackTableGrid() {\n    const observer = new MutationObserver(records => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n\n          if (nodeName === 'TABLE' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n\n        if (!gridNeedsRedraw) {\n          return;\n        }\n\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n\n        this.grid = getTableGrid(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      this.grid = getTableGrid(tableElement);\n      observer.observe(tableElement, {\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n\n  clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.gridSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.enableHighlightStyle();\n    editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      const grid = getTableGrid(tableElement);\n      $updateDOMForSelection(editor, grid, null);\n      lexical.$setSelection(null);\n      editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n\n  enableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      utils.removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n\n  disableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      utils.addClassNamesToElement(tableElement, editor._config.theme.tableSelection);\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n\n  updateTableGridSelection(selection) {\n    if (selection != null && selection.gridKey === this.tableNodeKey) {\n      const editor = this.editor;\n      this.gridSelection = selection;\n      this.isHighlightingCells = true;\n      this.disableHighlightStyle();\n      $updateDOMForSelection(editor, this.grid, this.gridSelection);\n    } else if (selection == null) {\n      this.clearHighlight();\n    }\n  }\n\n  setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n\n      if (this.anchorCell !== null) {\n        const domSelection = getDOMSelection(editor._window); // Collapse the selection\n\n        if (domSelection) {\n          domSelection.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);\n        }\n      }\n\n      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.focusX && cellY === this.focusY) {\n        return;\n      }\n\n      this.focusX = cellX;\n      this.focusY = cellY;\n\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n        if (this.gridSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode)) {\n          const focusNodeKey = focusTableCellNode.getKey();\n          this.gridSelection = this.gridSelection.clone() || lexical.DEPRECATED_$createGridSelection();\n          this.focusCellNodeKey = focusNodeKey;\n          this.gridSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey);\n          lexical.$setSelection(this.gridSelection);\n          editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n          $updateDOMForSelection(editor, this.grid, this.gridSelection);\n        }\n      }\n    });\n  }\n\n  setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    this.editor.update(() => {\n      const anchorTableCellNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.gridSelection = lexical.DEPRECATED_$createGridSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n\n  formatCells(type) {\n    this.editor.update(() => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.DEPRECATED_$isGridSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n\n      const formatSelection = lexical.$createRangeSelection();\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n      selection.getNodes().forEach(cellNode => {\n        if ($isTableCellNode(cellNode) && cellNode.getTextContentSize() !== 0) {\n          anchor.set(cellNode.getKey(), 0, 'element');\n          focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n          formatSelection.formatText(type);\n        }\n      });\n      lexical.$setSelection(selection);\n      this.editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n\n  clearText() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const selection = lexical.$getSelection();\n\n      if (!lexical.DEPRECATED_$isGridSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n\n      if (selectedNodes.length === this.grid.columns * this.grid.rows) {\n        tableNode.selectPrevious(); // Delete entire table\n\n        tableNode.remove();\n        const rootNode = lexical.$getRoot();\n        rootNode.selectStart();\n        return;\n      }\n\n      selectedNodes.forEach(cellNode => {\n        if (lexical.$isElementNode(cellNode)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          const textNode = lexical.$createTextNode();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach(child => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n      $updateDOMForSelection(editor, this.grid, null);\n      lexical.$setSelection(null);\n      editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nfunction applyTableHandlers(tableNode, tableElement, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n\n  const tableSelection = new TableSelection(editor, tableNode.getKey());\n  const editorWindow = editor._window || window;\n  attachTableSelectionToTableElement(tableElement, tableSelection);\n  tableElement.addEventListener('mousedown', event => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      }\n\n      if (!editorWindow) {\n        return;\n      }\n\n      const anchorCell = getCellFromTarget(event.target);\n\n      if (anchorCell !== null) {\n        stopEvent(event);\n        tableSelection.setAnchorCellForSelection(anchorCell);\n      }\n\n      const onMouseUp = () => {\n        editorWindow.removeEventListener('mouseup', onMouseUp);\n        editorWindow.removeEventListener('mousemove', onMouseMove);\n      };\n\n      const onMouseMove = moveEvent => {\n        const focusCell = getCellFromTarget(moveEvent.target);\n\n        if (focusCell !== null && (tableSelection.anchorX !== focusCell.x || tableSelection.anchorY !== focusCell.y)) {\n          moveEvent.preventDefault();\n          tableSelection.setFocusCellForSelection(focusCell);\n        }\n      };\n\n      editorWindow.addEventListener('mouseup', onMouseUp);\n      editorWindow.addEventListener('mousemove', onMouseMove);\n    }, 0);\n  }); // Clear selection when clicking outside of dom.\n\n  const mouseDownCallback = event => {\n    if (event.button !== 0) {\n      return;\n    }\n\n    editor.update(() => {\n      const selection = lexical.$getSelection();\n      const target = event.target;\n\n      if (lexical.DEPRECATED_$isGridSelection(selection) && selection.gridKey === tableSelection.tableNodeKey && rootElement.contains(target)) {\n        tableSelection.clearHighlight();\n      }\n    });\n  };\n\n  editorWindow.addEventListener('mousedown', mouseDownCallback);\n  tableSelection.listenersToRemove.add(() => editorWindow.removeEventListener('mousedown', mouseDownCallback));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => $handleArrowKey(editor, event, 'down', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => $handleArrowKey(editor, event, 'up', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => $handleArrowKey(editor, event, 'backward', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => $handleArrowKey(editor, event, 'forward', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      const focusCellNode = utils.$findMatchingParent(selection.focus.getNode(), $isTableCellNode);\n\n      if ($isTableCellNode(focusCellNode)) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_HIGH));\n\n  const deleteTextHandler = command => () => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.clearText();\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n\n      if (selectionContainsPartialTable) {\n        tableSelection.clearText();\n        return true;\n      }\n\n      const nearestElementNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && utils.$findMatchingParent(nearestElementNode, n => lexical.$isElementNode(n) && $isTableCellNode(n.getParent()));\n\n      if (!lexical.$isElementNode(topLevelCellElementNode) || !lexical.$isElementNode(nearestElementNode)) {\n        return false;\n      }\n\n      if (command === lexical.DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n\n      if (command === lexical.DELETE_CHARACTER_COMMAND || command === lexical.DELETE_WORD_COMMAND) {\n        if (selection.isCollapsed() && selection.anchor.offset === 0) {\n          if (nearestElementNode !== topLevelCellElementNode) {\n            const children = nearestElementNode.getChildren();\n            const newParagraphNode = lexical.$createParagraphNode();\n            children.forEach(child => newParagraphNode.append(child));\n            nearestElementNode.replace(newParagraphNode);\n            nearestElementNode.getWritable().__parent = tableCellNode.getKey();\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  [lexical.DELETE_WORD_COMMAND, lexical.DELETE_LINE_COMMAND, lexical.DELETE_CHARACTER_COMMAND].forEach(command => {\n    tableSelection.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), lexical.COMMAND_PRIORITY_CRITICAL));\n  });\n\n  const deleteCellHandler = event => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      event.preventDefault();\n      event.stopPropagation();\n      tableSelection.clearText();\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  };\n\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, deleteCellHandler, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_DELETE_COMMAND, deleteCellHandler, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.formatCells(payload);\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.clearHighlight();\n      return false;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n\n  if (hasTabHandler) {\n    tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n\n      if (tableCellNode === null) {\n        return false;\n      }\n\n      stopEvent(event);\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n      selectGridNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL));\n  }\n\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, lexical.COMMAND_PRIORITY_HIGH));\n\n  function getCellFromCellNode(tableCellNode) {\n    const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n    return tableNode.getCellFromCordsOrThrow(currentCords.x, currentCords.y, tableSelection.grid);\n  }\n\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.SELECTION_CHANGE_COMMAND, () => {\n    const selection = lexical.$getSelection();\n    const prevSelection = lexical.$getPreviousSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode(); // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = anchorCellNode && tableNode.is($findTableNode(anchorCellNode));\n      const isFocusInside = focusCellNode && tableNode.is($findTableNode(focusCellNode));\n      const isPartialyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n\n      if (isPartialyWithinTable) {\n        const newSelection = selection.clone();\n        newSelection.focus.set(tableNode.getKey(), isBackward ? 0 : tableNode.getChildrenSize(), 'element');\n        lexical.$setSelection(newSelection);\n        $addHighlightStyleToTable(editor, tableSelection);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into grid selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableSelection.setAnchorCellForSelection(getCellFromCellNode(anchorCellNode));\n          tableSelection.setFocusCellForSelection(getCellFromCellNode(focusCellNode), true);\n        }\n      }\n    }\n\n    if (selection && !selection.is(prevSelection) && (lexical.DEPRECATED_$isGridSelection(selection) || lexical.DEPRECATED_$isGridSelection(prevSelection)) && tableSelection.gridSelection && !tableSelection.gridSelection.is(prevSelection)) {\n      if (lexical.DEPRECATED_$isGridSelection(selection) && selection.gridKey === tableSelection.tableNodeKey) {\n        tableSelection.updateTableGridSelection(selection);\n      } else if (!lexical.DEPRECATED_$isGridSelection(selection) && lexical.DEPRECATED_$isGridSelection(prevSelection) && prevSelection.gridKey === tableSelection.tableNodeKey) {\n        tableSelection.updateTableGridSelection(null);\n      }\n\n      return false;\n    }\n\n    if (tableSelection.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableSelection);\n    } else if (!tableSelection.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableSelection);\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  return tableSelection;\n}\nfunction attachTableSelectionToTableElement(tableElement, tableSelection) {\n  tableElement[LEXICAL_ELEMENT_KEY] = tableSelection;\n}\nfunction getTableSelectionFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY];\n}\nfunction getCellFromTarget(node) {\n  let currentNode = node;\n\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n\n      if (cell === undefined) {\n        return null;\n      }\n\n      return cell;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n}\nfunction getTableGrid(tableElement) {\n  const cells = [];\n  const grid = {\n    cells,\n    columns: 0,\n    rows: 0\n  };\n  let currentNode = tableElement.firstChild;\n  let x = 0;\n  let y = 0;\n  cells.length = 0;\n\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      }; // @ts-expect-error: internal field\n\n      currentNode._cell = cell;\n\n      if (cells[y] === undefined) {\n        cells[y] = [];\n      }\n\n      cells[y][x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n\n    const sibling = currentNode.nextSibling;\n\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n\n    const parent = currentNode.parentNode;\n\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n\n      if (parentSibling == null) {\n        break;\n      }\n\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, grid, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachGridCell(grid, (cell, lexicalNode) => {\n    const elem = cell.elem;\n\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachGridCell(grid, cb) {\n  const {\n    cells\n  } = grid;\n\n  for (let y = 0; y < cells.length; y++) {\n    const row = cells[y];\n\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      const lexicalNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.disableHighlightStyle();\n  $forEachGridCell(tableSelection.grid, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.enableHighlightStyle();\n  $forEachGridCell(tableSelection.grid, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\n\nconst selectGridNodeInDirection = (tableSelection, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableSelection.grid.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableSelection.grid), isForward);\n      } else {\n        if (y !== (isForward ? tableSelection.grid.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableSelection.grid.columns - 1, y + (isForward ? 1 : -1), tableSelection.grid), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n\n      return true;\n\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableSelection.grid), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n\n      return true;\n\n    case 'down':\n      if (y !== tableSelection.grid.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableSelection.grid), true);\n      } else {\n        tableNode.selectNext();\n      }\n\n      return true;\n\n    default:\n      return false;\n  }\n};\n\nconst adjustFocusNodeInDirection = (tableSelection, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableSelection.grid.columns - 1 : 0)) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableSelection.grid));\n      }\n\n      return true;\n\n    case 'up':\n      if (y !== 0) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x, y - 1, tableSelection.grid));\n        return true;\n      } else {\n        return false;\n      }\n\n    case 'down':\n      if (y !== tableSelection.grid.rows - 1) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x, y + 1, tableSelection.grid));\n        return true;\n      } else {\n        return false;\n      }\n\n    default:\n      return false;\n  }\n};\n\nfunction $isSelectionInTable(selection, tableNode) {\n  if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n\n  return false;\n}\n\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\n\nconst BROWSER_BLUE_RGB = '172,206,247';\n\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const node = lexical.$getNearestNodeFromDOMNode(element);\n\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n\n  const backgroundColor = node.getBackgroundColor();\n\n  if (backgroundColor === null) {\n    element.style.setProperty('background-color', `rgb(${BROWSER_BLUE_RGB})`);\n  } else {\n    element.style.setProperty('background-image', `linear-gradient(to right, rgba(${BROWSER_BLUE_RGB},0.85), rgba(${BROWSER_BLUE_RGB},0.85))`);\n  }\n\n  element.style.setProperty('caret-color', 'transparent');\n}\n\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = lexical.$getNearestNodeFromDOMNode(element);\n\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n\n  const backgroundColor = node.getBackgroundColor();\n\n  if (backgroundColor === null) {\n    element.style.removeProperty('background-color');\n  }\n\n  element.style.removeProperty('background-image');\n  element.style.removeProperty('caret-color');\n}\n\nfunction $findCellNode(node) {\n  const cellNode = utils.$findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\n\nfunction $findTableNode(node) {\n  const tableNode = utils.$findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\n\nfunction $handleArrowKey(editor, event, direction, tableNode, tableSelection) {\n  const selection = lexical.$getSelection();\n\n  if (!$isSelectionInTable(selection, tableNode)) {\n    return false;\n  }\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed()) {\n    // Horizontal move between cels seem to work well without interruption\n    // so just exit early, and handle vertical moves\n    if (direction === 'backward' || direction === 'forward') {\n      return false;\n    }\n\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = utils.$findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = utils.$findMatchingParent(focus.getNode(), $isTableCellNode);\n\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n\n    let edgeSelectionRect;\n\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = window.getSelection();\n\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n\n    if (edgeChild == null) {\n      return false;\n    }\n\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n\n    if (edgeChildDOM == null) {\n      return false;\n    }\n\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableSelection.grid);\n\n      if (event.shiftKey) {\n        const cell = tableNode.getCellFromCordsOrThrow(cords.x, cords.y, tableSelection.grid);\n        tableSelection.setAnchorCellForSelection(cell);\n        tableSelection.setFocusCellForSelection(cell, true);\n      } else {\n        return selectGridNodeInDirection(tableSelection, tableNode, cords.x, cords.y, direction);\n      }\n\n      return true;\n    }\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = utils.$findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = utils.$findMatchingParent(focus.getNode(), $isTableCellNode);\n\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode)) {\n      return false;\n    }\n\n    stopEvent(event);\n\n    if (event.shiftKey) {\n      const cords = tableNode.getCordsFromCellNode(focusCellNode, tableSelection.grid);\n      return adjustFocusNodeInDirection(tableSelection, tableNode, cords.x, cords.y, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableNode extends lexical.DEPRECATED_GridNode {\n  /** @internal */\n  static getType() {\n    return 'table';\n  }\n\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: convertTableElement,\n        priority: 1\n      })\n    };\n  }\n\n  static importJSON(_serializedNode) {\n    return $createTableNode();\n  }\n\n  constructor(key) {\n    super(key);\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'table',\n      version: 1\n    };\n  }\n\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    utils.addClassNamesToElement(tableElement, config.theme.table);\n    return tableElement;\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  exportDOM(editor) {\n    return { ...super.exportDOM(editor),\n      after: tableElement => {\n        if (tableElement) {\n          const newElement = tableElement.cloneNode();\n          const colGroup = document.createElement('colgroup');\n          const tBody = document.createElement('tbody');\n          tBody.append(...tableElement.children);\n          const firstRow = this.getFirstChildOrThrow();\n\n          if (!$isTableRowNode(firstRow)) {\n            throw new Error('Expected to find row node.');\n          }\n\n          const colCount = firstRow.getChildrenSize();\n\n          for (let i = 0; i < colCount; i++) {\n            const col = document.createElement('col');\n            colGroup.append(col);\n          }\n\n          newElement.replaceChildren(colGroup, tBody);\n          return newElement;\n        }\n      }\n    };\n  } // TODO 0.10 deprecate\n\n\n  canExtractContents() {\n    return false;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  isShadowRoot() {\n    return true;\n  }\n\n  getCordsFromCellNode(tableCellNode, grid) {\n    const {\n      rows,\n      cells\n    } = grid;\n\n    for (let y = 0; y < rows; y++) {\n      const row = cells[y];\n\n      if (row == null) {\n        throw new Error(`Row not found at y:${y}`);\n      }\n\n      const x = row.findIndex(({\n        elem\n      }) => {\n        const cellNode = lexical.$getNearestNodeFromDOMNode(elem);\n        return cellNode === tableCellNode;\n      });\n\n      if (x !== -1) {\n        return {\n          x,\n          y\n        };\n      }\n    }\n\n    throw new Error('Cell not found in table.');\n  }\n\n  getCellFromCords(x, y, grid) {\n    const {\n      cells\n    } = grid;\n    const row = cells[y];\n\n    if (row == null) {\n      return null;\n    }\n\n    const cell = row[x];\n\n    if (cell == null) {\n      return null;\n    }\n\n    return cell;\n  }\n\n  getCellFromCordsOrThrow(x, y, grid) {\n    const cell = this.getCellFromCords(x, y, grid);\n\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n\n    return cell;\n  }\n\n  getCellNodeFromCords(x, y, grid) {\n    const cell = this.getCellFromCords(x, y, grid);\n\n    if (cell == null) {\n      return null;\n    }\n\n    const node = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n\n    return null;\n  }\n\n  getCellNodeFromCordsOrThrow(x, y, grid) {\n    const node = this.getCellNodeFromCords(x, y, grid);\n\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n\n    return node;\n  }\n\n  canSelectBefore() {\n    return true;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n}\nfunction $getElementGridForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n\n  return getTableGrid(tableElement);\n}\nfunction convertTableElement(_domNode) {\n  return {\n    node: $createTableNode()\n  };\n}\nfunction $createTableNode() {\n  return lexical.$applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) headerState |= TableCellHeaderStates.ROW;\n        if (iColumn === 0 && includeHeaders.columns) headerState |= TableCellHeaderStates.COLUMN;\n      } else if (includeHeaders) {\n        if (iRow === 0) headerState |= TableCellHeaderStates.ROW;\n        if (iColumn === 0) headerState |= TableCellHeaderStates.COLUMN;\n      }\n\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = lexical.$createParagraphNode();\n      paragraphNode.append(lexical.$createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n\n    tableNode.append(tableRowNode);\n  }\n\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableCellNode(n));\n\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableRowNode(n));\n\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableNode(n));\n\n  if ($isTableNode(node)) {\n    return node;\n  }\n\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, grid) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, grid);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, grid),\n    below: tableNode.getCellNodeFromCords(x, y + 1, grid),\n    left: tableNode.getCellNodeFromCords(x - 1, y, grid),\n    right: tableNode.getCellNodeFromCords(x + 1, y, grid)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, grid) {\n  const tableRows = tableNode.getChildren();\n\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n\n  const targetRowNode = tableRows[targetIndex];\n\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, grid);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append(lexical.$createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n\n  return tableNode;\n}\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const focus = selection.focus.getNode();\n  const [focusCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, focusCellMap] = lexical.DEPRECATED_$computeGridMap(grid, focusCell, focusCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n\n  if (insertAfter) {\n    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n    const focusEndRowMap = gridMap[focusEndRow];\n    const newRow = $createTableRowNode();\n\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusEndRowMap[i];\n\n      if (startRow + cell.__rowSpan - 1 <= focusEndRow) {\n        newRow.append($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n\n    const focusEndRowNode = grid.getChildAtIndex(focusEndRow);\n\n    if (!lexical.DEPRECATED_$isGridRowNode(focusEndRowNode)) {\n      throw Error(`focusEndRow is not a GridRowNode`);\n    }\n\n    focusEndRowNode.insertAfter(newRow);\n  } else {\n    const focusStartRowMap = gridMap[focusStartRow];\n    const newRow = $createTableRowNode();\n\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusStartRowMap[i];\n\n      if (startRow === focusStartRow) {\n        newRow.append($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n\n    const focusStartRowNode = grid.getChildAtIndex(focusStartRow);\n\n    if (!lexical.DEPRECATED_$isGridRowNode(focusStartRowNode)) {\n      throw Error(`focusEndRow is not a GridRowNode`);\n    }\n\n    focusStartRowNode.insertBefore(newRow);\n  }\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, grid) {\n  const tableRows = tableNode.getChildren();\n\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n\n        const targetCell = tableRowChildren[targetIndex];\n\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, grid);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append(lexical.$createParagraphNode());\n\n        if (shouldInsertAfter) {\n          targetCell.insertAfter(newTableCell);\n        } else {\n          targetCell.insertBefore(newTableCell);\n        }\n      }\n    }\n  }\n\n  return tableNode;\n}\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const [focusCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = lexical.DEPRECATED_$computeGridMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n\n  if (!lexical.DEPRECATED_$isGridRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n\n  let firstInsertedCell = null;\n\n  function $createTableCellNodeForInsertTableColumn() {\n    const cell = $createTableCellNode(TableCellHeaderStates.NO_STATUS).append(lexical.$createParagraphNode());\n\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n\n    return cell;\n  }\n\n  let loopRow = gridFirstChild;\n\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n\n      if (!lexical.DEPRECATED_$isGridRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n\n      loopRow = currentRow;\n    }\n\n    const rowMap = gridMap[i];\n\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn());\n      continue;\n    }\n\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn());\n          continue rowLoop;\n        }\n      }\n\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn());\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const [focusCell] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = lexical.DEPRECATED_$computeGridMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      } // Rows overflowing top have to be trimmed\n\n\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        cell.setRowSpan(cell.__rowSpan - (cellStartRow - anchorStartRow));\n      } // Rows overflowing bottom have to be trimmed and moved to the next row\n\n\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n\n        if (column === 0) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          const {\n            cell: previousCell\n          } = nextRow[column - 1];\n          previousCell.insertAfter(cell);\n        }\n      }\n    }\n\n    const rowNode = grid.getChildAtIndex(row);\n\n    if (!lexical.DEPRECATED_$isGridRowNode(rowNode)) {\n      throw Error(`Expected GridNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n\n    rowNode.remove();\n  }\n\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const [focusCell] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = lexical.DEPRECATED_$computeGridMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n\n  const rowCount = gridMap.length;\n\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn; // Overflowing left\n\n          cell.setColSpan(cell.__colSpan - // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = focusRowMap[focusStartColumn + focusCell.__colSpan];\n\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusRowMap[focusStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n}\n\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n\n  if (!(firstDescendant !== null)) {\n    throw Error(`Unexpected empty cell`);\n  }\n\n  firstDescendant.getParentOrThrow().selectStart();\n}\n\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\nfunction $unmergeCell() {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n    }\n\n    cell.setColSpan(1);\n  }\n\n  if (rowSpan > 1) {\n    const [map, cellMap] = lexical.DEPRECATED_$computeGridMap(grid, cell, cell);\n    const {\n      startColumn,\n      startRow\n    } = cellMap;\n    let currentRowNode;\n\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = row.getNextSibling();\n\n      if (!lexical.DEPRECATED_$isGridRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n\n      let insertAfterCell = null;\n\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n\n      if (insertAfterCell === null) {\n        for (let j = 0; j < colSpan; j++) {\n          $insertFirst(currentRowNode, $createTableCellNode(TableCellHeaderStates.NO_STATUS));\n        }\n      } else {\n        for (let j = 0; j < colSpan; j++) {\n          insertAfterCell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n        }\n      }\n    }\n\n    cell.setRowSpan(1);\n  }\n}\n\n/** @module @lexical/table */\nconst INSERT_TABLE_COMMAND = lexical.createCommand('INSERT_TABLE_COMMAND');\n\nexports.$createTableCellNode = $createTableCellNode;\nexports.$createTableNode = $createTableNode;\nexports.$createTableNodeWithDimensions = $createTableNodeWithDimensions;\nexports.$createTableRowNode = $createTableRowNode;\nexports.$deleteTableColumn = $deleteTableColumn;\nexports.$deleteTableColumn__EXPERIMENTAL = $deleteTableColumn__EXPERIMENTAL;\nexports.$deleteTableRow__EXPERIMENTAL = $deleteTableRow__EXPERIMENTAL;\nexports.$getElementGridForTableNode = $getElementGridForTableNode;\nexports.$getTableCellNodeFromLexicalNode = $getTableCellNodeFromLexicalNode;\nexports.$getTableColumnIndexFromTableCellNode = $getTableColumnIndexFromTableCellNode;\nexports.$getTableNodeFromLexicalNodeOrThrow = $getTableNodeFromLexicalNodeOrThrow;\nexports.$getTableRowIndexFromTableCellNode = $getTableRowIndexFromTableCellNode;\nexports.$getTableRowNodeFromTableCellNodeOrThrow = $getTableRowNodeFromTableCellNodeOrThrow;\nexports.$insertTableColumn = $insertTableColumn;\nexports.$insertTableColumn__EXPERIMENTAL = $insertTableColumn__EXPERIMENTAL;\nexports.$insertTableRow = $insertTableRow;\nexports.$insertTableRow__EXPERIMENTAL = $insertTableRow__EXPERIMENTAL;\nexports.$isTableCellNode = $isTableCellNode;\nexports.$isTableNode = $isTableNode;\nexports.$isTableRowNode = $isTableRowNode;\nexports.$removeTableRowAtIndex = $removeTableRowAtIndex;\nexports.$unmergeCell = $unmergeCell;\nexports.INSERT_TABLE_COMMAND = INSERT_TABLE_COMMAND;\nexports.TableCellHeaderStates = TableCellHeaderStates;\nexports.TableCellNode = TableCellNode;\nexports.TableNode = TableNode;\nexports.TableRowNode = TableRowNode;\nexports.TableSelection = TableSelection;\nexports.applyTableHandlers = applyTableHandlers;\nexports.getCellFromTarget = getCellFromTarget;\nexports.getTableSelectionFromTableElement = getTableSelectionFromTableElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90YWJsZS9MZXhpY2FsVGFibGUuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMseUZBQWdCOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxxREFBcUQ7QUFDckY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLEdBQUc7O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseURBQXlELGlCQUFpQjtBQUMxRSxJQUFJO0FBQ0osb0ZBQW9GLGlCQUFpQixlQUFlLGlCQUFpQjtBQUNySTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sb0JBQW9CLFVBQVU7QUFDOUI7O0FBRUE7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsaUJBQWlCO0FBQ3RDOztBQUVBLDBCQUEwQix1QkFBdUI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHNCQUFzQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsdUJBQXVCO0FBQ3JELHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQyxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEIsc0NBQXNDO0FBQ3RDLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsd0NBQXdDO0FBQ3hDLHFDQUFxQztBQUNyQyxtQ0FBbUM7QUFDbkMsd0NBQXdDO0FBQ3hDLDZDQUE2QztBQUM3QywyQ0FBMkM7QUFDM0MsMENBQTBDO0FBQzFDLGdEQUFnRDtBQUNoRCwwQkFBMEI7QUFDMUIsd0NBQXdDO0FBQ3hDLHVCQUF1QjtBQUN2QixxQ0FBcUM7QUFDckMsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLG9CQUFvQjtBQUNwQiw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsb0JBQW9CO0FBQ3BCLHNCQUFzQjtBQUN0QiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGFibGUvTGV4aWNhbFRhYmxlLmRldi5qcz8zNzhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IFBJWEVMX1ZBTFVFX1JFR19FWFAgPSAvXihcXGQrKD86XFwuXFxkKyk/KXB4JC87XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IFRhYmxlQ2VsbEhlYWRlclN0YXRlcyA9IHtcbiAgQk9USDogMyxcbiAgQ09MVU1OOiAyLFxuICBOT19TVEFUVVM6IDAsXG4gIFJPVzogMVxufTtcblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFRhYmxlQ2VsbE5vZGUgZXh0ZW5kcyBsZXhpY2FsLkRFUFJFQ0FURURfR3JpZENlbGxOb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAndGFibGVjZWxsJztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgY29uc3QgY2VsbE5vZGUgPSBuZXcgVGFibGVDZWxsTm9kZShub2RlLl9faGVhZGVyU3RhdGUsIG5vZGUuX19jb2xTcGFuLCBub2RlLl9fd2lkdGgsIG5vZGUuX19rZXkpO1xuICAgIGNlbGxOb2RlLl9fcm93U3BhbiA9IG5vZGUuX19yb3dTcGFuO1xuICAgIGNlbGxOb2RlLl9fYmFja2dyb3VuZENvbG9yID0gbm9kZS5fX2JhY2tncm91bmRDb2xvcjtcbiAgICByZXR1cm4gY2VsbE5vZGU7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGFibGVDZWxsTm9kZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHRoOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUYWJsZUNlbGxOb2RlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3QgY29sU3BhbiA9IHNlcmlhbGl6ZWROb2RlLmNvbFNwYW4gfHwgMTtcbiAgICBjb25zdCByb3dTcGFuID0gc2VyaWFsaXplZE5vZGUucm93U3BhbiB8fCAxO1xuICAgIGNvbnN0IGNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoc2VyaWFsaXplZE5vZGUuaGVhZGVyU3RhdGUsIGNvbFNwYW4sIHNlcmlhbGl6ZWROb2RlLndpZHRoIHx8IHVuZGVmaW5lZCk7XG4gICAgY2VsbE5vZGUuX19yb3dTcGFuID0gcm93U3BhbjtcbiAgICBjZWxsTm9kZS5fX2JhY2tncm91bmRDb2xvciA9IHNlcmlhbGl6ZWROb2RlLmJhY2tncm91bmRDb2xvciB8fCBudWxsO1xuICAgIHJldHVybiBjZWxsTm9kZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUywgY29sU3BhbiA9IDEsIHdpZHRoLCBrZXkpIHtcbiAgICBzdXBlcihjb2xTcGFuLCBrZXkpO1xuICAgIHRoaXMuX19oZWFkZXJTdGF0ZSA9IGhlYWRlclN0YXRlO1xuICAgIHRoaXMuX193aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX19iYWNrZ3JvdW5kQ29sb3IgPSBudWxsO1xuICB9XG5cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuZ2V0VGFnKCkpO1xuXG4gICAgaWYgKHRoaXMuX193aWR0aCkge1xuICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IGAke3RoaXMuX193aWR0aH1weGA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX19jb2xTcGFuID4gMSkge1xuICAgICAgZWxlbWVudC5jb2xTcGFuID0gdGhpcy5fX2NvbFNwYW47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX19yb3dTcGFuID4gMSkge1xuICAgICAgZWxlbWVudC5yb3dTcGFuID0gdGhpcy5fX3Jvd1NwYW47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX19iYWNrZ3JvdW5kQ29sb3IgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5fX2JhY2tncm91bmRDb2xvcjtcbiAgICB9XG5cbiAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS50YWJsZUNlbGwsIHRoaXMuaGFzSGVhZGVyKCkgJiYgY29uZmlnLnRoZW1lLnRhYmxlQ2VsbEhlYWRlcik7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBjb25zdCBlbGVtZW50XyA9IGVsZW1lbnQ7XG4gICAgICBjb25zdCBtYXhXaWR0aCA9IDcwMDtcbiAgICAgIGNvbnN0IGNvbENvdW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgICBlbGVtZW50Xy5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIGJsYWNrJztcblxuICAgICAgaWYgKHRoaXMuX19jb2xTcGFuID4gMSkge1xuICAgICAgICBlbGVtZW50Xy5jb2xTcGFuID0gdGhpcy5fX2NvbFNwYW47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9fcm93U3BhbiA+IDEpIHtcbiAgICAgICAgZWxlbWVudF8ucm93U3BhbiA9IHRoaXMuX19yb3dTcGFuO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50Xy5zdHlsZS53aWR0aCA9IGAke3RoaXMuZ2V0V2lkdGgoKSB8fCBNYXRoLm1heCg5MCwgbWF4V2lkdGggLyBjb2xDb3VudCl9cHhgO1xuICAgICAgZWxlbWVudF8uc3R5bGUudmVydGljYWxBbGlnbiA9ICd0b3AnO1xuICAgICAgZWxlbWVudF8uc3R5bGUudGV4dEFsaWduID0gJ3N0YXJ0JztcbiAgICAgIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0QmFja2dyb3VuZENvbG9yKCk7XG5cbiAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudF8uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc0hlYWRlcigpKSB7XG4gICAgICAgIGVsZW1lbnRfLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjZjJmM2Y1JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5nZXRCYWNrZ3JvdW5kQ29sb3IoKSxcbiAgICAgIGhlYWRlclN0YXRlOiB0aGlzLl9faGVhZGVyU3RhdGUsXG4gICAgICB0eXBlOiAndGFibGVjZWxsJyxcbiAgICAgIHdpZHRoOiB0aGlzLmdldFdpZHRoKClcbiAgICB9O1xuICB9XG5cbiAgZ2V0VGFnKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0hlYWRlcigpID8gJ3RoJyA6ICd0ZCc7XG4gIH1cblxuICBzZXRIZWFkZXJTdHlsZXMoaGVhZGVyU3RhdGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19oZWFkZXJTdGF0ZSA9IGhlYWRlclN0YXRlO1xuICAgIHJldHVybiB0aGlzLl9faGVhZGVyU3RhdGU7XG4gIH1cblxuICBnZXRIZWFkZXJTdHlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19oZWFkZXJTdGF0ZTtcbiAgfVxuXG4gIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fd2lkdGggPSB3aWR0aDtcbiAgICByZXR1cm4gdGhpcy5fX3dpZHRoO1xuICB9XG5cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX193aWR0aDtcbiAgfVxuXG4gIGdldEJhY2tncm91bmRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2JhY2tncm91bmRDb2xvcjtcbiAgfVxuXG4gIHNldEJhY2tncm91bmRDb2xvcihuZXdCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICB0aGlzLmdldFdyaXRhYmxlKCkuX19iYWNrZ3JvdW5kQ29sb3IgPSBuZXdCYWNrZ3JvdW5kQ29sb3I7XG4gIH1cblxuICB0b2dnbGVIZWFkZXJTdHlsZShoZWFkZXJTdGF0ZVRvVG9nZ2xlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcblxuICAgIGlmICgoc2VsZi5fX2hlYWRlclN0YXRlICYgaGVhZGVyU3RhdGVUb1RvZ2dsZSkgPT09IGhlYWRlclN0YXRlVG9Ub2dnbGUpIHtcbiAgICAgIHNlbGYuX19oZWFkZXJTdGF0ZSAtPSBoZWFkZXJTdGF0ZVRvVG9nZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9faGVhZGVyU3RhdGUgKz0gaGVhZGVyU3RhdGVUb1RvZ2dsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIGhhc0hlYWRlclN0YXRlKGhlYWRlclN0YXRlKSB7XG4gICAgcmV0dXJuICh0aGlzLmdldEhlYWRlclN0eWxlcygpICYgaGVhZGVyU3RhdGUpID09PSBoZWFkZXJTdGF0ZTtcbiAgfVxuXG4gIGhhc0hlYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2hlYWRlclN0YXRlICE9PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTO1xuICB9XG5cbiAgdXBkYXRlRE9NKHByZXZOb2RlKSB7XG4gICAgcmV0dXJuIHByZXZOb2RlLl9faGVhZGVyU3RhdGUgIT09IHRoaXMuX19oZWFkZXJTdGF0ZSB8fCBwcmV2Tm9kZS5fX3dpZHRoICE9PSB0aGlzLl9fd2lkdGggfHwgcHJldk5vZGUuX19jb2xTcGFuICE9PSB0aGlzLl9fY29sU3BhbiB8fCBwcmV2Tm9kZS5fX3Jvd1NwYW4gIT09IHRoaXMuX19yb3dTcGFuIHx8IHByZXZOb2RlLl9fYmFja2dyb3VuZENvbG9yICE9PSB0aGlzLl9fYmFja2dyb3VuZENvbG9yO1xuICB9XG5cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn1cbmZ1bmN0aW9uIGNvbnZlcnRUYWJsZUNlbGxOb2RlRWxlbWVudChkb21Ob2RlKSB7XG4gIGNvbnN0IGRvbU5vZGVfID0gZG9tTm9kZTtcbiAgY29uc3Qgbm9kZU5hbWUgPSBkb21Ob2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGxldCB3aWR0aCA9IHVuZGVmaW5lZDtcblxuICBpZiAoUElYRUxfVkFMVUVfUkVHX0VYUC50ZXN0KGRvbU5vZGVfLnN0eWxlLndpZHRoKSkge1xuICAgIHdpZHRoID0gcGFyc2VGbG9hdChkb21Ob2RlXy5zdHlsZS53aWR0aCk7XG4gIH1cblxuICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUobm9kZU5hbWUgPT09ICd0aCcgPyBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XIDogVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUywgZG9tTm9kZV8uY29sU3Bhbiwgd2lkdGgpO1xuICB0YWJsZUNlbGxOb2RlLl9fcm93U3BhbiA9IGRvbU5vZGVfLnJvd1NwYW47XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IGRvbU5vZGVfLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcblxuICBpZiAoYmFja2dyb3VuZENvbG9yICE9PSAnJykge1xuICAgIHRhYmxlQ2VsbE5vZGUuX19iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvckNoaWxkOiAobGV4aWNhbE5vZGUsIHBhcmVudExleGljYWxOb2RlKSA9PiB7XG4gICAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShwYXJlbnRMZXhpY2FsTm9kZSkgJiYgIWxleGljYWwuJGlzRWxlbWVudE5vZGUobGV4aWNhbE5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHBhcmFncmFwaE5vZGUgPSBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG5cbiAgICAgICAgaWYgKGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShsZXhpY2FsTm9kZSkgJiYgbGV4aWNhbE5vZGUuZ2V0VGV4dENvbnRlbnQoKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFncmFwaE5vZGUuYXBwZW5kKGxleGljYWxOb2RlKTtcbiAgICAgICAgcmV0dXJuIHBhcmFncmFwaE5vZGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsZXhpY2FsTm9kZTtcbiAgICB9LFxuICAgIG5vZGU6IHRhYmxlQ2VsbE5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlLCBjb2xTcGFuID0gMSwgd2lkdGgpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlLCBjb2xTcGFuLCB3aWR0aCkpO1xufVxuZnVuY3Rpb24gJGlzVGFibGVDZWxsTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGFibGVDZWxsTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgVGFibGVSb3dOb2RlIGV4dGVuZHMgbGV4aWNhbC5ERVBSRUNBVEVEX0dyaWRSb3dOb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3RhYmxlcm93JztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZVJvd05vZGUobm9kZS5fX2hlaWdodCwgbm9kZS5fX2tleSk7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0cjogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGFibGVSb3dFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZVRhYmxlUm93Tm9kZShzZXJpYWxpemVkTm9kZS5oZWlnaHQpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoaGVpZ2h0LCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX19oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHR5cGU6ICd0YWJsZXJvdycsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcblxuICAgIGlmICh0aGlzLl9faGVpZ2h0KSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke3RoaXMuX19oZWlnaHR9cHhgO1xuICAgIH1cblxuICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLnRhYmxlUm93KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIGlzU2hhZG93Um9vdCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHRoaXMuX19oZWlnaHQ7XG4gIH1cblxuICBnZXRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19oZWlnaHQ7XG4gIH1cblxuICB1cGRhdGVET00ocHJldk5vZGUpIHtcbiAgICByZXR1cm4gcHJldk5vZGUuX19oZWlnaHQgIT09IHRoaXMuX19oZWlnaHQ7XG4gIH1cblxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNhbkluZGVudCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxufVxuZnVuY3Rpb24gY29udmVydFRhYmxlUm93RWxlbWVudChkb21Ob2RlKSB7XG4gIGNvbnN0IGRvbU5vZGVfID0gZG9tTm9kZTtcbiAgbGV0IGhlaWdodCA9IHVuZGVmaW5lZDtcblxuICBpZiAoUElYRUxfVkFMVUVfUkVHX0VYUC50ZXN0KGRvbU5vZGVfLnN0eWxlLmhlaWdodCkpIHtcbiAgICBoZWlnaHQgPSBwYXJzZUZsb2F0KGRvbU5vZGVfLnN0eWxlLmhlaWdodCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVUYWJsZVJvd05vZGUoaGVpZ2h0KVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlUm93Tm9kZShoZWlnaHQpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUYWJsZVJvd05vZGUoaGVpZ2h0KSk7XG59XG5mdW5jdGlvbiAkaXNUYWJsZVJvd05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRhYmxlUm93Tm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IGdldERPTVNlbGVjdGlvbiA9IHRhcmdldFdpbmRvdyA9PiBDQU5fVVNFX0RPTSA/ICh0YXJnZXRXaW5kb3cgfHwgd2luZG93KS5nZXRTZWxlY3Rpb24oKSA6IG51bGw7XG5cbmNsYXNzIFRhYmxlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoZWRpdG9yLCB0YWJsZU5vZGVLZXkpIHtcbiAgICB0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgPSBmYWxzZTtcbiAgICB0aGlzLmFuY2hvclggPSAtMTtcbiAgICB0aGlzLmFuY2hvclkgPSAtMTtcbiAgICB0aGlzLmZvY3VzWCA9IC0xO1xuICAgIHRoaXMuZm9jdXNZID0gLTE7XG4gICAgdGhpcy5saXN0ZW5lcnNUb1JlbW92ZSA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnRhYmxlTm9kZUtleSA9IHRhYmxlTm9kZUtleTtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLmdyaWQgPSB7XG4gICAgICBjZWxsczogW10sXG4gICAgICBjb2x1bW5zOiAwLFxuICAgICAgcm93czogMFxuICAgIH07XG4gICAgdGhpcy5ncmlkU2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmZvY3VzQ2VsbE5vZGVLZXkgPSBudWxsO1xuICAgIHRoaXMuYW5jaG9yQ2VsbCA9IG51bGw7XG4gICAgdGhpcy5mb2N1c0NlbGwgPSBudWxsO1xuICAgIHRoaXMuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgPSBmYWxzZTtcbiAgICB0aGlzLnRyYWNrVGFibGVHcmlkKCk7XG4gIH1cblxuICBnZXRHcmlkKCkge1xuICAgIHJldHVybiB0aGlzLmdyaWQ7XG4gIH1cblxuICByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgQXJyYXkuZnJvbSh0aGlzLmxpc3RlbmVyc1RvUmVtb3ZlKS5mb3JFYWNoKHJlbW92ZUxpc3RlbmVyID0+IHJlbW92ZUxpc3RlbmVyKCkpO1xuICB9XG5cbiAgdHJhY2tUYWJsZUdyaWQoKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihyZWNvcmRzID0+IHtcbiAgICAgIHRoaXMuZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGxldCBncmlkTmVlZHNSZWRyYXcgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHJlY29yZC50YXJnZXQ7XG4gICAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWU7XG5cbiAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdUQUJMRScgfHwgbm9kZU5hbWUgPT09ICdUUicpIHtcbiAgICAgICAgICAgIGdyaWROZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWdyaWROZWVkc1JlZHJhdykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IHRoaXMuZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG5cbiAgICAgICAgaWYgKCF0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgVGFibGVFbGVtZW50IGluIERPTScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkID0gZ2V0VGFibGVHcmlkKHRhYmxlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgdGFibGVFbGVtZW50ID0gdGhpcy5lZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcblxuICAgICAgaWYgKCF0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ncmlkID0gZ2V0VGFibGVHcmlkKHRhYmxlRWxlbWVudCk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKHRhYmxlRWxlbWVudCwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY2xlYXJIaWdobGlnaHQoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gZmFsc2U7XG4gICAgdGhpcy5hbmNob3JYID0gLTE7XG4gICAgdGhpcy5hbmNob3JZID0gLTE7XG4gICAgdGhpcy5mb2N1c1ggPSAtMTtcbiAgICB0aGlzLmZvY3VzWSA9IC0xO1xuICAgIHRoaXMuZ3JpZFNlbGVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5hbmNob3JDZWxsTm9kZUtleSA9IG51bGw7XG4gICAgdGhpcy5mb2N1c0NlbGxOb2RlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvckNlbGwgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNDZWxsID0gbnVsbDtcbiAgICB0aGlzLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzID0gZmFsc2U7XG4gICAgdGhpcy5lbmFibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgdGFibGVOb2RlID0gbGV4aWNhbC4kZ2V0Tm9kZUJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcblxuICAgICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFRhYmxlTm9kZS4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFibGVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG5cbiAgICAgIGlmICghdGFibGVFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBUYWJsZUVsZW1lbnQgaW4gRE9NJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGdyaWQgPSBnZXRUYWJsZUdyaWQodGFibGVFbGVtZW50KTtcbiAgICAgICR1cGRhdGVET01Gb3JTZWxlY3Rpb24oZWRpdG9yLCBncmlkLCBudWxsKTtcbiAgICAgIGxleGljYWwuJHNldFNlbGVjdGlvbihudWxsKTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5TRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH1cblxuICBlbmFibGVIaWdobGlnaHRTdHlsZSgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuXG4gICAgICBpZiAoIXRhYmxlRWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgVGFibGVFbGVtZW50IGluIERPTScpO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5yZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQodGFibGVFbGVtZW50LCBlZGl0b3IuX2NvbmZpZy50aGVtZS50YWJsZVNlbGVjdGlvbik7XG4gICAgICB0YWJsZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZS1zZWxlY3Rpb24nKTtcbiAgICAgIHRoaXMuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2FibGVIaWdobGlnaHRTdHlsZSgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuXG4gICAgICBpZiAoIXRhYmxlRWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgVGFibGVFbGVtZW50IGluIERPTScpO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KHRhYmxlRWxlbWVudCwgZWRpdG9yLl9jb25maWcudGhlbWUudGFibGVTZWxlY3Rpb24pO1xuICAgICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IHRydWU7XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVUYWJsZUdyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgaWYgKHNlbGVjdGlvbiAhPSBudWxsICYmIHNlbGVjdGlvbi5ncmlkS2V5ID09PSB0aGlzLnRhYmxlTm9kZUtleSkge1xuICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICB0aGlzLmdyaWRTZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICB0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgPSB0cnVlO1xuICAgICAgdGhpcy5kaXNhYmxlSGlnaGxpZ2h0U3R5bGUoKTtcbiAgICAgICR1cGRhdGVET01Gb3JTZWxlY3Rpb24oZWRpdG9yLCB0aGlzLmdyaWQsIHRoaXMuZ3JpZFNlbGVjdGlvbik7XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgdGhpcy5jbGVhckhpZ2hsaWdodCgpO1xuICAgIH1cbiAgfVxuXG4gIHNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihjZWxsLCBpZ25vcmVTdGFydCA9IGZhbHNlKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZU5vZGUgPSBsZXhpY2FsLiRnZXROb2RlQnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuXG4gICAgICBpZiAoISRpc1RhYmxlTm9kZSh0YWJsZU5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVGFibGVOb2RlLicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcblxuICAgICAgaWYgKCF0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2VsbFggPSBjZWxsLng7XG4gICAgICBjb25zdCBjZWxsWSA9IGNlbGwueTtcbiAgICAgIHRoaXMuZm9jdXNDZWxsID0gY2VsbDtcblxuICAgICAgaWYgKHRoaXMuYW5jaG9yQ2VsbCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpOyAvLyBDb2xsYXBzZSB0aGUgc2VsZWN0aW9uXG5cbiAgICAgICAgaWYgKGRvbVNlbGVjdGlvbikge1xuICAgICAgICAgIGRvbVNlbGVjdGlvbi5zZXRCYXNlQW5kRXh0ZW50KHRoaXMuYW5jaG9yQ2VsbC5lbGVtLCAwLCB0aGlzLmZvY3VzQ2VsbC5lbGVtLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyAmJiAodGhpcy5hbmNob3JYICE9PSBjZWxsWCB8fCB0aGlzLmFuY2hvclkgIT09IGNlbGxZIHx8IGlnbm9yZVN0YXJ0KSkge1xuICAgICAgICB0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgICAgfSBlbHNlIGlmIChjZWxsWCA9PT0gdGhpcy5mb2N1c1ggJiYgY2VsbFkgPT09IHRoaXMuZm9jdXNZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mb2N1c1ggPSBjZWxsWDtcbiAgICAgIHRoaXMuZm9jdXNZID0gY2VsbFk7XG5cbiAgICAgIGlmICh0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMpIHtcbiAgICAgICAgY29uc3QgZm9jdXNUYWJsZUNlbGxOb2RlID0gbGV4aWNhbC4kZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShjZWxsLmVsZW0pO1xuXG4gICAgICAgIGlmICh0aGlzLmdyaWRTZWxlY3Rpb24gIT0gbnVsbCAmJiB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ICE9IG51bGwgJiYgJGlzVGFibGVDZWxsTm9kZShmb2N1c1RhYmxlQ2VsbE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgZm9jdXNOb2RlS2V5ID0gZm9jdXNUYWJsZUNlbGxOb2RlLmdldEtleSgpO1xuICAgICAgICAgIHRoaXMuZ3JpZFNlbGVjdGlvbiA9IHRoaXMuZ3JpZFNlbGVjdGlvbi5jbG9uZSgpIHx8IGxleGljYWwuREVQUkVDQVRFRF8kY3JlYXRlR3JpZFNlbGVjdGlvbigpO1xuICAgICAgICAgIHRoaXMuZm9jdXNDZWxsTm9kZUtleSA9IGZvY3VzTm9kZUtleTtcbiAgICAgICAgICB0aGlzLmdyaWRTZWxlY3Rpb24uc2V0KHRoaXMudGFibGVOb2RlS2V5LCB0aGlzLmFuY2hvckNlbGxOb2RlS2V5LCB0aGlzLmZvY3VzQ2VsbE5vZGVLZXkpO1xuICAgICAgICAgIGxleGljYWwuJHNldFNlbGVjdGlvbih0aGlzLmdyaWRTZWxlY3Rpb24pO1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5TRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRoaXMuZ3JpZCwgdGhpcy5ncmlkU2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihjZWxsKSB7XG4gICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gZmFsc2U7XG4gICAgdGhpcy5hbmNob3JDZWxsID0gY2VsbDtcbiAgICB0aGlzLmFuY2hvclggPSBjZWxsLng7XG4gICAgdGhpcy5hbmNob3JZID0gY2VsbC55O1xuICAgIHRoaXMuZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCBhbmNob3JUYWJsZUNlbGxOb2RlID0gbGV4aWNhbC4kZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShjZWxsLmVsZW0pO1xuXG4gICAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShhbmNob3JUYWJsZUNlbGxOb2RlKSkge1xuICAgICAgICBjb25zdCBhbmNob3JOb2RlS2V5ID0gYW5jaG9yVGFibGVDZWxsTm9kZS5nZXRLZXkoKTtcbiAgICAgICAgdGhpcy5ncmlkU2VsZWN0aW9uID0gbGV4aWNhbC5ERVBSRUNBVEVEXyRjcmVhdGVHcmlkU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgPSBhbmNob3JOb2RlS2V5O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZm9ybWF0Q2VsbHModHlwZSkge1xuICAgIHRoaXMuZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKCFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgZ3JpZCBzZWxlY3Rpb25gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBmb3JtYXRTZWxlY3Rpb24gPSBsZXhpY2FsLiRjcmVhdGVSYW5nZVNlbGVjdGlvbigpO1xuICAgICAgY29uc3QgYW5jaG9yID0gZm9ybWF0U2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGZvY3VzID0gZm9ybWF0U2VsZWN0aW9uLmZvY3VzO1xuICAgICAgc2VsZWN0aW9uLmdldE5vZGVzKCkuZm9yRWFjaChjZWxsTm9kZSA9PiB7XG4gICAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGNlbGxOb2RlKSAmJiBjZWxsTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSAhPT0gMCkge1xuICAgICAgICAgIGFuY2hvci5zZXQoY2VsbE5vZGUuZ2V0S2V5KCksIDAsICdlbGVtZW50Jyk7XG4gICAgICAgICAgZm9jdXMuc2V0KGNlbGxOb2RlLmdldEtleSgpLCBjZWxsTm9kZS5nZXRDaGlsZHJlblNpemUoKSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICBmb3JtYXRTZWxlY3Rpb24uZm9ybWF0VGV4dCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsZXhpY2FsLiRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgIHRoaXMuZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLlNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsZWFyVGV4dCgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlTm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG5cbiAgICAgIGlmICghJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBUYWJsZU5vZGUuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAoIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBncmlkIHNlbGVjdGlvbmApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKS5maWx0ZXIoJGlzVGFibGVDZWxsTm9kZSk7XG5cbiAgICAgIGlmIChzZWxlY3RlZE5vZGVzLmxlbmd0aCA9PT0gdGhpcy5ncmlkLmNvbHVtbnMgKiB0aGlzLmdyaWQucm93cykge1xuICAgICAgICB0YWJsZU5vZGUuc2VsZWN0UHJldmlvdXMoKTsgLy8gRGVsZXRlIGVudGlyZSB0YWJsZVxuXG4gICAgICAgIHRhYmxlTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBsZXhpY2FsLiRnZXRSb290KCk7XG4gICAgICAgIHJvb3ROb2RlLnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKGNlbGxOb2RlID0+IHtcbiAgICAgICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUoY2VsbE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IGxleGljYWwuJGNyZWF0ZVRleHROb2RlKCk7XG4gICAgICAgICAgcGFyYWdyYXBoTm9kZS5hcHBlbmQodGV4dE5vZGUpO1xuICAgICAgICAgIGNlbGxOb2RlLmFwcGVuZChwYXJhZ3JhcGhOb2RlKTtcbiAgICAgICAgICBjZWxsTm9kZS5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBwYXJhZ3JhcGhOb2RlKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgICR1cGRhdGVET01Gb3JTZWxlY3Rpb24oZWRpdG9yLCB0aGlzLmdyaWQsIG51bGwpO1xuICAgICAgbGV4aWNhbC4kc2V0U2VsZWN0aW9uKG51bGwpO1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLlNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfVxuXG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IExFWElDQUxfRUxFTUVOVF9LRVkgPSAnX19sZXhpY2FsVGFibGVTZWxlY3Rpb24nO1xuZnVuY3Rpb24gYXBwbHlUYWJsZUhhbmRsZXJzKHRhYmxlTm9kZSwgdGFibGVFbGVtZW50LCBlZGl0b3IsIGhhc1RhYkhhbmRsZXIpIHtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcblxuICBpZiAocm9vdEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJvb3QgZWxlbWVudC4nKTtcbiAgfVxuXG4gIGNvbnN0IHRhYmxlU2VsZWN0aW9uID0gbmV3IFRhYmxlU2VsZWN0aW9uKGVkaXRvciwgdGFibGVOb2RlLmdldEtleSgpKTtcbiAgY29uc3QgZWRpdG9yV2luZG93ID0gZWRpdG9yLl93aW5kb3cgfHwgd2luZG93O1xuICBhdHRhY2hUYWJsZVNlbGVjdGlvblRvVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgdGFibGVTZWxlY3Rpb24pO1xuICB0YWJsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZXZlbnQgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghZWRpdG9yV2luZG93KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYW5jaG9yQ2VsbCA9IGdldENlbGxGcm9tVGFyZ2V0KGV2ZW50LnRhcmdldCk7XG5cbiAgICAgIGlmIChhbmNob3JDZWxsICE9PSBudWxsKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIHRhYmxlU2VsZWN0aW9uLnNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oYW5jaG9yQ2VsbCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uTW91c2VVcCA9ICgpID0+IHtcbiAgICAgICAgZWRpdG9yV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgICBlZGl0b3JXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgICAgfTtcblxuICAgICAgY29uc3Qgb25Nb3VzZU1vdmUgPSBtb3ZlRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBmb2N1c0NlbGwgPSBnZXRDZWxsRnJvbVRhcmdldChtb3ZlRXZlbnQudGFyZ2V0KTtcblxuICAgICAgICBpZiAoZm9jdXNDZWxsICE9PSBudWxsICYmICh0YWJsZVNlbGVjdGlvbi5hbmNob3JYICE9PSBmb2N1c0NlbGwueCB8fCB0YWJsZVNlbGVjdGlvbi5hbmNob3JZICE9PSBmb2N1c0NlbGwueSkpIHtcbiAgICAgICAgICBtb3ZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0YWJsZVNlbGVjdGlvbi5zZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oZm9jdXNDZWxsKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZWRpdG9yV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgICAgZWRpdG9yV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICB9LCAwKTtcbiAgfSk7IC8vIENsZWFyIHNlbGVjdGlvbiB3aGVuIGNsaWNraW5nIG91dHNpZGUgb2YgZG9tLlxuXG4gIGNvbnN0IG1vdXNlRG93bkNhbGxiYWNrID0gZXZlbnQgPT4ge1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uZ3JpZEtleSA9PT0gdGFibGVTZWxlY3Rpb24udGFibGVOb2RlS2V5ICYmIHJvb3RFbGVtZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgdGFibGVTZWxlY3Rpb24uY2xlYXJIaWdobGlnaHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBlZGl0b3JXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2VEb3duQ2FsbGJhY2spO1xuICB0YWJsZVNlbGVjdGlvbi5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoKCkgPT4gZWRpdG9yV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bkNhbGxiYWNrKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgZXZlbnQgPT4gJGhhbmRsZUFycm93S2V5KGVkaXRvciwgZXZlbnQsICdkb3duJywgdGFibGVOb2RlLCB0YWJsZVNlbGVjdGlvbiksIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0FSUk9XX1VQX0NPTU1BTkQsIGV2ZW50ID0+ICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCAndXAnLCB0YWJsZU5vZGUsIHRhYmxlU2VsZWN0aW9uKSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgdGFibGVTZWxlY3Rpb24ubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQVJST1dfTEVGVF9DT01NQU5ELCBldmVudCA9PiAkaGFuZGxlQXJyb3dLZXkoZWRpdG9yLCBldmVudCwgJ2JhY2t3YXJkJywgdGFibGVOb2RlLCB0YWJsZVNlbGVjdGlvbiksIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIGV2ZW50ID0+ICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCAnZm9yd2FyZCcsIHRhYmxlTm9kZSwgdGFibGVTZWxlY3Rpb24pLCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfSElHSCkpO1xuICB0YWJsZVNlbGVjdGlvbi5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9FU0NBUEVfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuXG4gICAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShmb2N1c0NlbGxOb2RlKSkge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBmb2N1c0NlbGxOb2RlLnNlbGVjdEVuZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG5cbiAgY29uc3QgZGVsZXRlVGV4dEhhbmRsZXIgPSBjb21tYW5kID0+ICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgdGFibGVTZWxlY3Rpb24uY2xlYXJUZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG5cbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgICBjb25zdCBpc0FuY2hvckluc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKGFuY2hvck5vZGUpO1xuICAgICAgY29uc3QgaXNGb2N1c0luc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKGZvY3VzTm9kZSk7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Db250YWluc1BhcnRpYWxUYWJsZSA9IGlzQW5jaG9ySW5zaWRlICYmICFpc0ZvY3VzSW5zaWRlIHx8IGlzRm9jdXNJbnNpZGUgJiYgIWlzQW5jaG9ySW5zaWRlO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uQ29udGFpbnNQYXJ0aWFsVGFibGUpIHtcbiAgICAgICAgdGFibGVTZWxlY3Rpb24uY2xlYXJUZXh0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZWFyZXN0RWxlbWVudE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+IGxleGljYWwuJGlzRWxlbWVudE5vZGUobikpO1xuICAgICAgY29uc3QgdG9wTGV2ZWxDZWxsRWxlbWVudE5vZGUgPSBuZWFyZXN0RWxlbWVudE5vZGUgJiYgdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChuZWFyZXN0RWxlbWVudE5vZGUsIG4gPT4gbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShuKSAmJiAkaXNUYWJsZUNlbGxOb2RlKG4uZ2V0UGFyZW50KCkpKTtcblxuICAgICAgaWYgKCFsZXhpY2FsLiRpc0VsZW1lbnROb2RlKHRvcExldmVsQ2VsbEVsZW1lbnROb2RlKSB8fCAhbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShuZWFyZXN0RWxlbWVudE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbW1hbmQgPT09IGxleGljYWwuREVMRVRFX0xJTkVfQ09NTUFORCAmJiB0b3BMZXZlbENlbGxFbGVtZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBGaXggRGVsZXRlIExpbmUgaW4gVGFibGUgQ2VsbHMuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tbWFuZCA9PT0gbGV4aWNhbC5ERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQgfHwgY29tbWFuZCA9PT0gbGV4aWNhbC5ERUxFVEVfV09SRF9DT01NQU5EKSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMCkge1xuICAgICAgICAgIGlmIChuZWFyZXN0RWxlbWVudE5vZGUgIT09IHRvcExldmVsQ2VsbEVsZW1lbnROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5lYXJlc3RFbGVtZW50Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgICAgY29uc3QgbmV3UGFyYWdyYXBoTm9kZSA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gbmV3UGFyYWdyYXBoTm9kZS5hcHBlbmQoY2hpbGQpKTtcbiAgICAgICAgICAgIG5lYXJlc3RFbGVtZW50Tm9kZS5yZXBsYWNlKG5ld1BhcmFncmFwaE5vZGUpO1xuICAgICAgICAgICAgbmVhcmVzdEVsZW1lbnROb2RlLmdldFdyaXRhYmxlKCkuX19wYXJlbnQgPSB0YWJsZUNlbGxOb2RlLmdldEtleSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIFtsZXhpY2FsLkRFTEVURV9XT1JEX0NPTU1BTkQsIGxleGljYWwuREVMRVRFX0xJTkVfQ09NTUFORCwgbGV4aWNhbC5ERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkRdLmZvckVhY2goY29tbWFuZCA9PiB7XG4gICAgdGFibGVTZWxlY3Rpb24ubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoY29tbWFuZCwgZGVsZXRlVGV4dEhhbmRsZXIoY29tbWFuZCksIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB9KTtcblxuICBjb25zdCBkZWxldGVDZWxsSGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGFibGVTZWxlY3Rpb24uY2xlYXJUZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG5cbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCBkZWxldGVDZWxsSGFuZGxlciwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0RFTEVURV9DT01NQU5ELCBkZWxldGVDZWxsSGFuZGxlciwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuRk9STUFUX1RFWFRfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHRhYmxlU2VsZWN0aW9uLmZvcm1hdENlbGxzKHBheWxvYWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpO1xuXG4gICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBwYXlsb2FkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgdGFibGVTZWxlY3Rpb24uY2xlYXJIaWdobGlnaHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG5cbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcblxuICBpZiAoaGFzVGFiSGFuZGxlcikge1xuICAgIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX1RBQl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8ICEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSAkZmluZENlbGxOb2RlKHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKTtcblxuICAgICAgaWYgKHRhYmxlQ2VsbE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgY29uc3QgY3VycmVudENvcmRzID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlU2VsZWN0aW9uLmdyaWQpO1xuICAgICAgc2VsZWN0R3JpZE5vZGVJbkRpcmVjdGlvbih0YWJsZVNlbGVjdGlvbiwgdGFibGVOb2RlLCBjdXJyZW50Q29yZHMueCwgY3VycmVudENvcmRzLnksICFldmVudC5zaGlmdEtleSA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIH1cblxuICB0YWJsZVNlbGVjdGlvbi5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkZPQ1VTX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIHJldHVybiB0YWJsZU5vZGUuaXNTZWxlY3RlZCgpO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfSElHSCkpO1xuXG4gIGZ1bmN0aW9uIGdldENlbGxGcm9tQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkge1xuICAgIGNvbnN0IGN1cnJlbnRDb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZVNlbGVjdGlvbi5ncmlkKTtcbiAgICByZXR1cm4gdGFibGVOb2RlLmdldENlbGxGcm9tQ29yZHNPclRocm93KGN1cnJlbnRDb3Jkcy54LCBjdXJyZW50Q29yZHMueSwgdGFibGVTZWxlY3Rpb24uZ3JpZCk7XG4gIH1cblxuICB0YWJsZVNlbGVjdGlvbi5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLlNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZvY3VzXG4gICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7IC8vIFVzaW5nIGV4cGxpY2l0IGNvbXBhcmlzb24gd2l0aCB0YWJsZSBub2RlIHRvIGVuc3VyZSBpdCdzIG5vdCBhIG5lc3RlZCB0YWJsZVxuICAgICAgLy8gYXMgaW4gdGhhdCBjYXNlIHdlJ2xsIGxlYXZlIHNlbGVjdGlvbiByZXNvbHZpbmcgdG8gdGhhdCB0YWJsZVxuXG4gICAgICBjb25zdCBhbmNob3JDZWxsTm9kZSA9ICRmaW5kQ2VsbE5vZGUoYW5jaG9yTm9kZSk7XG4gICAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGZpbmRDZWxsTm9kZShmb2N1c05vZGUpO1xuICAgICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSBhbmNob3JDZWxsTm9kZSAmJiB0YWJsZU5vZGUuaXMoJGZpbmRUYWJsZU5vZGUoYW5jaG9yQ2VsbE5vZGUpKTtcbiAgICAgIGNvbnN0IGlzRm9jdXNJbnNpZGUgPSBmb2N1c0NlbGxOb2RlICYmIHRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShmb2N1c0NlbGxOb2RlKSk7XG4gICAgICBjb25zdCBpc1BhcnRpYWx5V2l0aGluVGFibGUgPSBpc0FuY2hvckluc2lkZSAhPT0gaXNGb2N1c0luc2lkZTtcbiAgICAgIGNvbnN0IGlzV2l0aGluVGFibGUgPSBpc0FuY2hvckluc2lkZSAmJiBpc0ZvY3VzSW5zaWRlO1xuICAgICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG5cbiAgICAgIGlmIChpc1BhcnRpYWx5V2l0aGluVGFibGUpIHtcbiAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gc2VsZWN0aW9uLmNsb25lKCk7XG4gICAgICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQodGFibGVOb2RlLmdldEtleSgpLCBpc0JhY2t3YXJkID8gMCA6IHRhYmxlTm9kZS5nZXRDaGlsZHJlblNpemUoKSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgbGV4aWNhbC4kc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XG4gICAgICAgICRhZGRIaWdobGlnaHRTdHlsZVRvVGFibGUoZWRpdG9yLCB0YWJsZVNlbGVjdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKGlzV2l0aGluVGFibGUpIHtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBzZWxlY3Rpb24gc3BhbnMgYWNyb3NzIG11bHRpcGxlIGNlbGxzIGJ1dCBzdGlsbFxuICAgICAgICAvLyBoYXMgcmFuZ2Ugc2VsZWN0aW9uLCB0aGVuIHdlIGNvbnZlcnQgaXQgaW50byBncmlkIHNlbGVjdGlvblxuICAgICAgICBpZiAoIWFuY2hvckNlbGxOb2RlLmlzKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICAgICAgdGFibGVTZWxlY3Rpb24uc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihnZXRDZWxsRnJvbUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSk7XG4gICAgICAgICAgdGFibGVTZWxlY3Rpb24uc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGdldENlbGxGcm9tQ2VsbE5vZGUoZm9jdXNDZWxsTm9kZSksIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGlvbiAmJiAhc2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pICYmIChsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pKSAmJiB0YWJsZVNlbGVjdGlvbi5ncmlkU2VsZWN0aW9uICYmICF0YWJsZVNlbGVjdGlvbi5ncmlkU2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgICBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uZ3JpZEtleSA9PT0gdGFibGVTZWxlY3Rpb24udGFibGVOb2RlS2V5KSB7XG4gICAgICAgIHRhYmxlU2VsZWN0aW9uLnVwZGF0ZVRhYmxlR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBwcmV2U2VsZWN0aW9uLmdyaWRLZXkgPT09IHRhYmxlU2VsZWN0aW9uLnRhYmxlTm9kZUtleSkge1xuICAgICAgICB0YWJsZVNlbGVjdGlvbi51cGRhdGVUYWJsZUdyaWRTZWxlY3Rpb24obnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGFibGVTZWxlY3Rpb24uaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgJiYgIXRhYmxlTm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICRyZW1vdmVIaWdobGlnaHRTdHlsZVRvVGFibGUoZWRpdG9yLCB0YWJsZVNlbGVjdGlvbik7XG4gICAgfSBlbHNlIGlmICghdGFibGVTZWxlY3Rpb24uaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgJiYgdGFibGVOb2RlLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgJGFkZEhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlU2VsZWN0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICByZXR1cm4gdGFibGVTZWxlY3Rpb247XG59XG5mdW5jdGlvbiBhdHRhY2hUYWJsZVNlbGVjdGlvblRvVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgdGFibGVTZWxlY3Rpb24pIHtcbiAgdGFibGVFbGVtZW50W0xFWElDQUxfRUxFTUVOVF9LRVldID0gdGFibGVTZWxlY3Rpb247XG59XG5mdW5jdGlvbiBnZXRUYWJsZVNlbGVjdGlvbkZyb21UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSB7XG4gIHJldHVybiB0YWJsZUVsZW1lbnRbTEVYSUNBTF9FTEVNRU5UX0tFWV07XG59XG5mdW5jdGlvbiBnZXRDZWxsRnJvbVRhcmdldChub2RlKSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG5cbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICBjb25zdCBub2RlTmFtZSA9IGN1cnJlbnROb2RlLm5vZGVOYW1lO1xuXG4gICAgaWYgKG5vZGVOYW1lID09PSAnVEQnIHx8IG5vZGVOYW1lID09PSAnVEgnKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgICAgY29uc3QgY2VsbCA9IGN1cnJlbnROb2RlLl9jZWxsO1xuXG4gICAgICBpZiAoY2VsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2VsbDtcbiAgICB9XG5cbiAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFRhYmxlR3JpZCh0YWJsZUVsZW1lbnQpIHtcbiAgY29uc3QgY2VsbHMgPSBbXTtcbiAgY29uc3QgZ3JpZCA9IHtcbiAgICBjZWxscyxcbiAgICBjb2x1bW5zOiAwLFxuICAgIHJvd3M6IDBcbiAgfTtcbiAgbGV0IGN1cnJlbnROb2RlID0gdGFibGVFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBjZWxscy5sZW5ndGggPSAwO1xuXG4gIHdoaWxlIChjdXJyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgY29uc3Qgbm9kZU1hbWUgPSBjdXJyZW50Tm9kZS5ub2RlTmFtZTtcblxuICAgIGlmIChub2RlTWFtZSA9PT0gJ1REJyB8fCBub2RlTWFtZSA9PT0gJ1RIJykge1xuICAgICAgY29uc3QgZWxlbSA9IGN1cnJlbnROb2RlO1xuICAgICAgY29uc3QgY2VsbCA9IHtcbiAgICAgICAgZWxlbSxcbiAgICAgICAgaGFzQmFja2dyb3VuZENvbG9yOiBlbGVtLnN0eWxlLmJhY2tncm91bmRDb2xvciAhPT0gJycsXG4gICAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZSxcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTsgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcblxuICAgICAgY3VycmVudE5vZGUuX2NlbGwgPSBjZWxsO1xuXG4gICAgICBpZiAoY2VsbHNbeV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjZWxsc1t5XSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBjZWxsc1t5XVt4XSA9IGNlbGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY3VycmVudE5vZGUuZmlyc3RDaGlsZDtcblxuICAgICAgaWYgKGNoaWxkICE9IG51bGwpIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2libGluZyA9IGN1cnJlbnROb2RlLm5leHRTaWJsaW5nO1xuXG4gICAgaWYgKHNpYmxpbmcgIT0gbnVsbCkge1xuICAgICAgeCsrO1xuICAgICAgY3VycmVudE5vZGUgPSBzaWJsaW5nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50ID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcblxuICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyZW50U2libGluZyA9IHBhcmVudC5uZXh0U2libGluZztcblxuICAgICAgaWYgKHBhcmVudFNpYmxpbmcgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgeSsrO1xuICAgICAgeCA9IDA7XG4gICAgICBjdXJyZW50Tm9kZSA9IHBhcmVudFNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZ3JpZC5jb2x1bW5zID0geCArIDE7XG4gIGdyaWQucm93cyA9IHkgKyAxO1xuICByZXR1cm4gZ3JpZDtcbn1cbmZ1bmN0aW9uICR1cGRhdGVET01Gb3JTZWxlY3Rpb24oZWRpdG9yLCBncmlkLCBzZWxlY3Rpb24pIHtcbiAgY29uc3Qgc2VsZWN0ZWRDZWxsTm9kZXMgPSBuZXcgU2V0KHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5nZXROb2RlcygpIDogW10pO1xuICAkZm9yRWFjaEdyaWRDZWxsKGdyaWQsIChjZWxsLCBsZXhpY2FsTm9kZSkgPT4ge1xuICAgIGNvbnN0IGVsZW0gPSBjZWxsLmVsZW07XG5cbiAgICBpZiAoc2VsZWN0ZWRDZWxsTm9kZXMuaGFzKGxleGljYWxOb2RlKSkge1xuICAgICAgY2VsbC5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICAkYWRkSGlnaGxpZ2h0VG9ET00oZWRpdG9yLCBjZWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbC5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgICAgJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKTtcblxuICAgICAgaWYgKCFlbGVtLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gJGZvckVhY2hHcmlkQ2VsbChncmlkLCBjYikge1xuICBjb25zdCB7XG4gICAgY2VsbHNcbiAgfSA9IGdyaWQ7XG5cbiAgZm9yIChsZXQgeSA9IDA7IHkgPCBjZWxscy5sZW5ndGg7IHkrKykge1xuICAgIGNvbnN0IHJvdyA9IGNlbGxzW3ldO1xuXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCByb3cubGVuZ3RoOyB4KyspIHtcbiAgICAgIGNvbnN0IGNlbGwgPSByb3dbeF07XG4gICAgICBjb25zdCBsZXhpY2FsTm9kZSA9IGxleGljYWwuJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoY2VsbC5lbGVtKTtcblxuICAgICAgaWYgKGxleGljYWxOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGNiKGNlbGwsIGxleGljYWxOb2RlLCB7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJGFkZEhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlU2VsZWN0aW9uKSB7XG4gIHRhYmxlU2VsZWN0aW9uLmRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAkZm9yRWFjaEdyaWRDZWxsKHRhYmxlU2VsZWN0aW9uLmdyaWQsIGNlbGwgPT4ge1xuICAgIGNlbGwuaGlnaGxpZ2h0ZWQgPSB0cnVlO1xuICAgICRhZGRIaWdobGlnaHRUb0RPTShlZGl0b3IsIGNlbGwpO1xuICB9KTtcbn1cbmZ1bmN0aW9uICRyZW1vdmVIaWdobGlnaHRTdHlsZVRvVGFibGUoZWRpdG9yLCB0YWJsZVNlbGVjdGlvbikge1xuICB0YWJsZVNlbGVjdGlvbi5lbmFibGVIaWdobGlnaHRTdHlsZSgpO1xuICAkZm9yRWFjaEdyaWRDZWxsKHRhYmxlU2VsZWN0aW9uLmdyaWQsIGNlbGwgPT4ge1xuICAgIGNvbnN0IGVsZW0gPSBjZWxsLmVsZW07XG4gICAgY2VsbC5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgICRyZW1vdmVIaWdobGlnaHRGcm9tRE9NKGVkaXRvciwgY2VsbCk7XG5cbiAgICBpZiAoIWVsZW0uZ2V0QXR0cmlidXRlKCdzdHlsZScpKSB7XG4gICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCBzZWxlY3RHcmlkTm9kZUluRGlyZWN0aW9uID0gKHRhYmxlU2VsZWN0aW9uLCB0YWJsZU5vZGUsIHgsIHksIGRpcmVjdGlvbikgPT4ge1xuICBjb25zdCBpc0ZvcndhcmQgPSBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJztcblxuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgJ2JhY2t3YXJkJzpcbiAgICBjYXNlICdmb3J3YXJkJzpcbiAgICAgIGlmICh4ICE9PSAoaXNGb3J3YXJkID8gdGFibGVTZWxlY3Rpb24uZ3JpZC5jb2x1bW5zIC0gMSA6IDApKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4ICsgKGlzRm9yd2FyZCA/IDEgOiAtMSksIHksIHRhYmxlU2VsZWN0aW9uLmdyaWQpLCBpc0ZvcndhcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHkgIT09IChpc0ZvcndhcmQgPyB0YWJsZVNlbGVjdGlvbi5ncmlkLnJvd3MgLSAxIDogMCkpIHtcbiAgICAgICAgICBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coaXNGb3J3YXJkID8gMCA6IHRhYmxlU2VsZWN0aW9uLmdyaWQuY29sdW1ucyAtIDEsIHkgKyAoaXNGb3J3YXJkID8gMSA6IC0xKSwgdGFibGVTZWxlY3Rpb24uZ3JpZCksIGlzRm9yd2FyZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRm9yd2FyZCkge1xuICAgICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhYmxlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlICd1cCc6XG4gICAgICBpZiAoeSAhPT0gMCkge1xuICAgICAgICBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coeCwgeSAtIDEsIHRhYmxlU2VsZWN0aW9uLmdyaWQpLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWJsZU5vZGUuc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlICdkb3duJzpcbiAgICAgIGlmICh5ICE9PSB0YWJsZVNlbGVjdGlvbi5ncmlkLnJvd3MgLSAxKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4LCB5ICsgMSwgdGFibGVTZWxlY3Rpb24uZ3JpZCksIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFibGVOb2RlLnNlbGVjdE5leHQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5jb25zdCBhZGp1c3RGb2N1c05vZGVJbkRpcmVjdGlvbiA9ICh0YWJsZVNlbGVjdGlvbiwgdGFibGVOb2RlLCB4LCB5LCBkaXJlY3Rpb24pID0+IHtcbiAgY29uc3QgaXNGb3J3YXJkID0gZGlyZWN0aW9uID09PSAnZm9yd2FyZCc7XG5cbiAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICBjYXNlICdiYWNrd2FyZCc6XG4gICAgY2FzZSAnZm9yd2FyZCc6XG4gICAgICBpZiAoeCAhPT0gKGlzRm9yd2FyZCA/IHRhYmxlU2VsZWN0aW9uLmdyaWQuY29sdW1ucyAtIDEgOiAwKSkge1xuICAgICAgICB0YWJsZVNlbGVjdGlvbi5zZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24odGFibGVOb2RlLmdldENlbGxGcm9tQ29yZHNPclRocm93KHggKyAoaXNGb3J3YXJkID8gMSA6IC0xKSwgeSwgdGFibGVTZWxlY3Rpb24uZ3JpZCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ3VwJzpcbiAgICAgIGlmICh5ICE9PSAwKSB7XG4gICAgICAgIHRhYmxlU2VsZWN0aW9uLnNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbih0YWJsZU5vZGUuZ2V0Q2VsbEZyb21Db3Jkc09yVGhyb3coeCwgeSAtIDEsIHRhYmxlU2VsZWN0aW9uLmdyaWQpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBjYXNlICdkb3duJzpcbiAgICAgIGlmICh5ICE9PSB0YWJsZVNlbGVjdGlvbi5ncmlkLnJvd3MgLSAxKSB7XG4gICAgICAgIHRhYmxlU2VsZWN0aW9uLnNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbih0YWJsZU5vZGUuZ2V0Q2VsbEZyb21Db3Jkc09yVGhyb3coeCwgeSArIDEsIHRhYmxlU2VsZWN0aW9uLmdyaWQpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiAkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSB7XG4gIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IGlzQW5jaG9ySW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2Yoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgIGNvbnN0IGlzRm9jdXNJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpKTtcbiAgICByZXR1cm4gaXNBbmNob3JJbnNpZGUgJiYgaXNGb2N1c0luc2lkZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0VGFibGVDZWxsTm9kZSh0YWJsZUNlbGwsIGZyb21TdGFydCkge1xuICBpZiAoZnJvbVN0YXJ0KSB7XG4gICAgdGFibGVDZWxsLnNlbGVjdFN0YXJ0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGFibGVDZWxsLnNlbGVjdEVuZCgpO1xuICB9XG59XG5cbmNvbnN0IEJST1dTRVJfQkxVRV9SR0IgPSAnMTcyLDIwNiwyNDcnO1xuXG5mdW5jdGlvbiAkYWRkSGlnaGxpZ2h0VG9ET00oZWRpdG9yLCBjZWxsKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBjZWxsLmVsZW07XG4gIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGVsZW1lbnQpO1xuXG4gIGlmICghJGlzVGFibGVDZWxsTm9kZShub2RlKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0byBmaW5kIExleGljYWxOb2RlIGZyb20gVGFibGUgQ2VsbCBET01Ob2RlYCk7XG4gIH1cblxuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBub2RlLmdldEJhY2tncm91bmRDb2xvcigpO1xuXG4gIGlmIChiYWNrZ3JvdW5kQ29sb3IgPT09IG51bGwpIHtcbiAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLWNvbG9yJywgYHJnYigke0JST1dTRVJfQkxVRV9SR0J9KWApO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtaW1hZ2UnLCBgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCByZ2JhKCR7QlJPV1NFUl9CTFVFX1JHQn0sMC44NSksIHJnYmEoJHtCUk9XU0VSX0JMVUVfUkdCfSwwLjg1KSlgKTtcbiAgfVxuXG4gIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJ2NhcmV0LWNvbG9yJywgJ3RyYW5zcGFyZW50Jyk7XG59XG5cbmZ1bmN0aW9uICRyZW1vdmVIaWdobGlnaHRGcm9tRE9NKGVkaXRvciwgY2VsbCkge1xuICBjb25zdCBlbGVtZW50ID0gY2VsbC5lbGVtO1xuICBjb25zdCBub2RlID0gbGV4aWNhbC4kZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShlbGVtZW50KTtcblxuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUobm9kZSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdG8gZmluZCBMZXhpY2FsTm9kZSBmcm9tIFRhYmxlIENlbGwgRE9NTm9kZWApO1xuICB9XG5cbiAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gbm9kZS5nZXRCYWNrZ3JvdW5kQ29sb3IoKTtcblxuICBpZiAoYmFja2dyb3VuZENvbG9yID09PSBudWxsKSB7XG4gICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICB9XG5cbiAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnYmFja2dyb3VuZC1pbWFnZScpO1xuICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdjYXJldC1jb2xvcicpO1xufVxuXG5mdW5jdGlvbiAkZmluZENlbGxOb2RlKG5vZGUpIHtcbiAgY29uc3QgY2VsbE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KG5vZGUsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICByZXR1cm4gJGlzVGFibGVDZWxsTm9kZShjZWxsTm9kZSkgPyBjZWxsTm9kZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uICRmaW5kVGFibGVOb2RlKG5vZGUpIHtcbiAgY29uc3QgdGFibGVOb2RlID0gdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChub2RlLCAkaXNUYWJsZU5vZGUpO1xuICByZXR1cm4gJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkgPyB0YWJsZU5vZGUgOiBudWxsO1xufVxuXG5mdW5jdGlvbiAkaGFuZGxlQXJyb3dLZXkoZWRpdG9yLCBldmVudCwgZGlyZWN0aW9uLCB0YWJsZU5vZGUsIHRhYmxlU2VsZWN0aW9uKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgLy8gSG9yaXpvbnRhbCBtb3ZlIGJldHdlZW4gY2VscyBzZWVtIHRvIHdvcmsgd2VsbCB3aXRob3V0IGludGVycnVwdGlvblxuICAgIC8vIHNvIGp1c3QgZXhpdCBlYXJseSwgYW5kIGhhbmRsZSB2ZXJ0aWNhbCBtb3Zlc1xuICAgIGlmIChkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcgfHwgZGlyZWN0aW9uID09PSAnZm9yd2FyZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvci5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG5cbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoYW5jaG9yQ2VsbE5vZGUpIHx8ICFhbmNob3JDZWxsTm9kZS5pcyhmb2N1c0NlbGxOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGFuY2hvckNlbGxEb20gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvckNlbGxOb2RlLl9fa2V5KTtcbiAgICBjb25zdCBhbmNob3JET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvci5rZXkpO1xuXG4gICAgaWYgKGFuY2hvckRPTSA9PSBudWxsIHx8IGFuY2hvckNlbGxEb20gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBlZGdlU2VsZWN0aW9uUmVjdDtcblxuICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICBlZGdlU2VsZWN0aW9uUmVjdCA9IGFuY2hvckRPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZG9tU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAoZG9tU2VsZWN0aW9uID09PSBudWxsIHx8IGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgIGVkZ2VTZWxlY3Rpb25SZWN0ID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuXG4gICAgY29uc3QgZWRnZUNoaWxkID0gZGlyZWN0aW9uID09PSAndXAnID8gYW5jaG9yQ2VsbE5vZGUuZ2V0Rmlyc3RDaGlsZCgpIDogYW5jaG9yQ2VsbE5vZGUuZ2V0TGFzdENoaWxkKCk7XG5cbiAgICBpZiAoZWRnZUNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBlZGdlQ2hpbGRET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGVkZ2VDaGlsZC5fX2tleSk7XG5cbiAgICBpZiAoZWRnZUNoaWxkRE9NID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBlZGdlUmVjdCA9IGVkZ2VDaGlsZERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBpc0V4aXRpbmcgPSBkaXJlY3Rpb24gPT09ICd1cCcgPyBlZGdlUmVjdC50b3AgPiBlZGdlU2VsZWN0aW9uUmVjdC50b3AgLSBlZGdlU2VsZWN0aW9uUmVjdC5oZWlnaHQgOiBlZGdlU2VsZWN0aW9uUmVjdC5ib3R0b20gKyBlZGdlU2VsZWN0aW9uUmVjdC5oZWlnaHQgPiBlZGdlUmVjdC5ib3R0b207XG5cbiAgICBpZiAoaXNFeGl0aW5nKSB7XG4gICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgY29uc3QgY29yZHMgPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUoYW5jaG9yQ2VsbE5vZGUsIHRhYmxlU2VsZWN0aW9uLmdyaWQpO1xuXG4gICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgY29uc3QgY2VsbCA9IHRhYmxlTm9kZS5nZXRDZWxsRnJvbUNvcmRzT3JUaHJvdyhjb3Jkcy54LCBjb3Jkcy55LCB0YWJsZVNlbGVjdGlvbi5ncmlkKTtcbiAgICAgICAgdGFibGVTZWxlY3Rpb24uc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihjZWxsKTtcbiAgICAgICAgdGFibGVTZWxlY3Rpb24uc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGNlbGwsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdEdyaWROb2RlSW5EaXJlY3Rpb24odGFibGVTZWxlY3Rpb24sIHRhYmxlTm9kZSwgY29yZHMueCwgY29yZHMueSwgZGlyZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvci5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG5cbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoYW5jaG9yQ2VsbE5vZGUpIHx8ICEkaXNUYWJsZUNlbGxOb2RlKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RvcEV2ZW50KGV2ZW50KTtcblxuICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgY29uc3QgY29yZHMgPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUoZm9jdXNDZWxsTm9kZSwgdGFibGVTZWxlY3Rpb24uZ3JpZCk7XG4gICAgICByZXR1cm4gYWRqdXN0Rm9jdXNOb2RlSW5EaXJlY3Rpb24odGFibGVTZWxlY3Rpb24sIHRhYmxlTm9kZSwgY29yZHMueCwgY29yZHMueSwgZGlyZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9jdXNDZWxsTm9kZS5zZWxlY3RFbmQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc3RvcEV2ZW50KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgVGFibGVOb2RlIGV4dGVuZHMgbGV4aWNhbC5ERVBSRUNBVEVEX0dyaWROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3RhYmxlJztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZU5vZGUobm9kZS5fX2tleSk7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWJsZTogX25vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRhYmxlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDFcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKF9zZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlVGFibGVOb2RlKCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4geyAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cblxuICBjcmVhdGVET00oY29uZmlnLCBlZGl0b3IpIHtcbiAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xuICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQodGFibGVFbGVtZW50LCBjb25maWcudGhlbWUudGFibGUpO1xuICAgIHJldHVybiB0YWJsZUVsZW1lbnQ7XG4gIH1cblxuICB1cGRhdGVET00oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydERPTShlZGl0b3IpLFxuICAgICAgYWZ0ZXI6IHRhYmxlRWxlbWVudCA9PiB7XG4gICAgICAgIGlmICh0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCBuZXdFbGVtZW50ID0gdGFibGVFbGVtZW50LmNsb25lTm9kZSgpO1xuICAgICAgICAgIGNvbnN0IGNvbEdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sZ3JvdXAnKTtcbiAgICAgICAgICBjb25zdCB0Qm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Rib2R5Jyk7XG4gICAgICAgICAgdEJvZHkuYXBwZW5kKC4uLnRhYmxlRWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgICAgY29uc3QgZmlyc3RSb3cgPSB0aGlzLmdldEZpcnN0Q2hpbGRPclRocm93KCk7XG5cbiAgICAgICAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShmaXJzdFJvdykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCByb3cgbm9kZS4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjb2xDb3VudCA9IGZpcnN0Um93LmdldENoaWxkcmVuU2l6ZSgpO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2wnKTtcbiAgICAgICAgICAgIGNvbEdyb3VwLmFwcGVuZChjb2wpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld0VsZW1lbnQucmVwbGFjZUNoaWxkcmVuKGNvbEdyb3VwLCB0Qm9keSk7XG4gICAgICAgICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9IC8vIFRPRE8gMC4xMCBkZXByZWNhdGVcblxuXG4gIGNhbkV4dHJhY3RDb250ZW50cygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzU2hhZG93Um9vdCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldENvcmRzRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIGdyaWQpIHtcbiAgICBjb25zdCB7XG4gICAgICByb3dzLFxuICAgICAgY2VsbHNcbiAgICB9ID0gZ3JpZDtcblxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgcm93czsgeSsrKSB7XG4gICAgICBjb25zdCByb3cgPSBjZWxsc1t5XTtcblxuICAgICAgaWYgKHJvdyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUm93IG5vdCBmb3VuZCBhdCB5OiR7eX1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeCA9IHJvdy5maW5kSW5kZXgoKHtcbiAgICAgICAgZWxlbVxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCBjZWxsTm9kZSA9IGxleGljYWwuJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZWxlbSk7XG4gICAgICAgIHJldHVybiBjZWxsTm9kZSA9PT0gdGFibGVDZWxsTm9kZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoeCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlbGwgbm90IGZvdW5kIGluIHRhYmxlLicpO1xuICB9XG5cbiAgZ2V0Q2VsbEZyb21Db3Jkcyh4LCB5LCBncmlkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2VsbHNcbiAgICB9ID0gZ3JpZDtcbiAgICBjb25zdCByb3cgPSBjZWxsc1t5XTtcblxuICAgIGlmIChyb3cgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgY2VsbCA9IHJvd1t4XTtcblxuICAgIGlmIChjZWxsID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjZWxsO1xuICB9XG5cbiAgZ2V0Q2VsbEZyb21Db3Jkc09yVGhyb3coeCwgeSwgZ3JpZCkge1xuICAgIGNvbnN0IGNlbGwgPSB0aGlzLmdldENlbGxGcm9tQ29yZHMoeCwgeSwgZ3JpZCk7XG5cbiAgICBpZiAoIWNlbGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2VsbCBub3QgZm91bmQgYXQgY29yZHMuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbGw7XG4gIH1cblxuICBnZXRDZWxsTm9kZUZyb21Db3Jkcyh4LCB5LCBncmlkKSB7XG4gICAgY29uc3QgY2VsbCA9IHRoaXMuZ2V0Q2VsbEZyb21Db3Jkcyh4LCB5LCBncmlkKTtcblxuICAgIGlmIChjZWxsID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGNlbGwuZWxlbSk7XG5cbiAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coeCwgeSwgZ3JpZCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHksIGdyaWQpO1xuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgYXQgY29yZHMgbm90IFRhYmxlQ2VsbE5vZGUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBjYW5TZWxlY3RCZWZvcmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn1cbmZ1bmN0aW9uICRnZXRFbGVtZW50R3JpZEZvclRhYmxlTm9kZShlZGl0b3IsIHRhYmxlTm9kZSkge1xuICBjb25zdCB0YWJsZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRhYmxlTm9kZS5nZXRLZXkoKSk7XG5cbiAgaWYgKHRhYmxlRWxlbWVudCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYWJsZSBFbGVtZW50IE5vdCBGb3VuZCcpO1xuICB9XG5cbiAgcmV0dXJuIGdldFRhYmxlR3JpZCh0YWJsZUVsZW1lbnQpO1xufVxuZnVuY3Rpb24gY29udmVydFRhYmxlRWxlbWVudChfZG9tTm9kZSkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVUYWJsZU5vZGUoKVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlTm9kZSgpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUYWJsZU5vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNUYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRhYmxlTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zKHJvd0NvdW50LCBjb2x1bW5Db3VudCwgaW5jbHVkZUhlYWRlcnMgPSB0cnVlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRjcmVhdGVUYWJsZU5vZGUoKTtcblxuICBmb3IgKGxldCBpUm93ID0gMDsgaVJvdyA8IHJvd0NvdW50OyBpUm93KyspIHtcbiAgICBjb25zdCB0YWJsZVJvd05vZGUgPSAkY3JlYXRlVGFibGVSb3dOb2RlKCk7XG5cbiAgICBmb3IgKGxldCBpQ29sdW1uID0gMDsgaUNvbHVtbiA8IGNvbHVtbkNvdW50OyBpQ29sdW1uKyspIHtcbiAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5jbHVkZUhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpUm93ID09PSAwICYmIGluY2x1ZGVIZWFkZXJzLnJvd3MpIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1c7XG4gICAgICAgIGlmIChpQ29sdW1uID09PSAwICYmIGluY2x1ZGVIZWFkZXJzLmNvbHVtbnMpIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU47XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVIZWFkZXJzKSB7XG4gICAgICAgIGlmIChpUm93ID09PSAwKSBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XO1xuICAgICAgICBpZiAoaUNvbHVtbiA9PT0gMCkgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlKTtcbiAgICAgIGNvbnN0IHBhcmFncmFwaE5vZGUgPSBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZChsZXhpY2FsLiRjcmVhdGVUZXh0Tm9kZSgpKTtcbiAgICAgIHRhYmxlQ2VsbE5vZGUuYXBwZW5kKHBhcmFncmFwaE5vZGUpO1xuICAgICAgdGFibGVSb3dOb2RlLmFwcGVuZCh0YWJsZUNlbGxOb2RlKTtcbiAgICB9XG5cbiAgICB0YWJsZU5vZGUuYXBwZW5kKHRhYmxlUm93Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ2VsbE5vZGVGcm9tTGV4aWNhbE5vZGUoc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0aW5nTm9kZSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcblxuICBpZiAoJGlzVGFibGVDZWxsTm9kZShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVSb3dOb2RlRnJvbVRhYmxlQ2VsbE5vZGVPclRocm93KHN0YXJ0aW5nTm9kZSkge1xuICBjb25zdCBub2RlID0gdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChzdGFydGluZ05vZGUsIG4gPT4gJGlzVGFibGVSb3dOb2RlKG4pKTtcblxuICBpZiAoJGlzVGFibGVSb3dOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRhYmxlIGNlbGwgdG8gYmUgaW5zaWRlIG9mIHRhYmxlIHJvdy4nKTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHN0YXJ0aW5nTm9kZSkge1xuICBjb25zdCBub2RlID0gdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChzdGFydGluZ05vZGUsIG4gPT4gJGlzVGFibGVOb2RlKG4pKTtcblxuICBpZiAoJGlzVGFibGVOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRhYmxlIGNlbGwgdG8gYmUgaW5zaWRlIG9mIHRhYmxlLicpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlUm93SW5kZXhGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSB7XG4gIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHRhYmxlUm93Tm9kZSk7XG4gIHJldHVybiB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKS5maW5kSW5kZXgobiA9PiBuLmlzKHRhYmxlUm93Tm9kZSkpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ29sdW1uSW5kZXhGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSB7XG4gIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIHJldHVybiB0YWJsZVJvd05vZGUuZ2V0Q2hpbGRyZW4oKS5maW5kSW5kZXgobiA9PiBuLmlzKHRhYmxlQ2VsbE5vZGUpKTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZUNlbGxTaWJsaW5nc0Zyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIGdyaWQpIHtcbiAgY29uc3QgdGFibGVOb2RlID0gJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCBncmlkKTtcbiAgcmV0dXJuIHtcbiAgICBhYm92ZTogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHkgLSAxLCBncmlkKSxcbiAgICBiZWxvdzogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHkgKyAxLCBncmlkKSxcbiAgICBsZWZ0OiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCAtIDEsIHksIGdyaWQpLFxuICAgIHJpZ2h0OiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCArIDEsIHksIGdyaWQpXG4gIH07XG59XG5mdW5jdGlvbiAkcmVtb3ZlVGFibGVSb3dBdEluZGV4KHRhYmxlTm9kZSwgaW5kZXhUb0RlbGV0ZSkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcblxuICBpZiAoaW5kZXhUb0RlbGV0ZSA+PSB0YWJsZVJvd3MubGVuZ3RoIHx8IGluZGV4VG9EZWxldGUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0YWJsZSBjZWxsIHRvIGJlIGluc2lkZSBvZiB0YWJsZSByb3cuJyk7XG4gIH1cblxuICBjb25zdCB0YXJnZXRSb3dOb2RlID0gdGFibGVSb3dzW2luZGV4VG9EZWxldGVdO1xuICB0YXJnZXRSb3dOb2RlLnJlbW92ZSgpO1xuICByZXR1cm4gdGFibGVOb2RlO1xufVxuZnVuY3Rpb24gJGluc2VydFRhYmxlUm93KHRhYmxlTm9kZSwgdGFyZ2V0SW5kZXgsIHNob3VsZEluc2VydEFmdGVyID0gdHJ1ZSwgcm93Q291bnQsIGdyaWQpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG5cbiAgaWYgKHRhcmdldEluZGV4ID49IHRhYmxlUm93cy5sZW5ndGggfHwgdGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYWJsZSByb3cgdGFyZ2V0IGluZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG5cbiAgY29uc3QgdGFyZ2V0Um93Tm9kZSA9IHRhYmxlUm93c1t0YXJnZXRJbmRleF07XG5cbiAgaWYgKCRpc1RhYmxlUm93Tm9kZSh0YXJnZXRSb3dOb2RlKSkge1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgcm93Q291bnQ7IHIrKykge1xuICAgICAgY29uc3QgdGFibGVSb3dDZWxscyA9IHRhcmdldFJvd05vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIGNvbnN0IHRhYmxlQ29sdW1uQ291bnQgPSB0YWJsZVJvd0NlbGxzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5ld1RhYmxlUm93Tm9kZSA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcblxuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCB0YWJsZUNvbHVtbkNvdW50OyBjKyspIHtcbiAgICAgICAgY29uc3QgdGFibGVDZWxsRnJvbVRhcmdldFJvdyA9IHRhYmxlUm93Q2VsbHNbY107XG5cbiAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbEZyb21UYXJnZXRSb3cpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRhYmxlIGNlbGxgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhYm92ZSxcbiAgICAgICAgICBiZWxvd1xuICAgICAgICB9ID0gJGdldFRhYmxlQ2VsbFNpYmxpbmdzRnJvbVRhYmxlQ2VsbE5vZGUodGFibGVDZWxsRnJvbVRhcmdldFJvdywgZ3JpZCk7XG4gICAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gYWJvdmUgJiYgYWJvdmUuZ2V0V2lkdGgoKSB8fCBiZWxvdyAmJiBiZWxvdy5nZXRXaWR0aCgpIHx8IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoYWJvdmUgJiYgYWJvdmUuaGFzSGVhZGVyU3RhdGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTikgfHwgYmVsb3cgJiYgYmVsb3cuaGFzSGVhZGVyU3RhdGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTikpIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlLCAxLCB3aWR0aCk7XG4gICAgICAgIHRhYmxlQ2VsbE5vZGUuYXBwZW5kKGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgICAgIG5ld1RhYmxlUm93Tm9kZS5hcHBlbmQodGFibGVDZWxsTm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRJbnNlcnRBZnRlcikge1xuICAgICAgICB0YXJnZXRSb3dOb2RlLmluc2VydEFmdGVyKG5ld1RhYmxlUm93Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRSb3dOb2RlLmluc2VydEJlZm9yZShuZXdUYWJsZVJvd05vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvdyBiZWZvcmUgaW5zZXJ0aW9uIGluZGV4IGRvZXMgbm90IGV4aXN0LicpO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cbmZ1bmN0aW9uICRpbnNlcnRUYWJsZVJvd19fRVhQRVJJTUVOVEFMKGluc2VydEFmdGVyID0gdHJ1ZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIShsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBHcmlkU2VsZWN0aW9uYCk7XG4gIH1cblxuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IFtmb2N1c0NlbGwsLCBncmlkXSA9IGxleGljYWwuREVQUkVDQVRFRF8kZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbZ3JpZE1hcCwgZm9jdXNDZWxsTWFwXSA9IGxleGljYWwuREVQUkVDQVRFRF8kY29tcHV0ZUdyaWRNYXAoZ3JpZCwgZm9jdXNDZWxsLCBmb2N1c0NlbGwpO1xuICBjb25zdCBjb2x1bW5Db3VudCA9IGdyaWRNYXBbMF0ubGVuZ3RoO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3c6IGZvY3VzU3RhcnRSb3dcbiAgfSA9IGZvY3VzQ2VsbE1hcDtcblxuICBpZiAoaW5zZXJ0QWZ0ZXIpIHtcbiAgICBjb25zdCBmb2N1c0VuZFJvdyA9IGZvY3VzU3RhcnRSb3cgKyBmb2N1c0NlbGwuX19yb3dTcGFuIC0gMTtcbiAgICBjb25zdCBmb2N1c0VuZFJvd01hcCA9IGdyaWRNYXBbZm9jdXNFbmRSb3ddO1xuICAgIGNvbnN0IG5ld1JvdyA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydFJvd1xuICAgICAgfSA9IGZvY3VzRW5kUm93TWFwW2ldO1xuXG4gICAgICBpZiAoc3RhcnRSb3cgKyBjZWxsLl9fcm93U3BhbiAtIDEgPD0gZm9jdXNFbmRSb3cpIHtcbiAgICAgICAgbmV3Um93LmFwcGVuZCgkY3JlYXRlVGFibGVDZWxsTm9kZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZWxsLnNldFJvd1NwYW4oY2VsbC5fX3Jvd1NwYW4gKyAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmb2N1c0VuZFJvd05vZGUgPSBncmlkLmdldENoaWxkQXRJbmRleChmb2N1c0VuZFJvdyk7XG5cbiAgICBpZiAoIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkUm93Tm9kZShmb2N1c0VuZFJvd05vZGUpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgZm9jdXNFbmRSb3cgaXMgbm90IGEgR3JpZFJvd05vZGVgKTtcbiAgICB9XG5cbiAgICBmb2N1c0VuZFJvd05vZGUuaW5zZXJ0QWZ0ZXIobmV3Um93KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmb2N1c1N0YXJ0Um93TWFwID0gZ3JpZE1hcFtmb2N1c1N0YXJ0Um93XTtcbiAgICBjb25zdCBuZXdSb3cgPSAkY3JlYXRlVGFibGVSb3dOb2RlKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRSb3dcbiAgICAgIH0gPSBmb2N1c1N0YXJ0Um93TWFwW2ldO1xuXG4gICAgICBpZiAoc3RhcnRSb3cgPT09IGZvY3VzU3RhcnRSb3cpIHtcbiAgICAgICAgbmV3Um93LmFwcGVuZCgkY3JlYXRlVGFibGVDZWxsTm9kZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZWxsLnNldFJvd1NwYW4oY2VsbC5fX3Jvd1NwYW4gKyAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmb2N1c1N0YXJ0Um93Tm9kZSA9IGdyaWQuZ2V0Q2hpbGRBdEluZGV4KGZvY3VzU3RhcnRSb3cpO1xuXG4gICAgaWYgKCFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFJvd05vZGUoZm9jdXNTdGFydFJvd05vZGUpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgZm9jdXNFbmRSb3cgaXMgbm90IGEgR3JpZFJvd05vZGVgKTtcbiAgICB9XG5cbiAgICBmb2N1c1N0YXJ0Um93Tm9kZS5pbnNlcnRCZWZvcmUobmV3Um93KTtcbiAgfVxufVxuZnVuY3Rpb24gJGluc2VydFRhYmxlQ29sdW1uKHRhYmxlTm9kZSwgdGFyZ2V0SW5kZXgsIHNob3VsZEluc2VydEFmdGVyID0gdHJ1ZSwgY29sdW1uQ291bnQsIGdyaWQpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG5cbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0YWJsZVJvd3MubGVuZ3RoOyByKyspIHtcbiAgICBjb25zdCBjdXJyZW50VGFibGVSb3dOb2RlID0gdGFibGVSb3dzW3JdO1xuXG4gICAgaWYgKCRpc1RhYmxlUm93Tm9kZShjdXJyZW50VGFibGVSb3dOb2RlKSkge1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb2x1bW5Db3VudDsgYysrKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlUm93Q2hpbGRyZW4gPSBjdXJyZW50VGFibGVSb3dOb2RlLmdldENoaWxkcmVuKCk7XG5cbiAgICAgICAgaWYgKHRhcmdldEluZGV4ID49IHRhYmxlUm93Q2hpbGRyZW4ubGVuZ3RoIHx8IHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFibGUgY29sdW1uIHRhcmdldCBpbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldENlbGwgPSB0YWJsZVJvd0NoaWxkcmVuW3RhcmdldEluZGV4XTtcblxuICAgICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFyZ2V0Q2VsbCkpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdGFibGUgY2VsbGApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgcmlnaHRcbiAgICAgICAgfSA9ICRnZXRUYWJsZUNlbGxTaWJsaW5nc0Zyb21UYWJsZUNlbGxOb2RlKHRhcmdldENlbGwsIGdyaWQpO1xuICAgICAgICBsZXQgaGVhZGVyU3RhdGUgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTO1xuXG4gICAgICAgIGlmIChsZWZ0ICYmIGxlZnQuaGFzSGVhZGVyU3RhdGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVykgfHwgcmlnaHQgJiYgcmlnaHQuaGFzSGVhZGVyU3RhdGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVykpIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV3VGFibGVDZWxsID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpO1xuICAgICAgICBuZXdUYWJsZUNlbGwuYXBwZW5kKGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG5cbiAgICAgICAgaWYgKHNob3VsZEluc2VydEFmdGVyKSB7XG4gICAgICAgICAgdGFyZ2V0Q2VsbC5pbnNlcnRBZnRlcihuZXdUYWJsZUNlbGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldENlbGwuaW5zZXJ0QmVmb3JlKG5ld1RhYmxlQ2VsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuZnVuY3Rpb24gJGluc2VydFRhYmxlQ29sdW1uX19FWFBFUklNRU5UQUwoaW5zZXJ0QWZ0ZXIgPSB0cnVlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIEdyaWRTZWxlY3Rpb25gKTtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IFthbmNob3JDZWxsXSA9IGxleGljYWwuREVQUkVDQVRFRF8kZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgY29uc3QgW2ZvY3VzQ2VsbCwsIGdyaWRdID0gbGV4aWNhbC5ERVBSRUNBVEVEXyRnZXROb2RlVHJpcGxldChmb2N1cyk7XG4gIGNvbnN0IFtncmlkTWFwLCBmb2N1c0NlbGxNYXAsIGFuY2hvckNlbGxNYXBdID0gbGV4aWNhbC5ERVBSRUNBVEVEXyRjb21wdXRlR3JpZE1hcChncmlkLCBmb2N1c0NlbGwsIGFuY2hvckNlbGwpO1xuICBjb25zdCByb3dDb3VudCA9IGdyaWRNYXAubGVuZ3RoO1xuICBjb25zdCBzdGFydENvbHVtbiA9IGluc2VydEFmdGVyID8gTWF0aC5tYXgoZm9jdXNDZWxsTWFwLnN0YXJ0Q29sdW1uLCBhbmNob3JDZWxsTWFwLnN0YXJ0Q29sdW1uKSA6IE1hdGgubWluKGZvY3VzQ2VsbE1hcC5zdGFydENvbHVtbiwgYW5jaG9yQ2VsbE1hcC5zdGFydENvbHVtbik7XG4gIGNvbnN0IGluc2VydEFmdGVyQ29sdW1uID0gaW5zZXJ0QWZ0ZXIgPyBzdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW4gLSAxIDogc3RhcnRDb2x1bW4gLSAxO1xuICBjb25zdCBncmlkRmlyc3RDaGlsZCA9IGdyaWQuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlKGdyaWRGaXJzdENoaWxkKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBmaXJzdFRhYmxlIGNoaWxkIHRvIGJlIGEgcm93YCk7XG4gIH1cblxuICBsZXQgZmlyc3RJbnNlcnRlZENlbGwgPSBudWxsO1xuXG4gIGZ1bmN0aW9uICRjcmVhdGVUYWJsZUNlbGxOb2RlRm9ySW5zZXJ0VGFibGVDb2x1bW4oKSB7XG4gICAgY29uc3QgY2VsbCA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVMpLmFwcGVuZChsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuXG4gICAgaWYgKGZpcnN0SW5zZXJ0ZWRDZWxsID09PSBudWxsKSB7XG4gICAgICBmaXJzdEluc2VydGVkQ2VsbCA9IGNlbGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbGw7XG4gIH1cblxuICBsZXQgbG9vcFJvdyA9IGdyaWRGaXJzdENoaWxkO1xuXG4gIHJvd0xvb3A6IGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGlmIChpICE9PSAwKSB7XG4gICAgICBjb25zdCBjdXJyZW50Um93ID0gbG9vcFJvdy5nZXROZXh0U2libGluZygpO1xuXG4gICAgICBpZiAoIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkUm93Tm9kZShjdXJyZW50Um93KSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgcm93IG5leHRTaWJsaW5nIHRvIGJlIGEgcm93YCk7XG4gICAgICB9XG5cbiAgICAgIGxvb3BSb3cgPSBjdXJyZW50Um93O1xuICAgIH1cblxuICAgIGNvbnN0IHJvd01hcCA9IGdyaWRNYXBbaV07XG5cbiAgICBpZiAoaW5zZXJ0QWZ0ZXJDb2x1bW4gPCAwKSB7XG4gICAgICAkaW5zZXJ0Rmlyc3QobG9vcFJvdywgJGNyZWF0ZVRhYmxlQ2VsbE5vZGVGb3JJbnNlcnRUYWJsZUNvbHVtbigpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGNlbGw6IGN1cnJlbnRDZWxsLFxuICAgICAgc3RhcnRDb2x1bW46IGN1cnJlbnRTdGFydENvbHVtbixcbiAgICAgIHN0YXJ0Um93OiBjdXJyZW50U3RhcnRSb3dcbiAgICB9ID0gcm93TWFwW2luc2VydEFmdGVyQ29sdW1uXTtcblxuICAgIGlmIChjdXJyZW50U3RhcnRDb2x1bW4gKyBjdXJyZW50Q2VsbC5fX2NvbFNwYW4gLSAxIDw9IGluc2VydEFmdGVyQ29sdW1uKSB7XG4gICAgICBsZXQgaW5zZXJ0QWZ0ZXJDZWxsID0gY3VycmVudENlbGw7XG4gICAgICBsZXQgaW5zZXJ0QWZ0ZXJDZWxsUm93U3RhcnQgPSBjdXJyZW50U3RhcnRSb3c7XG4gICAgICBsZXQgcHJldkNlbGxJbmRleCA9IGluc2VydEFmdGVyQ29sdW1uO1xuXG4gICAgICB3aGlsZSAoaW5zZXJ0QWZ0ZXJDZWxsUm93U3RhcnQgIT09IGkgJiYgaW5zZXJ0QWZ0ZXJDZWxsLl9fcm93U3BhbiA+IDEpIHtcbiAgICAgICAgcHJldkNlbGxJbmRleCAtPSBjdXJyZW50Q2VsbC5fX2NvbFNwYW47XG5cbiAgICAgICAgaWYgKHByZXZDZWxsSW5kZXggPj0gMCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNlbGw6IGNlbGxfLFxuICAgICAgICAgICAgc3RhcnRSb3c6IHN0YXJ0Um93X1xuICAgICAgICAgIH0gPSByb3dNYXBbcHJldkNlbGxJbmRleF07XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsID0gY2VsbF87XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsUm93U3RhcnQgPSBzdGFydFJvd187XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9vcFJvdy5hcHBlbmQoJGNyZWF0ZVRhYmxlQ2VsbE5vZGVGb3JJbnNlcnRUYWJsZUNvbHVtbigpKTtcbiAgICAgICAgICBjb250aW51ZSByb3dMb29wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluc2VydEFmdGVyQ2VsbC5pbnNlcnRBZnRlcigkY3JlYXRlVGFibGVDZWxsTm9kZUZvckluc2VydFRhYmxlQ29sdW1uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Q2VsbC5zZXRDb2xTcGFuKGN1cnJlbnRDZWxsLl9fY29sU3BhbiArIDEpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmaXJzdEluc2VydGVkQ2VsbCAhPT0gbnVsbCkge1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGZpcnN0SW5zZXJ0ZWRDZWxsKTtcbiAgfVxufVxuZnVuY3Rpb24gJGRlbGV0ZVRhYmxlQ29sdW1uKHRhYmxlTm9kZSwgdGFyZ2V0SW5kZXgpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJsZVJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50VGFibGVSb3dOb2RlID0gdGFibGVSb3dzW2ldO1xuXG4gICAgaWYgKCRpc1RhYmxlUm93Tm9kZShjdXJyZW50VGFibGVSb3dOb2RlKSkge1xuICAgICAgY29uc3QgdGFibGVSb3dDaGlsZHJlbiA9IGN1cnJlbnRUYWJsZVJvd05vZGUuZ2V0Q2hpbGRyZW4oKTtcblxuICAgICAgaWYgKHRhcmdldEluZGV4ID49IHRhYmxlUm93Q2hpbGRyZW4ubGVuZ3RoIHx8IHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIGNvbHVtbiB0YXJnZXQgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIHRhYmxlUm93Q2hpbGRyZW5bdGFyZ2V0SW5kZXhdLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YWJsZU5vZGU7XG59XG5mdW5jdGlvbiAkZGVsZXRlVGFibGVSb3dfX0VYUEVSSU1FTlRBTCgpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCEobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGEgUmFuZ2VTZWxlY3Rpb24gb3IgR3JpZFNlbGVjdGlvbmApO1xuICB9XG5cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgW2FuY2hvckNlbGwsLCBncmlkXSA9IGxleGljYWwuREVQUkVDQVRFRF8kZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgY29uc3QgW2ZvY3VzQ2VsbF0gPSBsZXhpY2FsLkRFUFJFQ0FURURfJGdldE5vZGVUcmlwbGV0KGZvY3VzKTtcbiAgY29uc3QgW2dyaWRNYXAsIGFuY2hvckNlbGxNYXAsIGZvY3VzQ2VsbE1hcF0gPSBsZXhpY2FsLkRFUFJFQ0FURURfJGNvbXB1dGVHcmlkTWFwKGdyaWQsIGFuY2hvckNlbGwsIGZvY3VzQ2VsbCk7XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdzogYW5jaG9yU3RhcnRSb3dcbiAgfSA9IGFuY2hvckNlbGxNYXA7XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdzogZm9jdXNTdGFydFJvd1xuICB9ID0gZm9jdXNDZWxsTWFwO1xuICBjb25zdCBmb2N1c0VuZFJvdyA9IGZvY3VzU3RhcnRSb3cgKyBmb2N1c0NlbGwuX19yb3dTcGFuIC0gMTtcblxuICBpZiAoZ3JpZE1hcC5sZW5ndGggPT09IGZvY3VzRW5kUm93IC0gYW5jaG9yU3RhcnRSb3cgKyAxKSB7XG4gICAgLy8gRW1wdHkgZ3JpZFxuICAgIGdyaWQucmVtb3ZlKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY29sdW1uQ291bnQgPSBncmlkTWFwWzBdLmxlbmd0aDtcbiAgY29uc3QgbmV4dFJvdyA9IGdyaWRNYXBbZm9jdXNFbmRSb3cgKyAxXTtcbiAgY29uc3QgbmV4dFJvd05vZGUgPSBncmlkLmdldENoaWxkQXRJbmRleChmb2N1c0VuZFJvdyArIDEpO1xuXG4gIGZvciAobGV0IHJvdyA9IGZvY3VzRW5kUm93OyByb3cgPj0gYW5jaG9yU3RhcnRSb3c7IHJvdy0tKSB7XG4gICAgZm9yIChsZXQgY29sdW1uID0gY29sdW1uQ291bnQgLSAxOyBjb2x1bW4gPj0gMDsgY29sdW1uLS0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRSb3c6IGNlbGxTdGFydFJvdyxcbiAgICAgICAgc3RhcnRDb2x1bW46IGNlbGxTdGFydENvbHVtblxuICAgICAgfSA9IGdyaWRNYXBbcm93XVtjb2x1bW5dO1xuXG4gICAgICBpZiAoY2VsbFN0YXJ0Q29sdW1uICE9PSBjb2x1bW4pIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVwZWF0IHdvcmsgZm9yIHRoZSBzYW1lIENlbGxcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIFJvd3Mgb3ZlcmZsb3dpbmcgdG9wIGhhdmUgdG8gYmUgdHJpbW1lZFxuXG5cbiAgICAgIGlmIChyb3cgPT09IGFuY2hvclN0YXJ0Um93ICYmIGNlbGxTdGFydFJvdyA8IGFuY2hvclN0YXJ0Um93KSB7XG4gICAgICAgIGNlbGwuc2V0Um93U3BhbihjZWxsLl9fcm93U3BhbiAtIChjZWxsU3RhcnRSb3cgLSBhbmNob3JTdGFydFJvdykpO1xuICAgICAgfSAvLyBSb3dzIG92ZXJmbG93aW5nIGJvdHRvbSBoYXZlIHRvIGJlIHRyaW1tZWQgYW5kIG1vdmVkIHRvIHRoZSBuZXh0IHJvd1xuXG5cbiAgICAgIGlmIChjZWxsU3RhcnRSb3cgPj0gYW5jaG9yU3RhcnRSb3cgJiYgY2VsbFN0YXJ0Um93ICsgY2VsbC5fX3Jvd1NwYW4gLSAxID4gZm9jdXNFbmRSb3cpIHtcbiAgICAgICAgY2VsbC5zZXRSb3dTcGFuKGNlbGwuX19yb3dTcGFuIC0gKGZvY3VzRW5kUm93IC0gY2VsbFN0YXJ0Um93ICsgMSkpO1xuXG4gICAgICAgIGlmICghKG5leHRSb3dOb2RlICE9PSBudWxsKSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBuZXh0Um93Tm9kZSBub3QgdG8gYmUgbnVsbGApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbHVtbiA9PT0gMCkge1xuICAgICAgICAgICRpbnNlcnRGaXJzdChuZXh0Um93Tm9kZSwgY2VsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY2VsbDogcHJldmlvdXNDZWxsXG4gICAgICAgICAgfSA9IG5leHRSb3dbY29sdW1uIC0gMV07XG4gICAgICAgICAgcHJldmlvdXNDZWxsLmluc2VydEFmdGVyKGNlbGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgcm93Tm9kZSA9IGdyaWQuZ2V0Q2hpbGRBdEluZGV4KHJvdyk7XG5cbiAgICBpZiAoIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkUm93Tm9kZShyb3dOb2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIEdyaWROb2RlIGNoaWxkQXRJbmRleCgke1N0cmluZyhyb3cpfSkgdG8gYmUgUm93Tm9kZWApO1xuICAgIH1cblxuICAgIHJvd05vZGUucmVtb3ZlKCk7XG4gIH1cblxuICBpZiAobmV4dFJvdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFxuICAgIH0gPSBuZXh0Um93WzBdO1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByZXZpb3VzUm93ID0gZ3JpZE1hcFthbmNob3JTdGFydFJvdyAtIDFdO1xuICAgIGNvbnN0IHtcbiAgICAgIGNlbGxcbiAgICB9ID0gcHJldmlvdXNSb3dbMF07XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRkZWxldGVUYWJsZUNvbHVtbl9fRVhQRVJJTUVOVEFMKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIShsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBHcmlkU2VsZWN0aW9uYCk7XG4gIH1cblxuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICBjb25zdCBbYW5jaG9yQ2VsbCwsIGdyaWRdID0gbGV4aWNhbC5ERVBSRUNBVEVEXyRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICBjb25zdCBbZm9jdXNDZWxsXSA9IGxleGljYWwuREVQUkVDQVRFRF8kZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbZ3JpZE1hcCwgYW5jaG9yQ2VsbE1hcCwgZm9jdXNDZWxsTWFwXSA9IGxleGljYWwuREVQUkVDQVRFRF8kY29tcHV0ZUdyaWRNYXAoZ3JpZCwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Q29sdW1uOiBhbmNob3JTdGFydENvbHVtblxuICB9ID0gYW5jaG9yQ2VsbE1hcDtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBmb2N1c1N0YXJ0Um93LFxuICAgIHN0YXJ0Q29sdW1uOiBmb2N1c1N0YXJ0Q29sdW1uXG4gIH0gPSBmb2N1c0NlbGxNYXA7XG4gIGNvbnN0IHN0YXJ0Q29sdW1uID0gTWF0aC5taW4oYW5jaG9yU3RhcnRDb2x1bW4sIGZvY3VzU3RhcnRDb2x1bW4pO1xuICBjb25zdCBlbmRDb2x1bW4gPSBNYXRoLm1heChhbmNob3JTdGFydENvbHVtbiArIGFuY2hvckNlbGwuX19jb2xTcGFuIC0gMSwgZm9jdXNTdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW4gLSAxKTtcbiAgY29uc3Qgc2VsZWN0ZWRDb2x1bW5Db3VudCA9IGVuZENvbHVtbiAtIHN0YXJ0Q29sdW1uICsgMTtcbiAgY29uc3QgY29sdW1uQ291bnQgPSBncmlkTWFwWzBdLmxlbmd0aDtcblxuICBpZiAoY29sdW1uQ291bnQgPT09IGVuZENvbHVtbiAtIHN0YXJ0Q29sdW1uICsgMSkge1xuICAgIC8vIEVtcHR5IGdyaWRcbiAgICBncmlkLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgZ3JpZC5yZW1vdmUoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCByb3dDb3VudCA9IGdyaWRNYXAubGVuZ3RoO1xuXG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd0NvdW50OyByb3crKykge1xuICAgIGZvciAobGV0IGNvbHVtbiA9IHN0YXJ0Q29sdW1uOyBjb2x1bW4gPD0gZW5kQ29sdW1uOyBjb2x1bW4rKykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydENvbHVtbjogY2VsbFN0YXJ0Q29sdW1uXG4gICAgICB9ID0gZ3JpZE1hcFtyb3ddW2NvbHVtbl07XG5cbiAgICAgIGlmIChjZWxsU3RhcnRDb2x1bW4gPCBzdGFydENvbHVtbikge1xuICAgICAgICBpZiAoY29sdW1uID09PSBzdGFydENvbHVtbikge1xuICAgICAgICAgIGNvbnN0IG92ZXJmbG93TGVmdCA9IHN0YXJ0Q29sdW1uIC0gY2VsbFN0YXJ0Q29sdW1uOyAvLyBPdmVyZmxvd2luZyBsZWZ0XG5cbiAgICAgICAgICBjZWxsLnNldENvbFNwYW4oY2VsbC5fX2NvbFNwYW4gLSAvLyBQb3NzaWJsZSBvdmVyZmxvdyByaWdodCB0b29cbiAgICAgICAgICBNYXRoLm1pbihzZWxlY3RlZENvbHVtbkNvdW50LCBjZWxsLl9fY29sU3BhbiAtIG92ZXJmbG93TGVmdCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNlbGxTdGFydENvbHVtbiArIGNlbGwuX19jb2xTcGFuIC0gMSA+IGVuZENvbHVtbikge1xuICAgICAgICBpZiAoY29sdW1uID09PSBlbmRDb2x1bW4pIHtcbiAgICAgICAgICAvLyBPdmVyZmxvd2luZyByaWdodFxuICAgICAgICAgIGNvbnN0IGluU2VsZWN0ZWRBcmVhID0gZW5kQ29sdW1uIC0gY2VsbFN0YXJ0Q29sdW1uICsgMTtcbiAgICAgICAgICBjZWxsLnNldENvbFNwYW4oY2VsbC5fX2NvbFNwYW4gLSBpblNlbGVjdGVkQXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZm9jdXNSb3dNYXAgPSBncmlkTWFwW2ZvY3VzU3RhcnRSb3ddO1xuICBjb25zdCBuZXh0Q29sdW1uID0gZm9jdXNSb3dNYXBbZm9jdXNTdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW5dO1xuXG4gIGlmIChuZXh0Q29sdW1uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IG5leHRDb2x1bW47XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJldmlvdXNSb3cgPSBmb2N1c1Jvd01hcFtmb2N1c1N0YXJ0Q29sdW1uIC0gMV07XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFxuICAgIH0gPSBwcmV2aW91c1JvdztcbiAgICAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKSB7XG4gIGNvbnN0IGZpcnN0RGVzY2VuZGFudCA9IGNlbGwuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG5cbiAgaWYgKCEoZmlyc3REZXNjZW5kYW50ICE9PSBudWxsKSkge1xuICAgIHRocm93IEVycm9yKGBVbmV4cGVjdGVkIGVtcHR5IGNlbGxgKTtcbiAgfVxuXG4gIGZpcnN0RGVzY2VuZGFudC5nZXRQYXJlbnRPclRocm93KCkuc2VsZWN0U3RhcnQoKTtcbn1cblxuZnVuY3Rpb24gJGluc2VydEZpcnN0KHBhcmVudCwgbm9kZSkge1xuICBjb25zdCBmaXJzdENoaWxkID0gcGFyZW50LmdldEZpcnN0Q2hpbGQoKTtcblxuICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCkge1xuICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudC5hcHBlbmQobm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gJHVubWVyZ2VDZWxsKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIShsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBHcmlkU2VsZWN0aW9uYCk7XG4gIH1cblxuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgW2NlbGwsIHJvdywgZ3JpZF0gPSBsZXhpY2FsLkRFUFJFQ0FURURfJGdldE5vZGVUcmlwbGV0KGFuY2hvcik7XG4gIGNvbnN0IGNvbFNwYW4gPSBjZWxsLl9fY29sU3BhbjtcbiAgY29uc3Qgcm93U3BhbiA9IGNlbGwuX19yb3dTcGFuO1xuXG4gIGlmIChjb2xTcGFuID4gMSkge1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY29sU3BhbjsgaSsrKSB7XG4gICAgICBjZWxsLmluc2VydEFmdGVyKCRjcmVhdGVUYWJsZUNlbGxOb2RlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVMpKTtcbiAgICB9XG5cbiAgICBjZWxsLnNldENvbFNwYW4oMSk7XG4gIH1cblxuICBpZiAocm93U3BhbiA+IDEpIHtcbiAgICBjb25zdCBbbWFwLCBjZWxsTWFwXSA9IGxleGljYWwuREVQUkVDQVRFRF8kY29tcHV0ZUdyaWRNYXAoZ3JpZCwgY2VsbCwgY2VsbCk7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRDb2x1bW4sXG4gICAgICBzdGFydFJvd1xuICAgIH0gPSBjZWxsTWFwO1xuICAgIGxldCBjdXJyZW50Um93Tm9kZTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcm93U3BhbjsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50Um93ID0gc3RhcnRSb3cgKyBpO1xuICAgICAgY29uc3QgY3VycmVudFJvd01hcCA9IG1hcFtjdXJyZW50Um93XTtcbiAgICAgIGN1cnJlbnRSb3dOb2RlID0gcm93LmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICAgIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlKGN1cnJlbnRSb3dOb2RlKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgcm93IG5leHQgc2libGluZyB0byBiZSBhIHJvd2ApO1xuICAgICAgfVxuXG4gICAgICBsZXQgaW5zZXJ0QWZ0ZXJDZWxsID0gbnVsbDtcblxuICAgICAgZm9yIChsZXQgY29sdW1uID0gMDsgY29sdW1uIDwgc3RhcnRDb2x1bW47IGNvbHVtbisrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsTWFwID0gY3VycmVudFJvd01hcFtjb2x1bW5dO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGN1cnJlbnRDZWxsTWFwLmNlbGw7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRDZWxsTWFwLnN0YXJ0Um93ID09PSBjdXJyZW50Um93KSB7XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsID0gY3VycmVudENlbGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudENlbGwuX19jb2xTcGFuID4gMSkge1xuICAgICAgICAgIGNvbHVtbiArPSBjdXJyZW50Q2VsbC5fX2NvbFNwYW4gLSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnNlcnRBZnRlckNlbGwgPT09IG51bGwpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xTcGFuOyBqKyspIHtcbiAgICAgICAgICAkaW5zZXJ0Rmlyc3QoY3VycmVudFJvd05vZGUsICRjcmVhdGVUYWJsZUNlbGxOb2RlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVMpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xTcGFuOyBqKyspIHtcbiAgICAgICAgICBpbnNlcnRBZnRlckNlbGwuaW5zZXJ0QWZ0ZXIoJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2VsbC5zZXRSb3dTcGFuKDEpO1xuICB9XG59XG5cbi8qKiBAbW9kdWxlIEBsZXhpY2FsL3RhYmxlICovXG5jb25zdCBJTlNFUlRfVEFCTEVfQ09NTUFORCA9IGxleGljYWwuY3JlYXRlQ29tbWFuZCgnSU5TRVJUX1RBQkxFX0NPTU1BTkQnKTtcblxuZXhwb3J0cy4kY3JlYXRlVGFibGVDZWxsTm9kZSA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlO1xuZXhwb3J0cy4kY3JlYXRlVGFibGVOb2RlID0gJGNyZWF0ZVRhYmxlTm9kZTtcbmV4cG9ydHMuJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zID0gJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zO1xuZXhwb3J0cy4kY3JlYXRlVGFibGVSb3dOb2RlID0gJGNyZWF0ZVRhYmxlUm93Tm9kZTtcbmV4cG9ydHMuJGRlbGV0ZVRhYmxlQ29sdW1uID0gJGRlbGV0ZVRhYmxlQ29sdW1uO1xuZXhwb3J0cy4kZGVsZXRlVGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTCA9ICRkZWxldGVUYWJsZUNvbHVtbl9fRVhQRVJJTUVOVEFMO1xuZXhwb3J0cy4kZGVsZXRlVGFibGVSb3dfX0VYUEVSSU1FTlRBTCA9ICRkZWxldGVUYWJsZVJvd19fRVhQRVJJTUVOVEFMO1xuZXhwb3J0cy4kZ2V0RWxlbWVudEdyaWRGb3JUYWJsZU5vZGUgPSAkZ2V0RWxlbWVudEdyaWRGb3JUYWJsZU5vZGU7XG5leHBvcnRzLiRnZXRUYWJsZUNlbGxOb2RlRnJvbUxleGljYWxOb2RlID0gJGdldFRhYmxlQ2VsbE5vZGVGcm9tTGV4aWNhbE5vZGU7XG5leHBvcnRzLiRnZXRUYWJsZUNvbHVtbkluZGV4RnJvbVRhYmxlQ2VsbE5vZGUgPSAkZ2V0VGFibGVDb2x1bW5JbmRleEZyb21UYWJsZUNlbGxOb2RlO1xuZXhwb3J0cy4kZ2V0VGFibGVOb2RlRnJvbUxleGljYWxOb2RlT3JUaHJvdyA9ICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93O1xuZXhwb3J0cy4kZ2V0VGFibGVSb3dJbmRleEZyb21UYWJsZUNlbGxOb2RlID0gJGdldFRhYmxlUm93SW5kZXhGcm9tVGFibGVDZWxsTm9kZTtcbmV4cG9ydHMuJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdyA9ICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3c7XG5leHBvcnRzLiRpbnNlcnRUYWJsZUNvbHVtbiA9ICRpbnNlcnRUYWJsZUNvbHVtbjtcbmV4cG9ydHMuJGluc2VydFRhYmxlQ29sdW1uX19FWFBFUklNRU5UQUwgPSAkaW5zZXJ0VGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTDtcbmV4cG9ydHMuJGluc2VydFRhYmxlUm93ID0gJGluc2VydFRhYmxlUm93O1xuZXhwb3J0cy4kaW5zZXJ0VGFibGVSb3dfX0VYUEVSSU1FTlRBTCA9ICRpbnNlcnRUYWJsZVJvd19fRVhQRVJJTUVOVEFMO1xuZXhwb3J0cy4kaXNUYWJsZUNlbGxOb2RlID0gJGlzVGFibGVDZWxsTm9kZTtcbmV4cG9ydHMuJGlzVGFibGVOb2RlID0gJGlzVGFibGVOb2RlO1xuZXhwb3J0cy4kaXNUYWJsZVJvd05vZGUgPSAkaXNUYWJsZVJvd05vZGU7XG5leHBvcnRzLiRyZW1vdmVUYWJsZVJvd0F0SW5kZXggPSAkcmVtb3ZlVGFibGVSb3dBdEluZGV4O1xuZXhwb3J0cy4kdW5tZXJnZUNlbGwgPSAkdW5tZXJnZUNlbGw7XG5leHBvcnRzLklOU0VSVF9UQUJMRV9DT01NQU5EID0gSU5TRVJUX1RBQkxFX0NPTU1BTkQ7XG5leHBvcnRzLlRhYmxlQ2VsbEhlYWRlclN0YXRlcyA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcztcbmV4cG9ydHMuVGFibGVDZWxsTm9kZSA9IFRhYmxlQ2VsbE5vZGU7XG5leHBvcnRzLlRhYmxlTm9kZSA9IFRhYmxlTm9kZTtcbmV4cG9ydHMuVGFibGVSb3dOb2RlID0gVGFibGVSb3dOb2RlO1xuZXhwb3J0cy5UYWJsZVNlbGVjdGlvbiA9IFRhYmxlU2VsZWN0aW9uO1xuZXhwb3J0cy5hcHBseVRhYmxlSGFuZGxlcnMgPSBhcHBseVRhYmxlSGFuZGxlcnM7XG5leHBvcnRzLmdldENlbGxGcm9tVGFyZ2V0ID0gZ2V0Q2VsbEZyb21UYXJnZXQ7XG5leHBvcnRzLmdldFRhYmxlU2VsZWN0aW9uRnJvbVRhYmxlRWxlbWVudCA9IGdldFRhYmxlU2VsZWN0aW9uRnJvbVRhYmxlRWxlbWVudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/table/LexicalTable.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/table/LexicalTable.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lexical/table/LexicalTable.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalTable =  true ? __webpack_require__(/*! ./LexicalTable.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/table/LexicalTable.dev.js\") : 0\nmodule.exports = LexicalTable;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90YWJsZS9MZXhpY2FsVGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWixxQkFBcUIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLG9HQUF1QixJQUFJLENBQWlDO0FBQ2xJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90YWJsZS9MZXhpY2FsVGFibGUuanM/NzY5MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbFRhYmxlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxUYWJsZS5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbFRhYmxlLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsVGFibGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/table/LexicalTable.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/text/LexicalText.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/text/LexicalText.dev.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/text */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n\n  mainLoop: while (node !== null) {\n    if (lexical.$isElementNode(node)) {\n      const child = node.getFirstChild();\n\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if (lexical.$isTextNode(node)) {\n      const characters = node.getTextContentSize();\n\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n\n      currentCharacters += characters;\n    }\n\n    const sibling = node.getNextSibling();\n\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n\n    let parent = node.getParent();\n\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n\n      parent = parent.getParent();\n    }\n\n    break;\n  }\n\n  return null;\n}\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\n\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n\n  let text = $rootTextContent();\n\n  if (trim) {\n    text = text.trim();\n  }\n\n  return text === '';\n}\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\n\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\n\nfunction $rootTextContent() {\n  const root = lexical.$getRoot();\n  return root.getTextContent();\n}\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\n\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n\n  const root = lexical.$getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n\n  if (childrenLength > 1) {\n    return false;\n  }\n\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n\n    if (lexical.$isDecoratorNode(topBlock)) {\n      return false;\n    }\n\n    if (lexical.$isElementNode(topBlock)) {\n      if (!lexical.$isParagraphNode(topBlock)) {\n        return false;\n      }\n\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n\n        if (!lexical.$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\n\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Returns a touple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n\n  const replaceWithSimpleText = node => {\n    const textNode = lexical.$createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n\n  const textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n\n    const prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n\n    if (lexical.$isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    } // eslint-disable-next-line no-constant-condition\n\n\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n\n        if (lexical.$isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      } else {\n        const nextMatch = getMatch(nextText);\n\n        if (nextMatch !== null && nextMatch.start === 0) {\n          return;\n        }\n      }\n\n      if (match === null) {\n        return;\n      }\n\n      if (match.start === 0 && lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        continue;\n      }\n\n      let nodeToReplace;\n\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);\n      }\n\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n\n      if (currentNode == null) {\n        return;\n      }\n    }\n  };\n\n  const reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n\n    if (match === null || match.start !== 0) {\n      replaceWithSimpleText(node);\n      return;\n    }\n\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n\n    const prevSibling = node.getPreviousSibling();\n\n    if (lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      replaceWithSimpleText(prevSibling);\n      replaceWithSimpleText(node);\n    }\n\n    const nextSibling = node.getNextSibling();\n\n    if (lexical.$isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      replaceWithSimpleText(nextSibling); // This may have already been converted in the previous block\n\n      if (isTargetNode(node)) {\n        replaceWithSimpleText(node);\n      }\n    }\n  };\n\n  const removePlainTextTransform = editor.registerNodeTransform(lexical.TextNode, textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexports.$canShowPlaceholder = $canShowPlaceholder;\nexports.$canShowPlaceholderCurry = $canShowPlaceholderCurry;\nexports.$findTextIntersectionFromCharacters = $findTextIntersectionFromCharacters;\nexports.$isRootTextContentEmpty = $isRootTextContentEmpty;\nexports.$isRootTextContentEmptyCurry = $isRootTextContentEmptyCurry;\nexports.$rootTextContent = $rootTextContent;\nexports.registerLexicalTextEntity = registerLexicalTextEntity;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90ZXh0L0xleGljYWxUZXh0LmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsc0VBQVM7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsNEJBQTRCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0IsZ0NBQWdDO0FBQ2hDLDJDQUEyQztBQUMzQywrQkFBK0I7QUFDL0Isb0NBQW9DO0FBQ3BDLHdCQUF3QjtBQUN4QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3RleHQvTGV4aWNhbFRleHQuZGV2LmpzPzJmZjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xuXG4vKiogQG1vZHVsZSBAbGV4aWNhbC90ZXh0ICovXG5cbi8qKlxuICogRmluZHMgYSBUZXh0Tm9kZSB3aXRoIGEgc2l6ZSBsYXJnZXIgdGhhbiB0YXJnZXRDaGFyYWN0ZXJzIGFuZCByZXR1cm5zXG4gKiB0aGUgbm9kZSBhbG9uZyB3aXRoIHRoZSByZW1haW5pbmcgbGVuZ3RoIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtIHJvb3QgLSBUaGUgUm9vdE5vZGUuXG4gKiBAcGFyYW0gdGFyZ2V0Q2hhcmFjdGVycyAtIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB3aG9zZSBUZXh0Tm9kZSBtdXN0IGJlIGxhcmdlciB0aGFuLlxuICogQHJldHVybnMgVGhlIFRleHROb2RlIGFuZCB0aGUgaW50ZXJzZWN0aW9ucyBvZmZzZXQsIG9yIG51bGwgaWYgbm8gVGV4dE5vZGUgaXMgZm91bmQuXG4gKi9cbmZ1bmN0aW9uICRmaW5kVGV4dEludGVyc2VjdGlvbkZyb21DaGFyYWN0ZXJzKHJvb3QsIHRhcmdldENoYXJhY3RlcnMpIHtcbiAgbGV0IG5vZGUgPSByb290LmdldEZpcnN0Q2hpbGQoKTtcbiAgbGV0IGN1cnJlbnRDaGFyYWN0ZXJzID0gMDtcblxuICBtYWluTG9vcDogd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcblxuICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICBjb25zdCBjaGFyYWN0ZXJzID0gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcblxuICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXJzICsgY2hhcmFjdGVycyA+IHRhcmdldENoYXJhY3RlcnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIG9mZnNldDogdGFyZ2V0Q2hhcmFjdGVycyAtIGN1cnJlbnRDaGFyYWN0ZXJzXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRDaGFyYWN0ZXJzICs9IGNoYXJhY3RlcnM7XG4gICAgfVxuXG4gICAgY29uc3Qgc2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBub2RlID0gc2libGluZztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuXG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyZW50U2libGluZyA9IHBhcmVudC5nZXROZXh0U2libGluZygpO1xuXG4gICAgICBpZiAocGFyZW50U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gcGFyZW50U2libGluZztcbiAgICAgICAgY29udGludWUgbWFpbkxvb3A7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICB9XG5cbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSByb290IGhhcyBhbnkgdGV4dCBjb250ZW50IGFuZCBjYW4gdHJpbSBhbnkgd2hpdGVzcGFjZSBpZiBpdCBkb2VzLlxuICogQHBhcmFtIGlzRWRpdG9yQ29tcG9zaW5nIC0gSXMgdGhlIGVkaXRvciBpbiBjb21wb3NpdGlvbiBtb2RlIGR1ZSB0byBhbiBhY3RpdmUgSW5wdXQgTWV0aG9kIEVkaXRvcj9cbiAqIEBwYXJhbSB0cmltIC0gU2hvdWxkIHRoZSByb290IHRleHQgaGF2ZSBpdHMgd2hpdGVzcGFjZWQgdHJpbW1lZD8gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGV4dCBjb250ZW50IGlzIGVtcHR5LCBmYWxzZSBpZiB0aGVyZSBpcyB0ZXh0IG9yIGlzRWRpdG9yQ29tcG9zaW5nIGlzIHRydWUuXG4gKi9cblxuZnVuY3Rpb24gJGlzUm9vdFRleHRDb250ZW50RW1wdHkoaXNFZGl0b3JDb21wb3NpbmcsIHRyaW0gPSB0cnVlKSB7XG4gIGlmIChpc0VkaXRvckNvbXBvc2luZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxldCB0ZXh0ID0gJHJvb3RUZXh0Q29udGVudCgpO1xuXG4gIGlmICh0cmltKSB7XG4gICAgdGV4dCA9IHRleHQudHJpbSgpO1xuICB9XG5cbiAgcmV0dXJuIHRleHQgPT09ICcnO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyB7QGxpbmsgJGlzUm9vdFRleHRDb250ZW50RW1wdHl9XG4gKiBAcGFyYW0gaXNFZGl0b3JDb21wb3NpbmcgLSBJcyB0aGUgZWRpdG9yIGluIGNvbXBvc2l0aW9uIG1vZGUgZHVlIHRvIGFuIGFjdGl2ZSBJbnB1dCBNZXRob2QgRWRpdG9yP1xuICogQHBhcmFtIHRyaW0gLSBTaG91bGQgdGhlIHJvb3QgdGV4dCBoYXZlIGl0cyB3aGl0ZXNwYWNlZCB0cmltbWVkPyBEZWZhdWx0cyB0byB0cnVlLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5IGJhc2VkIG9uIGFyZ3VtZW50cy5cbiAqL1xuXG5mdW5jdGlvbiAkaXNSb290VGV4dENvbnRlbnRFbXB0eUN1cnJ5KGlzRWRpdG9yQ29tcG9zaW5nLCB0cmltKSB7XG4gIHJldHVybiAoKSA9PiAkaXNSb290VGV4dENvbnRlbnRFbXB0eShpc0VkaXRvckNvbXBvc2luZywgdHJpbSk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHJvb3QncyB0ZXh0IGNvbnRlbnQuXG4gKiBAcmV0dXJucyBUaGUgcm9vdCdzIHRleHQgY29udGVudC5cbiAqL1xuXG5mdW5jdGlvbiAkcm9vdFRleHRDb250ZW50KCkge1xuICBjb25zdCByb290ID0gbGV4aWNhbC4kZ2V0Um9vdCgpO1xuICByZXR1cm4gcm9vdC5nZXRUZXh0Q29udGVudCgpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dCBzaG91bGQgc2hvdyB0aGUgcGxhY2Vob2xkZXIuIElmIGFueXRoaW5nIGlzIGluXG4gKiBpbiB0aGUgcm9vdCB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIG5vdCBiZSBzaG93bi5cbiAqIEBwYXJhbSBpc0NvbXBvc2luZyAtIElzIHRoZSBlZGl0b3IgaW4gY29tcG9zaXRpb24gbW9kZSBkdWUgdG8gYW4gYWN0aXZlIElucHV0IE1ldGhvZCBFZGl0b3I/XG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBpbnB1dCBzaG91bGQgc2hvdyB0aGUgcGxhY2Vob2xkZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiAkY2FuU2hvd1BsYWNlaG9sZGVyKGlzQ29tcG9zaW5nKSB7XG4gIGlmICghJGlzUm9vdFRleHRDb250ZW50RW1wdHkoaXNDb21wb3NpbmcsIGZhbHNlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHJvb3QgPSBsZXhpY2FsLiRnZXRSb290KCk7XG4gIGNvbnN0IGNoaWxkcmVuID0gcm9vdC5nZXRDaGlsZHJlbigpO1xuICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9wQmxvY2sgPSBjaGlsZHJlbltpXTtcblxuICAgIGlmIChsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUodG9wQmxvY2spKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUodG9wQmxvY2spKSB7XG4gICAgICBpZiAoIWxleGljYWwuJGlzUGFyYWdyYXBoTm9kZSh0b3BCbG9jaykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9wQmxvY2suX19pbmRlbnQgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0b3BCbG9ja0NoaWxkcmVuID0gdG9wQmxvY2suZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIGNvbnN0IHRvcEJsb2NrQ2hpbGRyZW5MZW5ndGggPSB0b3BCbG9ja0NoaWxkcmVuLmxlbmd0aDtcblxuICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0b3BCbG9ja0NoaWxkcmVuTGVuZ3RoOyBzKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0b3BCbG9ja0NoaWxkcmVuW2ldO1xuXG4gICAgICAgIGlmICghbGV4aWNhbC4kaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMge0BsaW5rICRjYW5TaG93UGxhY2Vob2xkZXJ9XG4gKiBAcGFyYW0gaXNFZGl0b3JDb21wb3NpbmcgLSBJcyB0aGUgZWRpdG9yIGluIGNvbXBvc2l0aW9uIG1vZGUgZHVlIHRvIGFuIGFjdGl2ZSBJbnB1dCBNZXRob2QgRWRpdG9yP1xuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzICRjYW5TaG93UGxhY2Vob2xkZXIgd2l0aCBhcmd1bWVudHMuXG4gKi9cblxuZnVuY3Rpb24gJGNhblNob3dQbGFjZWhvbGRlckN1cnJ5KGlzRWRpdG9yQ29tcG9zaW5nKSB7XG4gIHJldHVybiAoKSA9PiAkY2FuU2hvd1BsYWNlaG9sZGVyKGlzRWRpdG9yQ29tcG9zaW5nKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdG91cGxlIHRoYXQgY2FuIGJlIHJlc3RlZCAoLi4uKSBpbnRvIG1lcmdlUmVnaXN0ZXIgdG8gY2xlYW4gdXBcbiAqIG5vZGUgdHJhbnNmb3JtcyBsaXN0ZW5lcnMgdGhhdCB0cmFuc2Zvcm1zIHRleHQgaW50byBhbm90aGVyIG5vZGUsIGVnLiBhIEhhc2h0YWdOb2RlLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoXG4gICAgICAuLi5yZWdpc3RlckxleGljYWxUZXh0RW50aXR5KGVkaXRvciwgZ2V0TWF0Y2gsIHRhcmdldE5vZGUsIGNyZWF0ZU5vZGUpLFxuICAgICk7XG4gIH0sIFtjcmVhdGVOb2RlLCBlZGl0b3IsIGdldE1hdGNoLCB0YXJnZXROb2RlXSk7XG4gKiBgYGBcbiAqIFdoZXJlIHRhcmdldE5vZGUgaXMgdGhlIHR5cGUgb2Ygbm9kZSBjb250YWluaW5nIHRoZSB0ZXh0IHlvdSB3YW50IHRvIHRyYW5zZm9ybSAobGlrZSBhIHRleHQgaW5wdXQpLFxuICogdGhlbiBnZXRNYXRjaCB1c2VzIGEgcmVnZXggdG8gZmluZCBhIG1hdGNoaW5nIHRleHQgYW5kIGNyZWF0ZXMgdGhlIHByb3BlciBub2RlIHRvIGluY2x1ZGUgdGhlIG1hdGNoaW5nIHRleHQuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICogQHBhcmFtIGdldE1hdGNoIC0gRmluZHMgYSBtYXRjaGluZyBzdHJpbmcgdGhhdCBzYXRpc2ZpZXMgYSByZWdleCBleHByZXNzaW9uLlxuICogQHBhcmFtIHRhcmdldE5vZGUgLSBUaGUgbm9kZSB0eXBlIHRoYXQgY29udGFpbnMgdGV4dCB0byBtYXRjaCB3aXRoLiBlZy4gSGFzaHRhZ05vZGVcbiAqIEBwYXJhbSBjcmVhdGVOb2RlIC0gQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgbm9kZSB0byBjb250YWluIHRoZSBtYXRjaGVkIHRleHQuIGVnIGNyZWF0ZUhhc2h0YWdOb2RlXG4gKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBwbGFpbiB0ZXh0IGFuZCByZXZlcnNlIG5vZGUgdHJhbnNmb3JtIGxpc3RlbmVycy5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eShlZGl0b3IsIGdldE1hdGNoLCB0YXJnZXROb2RlLCBjcmVhdGVOb2RlKSB7XG4gIGNvbnN0IGlzVGFyZ2V0Tm9kZSA9IG5vZGUgPT4ge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgdGFyZ2V0Tm9kZTtcbiAgfTtcblxuICBjb25zdCByZXBsYWNlV2l0aFNpbXBsZVRleHQgPSBub2RlID0+IHtcbiAgICBjb25zdCB0ZXh0Tm9kZSA9IGxleGljYWwuJGNyZWF0ZVRleHROb2RlKG5vZGUuZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgdGV4dE5vZGUuc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0KCkpO1xuICAgIG5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gIH07XG5cbiAgY29uc3QgZ2V0TW9kZSA9IG5vZGUgPT4ge1xuICAgIHJldHVybiBub2RlLmdldExhdGVzdCgpLl9fbW9kZTtcbiAgfTtcblxuICBjb25zdCB0ZXh0Tm9kZVRyYW5zZm9ybSA9IG5vZGUgPT4ge1xuICAgIGlmICghbm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBsZXQgdGV4dCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuICAgIGxldCBtYXRjaDtcblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgY29uc3QgcHJldmlvdXNUZXh0ID0gcHJldlNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgIGNvbnN0IGNvbWJpbmVkVGV4dCA9IHByZXZpb3VzVGV4dCArIHRleHQ7XG4gICAgICBjb25zdCBwcmV2TWF0Y2ggPSBnZXRNYXRjaChjb21iaW5lZFRleHQpO1xuXG4gICAgICBpZiAoaXNUYXJnZXROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgICBpZiAocHJldk1hdGNoID09PSBudWxsIHx8IGdldE1vZGUocHJldlNpYmxpbmcpICE9PSAwKSB7XG4gICAgICAgICAgcmVwbGFjZVdpdGhTaW1wbGVUZXh0KHByZXZTaWJsaW5nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZGlmZiA9IHByZXZNYXRjaC5lbmQgLSBwcmV2aW91c1RleHQubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjb25jYXRUZXh0ID0gdGV4dC5zbGljZSgwLCBkaWZmKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RleHRDb250ZW50ID0gcHJldmlvdXNUZXh0ICsgY29uY2F0VGV4dDtcbiAgICAgICAgICAgIHByZXZTaWJsaW5nLnNlbGVjdCgpO1xuICAgICAgICAgICAgcHJldlNpYmxpbmcuc2V0VGV4dENvbnRlbnQobmV3VGV4dENvbnRlbnQpO1xuXG4gICAgICAgICAgICBpZiAoZGlmZiA9PT0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1RleHQgPSB0ZXh0LnNsaWNlKGRpZmYpO1xuICAgICAgICAgICAgICBub2RlLnNldFRleHRDb250ZW50KHJlbWFpbmluZ1RleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXZNYXRjaCA9PT0gbnVsbCB8fCBwcmV2TWF0Y2guc3RhcnQgPCBwcmV2aW91c1RleHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cblxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIG1hdGNoID0gZ2V0TWF0Y2godGV4dCk7XG4gICAgICBsZXQgbmV4dFRleHQgPSBtYXRjaCA9PT0gbnVsbCA/ICcnIDogdGV4dC5zbGljZShtYXRjaC5lbmQpO1xuICAgICAgdGV4dCA9IG5leHRUZXh0O1xuXG4gICAgICBpZiAobmV4dFRleHQgPT09ICcnKSB7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gY3VycmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgICAgICBuZXh0VGV4dCA9IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50KCkgKyBuZXh0U2libGluZy5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICAgIGNvbnN0IG5leHRNYXRjaCA9IGdldE1hdGNoKG5leHRUZXh0KTtcblxuICAgICAgICAgIGlmIChuZXh0TWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpc1RhcmdldE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgIHJlcGxhY2VXaXRoU2ltcGxlVGV4dChuZXh0U2libGluZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXh0U2libGluZy5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dE1hdGNoLnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXh0TWF0Y2ggPSBnZXRNYXRjaChuZXh0VGV4dCk7XG5cbiAgICAgICAgaWYgKG5leHRNYXRjaCAhPT0gbnVsbCAmJiBuZXh0TWF0Y2guc3RhcnQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoLnN0YXJ0ID09PSAwICYmIGxleGljYWwuJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpICYmIHByZXZTaWJsaW5nLmlzVGV4dEVudGl0eSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgbm9kZVRvUmVwbGFjZTtcblxuICAgICAgaWYgKG1hdGNoLnN0YXJ0ID09PSAwKSB7XG4gICAgICAgIFtub2RlVG9SZXBsYWNlLCBjdXJyZW50Tm9kZV0gPSBjdXJyZW50Tm9kZS5zcGxpdFRleHQobWF0Y2guZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFssIG5vZGVUb1JlcGxhY2UsIGN1cnJlbnROb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVwbGFjZW1lbnROb2RlID0gY3JlYXRlTm9kZShub2RlVG9SZXBsYWNlKTtcbiAgICAgIHJlcGxhY2VtZW50Tm9kZS5zZXRGb3JtYXQobm9kZVRvUmVwbGFjZS5nZXRGb3JtYXQoKSk7XG4gICAgICBub2RlVG9SZXBsYWNlLnJlcGxhY2UocmVwbGFjZW1lbnROb2RlKTtcblxuICAgICAgaWYgKGN1cnJlbnROb2RlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCByZXZlcnNlTm9kZVRyYW5zZm9ybSA9IG5vZGUgPT4ge1xuICAgIGNvbnN0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgY29uc3QgbWF0Y2ggPSBnZXRNYXRjaCh0ZXh0KTtcblxuICAgIGlmIChtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaC5zdGFydCAhPT0gMCkge1xuICAgICAgcmVwbGFjZVdpdGhTaW1wbGVUZXh0KG5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IG1hdGNoLmVuZCkge1xuICAgICAgLy8gVGhpcyB3aWxsIHNwbGl0IG91dCB0aGUgcmVzdCBvZiB0aGUgdGV4dCBhcyBzaW1wbGUgdGV4dFxuICAgICAgbm9kZS5zcGxpdFRleHQobWF0Y2guZW5kKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2U2libGluZyA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShwcmV2U2libGluZykgJiYgcHJldlNpYmxpbmcuaXNUZXh0RW50aXR5KCkpIHtcbiAgICAgIHJlcGxhY2VXaXRoU2ltcGxlVGV4dChwcmV2U2libGluZyk7XG4gICAgICByZXBsYWNlV2l0aFNpbXBsZVRleHQobm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShuZXh0U2libGluZykgJiYgbmV4dFNpYmxpbmcuaXNUZXh0RW50aXR5KCkpIHtcbiAgICAgIHJlcGxhY2VXaXRoU2ltcGxlVGV4dChuZXh0U2libGluZyk7IC8vIFRoaXMgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNvbnZlcnRlZCBpbiB0aGUgcHJldmlvdXMgYmxvY2tcblxuICAgICAgaWYgKGlzVGFyZ2V0Tm9kZShub2RlKSkge1xuICAgICAgICByZXBsYWNlV2l0aFNpbXBsZVRleHQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlbW92ZVBsYWluVGV4dFRyYW5zZm9ybSA9IGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0obGV4aWNhbC5UZXh0Tm9kZSwgdGV4dE5vZGVUcmFuc2Zvcm0pO1xuICBjb25zdCByZW1vdmVSZXZlcnNlTm9kZVRyYW5zZm9ybSA9IGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0odGFyZ2V0Tm9kZSwgcmV2ZXJzZU5vZGVUcmFuc2Zvcm0pO1xuICByZXR1cm4gW3JlbW92ZVBsYWluVGV4dFRyYW5zZm9ybSwgcmVtb3ZlUmV2ZXJzZU5vZGVUcmFuc2Zvcm1dO1xufVxuXG5leHBvcnRzLiRjYW5TaG93UGxhY2Vob2xkZXIgPSAkY2FuU2hvd1BsYWNlaG9sZGVyO1xuZXhwb3J0cy4kY2FuU2hvd1BsYWNlaG9sZGVyQ3VycnkgPSAkY2FuU2hvd1BsYWNlaG9sZGVyQ3Vycnk7XG5leHBvcnRzLiRmaW5kVGV4dEludGVyc2VjdGlvbkZyb21DaGFyYWN0ZXJzID0gJGZpbmRUZXh0SW50ZXJzZWN0aW9uRnJvbUNoYXJhY3RlcnM7XG5leHBvcnRzLiRpc1Jvb3RUZXh0Q29udGVudEVtcHR5ID0gJGlzUm9vdFRleHRDb250ZW50RW1wdHk7XG5leHBvcnRzLiRpc1Jvb3RUZXh0Q29udGVudEVtcHR5Q3VycnkgPSAkaXNSb290VGV4dENvbnRlbnRFbXB0eUN1cnJ5O1xuZXhwb3J0cy4kcm9vdFRleHRDb250ZW50ID0gJHJvb3RUZXh0Q29udGVudDtcbmV4cG9ydHMucmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eSA9IHJlZ2lzdGVyTGV4aWNhbFRleHRFbnRpdHk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/text/LexicalText.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/text/LexicalText.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/text/LexicalText.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalText =  true ? __webpack_require__(/*! ./LexicalText.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/text/LexicalText.dev.js\") : 0\nmodule.exports = LexicalText;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90ZXh0L0xleGljYWxUZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osb0JBQW9CLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxpR0FBc0IsSUFBSSxDQUFnQztBQUMvSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGV4dC9MZXhpY2FsVGV4dC5qcz80ZjA0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsVGV4dCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsVGV4dC5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbFRleHQucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxUZXh0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/text/LexicalText.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.dev.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.dev.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar selection = __webpack_require__(/*! @lexical/selection */ \"(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/utils */\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      const classesToAdd = className.split(' ').filter(n => n !== '');\n      element.classList.add(...classesToAdd);\n    }\n  });\n}\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\n\nfunction removeClassNamesFromElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\n\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\n\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n\n      if (done) {\n        return resolve(processed);\n      }\n\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n\n        handleNextFile();\n      });\n\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * {depth: number, node: LexicalNode} It will always return at least 1 node (the ending node) so long as it exists\n */\n\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n\n  return nodes;\n}\n\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n\n  return depth;\n}\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\n\n\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return null;\n}\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\n\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n\n  return blockNode;\n}\n\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the compenent it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguements\n * are considered to be the func argument and spread from there.\n * @param func - An array of functions meant to be executed by the returned function.\n * @returns the function which executes all the passed register command functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\n\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n\n    let parentNode = node;\n    let childNode = node;\n\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n\n    return null;\n  };\n\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match; // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\n\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = selection.$cloneWithProperties(node);\n\n    if (lexical.$isTextNode(clone)) {\n      clone.__text = node.__text;\n    }\n\n    nodeMap.set(key, clone);\n  }\n\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n\n  editor._dirtyType = FULL_RECONCILE;\n  const selection$1 = editorState._selection;\n  lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\n}\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\n\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection() || lexical.$getPreviousSelection();\n\n  if (lexical.$isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n\n      if (lexical.$isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n\n      const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = lexical.$getRoot();\n      root.append(node);\n    }\n\n    const paragraphNode = lexical.$createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n\n  return node.getLatest();\n}\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexcial element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexcial element with the previous node appended within (as a child, including its children).\n */\n\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\n\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n/**\n * @param x - The element being testing\n * @returns Returns true if x is an HTML element, false otherwise.\n */\n\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\nexports.$splitNode = lexical.$splitNode;\nexports.$dfs = $dfs;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.isHTMLAnchorElement = isHTMLAnchorElement;\nexports.isHTMLElement = isHTMLElement;\nexports.isMimeType = isMimeType;\nexports.mediaFileReader = mediaFileReader;\nexports.mergeRegister = mergeRegister;\nexports.objectKlassEquals = objectKlassEquals;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC91dGlscy9MZXhpY2FsVXRpbHMuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLHFHQUFvQjtBQUM1QyxjQUFjLG1CQUFPLENBQUMsc0VBQVM7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0NBQWtDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUzs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxrQ0FBa0M7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWiwyQkFBMkI7QUFDM0IsOENBQThDO0FBQzlDLDZCQUE2QjtBQUM3QixnQ0FBZ0M7QUFDaEMsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUIsMkJBQTJCO0FBQzNCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIscUNBQXFDO0FBQ3JDLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmRldi5qcz9lOTMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2VsZWN0aW9uID0gcmVxdWlyZSgnQGxleGljYWwvc2VsZWN0aW9uJyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcblxuLyoqIEBtb2R1bGUgQGxleGljYWwvdXRpbHMgKi9cblxuLyoqXG4gKiBUYWtlcyBhbiBIVE1MIGVsZW1lbnQgYW5kIGFkZHMgdGhlIGNsYXNzTmFtZXMgcGFzc2VkIHdpdGhpbiBhbiBhcnJheSxcbiAqIGlnbm9yaW5nIGFueSBub24tc3RyaW5nIHR5cGVzLiBBIHNwYWNlIGNhbiBiZSB1c2VkIHRvIGFkZCBtdWx0aXBsZSBjbGFzc2VzXG4gKiBlZy4gYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBbJ2VsZW1lbnQtaW5uZXIgYWN0aXZlJywgdHJ1ZSwgbnVsbF0pXG4gKiB3aWxsIGFkZCBib3RoICdlbGVtZW50LWlubmVyJyBhbmQgJ2FjdGl2ZScgYXMgY2xhc3NlcyB0byB0aGF0IGVsZW1lbnQuXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGluIHdoaWNoIHRoZSBjbGFzc2VzIGFyZSBhZGRlZFxuICogQHBhcmFtIGNsYXNzTmFtZXMgLSBBbiBhcnJheSBkZWZpbmluZyB0aGUgY2xhc3MgbmFtZXMgdG8gYWRkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgLi4uY2xhc3NOYW1lcykge1xuICBjbGFzc05hbWVzLmZvckVhY2goY2xhc3NOYW1lID0+IHtcbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGNsYXNzZXNUb0FkZCA9IGNsYXNzTmFtZS5zcGxpdCgnICcpLmZpbHRlcihuID0+IG4gIT09ICcnKTtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzVG9BZGQpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIFRha2VzIGFuIEhUTUwgZWxlbWVudCBhbmQgcmVtb3ZlcyB0aGUgY2xhc3NOYW1lcyBwYXNzZWQgd2l0aGluIGFuIGFycmF5LFxuICogaWdub3JpbmcgYW55IG5vbi1zdHJpbmcgdHlwZXMuIEEgc3BhY2UgY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIG11bHRpcGxlIGNsYXNzZXNcbiAqIGVnLiByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZWxlbWVudCwgWydhY3RpdmUgc21hbGwnLCB0cnVlLCBudWxsXSlcbiAqIHdpbGwgcmVtb3ZlIGJvdGggdGhlICdhY3RpdmUnIGFuZCAnc21hbGwnIGNsYXNzZXMgZnJvbSB0aGF0IGVsZW1lbnQuXG4gKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGluIHdoaWNoIHRoZSBjbGFzc2VzIGFyZSByZW1vdmVkXG4gKiBAcGFyYW0gY2xhc3NOYW1lcyAtIEFuIGFycmF5IGRlZmluaW5nIHRoZSBjbGFzcyBuYW1lcyB0byByZW1vdmUgZnJvbSB0aGUgZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCAuLi5jbGFzc05hbWVzKSB7XG4gIGNsYXNzTmFtZXMuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZS5zcGxpdCgnICcpKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpbGUgdHlwZSBtYXRjaGVzIHRoZSB0eXBlcyBwYXNzZWQgd2l0aGluIHRoZSBhY2NlcHRhYmxlTWltZVR5cGVzIGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBUaGUgdHlwZXMgcGFzc2VkIG11c3QgYmUgc3RyaW5ncyBhbmQgYXJlIENBU0UtU0VOU0lUSVZFLlxuICogZWcuIGlmIGZpbGUgaXMgb2YgdHlwZSAndGV4dCcgYW5kIGFjY2VwdGFibGVNaW1lVHlwZXMgPSBbJ1RFWFQnLCAnSU1BR0UnXSB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gZmFsc2UuXG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBmaWxlIHlvdSB3YW50IHRvIHR5cGUgY2hlY2suXG4gKiBAcGFyYW0gYWNjZXB0YWJsZU1pbWVUeXBlcyAtIEFuIGFycmF5IG9mIHN0cmluZ3Mgb2YgdHlwZXMgd2hpY2ggdGhlIGZpbGUgaXMgY2hlY2tlZCBhZ2FpbnN0LlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZmlsZSBpcyBhbiBhY2NlcHRhYmxlIG1pbWUgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzTWltZVR5cGUoZmlsZSwgYWNjZXB0YWJsZU1pbWVUeXBlcykge1xuICBmb3IgKGNvbnN0IGFjY2VwdGFibGVUeXBlIG9mIGFjY2VwdGFibGVNaW1lVHlwZXMpIHtcbiAgICBpZiAoZmlsZS50eXBlLnN0YXJ0c1dpdGgoYWNjZXB0YWJsZVR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIExleGljYWwgRmlsZSBSZWFkZXIgd2l0aDpcbiAqICAxLiBNSU1FIHR5cGUgc3VwcG9ydFxuICogIDIuIGJhdGNoZWQgcmVzdWx0cyAoSGlzdG9yeVBsdWdpbiBjb21wYXRpYmlsaXR5KVxuICogIDMuIE9yZGVyIGF3YXJlIChyZXNwZWN0cyB0aGUgb3JkZXIgd2hlbiBtdWx0aXBsZSBGaWxlcyBhcmUgcGFzc2VkKVxuICpcbiAqIGNvbnN0IGZpbGVzUmVzdWx0ID0gYXdhaXQgbWVkaWFGaWxlUmVhZGVyKGZpbGVzLCBbJ2ltYWdlLyddKTtcbiAqIGZpbGVzUmVzdWx0LmZvckVhY2goZmlsZSA9PiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKCdJTlNFUlRfSU1BR0UnLCB7XG4gKiAgIHNyYzogZmlsZS5yZXN1bHQsXG4gKiB9KSk7XG4gKi9cblxuZnVuY3Rpb24gbWVkaWFGaWxlUmVhZGVyKGZpbGVzLCBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gIGNvbnN0IGZpbGVzSXRlcmF0b3IgPSBmaWxlc1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcHJvY2Vzc2VkID0gW107XG5cbiAgICBjb25zdCBoYW5kbGVOZXh0RmlsZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZG9uZSxcbiAgICAgICAgdmFsdWU6IGZpbGVcbiAgICAgIH0gPSBmaWxlc0l0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUocHJvY2Vzc2VkKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIGZpbGVSZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZmlsZVJlYWRlci5yZXN1bHQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcHJvY2Vzc2VkLnB1c2goe1xuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlTmV4dEZpbGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNNaW1lVHlwZShmaWxlLCBhY2NlcHRhYmxlTWltZVR5cGVzKSkge1xuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVOZXh0RmlsZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBoYW5kbGVOZXh0RmlsZSgpO1xuICB9KTtcbn1cbi8qKlxuICogXCJEZXB0aC1GaXJzdCBTZWFyY2hcIiBzdGFydHMgYXQgdGhlIHJvb3QvdG9wIG5vZGUgb2YgYSB0cmVlIGFuZCBnb2VzIGFzIGZhciBhcyBpdCBjYW4gZG93biBhIGJyYW5jaCBlbmRcbiAqIGJlZm9yZSBiYWNrdHJhY2tpbmcgYW5kIGZpbmRpbmcgYSBuZXcgcGF0aC4gQ29uc2lkZXIgc29sdmluZyBhIG1hemUgYnkgaHVnZ2luZyBlaXRoZXIgd2FsbCwgbW92aW5nIGRvd24gYVxuICogYnJhbmNoIHVudGlsIHlvdSBoaXQgYSBkZWFkLWVuZCAobGVhZikgYW5kIGJhY2t0cmFja2luZyB0byBmaW5kIHRoZSBuZWFyZXN0IGJyYW5jaGluZyBwYXRoIGFuZCByZXBlYXQuXG4gKiBJdCB3aWxsIHRoZW4gcmV0dXJuIGFsbCB0aGUgbm9kZXMgZm91bmQgaW4gdGhlIHNlYXJjaCBpbiBhbiBhcnJheSBvZiBvYmplY3RzLlxuICogQHBhcmFtIHN0YXJ0aW5nTm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2gsIGlmIG9tbWl0dGVkLCBpdCB3aWxsIHN0YXJ0IGF0IHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0gZW5kaW5nTm9kZSAtIFRoZSBub2RlIHRvIGVuZCB0aGUgc2VhcmNoLCBpZiBvbW1pdHRlZCwgaXQgd2lsbCBmaW5kIGFsbCBkZXNjZW5kYW50cyBvZiB0aGUgc3RhcnRpbmdOb2RlLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygb2JqZWN0cyBvZiBhbGwgdGhlIG5vZGVzIGZvdW5kIGJ5IHRoZSBzZWFyY2gsIGluY2x1ZGluZyB0aGVpciBkZXB0aCBpbnRvIHRoZSB0cmVlLlxuICoge2RlcHRoOiBudW1iZXIsIG5vZGU6IExleGljYWxOb2RlfSBJdCB3aWxsIGFsd2F5cyByZXR1cm4gYXQgbGVhc3QgMSBub2RlICh0aGUgZW5kaW5nIG5vZGUpIHNvIGxvbmcgYXMgaXQgZXhpc3RzXG4gKi9cblxuZnVuY3Rpb24gJGRmcyhzdGFydGluZ05vZGUsIGVuZGluZ05vZGUpIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgY29uc3Qgc3RhcnQgPSAoc3RhcnRpbmdOb2RlIHx8IGxleGljYWwuJGdldFJvb3QoKSkuZ2V0TGF0ZXN0KCk7XG4gIGNvbnN0IGVuZCA9IGVuZGluZ05vZGUgfHwgKGxleGljYWwuJGlzRWxlbWVudE5vZGUoc3RhcnQpID8gc3RhcnQuZ2V0TGFzdERlc2NlbmRhbnQoKSA6IHN0YXJ0KTtcbiAgbGV0IG5vZGUgPSBzdGFydDtcbiAgbGV0IGRlcHRoID0gJGdldERlcHRoKG5vZGUpO1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsICYmICFub2RlLmlzKGVuZCkpIHtcbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGRlcHRoLFxuICAgICAgbm9kZVxuICAgIH0pO1xuXG4gICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5nZXRDaGlsZHJlblNpemUoKSA+IDApIHtcbiAgICAgIG5vZGUgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGRlcHRoKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgaW1tZWRpYXRlIHNpYmxpbmcgb3IgbmVhcmVzdCBwYXJlbnQgc2libGluZ1xuICAgICAgbGV0IHNpYmxpbmcgPSBudWxsO1xuXG4gICAgICB3aGlsZSAoc2libGluZyA9PT0gbnVsbCAmJiBub2RlICE9PSBudWxsKSB7XG4gICAgICAgIHNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICAgICAgaWYgKHNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBzaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGUgIT09IG51bGwgJiYgbm9kZS5pcyhlbmQpKSB7XG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBkZXB0aCxcbiAgICAgIG5vZGVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn1cblxuZnVuY3Rpb24gJGdldERlcHRoKG5vZGUpIHtcbiAgbGV0IGlubmVyTm9kZSA9IG5vZGU7XG4gIGxldCBkZXB0aCA9IDA7XG5cbiAgd2hpbGUgKChpbm5lck5vZGUgPSBpbm5lck5vZGUuZ2V0UGFyZW50KCkpICE9PSBudWxsKSB7XG4gICAgZGVwdGgrKztcbiAgfVxuXG4gIHJldHVybiBkZXB0aDtcbn1cbi8qKlxuICogVGFrZXMgYSBub2RlIGFuZCB0cmF2ZXJzZXMgdXAgaXRzIGFuY2VzdG9ycyAodG93YXJkIHRoZSByb290IG5vZGUpXG4gKiBpbiBvcmRlciB0byBmaW5kIGEgc3BlY2lmaWMgdHlwZSBvZiBub2RlLlxuICogQHBhcmFtIG5vZGUgLSB0aGUgbm9kZSB0byBiZWdpbiBzZWFyY2hpbmcuXG4gKiBAcGFyYW0ga2xhc3MgLSBhbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBvZiBub2RlIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgdGhlIG5vZGUgb2YgdHlwZSBrbGFzcyB0aGF0IHdhcyBwYXNzZWQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAqL1xuXG5cbmZ1bmN0aW9uICRnZXROZWFyZXN0Tm9kZU9mVHlwZShub2RlLCBrbGFzcykge1xuICBsZXQgcGFyZW50ID0gbm9kZTtcblxuICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2Yga2xhc3MpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQgbm9kZSBvZiB0aGUgbmVhcmVzdCBhbmNlc3Rvciwgb3RoZXJ3aXNlIHRocm93cyBhbiBlcnJvci5cbiAqIEBwYXJhbSBzdGFydE5vZGUgLSBUaGUgc3RhcnRpbmcgbm9kZSBvZiB0aGUgc2VhcmNoXG4gKiBAcmV0dXJucyBUaGUgYW5jZXN0b3Igbm9kZSBmb3VuZFxuICovXG5cbmZ1bmN0aW9uICRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93KHN0YXJ0Tm9kZSkge1xuICBjb25zdCBibG9ja05vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0Tm9kZSwgbm9kZSA9PiBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuXG4gIGlmICghbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShibG9ja05vZGUpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIG5vZGUgJHtzdGFydE5vZGUuX19rZXl9IHRvIGhhdmUgY2xvc2VzdCBibG9jayBlbGVtZW50IG5vZGUuYCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJsb2NrTm9kZTtcbn1cblxuLyoqXG4gKiBTdGFydHMgd2l0aCBhIG5vZGUgYW5kIG1vdmVzIHVwIHRoZSB0cmVlICh0b3dhcmQgdGhlIHJvb3Qgbm9kZSkgdG8gZmluZCBhIG1hdGNoaW5nIG5vZGUgYmFzZWQgb25cbiAqIHRoZSBzZWFyY2ggcGFyYW1ldGVycyBvZiB0aGUgZmluZEZuLiAoQ29uc2lkZXIgSmF2YVNjcmlwdHMnIC5maW5kKCkgZnVuY3Rpb24gd2hlcmUgYSB0ZXN0aW5nIGZ1bmN0aW9uIG11c3QgYmVcbiAqIHBhc3NlZCBhcyBhbiBhcmd1bWVudC4gZWcuIGlmKCAobm9kZSkgPT4gbm9kZS5fX3R5cGUgPT09ICdkaXYnKSApIHJldHVybiB0cnVlOyBvdGhlcndpc2UgcmV0dXJuIGZhbHNlXG4gKiBAcGFyYW0gc3RhcnRpbmdOb2RlIC0gVGhlIG5vZGUgd2hlcmUgdGhlIHNlYXJjaCBzdGFydHMuXG4gKiBAcGFyYW0gZmluZEZuIC0gQSB0ZXN0aW5nIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IG5vZGUgc2F0aXNmaWVzIHRoZSB0ZXN0aW5nIHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJucyBBIHBhcmVudCBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgZmluZEZuIHBhcmFtZXRlcnMsIG9yIG51bGwgaWYgb25lIHdhc24ndCBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gJGZpbmRNYXRjaGluZ1BhcmVudChzdGFydGluZ05vZGUsIGZpbmRGbikge1xuICBsZXQgY3VyciA9IHN0YXJ0aW5nTm9kZTtcblxuICB3aGlsZSAoY3VyciAhPT0gbGV4aWNhbC4kZ2V0Um9vdCgpICYmIGN1cnIgIT0gbnVsbCkge1xuICAgIGlmIChmaW5kRm4oY3VycikpIHtcbiAgICAgIHJldHVybiBjdXJyO1xuICAgIH1cblxuICAgIGN1cnIgPSBjdXJyLmdldFBhcmVudCgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBleGVjdXRlIGFsbCBmdW5jdGlvbnMgcGFzc2VkIHdoZW4gY2FsbGVkLiBJdCBpcyBnZW5lcmFsbHkgdXNlZFxuICogdG8gcmVnaXN0ZXIgbXVsdGlwbGUgbGV4aWNhbCBsaXN0ZW5lcnMgYW5kIHRoZW4gdGVhciB0aGVtIGRvd24gd2l0aCBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsLCBzdWNoXG4gKiBhcyBSZWFjdCdzIHVzZUVmZmVjdCBob29rLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiB1c2VFZmZlY3QoKCkgPT4ge1xuICogICByZXR1cm4gbWVyZ2VSZWdpc3RlcihcbiAqICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKC4uLnJlZ2lzdGVyQ29tbWFuZDEgbG9naWMpLFxuICogICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoLi4ucmVnaXN0ZXJDb21tYW5kMiBsb2dpYyksXG4gKiAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZCguLi5yZWdpc3RlckNvbW1hbmQzIGxvZ2ljKVxuICogICApXG4gKiB9LCBbZWRpdG9yXSlcbiAqIGBgYFxuICogSW4gdGhpcyBjYXNlLCB1c2VFZmZlY3QgaXMgcmV0dXJuaW5nIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBtZXJnZVJlZ2lzdGVyIGFzIGEgY2xlYW51cFxuICogZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZWl0aGVyIHRoZSB1c2VFZmZlY3QgcnVucyBhZ2FpbiAoZHVlIHRvIG9uZSBvZiBpdHMgZGVwZW5kZW5jaWVzXG4gKiB1cGRhdGluZykgb3IgdGhlIGNvbXBlbmVudCBpdCByZXNpZGVzIGluIHVubW91bnRzLlxuICogTm90ZSB0aGUgZnVuY3Rpb25zIGRvbid0IG5lY2Nlc2FyaWx5IG5lZWQgdG8gYmUgaW4gYW4gYXJyYXkgYXMgYWxsIGFyZ3VlbWVudHNcbiAqIGFyZSBjb25zaWRlcmVkIHRvIGJlIHRoZSBmdW5jIGFyZ3VtZW50IGFuZCBzcHJlYWQgZnJvbSB0aGVyZS5cbiAqIEBwYXJhbSBmdW5jIC0gQW4gYXJyYXkgb2YgZnVuY3Rpb25zIG1lYW50IHRvIGJlIGV4ZWN1dGVkIGJ5IHRoZSByZXR1cm5lZCBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHRoZSBmdW5jdGlvbiB3aGljaCBleGVjdXRlcyBhbGwgdGhlIHBhc3NlZCByZWdpc3RlciBjb21tYW5kIGZ1bmN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VSZWdpc3RlciguLi5mdW5jKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZnVuYy5mb3JFYWNoKGYgPT4gZigpKTtcbiAgfTtcbn1cbi8qKlxuICogQXR0ZW1wdHMgdG8gcmVzb2x2ZSBuZXN0ZWQgZWxlbWVudCBub2RlcyBvZiB0aGUgc2FtZSB0eXBlIGludG8gYSBzaW5nbGUgbm9kZSBvZiB0aGF0IHR5cGUuXG4gKiBJdCBpcyBnZW5lcmFsbHkgdXNlZCBmb3IgbWFya3MvY29tbWVudGluZ1xuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIHRhcmdldE5vZGUgLSBUaGUgdGFyZ2V0IGZvciB0aGUgbmVzdGVkIGVsZW1lbnQgdG8gYmUgZXh0cmFjdGVkIGZyb20uXG4gKiBAcGFyYW0gY2xvbmVOb2RlIC0gU2VlIHtAbGluayAkY3JlYXRlTWFya05vZGV9XG4gKiBAcGFyYW0gaGFuZGxlT3ZlcmxhcCAtIEhhbmRsZXMgYW55IG92ZXJsYXAgYmV0d2VlbiB0aGUgbm9kZSB0byBleHRyYWN0IGFuZCB0aGUgdGFyZ2V0Tm9kZVxuICogQHJldHVybnMgVGhlIGxleGljYWwgZWRpdG9yXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJOZXN0ZWRFbGVtZW50UmVzb2x2ZXIoZWRpdG9yLCB0YXJnZXROb2RlLCBjbG9uZU5vZGUsIGhhbmRsZU92ZXJsYXApIHtcbiAgY29uc3QgJGlzVGFyZ2V0Tm9kZSA9IG5vZGUgPT4ge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgdGFyZ2V0Tm9kZTtcbiAgfTtcblxuICBjb25zdCAkZmluZE1hdGNoID0gbm9kZSA9PiB7XG4gICAgLy8gRmlyc3QgdmFsaWRhdGUgd2UgZG9uJ3QgaGF2ZSBhbnkgY2hpbGRyZW4gdGhhdCBhcmUgb2YgdGhlIHRhcmdldCxcbiAgICAvLyBhcyB3ZSBuZWVkIHRvIGhhbmRsZSB0aGVtIGZpcnN0LlxuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgaWYgKCRpc1RhcmdldE5vZGUoY2hpbGQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBwYXJlbnROb2RlID0gbm9kZTtcbiAgICBsZXQgY2hpbGROb2RlID0gbm9kZTtcblxuICAgIHdoaWxlIChwYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICBjaGlsZE5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgICAgIGlmICgkaXNUYXJnZXROb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hpbGQ6IGNoaWxkTm9kZSxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudE5vZGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBjb25zdCBlbGVtZW50Tm9kZVRyYW5zZm9ybSA9IG5vZGUgPT4ge1xuICAgIGNvbnN0IG1hdGNoID0gJGZpbmRNYXRjaChub2RlKTtcblxuICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjaGlsZCxcbiAgICAgICAgcGFyZW50XG4gICAgICB9ID0gbWF0Y2g7IC8vIFNpbXBsZSBwYXRoLCB3ZSBjYW4gbW92ZSBjaGlsZCBvdXQgYW5kIHNpYmxpbmdzIGludG8gYSBuZXcgcGFyZW50LlxuXG4gICAgICBpZiAoY2hpbGQuaXMobm9kZSkpIHtcbiAgICAgICAgaGFuZGxlT3ZlcmxhcChwYXJlbnQsIG5vZGUpO1xuICAgICAgICBjb25zdCBuZXh0U2libGluZ3MgPSBjaGlsZC5nZXROZXh0U2libGluZ3MoKTtcbiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmdzTGVuZ3RoID0gbmV4dFNpYmxpbmdzLmxlbmd0aDtcbiAgICAgICAgcGFyZW50Lmluc2VydEFmdGVyKGNoaWxkKTtcblxuICAgICAgICBpZiAobmV4dFNpYmxpbmdzTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgbmV3UGFyZW50ID0gY2xvbmVOb2RlKHBhcmVudCk7XG4gICAgICAgICAgY2hpbGQuaW5zZXJ0QWZ0ZXIobmV3UGFyZW50KTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dFNpYmxpbmdzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld1BhcmVudC5hcHBlbmQobmV4dFNpYmxpbmdzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhcmVudC5jYW5CZUVtcHR5KCkgJiYgcGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKHRhcmdldE5vZGUsIGVsZW1lbnROb2RlVHJhbnNmb3JtKTtcbn1cbi8qKlxuICogQ2xvbmVzIHRoZSBlZGl0b3IgYW5kIG1hcmtzIGl0IGFzIGRpcnR5IHRvIGJlIHJlY29uY2lsZWQuIElmIHRoZXJlIHdhcyBhIHNlbGVjdGlvbixcbiAqIGl0IHdvdWxkIGJlIHNldCBiYWNrIHRvIGl0cyBwcmV2aW91cyBzdGF0ZSwgb3IgbnVsbCBvdGhlcndpc2UuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yXG4gKiBAcGFyYW0gZWRpdG9yU3RhdGUgLSBUaGUgZWRpdG9yJ3Mgc3RhdGVcbiAqL1xuXG5mdW5jdGlvbiAkcmVzdG9yZUVkaXRvclN0YXRlKGVkaXRvciwgZWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgRlVMTF9SRUNPTkNJTEUgPSAyO1xuICBjb25zdCBub2RlTWFwID0gbmV3IE1hcCgpO1xuICBjb25zdCBhY3RpdmVFZGl0b3JTdGF0ZSA9IGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlO1xuXG4gIGZvciAoY29uc3QgW2tleSwgbm9kZV0gb2YgZWRpdG9yU3RhdGUuX25vZGVNYXApIHtcbiAgICBjb25zdCBjbG9uZSA9IHNlbGVjdGlvbi4kY2xvbmVXaXRoUHJvcGVydGllcyhub2RlKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGNsb25lKSkge1xuICAgICAgY2xvbmUuX190ZXh0ID0gbm9kZS5fX3RleHQ7XG4gICAgfVxuXG4gICAgbm9kZU1hcC5zZXQoa2V5LCBjbG9uZSk7XG4gIH1cblxuICBpZiAoYWN0aXZlRWRpdG9yU3RhdGUpIHtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZS5fbm9kZU1hcCA9IG5vZGVNYXA7XG4gIH1cblxuICBlZGl0b3IuX2RpcnR5VHlwZSA9IEZVTExfUkVDT05DSUxFO1xuICBjb25zdCBzZWxlY3Rpb24kMSA9IGVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGxleGljYWwuJHNldFNlbGVjdGlvbihzZWxlY3Rpb24kMSA9PT0gbnVsbCA/IG51bGwgOiBzZWxlY3Rpb24kMS5jbG9uZSgpKTtcbn1cbi8qKlxuICogSWYgdGhlIHNlbGVjdGVkIGluc2VydGlvbiBhcmVhIGlzIHRoZSByb290L3NoYWRvdyByb290IG5vZGUgKHNlZSB7QGxpbmsgbGV4aWNhbCEkaXNSb290T3JTaGFkb3dSb290fSksXG4gKiB0aGUgbm9kZSB3aWxsIGJlIGFwcGVuZGVkIHRoZXJlLCBvdGhlcndpc2UsIGl0IHdpbGwgYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBpbnNlcnRpb24gYXJlYS5cbiAqIElmIHRoZXJlIGlzIG5vIHNlbGVjdGlvbiB3aGVyZSB0aGUgbm9kZSBpcyB0byBiZSBpbnNlcnRlZCwgaXQgd2lsbCBiZSBhcHBlbmRlZCBhZnRlciBhbnkgY3VycmVudCBub2Rlc1xuICogd2l0aGluIHRoZSB0cmVlLCBhcyBhIGNoaWxkIG9mIHRoZSByb290IG5vZGUuIEEgcGFyYWdyYXBoIG5vZGUgd2lsbCB0aGVuIGJlIGFkZGVkIGFmdGVyIHRoZSBpbnNlcnRlZCBub2RlIGFuZCBzZWxlY3RlZC5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgaW5zZXJ0ZWRcbiAqIEByZXR1cm5zIFRoZSBub2RlIGFmdGVyIGl0cyBpbnNlcnRpb25cbiAqL1xuXG5mdW5jdGlvbiAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3Qobm9kZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKSB8fCBsZXhpY2FsLiRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuXG4gIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCB7XG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuXG4gICAgaWYgKGxleGljYWwuJGlzUm9vdE9yU2hhZG93Um9vdChmb2N1c05vZGUpKSB7XG4gICAgICBjb25zdCBmb2N1c0NoaWxkID0gZm9jdXNOb2RlLmdldENoaWxkQXRJbmRleChmb2N1c09mZnNldCk7XG5cbiAgICAgIGlmIChmb2N1c0NoaWxkID09IG51bGwpIHtcbiAgICAgICAgZm9jdXNOb2RlLmFwcGVuZChub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvY3VzQ2hpbGQuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNlbGVjdE5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHNwbGl0Tm9kZTtcbiAgICAgIGxldCBzcGxpdE9mZnNldDtcblxuICAgICAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoZm9jdXNOb2RlKSkge1xuICAgICAgICBzcGxpdE5vZGUgPSBmb2N1c05vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICBzcGxpdE9mZnNldCA9IGZvY3VzTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuXG4gICAgICAgIGlmIChmb2N1c09mZnNldCA+IDApIHtcbiAgICAgICAgICBzcGxpdE9mZnNldCArPSAxO1xuICAgICAgICAgIGZvY3VzTm9kZS5zcGxpdFRleHQoZm9jdXNPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGxpdE5vZGUgPSBmb2N1c05vZGU7XG4gICAgICAgIHNwbGl0T2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFssIHJpZ2h0VHJlZV0gPSBsZXhpY2FsLiRzcGxpdE5vZGUoc3BsaXROb2RlLCBzcGxpdE9mZnNldCk7XG4gICAgICByaWdodFRyZWUuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgcmlnaHRUcmVlLnNlbGVjdFN0YXJ0KCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChsZXhpY2FsLiRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0uZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdygpLmluc2VydEFmdGVyKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByb290ID0gbGV4aWNhbC4kZ2V0Um9vdCgpO1xuICAgICAgcm9vdC5hcHBlbmQobm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBub2RlLmluc2VydEFmdGVyKHBhcmFncmFwaE5vZGUpO1xuICAgIHBhcmFncmFwaE5vZGUuc2VsZWN0KCk7XG4gIH1cblxuICByZXR1cm4gbm9kZS5nZXRMYXRlc3QoKTtcbn1cbi8qKlxuICogV3JhcHMgdGhlIG5vZGUgaW50byBhbm90aGVyIG5vZGUgY3JlYXRlZCBmcm9tIGEgY3JlYXRlRWxlbWVudE5vZGUgZnVuY3Rpb24sIGVnLiAkY3JlYXRlUGFyYWdyYXBoTm9kZVxuICogQHBhcmFtIG5vZGUgLSBOb2RlIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudE5vZGUgLSBDcmVhdGVzIGEgbmV3IGxleGNpYWwgZWxlbWVudCB0byB3cmFwIHRoZSB0by1iZS13cmFwcGVkIG5vZGUgYW5kIHJldHVybnMgaXQuXG4gKiBAcmV0dXJucyBBIG5ldyBsZXhjaWFsIGVsZW1lbnQgd2l0aCB0aGUgcHJldmlvdXMgbm9kZSBhcHBlbmRlZCB3aXRoaW4gKGFzIGEgY2hpbGQsIGluY2x1ZGluZyBpdHMgY2hpbGRyZW4pLlxuICovXG5cbmZ1bmN0aW9uICR3cmFwTm9kZUluRWxlbWVudChub2RlLCBjcmVhdGVFbGVtZW50Tm9kZSkge1xuICBjb25zdCBlbGVtZW50Tm9kZSA9IGNyZWF0ZUVsZW1lbnROb2RlKCk7XG4gIG5vZGUucmVwbGFjZShlbGVtZW50Tm9kZSk7XG4gIGVsZW1lbnROb2RlLmFwcGVuZChub2RlKTtcbiAgcmV0dXJuIGVsZW1lbnROb2RlO1xufVxuLyoqXG4gKiBAcGFyYW0geCAtIFRoZSBlbGVtZW50IGJlaW5nIHRlc3RlZFxuICogQHJldHVybnMgUmV0dXJucyB0cnVlIGlmIHggaXMgYW4gSFRNTCBhbmNob3IgdGFnLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuXG5mdW5jdGlvbiBpc0hUTUxBbmNob3JFbGVtZW50KHgpIHtcbiAgcmV0dXJuIGlzSFRNTEVsZW1lbnQoeCkgJiYgeC50YWdOYW1lID09PSAnQSc7XG59XG4vKipcbiAqIEBwYXJhbSB4IC0gVGhlIGVsZW1lbnQgYmVpbmcgdGVzdGluZ1xuICogQHJldHVybnMgUmV0dXJucyB0cnVlIGlmIHggaXMgYW4gSFRNTCBlbGVtZW50LCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh4KSB7XG4gIC8vIEB0cy1pZ25vcmUtbmV4dC1saW5lIC0gc3RyaWN0IGNoZWNrIG9uIG5vZGVUeXBlIGhlcmUgc2hvdWxkIGZpbHRlciBvdXQgbm9uLUVsZW1lbnQgRXZlbnRUYXJnZXQgaW1wbGVtZW50b3JzXG4gIHJldHVybiB4Lm5vZGVUeXBlID09PSAxO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4vKipcbiAqIEBwYXJhbSBvYmplY3QgPSBUaGUgaW5zdGFuY2Ugb2YgdGhlIHR5cGVcbiAqIEBwYXJhbSBvYmplY3RDbGFzcyA9IFRoZSBjbGFzcyBvZiB0aGUgdHlwZVxuICogQHJldHVybnMgV2hldGhlciB0aGUgb2JqZWN0IGlzIGhhcyB0aGUgc2FtZSBLbGFzcyBvZiB0aGUgb2JqZWN0Q2xhc3MsIGlnbm9yaW5nIHRoZSBkaWZmZXJlbmNlIGFjcm9zcyB3aW5kb3cgKGUuZy4gZGlmZmVyZW50IGlmcmFtcylcbiAqL1xuZnVuY3Rpb24gb2JqZWN0S2xhc3NFcXVhbHMob2JqZWN0LCBvYmplY3RDbGFzcykge1xuICByZXR1cm4gb2JqZWN0ICE9PSBudWxsID8gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkuY29uc3RydWN0b3IubmFtZSA9PT0gb2JqZWN0Q2xhc3MubmFtZSA6IGZhbHNlO1xufVxuXG5leHBvcnRzLiRzcGxpdE5vZGUgPSBsZXhpY2FsLiRzcGxpdE5vZGU7XG5leHBvcnRzLiRkZnMgPSAkZGZzO1xuZXhwb3J0cy4kZmluZE1hdGNoaW5nUGFyZW50ID0gJGZpbmRNYXRjaGluZ1BhcmVudDtcbmV4cG9ydHMuJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3cgPSAkZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdztcbmV4cG9ydHMuJGdldE5lYXJlc3ROb2RlT2ZUeXBlID0gJGdldE5lYXJlc3ROb2RlT2ZUeXBlO1xuZXhwb3J0cy4kaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3QgPSAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3Q7XG5leHBvcnRzLiRyZXN0b3JlRWRpdG9yU3RhdGUgPSAkcmVzdG9yZUVkaXRvclN0YXRlO1xuZXhwb3J0cy4kd3JhcE5vZGVJbkVsZW1lbnQgPSAkd3JhcE5vZGVJbkVsZW1lbnQ7XG5leHBvcnRzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQgPSBhZGRDbGFzc05hbWVzVG9FbGVtZW50O1xuZXhwb3J0cy5pc0hUTUxBbmNob3JFbGVtZW50ID0gaXNIVE1MQW5jaG9yRWxlbWVudDtcbmV4cG9ydHMuaXNIVE1MRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQ7XG5leHBvcnRzLmlzTWltZVR5cGUgPSBpc01pbWVUeXBlO1xuZXhwb3J0cy5tZWRpYUZpbGVSZWFkZXIgPSBtZWRpYUZpbGVSZWFkZXI7XG5leHBvcnRzLm1lcmdlUmVnaXN0ZXIgPSBtZXJnZVJlZ2lzdGVyO1xuZXhwb3J0cy5vYmplY3RLbGFzc0VxdWFscyA9IG9iamVjdEtsYXNzRXF1YWxzO1xuZXhwb3J0cy5yZWdpc3Rlck5lc3RlZEVsZW1lbnRSZXNvbHZlciA9IHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyO1xuZXhwb3J0cy5yZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQgPSByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalUtils =  true ? __webpack_require__(/*! ./LexicalUtils.dev.js */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.dev.js\") : 0\nmodule.exports = LexicalUtils;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC91dGlscy9MZXhpY2FsVXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWixxQkFBcUIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLG9HQUF1QixJQUFJLENBQWlDO0FBQ2xJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC91dGlscy9MZXhpY2FsVXRpbHMuanM/MTY5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbFV0aWxzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxVdGlscy5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbFV0aWxzLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsVXRpbHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lexical/Lexical.dev.js":
/*!*********************************************!*\
  !*** ./node_modules/lexical/Lexical.dev.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createCommand(type) {\n  return {\n    type\n  } ;\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3; // Reconciling\n\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2; // Text node modes\n\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2; // IS_INERT = 3\n// Text node formatting\n\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT; // Text node details\n\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1; // Element node formatting\n\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6; // Reconciliation\n\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b'; // For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\n\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n'; // For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\n\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'; // eslint-disable-next-line no-misleading-character-class\n\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']'); // eslint-disable-next-line no-misleading-character-class\n\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcesssingMutations() {\n  return isProcessingMutations;\n}\n\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\n\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\n\nfunction isManagedLineBreak(dom, target, editor) {\n  return (// @ts-expect-error: internal field\n    target.__lexicalLineBreak === dom || // @ts-ignore We intentionally add this to the Node.\n    dom[`__lexicalKey_${editor._key}`] !== undefined\n  );\n}\n\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\n\nfunction handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n\n  const text = target.nodeValue;\n\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\n\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\n}\n\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement(); // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n\n        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {\n          continue;\n        }\n\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            handleTextMutation( // nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true; // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n\n          const addedDOMs = mutation.addedNodes;\n\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      } // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n\n\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.getChildrenKeys();\n            let currentDOM = targetDOM.firstChild;\n\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n\n              if (correctDOM === null) {\n                continue;\n              }\n\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      } // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n\n\n      const records = observer.takeRecords(); // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        } // Clear any of those removal mutations\n\n\n        observer.takeRecords();\n      }\n\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\n\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\n\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  } // Backward\n\n\n  let previousNode;\n\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  } // Forward\n\n\n  let nextNode;\n\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\n\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet keyCounter = 1;\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n\n  if (activeElement === null) {\n    return false;\n  }\n\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' && // @ts-ignore iternal field\n  activeElement.__lexicalEditor == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n\n  while (currentNode != null) {\n    // @ts-expect-error: internal field\n    const editor = currentNode.__lexicalEditor;\n\n    if (editor != null) {\n      return editor;\n    }\n\n    currentNode = getParentElement(currentNode);\n  }\n\n  return null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\n\nfunction isDOMNodeLexicalTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE;\n}\n\nfunction getDOMTextNode(element) {\n  let node = element;\n\n  while (node != null) {\n    if (isDOMNodeLexicalTextNode(node)) {\n      return node;\n    }\n\n    node = node.firstChild;\n  }\n\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  const isStateFlagPresent = format & activeFormat;\n\n  if (isStateFlagPresent && (alignWithFormat === null || (alignWithFormat & activeFormat) === 0)) {\n    // Remove the state flag.\n    return format ^ activeFormat;\n  }\n\n  if (alignWithFormat === null || alignWithFormat & activeFormat) {\n    // Add the state flag.\n    return format | activeFormat;\n  }\n\n  return format;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    node.__key = existingKey;\n    return;\n  }\n\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n\n  editorState._nodeMap.set(key, node); // TODO Split this function into leaf/element\n\n\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n\n  editor._cloneNotNeeded.add(key);\n\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\n\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n\n    const node = nodeMap.get(nextParentKey);\n\n    if (node === undefined) {\n      break;\n    }\n\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling(); // TODO: this function duplicates a bunch of operations, can be simplified.\n\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n\n      writableNode.__prev = null;\n    }\n\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n\n      writableNode.__next = null;\n    }\n\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n} // Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\n\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n\n  const node = editorState._nodeMap.get(key);\n\n  if (node === undefined) {\n    return null;\n  }\n\n  return node;\n}\nfunction getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor(); // @ts-ignore We intentionally add this to the Node.\n\n  const key = dom[`__lexicalKey_${editor._key}`];\n\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n\n  return null;\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n\n  while (dom != null) {\n    const node = getNodeFromDOMNode(dom, editorState);\n\n    if (node !== null) {\n      return node;\n    }\n\n    dom = getParentElement(dom);\n  }\n\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n\n    if (editorState.isEmpty()) {\n      return;\n    }\n\n    if (type === 'root') {\n      $getRoot().markDirty();\n      return;\n    }\n\n    const nodeMap = editorState._nodeMap;\n\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n\n    selection.dirty = true;\n    selection._cachedNodes = null;\n  }\n\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\nfunction getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n\n    return null;\n  }\n\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\n\nfunction getNodeKeyFromDOM( // Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n\n  while (node != null) {\n    // @ts-ignore We intentionally add this to the Node.\n    const key = node[`__lexicalKey_${editor._key}`];\n\n    if (key !== undefined) {\n      return key;\n    }\n\n    node = getParentElement(node);\n  }\n\n  return null;\n}\n\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\n    return anchorNode.nodeValue;\n  }\n\n  return null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n\n  if (domSelection === null) {\n    return;\n  }\n\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n\n    const prevTextContent = node.getTextContent();\n\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n\n        return;\n      }\n\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing || // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter())) {\n        node.markDirty();\n        return;\n      }\n\n      const selection = $getSelection();\n\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\n\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n} // This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\n\n\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(keyCode, altKey, ctrlKey, metaKey) {\n  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(keyCode, shiftKey) {\n  return isReturn(keyCode) && !shiftKey;\n}\nfunction isLineBreak(keyCode, shiftKey) {\n  return isReturn(keyCode) && shiftKey;\n} // Inserts a new line after the selection\n\nfunction isOpenLineBreak(keyCode, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && keyCode === 79;\n}\nfunction isDeleteWordBackward(keyCode, altKey, ctrlKey) {\n  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(keyCode, altKey, ctrlKey) {\n  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(keyCode);\n}\nfunction isDeleteLineForward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isDelete(keyCode);\n}\nfunction isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n\n    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;\n  }\n\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n\n  return isBackspace(keyCode);\n}\nfunction isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n\n    return isDelete(keyCode) || keyCode === 68 && ctrlKey;\n  }\n\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n\n  return isDelete(keyCode);\n}\nfunction isUndo(keyCode, shiftKey, metaKey, ctrlKey) {\n  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return keyCode === 90 && metaKey && shiftKey;\n  }\n\n  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;\n}\nfunction isCopy(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n\n  if (keyCode === 67) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n\n  return false;\n}\nfunction isCut(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n\n  if (keyCode === 88) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n\n  return false;\n}\n\nfunction isArrowLeft(keyCode) {\n  return keyCode === 37;\n}\n\nfunction isArrowRight(keyCode) {\n  return keyCode === 39;\n}\n\nfunction isArrowUp(keyCode) {\n  return keyCode === 38;\n}\n\nfunction isArrowDown(keyCode) {\n  return keyCode === 40;\n}\n\nfunction isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(keyCode, ctrlKey, metaKey) {\n  return isArrowUp(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(keyCode, ctrlKey, metaKey) {\n  return isArrowDown(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(keyCode) {\n  return keyCode === 32;\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n\n  return ctrlKey;\n}\nfunction isReturn(keyCode) {\n  return keyCode === 13;\n}\nfunction isBackspace(keyCode) {\n  return keyCode === 8;\n}\nfunction isEscape(keyCode) {\n  return keyCode === 27;\n}\nfunction isDelete(keyCode) {\n  return keyCode === 46;\n}\nfunction isSelectAll(keyCode, metaKey, ctrlKey) {\n  return keyCode === 65 && controlOrMeta(metaKey, ctrlKey);\n}\nfunction $selectAll() {\n  const root = $getRoot();\n  const selection = root.select(0, root.getChildrenSize());\n  $setSelection($normalizeSelection(selection));\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n\n  const classNames = classNamesTheme[classNameThemeType]; // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n\n  if (typeof classNames === 'string') {\n    const classNamesArr = classNames.split(' ');\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n\n  const prevMutation = mutatedNodesByType.get(nodeKey); // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\nfunction $nodesOfType(klass) {\n  const editorState = getActiveEditorState();\n  const readOnly = editorState._readOnly;\n  const klassType = klass.getType();\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\n      nodesOfType.push(node);\n    }\n  }\n\n  return nodesOfType;\n}\n\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\n\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n\n      return possibleNode;\n    }\n  }\n\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = rootElement.ownerDocument;\n  const defaultView = doc.defaultView;\n\n  if (defaultView === null) {\n    return;\n  }\n\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n\n    let diff = 0;\n\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n\n    if (isBodyElement) {\n      break;\n    }\n\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n\n  editor._updateTags.add(tag);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = domElem.ownerDocument;\n  return ownerDoc && ownerDoc.defaultView || null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n\n    parent = parent.getParentOrThrow();\n  }\n\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\nfunction $copyNode(node) {\n  // @ts-ignore\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n\n  const registeredNode = editor._nodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n    }\n  }\n\n  const replaceFunc = registeredNode.replace;\n\n  if (replaceFunc !== null) {\n    const replacementNode = replaceFunc(node);\n\n    if (!(replacementNode instanceof node.constructor)) {\n      {\n        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);\n      }\n    }\n\n    return replacementNode;\n  }\n\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\n\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = blockCursorTheme.split(' '); // @ts-expect-error: intentional\n\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n\n  return element;\n}\n\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\n\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n\n      if (needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n\n      rootElement.style.caretColor = 'transparent';\n\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n\n      return;\n    }\n  } // Remove cursor\n\n\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n\n  if (startNode == null) {\n    startNode = node;\n  }\n\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent); // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n\n    if (isParentRoot) {\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\nfunction $getChildrenRecursively(node) {\n  const nodes = [];\n  const stack = [node];\n\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n\n    if (!(currentNode !== undefined)) {\n      throw Error(`Stack.length > 0; can't be undefined`);\n    }\n\n    if ($isElementNode(currentNode)) {\n      stack.unshift(...currentNode.getChildren());\n    }\n\n    if (currentNode !== node) {\n      nodes.push(currentNode);\n    }\n  }\n\n  return nodes;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n\n      delete decorators[key];\n    }\n  }\n}\n\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n\n  while (child !== null) {\n    const childKey = child.__key; // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      } // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n\n\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n\n      nodeMapDelete.push(childKey);\n    }\n\n    child = child.getNextSibling();\n  }\n}\n\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap; // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n\n  const nodeMapDelete = [];\n\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        } // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n\n\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\n\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  } // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n\n\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\n\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\n\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\n\nconst DEFAULT_INDENT_VALUE = '40px';\n\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\n\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\n\nfunction createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1); // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      createChildrenWithDirection(children, endIndex, node, dom);\n    }\n\n    const format = node.__format;\n\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      } // Decorators are always non editable\n\n\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // @ts-expect-error: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\n\nfunction createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  createChildren(children, element, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\n\nfunction createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n\n  for (; startIndex <= endIndex; ++startIndex) {\n    createNode(children[startIndex], dom, insertDOM);\n  }\n\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  } // @ts-expect-error: internal field\n\n\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\n\nfunction isLastChildLineBreakOrDecorator(childKey, nodeMap) {\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();\n} // If we end an element with a LineBreakNode, then we need to add an additional <br>\n\n\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));\n  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);\n\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // @ts-expect-error: internal field\n      const element = dom.__lexicalLineBreak;\n\n      if (element != null) {\n        dom.removeChild(element);\n      } // @ts-expect-error: internal field\n\n\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br'); // @ts-expect-error: internal field\n\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\n\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent = // @ts-expect-error: internal field\n  dom.__lexicalDirTextContent; // @ts-expect-error: internal field\n\n  const previousDirection = dom.__lexicalDir;\n\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined; // Remove the old theme classes if they exist\n\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = previousDirectionTheme.split(' ');\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        } // @ts-ignore: intentional\n\n\n        classList.remove(...previousDirectionTheme);\n      }\n\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = nextDirectionTheme.split(' '); // @ts-expect-error: intentional\n\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        } // Update direction\n\n\n        dom.dir = direction;\n      }\n\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n\n    activeTextDirection = direction; // @ts-expect-error: internal field\n\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent; // @ts-expect-error: internal field\n\n    dom.__lexicalDir = direction;\n  }\n}\n\nfunction reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  reconcileChildren(prevElement, nextElement, dom);\n  reconcileBlockDirection(nextElement, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\n\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n\n  return children;\n}\n\nfunction reconcileChildren(prevElement, nextElement, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFrstChildKey = nextElement.__first;\n\n    if (prevFirstChildKey === nextFrstChildKey) {\n      reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = createNode(nextFrstChildKey, null, null);\n      dom.replaceChild(replacementDOM, lastDOM);\n      destroyNode(prevFirstChildKey, null);\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        // @ts-expect-error: internal field\n        const lexicalLineBreak = dom.__lexicalLineBreak;\n        const canUseFastPath = lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);\n    }\n  }\n\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  } // @ts-expect-error: internal field\n\n\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\n\nfunction reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key); // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // @ts-expect-error: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      } // @ts-expect-error: internal field\n\n\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n\n    return dom;\n  } // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n\n\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  } // Update node. If it returns true, we need to unmount and re-create the node\n\n\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = createNode(key, null, null);\n\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n\n    const nextFormat = nextNode.__format;\n\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n\n    if (isDirty) {\n      reconcileChildrenWithDirection(prevNode, nextNode, dom);\n\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    nextNode = nextNode.getWritable();\n    nextNode.__cachedText = editorTextContent;\n  }\n\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n\n  return dom;\n}\n\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n\n  pendingDecorators[key] = decorator;\n}\n\nfunction getFirstChild(element) {\n  return element.firstChild;\n}\n\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n\n  return nextSibling;\n}\n\nfunction reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n\n          reconcileNode(nextKey, dom);\n        }\n\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n  }\n\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\n\nfunction reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = ''; // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap); // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  reconcileNode('root', null); // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n\n  activeEditor$1 = undefined; // @ts-ignore\n\n  activeEditorNodes = undefined; // @ts-ignore\n\n  activeDirtyElements = undefined; // @ts-ignore\n\n  activeDirtyLeaves = undefined; // @ts-ignore\n\n  activePrevNodeMap = undefined; // @ts-ignore\n\n  activeNextNodeMap = undefined; // @ts-ignore\n\n  activeEditorConfig = undefined; // @ts-ignore\n\n  activePrevKeyToDOMMap = undefined; // @ts-ignore\n\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap; // @ts-ignore We intentionally add this to the Node.\n\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\n\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\n\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\n\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = 0;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nlet rootElementsRegistered = 0;\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0]; // This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\n\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key || // If we're working with a non-text node.\n  !$isTextNode(anchorNode) || // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT || // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() || // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) || // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) || // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style || // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\n\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\n}\n\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false; // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n\n    const selection = $getSelection(); // Update the selection format\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        } // If we have marked a collapsed selection format, and we're\n        // within the given time range – then attempt to use that format\n        // instead of getting the format from the anchor node.\n\n\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element') {\n            selection.format = 0;\n            selection.style = '';\n          }\n        }\n      } else {\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n\n          if ($isTextNode(node)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n} // This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\n\n\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Tripple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n\n          if (anchorNode !== focusNode) {\n            if ($isElementNode(anchorNode)) {\n              anchorNode.select(0);\n            } else {\n              anchorNode.getParentOrThrow().select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n\n        if (domAnchorNode !== null) {\n          const nodeType = domAnchorNode.nodeType; // If the user is attempting to click selection back onto text, then\n          // we should attempt create a range selection.\n          // When we click on an empty paragraph node or the end of a paragraph that ends\n          // with an image/poll, the nodeType will be ELEMENT_NODE\n\n          if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {\n            const newSelection = internalCreateRangeSelection(lastSelection, domSelection, editor);\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\n\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n\n  if (target instanceof Node && pointerType !== 'touch') {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\n\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n\n  const targetRanges = event.getTargetRanges();\n\n  if (targetRanges.length === 0) {\n    return null;\n  }\n\n  return targetRanges[0];\n}\n\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\n\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\n\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event); // We let the browser do its own thing for composition.\n\n  if (inputType === 'deleteCompositionText' || // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n\n        $setSelection(prevSelection.clone());\n      }\n\n      if ($isRangeSelection(selection)) {\n        // Used for handling backspace in Android.\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && selection.anchor.key === selection.focus.key) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0; // Fixes an Android bug where selection flickers when backspacing\n\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          event.preventDefault();\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n        }\n\n        return;\n      }\n    }\n\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n\n    const data = event.data; // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    } // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n\n\n    event.preventDefault();\n\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null); // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n\n          break;\n        }\n\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n\n          break;\n        }\n\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n\n    }\n  });\n}\n\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n\n      if (domSelection === null) {\n        return;\n      }\n\n      const offset = anchor.offset; // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n\n      const textLength = data.length; // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      } // This ensures consistency on Android.\n\n\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData); // onInput always fires after onCompositionEnd for FF.\n\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    } // Also flush any other mutations that might have occurred\n    // since the change.\n\n\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\n\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n\n      if ( // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\n\nfunction onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null); // Handle termination of composition.\n\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n\n      return;\n    } // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n\n\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n\n  $updateSelectedTextFromDOM(true, editor, data);\n}\n\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\n\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.keyCode;\n\n  if (editor.isComposing()) {\n    return;\n  }\n\n  const {\n    keyCode,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n\n  if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(keyCode, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(keyCode)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(keyCode, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(keyCode, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(keyCode)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(keyCode)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(keyCode)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n\n    if ($isNodeSelection(prevSelection)) {\n      if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(keyCode, metaKey, ctrlKey)) {\n        event.preventDefault();\n        editor.update(() => {\n          $selectAll();\n        });\n      } // FF does it well (no need to override behavior)\n\n    } else if (!IS_FIREFOX && isSelectAll(keyCode, metaKey, ctrlKey)) {\n      event.preventDefault();\n      editor.update(() => {\n        $selectAll();\n      });\n    }\n  }\n\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\n\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n\n  if (eventHandles === undefined) {\n    eventHandles = []; // @ts-expect-error: internal field\n\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n\n  return eventHandles;\n} // Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\n\n\nconst activeNestedEditorsMap = new Map();\n\nfunction onDocumentSelectionChange(event) {\n  const target = event.target;\n  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\n  const domSelection = getDOMSelection(targetWindow);\n\n  if (domSelection === null) {\n    return;\n  }\n\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n\n  if (nextActiveEditor === null) {\n    return;\n  }\n\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n\n      if (domAnchorNode === null) {\n        return;\n      }\n\n      const nodeType = domAnchorNode.nodeType; // If the user is attempting to click selection back onto text, then\n      // we should attempt create a range selection.\n      // When we click on an empty paragraph node or the end of a paragraph that ends\n      // with an image/poll, the nodeType will be ELEMENT_NODE\n\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\n        return;\n      }\n\n      const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor);\n      $setSelection(newSelection);\n    });\n  } // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n\n\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n\n  onSelectionChange(domSelection, nextActiveEditor, true); // If newly selected editor is nested, then add it to the map, clean map otherwise\n\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\n\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\n\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\n\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  if (rootElementsRegistered === 0) {\n    const doc = rootElement.ownerDocument;\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n\n  rootElementsRegistered++; // @ts-expect-error: internal field\n\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n\n      stopLexicalPropagation(event);\n\n      if (editor.isEditable()) {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n\n      stopLexicalPropagation(event);\n\n      if (editor.isEditable()) {\n        switch (eventName) {\n          case 'cut':\n            return dispatchCommand(editor, CUT_COMMAND, event);\n\n          case 'copy':\n            return dispatchCommand(editor, COPY_COMMAND, event);\n\n          case 'paste':\n            return dispatchCommand(editor, PASTE_COMMAND, event);\n\n          case 'dragstart':\n            return dispatchCommand(editor, DRAGSTART_COMMAND, event);\n\n          case 'dragover':\n            return dispatchCommand(editor, DRAGOVER_COMMAND, event);\n\n          case 'dragend':\n            return dispatchCommand(editor, DRAGEND_COMMAND, event);\n\n          case 'focus':\n            return dispatchCommand(editor, FOCUS_COMMAND, event);\n\n          case 'blur':\n            {\n              return dispatchCommand(editor, BLUR_COMMAND, event);\n            }\n\n          case 'drop':\n            return dispatchCommand(editor, DROP_COMMAND, event);\n        }\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  if (rootElementsRegistered !== 0) {\n    rootElementsRegistered--; // We only want to have a single global selectionchange event handler, shared\n    // between all editor instances.\n\n    if (rootElementsRegistered === 0) {\n      const doc = rootElement.ownerDocument;\n      doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n    }\n  } // @ts-expect-error: internal field\n\n\n  const editor = rootElement.__lexicalEditor;\n\n  if (editor !== null && editor !== undefined) {\n    cleanActiveNestedEditorsMap(editor); // @ts-expect-error: internal field\n\n    rootElement.__lexicalEditor = null;\n  }\n\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  } // @ts-expect-error: internal field\n\n\n  rootElement.__lexicalEventHandles = [];\n}\n\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\n\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n\n  if (parent === null) {\n    return;\n  }\n\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    removeNode(parent, restoreSelection);\n  }\n\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n\n\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  constructor(key) {\n    // @ts-expect-error\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, // @ts-expect-error\n        this.constructor);\n      }\n    }\n  } // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n\n\n  getType() {\n    return this.__type;\n  }\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n\n\n  isAttached() {\n    let nodeKey = this.__key;\n\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n\n      const node = $getNodeByKey(nodeKey);\n\n      if (node === null) {\n        break;\n      }\n\n      nodeKey = node.__parent;\n    }\n\n    return false;\n  }\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n\n\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n\n    if (targetSelection == null) {\n      return false;\n    }\n\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n\n    if ($isTextNode(this)) {\n      return isSelected;\n    } // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n\n\n    if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element' && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {\n      return false;\n    }\n\n    return isSelected;\n  }\n  /**\n   * Returns this nodes key.\n   */\n\n\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n\n\n  getIndexWithinParent() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return -1;\n    }\n\n    let node = parent.getFirstChild();\n    let index = 0;\n\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n\n      index++;\n      node = node.getNextSibling();\n    }\n\n    return -1;\n  }\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n\n\n  getParent() {\n    const parent = this.getLatest().__parent;\n\n    if (parent === null) {\n      return null;\n    }\n\n    return $getNodeByKey(parent);\n  }\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n\n\n  getParentOrThrow() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n\n    return parent;\n  }\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n\n\n  getTopLevelElement() {\n    let node = this;\n\n    while (node !== null) {\n      const parent = node.getParent();\n\n      if ($isRootOrShadowRoot(parent)) {\n        return node;\n      }\n\n      node = parent;\n    }\n\n    return null;\n  }\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n\n\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n\n    return parent;\n  }\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n\n\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n\n    return parents;\n  }\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n\n\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n\n    return parents;\n  }\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n\n\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n\n\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return siblings;\n    }\n\n    let node = parent.getFirstChild();\n\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n\n    return siblings;\n  }\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n\n\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n\n\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n\n    return siblings;\n  }\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n\n\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n\n    const aLength = a.length;\n    const bLength = b.length;\n\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n\n    const bSet = new Set(b);\n\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n\n\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n\n    return this.__key === object.__key;\n  }\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n\n\n  isBefore(targetNode) {\n    if (this === targetNode) {\n      return false;\n    }\n\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n\n    while (true) {\n      const parent = node.getParentOrThrow();\n\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n\n      node = parent;\n    }\n\n    node = targetNode;\n\n    while (true) {\n      const parent = node.getParentOrThrow();\n\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n\n      node = parent;\n    }\n\n    return indexA < indexB;\n  }\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n\n\n  isParentOf(targetNode) {\n    const key = this.__key;\n\n    if (key === targetNode.__key) {\n      return false;\n    }\n\n    let node = targetNode;\n\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n\n      node = node.getParent();\n    }\n\n    return false;\n  } // TO-DO: this function can be simplified a lot\n\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n\n\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n\n    while (true) {\n      const key = node.__key;\n\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n\n      if (node === targetNode) {\n        break;\n      }\n\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n\n      const parent = node.getParentOrThrow();\n\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n\n      if (parent === targetNode) {\n        break;\n      }\n\n      let parentSibling = null;\n      let ancestor = parent;\n\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        }\n      } while (parentSibling === null);\n\n      node = parentSibling;\n    }\n\n    if (!isBefore) {\n      nodes.reverse();\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n\n\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n\n\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n\n    return latest;\n  }\n  /**\n   * Returns a mutable version of the node. Will throw an error if\n   * called outside of a Lexical Editor {@link LexicalEditor.update} callback.\n   *\n   */\n\n\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key; // Ensure we get the latest node from pending state\n\n    const latestNode = this.getLatest();\n    const parent = latestNode.__parent;\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n\n    if (selection !== null) {\n      selection._cachedNodes = null;\n    }\n\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n\n    const constructor = latestNode.constructor; // @ts-expect-error\n\n    const mutableNode = constructor.clone(latestNode);\n    mutableNode.__parent = parent;\n    mutableNode.__next = latestNode.__next;\n    mutableNode.__prev = latestNode.__prev;\n\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\n      mutableNode.__first = latestNode.__first;\n      mutableNode.__last = latestNode.__last;\n      mutableNode.__size = latestNode.__size;\n      mutableNode.__indent = latestNode.__indent;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__dir = latestNode.__dir;\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__style = latestNode.__style;\n      mutableNode.__mode = latestNode.__mode;\n      mutableNode.__detail = latestNode.__detail;\n    }\n\n    cloneNotNeeded.add(key);\n    mutableNode.__key = key;\n    internalMarkNodeAsDirty(mutableNode); // Update reference in node map\n\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n\n\n  getTextContent() {\n    return '';\n  }\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n\n\n  getTextContentSize() {\n    return this.getTextContent().length;\n  } // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n\n\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n\n\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n\n\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n\n\n  exportJSON() {\n    {\n      throw Error(`exportJSON: base method not extended`);\n    }\n  }\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n\n\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n\n\n  static transform() {\n    return null;\n  } // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n\n\n  remove(preserveEmptyParent) {\n    removeNode(this, true, preserveEmptyParent);\n  }\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n\n\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) selection = selection.clone();\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    removeNode(self, false, true);\n\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n\n    writableReplaceWith.__prev = prevKey;\n\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n\n    if (includeChildren) {\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n\n    return writableReplaceWith;\n  }\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n\n\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n\n    return nodeToInsert;\n  }\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n\n\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev; // TODO: this is O(n), can we improve?\n\n    const index = this.getIndexWithinParent();\n\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n\n    return nodeToInsert;\n  }\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n\n\n  isParentRequired() {\n    return false;\n  }\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n\n\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n\n\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n\n\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n\n    if (nextSibling === null) {\n      return parent.select();\n    }\n\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n\n\n  markDirty() {\n    this.getWritable();\n  }\n\n}\n\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type); // Common error - split in its own invariant\n\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n\n  const editorKlass = registeredNode.klass;\n\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n\n  constructor(key) {\n    super(key);\n  }\n\n  getTextContent() {\n    return '\\n';\n  }\n\n  createDOM() {\n    return document.createElement('br');\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      br: node => {\n        const parentElement = node.parentElement; // If the <br> is the only child, then skip including it\n\n        let firstChild;\n        let lastChild;\n\n        if (parentElement !== null && ((firstChild = parentElement.firstChild) === node || firstChild.nextSibling === node && firstChild.nodeType === DOM_TEXT_TYPE && (firstChild.textContent || '').match(/^[\\s|\\r?\\n|\\t]+$/) !== null) && ((lastChild = parentElement.lastChild) === node || lastChild.previousSibling === node && lastChild.nodeType === DOM_TEXT_TYPE && (lastChild.textContent || '').match(/^[\\s|\\r?\\n|\\t]+$/) !== null)) {\n          return null;\n        }\n\n        return {\n          conversion: convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode();\n  }\n\n  exportJSON() {\n    return {\n      type: 'linebreak',\n      version: 1\n    };\n  }\n\n}\n\nfunction convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\n\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n\n  return null;\n}\n\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n\n  return 'span';\n}\n\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList; // Firstly we handle the base theme.\n\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  } // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n\n\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n\n          continue;\n        }\n\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\n\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\n\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing(); // Always add a suffix if we're composing a node\n\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        } // @ts-expect-error\n\n\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\n\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme; // Apply theme class names\n\n  const textClassNames = theme.text;\n\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\n\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n/** @noInheritDoc */\n\n\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'text';\n  }\n\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n\n\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n\n\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n\n\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n\n\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n\n\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n\n\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n\n\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n\n\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n\n\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n\n\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n\n\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n\n\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n\n\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  } // View\n\n\n  createDOM(config) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n\n    if (prevTag !== nextTag) {\n      return true;\n    }\n\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n\n    let innerDOM = dom;\n\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme; // Apply theme class names\n\n    const textClassNames = theme.text;\n\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createTextNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  } // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n\n\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor); // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n\n    if (element !== null) {\n      if (this.hasFormat('bold')) {\n        element = wrapElementWith(element, 'b');\n      }\n\n      if (this.hasFormat('italic')) {\n        element = wrapElementWith(element, 'i');\n      }\n\n      if (this.hasFormat('strikethrough')) {\n        element = wrapElementWith(element, 's');\n      }\n\n      if (this.hasFormat('underline')) {\n        element = wrapElementWith(element, 'u');\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      type: 'text',\n      version: 1\n    };\n  } // Mutators\n\n\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n\n\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.togglerUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n\n\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n\n\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it is present.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n\n\n  toggleFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return this.setFormat(this.getFormat() ^ formatFlag);\n  }\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n\n\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n\n\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n\n\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n\n    if (this.__mode === mode) {\n      return this;\n    }\n\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n\n\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n\n    return selection;\n  }\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n\n\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n\n    if (index < 0) {\n      index = handledTextLength + index;\n\n      if (index < 0) {\n        index = 0;\n      }\n    }\n\n    const selection = $getSelection();\n\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n\n\n  canInsertTextBefore() {\n    return true;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n\n\n  canInsertTextAfter() {\n    return true;\n  }\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n\n\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n\n      string += textContent[i];\n    }\n\n    if (string !== '') {\n      parts.push(string);\n    }\n\n    const partsLength = parts.length;\n\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n\n    const firstPart = parts[0];\n    const parent = self.getParentOrThrow();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    } // Handle selection\n\n\n    const selection = $getSelection(); // Then handle all other parts\n\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    } // Insert the nodes into the parent's children\n\n\n    internalMarkSiblingsAsDirty(this);\n    const writableParent = parent.getWritable();\n    const insertionIndex = this.getIndexWithinParent();\n\n    if (hasReplacedSelf) {\n      writableParent.splice(insertionIndex, 0, splitNodes);\n      this.remove();\n    } else {\n      writableParent.splice(insertionIndex, 1, splitNodes);\n    }\n\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n    }\n\n    return splitNodes;\n  }\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n\n\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n\n\n  isTextEntity() {\n    return false;\n  }\n\n}\n\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode; // Google Docs uses span tags + font-weight for bold text\n\n  const hasBoldFontWeight = span.style.fontWeight === '700'; // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n\n  const hasLinethroughTextDecoration = span.style.textDecoration === 'line-through'; // Google Docs uses span tags + font-style for italic text\n\n  const hasItalicFontStyle = span.style.fontStyle === 'italic'; // Google Docs uses span tags + text-decoration: underline for underline text\n\n  const hasUnderlineTextDecoration = span.style.textDecoration === 'underline'; // Google Docs uses span tags + vertical-align to specify subscript and superscript\n\n  const verticalAlign = span.style.verticalAlign;\n  return {\n    forChild: lexicalNode => {\n      if (!$isTextNode(lexicalNode)) {\n        return lexicalNode;\n      }\n\n      if (hasBoldFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n\n      if (hasLinethroughTextDecoration) {\n        lexicalNode.toggleFormat('strikethrough');\n      }\n\n      if (hasItalicFontStyle) {\n        lexicalNode.toggleFormat('italic');\n      }\n\n      if (hasUnderlineTextDecoration) {\n        lexicalNode.toggleFormat('underline');\n      }\n\n      if (verticalAlign === 'sub') {\n        lexicalNode.toggleFormat('subscript');\n      }\n\n      if (verticalAlign === 'super') {\n        lexicalNode.toggleFormat('superscript');\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode; // Google Docs wraps all copied HTML in a <b> with font-weight normal\n\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nconst preParentCache = new WeakMap();\n\nfunction isNodePre(node) {\n  return node.nodeName === 'PRE' || node.nodeType === DOM_ELEMENT_TYPE && node.style.whiteSpace.startsWith('pre');\n}\n\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n\n  const resultNode = cached === undefined ? parent : cached;\n\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n\n  return resultNode;\n}\n\nfunction convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n\n  if (!(parentDom !== null)) {\n    throw Error(`Expected parentElement of Text not to be null`);\n  }\n\n  let textContent = domNode_.textContent || ''; // No collapse and preserve segment break for pre, pre-wrap and pre-line\n\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n\n    return {\n      node: nodes\n    };\n  }\n\n  textContent = textContent.replace(/\\r?\\n|\\t/gm, ' ').replace('\\r', '').replace(/\\s+/g, ' ');\n\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n\n      if (previousTextContent.length > 0) {\n        if (previousTextContent.match(/(?:\\s|\\r?\\n|\\t)$/)) {\n          textContent = textContent.slice(1);\n        }\n\n        isStartOfLine = false;\n        break;\n      }\n    }\n\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^[\\s|\\r?\\n|\\t]+/, '');\n\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n\n  return {\n    node: $createTextNode(textContent)\n  };\n}\n\nconst inlineParents = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, 'i');\n\nfunction findTextInLine(text, forward) {\n  let node = text; // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    let sibling;\n\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n\n      if (parentElement === null) {\n        return null;\n      }\n\n      node = parentElement;\n    }\n\n    node = sibling;\n\n    if (node.nodeType === DOM_ELEMENT_TYPE) {\n      const display = node.style.display;\n\n      if (display === '' && node.nodeName.match(inlineParents) === null || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n\n    let descendant = node;\n\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n\n    if (node.nodeType === DOM_TEXT_TYPE) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\n\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\n\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !lexicalNode.hasFormat(format)) {\n        lexicalNode.toggleFormat(format);\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n\n  static clone(node) {\n    const newNode = new TabNode(node.__key); // TabNode __text can be either '\\t' or ''. insertText will remove the empty Node\n\n    newNode.__text = node.__text;\n    newNode.__format = node.__format;\n    newNode.__style = node.__style;\n    return newNode;\n  }\n\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n\n  static importDOM() {\n    return null;\n  }\n\n  static importJSON(serializedTabNode) {\n    const node = $createTabNode();\n    node.setFormat(serializedTabNode.format);\n    node.setStyle(serializedTabNode.style);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'tab',\n      version: 1\n    };\n  }\n\n  setTextContent(_text) {\n    {\n      throw Error(`TabNode does not support setTextContent`);\n    }\n  }\n\n  setDetail(_detail) {\n    {\n      throw Error(`TabNode does not support setDetail`);\n    }\n  }\n\n  setMode(_type) {\n    {\n      throw Error(`TabNode does not support setMode`);\n    }\n  }\n\n  canInsertTextBefore() {\n    return false;\n  }\n\n  canInsertTextAfter() {\n    return false;\n  }\n\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass Point {\n  constructor(key, offset, type) {\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n\n    return aNode.isBefore(bNode);\n  }\n\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n\n    return node;\n  }\n\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n\n      if (selection !== null) {\n        selection._cachedNodes = null;\n        selection.dirty = true;\n      }\n    }\n  }\n\n}\n\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\n\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n\n  point.set(key, offset, type);\n}\n\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\n\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target); // Fix the end point offset if it refers to the same element as start,\n    // as we've now inserted another element before it. Note that we only\n    // do it if selection is not collapsed as otherwise it'll transfer\n    // both focus and anchor to the text node below\n\n    if (end.type === 'element' && end.key === start.key && end.offset !== start.offset) {\n      end.set(end.key, end.offset + 1, 'element');\n    }\n  } // Transfer the element point to a text point.\n\n\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n\n  start.set(textNode.__key, 0, 'text');\n}\n\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\n\nclass NodeSelection {\n  constructor(objects) {\n    this.dirty = false;\n    this._nodes = objects;\n    this._cachedNodes = null;\n  }\n\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n\n  add(key) {\n    this.dirty = true;\n\n    this._nodes.add(key);\n\n    this._cachedNodes = null;\n  }\n\n  delete(key) {\n    this.dirty = true;\n\n    this._nodes.delete(key);\n\n    this._cachedNodes = null;\n  }\n\n  clear() {\n    this.dirty = true;\n\n    this._nodes.clear();\n\n    this._cachedNodes = null;\n  }\n\n  has(key) {\n    return this._nodes.has(key);\n  }\n\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n\n  extract() {\n    return this.getNodes();\n  }\n\n  insertRawText(text) {// Do nothing?\n  }\n\n  insertText() {// Do nothing?\n  }\n\n  insertNodes(nodes, selectStart) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd; // Insert nodes\n\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n\n    selectionAtEnd.insertNodes(nodes, selectStart); // Remove selected nodes\n\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n\n    return true;\n  }\n\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n\n    const objects = this._nodes;\n    const nodes = [];\n\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n\n    return nodes;\n  }\n\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n\n    return textContent;\n  }\n\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass GridSelection {\n  constructor(gridKey, anchor, focus) {\n    this.gridKey = gridKey;\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n\n  is(selection) {\n    if (!DEPRECATED_$isGridSelection(selection)) {\n      return false;\n    }\n\n    return this.gridKey === selection.gridKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n\n  set(gridKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.gridKey = gridKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n\n  clone() {\n    return new GridSelection(this.gridKey, this.anchor, this.focus);\n  }\n\n  isCollapsed() {\n    return false;\n  }\n\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n\n  extract() {\n    return this.getNodes();\n  }\n\n  insertRawText(text) {// Do nothing?\n  }\n\n  insertText() {// Do nothing?\n  }\n\n  insertNodes(nodes, selectStart) {\n    const focusNode = this.focus.getNode();\n    const selection = $normalizeSelection(focusNode.select(0, focusNode.getChildrenSize()));\n    return selection.insertNodes(nodes, selectStart);\n  } // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n\n\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n\n    if (!(anchorCellNode !== null)) {\n      throw Error(`getNodes: expected to find AnchorNode`);\n    }\n\n    const anchorCellNodeIndex = anchorCellNode.getIndexWithinParent();\n    const anchorCelRoweIndex = anchorCellNode.getParentOrThrow().getIndexWithinParent();\n    const focusCellNode = $getNodeByKey(this.focus.key);\n\n    if (!(focusCellNode !== null)) {\n      throw Error(`getNodes: expected to find FocusNode`);\n    }\n\n    const focusCellNodeIndex = focusCellNode.getIndexWithinParent();\n    const focusCellRowIndex = focusCellNode.getParentOrThrow().getIndexWithinParent();\n    const startX = Math.min(anchorCellNodeIndex, focusCellNodeIndex);\n    const stopX = Math.max(anchorCellNodeIndex, focusCellNodeIndex);\n    const startY = Math.min(anchorCelRoweIndex, focusCellRowIndex);\n    const stopY = Math.max(anchorCelRoweIndex, focusCellRowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n\n    const anchorNode = this.anchor.getNode();\n    const focusNode = this.focus.getNode();\n    const anchorCell = $findMatchingParent(anchorNode, DEPRECATED_$isGridCellNode); // todo replace with triplet\n\n    const focusCell = $findMatchingParent(focusNode, DEPRECATED_$isGridCellNode);\n\n    if (!DEPRECATED_$isGridCellNode(anchorCell)) {\n      throw Error(`Expected GridSelection anchor to be (or a child of) GridCellNode`);\n    }\n\n    if (!DEPRECATED_$isGridCellNode(focusCell)) {\n      throw Error(`Expected GridSelection focus to be (or a child of) GridCellNode`);\n    }\n\n    const anchorRow = anchorCell.getParent();\n\n    if (!DEPRECATED_$isGridRowNode(anchorRow)) {\n      throw Error(`Expected anchorCell to have a parent GridRowNode`);\n    }\n\n    const gridNode = anchorRow.getParent();\n\n    if (!DEPRECATED_$isGridNode(gridNode)) {\n      throw Error(`Expected tableNode to have a parent GridNode`);\n    } // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing GridSelection and moving the logic to the plugin would make\n    // this possible.\n\n\n    const [map, cellAMap, cellBMap] = DEPRECATED_$computeGridMap(gridNode, anchorCell, focusCell);\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n    let exploredMinColumn = minColumn;\n    let exploredMinRow = minRow;\n    let exploredMaxColumn = minColumn;\n    let exploredMaxRow = minRow;\n\n    function expandBoundary(mapValue) {\n      const {\n        cell,\n        startColumn: cellStartColumn,\n        startRow: cellStartRow\n      } = mapValue;\n      minColumn = Math.min(minColumn, cellStartColumn);\n      minRow = Math.min(minRow, cellStartRow);\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n    }\n\n    while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n      if (minColumn < exploredMinColumn) {\n        // Expand on the left\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const previousColumn = exploredMinColumn - 1;\n\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\n        }\n\n        exploredMinColumn = previousColumn;\n      }\n\n      if (minRow < exploredMinRow) {\n        // Expand on top\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const previousRow = exploredMinRow - 1;\n\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\n        }\n\n        exploredMinRow = previousRow;\n      }\n\n      if (maxColumn > exploredMaxColumn) {\n        // Expand on the right\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const nextColumn = exploredMaxColumn + 1;\n\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\n        }\n\n        exploredMaxColumn = nextColumn;\n      }\n\n      if (maxRow > exploredMaxRow) {\n        // Expand on the bottom\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const nextRow = exploredMaxRow + 1;\n\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\n        }\n\n        exploredMaxRow = nextRow;\n      }\n    }\n\n    const nodes = [gridNode];\n    let lastRow = null;\n\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n\n        if (!DEPRECATED_$isGridRowNode(currentRow)) {\n          throw Error(`Expected GridCellNode parent to be a GridRowNode`);\n        }\n\n        if (currentRow !== lastRow) {\n          nodes.push(currentRow);\n        }\n\n        nodes.push(cell, ...$getChildrenRecursively(cell));\n        lastRow = currentRow;\n      }\n    }\n\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n\n    return nodes;\n  }\n\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n\n    return textContent;\n  }\n\n}\nfunction DEPRECATED_$isGridSelection(x) {\n  return x instanceof GridSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this.format = format;\n    this.style = style;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n\n\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n\n\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n\n\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n\n\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset); // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n\n    let nodes;\n\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n    }\n\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n\n    return nodes;\n  }\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n\n\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n\n\n  getTextContent() {\n    const nodes = this.getNodes();\n\n    if (nodes.length === 0) {\n      return '';\n    }\n\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n\n    return textContent;\n  }\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n\n\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n\n\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n\n\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n\n\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n\n\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n\n\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n\n    this.insertNodes(nodes);\n  }\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection as a new\n   * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.\n   *\n   * @param text the text to insert into the Selection\n   */\n\n\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = this.isCollapsed() || anchor.isBefore(focus);\n    const format = this.format;\n    const style = this.style;\n\n    if (isBefore && anchor.type === 'element') {\n      $transferStartingElementPointToTextPoint(anchor, focus, format, style);\n    } else if (!isBefore && focus.type === 'element') {\n      $transferStartingElementPointToTextPoint(focus, anchor, format, style);\n    }\n\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const firstPoint = isBefore ? anchor : focus;\n    const endPoint = isBefore ? focus : anchor;\n    const startOffset = firstPoint.offset;\n    const endOffset = endPoint.offset;\n    let firstNode = selectedNodes[0];\n\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n\n      prevSibling.select();\n      firstNode = prevSibling;\n\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          } // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n\n\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n\n          return;\n        }\n      }\n\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]); // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode; // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      } // Handle mutations to the last node.\n\n\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n\n          lastNode = lastNode.spliceText(0, endOffset, '');\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      } // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n\n\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement); // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n\n          parent = parent.getParent();\n        }\n      } // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n\n\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      } // Remove all selected nodes that haven't already been removed.\n\n\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n\n\n  removeText() {\n    this.insertText('');\n  }\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   */\n\n\n  formatText(formatType) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType); // When changing format, we should stop composition\n\n      $setCompositionKey(null);\n      return;\n    }\n\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n\n    const selectedTextNodesLength = selectedTextNodes.length;\n\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType); // When changing format, we should stop composition\n\n      $setCompositionKey(null);\n      return;\n    }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset; // In case selection started at the end of text node use next text node\n\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n\n    if (firstNode == null) {\n      return;\n    }\n\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize(); // Single node selected\n\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n\n      if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat); // Update selection only if starts/ends on text node\n\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n\n      this.format = firstNextFormat;\n      return;\n    } // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n\n\n    if (startOffset !== 0) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat); // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize()) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n\n      lastNode.setFormat(lastNextFormat);\n    } // Process all text nodes in between\n\n\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n\n      if (!textNode.isToken()) {\n        const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n        textNode.setFormat(nextFormat);\n      }\n    } // Update selection only if starts/ends on text node\n\n\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n\n    this.format = firstNextFormat | lastNextFormat;\n  }\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accomodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   * @param selectStart - whether or not to select the start after the insertion.\n   * @returns true if the nodes were inserted successfully, false otherwise.\n   */\n\n\n  insertNodes(nodes, selectStart) {\n    // If there is a range selected remove the text in it\n    if (!this.isCollapsed()) {\n      const selectionEnd = this.isBackward() ? this.anchor : this.focus;\n      const nextSibling = selectionEnd.getNode().getNextSibling();\n      const nextSiblingKey = nextSibling ? nextSibling.getKey() : null;\n      const prevSibling = selectionEnd.getNode().getPreviousSibling();\n      const prevSiblingKey = prevSibling ? prevSibling.getKey() : null;\n      this.removeText(); // If the selection has been moved to an adjacent inline element, create\n      // a temporary text node that we can insert the nodes after.\n\n      if (this.isCollapsed() && this.focus.type === 'element') {\n        let textNode;\n\n        if (this.focus.key === nextSiblingKey && this.focus.offset === 0) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertBefore(textNode);\n        } else if (this.focus.key === prevSiblingKey && this.focus.offset === this.focus.getNode().getChildrenSize()) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertAfter(textNode);\n        }\n\n        if (textNode) {\n          this.focus.set(textNode.__key, 0, 'text');\n          this.anchor.set(textNode.__key, 0, 'text');\n        }\n      }\n    }\n\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    const anchorNode = anchor.getNode();\n    let target = anchorNode;\n\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n      const placementNode = element.getChildAtIndex(anchorOffset - 1);\n\n      if (placementNode === null) {\n        target = element;\n      } else {\n        target = placementNode;\n      }\n    }\n\n    const siblings = []; // Get all remaining text node siblings in this element so we can\n    // append them after the last node we're inserting.\n\n    const nextSiblings = anchorNode.getNextSiblings();\n    const topLevelElement = $isRootOrShadowRoot(anchorNode) ? null : anchorNode.getTopLevelElementOrThrow();\n\n    if ($isTextNode(anchorNode)) {\n      const textContent = anchorNode.getTextContent();\n      const textContentLength = textContent.length;\n\n      if (anchorOffset === 0 && textContentLength !== 0) {\n        const prevSibling = anchorNode.getPreviousSibling();\n\n        if (prevSibling !== null) {\n          target = prevSibling;\n        } else {\n          target = anchorNode.getParentOrThrow();\n        }\n\n        siblings.push(anchorNode);\n      } else if (anchorOffset === textContentLength) {\n        target = anchorNode;\n      } else if (anchorNode.isToken()) {\n        // Do nothing if we're inside a token node\n        return false;\n      } else {\n        // If we started with a range selected grab the danglingText after the\n        // end of the selection and put it on our siblings array so we can\n        // append it after the last node we're inserting\n        let danglingText;\n        [target, danglingText] = anchorNode.splitText(anchorOffset);\n        siblings.push(danglingText);\n      }\n    }\n\n    const startingNode = target;\n    siblings.push(...nextSiblings);\n    const firstNode = nodes[0];\n    let didReplaceOrMerge = false;\n    let lastNode = null; // Time to insert the nodes!\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (!$isRootOrShadowRoot(target) && !$isDecoratorNode(target) && $isElementNode(node) && !node.isInline()) {\n        // -----\n        // Heuristics for the replacement or merging of elements\n        // -----\n        // If we have an incoming element node as the first node, then we'll need\n        // see if we can merge any descendant leaf nodes into our existing target.\n        // We can do this by finding the first descendant in our node and then we can\n        // pluck it and its parent (siblings included) out and insert them directly\n        // into our target. We only do this for the first node, as we are only\n        // interested in merging with the anchor, which is our target.\n        //\n        // If we apply either the replacement or merging heuristics, we need to be\n        // careful that we're not trying to insert a non-element node into a root node,\n        // so we check if the target's parent after this logic is the root node and if\n        // so we trigger an invariant to ensure this problem is caught in development\n        // and fixed accordingly.\n        if (node.is(firstNode)) {\n          if ($isElementNode(target) && target.isEmpty() && target.canReplaceWith(node)) {\n            target.replace(node);\n            target = node;\n            didReplaceOrMerge = true;\n            continue;\n          } // We may have a node tree where there are many levels, for example with\n          // lists and tables. So let's find the first descendant to try and merge\n          // with. So if we have the target:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //\n          // and we are trying to insert:\n          //\n          // ListNode (3)\n          //   ListItemNode (4)\n          //     Text (5)\n          //   ListItemNode (6)\n          //\n          // The result would be:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //   Text (5)\n          //\n\n\n          const firstDescendant = node.getFirstDescendant();\n\n          if ($isLeafNode(firstDescendant)) {\n            let element = firstDescendant.getParentOrThrow();\n\n            while (element.isInline()) {\n              element = element.getParentOrThrow();\n            }\n\n            const children = element.getChildren();\n            const childrenLength = children.length;\n\n            if ($isElementNode(target)) {\n              let firstChild = target.getFirstChild();\n\n              for (let s = 0; s < childrenLength; s++) {\n                const child = children[s];\n\n                if (firstChild === null) {\n                  target.append(child);\n                } else {\n                  firstChild.insertAfter(child);\n                }\n\n                firstChild = child;\n              }\n            } else {\n              for (let s = childrenLength - 1; s >= 0; s--) {\n                target.insertAfter(children[s]);\n              }\n\n              target = target.getParentOrThrow();\n            }\n\n            lastNode = children[childrenLength - 1];\n            element.remove();\n            didReplaceOrMerge = true;\n\n            if (element.is(node)) {\n              continue;\n            }\n          }\n        }\n\n        if ($isTextNode(target)) {\n          if (topLevelElement === null) {\n            {\n              throw Error(`insertNode: topLevelElement is root node`);\n            }\n          }\n\n          target = topLevelElement;\n        }\n      } else if (didReplaceOrMerge && !$isElementNode(node) && !$isDecoratorNode(node) && $isRootOrShadowRoot(target.getParent())) {\n        {\n          throw Error(`insertNodes: cannot insert a non-element into a root node`);\n        }\n      }\n\n      didReplaceOrMerge = false;\n\n      if ($isElementNode(target) && !target.isInline()) {\n        lastNode = node;\n\n        if ($isDecoratorNode(node) && !node.isInline()) {\n          target = target.insertAfter(node, false);\n        } else if (!$isElementNode(node)) {\n          const firstChild = target.getFirstChild();\n\n          if (firstChild !== null) {\n            firstChild.insertBefore(node);\n          } else {\n            target.append(node);\n          }\n\n          target = node;\n        } else {\n          if (!node.canBeEmpty() && node.isEmpty()) {\n            continue;\n          }\n\n          if ($isRootNode(target)) {\n            const placementNode = target.getChildAtIndex(anchorOffset);\n\n            if (placementNode !== null) {\n              placementNode.insertBefore(node);\n            } else {\n              target.append(node);\n            }\n\n            target = node;\n          } else if (node.isInline()) {\n            target.append(node);\n            target = node;\n          } else {\n            target = target.insertAfter(node, false);\n          }\n        }\n      } else if (!$isElementNode(node) || $isElementNode(node) && node.isInline() || $isDecoratorNode(target) && !target.isInline()) {\n        lastNode = node; // when pasting top level node in the middle of paragraph\n        // we need to split paragraph instead of placing it inline\n\n        if ($isRangeSelection(this) && $isDecoratorNode(node) && ($isElementNode(target) || $isTextNode(target)) && !node.isInline()) {\n          let splitNode;\n          let splitOffset;\n\n          if ($isTextNode(target)) {\n            splitNode = target.getParentOrThrow();\n            const [textNode] = target.splitText(anchorOffset);\n            splitOffset = textNode.getIndexWithinParent() + 1;\n          } else {\n            splitNode = target;\n            splitOffset = anchorOffset;\n          }\n\n          const [, rightTree] = $splitNode(splitNode, splitOffset);\n          target = rightTree.insertBefore(node);\n        } else {\n          target = target.insertAfter(node, false);\n        }\n      } else {\n        const nextTarget = target.getParentOrThrow(); // if we're inserting an Element after a LineBreak, we want to move the target to the parent\n        // and remove the LineBreak so we don't have empty space.\n\n        if ($isLineBreakNode(target)) {\n          target.remove();\n        }\n\n        target = nextTarget; // Re-try again with the target being the parent\n\n        i--;\n        continue;\n      }\n    }\n\n    if (selectStart) {\n      // Handle moving selection to start for all nodes\n      if ($isTextNode(startingNode)) {\n        startingNode.select();\n      } else {\n        const prevSibling = target.getPreviousSibling();\n\n        if ($isTextNode(prevSibling)) {\n          prevSibling.select();\n        } else {\n          const index = target.getIndexWithinParent();\n          target.getParentOrThrow().select(index, index);\n        }\n      }\n    }\n\n    if ($isElementNode(target)) {\n      // If the last node to be inserted was a text node,\n      // then we should attempt to move selection to that.\n      const lastChild = $isTextNode(lastNode) ? lastNode : $isElementNode(lastNode) && lastNode.isInline() ? lastNode.getLastDescendant() : target.getLastDescendant();\n\n      if (!selectStart) {\n        // Handle moving selection to end for elements\n        if (lastChild === null) {\n          target.select();\n        } else if ($isTextNode(lastChild)) {\n          if (lastChild.getTextContent() === '') {\n            lastChild.selectPrevious();\n          } else {\n            lastChild.select();\n          }\n        } else {\n          lastChild.selectNext();\n        }\n      }\n\n      if (siblings.length !== 0) {\n        const originalTarget = target;\n\n        for (let i = siblings.length - 1; i >= 0; i--) {\n          const sibling = siblings[i];\n          const prevParent = sibling.getParentOrThrow();\n\n          if ($isElementNode(target) && !$isBlockElementNode(sibling) && !($isDecoratorNode(sibling) && ( // Note: We are only looking for decorators that are inline and not isolated.\n          !sibling.isInline() || sibling.isIsolated()))) {\n            if (originalTarget === target) {\n              target.append(sibling);\n            } else {\n              target.insertBefore(sibling);\n            }\n\n            target = sibling;\n          } else if (!$isElementNode(target) && !$isBlockElementNode(sibling)) {\n            target.insertBefore(sibling);\n            target = sibling;\n          } else {\n            if ($isElementNode(sibling) && !sibling.canInsertAfter(target)) {\n              // @ts-ignore The clone method does exist on the constructor.\n              const prevParentClone = prevParent.constructor.clone(prevParent);\n\n              if (!$isElementNode(prevParentClone)) {\n                {\n                  throw Error(`insertNodes: cloned parent clone is not an element`);\n                }\n              }\n\n              prevParentClone.append(sibling);\n              target.insertAfter(prevParentClone);\n            } else {\n              target.insertAfter(sibling);\n            }\n          } // Check if the prev parent is empty, as it might need\n          // removing.\n\n\n          if (prevParent.isEmpty() && !prevParent.canBeEmpty()) {\n            prevParent.remove();\n          }\n        }\n      }\n    } else if (!selectStart) {\n      // Handle moving selection to end for other nodes\n      if ($isTextNode(target)) {\n        target.select();\n      } else {\n        const element = target.getParentOrThrow();\n        const index = target.getIndexWithinParent() + 1;\n        element.select(index, index);\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   */\n\n\n  insertParagraph() {\n    if (!this.isCollapsed()) {\n      this.removeText();\n    }\n\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    let currentElement;\n    let nodesToMove = [];\n    let siblingsToMove = [];\n\n    if (anchor.type === 'text') {\n      const anchorNode = anchor.getNode();\n      nodesToMove = anchorNode.getNextSiblings().reverse();\n      currentElement = anchorNode.getParentOrThrow();\n      const isInline = currentElement.isInline();\n      const textContentLength = isInline ? currentElement.getTextContentSize() : anchorNode.getTextContentSize();\n\n      if (anchorOffset === 0) {\n        nodesToMove.push(anchorNode);\n      } else {\n        if (isInline) {\n          // For inline nodes, we want to move all the siblings to the new paragraph\n          // if selection is at the end, we just move the siblings. Otherwise, we also\n          // split the text node and add that and it's siblings below.\n          siblingsToMove = currentElement.getNextSiblings();\n        }\n\n        if (anchorOffset !== textContentLength) {\n          if (!isInline || anchorOffset !== anchorNode.getTextContentSize()) {\n            const [, splitNode] = anchorNode.splitText(anchorOffset);\n            nodesToMove.push(splitNode);\n          }\n        }\n      }\n    } else {\n      currentElement = anchor.getNode();\n\n      if ($isRootOrShadowRoot(currentElement)) {\n        const paragraph = $createParagraphNode();\n        const child = currentElement.getChildAtIndex(anchorOffset);\n        paragraph.select();\n\n        if (child !== null) {\n          child.insertBefore(paragraph, false);\n        } else {\n          currentElement.append(paragraph);\n        }\n\n        return;\n      }\n\n      nodesToMove = currentElement.getChildren().slice(anchorOffset).reverse();\n    }\n\n    const nodesToMoveLength = nodesToMove.length;\n\n    if (anchorOffset === 0 && nodesToMoveLength > 0 && currentElement.isInline()) {\n      const parent = currentElement.getParentOrThrow();\n      const newElement = parent.insertNewAfter(this, false);\n\n      if ($isElementNode(newElement)) {\n        const children = parent.getChildren();\n\n        for (let i = 0; i < children.length; i++) {\n          newElement.append(children[i]);\n        }\n      }\n\n      return;\n    }\n\n    const newElement = currentElement.insertNewAfter(this, false);\n\n    if (newElement === null) {\n      // Handle as a line break insertion\n      this.insertLineBreak();\n    } else if ($isElementNode(newElement)) {\n      // If we're at the beginning of the current element, move the new element to be before the current element\n      const currentElementFirstChild = currentElement.getFirstChild();\n      const isBeginning = anchorOffset === 0 && (currentElement.is(anchor.getNode()) || currentElementFirstChild && currentElementFirstChild.is(anchor.getNode()));\n\n      if (isBeginning && nodesToMoveLength > 0) {\n        currentElement.insertBefore(newElement);\n        return;\n      }\n\n      let firstChild = null;\n      const siblingsToMoveLength = siblingsToMove.length;\n      const parent = newElement.getParentOrThrow(); // For inline elements, we append the siblings to the parent.\n\n      if (siblingsToMoveLength > 0) {\n        for (let i = 0; i < siblingsToMoveLength; i++) {\n          const siblingToMove = siblingsToMove[i];\n          parent.append(siblingToMove);\n        }\n      }\n\n      if (nodesToMoveLength !== 0) {\n        for (let i = 0; i < nodesToMoveLength; i++) {\n          const nodeToMove = nodesToMove[i];\n\n          if (firstChild === null) {\n            newElement.append(nodeToMove);\n          } else {\n            firstChild.insertBefore(nodeToMove);\n          }\n\n          firstChild = nodeToMove;\n        }\n      }\n\n      if (!newElement.canBeEmpty() && newElement.getChildrenSize() === 0) {\n        newElement.selectPrevious();\n        newElement.remove();\n      } else {\n        newElement.selectStart();\n      }\n    }\n  }\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   *\n   * @param selectStart whether or not to select the start of the insertion range after the operation completes.\n   */\n\n\n  insertLineBreak(selectStart) {\n    const lineBreakNode = $createLineBreakNode();\n    const anchor = this.anchor;\n\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n\n      if ($isRootNode(element)) {\n        this.insertParagraph();\n      }\n    }\n\n    if (selectStart) {\n      this.insertNodes([lineBreakNode], true);\n    } else {\n      if (this.insertNodes([lineBreakNode])) {\n        lineBreakNode.selectNext(0, 0);\n      }\n    }\n  }\n  /**\n   * Returns the character-based offsets of the Selection, accounting for non-text Points\n   * by using the children size or text content.\n   *\n   * @returns the character offsets for the Selection\n   */\n\n\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n\n\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n\n      return [firstNode];\n    }\n\n    const isBefore = anchor.isBefore(focus);\n\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n\n    return selectedNodes;\n  }\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n\n\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move'; // Handle the selection movement around decorators.\n\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n\n          if (!isBackward) {\n            offset++;\n          }\n        }\n\n        focus.set(elementKey, offset, 'element');\n\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n\n        return;\n      }\n    }\n\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n\n    if (!domSelection) {\n      return;\n    }\n\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement; // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    } // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n\n\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity); // Guard against no ranges\n\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0); // Apply the DOM selection to our Lexical selection.\n\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        } // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n\n\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const focus = this.focus;\n      let anchorNode = anchor.getNode();\n\n      if (!isBackward && ( // Delete forward handle case\n      anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n        const parent = anchorNode.getParent();\n        const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n\n        if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n          return;\n        }\n      } // Handle the deletion around decorators.\n\n\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n\n        return;\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n\n      this.modify('extend', isBackward, 'character');\n\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n\n    this.removeText();\n\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      if (this.anchor.type === 'text') {\n        this.modify('extend', isBackward, 'lineboundary');\n      } // If selection is extended to cover text edge then extend it one character more\n      // to delete its parent element. Otherwise text content will be deleted but empty\n      // parent node will remain\n\n\n      const endPoint = isBackward ? this.focus : this.anchor;\n\n      if (endPoint.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n    }\n\n    this.removeText();\n  }\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      this.modify('extend', isBackward, 'word');\n    }\n\n    this.removeText();\n  }\n\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\n\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n\n  if (point.type === 'text') {\n    return offset;\n  }\n\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\n\nfunction getCharacterOffsets(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\n\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\n\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\n\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\n\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n\n      break;\n    }\n  }\n\n  const nextTextContent = split.join('').trim();\n\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\n\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\n\nfunction internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode; // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false; // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length; // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n\n    if (childDOM === editor._blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (editor._blockCursorElement !== null) {\n      resolvedOffset--;\n    }\n\n    resolvedNode = getNodeFromDOM(childDOM);\n\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = getNodeFromDOM(dom); // Ensure resolvedElement is actually a element.\n\n      if (resolvedElement === null) {\n        return null;\n      }\n\n      if ($isElementNode(resolvedElement)) {\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n\n          if (descendant === null) {\n            resolvedElement = child;\n            resolvedOffset = 0;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n        }\n\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent(); // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = getNodeFromDOM(dom);\n  }\n\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\n\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize(); // @ts-expect-error: intentional\n\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0; // @ts-expect-error: intentional\n\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\n\nfunction normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus); // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n\n    const editor = getActiveEditor();\n\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\n\nfunction internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n\n  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n\n  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = getNodeFromDOM(anchorDOM);\n    const focusNode = getNodeFromDOM(focusDOM); // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  } // Handle normalization of selection when it is at the boundaries.\n\n\n  normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\n\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n} // This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction DEPRECATED_$createGridSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new GridSelection('root', anchor, focus);\n}\nfunction internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n\n  if ($isNodeSelection(lastSelection) || DEPRECATED_$isGridSelection(lastSelection)) {\n    return lastSelection.clone();\n  }\n\n  return internalCreateRangeSelection(lastSelection, domSelection, editor);\n}\nfunction internalCreateRangeSelection(lastSelection, domSelection, editor) {\n  const windowObj = editor._window;\n\n  if (windowObj === null) {\n    return null;\n  } // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n\n  const windowEvent = windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcesssingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  } // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n\n\n  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n\n  const parentKey = parentNode.__key; // Single node. We shift selection but never redimension it\n\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element'); // The new selection might point to text nodes, try to resolve them\n\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  } // The new selection might point to text nodes, try to resolve them\n\n\n  $updateSelectionResolveTextNodes(selection);\n}\n\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n\n    return;\n  }\n\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\n\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement; // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n\n    return;\n  }\n\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  } // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n\n\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  } // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n\n\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n\n    if (anchor.type !== 'element') {\n      return;\n    }\n  } // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n\n\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  } catch (error) {// If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n  }\n\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n\n    if (selectionTarget !== null) {\n      let selectionRect;\n\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes, selectStart) {\n  let selection = $getSelection() || $getPreviousSelection();\n\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n\n  return selection.insertNodes(nodes, selectStart);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n\n  if (selection === null) {\n    return '';\n  }\n\n  return selection.getTextContent();\n}\nfunction DEPRECATED_$computeGridMap(grid, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n\n  function write(startRow, startColumn, cell) {\n    const value = {\n      cell,\n      startColumn,\n      startRow\n    };\n    const rowSpan = cell.__rowSpan;\n    const colSpan = cell.__colSpan;\n\n    for (let i = 0; i < rowSpan; i++) {\n      if (tableMap[startRow + i] === undefined) {\n        tableMap[startRow + i] = [];\n      }\n\n      for (let j = 0; j < colSpan; j++) {\n        tableMap[startRow + i][startColumn + j] = value;\n      }\n    }\n\n    if (cellA.is(cell)) {\n      cellAValue = value;\n    }\n\n    if (cellB.is(cell)) {\n      cellBValue = value;\n    }\n  }\n\n  function isEmpty(row, column) {\n    return tableMap[row] === undefined || tableMap[row][column] === undefined;\n  }\n\n  const gridChildren = grid.getChildren();\n\n  for (let i = 0; i < gridChildren.length; i++) {\n    const row = gridChildren[i];\n\n    if (!DEPRECATED_$isGridRowNode(row)) {\n      throw Error(`Expected GridNode children to be GridRowNode`);\n    }\n\n    const rowChildren = row.getChildren();\n    let j = 0;\n\n    for (const cell of rowChildren) {\n      if (!DEPRECATED_$isGridCellNode(cell)) {\n        throw Error(`Expected GridRowNode children to be GridCellNode`);\n      }\n\n      while (!isEmpty(i, j)) {\n        j++;\n      }\n\n      write(i, j, cell);\n      j += cell.__colSpan;\n    }\n  }\n\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Grid`);\n  }\n\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Grid`);\n  }\n\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction DEPRECATED_$getNodeTriplet(source) {\n  let cell;\n\n  if (source instanceof DEPRECATED_GridCellNode) {\n    cell = source;\n  } else if (source instanceof LexicalNode) {\n    const cell_ = $findMatchingParent(source, DEPRECATED_$isGridCellNode);\n\n    if (!DEPRECATED_$isGridCellNode(cell_)) {\n      throw Error(`Expected to find a parent GridCellNode`);\n    }\n\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), DEPRECATED_$isGridCellNode);\n\n    if (!DEPRECATED_$isGridCellNode(cell_)) {\n      throw Error(`Expected to find a parent GridCellNode`);\n    }\n\n    cell = cell_;\n  }\n\n  const row = cell.getParent();\n\n  if (!DEPRECATED_$isGridRowNode(row)) {\n    throw Error(`Expected GridCellNode to have a parent GridRowNode`);\n  }\n\n  const grid = row.getParent();\n\n  if (!DEPRECATED_$isGridNode(grid)) {\n    throw Error(`Expected GridRowNode to have a parent GridNode`);\n  }\n\n  return [cell, row, grid];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\n    }\n  }\n\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\n    }\n  }\n\n  return activeEditor;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n\n  const transformsArrLength = transformsArr.length;\n\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\n\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined && // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\n\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\n\n\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n\n        dirtyLeaves.add(nodeKey);\n      }\n\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size; // We want to prioritize node transforms over element transforms\n\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    } // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n\n\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n\n      const node = nodeMap.get(nodeKey);\n\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\n\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\n\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n\n  const nodeClass = registeredNode.klass;\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n\n  return node;\n}\n\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n\n    if (updateFn) {\n      updateFn();\n    } // Make the editorState immutable\n\n\n    editorState._readOnly = true;\n\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n\n  return editorState;\n} // This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = null;\n\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\n\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\n\nfunction commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n\n  if (pendingEditorState === null) {\n    return;\n  } // ======\n  // Reconciliation has started.\n  // ======\n\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false; // We don't want updates to sync block the reconciliation.\n\n    editor._updating = true;\n\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      } // Reset editor and restore incoming editor state to the DOM\n\n\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n\n      Object.freeze(pendingSelection);\n    }\n  }\n\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n\n    editor._cloneNotNeeded.clear();\n\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n\n  $garbageCollectDetachedDecorators(editor, pendingEditorState); // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window); // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n\n  if (editor._editable && // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n\n\n  const pendingDecorators = editor._pendingDecorators;\n\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  } // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n\n\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  triggerEnqueuedUpdates(editor);\n}\n\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\n\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags\n      });\n    }\n  }\n}\n\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n\n  const editors = getEditorsToPropagate(editor);\n\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      beginUpdate(editor, updateFn, options);\n    }\n  }\n}\n\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\n\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false; // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      let tag;\n\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        tag = options.tag;\n\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n\n        if (tag) {\n          editor._updateTags.add(tag);\n        }\n      }\n\n      nextUpdateFn();\n    }\n  }\n\n  return skipTransforms;\n}\n\nfunction beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n  let discrete = false;\n\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection != null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = internalCreateSelection(editor);\n      }\n    }\n\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n\n    const endingCompositionKey = editor._compositionKey;\n\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n\n    const pendingSelection = pendingEditorState._selection;\n\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    } // Restore existing editor state to the DOM\n\n\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n\n    editor._cloneNotNeeded.clear();\n\n    editor._dirtyLeaves = new Set();\n\n    editor._dirtyElements.clear();\n\n    commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);\n\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\n\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\n\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n  }\n\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n\n  isIsolated() {\n    return false;\n  }\n\n  isInline() {\n    return true;\n  }\n\n  isKeyboardSelectable() {\n    return true;\n  }\n\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__indent = 0;\n    this.__dir = null;\n  }\n\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n\n    return children;\n  }\n\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n\n    return children;\n  }\n\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n\n      child = child.getNextSibling();\n    }\n\n    return textNodes;\n  }\n\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getFirstChild();\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      break;\n    }\n\n    return node;\n  }\n\n  getLastDescendant() {\n    let node = this.getLastChild();\n\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getLastChild();\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      break;\n    }\n\n    return node;\n  }\n\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length; // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n\n    return firstChild;\n  }\n\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n\n    return lastChild;\n  }\n\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n\n        node = node.getNextSibling();\n        i++;\n      }\n\n      return null;\n    }\n\n    node = this.getLastChild();\n    i = size - 1;\n\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n\n      node = node.getPreviousSibling();\n      i--;\n    }\n\n    return null;\n  }\n\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n\n    return textContent;\n  }\n\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n\n    return textContentSize;\n  }\n\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n\n    return false;\n  } // Mutators\n\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n\n    const key = this.__key;\n\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n\n    return selection;\n  }\n\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n\n    if ($isElementNode(firstNode) || $isTextNode(firstNode)) {\n      return firstNode.select(0, 0);\n    } // Decorator or LineBreak\n\n\n    if (firstNode !== null) {\n      return firstNode.selectPrevious();\n    }\n\n    return this.select(0, 0);\n  }\n\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      return lastNode.select();\n    } // Decorator or LineBreak\n\n\n    if (lastNode !== null) {\n      return lastNode.selectNext();\n    }\n\n    return this.select();\n  }\n\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n\n    let prevNode = nodeBeforeRange;\n\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n\n      const writableNodeToInsert = nodeToInsert.getWritable();\n\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      } // Set child parent to self\n\n\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n\n    writableSelf.__size = newSize; // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        } // Cleanup if node can't be empty\n\n\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n\n    return writableSelf;\n  } // JSON serialization\n\n\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'element',\n      version: 1\n    };\n  } // These are intended to be extends for specific element heuristics.\n\n\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n\n\n  collapseAtStart(selection) {\n    return false;\n  }\n\n  excludeFromCopy(destination) {\n    return false;\n  } // TODO 0.10 deprecate\n\n\n  canExtractContents() {\n    return true;\n  }\n\n  canReplaceWith(replacement) {\n    return true;\n  }\n\n  canInsertAfter(node) {\n    return true;\n  }\n\n  canBeEmpty() {\n    return true;\n  }\n\n  canInsertTextBefore() {\n    return true;\n  }\n\n  canInsertTextAfter() {\n    return true;\n  }\n\n  isInline() {\n    return false;\n  } // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n\n\n  isShadowRoot() {\n    return false;\n  }\n\n  canMergeWith(node) {\n    return false;\n  }\n\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\n\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n\n  while (node) {\n    const nodeKey = node.__key;\n\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n\n    node = node.getParent();\n  }\n\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n  static getType() {\n    return 'root';\n  }\n\n  static clone() {\n    return new RootNode();\n  }\n\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n\n  getTextContent() {\n    const cachedText = this.__cachedText;\n\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n\n    return super.getTextContent();\n  }\n\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  } // View\n\n\n  updateDOM(prevNode, dom) {\n    return false;\n  } // Mutate\n\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n\n    return super.append(...nodesToAppend);\n  }\n\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    const node = $getRoot();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'root',\n      version: 1\n    };\n  }\n\n  collapseAtStart() {\n    return true;\n  }\n\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n\n  const pendingSelection = editorState._selection; // Check if we need to update because of changes in selection\n\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\n\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n\n  const serializedChildren = serializedNode.children;\n\n  if ($isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n\n    const children = node.getChildren();\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  } // @ts-expect-error\n\n\n  return serializedNode;\n}\n\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n\n  read(callbackFn) {\n    return readEditorState(this, callbackFn);\n  }\n\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n\n  toJSON() {\n    return readEditorState(this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  } // View\n\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element && this.isEmpty()) {\n      element.append(document.createElement('br'));\n    }\n\n    if (element) {\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n\n      if (direction) {\n        element.dir = direction;\n      }\n\n      const indent = this.getIndent();\n\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML, but\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\n        element.style.textIndent = `${indent * 20}px`;\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createParagraphNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'paragraph',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter(_, restoreSelection) {\n    const newElement = $createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart() {\n    const children = this.getChildren(); // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n\n      const prevSibling = this.getPreviousSibling();\n\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nfunction convertParagraphElement(element) {\n  const node = $createParagraphNode();\n\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    const indent = parseInt(element.style.textIndent, 10) / 20;\n\n    if (indent > 0) {\n      node.setIndent(indent);\n    }\n  }\n\n  return {\n    node\n  };\n}\n\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n\n  editor._cloneNotNeeded.clear();\n\n  editor._dirtyLeaves = new Set();\n\n  editor._dirtyElements.clear();\n\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  } // Remove all the DOM nodes from the root element\n\n\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\n\nfunction initializeConversionCache(nodes) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM != null ? node.klass.importDOM.bind(node.klass) : null;\n\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n\n    handledConversions.add(importDOM);\n    const map = importDOM();\n\n    if (map !== null) {\n      Object.keys(map).forEach(key => {\n        let currentCache = conversionCache.get(key);\n\n        if (currentCache === undefined) {\n          currentCache = [];\n          conversionCache.set(key, currentCache);\n        }\n\n        currentCache.push(map[key]);\n      });\n    }\n  });\n  return conversionCache;\n}\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\n\n\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ...(config.nodes || [])];\n  const onError = config.onError;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replacementClass = null;\n      let replacementKlass = null;\n\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replacementClass = options.with;\n        replacementKlass = options.withKlass ? options.withKlass : null;\n      } // Ensure custom nodes implement required methods.\n\n\n      {\n        const name = klass.name;\n\n        if (name !== 'RootNode') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n\n          if ( // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') && // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n\n          if (proto instanceof DecoratorNode) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n\n          if ( // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n\n          if ( // eslint-disable-next-line no-prototype-builtins\n          !proto.hasOwnProperty('exportJSON')) {\n            console.warn(`${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n\n      registeredNodes.set(type, {\n        klass,\n        replace: replacementClass,\n        replaceWithKlass: replacementKlass,\n        transforms\n      });\n    }\n  }\n\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes), isEditable);\n\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n\n  return editor;\n}\nclass LexicalEditor {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor; // The root element associated with this editor\n\n    this._rootElement = null; // The current editor state\n\n    this._editorState = editorState; // Handling of drafts and updates\n\n    this._pendingEditorState = null; // Used to help co-ordinate selection and events\n\n    this._compositionKey = null;\n    this._deferred = []; // Used during reconciliation\n\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false; // Listeners\n\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    }; // Commands\n\n    this._commands = new Map(); // Editor configuration for theme/context.\n\n    this._config = config; // Mapping of types to their nodes\n\n    this._nodes = nodes; // React node decorators for portals\n\n    this._decorators = {};\n    this._pendingDecorators = null; // Used to optimize reconciliation\n\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set(); // Handling of DOM mutations\n\n    this._observer = null; // Used for identifying owning editors\n\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n\n\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched, subject to priority. Listeners that run at a higher priority can \"intercept\"\n   * commands and prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners registered at the same priority level will run deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n\n    const commandsMap = this._commands;\n\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n\n    const listenersInPriorityOrder = commandsMap.get(command);\n\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerMutationListener(klass, listener) {\n    const registeredNode = this._nodes.get(klass.getType());\n\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klass);\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n  /** @internal */\n\n\n  registerNodeTransformToKlass(klass, listener) {\n    const type = klass.getType();\n\n    const registeredNode = this._nodes.get(type);\n\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n\n    const transforms = registeredNode.transforms;\n    transforms.add(listener);\n    return registeredNode;\n  }\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n\n    markAllNodesAsDirty(this, klass.getType());\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n\n\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n\n\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload.\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n\n\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n\n\n  getDecorators() {\n    return this._decorators;\n  }\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n\n\n  getRootElement() {\n    return this._rootElement;\n  }\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n\n\n  getKey() {\n    return this._key;\n  }\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n\n\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n\n        this._updateTags.add('history-merge');\n\n        commitPendingUpdates(this); // TODO: remove this flag once we no longer use UEv2 internally\n\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n      } else {\n        // If content editable is unmounted we'll reset editor state back to original\n        // (or pending) editor state since there will be no reconciliation\n        this._editorState = pendingEditorState;\n        this._pendingEditorState = null;\n        this._window = null;\n      }\n\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n\n\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n\n\n  getEditorState() {\n    return this._editorState;\n  }\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n\n\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n\n      commitPendingUpdates(this);\n    }\n\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n\n    this._dirtyElements.set('root', false);\n\n    this._compositionKey = null;\n\n    if (tag != null) {\n      tags.add(tag);\n    }\n\n    commitPendingUpdates(this);\n  }\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserliazation from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n\n\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n\n\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n\n\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n\n          if (callbackFn) {\n            callbackFn();\n          }\n        },\n        tag: 'focus'\n      }); // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n  /**\n   * Removes focus from the editor.\n   */\n\n\n  blur() {\n    const rootElement = this._rootElement;\n\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n\n    const domSelection = getDOMSelection(this._window);\n\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n\n\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n\n\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n\n\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass DEPRECATED_GridCellNode extends ElementNode {\n  /** @internal */\n  constructor(colSpan, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      colSpan: this.__colSpan,\n      rowSpan: this.__rowSpan\n    };\n  }\n\n  getColSpan() {\n    return this.__colSpan;\n  }\n\n  setColSpan(colSpan) {\n    this.getWritable().__colSpan = colSpan;\n    return this;\n  }\n\n  getRowSpan() {\n    return this.__rowSpan;\n  }\n\n  setRowSpan(rowSpan) {\n    this.getWritable().__rowSpan = rowSpan;\n    return this;\n  }\n\n}\nfunction DEPRECATED_$isGridCellNode(node) {\n  return node instanceof DEPRECATED_GridCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridNode extends ElementNode {}\nfunction DEPRECATED_$isGridNode(node) {\n  return node instanceof DEPRECATED_GridNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridRowNode extends ElementNode {}\nfunction DEPRECATED_$isGridRowNode(node) {\n  return node instanceof DEPRECATED_GridRowNode;\n}\n\nexports.$addUpdateTag = $addUpdateTag;\nexports.$applyNodeReplacement = $applyNodeReplacement;\nexports.$copyNode = $copyNode;\nexports.$createLineBreakNode = $createLineBreakNode;\nexports.$createNodeSelection = $createNodeSelection;\nexports.$createParagraphNode = $createParagraphNode;\nexports.$createRangeSelection = $createRangeSelection;\nexports.$createTabNode = $createTabNode;\nexports.$createTextNode = $createTextNode;\nexports.$getAdjacentNode = $getAdjacentNode;\nexports.$getNearestNodeFromDOMNode = $getNearestNodeFromDOMNode;\nexports.$getNearestRootOrShadowRoot = $getNearestRootOrShadowRoot;\nexports.$getNodeByKey = $getNodeByKey;\nexports.$getPreviousSelection = $getPreviousSelection;\nexports.$getRoot = $getRoot;\nexports.$getSelection = $getSelection;\nexports.$getTextContent = $getTextContent;\nexports.$hasAncestor = $hasAncestor;\nexports.$hasUpdateTag = $hasUpdateTag;\nexports.$insertNodes = $insertNodes;\nexports.$isBlockElementNode = $isBlockElementNode;\nexports.$isDecoratorNode = $isDecoratorNode;\nexports.$isElementNode = $isElementNode;\nexports.$isInlineElementOrDecoratorNode = $isInlineElementOrDecoratorNode;\nexports.$isLeafNode = $isLeafNode;\nexports.$isLineBreakNode = $isLineBreakNode;\nexports.$isNodeSelection = $isNodeSelection;\nexports.$isParagraphNode = $isParagraphNode;\nexports.$isRangeSelection = $isRangeSelection;\nexports.$isRootNode = $isRootNode;\nexports.$isRootOrShadowRoot = $isRootOrShadowRoot;\nexports.$isTabNode = $isTabNode;\nexports.$isTextNode = $isTextNode;\nexports.$nodesOfType = $nodesOfType;\nexports.$normalizeSelection__EXPERIMENTAL = $normalizeSelection;\nexports.$parseSerializedNode = $parseSerializedNode;\nexports.$setCompositionKey = $setCompositionKey;\nexports.$setSelection = $setSelection;\nexports.$splitNode = $splitNode;\nexports.BLUR_COMMAND = BLUR_COMMAND;\nexports.CAN_REDO_COMMAND = CAN_REDO_COMMAND;\nexports.CAN_UNDO_COMMAND = CAN_UNDO_COMMAND;\nexports.CLEAR_EDITOR_COMMAND = CLEAR_EDITOR_COMMAND;\nexports.CLEAR_HISTORY_COMMAND = CLEAR_HISTORY_COMMAND;\nexports.CLICK_COMMAND = CLICK_COMMAND;\nexports.COMMAND_PRIORITY_CRITICAL = COMMAND_PRIORITY_CRITICAL;\nexports.COMMAND_PRIORITY_EDITOR = COMMAND_PRIORITY_EDITOR;\nexports.COMMAND_PRIORITY_HIGH = COMMAND_PRIORITY_HIGH;\nexports.COMMAND_PRIORITY_LOW = COMMAND_PRIORITY_LOW;\nexports.COMMAND_PRIORITY_NORMAL = COMMAND_PRIORITY_NORMAL;\nexports.CONTROLLED_TEXT_INSERTION_COMMAND = CONTROLLED_TEXT_INSERTION_COMMAND;\nexports.COPY_COMMAND = COPY_COMMAND;\nexports.CUT_COMMAND = CUT_COMMAND;\nexports.DELETE_CHARACTER_COMMAND = DELETE_CHARACTER_COMMAND;\nexports.DELETE_LINE_COMMAND = DELETE_LINE_COMMAND;\nexports.DELETE_WORD_COMMAND = DELETE_WORD_COMMAND;\nexports.DEPRECATED_$computeGridMap = DEPRECATED_$computeGridMap;\nexports.DEPRECATED_$createGridSelection = DEPRECATED_$createGridSelection;\nexports.DEPRECATED_$getNodeTriplet = DEPRECATED_$getNodeTriplet;\nexports.DEPRECATED_$isGridCellNode = DEPRECATED_$isGridCellNode;\nexports.DEPRECATED_$isGridNode = DEPRECATED_$isGridNode;\nexports.DEPRECATED_$isGridRowNode = DEPRECATED_$isGridRowNode;\nexports.DEPRECATED_$isGridSelection = DEPRECATED_$isGridSelection;\nexports.DEPRECATED_GridCellNode = DEPRECATED_GridCellNode;\nexports.DEPRECATED_GridNode = DEPRECATED_GridNode;\nexports.DEPRECATED_GridRowNode = DEPRECATED_GridRowNode;\nexports.DRAGEND_COMMAND = DRAGEND_COMMAND;\nexports.DRAGOVER_COMMAND = DRAGOVER_COMMAND;\nexports.DRAGSTART_COMMAND = DRAGSTART_COMMAND;\nexports.DROP_COMMAND = DROP_COMMAND;\nexports.DecoratorNode = DecoratorNode;\nexports.ElementNode = ElementNode;\nexports.FOCUS_COMMAND = FOCUS_COMMAND;\nexports.FORMAT_ELEMENT_COMMAND = FORMAT_ELEMENT_COMMAND;\nexports.FORMAT_TEXT_COMMAND = FORMAT_TEXT_COMMAND;\nexports.INDENT_CONTENT_COMMAND = INDENT_CONTENT_COMMAND;\nexports.INSERT_LINE_BREAK_COMMAND = INSERT_LINE_BREAK_COMMAND;\nexports.INSERT_PARAGRAPH_COMMAND = INSERT_PARAGRAPH_COMMAND;\nexports.INSERT_TAB_COMMAND = INSERT_TAB_COMMAND;\nexports.KEY_ARROW_DOWN_COMMAND = KEY_ARROW_DOWN_COMMAND;\nexports.KEY_ARROW_LEFT_COMMAND = KEY_ARROW_LEFT_COMMAND;\nexports.KEY_ARROW_RIGHT_COMMAND = KEY_ARROW_RIGHT_COMMAND;\nexports.KEY_ARROW_UP_COMMAND = KEY_ARROW_UP_COMMAND;\nexports.KEY_BACKSPACE_COMMAND = KEY_BACKSPACE_COMMAND;\nexports.KEY_DELETE_COMMAND = KEY_DELETE_COMMAND;\nexports.KEY_DOWN_COMMAND = KEY_DOWN_COMMAND;\nexports.KEY_ENTER_COMMAND = KEY_ENTER_COMMAND;\nexports.KEY_ESCAPE_COMMAND = KEY_ESCAPE_COMMAND;\nexports.KEY_MODIFIER_COMMAND = KEY_MODIFIER_COMMAND;\nexports.KEY_SPACE_COMMAND = KEY_SPACE_COMMAND;\nexports.KEY_TAB_COMMAND = KEY_TAB_COMMAND;\nexports.LineBreakNode = LineBreakNode;\nexports.MOVE_TO_END = MOVE_TO_END;\nexports.MOVE_TO_START = MOVE_TO_START;\nexports.OUTDENT_CONTENT_COMMAND = OUTDENT_CONTENT_COMMAND;\nexports.PASTE_COMMAND = PASTE_COMMAND;\nexports.ParagraphNode = ParagraphNode;\nexports.REDO_COMMAND = REDO_COMMAND;\nexports.REMOVE_TEXT_COMMAND = REMOVE_TEXT_COMMAND;\nexports.RootNode = RootNode;\nexports.SELECTION_CHANGE_COMMAND = SELECTION_CHANGE_COMMAND;\nexports.TabNode = TabNode;\nexports.TextNode = TextNode;\nexports.UNDO_COMMAND = UNDO_COMMAND;\nexports.createCommand = createCommand;\nexports.createEditor = createEditor;\nexports.getNearestEditorFromDOMNode = getNearestEditorFromDOMNode;\nexports.isSelectionCapturedInDecoratorInput = isSelectionCapturedInDecoratorInput;\nexports.isSelectionWithinEditor = isSelectionWithinEditor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sZXhpY2FsL0xleGljYWwuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHOztBQUVBLCtFQUErRTs7QUFFL0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBJQUEwSTs7QUFFMUk7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSw4SUFBOEk7O0FBRTlJLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysd0NBQXdDO0FBQ3hDO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCLHVCQUF1QjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1Qzs7O0FBR3ZDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQyxrQ0FBa0MsWUFBWTs7QUFFOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2RUFBNkUsSUFBSTtBQUNqRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0Msc0RBQXNEO0FBQzlGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyx3QkFBd0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFLFFBQVEsSUFBSSxxQkFBcUI7QUFDN0c7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFOztBQUVqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDLGlFQUFpRTs7QUFFakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCLGlDQUFpQzs7QUFFakMsbUNBQW1DOztBQUVuQyxpQ0FBaUM7O0FBRWpDLGlDQUFpQzs7QUFFakMsaUNBQWlDOztBQUVqQyxrQ0FBa0M7O0FBRWxDLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2RUFBNkUsSUFBSTtBQUNqRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOE5BQThOO0FBQzlOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixpQkFBaUI7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7O0FBRVIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQSxrQkFBa0IsOEJBQThCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsOEJBQThCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLGFBQWE7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNEJBQTRCO0FBQ3JFO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJDQUEyQztBQUNsRjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkNBQTJDO0FBQ3JEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsd0JBQXdCO0FBQ25HO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkRBQTZEOzs7QUFHN0Q7QUFDQTtBQUNBLDJEQUEyRCxZQUFZO0FBQ3ZFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxNQUFNLFVBQVUsWUFBWSxpQ0FBaUMsa0JBQWtCO0FBQ3RIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQzs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDJCQUEyQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOLHVDQUF1Qzs7QUFFdkM7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEIsNkRBQTZEOztBQUU3RCxxRkFBcUY7O0FBRXJGLGdFQUFnRTs7QUFFaEUsZ0ZBQWdGOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsWUFBWTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSix3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qjs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLG9EQUFvRDs7QUFFcEQsb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7O0FBRUEsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0ZBQW9GOztBQUVwRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixhQUFhO0FBQ3RDLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixZQUFZO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEdBQTBHO0FBQzFHOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0RBQWdELFFBQVE7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1Isc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRkFBaUY7QUFDakY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTixpQ0FBaUMsZUFBZTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QixvQkFBb0Isa0JBQWtCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCLG9CQUFvQjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGdHQUFnRzs7QUFFaEc7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isa0JBQWtCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUiw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFzQzs7QUFFdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSSxlQUFlO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLHlCQUF5QjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLHlCQUF5QjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzRUFBc0U7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWlFO0FBQ2pFO0FBQ0E7O0FBRUEsK0VBQStFO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLFFBQVE7QUFDMUIsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHlCQUF5QjtBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixNQUFNLHlCQUF5QixPQUFPO0FBQ3BFO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDLDhCQUE4Qjs7QUFFOUIscUNBQXFDOztBQUVyQyxxQ0FBcUM7O0FBRXJDO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsZ0NBQWdDOztBQUVoQywyQkFBMkI7O0FBRTNCLHlCQUF5Qjs7QUFFekI7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkJBQTJCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUI7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxxQ0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvQ0FBb0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseUNBQXlDO0FBQzVFO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHlCQUF5QjtBQUNuRixpRUFBaUUsbUNBQW1DO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTyxHQUFHO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckIsNkJBQTZCO0FBQzdCLGlCQUFpQjtBQUNqQiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0Isc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsa0NBQWtDO0FBQ2xDLG1DQUFtQztBQUNuQyxxQkFBcUI7QUFDckIsNkJBQTZCO0FBQzdCLGdCQUFnQjtBQUNoQixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCLHVDQUF1QztBQUN2QyxtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLG1CQUFtQjtBQUNuQiwyQkFBMkI7QUFDM0Isa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIseUNBQXlDO0FBQ3pDLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qiw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCLHFCQUFxQjtBQUNyQixpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLHlDQUF5QztBQUN6QyxvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLGdDQUFnQztBQUNoQywyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLGtDQUFrQztBQUNsQyx1Q0FBdUM7QUFDdkMsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUIsaUNBQWlDO0FBQ2pDLG1DQUFtQztBQUNuQywrQkFBK0I7QUFDL0IsMkJBQTJCO0FBQzNCLDhCQUE4QjtBQUM5Qix1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsOEJBQThCO0FBQzlCLDJCQUEyQjtBQUMzQiw4QkFBOEI7QUFDOUIsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQywwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QiwrQkFBK0I7QUFDL0IsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsK0JBQStCO0FBQy9CLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLDJCQUEyQjtBQUMzQixnQkFBZ0I7QUFDaEIsZ0NBQWdDO0FBQ2hDLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIsbUNBQW1DO0FBQ25DLDJDQUEyQztBQUMzQywrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xleGljYWwvTGV4aWNhbC5kZXYuanM/N2YzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tbWFuZCh0eXBlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZVxuICB9IDtcbn1cbmNvbnN0IFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1NFTEVDVElPTl9DSEFOR0VfQ09NTUFORCcpO1xuY29uc3QgQ0xJQ0tfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NMSUNLX0NPTU1BTkQnKTtcbmNvbnN0IERFTEVURV9DSEFSQUNURVJfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0RFTEVURV9DSEFSQUNURVJfQ09NTUFORCcpO1xuY29uc3QgSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQnKTtcbmNvbnN0IElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCcpO1xuY29uc3QgQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5EJyk7XG5jb25zdCBQQVNURV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnUEFTVEVfQ09NTUFORCcpO1xuY29uc3QgUkVNT1ZFX1RFWFRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1JFTU9WRV9URVhUX0NPTU1BTkQnKTtcbmNvbnN0IERFTEVURV9XT1JEX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdERUxFVEVfV09SRF9DT01NQU5EJyk7XG5jb25zdCBERUxFVEVfTElORV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnREVMRVRFX0xJTkVfQ09NTUFORCcpO1xuY29uc3QgRk9STUFUX1RFWFRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0ZPUk1BVF9URVhUX0NPTU1BTkQnKTtcbmNvbnN0IFVORE9fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1VORE9fQ09NTUFORCcpO1xuY29uc3QgUkVET19DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnUkVET19DT01NQU5EJyk7XG5jb25zdCBLRVlfRE9XTl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZRE9XTl9DT01NQU5EJyk7XG5jb25zdCBLRVlfQVJST1dfUklHSFRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9BUlJPV19SSUdIVF9DT01NQU5EJyk7XG5jb25zdCBNT1ZFX1RPX0VORCA9IGNyZWF0ZUNvbW1hbmQoJ01PVkVfVE9fRU5EJyk7XG5jb25zdCBLRVlfQVJST1dfTEVGVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0FSUk9XX0xFRlRfQ09NTUFORCcpO1xuY29uc3QgTU9WRV9UT19TVEFSVCA9IGNyZWF0ZUNvbW1hbmQoJ01PVkVfVE9fU1RBUlQnKTtcbmNvbnN0IEtFWV9BUlJPV19VUF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0FSUk9XX1VQX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9BUlJPV19ET1dOX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfQVJST1dfRE9XTl9DT01NQU5EJyk7XG5jb25zdCBLRVlfRU5URVJfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9FTlRFUl9DT01NQU5EJyk7XG5jb25zdCBLRVlfU1BBQ0VfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9TUEFDRV9DT01NQU5EJyk7XG5jb25zdCBLRVlfQkFDS1NQQUNFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfQkFDS1NQQUNFX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9FU0NBUEVfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9FU0NBUEVfQ09NTUFORCcpO1xuY29uc3QgS0VZX0RFTEVURV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0RFTEVURV9DT01NQU5EJyk7XG5jb25zdCBLRVlfVEFCX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfVEFCX0NPTU1BTkQnKTtcbmNvbnN0IElOU0VSVF9UQUJfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9UQUJfQ09NTUFORCcpO1xuY29uc3QgSU5ERU5UX0NPTlRFTlRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOREVOVF9DT05URU5UX0NPTU1BTkQnKTtcbmNvbnN0IE9VVERFTlRfQ09OVEVOVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnT1VUREVOVF9DT05URU5UX0NPTU1BTkQnKTtcbmNvbnN0IERST1BfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0RST1BfQ09NTUFORCcpO1xuY29uc3QgRk9STUFUX0VMRU1FTlRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0ZPUk1BVF9FTEVNRU5UX0NPTU1BTkQnKTtcbmNvbnN0IERSQUdTVEFSVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnRFJBR1NUQVJUX0NPTU1BTkQnKTtcbmNvbnN0IERSQUdPVkVSX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdEUkFHT1ZFUl9DT01NQU5EJyk7XG5jb25zdCBEUkFHRU5EX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdEUkFHRU5EX0NPTU1BTkQnKTtcbmNvbnN0IENPUFlfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NPUFlfQ09NTUFORCcpO1xuY29uc3QgQ1VUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDVVRfQ09NTUFORCcpO1xuY29uc3QgQ0xFQVJfRURJVE9SX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDTEVBUl9FRElUT1JfQ09NTUFORCcpO1xuY29uc3QgQ0xFQVJfSElTVE9SWV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ0xFQVJfSElTVE9SWV9DT01NQU5EJyk7XG5jb25zdCBDQU5fUkVET19DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ0FOX1JFRE9fQ09NTUFORCcpO1xuY29uc3QgQ0FOX1VORE9fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NBTl9VTkRPX0NPTU1BTkQnKTtcbmNvbnN0IEZPQ1VTX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdGT0NVU19DT01NQU5EJyk7XG5jb25zdCBCTFVSX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdCTFVSX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9NT0RJRklFUl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX01PRElGSUVSX0NPTU1BTkQnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IG51bGw7XG5jb25zdCBJU19BUFBMRSA9IENBTl9VU0VfRE9NICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfRklSRUZPWCA9IENBTl9VU0VfRE9NICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94KS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IENBTl9VU0VfQkVGT1JFX0lOUFVUID0gQ0FOX1VTRV9ET00gJiYgJ0lucHV0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlID8gJ2dldFRhcmdldFJhbmdlcycgaW4gbmV3IHdpbmRvdy5JbnB1dEV2ZW50KCdpbnB1dCcpIDogZmFsc2U7XG5jb25zdCBJU19TQUZBUkkgPSBDQU5fVVNFX0RPTSAmJiAvVmVyc2lvblxcL1tcXGQuXSsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0lPUyA9IENBTl9VU0VfRE9NICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07IC8vIEtlZXAgdGhlc2UgaW4gY2FzZSB3ZSBuZWVkIHRvIHVzZSB0aGVtIGluIHRoZSBmdXR1cmUuXG4vLyBleHBvcnQgY29uc3QgSVNfV0lORE9XUzogYm9vbGVhbiA9IENBTl9VU0VfRE9NICYmIC9XaW4vLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcblxuY29uc3QgSVNfQ0hST01FID0gQ0FOX1VTRV9ET00gJiYgL14oPz0uKkNocm9tZSkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIGV4cG9ydCBjb25zdCBjYW5Vc2VUZXh0SW5wdXRFdmVudDogYm9vbGVhbiA9IENBTl9VU0VfRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlO1xuXG5jb25zdCBJU19BUFBMRV9XRUJLSVQgPSBDQU5fVVNFX0RPTSAmJiAvQXBwbGVXZWJLaXRcXC9bXFxkLl0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFJU19DSFJPTUU7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgRE9NX0VMRU1FTlRfVFlQRSA9IDE7XG5jb25zdCBET01fVEVYVF9UWVBFID0gMzsgLy8gUmVjb25jaWxpbmdcblxuY29uc3QgTk9fRElSVFlfTk9ERVMgPSAwO1xuY29uc3QgSEFTX0RJUlRZX05PREVTID0gMTtcbmNvbnN0IEZVTExfUkVDT05DSUxFID0gMjsgLy8gVGV4dCBub2RlIG1vZGVzXG5cbmNvbnN0IElTX05PUk1BTCA9IDA7XG5jb25zdCBJU19UT0tFTiA9IDE7XG5jb25zdCBJU19TRUdNRU5URUQgPSAyOyAvLyBJU19JTkVSVCA9IDNcbi8vIFRleHQgbm9kZSBmb3JtYXR0aW5nXG5cbmNvbnN0IElTX0JPTEQgPSAxO1xuY29uc3QgSVNfSVRBTElDID0gMSA8PCAxO1xuY29uc3QgSVNfU1RSSUtFVEhST1VHSCA9IDEgPDwgMjtcbmNvbnN0IElTX1VOREVSTElORSA9IDEgPDwgMztcbmNvbnN0IElTX0NPREUgPSAxIDw8IDQ7XG5jb25zdCBJU19TVUJTQ1JJUFQgPSAxIDw8IDU7XG5jb25zdCBJU19TVVBFUlNDUklQVCA9IDEgPDwgNjtcbmNvbnN0IElTX0hJR0hMSUdIVCA9IDEgPDwgNztcbmNvbnN0IElTX0FMTF9GT1JNQVRUSU5HID0gSVNfQk9MRCB8IElTX0lUQUxJQyB8IElTX1NUUklLRVRIUk9VR0ggfCBJU19VTkRFUkxJTkUgfCBJU19DT0RFIHwgSVNfU1VCU0NSSVBUIHwgSVNfU1VQRVJTQ1JJUFQgfCBJU19ISUdITElHSFQ7IC8vIFRleHQgbm9kZSBkZXRhaWxzXG5cbmNvbnN0IElTX0RJUkVDVElPTkxFU1MgPSAxO1xuY29uc3QgSVNfVU5NRVJHRUFCTEUgPSAxIDw8IDE7IC8vIEVsZW1lbnQgbm9kZSBmb3JtYXR0aW5nXG5cbmNvbnN0IElTX0FMSUdOX0xFRlQgPSAxO1xuY29uc3QgSVNfQUxJR05fQ0VOVEVSID0gMjtcbmNvbnN0IElTX0FMSUdOX1JJR0hUID0gMztcbmNvbnN0IElTX0FMSUdOX0pVU1RJRlkgPSA0O1xuY29uc3QgSVNfQUxJR05fU1RBUlQgPSA1O1xuY29uc3QgSVNfQUxJR05fRU5EID0gNjsgLy8gUmVjb25jaWxpYXRpb25cblxuY29uc3QgTk9OX0JSRUFLSU5HX1NQQUNFID0gJ1xcdTAwQTAnO1xuY29uc3QgWkVST19XSURUSF9TUEFDRSA9ICdcXHUyMDBiJzsgLy8gRm9yIGlPUy9TYWZhcmkgd2UgdXNlIGEgbm9uIGJyZWFraW5nIHNwYWNlLCBvdGhlcndpc2UgdGhlIGN1cnNvciBhcHBlYXJzXG4vLyBvdmVybGFwcGluZyB0aGUgY29tcG9zZWQgdGV4dC5cblxuY29uc3QgQ09NUE9TSVRJT05fU1VGRklYID0gSVNfU0FGQVJJIHx8IElTX0lPUyB8fCBJU19BUFBMRV9XRUJLSVQgPyBOT05fQlJFQUtJTkdfU1BBQ0UgOiBaRVJPX1dJRFRIX1NQQUNFO1xuY29uc3QgRE9VQkxFX0xJTkVfQlJFQUsgPSAnXFxuXFxuJzsgLy8gRm9yIEZGLCB3ZSBuZWVkIHRvIHVzZSBhIG5vbi1icmVha2luZyBzcGFjZSwgb3IgaXQgZ2V0cyBjb21wb3NpdGlvblxuLy8gaW4gYSBzdHVjayBzdGF0ZS5cblxuY29uc3QgQ09NUE9TSVRJT05fU1RBUlRfQ0hBUiA9IElTX0ZJUkVGT1ggPyBOT05fQlJFQUtJTkdfU1BBQ0UgOiBDT01QT1NJVElPTl9TVUZGSVg7XG5jb25zdCBSVEwgPSAnXFx1MDU5MS1cXHUwN0ZGXFx1RkIxRC1cXHVGREZEXFx1RkU3MC1cXHVGRUZDJztcbmNvbnN0IExUUiA9ICdBLVphLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjYnICsgJ1xcdTAwRjgtXFx1MDJCOFxcdTAzMDAtXFx1MDU5MFxcdTA4MDAtXFx1MUZGRlxcdTIwMEVcXHUyQzAwLVxcdUZCMUMnICsgJ1xcdUZFMDAtXFx1RkU2RlxcdUZFRkQtXFx1RkZGRic7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzc1xuXG5jb25zdCBSVExfUkVHRVggPSBuZXcgUmVnRXhwKCdeW14nICsgTFRSICsgJ10qWycgKyBSVEwgKyAnXScpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3NcblxuY29uc3QgTFRSX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlteJyArIFJUTCArICddKlsnICsgTFRSICsgJ10nKTtcbmNvbnN0IFRFWFRfVFlQRV9UT19GT1JNQVQgPSB7XG4gIGJvbGQ6IElTX0JPTEQsXG4gIGNvZGU6IElTX0NPREUsXG4gIGhpZ2hsaWdodDogSVNfSElHSExJR0hULFxuICBpdGFsaWM6IElTX0lUQUxJQyxcbiAgc3RyaWtldGhyb3VnaDogSVNfU1RSSUtFVEhST1VHSCxcbiAgc3Vic2NyaXB0OiBJU19TVUJTQ1JJUFQsXG4gIHN1cGVyc2NyaXB0OiBJU19TVVBFUlNDUklQVCxcbiAgdW5kZXJsaW5lOiBJU19VTkRFUkxJTkVcbn07XG5jb25zdCBERVRBSUxfVFlQRV9UT19ERVRBSUwgPSB7XG4gIGRpcmVjdGlvbmxlc3M6IElTX0RJUkVDVElPTkxFU1MsXG4gIHVubWVyZ2VhYmxlOiBJU19VTk1FUkdFQUJMRVxufTtcbmNvbnN0IEVMRU1FTlRfVFlQRV9UT19GT1JNQVQgPSB7XG4gIGNlbnRlcjogSVNfQUxJR05fQ0VOVEVSLFxuICBlbmQ6IElTX0FMSUdOX0VORCxcbiAganVzdGlmeTogSVNfQUxJR05fSlVTVElGWSxcbiAgbGVmdDogSVNfQUxJR05fTEVGVCxcbiAgcmlnaHQ6IElTX0FMSUdOX1JJR0hULFxuICBzdGFydDogSVNfQUxJR05fU1RBUlRcbn07XG5jb25zdCBFTEVNRU5UX0ZPUk1BVF9UT19UWVBFID0ge1xuICBbSVNfQUxJR05fQ0VOVEVSXTogJ2NlbnRlcicsXG4gIFtJU19BTElHTl9FTkRdOiAnZW5kJyxcbiAgW0lTX0FMSUdOX0pVU1RJRlldOiAnanVzdGlmeScsXG4gIFtJU19BTElHTl9MRUZUXTogJ2xlZnQnLFxuICBbSVNfQUxJR05fUklHSFRdOiAncmlnaHQnLFxuICBbSVNfQUxJR05fU1RBUlRdOiAnc3RhcnQnXG59O1xuY29uc3QgVEVYVF9NT0RFX1RPX1RZUEUgPSB7XG4gIG5vcm1hbDogSVNfTk9STUFMLFxuICBzZWdtZW50ZWQ6IElTX1NFR01FTlRFRCxcbiAgdG9rZW46IElTX1RPS0VOXG59O1xuY29uc3QgVEVYVF9UWVBFX1RPX01PREUgPSB7XG4gIFtJU19OT1JNQUxdOiAnbm9ybWFsJyxcbiAgW0lTX1NFR01FTlRFRF06ICdzZWdtZW50ZWQnLFxuICBbSVNfVE9LRU5dOiAndG9rZW4nXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IFRFWFRfTVVUQVRJT05fVkFSSUFOQ0UgPSAxMDA7XG5sZXQgaXNQcm9jZXNzaW5nTXV0YXRpb25zID0gZmFsc2U7XG5sZXQgbGFzdFRleHRFbnRyeVRpbWVTdGFtcCA9IDA7XG5mdW5jdGlvbiBnZXRJc1Byb2Nlc3NzaW5nTXV0YXRpb25zKCkge1xuICByZXR1cm4gaXNQcm9jZXNzaW5nTXV0YXRpb25zO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVUaW1lU3RhbXAoZXZlbnQpIHtcbiAgbGFzdFRleHRFbnRyeVRpbWVTdGFtcCA9IGV2ZW50LnRpbWVTdGFtcDtcbn1cblxuZnVuY3Rpb24gaW5pdFRleHRFbnRyeUxpc3RlbmVyKGVkaXRvcikge1xuICBpZiAobGFzdFRleHRFbnRyeVRpbWVTdGFtcCA9PT0gMCkge1xuICAgIGdldFdpbmRvdyhlZGl0b3IpLmFkZEV2ZW50TGlzdGVuZXIoJ3RleHRJbnB1dCcsIHVwZGF0ZVRpbWVTdGFtcCwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNNYW5hZ2VkTGluZUJyZWFrKGRvbSwgdGFyZ2V0LCBlZGl0b3IpIHtcbiAgcmV0dXJuICgvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgIHRhcmdldC5fX2xleGljYWxMaW5lQnJlYWsgPT09IGRvbSB8fCAvLyBAdHMtaWdub3JlIFdlIGludGVudGlvbmFsbHkgYWRkIHRoaXMgdG8gdGhlIE5vZGUuXG4gICAgZG9tW2BfX2xleGljYWxLZXlfJHtlZGl0b3IuX2tleX1gXSAhPT0gdW5kZWZpbmVkXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldExhc3RTZWxlY3Rpb24oZWRpdG9yKSB7XG4gIHJldHVybiBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHNlbGVjdGlvbiAhPT0gbnVsbCA/IHNlbGVjdGlvbi5jbG9uZSgpIDogbnVsbDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRleHRNdXRhdGlvbih0YXJnZXQsIG5vZGUsIGVkaXRvcikge1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICBsZXQgYW5jaG9yT2Zmc2V0ID0gbnVsbDtcbiAgbGV0IGZvY3VzT2Zmc2V0ID0gbnVsbDtcblxuICBpZiAoZG9tU2VsZWN0aW9uICE9PSBudWxsICYmIGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlID09PSB0YXJnZXQpIHtcbiAgICBhbmNob3JPZmZzZXQgPSBkb21TZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICAgIGZvY3VzT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuICB9XG5cbiAgY29uc3QgdGV4dCA9IHRhcmdldC5ub2RlVmFsdWU7XG5cbiAgaWYgKHRleHQgIT09IG51bGwpIHtcbiAgICAkdXBkYXRlVGV4dE5vZGVGcm9tRE9NQ29udGVudChub2RlLCB0ZXh0LCBhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0LCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVGV4dE5vZGVGcm9tTXV0YXRpb24oc2VsZWN0aW9uLCB0YXJnZXRET00sIHRhcmdldE5vZGUpIHtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG5cbiAgICBpZiAoYW5jaG9yTm9kZS5pcyh0YXJnZXROb2RlKSAmJiBzZWxlY3Rpb24uZm9ybWF0ICE9PSBhbmNob3JOb2RlLmdldEZvcm1hdCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldERPTS5ub2RlVHlwZSA9PT0gRE9NX1RFWFRfVFlQRSAmJiB0YXJnZXROb2RlLmlzQXR0YWNoZWQoKTtcbn1cblxuZnVuY3Rpb24gJGZsdXNoTXV0YXRpb25zJDEoZWRpdG9yLCBtdXRhdGlvbnMsIG9ic2VydmVyKSB7XG4gIGlzUHJvY2Vzc2luZ011dGF0aW9ucyA9IHRydWU7XG4gIGNvbnN0IHNob3VsZEZsdXNoVGV4dE11dGF0aW9ucyA9IHBlcmZvcm1hbmNlLm5vdygpIC0gbGFzdFRleHRFbnRyeVRpbWVTdGFtcCA+IFRFWFRfTVVUQVRJT05fVkFSSUFOQ0U7XG5cbiAgdHJ5IHtcbiAgICB1cGRhdGVFZGl0b3IoZWRpdG9yLCAoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkgfHwgZ2V0TGFzdFNlbGVjdGlvbihlZGl0b3IpO1xuICAgICAgY29uc3QgYmFkRE9NVGFyZ2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7IC8vIFdlIHVzZSB0aGUgY3VycmVudCBlZGl0b3Igc3RhdGUsIGFzIHRoYXQgcmVmbGVjdHMgd2hhdCBpc1xuICAgICAgLy8gYWN0dWFsbHkgXCJvbiBzY3JlZW5cIi5cblxuICAgICAgY29uc3QgY3VycmVudEVkaXRvclN0YXRlID0gZWRpdG9yLl9lZGl0b3JTdGF0ZTtcbiAgICAgIGNvbnN0IGJsb2NrQ3Vyc29yRWxlbWVudCA9IGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50O1xuICAgICAgbGV0IHNob3VsZFJldmVydFNlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgbGV0IHBvc3NpYmxlVGV4dEZvckZpcmVmb3hQYXN0ZSA9ICcnO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBtdXRhdGlvbiA9IG11dGF0aW9uc1tpXTtcbiAgICAgICAgY29uc3QgdHlwZSA9IG11dGF0aW9uLnR5cGU7XG4gICAgICAgIGNvbnN0IHRhcmdldERPTSA9IG11dGF0aW9uLnRhcmdldDtcbiAgICAgICAgbGV0IHRhcmdldE5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZSh0YXJnZXRET00sIGN1cnJlbnRFZGl0b3JTdGF0ZSk7XG5cbiAgICAgICAgaWYgKHRhcmdldE5vZGUgPT09IG51bGwgJiYgdGFyZ2V0RE9NICE9PSByb290RWxlbWVudCB8fCAkaXNEZWNvcmF0b3JOb2RlKHRhcmdldE5vZGUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NoYXJhY3RlckRhdGEnKSB7XG4gICAgICAgICAgLy8gVGV4dCBtdXRhdGlvbnMgYXJlIGRlZmVycmVkIGFuZCBwYXNzZWQgdG8gbXV0YXRpb24gbGlzdGVuZXJzIHRvIGJlXG4gICAgICAgICAgLy8gcHJvY2Vzc2VkIG91dHNpZGUgb2YgdGhlIExleGljYWwgZW5naW5lLlxuICAgICAgICAgIGlmIChzaG91bGRGbHVzaFRleHRNdXRhdGlvbnMgJiYgJGlzVGV4dE5vZGUodGFyZ2V0Tm9kZSkgJiYgc2hvdWxkVXBkYXRlVGV4dE5vZGVGcm9tTXV0YXRpb24oc2VsZWN0aW9uLCB0YXJnZXRET00sIHRhcmdldE5vZGUpKSB7XG4gICAgICAgICAgICBoYW5kbGVUZXh0TXV0YXRpb24oIC8vIG5vZGVUeXBlID09PSBET01fVEVYVF9UWVBFIGlzIGEgVGV4dCBET00gbm9kZVxuICAgICAgICAgICAgdGFyZ2V0RE9NLCB0YXJnZXROb2RlLCBlZGl0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgIHNob3VsZFJldmVydFNlbGVjdGlvbiA9IHRydWU7IC8vIFdlIGF0dGVtcHQgdG8gXCJ1bmRvXCIgYW55IGNoYW5nZXMgdGhhdCBoYXZlIG9jY3VycmVkIG91dHNpZGVcbiAgICAgICAgICAvLyBvZiBMZXhpY2FsLiBXZSB3YW50IExleGljYWwncyBlZGl0b3Igc3RhdGUgdG8gYmUgc291cmNlIG9mIHRydXRoLlxuICAgICAgICAgIC8vIFRvIHRoZSB1c2VyLCB0aGVzZSB3aWxsIGxvb2sgbGlrZSBuby1vcHMuXG5cbiAgICAgICAgICBjb25zdCBhZGRlZERPTXMgPSBtdXRhdGlvbi5hZGRlZE5vZGVzO1xuXG4gICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBhZGRlZERPTXMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkRE9NID0gYWRkZWRET01zW3NdO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGdldE5vZGVGcm9tRE9NTm9kZShhZGRlZERPTSk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRET00gPSBhZGRlZERPTS5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50RE9NICE9IG51bGwgJiYgYWRkZWRET00gIT09IGJsb2NrQ3Vyc29yRWxlbWVudCAmJiBub2RlID09PSBudWxsICYmIChhZGRlZERPTS5ub2RlTmFtZSAhPT0gJ0JSJyB8fCAhaXNNYW5hZ2VkTGluZUJyZWFrKGFkZGVkRE9NLCBwYXJlbnRET00sIGVkaXRvcikpKSB7XG4gICAgICAgICAgICAgIGlmIChJU19GSVJFRk9YKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zc2libGVUZXh0ID0gYWRkZWRET00uaW5uZXJUZXh0IHx8IGFkZGVkRE9NLm5vZGVWYWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHBvc3NpYmxlVGV4dEZvckZpcmVmb3hQYXN0ZSArPSBwb3NzaWJsZVRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGFyZW50RE9NLnJlbW92ZUNoaWxkKGFkZGVkRE9NKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCByZW1vdmVkRE9NcyA9IG11dGF0aW9uLnJlbW92ZWROb2RlcztcbiAgICAgICAgICBjb25zdCByZW1vdmVkRE9Nc0xlbmd0aCA9IHJlbW92ZWRET01zLmxlbmd0aDtcblxuICAgICAgICAgIGlmIChyZW1vdmVkRE9Nc0xlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCB1bnJlbW92ZWRCUnMgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHJlbW92ZWRET01zTGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlZERPTSA9IHJlbW92ZWRET01zW3NdO1xuXG4gICAgICAgICAgICAgIGlmIChyZW1vdmVkRE9NLm5vZGVOYW1lID09PSAnQlInICYmIGlzTWFuYWdlZExpbmVCcmVhayhyZW1vdmVkRE9NLCB0YXJnZXRET00sIGVkaXRvcikgfHwgYmxvY2tDdXJzb3JFbGVtZW50ID09PSByZW1vdmVkRE9NKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RE9NLmFwcGVuZENoaWxkKHJlbW92ZWRET00pO1xuICAgICAgICAgICAgICAgIHVucmVtb3ZlZEJScysrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW1vdmVkRE9Nc0xlbmd0aCAhPT0gdW5yZW1vdmVkQlJzKSB7XG4gICAgICAgICAgICAgIGlmICh0YXJnZXRET00gPT09IHJvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGludGVybmFsR2V0Um9vdChjdXJyZW50RWRpdG9yU3RhdGUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYmFkRE9NVGFyZ2V0cy5zZXQodGFyZ2V0RE9NLCB0YXJnZXROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gTm93IHdlIHByb2Nlc3MgZWFjaCBvZiB0aGUgdW5pcXVlIHRhcmdldCBub2RlcywgYXR0ZW1wdGluZ1xuICAgICAgLy8gdG8gcmVzdG9yZSB0aGVpciBjb250ZW50cyBiYWNrIHRvIHRoZSBzb3VyY2Ugb2YgdHJ1dGgsIHdoaWNoXG4gICAgICAvLyBpcyBMZXhpY2FsJ3MgXCJjdXJyZW50XCIgZWRpdG9yIHN0YXRlLiBUaGlzIGlzIGJhc2ljYWxseSBsaWtlXG4gICAgICAvLyBhbiBpbnRlcm5hbCByZXZlcnQgb24gdGhlIERPTS5cblxuXG4gICAgICBpZiAoYmFkRE9NVGFyZ2V0cy5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IFt0YXJnZXRET00sIHRhcmdldE5vZGVdIG9mIGJhZERPTVRhcmdldHMpIHtcbiAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUodGFyZ2V0Tm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkS2V5cyA9IHRhcmdldE5vZGUuZ2V0Q2hpbGRyZW5LZXlzKCk7XG4gICAgICAgICAgICBsZXQgY3VycmVudERPTSA9IHRhcmdldERPTS5maXJzdENoaWxkO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGNoaWxkS2V5cy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjaGlsZEtleXNbc107XG4gICAgICAgICAgICAgIGNvbnN0IGNvcnJlY3RET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGtleSk7XG5cbiAgICAgICAgICAgICAgaWYgKGNvcnJlY3RET00gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjdXJyZW50RE9NID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRET00uYXBwZW5kQ2hpbGQoY29ycmVjdERPTSk7XG4gICAgICAgICAgICAgICAgY3VycmVudERPTSA9IGNvcnJlY3RET007XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudERPTSAhPT0gY29ycmVjdERPTSkge1xuICAgICAgICAgICAgICAgIHRhcmdldERPTS5yZXBsYWNlQ2hpbGQoY29ycmVjdERPTSwgY3VycmVudERPTSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjdXJyZW50RE9NID0gY3VycmVudERPTS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCRpc1RleHROb2RlKHRhcmdldE5vZGUpKSB7XG4gICAgICAgICAgICB0YXJnZXROb2RlLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDYXB0dXJlIGFsbCB0aGUgbXV0YXRpb25zIG1hZGUgZHVyaW5nIHRoaXMgZnVuY3Rpb24uIFRoaXNcbiAgICAgIC8vIGFsc28gcHJldmVudHMgdXMgaGF2aW5nIHRvIHByb2Nlc3MgdGhlbSBvbiB0aGUgbmV4dCBjeWNsZVxuICAgICAgLy8gb2Ygb25NdXRhdGlvbiwgYXMgdGhlc2UgbXV0YXRpb25zIHdlcmUgbWFkZSBieSB1cy5cblxuXG4gICAgICBjb25zdCByZWNvcmRzID0gb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTsgLy8gQ2hlY2sgZm9yIGFueSByYW5kb20gYXV0by1hZGRlZCA8YnI+IGVsZW1lbnRzLCBhbmQgcmVtb3ZlIHRoZW0uXG4gICAgICAvLyBUaGVzZSBnZXQgYWRkZWQgYnkgdGhlIGJyb3dzZXIgd2hlbiB3ZSB1bmRvIHRoZSBhYm92ZSBtdXRhdGlvbnNcbiAgICAgIC8vIGFuZCB0aGlzIGNhbiBsZWFkIHRvIGEgYnJva2VuIFVJLlxuXG4gICAgICBpZiAocmVjb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHJlY29yZHNbaV07XG4gICAgICAgICAgY29uc3QgYWRkZWROb2RlcyA9IHJlY29yZC5hZGRlZE5vZGVzO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHJlY29yZC50YXJnZXQ7XG5cbiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGFkZGVkTm9kZXMubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkRE9NID0gYWRkZWROb2Rlc1tzXTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudERPTSA9IGFkZGVkRE9NLnBhcmVudE5vZGU7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRET00gIT0gbnVsbCAmJiBhZGRlZERPTS5ub2RlTmFtZSA9PT0gJ0JSJyAmJiAhaXNNYW5hZ2VkTGluZUJyZWFrKGFkZGVkRE9NLCB0YXJnZXQsIGVkaXRvcikpIHtcbiAgICAgICAgICAgICAgcGFyZW50RE9NLnJlbW92ZUNoaWxkKGFkZGVkRE9NKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQ2xlYXIgYW55IG9mIHRob3NlIHJlbW92YWwgbXV0YXRpb25zXG5cblxuICAgICAgICBvYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRSZXZlcnRTZWxlY3Rpb24pIHtcbiAgICAgICAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICAgICAgICAgICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChJU19GSVJFRk9YICYmIGlzRmlyZWZveENsaXBib2FyZEV2ZW50cyhlZGl0b3IpKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmluc2VydFJhd1RleHQocG9zc2libGVUZXh0Rm9yRmlyZWZveFBhc3RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGlzUHJvY2Vzc2luZ011dGF0aW9ucyA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaFJvb3RNdXRhdGlvbnMoZWRpdG9yKSB7XG4gIGNvbnN0IG9ic2VydmVyID0gZWRpdG9yLl9vYnNlcnZlcjtcblxuICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICBjb25zdCBtdXRhdGlvbnMgPSBvYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICRmbHVzaE11dGF0aW9ucyQxKGVkaXRvciwgbXV0YXRpb25zLCBvYnNlcnZlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGluaXRNdXRhdGlvbk9ic2VydmVyKGVkaXRvcikge1xuICBpbml0VGV4dEVudHJ5TGlzdGVuZXIoZWRpdG9yKTtcbiAgZWRpdG9yLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMsIG9ic2VydmVyKSA9PiB7XG4gICAgJGZsdXNoTXV0YXRpb25zJDEoZWRpdG9yLCBtdXRhdGlvbnMsIG9ic2VydmVyKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJGNhblNpbXBsZVRleHROb2Rlc0JlTWVyZ2VkKG5vZGUxLCBub2RlMikge1xuICBjb25zdCBub2RlMU1vZGUgPSBub2RlMS5fX21vZGU7XG4gIGNvbnN0IG5vZGUxRm9ybWF0ID0gbm9kZTEuX19mb3JtYXQ7XG4gIGNvbnN0IG5vZGUxU3R5bGUgPSBub2RlMS5fX3N0eWxlO1xuICBjb25zdCBub2RlMk1vZGUgPSBub2RlMi5fX21vZGU7XG4gIGNvbnN0IG5vZGUyRm9ybWF0ID0gbm9kZTIuX19mb3JtYXQ7XG4gIGNvbnN0IG5vZGUyU3R5bGUgPSBub2RlMi5fX3N0eWxlO1xuICByZXR1cm4gKG5vZGUxTW9kZSA9PT0gbnVsbCB8fCBub2RlMU1vZGUgPT09IG5vZGUyTW9kZSkgJiYgKG5vZGUxRm9ybWF0ID09PSBudWxsIHx8IG5vZGUxRm9ybWF0ID09PSBub2RlMkZvcm1hdCkgJiYgKG5vZGUxU3R5bGUgPT09IG51bGwgfHwgbm9kZTFTdHlsZSA9PT0gbm9kZTJTdHlsZSk7XG59XG5cbmZ1bmN0aW9uICRtZXJnZVRleHROb2Rlcyhub2RlMSwgbm9kZTIpIHtcbiAgY29uc3Qgd3JpdGFibGVOb2RlMSA9IG5vZGUxLm1lcmdlV2l0aFNpYmxpbmcobm9kZTIpO1xuXG4gIGNvbnN0IG5vcm1hbGl6ZWROb2RlcyA9IGdldEFjdGl2ZUVkaXRvcigpLl9ub3JtYWxpemVkTm9kZXM7XG5cbiAgbm9ybWFsaXplZE5vZGVzLmFkZChub2RlMS5fX2tleSk7XG4gIG5vcm1hbGl6ZWROb2Rlcy5hZGQobm9kZTIuX19rZXkpO1xuICByZXR1cm4gd3JpdGFibGVOb2RlMTtcbn1cblxuZnVuY3Rpb24gJG5vcm1hbGl6ZVRleHROb2RlKHRleHROb2RlKSB7XG4gIGxldCBub2RlID0gdGV4dE5vZGU7XG5cbiAgaWYgKG5vZGUuX190ZXh0ID09PSAnJyAmJiBub2RlLmlzU2ltcGxlVGV4dCgpICYmICFub2RlLmlzVW5tZXJnZWFibGUoKSkge1xuICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgcmV0dXJuO1xuICB9IC8vIEJhY2t3YXJkXG5cblxuICBsZXQgcHJldmlvdXNOb2RlO1xuXG4gIHdoaWxlICgocHJldmlvdXNOb2RlID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSkgIT09IG51bGwgJiYgJGlzVGV4dE5vZGUocHJldmlvdXNOb2RlKSAmJiBwcmV2aW91c05vZGUuaXNTaW1wbGVUZXh0KCkgJiYgIXByZXZpb3VzTm9kZS5pc1VubWVyZ2VhYmxlKCkpIHtcbiAgICBpZiAocHJldmlvdXNOb2RlLl9fdGV4dCA9PT0gJycpIHtcbiAgICAgIHByZXZpb3VzTm9kZS5yZW1vdmUoKTtcbiAgICB9IGVsc2UgaWYgKCRjYW5TaW1wbGVUZXh0Tm9kZXNCZU1lcmdlZChwcmV2aW91c05vZGUsIG5vZGUpKSB7XG4gICAgICBub2RlID0gJG1lcmdlVGV4dE5vZGVzKHByZXZpb3VzTm9kZSwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9IC8vIEZvcndhcmRcblxuXG4gIGxldCBuZXh0Tm9kZTtcblxuICB3aGlsZSAoKG5leHROb2RlID0gbm9kZS5nZXROZXh0U2libGluZygpKSAhPT0gbnVsbCAmJiAkaXNUZXh0Tm9kZShuZXh0Tm9kZSkgJiYgbmV4dE5vZGUuaXNTaW1wbGVUZXh0KCkgJiYgIW5leHROb2RlLmlzVW5tZXJnZWFibGUoKSkge1xuICAgIGlmIChuZXh0Tm9kZS5fX3RleHQgPT09ICcnKSB7XG4gICAgICBuZXh0Tm9kZS5yZW1vdmUoKTtcbiAgICB9IGVsc2UgaWYgKCRjYW5TaW1wbGVUZXh0Tm9kZXNCZU1lcmdlZChub2RlLCBuZXh0Tm9kZSkpIHtcbiAgICAgIG5vZGUgPSAkbWVyZ2VUZXh0Tm9kZXMobm9kZSwgbmV4dE5vZGUpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJG5vcm1hbGl6ZVNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgJG5vcm1hbGl6ZVBvaW50KHNlbGVjdGlvbi5hbmNob3IpO1xuICAkbm9ybWFsaXplUG9pbnQoc2VsZWN0aW9uLmZvY3VzKTtcbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gJG5vcm1hbGl6ZVBvaW50KHBvaW50KSB7XG4gIHdoaWxlIChwb2ludC50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICBjb25zdCBub2RlID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgICBsZXQgbmV4dE5vZGU7XG4gICAgbGV0IG5leHRPZmZzZXRBdEVuZDtcblxuICAgIGlmIChvZmZzZXQgPT09IG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkpIHtcbiAgICAgIG5leHROb2RlID0gbm9kZS5nZXRDaGlsZEF0SW5kZXgob2Zmc2V0IC0gMSk7XG4gICAgICBuZXh0T2Zmc2V0QXRFbmQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0Tm9kZSA9IG5vZGUuZ2V0Q2hpbGRBdEluZGV4KG9mZnNldCk7XG4gICAgICBuZXh0T2Zmc2V0QXRFbmQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoJGlzVGV4dE5vZGUobmV4dE5vZGUpKSB7XG4gICAgICBwb2ludC5zZXQobmV4dE5vZGUuX19rZXksIG5leHRPZmZzZXRBdEVuZCA/IG5leHROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpIDogMCwgJ3RleHQnKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoISRpc0VsZW1lbnROb2RlKG5leHROb2RlKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcG9pbnQuc2V0KG5leHROb2RlLl9fa2V5LCBuZXh0T2Zmc2V0QXRFbmQgPyBuZXh0Tm9kZS5nZXRDaGlsZHJlblNpemUoKSA6IDAsICdlbGVtZW50Jyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xubGV0IGtleUNvdW50ZXIgPSAxO1xuZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21LZXkoKSB7XG4gIHJldHVybiAnJyArIGtleUNvdW50ZXIrKztcbn1cbmZ1bmN0aW9uIGdldFJlZ2lzdGVyZWROb2RlT3JUaHJvdyhlZGl0b3IsIG5vZGVUeXBlKSB7XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gZWRpdG9yLl9ub2Rlcy5nZXQobm9kZVR5cGUpO1xuXG4gIGlmIChyZWdpc3RlcmVkTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYHJlZ2lzdGVyZWROb2RlOiBUeXBlICR7bm9kZVR5cGV9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWdpc3RlcmVkTm9kZTtcbn1cbmNvbnN0IHNjaGVkdWxlTWljcm9UYXNrID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nID8gcXVldWVNaWNyb3Rhc2sgOiBmbiA9PiB7XG4gIC8vIE5vIHdpbmRvdyBwcmVmaXggaW50ZW5kZWQgKCMxNDAwKVxuICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZuKTtcbn07XG5mdW5jdGlvbiAkaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9yKG5vZGUpIHtcbiAgcmV0dXJuICRpc0RlY29yYXRvck5vZGUoJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUobm9kZSkpO1xufVxuZnVuY3Rpb24gaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9ySW5wdXQoYW5jaG9yRE9NKSB7XG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gIGlmIChhY3RpdmVFbGVtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgbm9kZU5hbWUgPSBhY3RpdmVFbGVtZW50Lm5vZGVOYW1lO1xuICByZXR1cm4gJGlzRGVjb3JhdG9yTm9kZSgkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShhbmNob3JET00pKSAmJiAobm9kZU5hbWUgPT09ICdJTlBVVCcgfHwgbm9kZU5hbWUgPT09ICdURVhUQVJFQScgfHwgYWN0aXZlRWxlbWVudC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyAmJiAvLyBAdHMtaWdub3JlIGl0ZXJuYWwgZmllbGRcbiAgYWN0aXZlRWxlbWVudC5fX2xleGljYWxFZGl0b3IgPT0gbnVsbCk7XG59XG5mdW5jdGlvbiBpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pIHtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcblxuICB0cnkge1xuICAgIHJldHVybiByb290RWxlbWVudCAhPT0gbnVsbCAmJiByb290RWxlbWVudC5jb250YWlucyhhbmNob3JET00pICYmIHJvb3RFbGVtZW50LmNvbnRhaW5zKGZvY3VzRE9NKSAmJiAvLyBJZ25vcmUgaWYgc2VsZWN0aW9uIGlzIHdpdGhpbiBuZXN0ZWQgZWRpdG9yXG4gICAgYW5jaG9yRE9NICE9PSBudWxsICYmICFpc1NlbGVjdGlvbkNhcHR1cmVkSW5EZWNvcmF0b3JJbnB1dChhbmNob3JET00pICYmIGdldE5lYXJlc3RFZGl0b3JGcm9tRE9NTm9kZShhbmNob3JET00pID09PSBlZGl0b3I7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0RWRpdG9yRnJvbURPTU5vZGUobm9kZSkge1xuICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuXG4gIHdoaWxlIChjdXJyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICBjb25zdCBlZGl0b3IgPSBjdXJyZW50Tm9kZS5fX2xleGljYWxFZGl0b3I7XG5cbiAgICBpZiAoZWRpdG9yICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBlZGl0b3I7XG4gICAgfVxuXG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnRFbGVtZW50KGN1cnJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VGV4dERpcmVjdGlvbih0ZXh0KSB7XG4gIGlmIChSVExfUkVHRVgudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiAncnRsJztcbiAgfVxuXG4gIGlmIChMVFJfUkVHRVgudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiAnbHRyJztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gJGlzVG9rZW5PclNlZ21lbnRlZChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzVG9rZW4oKSB8fCBub2RlLmlzU2VnbWVudGVkKCk7XG59XG5cbmZ1bmN0aW9uIGlzRE9NTm9kZUxleGljYWxUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSBET01fVEVYVF9UWVBFO1xufVxuXG5mdW5jdGlvbiBnZXRET01UZXh0Tm9kZShlbGVtZW50KSB7XG4gIGxldCBub2RlID0gZWxlbWVudDtcblxuICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgaWYgKGlzRE9NTm9kZUxleGljYWxUZXh0Tm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdG9nZ2xlVGV4dEZvcm1hdFR5cGUoZm9ybWF0LCB0eXBlLCBhbGlnbldpdGhGb3JtYXQpIHtcbiAgY29uc3QgYWN0aXZlRm9ybWF0ID0gVEVYVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXTtcbiAgY29uc3QgaXNTdGF0ZUZsYWdQcmVzZW50ID0gZm9ybWF0ICYgYWN0aXZlRm9ybWF0O1xuXG4gIGlmIChpc1N0YXRlRmxhZ1ByZXNlbnQgJiYgKGFsaWduV2l0aEZvcm1hdCA9PT0gbnVsbCB8fCAoYWxpZ25XaXRoRm9ybWF0ICYgYWN0aXZlRm9ybWF0KSA9PT0gMCkpIHtcbiAgICAvLyBSZW1vdmUgdGhlIHN0YXRlIGZsYWcuXG4gICAgcmV0dXJuIGZvcm1hdCBeIGFjdGl2ZUZvcm1hdDtcbiAgfVxuXG4gIGlmIChhbGlnbldpdGhGb3JtYXQgPT09IG51bGwgfHwgYWxpZ25XaXRoRm9ybWF0ICYgYWN0aXZlRm9ybWF0KSB7XG4gICAgLy8gQWRkIHRoZSBzdGF0ZSBmbGFnLlxuICAgIHJldHVybiBmb3JtYXQgfCBhY3RpdmVGb3JtYXQ7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0O1xufVxuZnVuY3Rpb24gJGlzTGVhZk5vZGUobm9kZSkge1xuICByZXR1cm4gJGlzVGV4dE5vZGUobm9kZSkgfHwgJGlzTGluZUJyZWFrTm9kZShub2RlKSB8fCAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpO1xufVxuZnVuY3Rpb24gJHNldE5vZGVLZXkobm9kZSwgZXhpc3RpbmdLZXkpIHtcbiAgaWYgKGV4aXN0aW5nS2V5ICE9IG51bGwpIHtcbiAgICBub2RlLl9fa2V5ID0gZXhpc3RpbmdLZXk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZXJyb3JPblJlYWRPbmx5KCk7XG4gIGVycm9yT25JbmZpbml0ZVRyYW5zZm9ybXMoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gZ2V0QWN0aXZlRWRpdG9yU3RhdGUoKTtcbiAgY29uc3Qga2V5ID0gZ2VuZXJhdGVSYW5kb21LZXkoKTtcblxuICBlZGl0b3JTdGF0ZS5fbm9kZU1hcC5zZXQoa2V5LCBub2RlKTsgLy8gVE9ETyBTcGxpdCB0aGlzIGZ1bmN0aW9uIGludG8gbGVhZi9lbGVtZW50XG5cblxuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBlZGl0b3IuX2RpcnR5RWxlbWVudHMuc2V0KGtleSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZWRpdG9yLl9kaXJ0eUxlYXZlcy5hZGQoa2V5KTtcbiAgfVxuXG4gIGVkaXRvci5fY2xvbmVOb3ROZWVkZWQuYWRkKGtleSk7XG5cbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBIQVNfRElSVFlfTk9ERVM7XG4gIG5vZGUuX19rZXkgPSBrZXk7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsTWFya1BhcmVudEVsZW1lbnRzQXNEaXJ0eShwYXJlbnRLZXksIG5vZGVNYXAsIGRpcnR5RWxlbWVudHMpIHtcbiAgbGV0IG5leHRQYXJlbnRLZXkgPSBwYXJlbnRLZXk7XG5cbiAgd2hpbGUgKG5leHRQYXJlbnRLZXkgIT09IG51bGwpIHtcbiAgICBpZiAoZGlydHlFbGVtZW50cy5oYXMobmV4dFBhcmVudEtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQobmV4dFBhcmVudEtleSk7XG5cbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkaXJ0eUVsZW1lbnRzLnNldChuZXh0UGFyZW50S2V5LCBmYWxzZSk7XG4gICAgbmV4dFBhcmVudEtleSA9IG5vZGUuX19wYXJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRnJvbVBhcmVudChub2RlKSB7XG4gIGNvbnN0IG9sZFBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgaWYgKG9sZFBhcmVudCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHdyaXRhYmxlTm9kZSA9IG5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCB3cml0YWJsZVBhcmVudCA9IG9sZFBhcmVudC5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTsgLy8gVE9ETzogdGhpcyBmdW5jdGlvbiBkdXBsaWNhdGVzIGEgYnVuY2ggb2Ygb3BlcmF0aW9ucywgY2FuIGJlIHNpbXBsaWZpZWQuXG5cbiAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChuZXh0U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3cml0YWJsZU5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVQYXJlbnQuX19maXJzdCA9IG5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0YWJsZVBhcmVudC5fX2ZpcnN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG5cbiAgICAgIGlmIChuZXh0U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3cml0YWJsZU5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSB3cml0YWJsZVByZXZTaWJsaW5nLl9fa2V5O1xuICAgICAgICB3cml0YWJsZVByZXZTaWJsaW5nLl9fbmV4dCA9IHdyaXRhYmxlTmV4dFNpYmxpbmcuX19rZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0YWJsZVByZXZTaWJsaW5nLl9fbmV4dCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHdyaXRhYmxlTm9kZS5fX3ByZXYgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChuZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKHByZXZTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlUHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZVBhcmVudC5fX2xhc3QgPSBwcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVQYXJlbnQuX19sYXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG5cbiAgICAgIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3cml0YWJsZVByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSB3cml0YWJsZU5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IHdyaXRhYmxlUHJldlNpYmxpbmcuX19rZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHdyaXRhYmxlTm9kZS5fX25leHQgPSBudWxsO1xuICAgIH1cblxuICAgIHdyaXRhYmxlUGFyZW50Ll9fc2l6ZS0tO1xuICAgIHdyaXRhYmxlTm9kZS5fX3BhcmVudCA9IG51bGw7XG4gIH1cbn0gLy8gTmV2ZXIgdXNlIHRoaXMgZnVuY3Rpb24gZGlyZWN0bHkhIEl0IHdpbGwgYnJlYWtcbi8vIHRoZSBjbG9uaW5nIGhldXJpc3RpYy4gSW5zdGVhZCB1c2Ugbm9kZS5nZXRXcml0YWJsZSgpLlxuXG5mdW5jdGlvbiBpbnRlcm5hbE1hcmtOb2RlQXNEaXJ0eShub2RlKSB7XG4gIGVycm9yT25JbmZpbml0ZVRyYW5zZm9ybXMoKTtcbiAgY29uc3QgbGF0ZXN0ID0gbm9kZS5nZXRMYXRlc3QoKTtcbiAgY29uc3QgcGFyZW50ID0gbGF0ZXN0Ll9fcGFyZW50O1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IGRpcnR5RWxlbWVudHMgPSBlZGl0b3IuX2RpcnR5RWxlbWVudHM7XG5cbiAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGludGVybmFsTWFya1BhcmVudEVsZW1lbnRzQXNEaXJ0eShwYXJlbnQsIG5vZGVNYXAsIGRpcnR5RWxlbWVudHMpO1xuICB9XG5cbiAgY29uc3Qga2V5ID0gbGF0ZXN0Ll9fa2V5O1xuICBlZGl0b3IuX2RpcnR5VHlwZSA9IEhBU19ESVJUWV9OT0RFUztcblxuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBkaXJ0eUVsZW1lbnRzLnNldChrZXksIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8gc3BsaXQgaW50ZXJuYWxseSBNYXJrTm9kZUFzRGlydHkgaW50byB0d28gZGVkaWNhdGVkIEVsZW1lbnQvbGVhdmUgZnVuY3Rpb25zXG4gICAgZWRpdG9yLl9kaXJ0eUxlYXZlcy5hZGQoa2V5KTtcbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJuYWxNYXJrU2libGluZ3NBc0RpcnR5KG5vZGUpIHtcbiAgY29uc3QgcHJldmlvdXNOb2RlID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgY29uc3QgbmV4dE5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgaWYgKHByZXZpb3VzTm9kZSAhPT0gbnVsbCkge1xuICAgIGludGVybmFsTWFya05vZGVBc0RpcnR5KHByZXZpb3VzTm9kZSk7XG4gIH1cblxuICBpZiAobmV4dE5vZGUgIT09IG51bGwpIHtcbiAgICBpbnRlcm5hbE1hcmtOb2RlQXNEaXJ0eShuZXh0Tm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRzZXRDb21wb3NpdGlvbktleShjb21wb3NpdGlvbktleSkge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IHByZXZpb3VzQ29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuXG4gIGlmIChjb21wb3NpdGlvbktleSAhPT0gcHJldmlvdXNDb21wb3NpdGlvbktleSkge1xuICAgIGVkaXRvci5fY29tcG9zaXRpb25LZXkgPSBjb21wb3NpdGlvbktleTtcblxuICAgIGlmIChwcmV2aW91c0NvbXBvc2l0aW9uS2V5ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShwcmV2aW91c0NvbXBvc2l0aW9uS2V5KTtcblxuICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb21wb3NpdGlvbktleSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgbm9kZSA9ICRnZXROb2RlQnlLZXkoY29tcG9zaXRpb25LZXkpO1xuXG4gICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmdldFdyaXRhYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkZ2V0Q29tcG9zaXRpb25LZXkoKSB7XG4gIGlmIChpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgcmV0dXJuIGVkaXRvci5fY29tcG9zaXRpb25LZXk7XG59XG5mdW5jdGlvbiAkZ2V0Tm9kZUJ5S2V5KGtleSwgX2VkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gX2VkaXRvclN0YXRlIHx8IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG5cbiAgY29uc3Qgbm9kZSA9IGVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChrZXkpO1xuXG4gIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZUZyb21ET01Ob2RlKGRvbSwgZWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7IC8vIEB0cy1pZ25vcmUgV2UgaW50ZW50aW9uYWxseSBhZGQgdGhpcyB0byB0aGUgTm9kZS5cblxuICBjb25zdCBrZXkgPSBkb21bYF9fbGV4aWNhbEtleV8ke2VkaXRvci5fa2V5fWBdO1xuXG4gIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAkZ2V0Tm9kZUJ5S2V5KGtleSwgZWRpdG9yU3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShzdGFydGluZ0RPTSwgZWRpdG9yU3RhdGUpIHtcbiAgbGV0IGRvbSA9IHN0YXJ0aW5nRE9NO1xuXG4gIHdoaWxlIChkb20gIT0gbnVsbCkge1xuICAgIGNvbnN0IG5vZGUgPSBnZXROb2RlRnJvbURPTU5vZGUoZG9tLCBlZGl0b3JTdGF0ZSk7XG5cbiAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgZG9tID0gZ2V0UGFyZW50RWxlbWVudChkb20pO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjbG9uZURlY29yYXRvcnMoZWRpdG9yKSB7XG4gIGNvbnN0IGN1cnJlbnREZWNvcmF0b3JzID0gZWRpdG9yLl9kZWNvcmF0b3JzO1xuICBjb25zdCBwZW5kaW5nRGVjb3JhdG9ycyA9IE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnREZWNvcmF0b3JzKTtcbiAgZWRpdG9yLl9wZW5kaW5nRGVjb3JhdG9ycyA9IHBlbmRpbmdEZWNvcmF0b3JzO1xuICByZXR1cm4gcGVuZGluZ0RlY29yYXRvcnM7XG59XG5mdW5jdGlvbiBnZXRFZGl0b3JTdGF0ZVRleHRDb250ZW50KGVkaXRvclN0YXRlKSB7XG4gIHJldHVybiBlZGl0b3JTdGF0ZS5yZWFkKCgpID0+ICRnZXRSb290KCkuZ2V0VGV4dENvbnRlbnQoKSk7XG59XG5mdW5jdGlvbiBtYXJrQWxsTm9kZXNBc0RpcnR5KGVkaXRvciwgdHlwZSkge1xuICAvLyBNYXJrIGFsbCBleGlzdGluZyB0ZXh0IG5vZGVzIGFzIGRpcnR5XG4gIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG5cbiAgICBpZiAoZWRpdG9yU3RhdGUuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdyb290Jykge1xuICAgICAgJGdldFJvb3QoKS5tYXJrRGlydHkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG5cbiAgICBmb3IgKGNvbnN0IFssIG5vZGVdIG9mIG5vZGVNYXApIHtcbiAgICAgIG5vZGUubWFya0RpcnR5KCk7XG4gICAgfVxuICB9LCBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9PT0gbnVsbCA/IHtcbiAgICB0YWc6ICdoaXN0b3J5LW1lcmdlJ1xuICB9IDogdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uICRnZXRSb290KCkge1xuICByZXR1cm4gaW50ZXJuYWxHZXRSb290KGdldEFjdGl2ZUVkaXRvclN0YXRlKCkpO1xufVxuZnVuY3Rpb24gaW50ZXJuYWxHZXRSb290KGVkaXRvclN0YXRlKSB7XG4gIHJldHVybiBlZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQoJ3Jvb3QnKTtcbn1cbmZ1bmN0aW9uICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG5cbiAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4oc2VsZWN0aW9uKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYCRzZXRTZWxlY3Rpb24gY2FsbGVkIG9uIGZyb3plbiBzZWxlY3Rpb24gb2JqZWN0LiBFbnN1cmUgc2VsZWN0aW9uIGlzIGNsb25lZCBiZWZvcmUgcGFzc2luZyBpbi5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgc2VsZWN0aW9uLl9jYWNoZWROb2RlcyA9IG51bGw7XG4gIH1cblxuICBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJGZsdXNoTXV0YXRpb25zKCkge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGZsdXNoUm9vdE11dGF0aW9ucyhlZGl0b3IpO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZUZyb21ET00oZG9tKSB7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICBjb25zdCBub2RlS2V5ID0gZ2V0Tm9kZUtleUZyb21ET00oZG9tLCBlZGl0b3IpO1xuXG4gIGlmIChub2RlS2V5ID09PSBudWxsKSB7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcblxuICAgIGlmIChkb20gPT09IHJvb3RFbGVtZW50KSB7XG4gICAgICByZXR1cm4gJGdldE5vZGVCeUtleSgncm9vdCcpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuICRnZXROb2RlQnlLZXkobm9kZUtleSk7XG59XG5mdW5jdGlvbiBnZXRUZXh0Tm9kZU9mZnNldChub2RlLCBtb3ZlU2VsZWN0aW9uVG9FbmQpIHtcbiAgcmV0dXJuIG1vdmVTZWxlY3Rpb25Ub0VuZCA/IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgOiAwO1xufVxuXG5mdW5jdGlvbiBnZXROb2RlS2V5RnJvbURPTSggLy8gTm90ZSB0aGF0IG5vZGUgaGVyZSByZWZlcnMgdG8gYSBET00gTm9kZSwgbm90IGFuIExleGljYWwgTm9kZVxuZG9tLCBlZGl0b3IpIHtcbiAgbGV0IG5vZGUgPSBkb207XG5cbiAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgIC8vIEB0cy1pZ25vcmUgV2UgaW50ZW50aW9uYWxseSBhZGQgdGhpcyB0byB0aGUgTm9kZS5cbiAgICBjb25zdCBrZXkgPSBub2RlW2BfX2xleGljYWxLZXlfJHtlZGl0b3IuX2tleX1gXTtcblxuICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0UGFyZW50RWxlbWVudChub2RlKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBkb2VzQ29udGFpbkdyYXBoZW1lKHN0cikge1xuICByZXR1cm4gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZy50ZXN0KHN0cik7XG59XG5mdW5jdGlvbiBnZXRFZGl0b3JzVG9Qcm9wYWdhdGUoZWRpdG9yKSB7XG4gIGNvbnN0IGVkaXRvcnNUb1Byb3BhZ2F0ZSA9IFtdO1xuICBsZXQgY3VycmVudEVkaXRvciA9IGVkaXRvcjtcblxuICB3aGlsZSAoY3VycmVudEVkaXRvciAhPT0gbnVsbCkge1xuICAgIGVkaXRvcnNUb1Byb3BhZ2F0ZS5wdXNoKGN1cnJlbnRFZGl0b3IpO1xuICAgIGN1cnJlbnRFZGl0b3IgPSBjdXJyZW50RWRpdG9yLl9wYXJlbnRFZGl0b3I7XG4gIH1cblxuICByZXR1cm4gZWRpdG9yc1RvUHJvcGFnYXRlO1xufVxuZnVuY3Rpb24gY3JlYXRlVUlEKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikucmVwbGFjZSgvW15hLXpdKy9nLCAnJykuc3Vic3RyKDAsIDUpO1xufVxuZnVuY3Rpb24gZ2V0QW5jaG9yVGV4dEZyb21ET00oYW5jaG9yTm9kZSkge1xuICBpZiAoYW5jaG9yTm9kZS5ub2RlVHlwZSA9PT0gRE9NX1RFWFRfVFlQRSkge1xuICAgIHJldHVybiBhbmNob3JOb2RlLm5vZGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gJHVwZGF0ZVNlbGVjdGVkVGV4dEZyb21ET00oaXNDb21wb3NpdGlvbkVuZCwgZWRpdG9yLCBkYXRhKSB7XG4gIC8vIFVwZGF0ZSB0aGUgdGV4dCBjb250ZW50IHdpdGggdGhlIGxhdGVzdCBjb21wb3NpdGlvbiB0ZXh0XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG5cbiAgaWYgKGRvbVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgbGV0IHtcbiAgICBhbmNob3JPZmZzZXQsXG4gICAgZm9jdXNPZmZzZXRcbiAgfSA9IGRvbVNlbGVjdGlvbjtcblxuICBpZiAoYW5jaG9yTm9kZSAhPT0gbnVsbCkge1xuICAgIGxldCB0ZXh0Q29udGVudCA9IGdldEFuY2hvclRleHRGcm9tRE9NKGFuY2hvck5vZGUpO1xuICAgIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShhbmNob3JOb2RlKTtcblxuICAgIGlmICh0ZXh0Q29udGVudCAhPT0gbnVsbCAmJiAkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgLy8gRGF0YSBpcyBpbnRlbnRpb25hbGx5IHRydXRoeSwgYXMgd2UgY2hlY2sgZm9yIGJvb2xlYW4sIG51bGwgYW5kIGVtcHR5IHN0cmluZy5cbiAgICAgIGlmICh0ZXh0Q29udGVudCA9PT0gQ09NUE9TSVRJT05fU1VGRklYICYmIGRhdGEpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRleHRDb250ZW50ID0gZGF0YTtcbiAgICAgICAgYW5jaG9yT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBmb2N1c09mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRDb250ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICR1cGRhdGVUZXh0Tm9kZUZyb21ET01Db250ZW50KG5vZGUsIHRleHRDb250ZW50LCBhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0LCBpc0NvbXBvc2l0aW9uRW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICR1cGRhdGVUZXh0Tm9kZUZyb21ET01Db250ZW50KHRleHROb2RlLCB0ZXh0Q29udGVudCwgYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCwgY29tcG9zaXRpb25FbmQpIHtcbiAgbGV0IG5vZGUgPSB0ZXh0Tm9kZTtcblxuICBpZiAobm9kZS5pc0F0dGFjaGVkKCkgJiYgKGNvbXBvc2l0aW9uRW5kIHx8ICFub2RlLmlzRGlydHkoKSkpIHtcbiAgICBjb25zdCBpc0NvbXBvc2luZyA9IG5vZGUuaXNDb21wb3NpbmcoKTtcbiAgICBsZXQgbm9ybWFsaXplZFRleHRDb250ZW50ID0gdGV4dENvbnRlbnQ7XG5cbiAgICBpZiAoKGlzQ29tcG9zaW5nIHx8IGNvbXBvc2l0aW9uRW5kKSAmJiB0ZXh0Q29udGVudFt0ZXh0Q29udGVudC5sZW5ndGggLSAxXSA9PT0gQ09NUE9TSVRJT05fU1VGRklYKSB7XG4gICAgICBub3JtYWxpemVkVGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJldlRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuXG4gICAgaWYgKGNvbXBvc2l0aW9uRW5kIHx8IG5vcm1hbGl6ZWRUZXh0Q29udGVudCAhPT0gcHJldlRleHRDb250ZW50KSB7XG4gICAgICBpZiAobm9ybWFsaXplZFRleHRDb250ZW50ID09PSAnJykge1xuICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG5cbiAgICAgICAgaWYgKCFJU19TQUZBUkkgJiYgIUlTX0lPUyAmJiAhSVNfQVBQTEVfV0VCS0lUKSB7XG4gICAgICAgICAgLy8gRm9yIGNvbXBvc2l0aW9uIChtYWlubHkgQW5kcm9pZCksIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBub2RlIG9uIGEgbGF0ZXIgdXBkYXRlXG4gICAgICAgICAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgMjApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgICBjb25zdCBwcmV2VGV4dENvbnRlbnRTaXplID0gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG4gICAgICBjb25zdCBub2RlS2V5ID0gbm9kZS5nZXRLZXkoKTtcblxuICAgICAgaWYgKG5vZGUuaXNUb2tlbigpIHx8IGNvbXBvc2l0aW9uS2V5ICE9PSBudWxsICYmIG5vZGVLZXkgPT09IGNvbXBvc2l0aW9uS2V5ICYmICFpc0NvbXBvc2luZyB8fCAvLyBDaGVjayBpZiBjaGFyYWN0ZXIgd2FzIGFkZGVkIGF0IHRoZSBzdGFydCBvciBib3VuZGFyaWVzIHdoZW4gbm90IGluc2VydGFibGUsIGFuZCB3ZSBuZWVkXG4gICAgICAvLyB0byBjbGVhciB0aGlzIGlucHV0IGZyb20gb2NjdXJyaW5nIGFzIHRoYXQgYWN0aW9uIHdhc24ndCBwZXJtaXR0ZWQuXG4gICAgICAkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiAocGFyZW50ICE9PSBudWxsICYmICFwYXJlbnQuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpICYmIHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMCB8fCBwcmV2U2VsZWN0aW9uLmFuY2hvci5rZXkgPT09IHRleHROb2RlLl9fa2V5ICYmIHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMCAmJiAhbm9kZS5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgfHwgcHJldlNlbGVjdGlvbi5mb2N1cy5rZXkgPT09IHRleHROb2RlLl9fa2V5ICYmIHByZXZTZWxlY3Rpb24uZm9jdXMub2Zmc2V0ID09PSBwcmV2VGV4dENvbnRlbnRTaXplICYmICFub2RlLmNhbkluc2VydFRleHRBZnRlcigpKSkge1xuICAgICAgICBub2RlLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IGFuY2hvck9mZnNldCA9PT0gbnVsbCB8fCBmb2N1c09mZnNldCA9PT0gbnVsbCkge1xuICAgICAgICBub2RlLnNldFRleHRDb250ZW50KG5vcm1hbGl6ZWRUZXh0Q29udGVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2Uobm9kZSwgYW5jaG9yT2Zmc2V0LCBub2RlLCBmb2N1c09mZnNldCk7XG5cbiAgICAgIGlmIChub2RlLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUZXh0Q29udGVudCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSAkY3JlYXRlVGV4dE5vZGUob3JpZ2luYWxUZXh0Q29udGVudCk7XG4gICAgICAgIG5vZGUucmVwbGFjZShyZXBsYWNlbWVudCk7XG4gICAgICAgIG5vZGUgPSByZXBsYWNlbWVudDtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zZXRUZXh0Q29udGVudChub3JtYWxpemVkVGV4dENvbnRlbnQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiAkcHJldmlvdXNTaWJsaW5nRG9lc05vdEFjY2VwdFRleHQobm9kZSkge1xuICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICByZXR1cm4gKCRpc1RleHROb2RlKHByZXZpb3VzU2libGluZykgfHwgJGlzRWxlbWVudE5vZGUocHJldmlvdXNTaWJsaW5nKSAmJiBwcmV2aW91c1NpYmxpbmcuaXNJbmxpbmUoKSkgJiYgIXByZXZpb3VzU2libGluZy5jYW5JbnNlcnRUZXh0QWZ0ZXIoKTtcbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBjb25uZWN0ZWQgdG8gJHNob3VsZFByZXZlbnREZWZhdWx0QW5kSW5zZXJ0VGV4dCBhbmQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZVxuLy8gVGV4dE5vZGUgYm91bmRhcmllcyBhcmUgd3JpdGFibGUgb3Igd2Ugc2hvdWxkIHVzZSB0aGUgcHJldmlvdXMvbmV4dCBzaWJsaW5nIGluc3RlYWQuIEZvciBleGFtcGxlLFxuLy8gaW4gdGhlIGNhc2Ugb2YgYSBMaW5rTm9kZSwgYm91bmRhcmllcyBhcmUgbm90IHdyaXRhYmxlLlxuXG5cbmZ1bmN0aW9uICRzaG91bGRJbnNlcnRUZXh0QWZ0ZXJPckJlZm9yZVRleHROb2RlKHNlbGVjdGlvbiwgbm9kZSkge1xuICBpZiAobm9kZS5pc1NlZ21lbnRlZCgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgb2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICBjb25zdCBpc1Rva2VuID0gbm9kZS5pc1Rva2VuKCk7XG5cbiAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgIHJldHVybiAhbm9kZS5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgfHwgIXBhcmVudC5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgfHwgaXNUb2tlbiB8fCAkcHJldmlvdXNTaWJsaW5nRG9lc05vdEFjY2VwdFRleHQobm9kZSk7XG4gIH0gZWxzZSBpZiAob2Zmc2V0ID09PSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgcmV0dXJuICFub2RlLmNhbkluc2VydFRleHRBZnRlcigpIHx8ICFwYXJlbnQuY2FuSW5zZXJ0VGV4dEFmdGVyKCkgfHwgaXNUb2tlbjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVGFiKGtleUNvZGUsIGFsdEtleSwgY3RybEtleSwgbWV0YUtleSkge1xuICByZXR1cm4ga2V5Q29kZSA9PT0gOSAmJiAhYWx0S2V5ICYmICFjdHJsS2V5ICYmICFtZXRhS2V5O1xufVxuZnVuY3Rpb24gaXNCb2xkKGtleUNvZGUsIGFsdEtleSwgbWV0YUtleSwgY3RybEtleSkge1xuICByZXR1cm4ga2V5Q29kZSA9PT0gNjYgJiYgIWFsdEtleSAmJiBjb250cm9sT3JNZXRhKG1ldGFLZXksIGN0cmxLZXkpO1xufVxuZnVuY3Rpb24gaXNJdGFsaWMoa2V5Q29kZSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBrZXlDb2RlID09PSA3MyAmJiAhYWx0S2V5ICYmIGNvbnRyb2xPck1ldGEobWV0YUtleSwgY3RybEtleSk7XG59XG5mdW5jdGlvbiBpc1VuZGVybGluZShrZXlDb2RlLCBhbHRLZXksIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgcmV0dXJuIGtleUNvZGUgPT09IDg1ICYmICFhbHRLZXkgJiYgY29udHJvbE9yTWV0YShtZXRhS2V5LCBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uIGlzUGFyYWdyYXBoKGtleUNvZGUsIHNoaWZ0S2V5KSB7XG4gIHJldHVybiBpc1JldHVybihrZXlDb2RlKSAmJiAhc2hpZnRLZXk7XG59XG5mdW5jdGlvbiBpc0xpbmVCcmVhayhrZXlDb2RlLCBzaGlmdEtleSkge1xuICByZXR1cm4gaXNSZXR1cm4oa2V5Q29kZSkgJiYgc2hpZnRLZXk7XG59IC8vIEluc2VydHMgYSBuZXcgbGluZSBhZnRlciB0aGUgc2VsZWN0aW9uXG5cbmZ1bmN0aW9uIGlzT3BlbkxpbmVCcmVhayhrZXlDb2RlLCBjdHJsS2V5KSB7XG4gIC8vIDc5ID0gS2V5T1xuICByZXR1cm4gSVNfQVBQTEUgJiYgY3RybEtleSAmJiBrZXlDb2RlID09PSA3OTtcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlV29yZEJhY2t3YXJkKGtleUNvZGUsIGFsdEtleSwgY3RybEtleSkge1xuICByZXR1cm4gaXNCYWNrc3BhY2Uoa2V5Q29kZSkgJiYgKElTX0FQUExFID8gYWx0S2V5IDogY3RybEtleSk7XG59XG5mdW5jdGlvbiBpc0RlbGV0ZVdvcmRGb3J3YXJkKGtleUNvZGUsIGFsdEtleSwgY3RybEtleSkge1xuICByZXR1cm4gaXNEZWxldGUoa2V5Q29kZSkgJiYgKElTX0FQUExFID8gYWx0S2V5IDogY3RybEtleSk7XG59XG5mdW5jdGlvbiBpc0RlbGV0ZUxpbmVCYWNrd2FyZChrZXlDb2RlLCBtZXRhS2V5KSB7XG4gIHJldHVybiBJU19BUFBMRSAmJiBtZXRhS2V5ICYmIGlzQmFja3NwYWNlKGtleUNvZGUpO1xufVxuZnVuY3Rpb24gaXNEZWxldGVMaW5lRm9yd2FyZChrZXlDb2RlLCBtZXRhS2V5KSB7XG4gIHJldHVybiBJU19BUFBMRSAmJiBtZXRhS2V5ICYmIGlzRGVsZXRlKGtleUNvZGUpO1xufVxuZnVuY3Rpb24gaXNEZWxldGVCYWNrd2FyZChrZXlDb2RlLCBhbHRLZXksIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgaWYgKElTX0FQUExFKSB7XG4gICAgaWYgKGFsdEtleSB8fCBtZXRhS2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzQmFja3NwYWNlKGtleUNvZGUpIHx8IGtleUNvZGUgPT09IDcyICYmIGN0cmxLZXk7XG4gIH1cblxuICBpZiAoY3RybEtleSB8fCBhbHRLZXkgfHwgbWV0YUtleSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0JhY2tzcGFjZShrZXlDb2RlKTtcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlRm9yd2FyZChrZXlDb2RlLCBjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSB7XG4gIGlmIChJU19BUFBMRSkge1xuICAgIGlmIChzaGlmdEtleSB8fCBhbHRLZXkgfHwgbWV0YUtleSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBpc0RlbGV0ZShrZXlDb2RlKSB8fCBrZXlDb2RlID09PSA2OCAmJiBjdHJsS2V5O1xuICB9XG5cbiAgaWYgKGN0cmxLZXkgfHwgYWx0S2V5IHx8IG1ldGFLZXkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNEZWxldGUoa2V5Q29kZSk7XG59XG5mdW5jdGlvbiBpc1VuZG8oa2V5Q29kZSwgc2hpZnRLZXksIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgcmV0dXJuIGtleUNvZGUgPT09IDkwICYmICFzaGlmdEtleSAmJiBjb250cm9sT3JNZXRhKG1ldGFLZXksIGN0cmxLZXkpO1xufVxuZnVuY3Rpb24gaXNSZWRvKGtleUNvZGUsIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIGlmIChJU19BUFBMRSkge1xuICAgIHJldHVybiBrZXlDb2RlID09PSA5MCAmJiBtZXRhS2V5ICYmIHNoaWZ0S2V5O1xuICB9XG5cbiAgcmV0dXJuIGtleUNvZGUgPT09IDg5ICYmIGN0cmxLZXkgfHwga2V5Q29kZSA9PT0gOTAgJiYgY3RybEtleSAmJiBzaGlmdEtleTtcbn1cbmZ1bmN0aW9uIGlzQ29weShrZXlDb2RlLCBzaGlmdEtleSwgbWV0YUtleSwgY3RybEtleSkge1xuICBpZiAoc2hpZnRLZXkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoa2V5Q29kZSA9PT0gNjcpIHtcbiAgICByZXR1cm4gSVNfQVBQTEUgPyBtZXRhS2V5IDogY3RybEtleTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ3V0KGtleUNvZGUsIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIGlmIChzaGlmdEtleSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChrZXlDb2RlID09PSA4OCkge1xuICAgIHJldHVybiBJU19BUFBMRSA/IG1ldGFLZXkgOiBjdHJsS2V5O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Fycm93TGVmdChrZXlDb2RlKSB7XG4gIHJldHVybiBrZXlDb2RlID09PSAzNztcbn1cblxuZnVuY3Rpb24gaXNBcnJvd1JpZ2h0KGtleUNvZGUpIHtcbiAgcmV0dXJuIGtleUNvZGUgPT09IDM5O1xufVxuXG5mdW5jdGlvbiBpc0Fycm93VXAoa2V5Q29kZSkge1xuICByZXR1cm4ga2V5Q29kZSA9PT0gMzg7XG59XG5cbmZ1bmN0aW9uIGlzQXJyb3dEb3duKGtleUNvZGUpIHtcbiAgcmV0dXJuIGtleUNvZGUgPT09IDQwO1xufVxuXG5mdW5jdGlvbiBpc01vdmVCYWNrd2FyZChrZXlDb2RlLCBjdHJsS2V5LCBhbHRLZXksIG1ldGFLZXkpIHtcbiAgcmV0dXJuIGlzQXJyb3dMZWZ0KGtleUNvZGUpICYmICFjdHJsS2V5ICYmICFtZXRhS2V5ICYmICFhbHRLZXk7XG59XG5mdW5jdGlvbiBpc01vdmVUb1N0YXJ0KGtleUNvZGUsIGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpIHtcbiAgcmV0dXJuIGlzQXJyb3dMZWZ0KGtleUNvZGUpICYmICFhbHRLZXkgJiYgIXNoaWZ0S2V5ICYmIChjdHJsS2V5IHx8IG1ldGFLZXkpO1xufVxuZnVuY3Rpb24gaXNNb3ZlRm9yd2FyZChrZXlDb2RlLCBjdHJsS2V5LCBhbHRLZXksIG1ldGFLZXkpIHtcbiAgcmV0dXJuIGlzQXJyb3dSaWdodChrZXlDb2RlKSAmJiAhY3RybEtleSAmJiAhbWV0YUtleSAmJiAhYWx0S2V5O1xufVxuZnVuY3Rpb24gaXNNb3ZlVG9FbmQoa2V5Q29kZSwgY3RybEtleSwgc2hpZnRLZXksIGFsdEtleSwgbWV0YUtleSkge1xuICByZXR1cm4gaXNBcnJvd1JpZ2h0KGtleUNvZGUpICYmICFhbHRLZXkgJiYgIXNoaWZ0S2V5ICYmIChjdHJsS2V5IHx8IG1ldGFLZXkpO1xufVxuZnVuY3Rpb24gaXNNb3ZlVXAoa2V5Q29kZSwgY3RybEtleSwgbWV0YUtleSkge1xuICByZXR1cm4gaXNBcnJvd1VwKGtleUNvZGUpICYmICFjdHJsS2V5ICYmICFtZXRhS2V5O1xufVxuZnVuY3Rpb24gaXNNb3ZlRG93bihrZXlDb2RlLCBjdHJsS2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBpc0Fycm93RG93bihrZXlDb2RlKSAmJiAhY3RybEtleSAmJiAhbWV0YUtleTtcbn1cbmZ1bmN0aW9uIGlzTW9kaWZpZXIoY3RybEtleSwgc2hpZnRLZXksIGFsdEtleSwgbWV0YUtleSkge1xuICByZXR1cm4gY3RybEtleSB8fCBzaGlmdEtleSB8fCBhbHRLZXkgfHwgbWV0YUtleTtcbn1cbmZ1bmN0aW9uIGlzU3BhY2Uoa2V5Q29kZSkge1xuICByZXR1cm4ga2V5Q29kZSA9PT0gMzI7XG59XG5mdW5jdGlvbiBjb250cm9sT3JNZXRhKG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgaWYgKElTX0FQUExFKSB7XG4gICAgcmV0dXJuIG1ldGFLZXk7XG4gIH1cblxuICByZXR1cm4gY3RybEtleTtcbn1cbmZ1bmN0aW9uIGlzUmV0dXJuKGtleUNvZGUpIHtcbiAgcmV0dXJuIGtleUNvZGUgPT09IDEzO1xufVxuZnVuY3Rpb24gaXNCYWNrc3BhY2Uoa2V5Q29kZSkge1xuICByZXR1cm4ga2V5Q29kZSA9PT0gODtcbn1cbmZ1bmN0aW9uIGlzRXNjYXBlKGtleUNvZGUpIHtcbiAgcmV0dXJuIGtleUNvZGUgPT09IDI3O1xufVxuZnVuY3Rpb24gaXNEZWxldGUoa2V5Q29kZSkge1xuICByZXR1cm4ga2V5Q29kZSA9PT0gNDY7XG59XG5mdW5jdGlvbiBpc1NlbGVjdEFsbChrZXlDb2RlLCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBrZXlDb2RlID09PSA2NSAmJiBjb250cm9sT3JNZXRhKG1ldGFLZXksIGN0cmxLZXkpO1xufVxuZnVuY3Rpb24gJHNlbGVjdEFsbCgpIHtcbiAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IHJvb3Quc2VsZWN0KDAsIHJvb3QuZ2V0Q2hpbGRyZW5TaXplKCkpO1xuICAkc2V0U2VsZWN0aW9uKCRub3JtYWxpemVTZWxlY3Rpb24oc2VsZWN0aW9uKSk7XG59XG5mdW5jdGlvbiBnZXRDYWNoZWRDbGFzc05hbWVBcnJheShjbGFzc05hbWVzVGhlbWUsIGNsYXNzTmFtZVRoZW1lVHlwZSkge1xuICBpZiAoY2xhc3NOYW1lc1RoZW1lLl9fbGV4aWNhbENsYXNzTmFtZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICBjbGFzc05hbWVzVGhlbWUuX19sZXhpY2FsQ2xhc3NOYW1lQ2FjaGUgPSB7fTtcbiAgfVxuXG4gIGNvbnN0IGNsYXNzTmFtZXNDYWNoZSA9IGNsYXNzTmFtZXNUaGVtZS5fX2xleGljYWxDbGFzc05hbWVDYWNoZTtcbiAgY29uc3QgY2FjaGVkQ2xhc3NOYW1lcyA9IGNsYXNzTmFtZXNDYWNoZVtjbGFzc05hbWVUaGVtZVR5cGVdO1xuXG4gIGlmIChjYWNoZWRDbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY2FjaGVkQ2xhc3NOYW1lcztcbiAgfVxuXG4gIGNvbnN0IGNsYXNzTmFtZXMgPSBjbGFzc05hbWVzVGhlbWVbY2xhc3NOYW1lVGhlbWVUeXBlXTsgLy8gQXMgd2UncmUgdXNpbmcgY2xhc3NMaXN0LCB3ZSBuZWVkXG4gIC8vIHRvIGhhbmRsZSBjbGFzc05hbWUgdG9rZW5zIHRoYXQgaGF2ZSBzcGFjZXMuXG4gIC8vIFRoZSBlYXNpZXN0IHdheSB0byBkbyB0aGlzIHRvIGNvbnZlcnQgdGhlXG4gIC8vIGNsYXNzTmFtZSB0b2tlbnMgdG8gYW4gYXJyYXkgdGhhdCBjYW4gYmVcbiAgLy8gYXBwbGllZCB0byBjbGFzc0xpc3QuYWRkKCkvcmVtb3ZlKCkuXG5cbiAgaWYgKHR5cGVvZiBjbGFzc05hbWVzID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGNsYXNzTmFtZXNBcnIgPSBjbGFzc05hbWVzLnNwbGl0KCcgJyk7XG4gICAgY2xhc3NOYW1lc0NhY2hlW2NsYXNzTmFtZVRoZW1lVHlwZV0gPSBjbGFzc05hbWVzQXJyO1xuICAgIHJldHVybiBjbGFzc05hbWVzQXJyO1xuICB9XG5cbiAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBzZXRNdXRhdGVkTm9kZShtdXRhdGVkTm9kZXMsIHJlZ2lzdGVyZWROb2RlcywgbXV0YXRpb25MaXN0ZW5lcnMsIG5vZGUsIG11dGF0aW9uKSB7XG4gIGlmIChtdXRhdGlvbkxpc3RlbmVycy5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLl9fdHlwZTtcbiAgY29uc3Qgbm9kZUtleSA9IG5vZGUuX19rZXk7XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gcmVnaXN0ZXJlZE5vZGVzLmdldChub2RlVHlwZSk7XG5cbiAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgVHlwZSAke25vZGVUeXBlfSBub3QgaW4gcmVnaXN0ZXJlZE5vZGVzYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qga2xhc3MgPSByZWdpc3RlcmVkTm9kZS5rbGFzcztcbiAgbGV0IG11dGF0ZWROb2Rlc0J5VHlwZSA9IG11dGF0ZWROb2Rlcy5nZXQoa2xhc3MpO1xuXG4gIGlmIChtdXRhdGVkTm9kZXNCeVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIG11dGF0ZWROb2Rlc0J5VHlwZSA9IG5ldyBNYXAoKTtcbiAgICBtdXRhdGVkTm9kZXMuc2V0KGtsYXNzLCBtdXRhdGVkTm9kZXNCeVR5cGUpO1xuICB9XG5cbiAgY29uc3QgcHJldk11dGF0aW9uID0gbXV0YXRlZE5vZGVzQnlUeXBlLmdldChub2RlS2V5KTsgLy8gSWYgdGhlIG5vZGUgaGFzIGFscmVhZHkgYmVlbiBcImRlc3Ryb3llZFwiLCB5ZXQgd2UgYXJlXG4gIC8vIHJlLW1ha2luZyBpdCwgdGhlbiB0aGlzIG1lYW5zIGEgbW92ZSBsaWtlbHkgaGFwcGVuZWQuXG4gIC8vIFdlIHNob3VsZCBjaGFuZ2UgdGhlIG11dGF0aW9uIHRvIGJlIHRoYXQgb2YgXCJ1cGRhdGVkXCJcbiAgLy8gaW5zdGVhZC5cblxuICBjb25zdCBpc01vdmUgPSBwcmV2TXV0YXRpb24gPT09ICdkZXN0cm95ZWQnICYmIG11dGF0aW9uID09PSAnY3JlYXRlZCc7XG5cbiAgaWYgKHByZXZNdXRhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IGlzTW92ZSkge1xuICAgIG11dGF0ZWROb2Rlc0J5VHlwZS5zZXQobm9kZUtleSwgaXNNb3ZlID8gJ3VwZGF0ZWQnIDogbXV0YXRpb24pO1xuICB9XG59XG5mdW5jdGlvbiAkbm9kZXNPZlR5cGUoa2xhc3MpIHtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCByZWFkT25seSA9IGVkaXRvclN0YXRlLl9yZWFkT25seTtcbiAgY29uc3Qga2xhc3NUeXBlID0ga2xhc3MuZ2V0VHlwZSgpO1xuICBjb25zdCBub2RlcyA9IGVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBjb25zdCBub2Rlc09mVHlwZSA9IFtdO1xuXG4gIGZvciAoY29uc3QgWywgbm9kZV0gb2Ygbm9kZXMpIHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGtsYXNzICYmIG5vZGUuX190eXBlID09PSBrbGFzc1R5cGUgJiYgKHJlYWRPbmx5IHx8IG5vZGUuaXNBdHRhY2hlZCgpKSkge1xuICAgICAgbm9kZXNPZlR5cGUucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZXNPZlR5cGU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVFbGVtZW50KGVsZW1lbnQsIGlzQmFja3dhcmQsIGZvY3VzT2Zmc2V0KSB7XG4gIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQuZ2V0UGFyZW50KCk7XG4gIGxldCBvZmZzZXQgPSBmb2N1c09mZnNldDtcbiAgbGV0IGJsb2NrID0gZWxlbWVudDtcblxuICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKGlzQmFja3dhcmQgJiYgZm9jdXNPZmZzZXQgPT09IDApIHtcbiAgICAgIG9mZnNldCA9IGJsb2NrLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICBibG9jayA9IHBhcmVudDtcbiAgICB9IGVsc2UgaWYgKCFpc0JhY2t3YXJkICYmIGZvY3VzT2Zmc2V0ID09PSBibG9jay5nZXRDaGlsZHJlblNpemUoKSkge1xuICAgICAgb2Zmc2V0ID0gYmxvY2suZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDE7XG4gICAgICBibG9jayA9IHBhcmVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmxvY2suZ2V0Q2hpbGRBdEluZGV4KGlzQmFja3dhcmQgPyBvZmZzZXQgLSAxIDogb2Zmc2V0KTtcbn1cblxuZnVuY3Rpb24gJGdldEFkamFjZW50Tm9kZShmb2N1cywgaXNCYWNrd2FyZCkge1xuICBjb25zdCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcblxuICBpZiAoZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgY29uc3QgYmxvY2sgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgcmV0dXJuIHJlc29sdmVFbGVtZW50KGJsb2NrLCBpc0JhY2t3YXJkLCBmb2N1c09mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuXG4gICAgaWYgKGlzQmFja3dhcmQgJiYgZm9jdXNPZmZzZXQgPT09IDAgfHwgIWlzQmFja3dhcmQgJiYgZm9jdXNPZmZzZXQgPT09IGZvY3VzTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgICAgY29uc3QgcG9zc2libGVOb2RlID0gaXNCYWNrd2FyZCA/IGZvY3VzTm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IGZvY3VzTm9kZS5nZXROZXh0U2libGluZygpO1xuXG4gICAgICBpZiAocG9zc2libGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlRWxlbWVudChmb2N1c05vZGUuZ2V0UGFyZW50T3JUaHJvdygpLCBpc0JhY2t3YXJkLCBmb2N1c05vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIChpc0JhY2t3YXJkID8gMCA6IDEpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvc3NpYmxlTm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzRmlyZWZveENsaXBib2FyZEV2ZW50cyhlZGl0b3IpIHtcbiAgY29uc3QgZXZlbnQgPSBnZXRXaW5kb3coZWRpdG9yKS5ldmVudDtcbiAgY29uc3QgaW5wdXRUeXBlID0gZXZlbnQgJiYgZXZlbnQuaW5wdXRUeXBlO1xuICByZXR1cm4gaW5wdXRUeXBlID09PSAnaW5zZXJ0RnJvbVBhc3RlJyB8fCBpbnB1dFR5cGUgPT09ICdpbnNlcnRGcm9tUGFzdGVBc1F1b3RhdGlvbic7XG59XG5mdW5jdGlvbiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBjb21tYW5kLCBwYXlsb2FkKSB7XG4gIHJldHVybiB0cmlnZ2VyQ29tbWFuZExpc3RlbmVycyhlZGl0b3IsIGNvbW1hbmQsIHBheWxvYWQpO1xufVxuZnVuY3Rpb24gJHRleHRDb250ZW50UmVxdWlyZXNEb3VibGVMaW5lYnJlYWtBdEVuZChub2RlKSB7XG4gIHJldHVybiAhJGlzUm9vdE5vZGUobm9kZSkgJiYgIW5vZGUuaXNMYXN0Q2hpbGQoKSAmJiAhbm9kZS5pc0lubGluZSgpO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudEJ5S2V5T3JUaHJvdyhlZGl0b3IsIGtleSkge1xuICBjb25zdCBlbGVtZW50ID0gZWRpdG9yLl9rZXlUb0RPTU1hcC5nZXQoa2V5KTtcblxuICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYFJlY29uY2lsaWF0aW9uOiBjb3VsZCBub3QgZmluZCBET00gZWxlbWVudCBmb3Igbm9kZSBrZXkgJHtrZXl9YCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRFbGVtZW50KG5vZGUpIHtcbiAgY29uc3QgcGFyZW50RWxlbWVudCA9IG5vZGUuYXNzaWduZWRTbG90IHx8IG5vZGUucGFyZW50RWxlbWVudDtcbiAgcmV0dXJuIHBhcmVudEVsZW1lbnQgIT09IG51bGwgJiYgcGFyZW50RWxlbWVudC5ub2RlVHlwZSA9PT0gMTEgPyBwYXJlbnRFbGVtZW50Lmhvc3QgOiBwYXJlbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChlZGl0b3IsIHNlbGVjdGlvblJlY3QsIHJvb3RFbGVtZW50KSB7XG4gIGNvbnN0IGRvYyA9IHJvb3RFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGNvbnN0IGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3O1xuXG4gIGlmIChkZWZhdWx0VmlldyA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCB7XG4gICAgdG9wOiBjdXJyZW50VG9wLFxuICAgIGJvdHRvbTogY3VycmVudEJvdHRvbVxuICB9ID0gc2VsZWN0aW9uUmVjdDtcbiAgbGV0IHRhcmdldFRvcCA9IDA7XG4gIGxldCB0YXJnZXRCb3R0b20gPSAwO1xuICBsZXQgZWxlbWVudCA9IHJvb3RFbGVtZW50O1xuXG4gIHdoaWxlIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgY29uc3QgaXNCb2R5RWxlbWVudCA9IGVsZW1lbnQgPT09IGRvYy5ib2R5O1xuXG4gICAgaWYgKGlzQm9keUVsZW1lbnQpIHtcbiAgICAgIHRhcmdldFRvcCA9IDA7XG4gICAgICB0YXJnZXRCb3R0b20gPSBnZXRXaW5kb3coZWRpdG9yKS5pbm5lckhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0YXJnZXRUb3AgPSB0YXJnZXRSZWN0LnRvcDtcbiAgICAgIHRhcmdldEJvdHRvbSA9IHRhcmdldFJlY3QuYm90dG9tO1xuICAgIH1cblxuICAgIGxldCBkaWZmID0gMDtcblxuICAgIGlmIChjdXJyZW50VG9wIDwgdGFyZ2V0VG9wKSB7XG4gICAgICBkaWZmID0gLSh0YXJnZXRUb3AgLSBjdXJyZW50VG9wKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRCb3R0b20gPiB0YXJnZXRCb3R0b20pIHtcbiAgICAgIGRpZmYgPSBjdXJyZW50Qm90dG9tIC0gdGFyZ2V0Qm90dG9tO1xuICAgIH1cblxuICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICBpZiAoaXNCb2R5RWxlbWVudCkge1xuICAgICAgICAvLyBPbmx5IGhhbmRsZXMgc2Nyb2xsaW5nIG9mIFkgYXhpc1xuICAgICAgICBkZWZhdWx0Vmlldy5zY3JvbGxCeSgwLCBkaWZmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCArPSBkaWZmO1xuICAgICAgICBjb25zdCB5T2Zmc2V0ID0gZWxlbWVudC5zY3JvbGxUb3AgLSBzY3JvbGxUb3A7XG4gICAgICAgIGN1cnJlbnRUb3AgLT0geU9mZnNldDtcbiAgICAgICAgY3VycmVudEJvdHRvbSAtPSB5T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0JvZHlFbGVtZW50KSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gZ2V0UGFyZW50RWxlbWVudChlbGVtZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gJGhhc1VwZGF0ZVRhZyh0YWcpIHtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIHJldHVybiBlZGl0b3IuX3VwZGF0ZVRhZ3MuaGFzKHRhZyk7XG59XG5mdW5jdGlvbiAkYWRkVXBkYXRlVGFnKHRhZykge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG5cbiAgZWRpdG9yLl91cGRhdGVUYWdzLmFkZCh0YWcpO1xufVxuZnVuY3Rpb24gJG1heWJlTW92ZUNoaWxkcmVuU2VsZWN0aW9uVG9QYXJlbnQocGFyZW50Tm9kZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICEkaXNFbGVtZW50Tm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cblxuICBjb25zdCB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH0gPSBzZWxlY3Rpb247XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG5cbiAgaWYgKCRoYXNBbmNlc3RvcihhbmNob3JOb2RlLCBwYXJlbnROb2RlKSkge1xuICAgIGFuY2hvci5zZXQocGFyZW50Tm9kZS5fX2tleSwgMCwgJ2VsZW1lbnQnKTtcbiAgfVxuXG4gIGlmICgkaGFzQW5jZXN0b3IoZm9jdXNOb2RlLCBwYXJlbnROb2RlKSkge1xuICAgIGZvY3VzLnNldChwYXJlbnROb2RlLl9fa2V5LCAwLCAnZWxlbWVudCcpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uICRoYXNBbmNlc3RvcihjaGlsZCwgdGFyZ2V0Tm9kZSkge1xuICBsZXQgcGFyZW50ID0gY2hpbGQuZ2V0UGFyZW50KCk7XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGlmIChwYXJlbnQuaXModGFyZ2V0Tm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRWaWV3KGRvbUVsZW0pIHtcbiAgY29uc3Qgb3duZXJEb2MgPSBkb21FbGVtLm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvYyAmJiBvd25lckRvYy5kZWZhdWx0VmlldyB8fCBudWxsO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93KGVkaXRvcikge1xuICBjb25zdCB3aW5kb3dPYmogPSBlZGl0b3IuX3dpbmRvdztcblxuICBpZiAod2luZG93T2JqID09PSBudWxsKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYHdpbmRvdyBvYmplY3Qgbm90IGZvdW5kYCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdpbmRvd09iajtcbn1cbmZ1bmN0aW9uICRpc0lubGluZUVsZW1lbnRPckRlY29yYXRvck5vZGUobm9kZSkge1xuICByZXR1cm4gJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpIHx8ICRpc0RlY29yYXRvck5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpO1xufVxuZnVuY3Rpb24gJGdldE5lYXJlc3RSb290T3JTaGFkb3dSb290KG5vZGUpIHtcbiAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cblxuICByZXR1cm4gcGFyZW50O1xufVxuZnVuY3Rpb24gJGlzUm9vdE9yU2hhZG93Um9vdChub2RlKSB7XG4gIHJldHVybiAkaXNSb290Tm9kZShub2RlKSB8fCAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmlzU2hhZG93Um9vdCgpO1xufVxuZnVuY3Rpb24gJGNvcHlOb2RlKG5vZGUpIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBjb3B5ID0gbm9kZS5jb25zdHJ1Y3Rvci5jbG9uZShub2RlKTtcbiAgJHNldE5vZGVLZXkoY29weSwgbnVsbCk7XG4gIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5vZGUpIHtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IG5vZGVUeXBlID0gbm9kZS5jb25zdHJ1Y3Rvci5nZXRUeXBlKCk7XG5cbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSBlZGl0b3IuX25vZGVzLmdldChub2RlVHlwZSk7XG5cbiAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgJGluaXRpYWxpemVOb2RlIGZhaWxlZC4gRW5zdXJlIG5vZGUgaGFzIGJlZW4gcmVnaXN0ZXJlZCB0byB0aGUgZWRpdG9yLiBZb3UgY2FuIGRvIHRoaXMgYnkgcGFzc2luZyB0aGUgbm9kZSBjbGFzcyB2aWEgdGhlIFwibm9kZXNcIiBhcnJheSBpbiB0aGUgZWRpdG9yIGNvbmZpZy5gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXBsYWNlRnVuYyA9IHJlZ2lzdGVyZWROb2RlLnJlcGxhY2U7XG5cbiAgaWYgKHJlcGxhY2VGdW5jICE9PSBudWxsKSB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnROb2RlID0gcmVwbGFjZUZ1bmMobm9kZSk7XG5cbiAgICBpZiAoIShyZXBsYWNlbWVudE5vZGUgaW5zdGFuY2VvZiBub2RlLmNvbnN0cnVjdG9yKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgJGluaXRpYWxpemVOb2RlIGZhaWxlZC4gRW5zdXJlIHJlcGxhY2VtZW50IG5vZGUgaXMgYSBzdWJjbGFzcyBvZiB0aGUgb3JpZ2luYWwgbm9kZS5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVwbGFjZW1lbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBlcnJvck9uSW5zZXJ0VGV4dE5vZGVPblJvb3Qobm9kZSwgaW5zZXJ0Tm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcblxuICBpZiAoJGlzUm9vdE5vZGUocGFyZW50Tm9kZSkgJiYgISRpc0VsZW1lbnROb2RlKGluc2VydE5vZGUpICYmICEkaXNEZWNvcmF0b3JOb2RlKGluc2VydE5vZGUpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYE9ubHkgZWxlbWVudCBvciBkZWNvcmF0b3Igbm9kZXMgY2FuIGJlIGluc2VydGVkIGluIHRvIHRoZSByb290IG5vZGVgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQmxvY2tDdXJzb3JFbGVtZW50KGVkaXRvckNvbmZpZykge1xuICBjb25zdCB0aGVtZSA9IGVkaXRvckNvbmZpZy50aGVtZTtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9ICdmYWxzZSc7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtY3Vyc29yJywgJ3RydWUnKTtcbiAgbGV0IGJsb2NrQ3Vyc29yVGhlbWUgPSB0aGVtZS5ibG9ja0N1cnNvcjtcblxuICBpZiAoYmxvY2tDdXJzb3JUaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBibG9ja0N1cnNvclRoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgY2xhc3NOYW1lc0FyciA9IGJsb2NrQ3Vyc29yVGhlbWUuc3BsaXQoJyAnKTsgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZW50aW9uYWxcblxuICAgICAgYmxvY2tDdXJzb3JUaGVtZSA9IHRoZW1lLmJsb2NrQ3Vyc29yID0gY2xhc3NOYW1lc0FycjtcbiAgICB9XG5cbiAgICBpZiAoYmxvY2tDdXJzb3JUaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoLi4uYmxvY2tDdXJzb3JUaGVtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIG5lZWRzQmxvY2tDdXJzb3Iobm9kZSkge1xuICByZXR1cm4gKCRpc0RlY29yYXRvck5vZGUobm9kZSkgfHwgJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuY2FuQmVFbXB0eSgpKSAmJiAhbm9kZS5pc0lubGluZSgpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVET01CbG9ja0N1cnNvckVsZW1lbnQoYmxvY2tDdXJzb3JFbGVtZW50LCBlZGl0b3IsIHJvb3RFbGVtZW50KSB7XG4gIHJvb3RFbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdjYXJldC1jb2xvcicpO1xuICBlZGl0b3IuX2Jsb2NrQ3Vyc29yRWxlbWVudCA9IG51bGw7XG4gIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBibG9ja0N1cnNvckVsZW1lbnQucGFyZW50RWxlbWVudDtcblxuICBpZiAocGFyZW50RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIHBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoYmxvY2tDdXJzb3JFbGVtZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlRE9NQmxvY2tDdXJzb3JFbGVtZW50KGVkaXRvciwgcm9vdEVsZW1lbnQsIG5leHRTZWxlY3Rpb24pIHtcbiAgbGV0IGJsb2NrQ3Vyc29yRWxlbWVudCA9IGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50O1xuXG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSAmJiBuZXh0U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgbmV4dFNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHJvb3RFbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgY29uc3QgYW5jaG9yID0gbmV4dFNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZWxlbWVudE5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IG9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgY29uc3QgZWxlbWVudE5vZGVTaXplID0gZWxlbWVudE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgbGV0IGlzQmxvY2tDdXJzb3IgPSBmYWxzZTtcbiAgICBsZXQgaW5zZXJ0QmVmb3JlRWxlbWVudCA9IG51bGw7XG5cbiAgICBpZiAob2Zmc2V0ID09PSBlbGVtZW50Tm9kZVNpemUpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZWxlbWVudE5vZGUuZ2V0Q2hpbGRBdEluZGV4KG9mZnNldCAtIDEpO1xuXG4gICAgICBpZiAobmVlZHNCbG9ja0N1cnNvcihjaGlsZCkpIHtcbiAgICAgICAgaXNCbG9ja0N1cnNvciA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZWxlbWVudE5vZGUuZ2V0Q2hpbGRBdEluZGV4KG9mZnNldCk7XG5cbiAgICAgIGlmIChuZWVkc0Jsb2NrQ3Vyc29yKGNoaWxkKSkge1xuICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICAgICAgaWYgKHNpYmxpbmcgPT09IG51bGwgfHwgbmVlZHNCbG9ja0N1cnNvcihzaWJsaW5nKSkge1xuICAgICAgICAgIGlzQmxvY2tDdXJzb3IgPSB0cnVlO1xuICAgICAgICAgIGluc2VydEJlZm9yZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGNoaWxkLl9fa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0Jsb2NrQ3Vyc29yKSB7XG4gICAgICBjb25zdCBlbGVtZW50RE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShlbGVtZW50Tm9kZS5fX2tleSk7XG5cbiAgICAgIGlmIChibG9ja0N1cnNvckVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQgPSBibG9ja0N1cnNvckVsZW1lbnQgPSBjcmVhdGVCbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yLl9jb25maWcpO1xuICAgICAgfVxuXG4gICAgICByb290RWxlbWVudC5zdHlsZS5jYXJldENvbG9yID0gJ3RyYW5zcGFyZW50JztcblxuICAgICAgaWYgKGluc2VydEJlZm9yZUVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudERPTS5hcHBlbmRDaGlsZChibG9ja0N1cnNvckVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudERPTS5pbnNlcnRCZWZvcmUoYmxvY2tDdXJzb3JFbGVtZW50LCBpbnNlcnRCZWZvcmVFbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSAvLyBSZW1vdmUgY3Vyc29yXG5cblxuICBpZiAoYmxvY2tDdXJzb3JFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgcmVtb3ZlRE9NQmxvY2tDdXJzb3JFbGVtZW50KGJsb2NrQ3Vyc29yRWxlbWVudCwgZWRpdG9yLCByb290RWxlbWVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERPTVNlbGVjdGlvbih0YXJnZXRXaW5kb3cpIHtcbiAgcmV0dXJuICFDQU5fVVNFX0RPTSA/IG51bGwgOiAodGFyZ2V0V2luZG93IHx8IHdpbmRvdykuZ2V0U2VsZWN0aW9uKCk7XG59XG5mdW5jdGlvbiAkc3BsaXROb2RlKG5vZGUsIG9mZnNldCkge1xuICBsZXQgc3RhcnROb2RlID0gbm9kZS5nZXRDaGlsZEF0SW5kZXgob2Zmc2V0KTtcblxuICBpZiAoc3RhcnROb2RlID09IG51bGwpIHtcbiAgICBzdGFydE5vZGUgPSBub2RlO1xuICB9XG5cbiAgaWYgKCEhJGlzUm9vdE9yU2hhZG93Um9vdChub2RlKSkge1xuICAgIHRocm93IEVycm9yKGBDYW4gbm90IGNhbGwgJHNwbGl0Tm9kZSgpIG9uIHJvb3QgZWxlbWVudGApO1xuICB9XG5cbiAgY29uc3QgcmVjdXJzZSA9IGN1cnJlbnROb2RlID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgY29uc3QgaXNQYXJlbnRSb290ID0gJGlzUm9vdE9yU2hhZG93Um9vdChwYXJlbnQpOyAvLyBUaGUgbm9kZSB3ZSBzdGFydCBzcGxpdCBmcm9tIChsZWFmKSBpcyBtb3ZlZCwgYnV0IGl0cyByZWN1cnNpdmVcbiAgICAvLyBwYXJlbnRzIGFyZSBjb3BpZWQgdG8gY3JlYXRlIHNlcGFyYXRlIHRyZWVcblxuICAgIGNvbnN0IG5vZGVUb01vdmUgPSBjdXJyZW50Tm9kZSA9PT0gc3RhcnROb2RlICYmICFpc1BhcmVudFJvb3QgPyBjdXJyZW50Tm9kZSA6ICRjb3B5Tm9kZShjdXJyZW50Tm9kZSk7XG5cbiAgICBpZiAoaXNQYXJlbnRSb290KSB7XG4gICAgICBjdXJyZW50Tm9kZS5pbnNlcnRBZnRlcihub2RlVG9Nb3ZlKTtcbiAgICAgIHJldHVybiBbY3VycmVudE5vZGUsIG5vZGVUb01vdmUsIG5vZGVUb01vdmVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbbGVmdFRyZWUsIHJpZ2h0VHJlZSwgbmV3UGFyZW50XSA9IHJlY3Vyc2UocGFyZW50KTtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5ncyA9IGN1cnJlbnROb2RlLmdldE5leHRTaWJsaW5ncygpO1xuICAgICAgbmV3UGFyZW50LmFwcGVuZChub2RlVG9Nb3ZlLCAuLi5uZXh0U2libGluZ3MpO1xuICAgICAgcmV0dXJuIFtsZWZ0VHJlZSwgcmlnaHRUcmVlLCBub2RlVG9Nb3ZlXTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgW2xlZnRUcmVlLCByaWdodFRyZWVdID0gcmVjdXJzZShzdGFydE5vZGUpO1xuICByZXR1cm4gW2xlZnRUcmVlLCByaWdodFRyZWVdO1xufVxuZnVuY3Rpb24gJGZpbmRNYXRjaGluZ1BhcmVudChzdGFydGluZ05vZGUsIGZpbmRGbikge1xuICBsZXQgY3VyciA9IHN0YXJ0aW5nTm9kZTtcblxuICB3aGlsZSAoY3VyciAhPT0gJGdldFJvb3QoKSAmJiBjdXJyICE9IG51bGwpIHtcbiAgICBpZiAoZmluZEZuKGN1cnIpKSB7XG4gICAgICByZXR1cm4gY3VycjtcbiAgICB9XG5cbiAgICBjdXJyID0gY3Vyci5nZXRQYXJlbnQoKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gJGdldENoaWxkcmVuUmVjdXJzaXZlbHkobm9kZSkge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtub2RlXTtcblxuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGN1cnJlbnROb2RlID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoIShjdXJyZW50Tm9kZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYFN0YWNrLmxlbmd0aCA+IDA7IGNhbid0IGJlIHVuZGVmaW5lZGApO1xuICAgIH1cblxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHN0YWNrLnVuc2hpZnQoLi4uY3VycmVudE5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnROb2RlICE9PSBub2RlKSB7XG4gICAgICBub2Rlcy5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZXM7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uICRnYXJiYWdlQ29sbGVjdERldGFjaGVkRGVjb3JhdG9ycyhlZGl0b3IsIHBlbmRpbmdFZGl0b3JTdGF0ZSkge1xuICBjb25zdCBjdXJyZW50RGVjb3JhdG9ycyA9IGVkaXRvci5fZGVjb3JhdG9ycztcbiAgY29uc3QgcGVuZGluZ0RlY29yYXRvcnMgPSBlZGl0b3IuX3BlbmRpbmdEZWNvcmF0b3JzO1xuICBsZXQgZGVjb3JhdG9ycyA9IHBlbmRpbmdEZWNvcmF0b3JzIHx8IGN1cnJlbnREZWNvcmF0b3JzO1xuICBjb25zdCBub2RlTWFwID0gcGVuZGluZ0VkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBsZXQga2V5O1xuXG4gIGZvciAoa2V5IGluIGRlY29yYXRvcnMpIHtcbiAgICBpZiAoIW5vZGVNYXAuaGFzKGtleSkpIHtcbiAgICAgIGlmIChkZWNvcmF0b3JzID09PSBjdXJyZW50RGVjb3JhdG9ycykge1xuICAgICAgICBkZWNvcmF0b3JzID0gY2xvbmVEZWNvcmF0b3JzKGVkaXRvcik7XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBkZWNvcmF0b3JzW2tleV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uICRnYXJiYWdlQ29sbGVjdERldGFjaGVkRGVlcENoaWxkTm9kZXMobm9kZSwgcGFyZW50S2V5LCBwcmV2Tm9kZU1hcCwgbm9kZU1hcCwgbm9kZU1hcERlbGV0ZSwgZGlydHlOb2Rlcykge1xuICBsZXQgY2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBjb25zdCBjaGlsZEtleSA9IGNoaWxkLl9fa2V5OyAvLyBUT0RPIFJldmlzZSBjb25kaXRpb24gYmVsb3csIHJlZHVuZGFudD8gTGV4aWNhbE5vZGUgYWxyZWFkeSBjbGVhbnMgdXAgY2hpbGRyZW4gd2hlbiBtb3ZpbmcgTm9kZXNcblxuICAgIGlmIChjaGlsZC5fX3BhcmVudCA9PT0gcGFyZW50S2V5KSB7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICRnYXJiYWdlQ29sbGVjdERldGFjaGVkRGVlcENoaWxkTm9kZXMoY2hpbGQsIGNoaWxkS2V5LCBwcmV2Tm9kZU1hcCwgbm9kZU1hcCwgbm9kZU1hcERlbGV0ZSwgZGlydHlOb2Rlcyk7XG4gICAgICB9IC8vIElmIHdlIGhhdmUgY3JlYXRlZCBhIG5vZGUgYW5kIGl0IHdhcyBkZXJlZmVyZW5jZWQsIHRoZW4gYWxzb1xuICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gb3V0IGRpcnR5IG5vZGVzIFNldC5cblxuXG4gICAgICBpZiAoIXByZXZOb2RlTWFwLmhhcyhjaGlsZEtleSkpIHtcbiAgICAgICAgZGlydHlOb2Rlcy5kZWxldGUoY2hpbGRLZXkpO1xuICAgICAgfVxuXG4gICAgICBub2RlTWFwRGVsZXRlLnB1c2goY2hpbGRLZXkpO1xuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiAkZ2FyYmFnZUNvbGxlY3REZXRhY2hlZE5vZGVzKHByZXZFZGl0b3JTdGF0ZSwgZWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzLCBkaXJ0eUVsZW1lbnRzKSB7XG4gIGNvbnN0IHByZXZOb2RlTWFwID0gcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7IC8vIFN0b3JlIGRpcnR5RWxlbWVudHMgaW4gYSBxdWV1ZSBmb3IgbGF0ZXIgZGVsZXRpb247IGRlbGV0aW5nIGRpcnR5IHN1YnRyZWVzIHRvbyBlYXJseSB3aWxsXG4gIC8vIGhpbmRlciBhY2Nlc3NpbmcgLl9fbmV4dCBvbiBjaGlsZCBub2Rlc1xuXG4gIGNvbnN0IG5vZGVNYXBEZWxldGUgPSBbXTtcblxuICBmb3IgKGNvbnN0IFtub2RlS2V5XSBvZiBkaXJ0eUVsZW1lbnRzKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KG5vZGVLZXkpO1xuXG4gICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gR2FyYmFnZSBjb2xsZWN0IG5vZGUgYW5kIGl0cyBjaGlsZHJlbiBpZiB0aGV5IGV4aXN0XG4gICAgICBpZiAoIW5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgICAgICRnYXJiYWdlQ29sbGVjdERldGFjaGVkRGVlcENoaWxkTm9kZXMobm9kZSwgbm9kZUtleSwgcHJldk5vZGVNYXAsIG5vZGVNYXAsIG5vZGVNYXBEZWxldGUsIGRpcnR5RWxlbWVudHMpO1xuICAgICAgICB9IC8vIElmIHdlIGhhdmUgY3JlYXRlZCBhIG5vZGUgYW5kIGl0IHdhcyBkZXJlZmVyZW5jZWQsIHRoZW4gYWxzb1xuICAgICAgICAvLyByZW1vdmUgaXQgZnJvbSBvdXQgZGlydHkgbm9kZXMgU2V0LlxuXG5cbiAgICAgICAgaWYgKCFwcmV2Tm9kZU1hcC5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgICBkaXJ0eUVsZW1lbnRzLmRlbGV0ZShub2RlS2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGVNYXBEZWxldGUucHVzaChub2RlS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IG5vZGVLZXkgb2Ygbm9kZU1hcERlbGV0ZSkge1xuICAgIG5vZGVNYXAuZGVsZXRlKG5vZGVLZXkpO1xuICB9XG5cbiAgZm9yIChjb25zdCBub2RlS2V5IG9mIGRpcnR5TGVhdmVzKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KG5vZGVLZXkpO1xuXG4gICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiAhbm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICAgIGlmICghcHJldk5vZGVNYXAuaGFzKG5vZGVLZXkpKSB7XG4gICAgICAgIGRpcnR5TGVhdmVzLmRlbGV0ZShub2RlS2V5KTtcbiAgICAgIH1cblxuICAgICAgbm9kZU1hcC5kZWxldGUobm9kZUtleSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmxldCBzdWJUcmVlVGV4dENvbnRlbnQgPSAnJztcbmxldCBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCA9ICcnO1xubGV0IGVkaXRvclRleHRDb250ZW50ID0gJyc7XG5sZXQgYWN0aXZlRWRpdG9yQ29uZmlnO1xubGV0IGFjdGl2ZUVkaXRvciQxO1xubGV0IGFjdGl2ZUVkaXRvck5vZGVzO1xubGV0IHRyZWF0QWxsTm9kZXNBc0RpcnR5ID0gZmFsc2U7XG5sZXQgYWN0aXZlRWRpdG9yU3RhdGVSZWFkT25seSA9IGZhbHNlO1xubGV0IGFjdGl2ZU11dGF0aW9uTGlzdGVuZXJzO1xubGV0IGFjdGl2ZVRleHREaXJlY3Rpb24gPSBudWxsO1xubGV0IGFjdGl2ZURpcnR5RWxlbWVudHM7XG5sZXQgYWN0aXZlRGlydHlMZWF2ZXM7XG5sZXQgYWN0aXZlUHJldk5vZGVNYXA7XG5sZXQgYWN0aXZlTmV4dE5vZGVNYXA7XG5sZXQgYWN0aXZlUHJldktleVRvRE9NTWFwO1xubGV0IG11dGF0ZWROb2RlcztcblxuZnVuY3Rpb24gZGVzdHJveU5vZGUoa2V5LCBwYXJlbnRET00pIHtcbiAgY29uc3Qgbm9kZSA9IGFjdGl2ZVByZXZOb2RlTWFwLmdldChrZXkpO1xuXG4gIGlmIChwYXJlbnRET00gIT09IG51bGwpIHtcbiAgICBjb25zdCBkb20gPSBnZXRQcmV2RWxlbWVudEJ5S2V5T3JUaHJvdyhrZXkpO1xuXG4gICAgaWYgKGRvbS5wYXJlbnROb2RlID09PSBwYXJlbnRET00pIHtcbiAgICAgIHBhcmVudERPTS5yZW1vdmVDaGlsZChkb20pO1xuICAgIH1cbiAgfSAvLyBUaGlzIGxvZ2ljIGlzIHJlYWxseSBpbXBvcnRhbnQsIG90aGVyd2lzZSB3ZSB3aWxsIGxlYWsgRE9NIG5vZGVzXG4gIC8vIHdoZW4gdGhlaXIgY29ycmVzcG9uZGluZyBMZXhpY2FsTm9kZXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgZWRpdG9yIHN0YXRlLlxuXG5cbiAgaWYgKCFhY3RpdmVOZXh0Tm9kZU1hcC5oYXMoa2V5KSkge1xuICAgIGFjdGl2ZUVkaXRvciQxLl9rZXlUb0RPTU1hcC5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gY3JlYXRlQ2hpbGRyZW5BcnJheShub2RlLCBhY3RpdmVQcmV2Tm9kZU1hcCk7XG4gICAgZGVzdHJveUNoaWxkcmVuKGNoaWxkcmVuLCAwLCBjaGlsZHJlbi5sZW5ndGggLSAxLCBudWxsKTtcbiAgfVxuXG4gIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXRNdXRhdGVkTm9kZShtdXRhdGVkTm9kZXMsIGFjdGl2ZUVkaXRvck5vZGVzLCBhY3RpdmVNdXRhdGlvbkxpc3RlbmVycywgbm9kZSwgJ2Rlc3Ryb3llZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lDaGlsZHJlbihjaGlsZHJlbiwgX3N0YXJ0SW5kZXgsIGVuZEluZGV4LCBkb20pIHtcbiAgbGV0IHN0YXJ0SW5kZXggPSBfc3RhcnRJbmRleDtcblxuICBmb3IgKDsgc3RhcnRJbmRleCA8PSBlbmRJbmRleDsgKytzdGFydEluZGV4KSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltzdGFydEluZGV4XTtcblxuICAgIGlmIChjaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0cm95Tm9kZShjaGlsZCwgZG9tKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0VGV4dEFsaWduKGRvbVN0eWxlLCB2YWx1ZSkge1xuICBkb21TdHlsZS5zZXRQcm9wZXJ0eSgndGV4dC1hbGlnbicsIHZhbHVlKTtcbn1cblxuY29uc3QgREVGQVVMVF9JTkRFTlRfVkFMVUUgPSAnNDBweCc7XG5cbmZ1bmN0aW9uIHNldEVsZW1lbnRJbmRlbnQoZG9tLCBpbmRlbnQpIHtcbiAgY29uc3QgaW5kZW50Q2xhc3NOYW1lID0gYWN0aXZlRWRpdG9yQ29uZmlnLnRoZW1lLmluZGVudDtcblxuICBpZiAodHlwZW9mIGluZGVudENsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBlbGVtZW50SGFzQ2xhc3NOYW1lID0gZG9tLmNsYXNzTGlzdC5jb250YWlucyhpbmRlbnRDbGFzc05hbWUpO1xuXG4gICAgaWYgKGluZGVudCA+IDAgJiYgIWVsZW1lbnRIYXNDbGFzc05hbWUpIHtcbiAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKGluZGVudENsYXNzTmFtZSk7XG4gICAgfSBlbHNlIGlmIChpbmRlbnQgPCAxICYmIGVsZW1lbnRIYXNDbGFzc05hbWUpIHtcbiAgICAgIGRvbS5jbGFzc0xpc3QucmVtb3ZlKGluZGVudENsYXNzTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgaW5kZW50YXRpb25CYXNlVmFsdWUgPSBnZXRDb21wdXRlZFN0eWxlKGRvbSkuZ2V0UHJvcGVydHlWYWx1ZSgnLS1sZXhpY2FsLWluZGVudC1iYXNlLXZhbHVlJykgfHwgREVGQVVMVF9JTkRFTlRfVkFMVUU7XG4gIGRvbS5zdHlsZS5zZXRQcm9wZXJ0eSgncGFkZGluZy1pbmxpbmUtc3RhcnQnLCBpbmRlbnQgPT09IDAgPyAnJyA6IGBjYWxjKCR7aW5kZW50fSAqICR7aW5kZW50YXRpb25CYXNlVmFsdWV9KWApO1xufVxuXG5mdW5jdGlvbiBzZXRFbGVtZW50Rm9ybWF0KGRvbSwgZm9ybWF0KSB7XG4gIGNvbnN0IGRvbVN0eWxlID0gZG9tLnN0eWxlO1xuXG4gIGlmIChmb3JtYXQgPT09IDApIHtcbiAgICBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsICcnKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX0xFRlQpIHtcbiAgICBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsICdsZWZ0Jyk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0ID09PSBJU19BTElHTl9DRU5URVIpIHtcbiAgICBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsICdjZW50ZXInKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX1JJR0hUKSB7XG4gICAgc2V0VGV4dEFsaWduKGRvbVN0eWxlLCAncmlnaHQnKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX0pVU1RJRlkpIHtcbiAgICBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsICdqdXN0aWZ5Jyk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0ID09PSBJU19BTElHTl9TVEFSVCkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ3N0YXJ0Jyk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0ID09PSBJU19BTElHTl9FTkQpIHtcbiAgICBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsICdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlKGtleSwgcGFyZW50RE9NLCBpbnNlcnRET00pIHtcbiAgY29uc3Qgbm9kZSA9IGFjdGl2ZU5leHROb2RlTWFwLmdldChrZXkpO1xuXG4gIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgY3JlYXRlTm9kZTogbm9kZSBkb2VzIG5vdCBleGlzdCBpbiBub2RlTWFwYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZG9tID0gbm9kZS5jcmVhdGVET00oYWN0aXZlRWRpdG9yQ29uZmlnLCBhY3RpdmVFZGl0b3IkMSk7XG4gIHN0b3JlRE9NV2l0aEtleShrZXksIGRvbSwgYWN0aXZlRWRpdG9yJDEpOyAvLyBUaGlzIGhlbHBzIHByZXNlcnZlIHRoZSB0ZXh0LCBhbmQgc3RvcHMgc3BlbGwgY2hlY2sgdG9vbHMgZnJvbVxuICAvLyBtZXJnaW5nIG9yIGJyZWFrIHRoZSBzcGFucyAod2hpY2ggaGFwcGVucyBpZiB0aGV5IGFyZSBtaXNzaW5nXG4gIC8vIHRoaXMgYXR0cmlidXRlKS5cblxuICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtdGV4dCcsICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoJGlzRGVjb3JhdG9yTm9kZShub2RlKSkge1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1kZWNvcmF0b3InLCAndHJ1ZScpO1xuICB9XG5cbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgY29uc3QgaW5kZW50ID0gbm9kZS5fX2luZGVudDtcbiAgICBjb25zdCBjaGlsZHJlblNpemUgPSBub2RlLl9fc2l6ZTtcblxuICAgIGlmIChpbmRlbnQgIT09IDApIHtcbiAgICAgIHNldEVsZW1lbnRJbmRlbnQoZG9tLCBpbmRlbnQpO1xuICAgIH1cblxuICAgIGlmIChjaGlsZHJlblNpemUgIT09IDApIHtcbiAgICAgIGNvbnN0IGVuZEluZGV4ID0gY2hpbGRyZW5TaXplIC0gMTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gY3JlYXRlQ2hpbGRyZW5BcnJheShub2RlLCBhY3RpdmVOZXh0Tm9kZU1hcCk7XG4gICAgICBjcmVhdGVDaGlsZHJlbldpdGhEaXJlY3Rpb24oY2hpbGRyZW4sIGVuZEluZGV4LCBub2RlLCBkb20pO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm1hdCA9IG5vZGUuX19mb3JtYXQ7XG5cbiAgICBpZiAoZm9ybWF0ICE9PSAwKSB7XG4gICAgICBzZXRFbGVtZW50Rm9ybWF0KGRvbSwgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBpZiAoIW5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgcmVjb25jaWxlRWxlbWVudFRlcm1pbmF0aW5nTGluZUJyZWFrKG51bGwsIG5vZGUsIGRvbSk7XG4gICAgfVxuXG4gICAgaWYgKCR0ZXh0Q29udGVudFJlcXVpcmVzRG91YmxlTGluZWJyZWFrQXRFbmQobm9kZSkpIHtcbiAgICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSBET1VCTEVfTElORV9CUkVBSztcbiAgICAgIGVkaXRvclRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuXG4gICAgaWYgKCRpc0RlY29yYXRvck5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGRlY29yYXRvciA9IG5vZGUuZGVjb3JhdGUoYWN0aXZlRWRpdG9yJDEsIGFjdGl2ZUVkaXRvckNvbmZpZyk7XG5cbiAgICAgIGlmIChkZWNvcmF0b3IgIT09IG51bGwpIHtcbiAgICAgICAgcmVjb25jaWxlRGVjb3JhdG9yKGtleSwgZGVjb3JhdG9yKTtcbiAgICAgIH0gLy8gRGVjb3JhdG9ycyBhcmUgYWx3YXlzIG5vbiBlZGl0YWJsZVxuXG5cbiAgICAgIGRvbS5jb250ZW50RWRpdGFibGUgPSAnZmFsc2UnO1xuICAgIH0gZWxzZSBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIGlmICghbm9kZS5pc0RpcmVjdGlvbmxlc3MoKSkge1xuICAgICAgICBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCArPSB0ZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSB0ZXh0O1xuICAgIGVkaXRvclRleHRDb250ZW50ICs9IHRleHQ7XG4gIH1cblxuICBpZiAocGFyZW50RE9NICE9PSBudWxsKSB7XG4gICAgaWYgKGluc2VydERPTSAhPSBudWxsKSB7XG4gICAgICBwYXJlbnRET00uaW5zZXJ0QmVmb3JlKGRvbSwgaW5zZXJ0RE9NKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGNvbnN0IHBvc3NpYmxlTGluZUJyZWFrID0gcGFyZW50RE9NLl9fbGV4aWNhbExpbmVCcmVhaztcblxuICAgICAgaWYgKHBvc3NpYmxlTGluZUJyZWFrICE9IG51bGwpIHtcbiAgICAgICAgcGFyZW50RE9NLmluc2VydEJlZm9yZShkb20sIHBvc3NpYmxlTGluZUJyZWFrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudERPTS5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICAvLyBGcmVlemUgdGhlIG5vZGUgaW4gREVWIHRvIHByZXZlbnQgYWNjaWRlbnRhbCBtdXRhdGlvbnNcbiAgICBPYmplY3QuZnJlZXplKG5vZGUpO1xuICB9XG5cbiAgc2V0TXV0YXRlZE5vZGUobXV0YXRlZE5vZGVzLCBhY3RpdmVFZGl0b3JOb2RlcywgYWN0aXZlTXV0YXRpb25MaXN0ZW5lcnMsIG5vZGUsICdjcmVhdGVkJyk7XG4gIHJldHVybiBkb207XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuV2l0aERpcmVjdGlvbihjaGlsZHJlbiwgZW5kSW5kZXgsIGVsZW1lbnQsIGRvbSkge1xuICBjb25zdCBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQ7XG4gIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gJyc7XG4gIGNyZWF0ZUNoaWxkcmVuKGNoaWxkcmVuLCBlbGVtZW50LCAwLCBlbmRJbmRleCwgZG9tLCBudWxsKTtcbiAgcmVjb25jaWxlQmxvY2tEaXJlY3Rpb24oZWxlbWVudCwgZG9tKTtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDaGlsZHJlbihjaGlsZHJlbiwgZWxlbWVudCwgX3N0YXJ0SW5kZXgsIGVuZEluZGV4LCBkb20sIGluc2VydERPTSkge1xuICBjb25zdCBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudCA9IHN1YlRyZWVUZXh0Q29udGVudDtcbiAgc3ViVHJlZVRleHRDb250ZW50ID0gJyc7XG4gIGxldCBzdGFydEluZGV4ID0gX3N0YXJ0SW5kZXg7XG5cbiAgZm9yICg7IHN0YXJ0SW5kZXggPD0gZW5kSW5kZXg7ICsrc3RhcnRJbmRleCkge1xuICAgIGNyZWF0ZU5vZGUoY2hpbGRyZW5bc3RhcnRJbmRleF0sIGRvbSwgaW5zZXJ0RE9NKTtcbiAgfVxuXG4gIGlmICgkdGV4dENvbnRlbnRSZXF1aXJlc0RvdWJsZUxpbmVicmVha0F0RW5kKGVsZW1lbnQpKSB7XG4gICAgc3ViVHJlZVRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICB9IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG5cblxuICBkb20uX19sZXhpY2FsVGV4dENvbnRlbnQgPSBzdWJUcmVlVGV4dENvbnRlbnQ7XG4gIHN1YlRyZWVUZXh0Q29udGVudCA9IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ICsgc3ViVHJlZVRleHRDb250ZW50O1xufVxuXG5mdW5jdGlvbiBpc0xhc3RDaGlsZExpbmVCcmVha09yRGVjb3JhdG9yKGNoaWxkS2V5LCBub2RlTWFwKSB7XG4gIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChjaGlsZEtleSk7XG4gIHJldHVybiAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpIHx8ICRpc0RlY29yYXRvck5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpO1xufSAvLyBJZiB3ZSBlbmQgYW4gZWxlbWVudCB3aXRoIGEgTGluZUJyZWFrTm9kZSwgdGhlbiB3ZSBuZWVkIHRvIGFkZCBhbiBhZGRpdGlvbmFsIDxicj5cblxuXG5mdW5jdGlvbiByZWNvbmNpbGVFbGVtZW50VGVybWluYXRpbmdMaW5lQnJlYWsocHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBkb20pIHtcbiAgY29uc3QgcHJldkxpbmVCcmVhayA9IHByZXZFbGVtZW50ICE9PSBudWxsICYmIChwcmV2RWxlbWVudC5fX3NpemUgPT09IDAgfHwgaXNMYXN0Q2hpbGRMaW5lQnJlYWtPckRlY29yYXRvcihwcmV2RWxlbWVudC5fX2xhc3QsIGFjdGl2ZVByZXZOb2RlTWFwKSk7XG4gIGNvbnN0IG5leHRMaW5lQnJlYWsgPSBuZXh0RWxlbWVudC5fX3NpemUgPT09IDAgfHwgaXNMYXN0Q2hpbGRMaW5lQnJlYWtPckRlY29yYXRvcihuZXh0RWxlbWVudC5fX2xhc3QsIGFjdGl2ZU5leHROb2RlTWFwKTtcblxuICBpZiAocHJldkxpbmVCcmVhaykge1xuICAgIGlmICghbmV4dExpbmVCcmVhaykge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb20uX19sZXhpY2FsTGluZUJyZWFrO1xuXG4gICAgICBpZiAoZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgIGRvbS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICAgIH0gLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcblxuXG4gICAgICBkb20uX19sZXhpY2FsTGluZUJyZWFrID0gbnVsbDtcbiAgICB9XG4gIH0gZWxzZSBpZiAobmV4dExpbmVCcmVhaykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpOyAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuXG4gICAgZG9tLl9fbGV4aWNhbExpbmVCcmVhayA9IGVsZW1lbnQ7XG4gICAgZG9tLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUJsb2NrRGlyZWN0aW9uKGVsZW1lbnQsIGRvbSkge1xuICBjb25zdCBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudCA9IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gIGRvbS5fX2xleGljYWxEaXJUZXh0Q29udGVudDsgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcblxuICBjb25zdCBwcmV2aW91c0RpcmVjdGlvbiA9IGRvbS5fX2xleGljYWxEaXI7XG5cbiAgaWYgKHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50ICE9PSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCB8fCBwcmV2aW91c0RpcmVjdGlvbiAhPT0gYWN0aXZlVGV4dERpcmVjdGlvbikge1xuICAgIGNvbnN0IGhhc0VtcHR5RGlyZWN0aW9uZWRUZXh0Q29udGVudCA9IHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID09PSAnJztcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBoYXNFbXB0eURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPyBhY3RpdmVUZXh0RGlyZWN0aW9uIDogZ2V0VGV4dERpcmVjdGlvbihzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCk7XG5cbiAgICBpZiAoZGlyZWN0aW9uICE9PSBwcmV2aW91c0RpcmVjdGlvbikge1xuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZG9tLmNsYXNzTGlzdDtcbiAgICAgIGNvbnN0IHRoZW1lID0gYWN0aXZlRWRpdG9yQ29uZmlnLnRoZW1lO1xuICAgICAgbGV0IHByZXZpb3VzRGlyZWN0aW9uVGhlbWUgPSBwcmV2aW91c0RpcmVjdGlvbiAhPT0gbnVsbCA/IHRoZW1lW3ByZXZpb3VzRGlyZWN0aW9uXSA6IHVuZGVmaW5lZDtcbiAgICAgIGxldCBuZXh0RGlyZWN0aW9uVGhlbWUgPSBkaXJlY3Rpb24gIT09IG51bGwgPyB0aGVtZVtkaXJlY3Rpb25dIDogdW5kZWZpbmVkOyAvLyBSZW1vdmUgdGhlIG9sZCB0aGVtZSBjbGFzc2VzIGlmIHRoZXkgZXhpc3RcblxuICAgICAgaWYgKHByZXZpb3VzRGlyZWN0aW9uVGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHByZXZpb3VzRGlyZWN0aW9uVGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc3QgY2xhc3NOYW1lc0FyciA9IHByZXZpb3VzRGlyZWN0aW9uVGhlbWUuc3BsaXQoJyAnKTtcbiAgICAgICAgICBwcmV2aW91c0RpcmVjdGlvblRoZW1lID0gdGhlbWVbcHJldmlvdXNEaXJlY3Rpb25dID0gY2xhc3NOYW1lc0FycjtcbiAgICAgICAgfSAvLyBAdHMtaWdub3JlOiBpbnRlbnRpb25hbFxuXG5cbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSguLi5wcmV2aW91c0RpcmVjdGlvblRoZW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gbnVsbCB8fCBoYXNFbXB0eURpcmVjdGlvbmVkVGV4dENvbnRlbnQgJiYgZGlyZWN0aW9uID09PSAnbHRyJykge1xuICAgICAgICAvLyBSZW1vdmUgZGlyZWN0aW9uXG4gICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ2RpcicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXBwbHkgdGhlIG5ldyB0aGVtZSBjbGFzc2VzIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgaWYgKG5leHREaXJlY3Rpb25UaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXh0RGlyZWN0aW9uVGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWVzQXJyID0gbmV4dERpcmVjdGlvblRoZW1lLnNwbGl0KCcgJyk7IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVudGlvbmFsXG5cbiAgICAgICAgICAgIG5leHREaXJlY3Rpb25UaGVtZSA9IHRoZW1lW2RpcmVjdGlvbl0gPSBjbGFzc05hbWVzQXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0RGlyZWN0aW9uVGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xhc3NMaXN0LmFkZCguLi5uZXh0RGlyZWN0aW9uVGhlbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBVcGRhdGUgZGlyZWN0aW9uXG5cblxuICAgICAgICBkb20uZGlyID0gZGlyZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFjdGl2ZUVkaXRvclN0YXRlUmVhZE9ubHkpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVOb2RlID0gZWxlbWVudC5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZU5vZGUuX19kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWN0aXZlVGV4dERpcmVjdGlvbiA9IGRpcmVjdGlvbjsgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcblxuICAgIGRvbS5fX2xleGljYWxEaXJUZXh0Q29udGVudCA9IHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50OyAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuXG4gICAgZG9tLl9fbGV4aWNhbERpciA9IGRpcmVjdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbldpdGhEaXJlY3Rpb24ocHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBkb20pIHtcbiAgY29uc3QgcHJldmlvdXNTdWJUcmVlRGlyZWN0aW9uVGV4dENvbnRlbnQgPSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudDtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSAnJztcbiAgcmVjb25jaWxlQ2hpbGRyZW4ocHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBkb20pO1xuICByZWNvbmNpbGVCbG9ja0RpcmVjdGlvbihuZXh0RWxlbWVudCwgZG9tKTtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW5BcnJheShlbGVtZW50LCBub2RlTWFwKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gW107XG4gIGxldCBub2RlS2V5ID0gZWxlbWVudC5fX2ZpcnN0O1xuXG4gIHdoaWxlIChub2RlS2V5ICE9PSBudWxsKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KG5vZGVLZXkpO1xuXG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgY3JlYXRlQ2hpbGRyZW5BcnJheTogbm9kZSBkb2VzIG5vdCBleGlzdCBpbiBub2RlTWFwYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGRyZW4ucHVzaChub2RlS2V5KTtcbiAgICBub2RlS2V5ID0gbm9kZS5fX25leHQ7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgZG9tKSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ID0gc3ViVHJlZVRleHRDb250ZW50O1xuICBjb25zdCBwcmV2Q2hpbGRyZW5TaXplID0gcHJldkVsZW1lbnQuX19zaXplO1xuICBjb25zdCBuZXh0Q2hpbGRyZW5TaXplID0gbmV4dEVsZW1lbnQuX19zaXplO1xuICBzdWJUcmVlVGV4dENvbnRlbnQgPSAnJztcblxuICBpZiAocHJldkNoaWxkcmVuU2l6ZSA9PT0gMSAmJiBuZXh0Q2hpbGRyZW5TaXplID09PSAxKSB7XG4gICAgY29uc3QgcHJldkZpcnN0Q2hpbGRLZXkgPSBwcmV2RWxlbWVudC5fX2ZpcnN0O1xuICAgIGNvbnN0IG5leHRGcnN0Q2hpbGRLZXkgPSBuZXh0RWxlbWVudC5fX2ZpcnN0O1xuXG4gICAgaWYgKHByZXZGaXJzdENoaWxkS2V5ID09PSBuZXh0RnJzdENoaWxkS2V5KSB7XG4gICAgICByZWNvbmNpbGVOb2RlKHByZXZGaXJzdENoaWxkS2V5LCBkb20pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0RE9NID0gZ2V0UHJldkVsZW1lbnRCeUtleU9yVGhyb3cocHJldkZpcnN0Q2hpbGRLZXkpO1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnRET00gPSBjcmVhdGVOb2RlKG5leHRGcnN0Q2hpbGRLZXksIG51bGwsIG51bGwpO1xuICAgICAgZG9tLnJlcGxhY2VDaGlsZChyZXBsYWNlbWVudERPTSwgbGFzdERPTSk7XG4gICAgICBkZXN0cm95Tm9kZShwcmV2Rmlyc3RDaGlsZEtleSwgbnVsbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByZXZDaGlsZHJlbiA9IGNyZWF0ZUNoaWxkcmVuQXJyYXkocHJldkVsZW1lbnQsIGFjdGl2ZVByZXZOb2RlTWFwKTtcbiAgICBjb25zdCBuZXh0Q2hpbGRyZW4gPSBjcmVhdGVDaGlsZHJlbkFycmF5KG5leHRFbGVtZW50LCBhY3RpdmVOZXh0Tm9kZU1hcCk7XG5cbiAgICBpZiAocHJldkNoaWxkcmVuU2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKG5leHRDaGlsZHJlblNpemUgIT09IDApIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCBuZXh0RWxlbWVudCwgMCwgbmV4dENoaWxkcmVuU2l6ZSAtIDEsIGRvbSwgbnVsbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW5TaXplID09PSAwKSB7XG4gICAgICBpZiAocHJldkNoaWxkcmVuU2l6ZSAhPT0gMCkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgICAgICBjb25zdCBsZXhpY2FsTGluZUJyZWFrID0gZG9tLl9fbGV4aWNhbExpbmVCcmVhaztcbiAgICAgICAgY29uc3QgY2FuVXNlRmFzdFBhdGggPSBsZXhpY2FsTGluZUJyZWFrID09IG51bGw7XG4gICAgICAgIGRlc3Ryb3lDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIDAsIHByZXZDaGlsZHJlblNpemUgLSAxLCBjYW5Vc2VGYXN0UGF0aCA/IG51bGwgOiBkb20pO1xuXG4gICAgICAgIGlmIChjYW5Vc2VGYXN0UGF0aCkge1xuICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgcmVtb3ZpbmcgRE9NIG5vZGVzXG4gICAgICAgICAgZG9tLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVjb25jaWxlTm9kZUNoaWxkcmVuKG5leHRFbGVtZW50LCBwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgcHJldkNoaWxkcmVuU2l6ZSwgbmV4dENoaWxkcmVuU2l6ZSwgZG9tKTtcbiAgICB9XG4gIH1cblxuICBpZiAoJHRleHRDb250ZW50UmVxdWlyZXNEb3VibGVMaW5lYnJlYWtBdEVuZChuZXh0RWxlbWVudCkpIHtcbiAgICBzdWJUcmVlVGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gIH0gLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcblxuXG4gIGRvbS5fX2xleGljYWxUZXh0Q29udGVudCA9IHN1YlRyZWVUZXh0Q29udGVudDtcbiAgc3ViVHJlZVRleHRDb250ZW50ID0gcHJldmlvdXNTdWJUcmVlVGV4dENvbnRlbnQgKyBzdWJUcmVlVGV4dENvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZU5vZGUoa2V5LCBwYXJlbnRET00pIHtcbiAgY29uc3QgcHJldk5vZGUgPSBhY3RpdmVQcmV2Tm9kZU1hcC5nZXQoa2V5KTtcbiAgbGV0IG5leHROb2RlID0gYWN0aXZlTmV4dE5vZGVNYXAuZ2V0KGtleSk7XG5cbiAgaWYgKHByZXZOb2RlID09PSB1bmRlZmluZWQgfHwgbmV4dE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGByZWNvbmNpbGVOb2RlOiBwcmV2Tm9kZSBvciBuZXh0Tm9kZSBkb2VzIG5vdCBleGlzdCBpbiBub2RlTWFwYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgaXNEaXJ0eSA9IHRyZWF0QWxsTm9kZXNBc0RpcnR5IHx8IGFjdGl2ZURpcnR5TGVhdmVzLmhhcyhrZXkpIHx8IGFjdGl2ZURpcnR5RWxlbWVudHMuaGFzKGtleSk7XG4gIGNvbnN0IGRvbSA9IGdldEVsZW1lbnRCeUtleU9yVGhyb3coYWN0aXZlRWRpdG9yJDEsIGtleSk7IC8vIElmIHRoZSBub2RlIGtleSBwb2ludHMgdG8gdGhlIHNhbWUgaW5zdGFuY2UgaW4gYm90aCBzdGF0ZXNcbiAgLy8gYW5kIGlzbid0IGRpcnR5LCB3ZSBqdXN0IHVwZGF0ZSB0aGUgdGV4dCBjb250ZW50IGNhY2hlXG4gIC8vIGFuZCByZXR1cm4gdGhlIGV4aXN0aW5nIERPTSBOb2RlLlxuXG4gIGlmIChwcmV2Tm9kZSA9PT0gbmV4dE5vZGUgJiYgIWlzRGlydHkpIHtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUocHJldk5vZGUpKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgICAgY29uc3QgcHJldmlvdXNTdWJUcmVlVGV4dENvbnRlbnQgPSBkb20uX19sZXhpY2FsVGV4dENvbnRlbnQ7XG5cbiAgICAgIGlmIChwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudDtcbiAgICAgICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gcHJldmlvdXNTdWJUcmVlVGV4dENvbnRlbnQ7XG4gICAgICB9IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG5cblxuICAgICAgY29uc3QgcHJldmlvdXNTdWJUcmVlRGlyZWN0aW9uVGV4dENvbnRlbnQgPSBkb20uX19sZXhpY2FsRGlyVGV4dENvbnRlbnQ7XG5cbiAgICAgIGlmIChwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ICs9IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0ZXh0ID0gcHJldk5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcblxuICAgICAgaWYgKCRpc1RleHROb2RlKHByZXZOb2RlKSAmJiAhcHJldk5vZGUuaXNEaXJlY3Rpb25sZXNzKCkpIHtcbiAgICAgICAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgICAgIH1cblxuICAgICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSB0ZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBkb207XG4gIH0gLy8gSWYgdGhlIG5vZGUga2V5IGRvZXNuJ3QgcG9pbnQgdG8gdGhlIHNhbWUgaW5zdGFuY2UgaW4gYm90aCBtYXBzLFxuICAvLyBpdCBtZWFucyBpdCB3ZXJlIGNsb25lZC4gSWYgdGhleSdyZSBhbHNvIGRpcnR5LCB3ZSBtYXJrIHRoZW0gYXMgbXV0YXRlZC5cblxuXG4gIGlmIChwcmV2Tm9kZSAhPT0gbmV4dE5vZGUgJiYgaXNEaXJ0eSkge1xuICAgIHNldE11dGF0ZWROb2RlKG11dGF0ZWROb2RlcywgYWN0aXZlRWRpdG9yTm9kZXMsIGFjdGl2ZU11dGF0aW9uTGlzdGVuZXJzLCBuZXh0Tm9kZSwgJ3VwZGF0ZWQnKTtcbiAgfSAvLyBVcGRhdGUgbm9kZS4gSWYgaXQgcmV0dXJucyB0cnVlLCB3ZSBuZWVkIHRvIHVubW91bnQgYW5kIHJlLWNyZWF0ZSB0aGUgbm9kZVxuXG5cbiAgaWYgKG5leHROb2RlLnVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBhY3RpdmVFZGl0b3JDb25maWcpKSB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnRET00gPSBjcmVhdGVOb2RlKGtleSwgbnVsbCwgbnVsbCk7XG5cbiAgICBpZiAocGFyZW50RE9NID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGByZWNvbmNpbGVOb2RlOiBwYXJlbnRET00gaXMgbnVsbGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcmVudERPTS5yZXBsYWNlQ2hpbGQocmVwbGFjZW1lbnRET00sIGRvbSk7XG4gICAgZGVzdHJveU5vZGUoa2V5LCBudWxsKTtcbiAgICByZXR1cm4gcmVwbGFjZW1lbnRET007XG4gIH1cblxuICBpZiAoJGlzRWxlbWVudE5vZGUocHJldk5vZGUpICYmICRpc0VsZW1lbnROb2RlKG5leHROb2RlKSkge1xuICAgIC8vIFJlY29uY2lsZSBlbGVtZW50IGNoaWxkcmVuXG4gICAgY29uc3QgbmV4dEluZGVudCA9IG5leHROb2RlLl9faW5kZW50O1xuXG4gICAgaWYgKG5leHRJbmRlbnQgIT09IHByZXZOb2RlLl9faW5kZW50KSB7XG4gICAgICBzZXRFbGVtZW50SW5kZW50KGRvbSwgbmV4dEluZGVudCk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV4dEZvcm1hdCA9IG5leHROb2RlLl9fZm9ybWF0O1xuXG4gICAgaWYgKG5leHRGb3JtYXQgIT09IHByZXZOb2RlLl9fZm9ybWF0KSB7XG4gICAgICBzZXRFbGVtZW50Rm9ybWF0KGRvbSwgbmV4dEZvcm1hdCk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlydHkpIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuV2l0aERpcmVjdGlvbihwcmV2Tm9kZSwgbmV4dE5vZGUsIGRvbSk7XG5cbiAgICAgIGlmICghJGlzUm9vdE5vZGUobmV4dE5vZGUpICYmICFuZXh0Tm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAgIHJlY29uY2lsZUVsZW1lbnRUZXJtaW5hdGluZ0xpbmVCcmVhayhwcmV2Tm9kZSwgbmV4dE5vZGUsIGRvbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCR0ZXh0Q29udGVudFJlcXVpcmVzRG91YmxlTGluZWJyZWFrQXRFbmQobmV4dE5vZGUpKSB7XG4gICAgICBzdWJUcmVlVGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gICAgICBlZGl0b3JUZXh0Q29udGVudCArPSBET1VCTEVfTElORV9CUkVBSztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdGV4dCA9IG5leHROb2RlLmdldFRleHRDb250ZW50KCk7XG5cbiAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShuZXh0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGRlY29yYXRvciA9IG5leHROb2RlLmRlY29yYXRlKGFjdGl2ZUVkaXRvciQxLCBhY3RpdmVFZGl0b3JDb25maWcpO1xuXG4gICAgICBpZiAoZGVjb3JhdG9yICE9PSBudWxsKSB7XG4gICAgICAgIHJlY29uY2lsZURlY29yYXRvcihrZXksIGRlY29yYXRvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZShuZXh0Tm9kZSkgJiYgIW5leHROb2RlLmlzRGlyZWN0aW9ubGVzcygpKSB7XG4gICAgICAvLyBIYW5kbGUgdGV4dCBjb250ZW50LCBmb3IgTFRSLCBMVFIgY2FzZXMuXG4gICAgICBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCArPSB0ZXh0O1xuICAgIH1cblxuICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSB0ZXh0O1xuICAgIGVkaXRvclRleHRDb250ZW50ICs9IHRleHQ7XG4gIH1cblxuICBpZiAoIWFjdGl2ZUVkaXRvclN0YXRlUmVhZE9ubHkgJiYgJGlzUm9vdE5vZGUobmV4dE5vZGUpICYmIG5leHROb2RlLl9fY2FjaGVkVGV4dCAhPT0gZWRpdG9yVGV4dENvbnRlbnQpIHtcbiAgICAvLyBDYWNoZSB0aGUgbGF0ZXN0IHRleHQgY29udGVudC5cbiAgICBuZXh0Tm9kZSA9IG5leHROb2RlLmdldFdyaXRhYmxlKCk7XG4gICAgbmV4dE5vZGUuX19jYWNoZWRUZXh0ID0gZWRpdG9yVGV4dENvbnRlbnQ7XG4gIH1cblxuICB7XG4gICAgLy8gRnJlZXplIHRoZSBub2RlIGluIERFViB0byBwcmV2ZW50IGFjY2lkZW50YWwgbXV0YXRpb25zXG4gICAgT2JqZWN0LmZyZWV6ZShuZXh0Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gZG9tO1xufVxuXG5mdW5jdGlvbiByZWNvbmNpbGVEZWNvcmF0b3Ioa2V5LCBkZWNvcmF0b3IpIHtcbiAgbGV0IHBlbmRpbmdEZWNvcmF0b3JzID0gYWN0aXZlRWRpdG9yJDEuX3BlbmRpbmdEZWNvcmF0b3JzO1xuICBjb25zdCBjdXJyZW50RGVjb3JhdG9ycyA9IGFjdGl2ZUVkaXRvciQxLl9kZWNvcmF0b3JzO1xuXG4gIGlmIChwZW5kaW5nRGVjb3JhdG9ycyA9PT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50RGVjb3JhdG9yc1trZXldID09PSBkZWNvcmF0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwZW5kaW5nRGVjb3JhdG9ycyA9IGNsb25lRGVjb3JhdG9ycyhhY3RpdmVFZGl0b3IkMSk7XG4gIH1cblxuICBwZW5kaW5nRGVjb3JhdG9yc1trZXldID0gZGVjb3JhdG9yO1xufVxuXG5mdW5jdGlvbiBnZXRGaXJzdENoaWxkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuZmlyc3RDaGlsZDtcbn1cblxuZnVuY3Rpb24gZ2V0TmV4dFNpYmxpbmcoZWxlbWVudCkge1xuICBsZXQgbmV4dFNpYmxpbmcgPSBlbGVtZW50Lm5leHRTaWJsaW5nO1xuXG4gIGlmIChuZXh0U2libGluZyAhPT0gbnVsbCAmJiBuZXh0U2libGluZyA9PT0gYWN0aXZlRWRpdG9yJDEuX2Jsb2NrQ3Vyc29yRWxlbWVudCkge1xuICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcubmV4dFNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbmV4dFNpYmxpbmc7XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZU5vZGVDaGlsZHJlbihuZXh0RWxlbWVudCwgcHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIHByZXZDaGlsZHJlbkxlbmd0aCwgbmV4dENoaWxkcmVuTGVuZ3RoLCBkb20pIHtcbiAgY29uc3QgcHJldkVuZEluZGV4ID0gcHJldkNoaWxkcmVuTGVuZ3RoIC0gMTtcbiAgY29uc3QgbmV4dEVuZEluZGV4ID0gbmV4dENoaWxkcmVuTGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZDaGlsZHJlblNldDtcbiAgbGV0IG5leHRDaGlsZHJlblNldDtcbiAgbGV0IHNpYmxpbmdET00gPSBnZXRGaXJzdENoaWxkKGRvbSk7XG4gIGxldCBwcmV2SW5kZXggPSAwO1xuICBsZXQgbmV4dEluZGV4ID0gMDtcblxuICB3aGlsZSAocHJldkluZGV4IDw9IHByZXZFbmRJbmRleCAmJiBuZXh0SW5kZXggPD0gbmV4dEVuZEluZGV4KSB7XG4gICAgY29uc3QgcHJldktleSA9IHByZXZDaGlsZHJlbltwcmV2SW5kZXhdO1xuICAgIGNvbnN0IG5leHRLZXkgPSBuZXh0Q2hpbGRyZW5bbmV4dEluZGV4XTtcblxuICAgIGlmIChwcmV2S2V5ID09PSBuZXh0S2V5KSB7XG4gICAgICBzaWJsaW5nRE9NID0gZ2V0TmV4dFNpYmxpbmcocmVjb25jaWxlTm9kZShuZXh0S2V5LCBkb20pKTtcbiAgICAgIHByZXZJbmRleCsrO1xuICAgICAgbmV4dEluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmV2Q2hpbGRyZW5TZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcmV2Q2hpbGRyZW5TZXQgPSBuZXcgU2V0KHByZXZDaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW5TZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW5TZXQgPSBuZXcgU2V0KG5leHRDaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5leHRIYXNQcmV2S2V5ID0gbmV4dENoaWxkcmVuU2V0LmhhcyhwcmV2S2V5KTtcbiAgICAgIGNvbnN0IHByZXZIYXNOZXh0S2V5ID0gcHJldkNoaWxkcmVuU2V0LmhhcyhuZXh0S2V5KTtcblxuICAgICAgaWYgKCFuZXh0SGFzUHJldktleSkge1xuICAgICAgICAvLyBSZW1vdmUgcHJldlxuICAgICAgICBzaWJsaW5nRE9NID0gZ2V0TmV4dFNpYmxpbmcoZ2V0UHJldkVsZW1lbnRCeUtleU9yVGhyb3cocHJldktleSkpO1xuICAgICAgICBkZXN0cm95Tm9kZShwcmV2S2V5LCBkb20pO1xuICAgICAgICBwcmV2SW5kZXgrKztcbiAgICAgIH0gZWxzZSBpZiAoIXByZXZIYXNOZXh0S2V5KSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXh0XG4gICAgICAgIGNyZWF0ZU5vZGUobmV4dEtleSwgZG9tLCBzaWJsaW5nRE9NKTtcbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNb3ZlIG5leHRcbiAgICAgICAgY29uc3QgY2hpbGRET00gPSBnZXRFbGVtZW50QnlLZXlPclRocm93KGFjdGl2ZUVkaXRvciQxLCBuZXh0S2V5KTtcblxuICAgICAgICBpZiAoY2hpbGRET00gPT09IHNpYmxpbmdET00pIHtcbiAgICAgICAgICBzaWJsaW5nRE9NID0gZ2V0TmV4dFNpYmxpbmcocmVjb25jaWxlTm9kZShuZXh0S2V5LCBkb20pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2libGluZ0RPTSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb20uaW5zZXJ0QmVmb3JlKGNoaWxkRE9NLCBzaWJsaW5nRE9NKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tLmFwcGVuZENoaWxkKGNoaWxkRE9NKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWNvbmNpbGVOb2RlKG5leHRLZXksIGRvbSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2SW5kZXgrKztcbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYXBwZW5kTmV3Q2hpbGRyZW4gPSBwcmV2SW5kZXggPiBwcmV2RW5kSW5kZXg7XG4gIGNvbnN0IHJlbW92ZU9sZENoaWxkcmVuID0gbmV4dEluZGV4ID4gbmV4dEVuZEluZGV4O1xuXG4gIGlmIChhcHBlbmROZXdDaGlsZHJlbiAmJiAhcmVtb3ZlT2xkQ2hpbGRyZW4pIHtcbiAgICBjb25zdCBwcmV2aW91c05vZGUgPSBuZXh0Q2hpbGRyZW5bbmV4dEVuZEluZGV4ICsgMV07XG4gICAgY29uc3QgaW5zZXJ0RE9NID0gcHJldmlvdXNOb2RlID09PSB1bmRlZmluZWQgPyBudWxsIDogYWN0aXZlRWRpdG9yJDEuZ2V0RWxlbWVudEJ5S2V5KHByZXZpb3VzTm9kZSk7XG4gICAgY3JlYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCBuZXh0RWxlbWVudCwgbmV4dEluZGV4LCBuZXh0RW5kSW5kZXgsIGRvbSwgaW5zZXJ0RE9NKTtcbiAgfSBlbHNlIGlmIChyZW1vdmVPbGRDaGlsZHJlbiAmJiAhYXBwZW5kTmV3Q2hpbGRyZW4pIHtcbiAgICBkZXN0cm95Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBwcmV2SW5kZXgsIHByZXZFbmRJbmRleCwgZG9tKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvbmNpbGVSb290KHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlLCBlZGl0b3IsIGRpcnR5VHlwZSwgZGlydHlFbGVtZW50cywgZGlydHlMZWF2ZXMpIHtcbiAgLy8gV2UgY2FjaGUgdGV4dCBjb250ZW50IHRvIG1ha2UgcmV0cmlldmFsIG1vcmUgZWZmaWNpZW50LlxuICAvLyBUaGUgY2FjaGUgbXVzdCBiZSByZWJ1aWx0IGR1cmluZyByZWNvbmNpbGlhdGlvbiB0byBhY2NvdW50IGZvciBhbnkgY2hhbmdlcy5cbiAgc3ViVHJlZVRleHRDb250ZW50ID0gJyc7XG4gIGVkaXRvclRleHRDb250ZW50ID0gJyc7XG4gIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gJyc7IC8vIFJhdGhlciB0aGFuIHBhc3MgYXJvdW5kIGEgbG9hZCBvZiBhcmd1bWVudHMgdGhyb3VnaCB0aGUgc3RhY2sgcmVjdXJzaXZlbHlcbiAgLy8gd2UgaW5zdGVhZCBzZXQgdGhlbSBhcyBiaW5kaW5ncyB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBtb2R1bGUuXG5cbiAgdHJlYXRBbGxOb2Rlc0FzRGlydHkgPSBkaXJ0eVR5cGUgPT09IEZVTExfUkVDT05DSUxFO1xuICBhY3RpdmVUZXh0RGlyZWN0aW9uID0gbnVsbDtcbiAgYWN0aXZlRWRpdG9yJDEgPSBlZGl0b3I7XG4gIGFjdGl2ZUVkaXRvckNvbmZpZyA9IGVkaXRvci5fY29uZmlnO1xuICBhY3RpdmVFZGl0b3JOb2RlcyA9IGVkaXRvci5fbm9kZXM7XG4gIGFjdGl2ZU11dGF0aW9uTGlzdGVuZXJzID0gYWN0aXZlRWRpdG9yJDEuX2xpc3RlbmVycy5tdXRhdGlvbjtcbiAgYWN0aXZlRGlydHlFbGVtZW50cyA9IGRpcnR5RWxlbWVudHM7XG4gIGFjdGl2ZURpcnR5TGVhdmVzID0gZGlydHlMZWF2ZXM7XG4gIGFjdGl2ZVByZXZOb2RlTWFwID0gcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBhY3RpdmVOZXh0Tm9kZU1hcCA9IG5leHRFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgYWN0aXZlRWRpdG9yU3RhdGVSZWFkT25seSA9IG5leHRFZGl0b3JTdGF0ZS5fcmVhZE9ubHk7XG4gIGFjdGl2ZVByZXZLZXlUb0RPTU1hcCA9IG5ldyBNYXAoZWRpdG9yLl9rZXlUb0RPTU1hcCk7IC8vIFdlIGtlZXAgdHJhY2sgb2YgbXV0YXRlZCBub2RlcyBzbyB3ZSBjYW4gdHJpZ2dlciBtdXRhdGlvblxuICAvLyBsaXN0ZW5lcnMgbGF0ZXIgaW4gdGhlIHVwZGF0ZSBjeWNsZS5cblxuICBjb25zdCBjdXJyZW50TXV0YXRlZE5vZGVzID0gbmV3IE1hcCgpO1xuICBtdXRhdGVkTm9kZXMgPSBjdXJyZW50TXV0YXRlZE5vZGVzO1xuICByZWNvbmNpbGVOb2RlKCdyb290JywgbnVsbCk7IC8vIFdlIGRvbid0IHdhbnQgYSBidW5jaCBvZiB2b2lkIGNoZWNrcyB0aHJvdWdob3V0IHRoZSBzY29wZVxuICAvLyBzbyBpbnN0ZWFkIHdlIG1ha2UgaXQgc2VlbSB0aGF0IHRoZXNlIHZhbHVlcyBhcmUgYWx3YXlzIHNldC5cbiAgLy8gV2UgYWxzbyB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBjbGVhciB0aGVtIGRvd24sIG90aGVyd2lzZSB3ZVxuICAvLyBjYW4gbGVhayBtZW1vcnkuXG4gIC8vIEB0cy1pZ25vcmVcblxuICBhY3RpdmVFZGl0b3IkMSA9IHVuZGVmaW5lZDsgLy8gQHRzLWlnbm9yZVxuXG4gIGFjdGl2ZUVkaXRvck5vZGVzID0gdW5kZWZpbmVkOyAvLyBAdHMtaWdub3JlXG5cbiAgYWN0aXZlRGlydHlFbGVtZW50cyA9IHVuZGVmaW5lZDsgLy8gQHRzLWlnbm9yZVxuXG4gIGFjdGl2ZURpcnR5TGVhdmVzID0gdW5kZWZpbmVkOyAvLyBAdHMtaWdub3JlXG5cbiAgYWN0aXZlUHJldk5vZGVNYXAgPSB1bmRlZmluZWQ7IC8vIEB0cy1pZ25vcmVcblxuICBhY3RpdmVOZXh0Tm9kZU1hcCA9IHVuZGVmaW5lZDsgLy8gQHRzLWlnbm9yZVxuXG4gIGFjdGl2ZUVkaXRvckNvbmZpZyA9IHVuZGVmaW5lZDsgLy8gQHRzLWlnbm9yZVxuXG4gIGFjdGl2ZVByZXZLZXlUb0RPTU1hcCA9IHVuZGVmaW5lZDsgLy8gQHRzLWlnbm9yZVxuXG4gIG11dGF0ZWROb2RlcyA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGN1cnJlbnRNdXRhdGVkTm9kZXM7XG59XG5mdW5jdGlvbiBzdG9yZURPTVdpdGhLZXkoa2V5LCBkb20sIGVkaXRvcikge1xuICBjb25zdCBrZXlUb0RPTU1hcCA9IGVkaXRvci5fa2V5VG9ET01NYXA7IC8vIEB0cy1pZ25vcmUgV2UgaW50ZW50aW9uYWxseSBhZGQgdGhpcyB0byB0aGUgTm9kZS5cblxuICBkb21bJ19fbGV4aWNhbEtleV8nICsgZWRpdG9yLl9rZXldID0ga2V5O1xuICBrZXlUb0RPTU1hcC5zZXQoa2V5LCBkb20pO1xufVxuXG5mdW5jdGlvbiBnZXRQcmV2RWxlbWVudEJ5S2V5T3JUaHJvdyhrZXkpIHtcbiAgY29uc3QgZWxlbWVudCA9IGFjdGl2ZVByZXZLZXlUb0RPTU1hcC5nZXQoa2V5KTtcblxuICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYFJlY29uY2lsaWF0aW9uOiBjb3VsZCBub3QgZmluZCBET00gZWxlbWVudCBmb3Igbm9kZSBrZXkgJHtrZXl9YCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IFBBU1NfVEhST1VHSF9DT01NQU5EID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5jb25zdCBBTkRST0lEX0NPTVBPU0lUSU9OX0xBVEVOQ1kgPSAzMDtcbmNvbnN0IHJvb3RFbGVtZW50RXZlbnRzID0gW1sna2V5ZG93bicsIG9uS2V5RG93bl0sIFsncG9pbnRlcmRvd24nLCBvblBvaW50ZXJEb3duXSwgWydjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0XSwgWydjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmRdLCBbJ2lucHV0Jywgb25JbnB1dF0sIFsnY2xpY2snLCBvbkNsaWNrXSwgWydjdXQnLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsnY29weScsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydkcmFnc3RhcnQnLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsnZHJhZ292ZXInLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsnZHJhZ2VuZCcsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydwYXN0ZScsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydmb2N1cycsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydibHVyJywgUEFTU19USFJPVUdIX0NPTU1BTkRdLCBbJ2Ryb3AnLCBQQVNTX1RIUk9VR0hfQ09NTUFORF1dO1xuXG5pZiAoQ0FOX1VTRV9CRUZPUkVfSU5QVVQpIHtcbiAgcm9vdEVsZW1lbnRFdmVudHMucHVzaChbJ2JlZm9yZWlucHV0JywgKGV2ZW50LCBlZGl0b3IpID0+IG9uQmVmb3JlSW5wdXQoZXZlbnQsIGVkaXRvcildKTtcbn1cblxubGV0IGxhc3RLZXlEb3duVGltZVN0YW1wID0gMDtcbmxldCBsYXN0S2V5Q29kZSA9IDA7XG5sZXQgbGFzdEJlZm9yZUlucHV0SW5zZXJ0VGV4dFRpbWVTdGFtcCA9IDA7XG5sZXQgdW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEgPSBudWxsO1xubGV0IHJvb3RFbGVtZW50c1JlZ2lzdGVyZWQgPSAwO1xubGV0IGlzU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSA9IGZhbHNlO1xubGV0IGlzU2VsZWN0aW9uQ2hhbmdlRnJvbU1vdXNlRG93biA9IGZhbHNlO1xubGV0IGlzSW5zZXJ0TGluZUJyZWFrID0gZmFsc2U7XG5sZXQgaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24gPSBmYWxzZTtcbmxldCBjb2xsYXBzZWRTZWxlY3Rpb25Gb3JtYXQgPSBbMCwgJycsIDAsICdyb290JywgMF07IC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgTGV4aWNhbCBzaG91bGQgYXR0ZW1wdCB0byBvdmVycmlkZVxuLy8gdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBmb3IgaW5zZXJ0aW9uIG9mIHRleHQgYW5kIHVzZSBpdHMgb3duIGludGVybmFsXG4vLyBoZXVyaXN0aWNzLiBUaGlzIGlzIGFuIGV4dHJlbWVseSBpbXBvcnRhbnQgZnVuY3Rpb24sIGFuZCBtYWtlcyBtdWNoIG9mIExleGljYWxcbi8vIHdvcmsgYXMgaW50ZW5kZWQgYmV0d2VlbiBkaWZmZXJlbnQgYnJvd3NlcnMgYW5kIGFjcm9zcyB3b3JkLCBsaW5lIGFuZCBjaGFyYWN0ZXJcbi8vIGJvdW5kYXJ5L2Zvcm1hdHMuIEl0IGFsc28gaXMgaW1wb3J0YW50IGZvciB0ZXh0IHJlcGxhY2VtZW50LCBub2RlIHNjaGVtYXMgYW5kXG4vLyBjb21wb3NpdGlvbiBtZWNoYW5pY3MuXG5cbmZ1bmN0aW9uICRzaG91bGRQcmV2ZW50RGVmYXVsdEFuZEluc2VydFRleHQoc2VsZWN0aW9uLCBkb21UYXJnZXRSYW5nZSwgdGV4dCwgdGltZVN0YW1wLCBpc0JlZm9yZUlucHV0KSB7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gIGNvbnN0IGRvbUFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24gIT09IG51bGwgPyBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSA6IG51bGw7XG4gIGNvbnN0IGFuY2hvcktleSA9IGFuY2hvci5rZXk7XG4gIGNvbnN0IGJhY2tpbmdBbmNob3JFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JLZXkpO1xuICBjb25zdCB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gIHJldHVybiBhbmNob3JLZXkgIT09IGZvY3VzLmtleSB8fCAvLyBJZiB3ZSdyZSB3b3JraW5nIHdpdGggYSBub24tdGV4dCBub2RlLlxuICAhJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkgfHwgLy8gSWYgd2UgYXJlIHJlcGxhY2luZyBhIHJhbmdlIHdpdGggYSBzaW5nbGUgY2hhcmFjdGVyIG9yIGdyYXBoZW1lLCBhbmQgbm90IGNvbXBvc2luZy5cbiAgKCFpc0JlZm9yZUlucHV0ICYmICghQ0FOX1VTRV9CRUZPUkVfSU5QVVQgfHwgLy8gV2UgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGhhcyBiZWVuXG4gIC8vIGEgcmVjZW50IGJlZm9yZWlucHV0IGV2ZW50IGZvciBcInRleHRJbnB1dFwiLiBJZiB0aGVyZSBoYXMgYmVlbiBvbmUgaW4gdGhlIGxhc3RcbiAgLy8gNTBtcyB0aGVuIHdlIHByb2NlZWQgYXMgbm9ybWFsLiBIb3dldmVyLCBpZiB0aGVyZSBpcyBub3QsIHRoZW4gdGhpcyBpcyBsaWtlbHlcbiAgLy8gYSBkYW5nbGluZyBgaW5wdXRgIGV2ZW50IGNhdXNlZCBieSBleGVjQ29tbWFuZCgnaW5zZXJ0VGV4dCcpLlxuICBsYXN0QmVmb3JlSW5wdXRJbnNlcnRUZXh0VGltZVN0YW1wIDwgdGltZVN0YW1wICsgNTApIHx8IGFuY2hvck5vZGUuaXNEaXJ0eSgpICYmIHRleHRMZW5ndGggPCAyIHx8IGRvZXNDb250YWluR3JhcGhlbWUodGV4dCkpICYmIGFuY2hvci5vZmZzZXQgIT09IGZvY3VzLm9mZnNldCAmJiAhYW5jaG9yTm9kZS5pc0NvbXBvc2luZygpIHx8IC8vIEFueSBub24gc3RhbmRhcmQgdGV4dCBub2RlLlxuICAkaXNUb2tlbk9yU2VnbWVudGVkKGFuY2hvck5vZGUpIHx8IC8vIElmIHRoZSB0ZXh0IGxlbmd0aCBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgY2hhcmFjdGVyIGFuZCB3ZSdyZSBlaXRoZXJcbiAgLy8gZGVhbGluZyB3aXRoIHRoaXMgaW4gXCJiZWZvcmVpbnB1dFwiIG9yIHdoZXJlIHRoZSBub2RlIGhhcyBhbHJlYWR5IHJlY2VudGx5XG4gIC8vIGJlZW4gY2hhbmdlZCAodGh1cyBpcyBkaXJ0eSkuXG4gIGFuY2hvck5vZGUuaXNEaXJ0eSgpICYmIHRleHRMZW5ndGggPiAxIHx8IC8vIElmIHRoZSBET00gc2VsZWN0aW9uIGVsZW1lbnQgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBiYWNraW5nIG5vZGUgZHVyaW5nIGJlZm9yZWlucHV0LlxuICAoaXNCZWZvcmVJbnB1dCB8fCAhQ0FOX1VTRV9CRUZPUkVfSU5QVVQpICYmIGJhY2tpbmdBbmNob3JFbGVtZW50ICE9PSBudWxsICYmICFhbmNob3JOb2RlLmlzQ29tcG9zaW5nKCkgJiYgZG9tQW5jaG9yTm9kZSAhPT0gZ2V0RE9NVGV4dE5vZGUoYmFja2luZ0FuY2hvckVsZW1lbnQpIHx8IC8vIElmIFRhcmdldFJhbmdlIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgRE9NIHNlbGVjdGlvbjsgYnJvd3NlciB0cnlpbmcgdG8gZWRpdCByYW5kb20gcGFydHNcbiAgLy8gb2YgdGhlIGVkaXRvci5cbiAgZG9tU2VsZWN0aW9uICE9PSBudWxsICYmIGRvbVRhcmdldFJhbmdlICE9PSBudWxsICYmICghZG9tVGFyZ2V0UmFuZ2UuY29sbGFwc2VkIHx8IGRvbVRhcmdldFJhbmdlLnN0YXJ0Q29udGFpbmVyICE9PSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSB8fCBkb21UYXJnZXRSYW5nZS5zdGFydE9mZnNldCAhPT0gZG9tU2VsZWN0aW9uLmFuY2hvck9mZnNldCkgfHwgLy8gQ2hlY2sgaWYgd2UncmUgY2hhbmdpbmcgZnJvbSBib2xkIHRvIGl0YWxpY3MsIG9yIHNvbWUgb3RoZXIgZm9ybWF0LlxuICBhbmNob3JOb2RlLmdldEZvcm1hdCgpICE9PSBzZWxlY3Rpb24uZm9ybWF0IHx8IGFuY2hvck5vZGUuZ2V0U3R5bGUoKSAhPT0gc2VsZWN0aW9uLnN0eWxlIHx8IC8vIE9uZSBsYXN0IHNldCBvZiBoZXVyaXN0aWNzIHRvIGNoZWNrIGFnYWluc3QuXG4gICRzaG91bGRJbnNlcnRUZXh0QWZ0ZXJPckJlZm9yZVRleHROb2RlKHNlbGVjdGlvbiwgYW5jaG9yTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFNraXBTZWxlY3Rpb25DaGFuZ2UoZG9tTm9kZSwgb2Zmc2V0KSB7XG4gIHJldHVybiBkb21Ob2RlICE9PSBudWxsICYmIGRvbU5vZGUubm9kZVZhbHVlICE9PSBudWxsICYmIGRvbU5vZGUubm9kZVR5cGUgPT09IERPTV9URVhUX1RZUEUgJiYgb2Zmc2V0ICE9PSAwICYmIG9mZnNldCAhPT0gZG9tTm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBvblNlbGVjdGlvbkNoYW5nZShkb21TZWxlY3Rpb24sIGVkaXRvciwgaXNBY3RpdmUpIHtcbiAgY29uc3Qge1xuICAgIGFuY2hvck5vZGU6IGFuY2hvckRPTSxcbiAgICBhbmNob3JPZmZzZXQsXG4gICAgZm9jdXNOb2RlOiBmb2N1c0RPTSxcbiAgICBmb2N1c09mZnNldFxuICB9ID0gZG9tU2VsZWN0aW9uO1xuXG4gIGlmIChpc1NlbGVjdGlvbkNoYW5nZUZyb21ET01VcGRhdGUpIHtcbiAgICBpc1NlbGVjdGlvbkNoYW5nZUZyb21ET01VcGRhdGUgPSBmYWxzZTsgLy8gSWYgbmF0aXZlIERPTSBzZWxlY3Rpb24gaXMgb24gYSBET00gZWxlbWVudCwgdGhlblxuICAgIC8vIHdlIHNob3VsZCBjb250aW51ZSBhcyB1c3VhbCwgYXMgTGV4aWNhbCdzIHNlbGVjdGlvblxuICAgIC8vIG1heSBoYXZlIG5vcm1hbGl6ZWQgdG8gYSBiZXR0ZXIgY2hpbGQuIElmIHRoZSBET01cbiAgICAvLyBlbGVtZW50IGlzIGEgdGV4dCBub2RlLCB3ZSBjYW4gc2FmZWx5IGFwcGx5IHRoaXNcbiAgICAvLyBvcHRpbWl6YXRpb24gYW5kIHNraXAgdGhlIHNlbGVjdGlvbiBjaGFuZ2UgZW50aXJlbHkuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGNoZWNrIGlmIHRoZSBvZmZzZXQgaXMgYXQgdGhlIGJvdW5kYXJ5LFxuICAgIC8vIGJlY2F1c2UgaW4gdGhpcyBjYXNlLCB3ZSBtaWdodCBuZWVkIHRvIG5vcm1hbGl6ZSB0byBhXG4gICAgLy8gc2libGluZyBpbnN0ZWFkLlxuXG4gICAgaWYgKHNob3VsZFNraXBTZWxlY3Rpb25DaGFuZ2UoYW5jaG9yRE9NLCBhbmNob3JPZmZzZXQpICYmIHNob3VsZFNraXBTZWxlY3Rpb25DaGFuZ2UoZm9jdXNET00sIGZvY3VzT2Zmc2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICAvLyBOb24tYWN0aXZlIGVkaXRvciBkb24ndCBuZWVkIGFueSBleHRyYSBsb2dpYyBmb3Igc2VsZWN0aW9uLCBpdCBvbmx5IG5lZWRzIHVwZGF0ZVxuICAgIC8vIHRvIHJlY29uY2lsZSBzZWxlY3Rpb24gKHNldCBpdCB0byBudWxsKSB0byBlbnN1cmUgdGhhdCBvbmx5IG9uZSBlZGl0b3IgaGFzIG5vbi1udWxsIHNlbGVjdGlvbi5cbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAkc2V0U2VsZWN0aW9uKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET00sIGZvY3VzRE9NKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTsgLy8gVXBkYXRlIHRoZSBzZWxlY3Rpb24gZm9ybWF0XG5cbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgLy8gQmFkbHkgaW50ZXJwcmV0ZWQgcmFuZ2Ugc2VsZWN0aW9uIHdoZW4gY29sbGFwc2VkIC0gIzE0ODJcbiAgICAgICAgaWYgKGRvbVNlbGVjdGlvbi50eXBlID09PSAnUmFuZ2UnICYmIGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBkb21TZWxlY3Rpb24uZm9jdXNOb2RlKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBJZiB3ZSBoYXZlIG1hcmtlZCBhIGNvbGxhcHNlZCBzZWxlY3Rpb24gZm9ybWF0LCBhbmQgd2UncmVcbiAgICAgICAgLy8gd2l0aGluIHRoZSBnaXZlbiB0aW1lIHJhbmdlIOKAkyB0aGVuIGF0dGVtcHQgdG8gdXNlIHRoYXQgZm9ybWF0XG4gICAgICAgIC8vIGluc3RlYWQgb2YgZ2V0dGluZyB0aGUgZm9ybWF0IGZyb20gdGhlIGFuY2hvciBub2RlLlxuXG5cbiAgICAgICAgY29uc3Qgd2luZG93RXZlbnQgPSBnZXRXaW5kb3coZWRpdG9yKS5ldmVudDtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWVTdGFtcCA9IHdpbmRvd0V2ZW50ID8gd2luZG93RXZlbnQudGltZVN0YW1wIDogcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGNvbnN0IFtsYXN0Rm9ybWF0LCBsYXN0U3R5bGUsIGxhc3RPZmZzZXQsIGxhc3RLZXksIHRpbWVTdGFtcF0gPSBjb2xsYXBzZWRTZWxlY3Rpb25Gb3JtYXQ7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lU3RhbXAgPCB0aW1lU3RhbXAgKyAyMDAgJiYgYW5jaG9yLm9mZnNldCA9PT0gbGFzdE9mZnNldCAmJiBhbmNob3Iua2V5ID09PSBsYXN0S2V5KSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmZvcm1hdCA9IGxhc3RGb3JtYXQ7XG4gICAgICAgICAgc2VsZWN0aW9uLnN0eWxlID0gbGFzdFN0eWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZm9ybWF0ID0gYW5jaG9yTm9kZS5nZXRGb3JtYXQoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5zdHlsZSA9IGFuY2hvck5vZGUuZ2V0U3R5bGUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFuY2hvci50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5mb3JtYXQgPSAwO1xuICAgICAgICAgICAgc2VsZWN0aW9uLnN0eWxlID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY29tYmluZWRGb3JtYXQgPSBJU19BTExfRk9STUFUVElORztcbiAgICAgICAgbGV0IGhhc1RleHROb2RlcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgICBjb25zdCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgICAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHdoYXQgYWJvdXQgc3R5bGU/XG4gICAgICAgICAgICBoYXNUZXh0Tm9kZXMgPSB0cnVlO1xuICAgICAgICAgICAgY29tYmluZWRGb3JtYXQgJj0gbm9kZS5nZXRGb3JtYXQoKTtcblxuICAgICAgICAgICAgaWYgKGNvbWJpbmVkRm9ybWF0ID09PSAwKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdGlvbi5mb3JtYXQgPSBoYXNUZXh0Tm9kZXMgPyBjb21iaW5lZEZvcm1hdCA6IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICB9KTtcbn0gLy8gVGhpcyBpcyBhIHdvcmstYXJvdW5kIGlzIG1haW5seSBDaHJvbWUgc3BlY2lmaWMgYnVnIHdoZXJlIGlmIHlvdSBzZWxlY3Rcbi8vIHRoZSBjb250ZW50cyBvZiBhbiBlbXB0eSBibG9jaywgeW91IGNhbm5vdCBlYXNpbHkgdW5zZWxlY3QgYW55dGhpbmcuXG4vLyBUaGlzIHJlc3VsdHMgaW4gYSB0aW55IHNlbGVjdGlvbiBib3ggdGhhdCBsb29rcyBidWdneS9icm9rZW4uIFRoaXMgY2FuXG4vLyBhbHNvIGhlbHAgb3RoZXIgYnJvd3NlcnMgd2hlbiBzZWxlY3Rpb24gbWlnaHQgXCJhcHBlYXJcIiBsb3N0LCB3aGVuIGl0XG4vLyByZWFsbHkgaXNuJ3QuXG5cblxuZnVuY3Rpb24gb25DbGljayhldmVudCwgZWRpdG9yKSB7XG4gIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcbiAgICBjb25zdCBsYXN0U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoZG9tU2VsZWN0aW9uKSB7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcblxuICAgICAgICBpZiAoYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBhbmNob3Iub2Zmc2V0ID09PSAwICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmICEkaXNSb290Tm9kZShhbmNob3JOb2RlKSAmJiAkZ2V0Um9vdCgpLmdldENoaWxkcmVuU2l6ZSgpID09PSAxICYmIGFuY2hvck5vZGUuZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdygpLmlzRW1wdHkoKSAmJiBsYXN0U2VsZWN0aW9uICE9PSBudWxsICYmIHNlbGVjdGlvbi5pcyhsYXN0U2VsZWN0aW9uKSkge1xuICAgICAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmRldGFpbCA9PT0gMyAmJiAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICAvLyBUcmlwcGxlIGNsaWNrIGNhdXNpbmcgc2VsZWN0aW9uIHRvIG92ZXJmbG93IGludG8gdGhlIG5lYXJlc3QgZWxlbWVudC4gSW4gdGhhdFxuICAgICAgICAgIC8vIGNhc2UgdmlzdWFsbHkgaXQgbG9va3MgbGlrZSBhIHNpbmdsZSBlbGVtZW50IGNvbnRlbnQgaXMgc2VsZWN0ZWQsIGZvY3VzIG5vZGVcbiAgICAgICAgICAvLyBpcyBhY3R1YWxseSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGVsZW1lbnQgKGlmIHByZXNlbnQpIGFuZCBhbnkgbWFuaXB1bGF0aW9uc1xuICAgICAgICAgIC8vIHdpdGggc2VsZWN0aW9uIChmb3JtYXR0aW5nKSBhcmUgYWZmZWN0aW5nIHNlY29uZCBlbGVtZW50IGFzIHdlbGxcbiAgICAgICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICAgICAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG5cbiAgICAgICAgICBpZiAoYW5jaG9yTm9kZSAhPT0gZm9jdXNOb2RlKSB7XG4gICAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgICAgYW5jaG9yTm9kZS5zZWxlY3QoMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKS5zZWxlY3QoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byB1cGRhdGUgdGhlIHNlbGVjdGlvbiBvbiB0b3VjaCBkZXZpY2VzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRleHQgYWZ0ZXIgYVxuICAgICAgICAvLyBub2RlIHNlbGVjdGlvbi4gU2VlIGlzU2VsZWN0aW9uQ2hhbmdlRnJvbU1vdXNlRG93biBmb3IgdGhlIGludmVyc2VcbiAgICAgICAgY29uc3QgZG9tQW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuXG4gICAgICAgIGlmIChkb21BbmNob3JOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZVR5cGUgPSBkb21BbmNob3JOb2RlLm5vZGVUeXBlOyAvLyBJZiB0aGUgdXNlciBpcyBhdHRlbXB0aW5nIHRvIGNsaWNrIHNlbGVjdGlvbiBiYWNrIG9udG8gdGV4dCwgdGhlblxuICAgICAgICAgIC8vIHdlIHNob3VsZCBhdHRlbXB0IGNyZWF0ZSBhIHJhbmdlIHNlbGVjdGlvbi5cbiAgICAgICAgICAvLyBXaGVuIHdlIGNsaWNrIG9uIGFuIGVtcHR5IHBhcmFncmFwaCBub2RlIG9yIHRoZSBlbmQgb2YgYSBwYXJhZ3JhcGggdGhhdCBlbmRzXG4gICAgICAgICAgLy8gd2l0aCBhbiBpbWFnZS9wb2xsLCB0aGUgbm9kZVR5cGUgd2lsbCBiZSBFTEVNRU5UX05PREVcblxuICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gRE9NX0VMRU1FTlRfVFlQRSB8fCBub2RlVHlwZSA9PT0gRE9NX1RFWFRfVFlQRSkge1xuICAgICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gaW50ZXJuYWxDcmVhdGVSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uLCBkb21TZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgICAgICAgICAkc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ0xJQ0tfQ09NTUFORCwgZXZlbnQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCwgZWRpdG9yKSB7XG4gIC8vIFRPRE8gaW1wbGVtZW50IHRleHQgZHJhZyAmIGRyb3BcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICBjb25zdCBwb2ludGVyVHlwZSA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuXG4gIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmIHBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgICAgLy8gRHJhZyAmIGRyb3Agc2hvdWxkIG5vdCByZWNvbXB1dGUgc2VsZWN0aW9uIHVudGlsIG1vdXNlIHVwOyBvdGhlcndpc2UgdGhlIGluaXRpYWxseVxuICAgICAgLy8gc2VsZWN0ZWQgY29udGVudCBpcyBsb3N0LlxuICAgICAgaWYgKCEkaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9yKHRhcmdldCkpIHtcbiAgICAgICAgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tTW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRSYW5nZShldmVudCkge1xuICBpZiAoIWV2ZW50LmdldFRhcmdldFJhbmdlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgdGFyZ2V0UmFuZ2VzID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKCk7XG5cbiAgaWYgKHRhcmdldFJhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRSYW5nZXNbMF07XG59XG5cbmZ1bmN0aW9uICRjYW5SZW1vdmVUZXh0KGFuY2hvck5vZGUsIGZvY3VzTm9kZSkge1xuICByZXR1cm4gYW5jaG9yTm9kZSAhPT0gZm9jdXNOb2RlIHx8ICRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpIHx8ICRpc0VsZW1lbnROb2RlKGZvY3VzTm9kZSkgfHwgIWFuY2hvck5vZGUuaXNUb2tlbigpIHx8ICFmb2N1c05vZGUuaXNUb2tlbigpO1xufVxuXG5mdW5jdGlvbiBpc1Bvc3NpYmx5QW5kcm9pZEtleVByZXNzKHRpbWVTdGFtcCkge1xuICByZXR1cm4gbGFzdEtleUNvZGUgPT09IDIyOSAmJiB0aW1lU3RhbXAgPCBsYXN0S2V5RG93blRpbWVTdGFtcCArIEFORFJPSURfQ09NUE9TSVRJT05fTEFURU5DWTtcbn1cblxuZnVuY3Rpb24gb25CZWZvcmVJbnB1dChldmVudCwgZWRpdG9yKSB7XG4gIGNvbnN0IGlucHV0VHlwZSA9IGV2ZW50LmlucHV0VHlwZTtcbiAgY29uc3QgdGFyZ2V0UmFuZ2UgPSBnZXRUYXJnZXRSYW5nZShldmVudCk7IC8vIFdlIGxldCB0aGUgYnJvd3NlciBkbyBpdHMgb3duIHRoaW5nIGZvciBjb21wb3NpdGlvbi5cblxuICBpZiAoaW5wdXRUeXBlID09PSAnZGVsZXRlQ29tcG9zaXRpb25UZXh0JyB8fCAvLyBJZiB3ZSdyZSBwYXN0aW5nIGluIEZGLCB3ZSBzaG91bGRuJ3QgZ2V0IHRoaXMgZXZlbnRcbiAgLy8gYXMgdGhlIGBwYXN0ZWAgZXZlbnQgc2hvdWxkIGhhdmUgdHJpZ2dlcmVkLCB1bmxlc3MgdGhlXG4gIC8vIHVzZXIgaGFzIGRvbS5ldmVudC5jbGlwYm9hcmRldmVudHMuZW5hYmxlZCBkaXNhYmxlZCBpblxuICAvLyBhYm91dDpjb25maWcuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byBwcm9jZXNzIHRoZVxuICAvLyBwYXN0ZWQgY29udGVudCBpbiB0aGUgRE9NIG11dGF0aW9uIHBoYXNlLlxuICBJU19GSVJFRk9YICYmIGlzRmlyZWZveENsaXBib2FyZEV2ZW50cyhlZGl0b3IpKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGlucHV0VHlwZSA9PT0gJ2luc2VydENvbXBvc2l0aW9uVGV4dCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB1cGRhdGVFZGl0b3IoZWRpdG9yLCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGlucHV0VHlwZSA9PT0gJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCcpIHtcbiAgICAgIGlmIChzZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgLy8gVXNlIHByZXZpb3VzIHNlbGVjdGlvblxuICAgICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgICRzZXRTZWxlY3Rpb24ocHJldlNlbGVjdGlvbi5jbG9uZSgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgLy8gVXNlZCBmb3IgaGFuZGxpbmcgYmFja3NwYWNlIGluIEFuZHJvaWQuXG4gICAgICAgIGlmIChpc1Bvc3NpYmx5QW5kcm9pZEtleVByZXNzKGV2ZW50LnRpbWVTdGFtcCkgJiYgZWRpdG9yLmlzQ29tcG9zaW5nKCkgJiYgc2VsZWN0aW9uLmFuY2hvci5rZXkgPT09IHNlbGVjdGlvbi5mb2N1cy5rZXkpIHtcbiAgICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG4gICAgICAgICAgbGFzdEtleURvd25UaW1lU3RhbXAgPSAwOyAvLyBGaXhlcyBhbiBBbmRyb2lkIGJ1ZyB3aGVyZSBzZWxlY3Rpb24gZmxpY2tlcnMgd2hlbiBiYWNrc3BhY2luZ1xuXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB1cGRhdGVFZGl0b3IoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIEFORFJPSURfQ09NUE9TSVRJT05fTEFURU5DWSk7XG5cbiAgICAgICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgYW5jaG9yTm9kZS5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5mb3JtYXQgPSBhbmNob3JOb2RlLmdldEZvcm1hdCgpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLnN0eWxlID0gYW5jaG9yTm9kZS5nZXRTdHlsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7IC8vIFRoaXMgcmVwcmVzZW50cyB0aGUgY2FzZSB3aGVuIHR3byBiZWZvcmVpbnB1dCBldmVudHMgYXJlIHRyaWdnZXJlZCBhdCB0aGUgc2FtZSB0aW1lICh3aXRob3V0IGFcbiAgICAvLyBmdWxsIGV2ZW50IGxvb3AgZW5kaW5nIGF0IGlucHV0KS4gVGhpcyBoYXBwZW5zIHdpdGggTWFjT1Mgd2l0aCB0aGUgZGVmYXVsdCBrZXlib2FyZCBzZXR0aW5ncyxcbiAgICAvLyBhIGNvbWJpbmF0aW9uIG9mIGF1dG9jb3JyZWN0aW9uICsgYXV0b2NhcGl0YWxpemF0aW9uLlxuICAgIC8vIEhhdmluZyBMZXhpY2FsIHJ1biBldmVyeXRoaW5nIGluIGNvbnRyb2xsZWQgbW9kZSB3b3VsZCBmaXggdGhlIGlzc3VlIHdpdGhvdXQgYWRkaXRpb25hbCBjb2RlXG4gICAgLy8gYnV0IHRoaXMgd291bGQga2lsbCB0aGUgbWFzc2l2ZSBwZXJmb3JtYW5jZSB3aW4gZnJvbSB0aGUgbW9zdCBjb21tb24gdHlwaW5nIGV2ZW50LlxuICAgIC8vIEFsdGVybmF0aXZlbHksIHdoZW4gdGhpcyBoYXBwZW5zIHdlIGNhbiBwcmVtYXR1cmVseSB1cGRhdGUgb3VyIEVkaXRvclN0YXRlIGJhc2VkIG9uIHRoZSBET01cbiAgICAvLyBjb250ZW50LCBhIGpvYiB0aGF0IHdvdWxkIHVzdWFsbHkgYmUgdGhlIGlucHV0IGV2ZW50J3MgcmVzcG9uc2liaWxpdHkuXG5cbiAgICBpZiAodW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEgIT09IG51bGwpIHtcbiAgICAgICR1cGRhdGVTZWxlY3RlZFRleHRGcm9tRE9NKGZhbHNlLCBlZGl0b3IsIHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoKCFzZWxlY3Rpb24uZGlydHkgfHwgdW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEgIT09IG51bGwpICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmICEkaXNSb290Tm9kZShzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSkgJiYgdGFyZ2V0UmFuZ2UgIT09IG51bGwpIHtcbiAgICAgIHNlbGVjdGlvbi5hcHBseURPTVJhbmdlKHRhcmdldFJhbmdlKTtcbiAgICB9XG5cbiAgICB1bnByb2Nlc3NlZEJlZm9yZUlucHV0RGF0YSA9IG51bGw7XG4gICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG5cbiAgICBpZiAoaW5wdXRUeXBlID09PSAnaW5zZXJ0VGV4dCcgfHwgaW5wdXRUeXBlID09PSAnaW5zZXJ0VHJhbnNwb3NlJykge1xuICAgICAgaWYgKGRhdGEgPT09ICdcXG4nKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIElOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gRE9VQkxFX0xJTkVfQlJFQUspIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhID09IG51bGwgJiYgZXZlbnQuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIC8vIEdldHMgYXJvdW5kIGEgU2FmYXJpIHRleHQgcmVwbGFjZW1lbnQgYnVnLlxuICAgICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2VsZWN0aW9uLmluc2VydFJhd1RleHQodGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgIT0gbnVsbCAmJiAkc2hvdWxkUHJldmVudERlZmF1bHRBbmRJbnNlcnRUZXh0KHNlbGVjdGlvbiwgdGFyZ2V0UmFuZ2UsIGRhdGEsIGV2ZW50LnRpbWVTdGFtcCwgdHJ1ZSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhID0gZGF0YTtcbiAgICAgIH1cblxuICAgICAgbGFzdEJlZm9yZUlucHV0SW5zZXJ0VGV4dFRpbWVTdGFtcCA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBjYXJyeWluZyBvdXRcbiAgICAvLyB0aGUgaW5wdXQgZXZlbnQsIHNvIHdlIGNhbiBjb250cm9sIHRoZVxuICAgIC8vIG91dHB1dC5cblxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIHN3aXRjaCAoaW5wdXRUeXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRGcm9tWWFuayc6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tRHJvcCc6XG4gICAgICBjYXNlICdpbnNlcnRSZXBsYWNlbWVudFRleHQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbUNvbXBvc2l0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvblxuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRMaW5lQnJlYWsnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVXNlZCBmb3IgQW5kcm9pZFxuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0UGFyYWdyYXBoJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFVzZWQgZm9yIEFuZHJvaWRcbiAgICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7IC8vIFNhZmFyaSBkb2VzIG5vdCBwcm92aWRlIHRoZSB0eXBlIFwiaW5zZXJ0TGluZUJyZWFrXCIuXG4gICAgICAgICAgLy8gU28gaW5zdGVhZCwgd2UgbmVlZCB0byBpbmZlciBpdCBmcm9tIHRoZSBrZXlib2FyZCBldmVudC5cbiAgICAgICAgICAvLyBXZSBkbyBub3QgYXBwbHkgdGhpcyBsb2dpYyB0byBpT1MgdG8gYWxsb3cgbmV3bGluZSBhdXRvLWNhcGl0YWxpemF0aW9uXG4gICAgICAgICAgLy8gd29yayB3aXRob3V0IGNyZWF0aW5nIGxpbmVicmVha3Mgd2hlbiBwcmVzc2luZyBFbnRlclxuXG4gICAgICAgICAgaWYgKGlzSW5zZXJ0TGluZUJyZWFrICYmICFJU19JT1MpIHtcbiAgICAgICAgICAgIGlzSW5zZXJ0TGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRGcm9tUGFzdGUnOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbVBhc3RlQXNRdW90YXRpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUEFTVEVfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q29tcG9zaXRpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCRjYW5SZW1vdmVUZXh0KGFuY2hvck5vZGUsIGZvY3VzTm9kZSkpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFJFTU9WRV9URVhUX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVCeURyYWcnOlxuICAgICAgY2FzZSAnZGVsZXRlQnlDdXQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUkVNT1ZFX1RFWFRfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlV29yZEJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9XT1JEX0NPTU1BTkQsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9XT1JEX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVIYXJkTGluZUJhY2t3YXJkJzpcbiAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0xJTkVfQ09NTUFORCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEZvcndhcmQnOlxuICAgICAgY2FzZSAnZGVsZXRlSGFyZExpbmVGb3J3YXJkJzpcbiAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lRm9yd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfTElORV9DT01NQU5ELCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZm9ybWF0U3RyaWtlVGhyb3VnaCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBGT1JNQVRfVEVYVF9DT01NQU5ELCAnc3RyaWtldGhyb3VnaCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2Zvcm1hdEJvbGQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9STUFUX1RFWFRfQ09NTUFORCwgJ2JvbGQnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdmb3JtYXRJdGFsaWMnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9STUFUX1RFWFRfQ09NTUFORCwgJ2l0YWxpYycpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2Zvcm1hdFVuZGVybGluZSc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBGT1JNQVRfVEVYVF9DT01NQU5ELCAndW5kZXJsaW5lJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaGlzdG9yeVVuZG8nOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgVU5ET19DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2hpc3RvcnlSZWRvJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFJFRE9fQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gb25JbnB1dChldmVudCwgZWRpdG9yKSB7XG4gIC8vIFdlIGRvbid0IHdhbnQgdGhlIG9uSW5wdXQgdG8gYnViYmxlLCBpbiB0aGUgY2FzZSBvZiBuZXN0ZWQgZWRpdG9ycy5cbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgY29uc3QgdGFyZ2V0UmFuZ2UgPSBnZXRUYXJnZXRSYW5nZShldmVudCk7XG5cbiAgICBpZiAoZGF0YSAhPSBudWxsICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgJHNob3VsZFByZXZlbnREZWZhdWx0QW5kSW5zZXJ0VGV4dChzZWxlY3Rpb24sIHRhcmdldFJhbmdlLCBkYXRhLCBldmVudC50aW1lU3RhbXAsIGZhbHNlKSkge1xuICAgICAgLy8gR2l2ZW4gd2UncmUgb3Zlci1yaWRpbmcgdGhlIGRlZmF1bHQgYmVoYXZpb3IsIHdlIHdpbGwgbmVlZFxuICAgICAgLy8gdG8gZW5zdXJlIHRvIGRpc2FibGUgY29tcG9zaXRpb24gYmVmb3JlIGRpc3BhdGNoaW5nIHRoZVxuICAgICAgLy8gaW5zZXJ0VGV4dCBjb21tYW5kIGZvciB3aGVuIGNoYW5naW5nIHRoZSBzZXF1ZW5jZSBmb3IgRkYuXG4gICAgICBpZiAoaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24pIHtcbiAgICAgICAgb25Db21wb3NpdGlvbkVuZEltcGwoZWRpdG9yLCBkYXRhKTtcbiAgICAgICAgaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24gPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcblxuICAgICAgaWYgKGRvbVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9mZnNldCA9IGFuY2hvci5vZmZzZXQ7IC8vIElmIHRoZSBjb250ZW50IGlzIHRoZSBzYW1lIGFzIGluc2VydGVkLCB0aGVuIGRvbid0IGRpc3BhdGNoIGFuIGluc2VydGlvbi5cbiAgICAgIC8vIEdpdmVuIG9uSW5wdXQgZG9lc24ndCB0YWtlIHRoZSBjdXJyZW50IHNlbGVjdGlvbiAoaXQgdXNlcyB0aGUgcHJldmlvdXMpXG4gICAgICAvLyB3ZSBjYW4gY29tcGFyZSB0aGF0IGFnYWluc3Qgd2hhdCB0aGUgRE9NIGN1cnJlbnRseSBzYXlzLlxuXG4gICAgICBpZiAoIUNBTl9VU0VfQkVGT1JFX0lOUFVUIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8ICEkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSB8fCBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSA9PT0gbnVsbCB8fCBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCkuc2xpY2UoMCwgb2Zmc2V0KSArIGRhdGEgKyBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCkuc2xpY2Uob2Zmc2V0ICsgc2VsZWN0aW9uLmZvY3VzLm9mZnNldCkgIT09IGdldEFuY2hvclRleHRGcm9tRE9NKGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlKSkge1xuICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIGRhdGEpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0ZXh0TGVuZ3RoID0gZGF0YS5sZW5ndGg7IC8vIEFub3RoZXIgaGFjayBmb3IgRkYsIGFzIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgSU1FIGlzIHN0aWxsXG4gICAgICAvLyBvcGVuLCBldmVuIHRob3VnaCBjb21wb3NpdGlvbmVuZCBoYXMgYWxyZWFkeSBmaXJlZCAoc2lnaCkuXG5cbiAgICAgIGlmIChJU19GSVJFRk9YICYmIHRleHRMZW5ndGggPiAxICYmIGV2ZW50LmlucHV0VHlwZSA9PT0gJ2luc2VydENvbXBvc2l0aW9uVGV4dCcgJiYgIWVkaXRvci5pc0NvbXBvc2luZygpKSB7XG4gICAgICAgIHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0IC09IHRleHRMZW5ndGg7XG4gICAgICB9IC8vIFRoaXMgZW5zdXJlcyBjb25zaXN0ZW5jeSBvbiBBbmRyb2lkLlxuXG5cbiAgICAgIGlmICghSVNfU0FGQVJJICYmICFJU19JT1MgJiYgIUlTX0FQUExFX1dFQktJVCAmJiBlZGl0b3IuaXNDb21wb3NpbmcoKSkge1xuICAgICAgICBsYXN0S2V5RG93blRpbWVTdGFtcCA9IDA7XG4gICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hhcmFjdGVyRGF0YSA9IGRhdGEgIT09IG51bGwgPyBkYXRhIDogdW5kZWZpbmVkO1xuICAgICAgJHVwZGF0ZVNlbGVjdGVkVGV4dEZyb21ET00oZmFsc2UsIGVkaXRvciwgY2hhcmFjdGVyRGF0YSk7IC8vIG9uSW5wdXQgYWx3YXlzIGZpcmVzIGFmdGVyIG9uQ29tcG9zaXRpb25FbmQgZm9yIEZGLlxuXG4gICAgICBpZiAoaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24pIHtcbiAgICAgICAgb25Db21wb3NpdGlvbkVuZEltcGwoZWRpdG9yLCBkYXRhIHx8IHVuZGVmaW5lZCk7XG4gICAgICAgIGlzRmlyZWZveEVuZGluZ0NvbXBvc2l0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSAvLyBBbHNvIGZsdXNoIGFueSBvdGhlciBtdXRhdGlvbnMgdGhhdCBtaWdodCBoYXZlIG9jY3VycmVkXG4gICAgLy8gc2luY2UgdGhlIGNoYW5nZS5cblxuXG4gICAgJGZsdXNoTXV0YXRpb25zKCk7XG4gIH0pO1xuICB1bnByb2Nlc3NlZEJlZm9yZUlucHV0RGF0YSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChldmVudCwgZWRpdG9yKSB7XG4gIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAhZWRpdG9yLmlzQ29tcG9zaW5nKCkpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICBjb25zdCBub2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICAkc2V0Q29tcG9zaXRpb25LZXkoYW5jaG9yLmtleSk7XG5cbiAgICAgIGlmICggLy8gSWYgaXQgaGFzIGJlZW4gMzBtcyBzaW5jZSB0aGUgbGFzdCBrZXlkb3duLCB0aGVuIHdlIHNob3VsZFxuICAgICAgLy8gYXBwbHkgdGhlIGVtcHR5IHNwYWNlIGhldXJpc3RpYy4gV2UgY2FuJ3QgZG8gdGhpcyBmb3IgU2FmYXJpLFxuICAgICAgLy8gYXMgdGhlIGtleWRvd24gZmlyZXMgYWZ0ZXIgY29tcG9zaXRpb24gc3RhcnQuXG4gICAgICBldmVudC50aW1lU3RhbXAgPCBsYXN0S2V5RG93blRpbWVTdGFtcCArIEFORFJPSURfQ09NUE9TSVRJT05fTEFURU5DWSB8fCAvLyBGRiBoYXMgaXNzdWVzIGFyb3VuZCBjb21wb3NpbmcgbXVsdGlieXRlIGNoYXJhY3RlcnMsIHNvIHdlIGFsc29cbiAgICAgIC8vIG5lZWQgdG8gaW52b2tlIHRoZSBlbXB0eSBzcGFjZSBoZXVyaXN0aWMgYmVsb3cuXG4gICAgICBhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCBub2RlLmdldEZvcm1hdCgpICE9PSBzZWxlY3Rpb24uZm9ybWF0IHx8IG5vZGUuZ2V0U3R5bGUoKSAhPT0gc2VsZWN0aW9uLnN0eWxlKSB7XG4gICAgICAgIC8vIFdlIGluc2VydCBhIHplcm8gd2lkdGggY2hhcmFjdGVyLCByZWFkeSBmb3IgdGhlIGNvbXBvc2l0aW9uXG4gICAgICAgIC8vIHRvIGdldCBpbnNlcnRlZCBpbnRvIHRoZSBuZXcgbm9kZSB3ZSBjcmVhdGUuIElmXG4gICAgICAgIC8vIHdlIGRvbid0IGRvIHRoaXMsIFNhZmFyaSB3aWxsIGZhaWwgb24gdXMgYmVjYXVzZVxuICAgICAgICAvLyB0aGVyZSBpcyBubyB0ZXh0IG5vZGUgbWF0Y2hpbmcgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBDT01QT1NJVElPTl9TVEFSVF9DSEFSKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kSW1wbChlZGl0b3IsIGRhdGEpIHtcbiAgY29uc3QgY29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7IC8vIEhhbmRsZSB0ZXJtaW5hdGlvbiBvZiBjb21wb3NpdGlvbi5cblxuICBpZiAoY29tcG9zaXRpb25LZXkgIT09IG51bGwgJiYgZGF0YSAhPSBudWxsKSB7XG4gICAgLy8gQ29tcG9zaXRpb24gY2FuIHNvbWV0aW1lcyBtb3ZlIHRvIGFuIGFkamFjZW50IERPTSBub2RlIHdoZW4gYmFja3NwYWNpbmcuXG4gICAgLy8gU28gY2hlY2sgZm9yIHRoZSBlbXB0eSBjYXNlLlxuICAgIGlmIChkYXRhID09PSAnJykge1xuICAgICAgY29uc3Qgbm9kZSA9ICRnZXROb2RlQnlLZXkoY29tcG9zaXRpb25LZXkpO1xuICAgICAgY29uc3QgdGV4dE5vZGUgPSBnZXRET01UZXh0Tm9kZShlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGNvbXBvc2l0aW9uS2V5KSk7XG5cbiAgICAgIGlmICh0ZXh0Tm9kZSAhPT0gbnVsbCAmJiB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IG51bGwgJiYgJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgICAgJHVwZGF0ZVRleHROb2RlRnJvbURPTUNvbnRlbnQobm9kZSwgdGV4dE5vZGUubm9kZVZhbHVlLCBudWxsLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ29tcG9zaXRpb24gY2FuIHNvbWV0aW1lcyBiZSB0aGF0IG9mIGEgbmV3IGxpbmUuIEluIHdoaWNoIGNhc2UsIHdlIG5lZWQgdG9cbiAgICAvLyBoYW5kbGUgdGhhdCBhY2NvcmRpbmdseS5cblxuXG4gICAgaWYgKGRhdGFbZGF0YS5sZW5ndGggLSAxXSA9PT0gJ1xcbicpIHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIGEgbGluZSBicmVhaywgd2UgYWxzbyBuZWVkIHRvIGluc2VydFxuICAgICAgICAvLyBhIGxpbmUgYnJlYWsuXG4gICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldChmb2N1cy5rZXksIGZvY3VzLm9mZnNldCwgZm9jdXMudHlwZSk7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9FTlRFUl9DT01NQU5ELCBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICR1cGRhdGVTZWxlY3RlZFRleHRGcm9tRE9NKHRydWUsIGVkaXRvciwgZGF0YSk7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQoZXZlbnQsIGVkaXRvcikge1xuICAvLyBGaXJlZm94IGZpcmVzIG9uQ29tcG9zaXRpb25FbmQgYmVmb3JlIG9uSW5wdXQsIGJ1dCBDaHJvbWUvV2Via2l0LFxuICAvLyBmaXJlIG9uSW5wdXQgYmVmb3JlIG9uQ29tcG9zaXRpb25FbmQuIFRvIGVuc3VyZSB0aGUgc2VxdWVuY2Ugd29ya3NcbiAgLy8gbGlrZSBDaHJvbWUvV2Via2l0IHdlIHVzZSB0aGUgaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24gZmxhZyB0b1xuICAvLyBkZWZlciBoYW5kbGluZyBvZiBvbkNvbXBvc2l0aW9uRW5kIGluIEZpcmVmb3ggdGlsbCB3ZSBoYXZlIHByb2Nlc3NlZFxuICAvLyB0aGUgbG9naWMgaW4gb25JbnB1dC5cbiAgaWYgKElTX0ZJUkVGT1gpIHtcbiAgICBpc0ZpcmVmb3hFbmRpbmdDb21wb3NpdGlvbiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgICAgb25Db21wb3NpdGlvbkVuZEltcGwoZWRpdG9yLCBldmVudC5kYXRhKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbktleURvd24oZXZlbnQsIGVkaXRvcikge1xuICBsYXN0S2V5RG93blRpbWVTdGFtcCA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgbGFzdEtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuXG4gIGlmIChlZGl0b3IuaXNDb21wb3NpbmcoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBrZXlDb2RlLFxuICAgIHNoaWZ0S2V5LFxuICAgIGN0cmxLZXksXG4gICAgbWV0YUtleSxcbiAgICBhbHRLZXlcbiAgfSA9IGV2ZW50O1xuXG4gIGlmIChkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfRE9XTl9DT01NQU5ELCBldmVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNNb3ZlRm9yd2FyZChrZXlDb2RlLCBjdHJsS2V5LCBhbHRLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc01vdmVUb0VuZChrZXlDb2RlLCBjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIE1PVkVfVE9fRU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNNb3ZlQmFja3dhcmQoa2V5Q29kZSwgY3RybEtleSwgYWx0S2V5LCBtZXRhS2V5KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc01vdmVUb1N0YXJ0KGtleUNvZGUsIGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgTU9WRV9UT19TVEFSVCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzTW92ZVVwKGtleUNvZGUsIGN0cmxLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0FSUk9XX1VQX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc01vdmVEb3duKGtleUNvZGUsIGN0cmxLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzTGluZUJyZWFrKGtleUNvZGUsIHNoaWZ0S2V5KSkge1xuICAgIGlzSW5zZXJ0TGluZUJyZWFrID0gdHJ1ZTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfRU5URVJfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzU3BhY2Uoa2V5Q29kZSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfU1BBQ0VfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzT3BlbkxpbmVCcmVhayhrZXlDb2RlLCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaXNJbnNlcnRMaW5lQnJlYWsgPSB0cnVlO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIElOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQsIHRydWUpO1xuICB9IGVsc2UgaWYgKGlzUGFyYWdyYXBoKGtleUNvZGUsIHNoaWZ0S2V5KSkge1xuICAgIGlzSW5zZXJ0TGluZUJyZWFrID0gZmFsc2U7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0VOVEVSX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc0RlbGV0ZUJhY2t3YXJkKGtleUNvZGUsIGFsdEtleSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICBpZiAoaXNCYWNrc3BhY2Uoa2V5Q29kZSkpIHtcbiAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9CQUNLU1BBQ0VfQ09NTUFORCwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCB0cnVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFc2NhcGUoa2V5Q29kZSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfRVNDQVBFX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc0RlbGV0ZUZvcndhcmQoa2V5Q29kZSwgY3RybEtleSwgc2hpZnRLZXksIGFsdEtleSwgbWV0YUtleSkpIHtcbiAgICBpZiAoaXNEZWxldGUoa2V5Q29kZSkpIHtcbiAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9ERUxFVEVfQ09NTUFORCwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBmYWxzZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRGVsZXRlV29yZEJhY2t3YXJkKGtleUNvZGUsIGFsdEtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9XT1JEX0NPTU1BTkQsIHRydWUpO1xuICB9IGVsc2UgaWYgKGlzRGVsZXRlV29yZEZvcndhcmQoa2V5Q29kZSwgYWx0S2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX1dPUkRfQ09NTUFORCwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKGlzRGVsZXRlTGluZUJhY2t3YXJkKGtleUNvZGUsIG1ldGFLZXkpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfTElORV9DT01NQU5ELCB0cnVlKTtcbiAgfSBlbHNlIGlmIChpc0RlbGV0ZUxpbmVGb3J3YXJkKGtleUNvZGUsIG1ldGFLZXkpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfTElORV9DT01NQU5ELCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAoaXNCb2xkKGtleUNvZGUsIGFsdEtleSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICdib2xkJyk7XG4gIH0gZWxzZSBpZiAoaXNVbmRlcmxpbmUoa2V5Q29kZSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9STUFUX1RFWFRfQ09NTUFORCwgJ3VuZGVybGluZScpO1xuICB9IGVsc2UgaWYgKGlzSXRhbGljKGtleUNvZGUsIGFsdEtleSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICdpdGFsaWMnKTtcbiAgfSBlbHNlIGlmIChpc1RhYihrZXlDb2RlLCBhbHRLZXksIGN0cmxLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX1RBQl9DT01NQU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNVbmRvKGtleUNvZGUsIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgVU5ET19DT01NQU5ELCB1bmRlZmluZWQpO1xuICB9IGVsc2UgaWYgKGlzUmVkbyhrZXlDb2RlLCBzaGlmdEtleSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFJFRE9fQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gZWRpdG9yLl9lZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuXG4gICAgaWYgKCRpc05vZGVTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikpIHtcbiAgICAgIGlmIChpc0NvcHkoa2V5Q29kZSwgc2hpZnRLZXksIG1ldGFLZXksIGN0cmxLZXkpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPUFlfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc0N1dChrZXlDb2RlLCBzaGlmdEtleSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ1VUX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTZWxlY3RBbGwoa2V5Q29kZSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgJHNlbGVjdEFsbCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gRkYgZG9lcyBpdCB3ZWxsIChubyBuZWVkIHRvIG92ZXJyaWRlIGJlaGF2aW9yKVxuXG4gICAgfSBlbHNlIGlmICghSVNfRklSRUZPWCAmJiBpc1NlbGVjdEFsbChrZXlDb2RlLCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAkc2VsZWN0QWxsKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNNb2RpZmllcihjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9NT0RJRklFUl9DT01NQU5ELCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEVsZW1lbnRSZW1vdmVIYW5kbGVzKHJvb3RFbGVtZW50KSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gIGxldCBldmVudEhhbmRsZXMgPSByb290RWxlbWVudC5fX2xleGljYWxFdmVudEhhbmRsZXM7XG5cbiAgaWYgKGV2ZW50SGFuZGxlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRIYW5kbGVzID0gW107IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG5cbiAgICByb290RWxlbWVudC5fX2xleGljYWxFdmVudEhhbmRsZXMgPSBldmVudEhhbmRsZXM7XG4gIH1cblxuICByZXR1cm4gZXZlbnRIYW5kbGVzO1xufSAvLyBNYXBwaW5nIHJvb3QgZWRpdG9ycyB0byB0aGVpciBhY3RpdmUgbmVzdGVkIGVkaXRvcnMsIGNvbnRhaW5zIG5lc3RlZCBlZGl0b3JzXG4vLyBtYXBwaW5nIG9ubHksIHNvIGlmIHJvb3QgZWRpdG9yIGlzIHNlbGVjdGVkIG1hcCB3aWxsIGhhdmUgbm8gcmVmZXJlbmNlIHRvIGZyZWUgdXAgbWVtb3J5XG5cblxuY29uc3QgYWN0aXZlTmVzdGVkRWRpdG9yc01hcCA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gb25Eb2N1bWVudFNlbGVjdGlvbkNoYW5nZShldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIGNvbnN0IHRhcmdldFdpbmRvdyA9IHRhcmdldCA9PSBudWxsID8gbnVsbCA6IHRhcmdldC5ub2RlVHlwZSA9PT0gOSA/IHRhcmdldC5kZWZhdWx0VmlldyA6IHRhcmdldC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24odGFyZ2V0V2luZG93KTtcblxuICBpZiAoZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbmV4dEFjdGl2ZUVkaXRvciA9IGdldE5lYXJlc3RFZGl0b3JGcm9tRE9NTm9kZShkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSk7XG5cbiAgaWYgKG5leHRBY3RpdmVFZGl0b3IgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNTZWxlY3Rpb25DaGFuZ2VGcm9tTW91c2VEb3duKSB7XG4gICAgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tTW91c2VEb3duID0gZmFsc2U7XG4gICAgdXBkYXRlRWRpdG9yKG5leHRBY3RpdmVFZGl0b3IsICgpID0+IHtcbiAgICAgIGNvbnN0IGxhc3RTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgICAgIGNvbnN0IGRvbUFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcblxuICAgICAgaWYgKGRvbUFuY2hvck5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlVHlwZSA9IGRvbUFuY2hvck5vZGUubm9kZVR5cGU7IC8vIElmIHRoZSB1c2VyIGlzIGF0dGVtcHRpbmcgdG8gY2xpY2sgc2VsZWN0aW9uIGJhY2sgb250byB0ZXh0LCB0aGVuXG4gICAgICAvLyB3ZSBzaG91bGQgYXR0ZW1wdCBjcmVhdGUgYSByYW5nZSBzZWxlY3Rpb24uXG4gICAgICAvLyBXaGVuIHdlIGNsaWNrIG9uIGFuIGVtcHR5IHBhcmFncmFwaCBub2RlIG9yIHRoZSBlbmQgb2YgYSBwYXJhZ3JhcGggdGhhdCBlbmRzXG4gICAgICAvLyB3aXRoIGFuIGltYWdlL3BvbGwsIHRoZSBub2RlVHlwZSB3aWxsIGJlIEVMRU1FTlRfTk9ERVxuXG4gICAgICBpZiAobm9kZVR5cGUgIT09IERPTV9FTEVNRU5UX1RZUEUgJiYgbm9kZVR5cGUgIT09IERPTV9URVhUX1RZUEUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBpbnRlcm5hbENyZWF0ZVJhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24sIGRvbVNlbGVjdGlvbiwgbmV4dEFjdGl2ZUVkaXRvcik7XG4gICAgICAkc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XG4gICAgfSk7XG4gIH0gLy8gV2hlbiBlZGl0b3IgcmVjZWl2ZXMgc2VsZWN0aW9uIGNoYW5nZSBldmVudCwgd2UncmUgY2hlY2tpbmcgaWZcbiAgLy8gaXQgaGFzIGFueSBzaWJsaW5nIGVkaXRvcnMgKHdpdGhpbiBzYW1lIHBhcmVudCBlZGl0b3IpIHRoYXQgd2VyZSBhY3RpdmVcbiAgLy8gYmVmb3JlLCBhbmQgdHJpZ2dlciBzZWxlY3Rpb24gY2hhbmdlIG9uIGl0IHRvIG51bGxpZnkgc2VsZWN0aW9uLlxuXG5cbiAgY29uc3QgZWRpdG9ycyA9IGdldEVkaXRvcnNUb1Byb3BhZ2F0ZShuZXh0QWN0aXZlRWRpdG9yKTtcbiAgY29uc3Qgcm9vdEVkaXRvciA9IGVkaXRvcnNbZWRpdG9ycy5sZW5ndGggLSAxXTtcbiAgY29uc3Qgcm9vdEVkaXRvcktleSA9IHJvb3RFZGl0b3IuX2tleTtcbiAgY29uc3QgYWN0aXZlTmVzdGVkRWRpdG9yID0gYWN0aXZlTmVzdGVkRWRpdG9yc01hcC5nZXQocm9vdEVkaXRvcktleSk7XG4gIGNvbnN0IHByZXZBY3RpdmVFZGl0b3IgPSBhY3RpdmVOZXN0ZWRFZGl0b3IgfHwgcm9vdEVkaXRvcjtcblxuICBpZiAocHJldkFjdGl2ZUVkaXRvciAhPT0gbmV4dEFjdGl2ZUVkaXRvcikge1xuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKGRvbVNlbGVjdGlvbiwgcHJldkFjdGl2ZUVkaXRvciwgZmFsc2UpO1xuICB9XG5cbiAgb25TZWxlY3Rpb25DaGFuZ2UoZG9tU2VsZWN0aW9uLCBuZXh0QWN0aXZlRWRpdG9yLCB0cnVlKTsgLy8gSWYgbmV3bHkgc2VsZWN0ZWQgZWRpdG9yIGlzIG5lc3RlZCwgdGhlbiBhZGQgaXQgdG8gdGhlIG1hcCwgY2xlYW4gbWFwIG90aGVyd2lzZVxuXG4gIGlmIChuZXh0QWN0aXZlRWRpdG9yICE9PSByb290RWRpdG9yKSB7XG4gICAgYWN0aXZlTmVzdGVkRWRpdG9yc01hcC5zZXQocm9vdEVkaXRvcktleSwgbmV4dEFjdGl2ZUVkaXRvcik7XG4gIH0gZWxzZSBpZiAoYWN0aXZlTmVzdGVkRWRpdG9yKSB7XG4gICAgYWN0aXZlTmVzdGVkRWRpdG9yc01hcC5kZWxldGUocm9vdEVkaXRvcktleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcExleGljYWxQcm9wYWdhdGlvbihldmVudCkge1xuICAvLyBXZSBhdHRhY2ggYSBzcGVjaWFsIHByb3BlcnR5IHRvIGVuc3VyZSB0aGUgc2FtZSBldmVudCBkb2Vzbid0IHJlLWZpcmVcbiAgLy8gZm9yIHBhcmVudCBlZGl0b3JzLlxuICAvLyBAdHMtaWdub3JlXG4gIGV2ZW50Ll9sZXhpY2FsSGFuZGxlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGhhc1N0b3BwZWRMZXhpY2FsUHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBzdG9wcGVkID0gZXZlbnQuX2xleGljYWxIYW5kbGVkID09PSB0cnVlO1xuICByZXR1cm4gc3RvcHBlZDtcbn1cblxuZnVuY3Rpb24gYWRkUm9vdEVsZW1lbnRFdmVudHMocm9vdEVsZW1lbnQsIGVkaXRvcikge1xuICAvLyBXZSBvbmx5IHdhbnQgdG8gaGF2ZSBhIHNpbmdsZSBnbG9iYWwgc2VsZWN0aW9uY2hhbmdlIGV2ZW50IGhhbmRsZXIsIHNoYXJlZFxuICAvLyBiZXR3ZWVuIGFsbCBlZGl0b3IgaW5zdGFuY2VzLlxuICBpZiAocm9vdEVsZW1lbnRzUmVnaXN0ZXJlZCA9PT0gMCkge1xuICAgIGNvbnN0IGRvYyA9IHJvb3RFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIG9uRG9jdW1lbnRTZWxlY3Rpb25DaGFuZ2UpO1xuICB9XG5cbiAgcm9vdEVsZW1lbnRzUmVnaXN0ZXJlZCsrOyAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuXG4gIHJvb3RFbGVtZW50Ll9fbGV4aWNhbEVkaXRvciA9IGVkaXRvcjtcbiAgY29uc3QgcmVtb3ZlSGFuZGxlcyA9IGdldFJvb3RFbGVtZW50UmVtb3ZlSGFuZGxlcyhyb290RWxlbWVudCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb290RWxlbWVudEV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFtldmVudE5hbWUsIG9uRXZlbnRdID0gcm9vdEVsZW1lbnRFdmVudHNbaV07XG4gICAgY29uc3QgZXZlbnRIYW5kbGVyID0gdHlwZW9mIG9uRXZlbnQgPT09ICdmdW5jdGlvbicgPyBldmVudCA9PiB7XG4gICAgICBpZiAoaGFzU3RvcHBlZExleGljYWxQcm9wYWdhdGlvbihldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzdG9wTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KTtcblxuICAgICAgaWYgKGVkaXRvci5pc0VkaXRhYmxlKCkpIHtcbiAgICAgICAgb25FdmVudChldmVudCwgZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9IDogZXZlbnQgPT4ge1xuICAgICAgaWYgKGhhc1N0b3BwZWRMZXhpY2FsUHJvcGFnYXRpb24oZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3RvcExleGljYWxQcm9wYWdhdGlvbihldmVudCk7XG5cbiAgICAgIGlmIChlZGl0b3IuaXNFZGl0YWJsZSgpKSB7XG4gICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgY2FzZSAnY3V0JzpcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDVVRfQ09NTUFORCwgZXZlbnQpO1xuXG4gICAgICAgICAgY2FzZSAnY29weSc6XG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ09QWV9DT01NQU5ELCBldmVudCk7XG5cbiAgICAgICAgICBjYXNlICdwYXN0ZSc6XG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUEFTVEVfQ09NTUFORCwgZXZlbnQpO1xuXG4gICAgICAgICAgY2FzZSAnZHJhZ3N0YXJ0JzpcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBEUkFHU1RBUlRfQ09NTUFORCwgZXZlbnQpO1xuXG4gICAgICAgICAgY2FzZSAnZHJhZ292ZXInOlxuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERSQUdPVkVSX0NPTU1BTkQsIGV2ZW50KTtcblxuICAgICAgICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERSQUdFTkRfQ09NTUFORCwgZXZlbnQpO1xuXG4gICAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPQ1VTX0NPTU1BTkQsIGV2ZW50KTtcblxuICAgICAgICAgIGNhc2UgJ2JsdXInOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQkxVUl9DT01NQU5ELCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdkcm9wJzpcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBEUk9QX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgcmVtb3ZlSGFuZGxlcy5wdXNoKCgpID0+IHtcbiAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVSb290RWxlbWVudEV2ZW50cyhyb290RWxlbWVudCkge1xuICBpZiAocm9vdEVsZW1lbnRzUmVnaXN0ZXJlZCAhPT0gMCkge1xuICAgIHJvb3RFbGVtZW50c1JlZ2lzdGVyZWQtLTsgLy8gV2Ugb25seSB3YW50IHRvIGhhdmUgYSBzaW5nbGUgZ2xvYmFsIHNlbGVjdGlvbmNoYW5nZSBldmVudCBoYW5kbGVyLCBzaGFyZWRcbiAgICAvLyBiZXR3ZWVuIGFsbCBlZGl0b3IgaW5zdGFuY2VzLlxuXG4gICAgaWYgKHJvb3RFbGVtZW50c1JlZ2lzdGVyZWQgPT09IDApIHtcbiAgICAgIGNvbnN0IGRvYyA9IHJvb3RFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgb25Eb2N1bWVudFNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICB9IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG5cblxuICBjb25zdCBlZGl0b3IgPSByb290RWxlbWVudC5fX2xleGljYWxFZGl0b3I7XG5cbiAgaWYgKGVkaXRvciAhPT0gbnVsbCAmJiBlZGl0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgIGNsZWFuQWN0aXZlTmVzdGVkRWRpdG9yc01hcChlZGl0b3IpOyAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuXG4gICAgcm9vdEVsZW1lbnQuX19sZXhpY2FsRWRpdG9yID0gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHJlbW92ZUhhbmRsZXMgPSBnZXRSb290RWxlbWVudFJlbW92ZUhhbmRsZXMocm9vdEVsZW1lbnQpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlSGFuZGxlcy5sZW5ndGg7IGkrKykge1xuICAgIHJlbW92ZUhhbmRsZXNbaV0oKTtcbiAgfSAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuXG5cbiAgcm9vdEVsZW1lbnQuX19sZXhpY2FsRXZlbnRIYW5kbGVzID0gW107XG59XG5cbmZ1bmN0aW9uIGNsZWFuQWN0aXZlTmVzdGVkRWRpdG9yc01hcChlZGl0b3IpIHtcbiAgaWYgKGVkaXRvci5fcGFyZW50RWRpdG9yICE9PSBudWxsKSB7XG4gICAgLy8gRm9yIG5lc3RlZCBlZGl0b3IgY2xlYW51cCBtYXAgaWYgdGhpcyBlZGl0b3Igd2FzIG1hcmtlZCBhcyBhY3RpdmVcbiAgICBjb25zdCBlZGl0b3JzID0gZ2V0RWRpdG9yc1RvUHJvcGFnYXRlKGVkaXRvcik7XG4gICAgY29uc3Qgcm9vdEVkaXRvciA9IGVkaXRvcnNbZWRpdG9ycy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCByb290RWRpdG9yS2V5ID0gcm9vdEVkaXRvci5fa2V5O1xuXG4gICAgaWYgKGFjdGl2ZU5lc3RlZEVkaXRvcnNNYXAuZ2V0KHJvb3RFZGl0b3JLZXkpID09PSBlZGl0b3IpIHtcbiAgICAgIGFjdGl2ZU5lc3RlZEVkaXRvcnNNYXAuZGVsZXRlKHJvb3RFZGl0b3JLZXkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBGb3IgdG9wLWxldmVsIGVkaXRvcnMgY2xlYW51cCBtYXBcbiAgICBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmRlbGV0ZShlZGl0b3IuX2tleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1NlbGVjdGlvbkNoYW5nZUZyb21ET01VcGRhdGUoKSB7XG4gIGlzU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSA9IHRydWU7XG59XG5mdW5jdGlvbiBtYXJrQ29sbGFwc2VkU2VsZWN0aW9uRm9ybWF0KGZvcm1hdCwgc3R5bGUsIG9mZnNldCwga2V5LCB0aW1lU3RhbXApIHtcbiAgY29sbGFwc2VkU2VsZWN0aW9uRm9ybWF0ID0gW2Zvcm1hdCwgc3R5bGUsIG9mZnNldCwga2V5LCB0aW1lU3RhbXBdO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiByZW1vdmVOb2RlKG5vZGVUb1JlbW92ZSwgcmVzdG9yZVNlbGVjdGlvbiwgcHJlc2VydmVFbXB0eVBhcmVudCkge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3Qga2V5ID0gbm9kZVRvUmVtb3ZlLl9fa2V5O1xuICBjb25zdCBwYXJlbnQgPSBub2RlVG9SZW1vdmUuZ2V0UGFyZW50KCk7XG5cbiAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRtYXliZU1vdmVDaGlsZHJlblNlbGVjdGlvblRvUGFyZW50KG5vZGVUb1JlbW92ZSk7XG4gIGxldCBzZWxlY3Rpb25Nb3ZlZCA9IGZhbHNlO1xuXG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHJlc3RvcmVTZWxlY3Rpb24pIHtcbiAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuXG4gICAgaWYgKGFuY2hvci5rZXkgPT09IGtleSkge1xuICAgICAgbW92ZVNlbGVjdGlvblBvaW50VG9TaWJsaW5nKGFuY2hvciwgbm9kZVRvUmVtb3ZlLCBwYXJlbnQsIG5vZGVUb1JlbW92ZS5nZXRQcmV2aW91c1NpYmxpbmcoKSwgbm9kZVRvUmVtb3ZlLmdldE5leHRTaWJsaW5nKCkpO1xuICAgICAgc2VsZWN0aW9uTW92ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChmb2N1cy5rZXkgPT09IGtleSkge1xuICAgICAgbW92ZVNlbGVjdGlvblBvaW50VG9TaWJsaW5nKGZvY3VzLCBub2RlVG9SZW1vdmUsIHBhcmVudCwgbm9kZVRvUmVtb3ZlLmdldFByZXZpb3VzU2libGluZygpLCBub2RlVG9SZW1vdmUuZ2V0TmV4dFNpYmxpbmcoKSk7XG4gICAgICBzZWxlY3Rpb25Nb3ZlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKCRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiByZXN0b3JlU2VsZWN0aW9uICYmIG5vZGVUb1JlbW92ZS5pc1NlbGVjdGVkKCkpIHtcbiAgICBub2RlVG9SZW1vdmUuc2VsZWN0UHJldmlvdXMoKTtcbiAgfVxuXG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHJlc3RvcmVTZWxlY3Rpb24gJiYgIXNlbGVjdGlvbk1vdmVkKSB7XG4gICAgLy8gRG9pbmcgdGhpcyBpcyBPKG4pIHNvIGxldHMgYXZvaWQgaXQgdW5sZXNzIHdlIG5lZWQgdG8gZG8gaXRcbiAgICBjb25zdCBpbmRleCA9IG5vZGVUb1JlbW92ZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgIHJlbW92ZUZyb21QYXJlbnQobm9kZVRvUmVtb3ZlKTtcbiAgICAkdXBkYXRlRWxlbWVudFNlbGVjdGlvbk9uQ3JlYXRlRGVsZXRlTm9kZShzZWxlY3Rpb24sIHBhcmVudCwgaW5kZXgsIC0xKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVGcm9tUGFyZW50KG5vZGVUb1JlbW92ZSk7XG4gIH1cblxuICBpZiAoIXByZXNlcnZlRW1wdHlQYXJlbnQgJiYgISRpc1Jvb3RPclNoYWRvd1Jvb3QocGFyZW50KSAmJiAhcGFyZW50LmNhbkJlRW1wdHkoKSAmJiBwYXJlbnQuaXNFbXB0eSgpKSB7XG4gICAgcmVtb3ZlTm9kZShwYXJlbnQsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICB9XG5cbiAgaWYgKHJlc3RvcmVTZWxlY3Rpb24gJiYgJGlzUm9vdE5vZGUocGFyZW50KSAmJiBwYXJlbnQuaXNFbXB0eSgpKSB7XG4gICAgcGFyZW50LnNlbGVjdEVuZCgpO1xuICB9XG59XG5jbGFzcyBMZXhpY2FsTm9kZSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IGFic3RyYWN0IGNsYXNzZXMgdW5mb3J0dW5hdGVseSwgc28gd2UgY2FuJ3QgX2ZvcmNlX1xuICAvLyBzdWJjbGFzc2VzIG9mIE5vZGUgdG8gaW1wbGVtZW50IHN0YXRpY3MuIEFsbCBzdWJjbGFzc2VzIG9mIE5vZGUgc2hvdWxkIGhhdmVcbiAgLy8gYSBzdGF0aWMgZ2V0VHlwZSBhbmQgY2xvbmUgbWV0aG9kIHRob3VnaC4gV2UgZGVmaW5lIGdldFR5cGUgYW5kIGNsb25lIGhlcmUgc28gd2UgY2FuIGNhbGwgaXRcbiAgLy8gb24gYW55ICBOb2RlLCBhbmQgd2UgdGhyb3cgdGhpcyBlcnJvciBieSBkZWZhdWx0IHNpbmNlIHRoZSBzdWJjbGFzcyBzaG91bGQgcHJvdmlkZVxuICAvLyB0aGVpciBvd24gaW1wbGVtZW50YXRpb24uXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmluZyB0eXBlIG9mIHRoaXMgbm9kZS4gRXZlcnkgbm9kZSBtdXN0XG4gICAqIGltcGxlbWVudCB0aGlzIGFuZCBpdCBNVVNUIEJFIFVOSVFVRSBhbW9uZ3N0IG5vZGVzIHJlZ2lzdGVyZWRcbiAgICogb24gdGhlIGVkaXRvci5cbiAgICpcbiAgICovXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsTm9kZTogTm9kZSAke3RoaXMubmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IC5nZXRUeXBlKCkuYCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDbG9uZXMgdGhpcyBub2RlLCBjcmVhdGluZyBhIG5ldyBub2RlIHdpdGggYSBkaWZmZXJlbnQga2V5XG4gICAqIGFuZCBhZGRpbmcgaXQgdG8gdGhlIEVkaXRvclN0YXRlIChidXQgbm90IGF0dGFjaGluZyBpdCBhbnl3aGVyZSEpLiBBbGwgbm9kZXMgbXVzdFxuICAgKiBpbXBsZW1lbnQgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqL1xuXG5cbiAgc3RhdGljIGNsb25lKF9kYXRhKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7dGhpcy5uYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgLmNsb25lKCkuYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHRoaXMuX190eXBlID0gdGhpcy5jb25zdHJ1Y3Rvci5nZXRUeXBlKCk7XG4gICAgdGhpcy5fX3BhcmVudCA9IG51bGw7XG4gICAgdGhpcy5fX3ByZXYgPSBudWxsO1xuICAgIHRoaXMuX19uZXh0ID0gbnVsbDtcbiAgICAkc2V0Tm9kZUtleSh0aGlzLCBrZXkpO1xuXG4gICAge1xuICAgICAgaWYgKHRoaXMuX190eXBlICE9PSAncm9vdCcpIHtcbiAgICAgICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgICAgIGVycm9yT25UeXBlS2xhc3NNaXNtYXRjaCh0aGlzLl9fdHlwZSwgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gR2V0dGVycyBhbmQgVHJhdmVyc2Vyc1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgdHlwZSBvZiB0aGlzIG5vZGUuXG4gICAqL1xuXG5cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3R5cGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBhIHBhdGggYmV0d2VlbiB0aGlzIG5vZGUgYW5kIHRoZSBSb290Tm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBUaGlzIGlzIGEgd2F5IG9mIGRldGVybWluaW5nIGlmIHRoZSBub2RlIGlzIFwiYXR0YWNoZWRcIiBFZGl0b3JTdGF0ZS4gVW5hdHRhY2hlZCBub2Rlc1xuICAgKiB3b24ndCBiZSByZWNvbmNpbGVkIGFuZCB3aWxsIHVsdGltYXRlbHQgYmUgY2xlYW5lZCB1cCBieSB0aGUgTGV4aWNhbCBHQy5cbiAgICovXG5cblxuICBpc0F0dGFjaGVkKCkge1xuICAgIGxldCBub2RlS2V5ID0gdGhpcy5fX2tleTtcblxuICAgIHdoaWxlIChub2RlS2V5ICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZUtleSA9PT0gJ3Jvb3QnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShub2RlS2V5KTtcblxuICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG5vZGVLZXkgPSBub2RlLl9fcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbm9kZSBpcyBjb250YWluZWQgd2l0aGluIHRoZSBwcm92aWRlZCBTZWxlY3Rpb24uLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIFJlbGllcyBvbiB0aGUgYWxnb3JpdGhtcyBpbXBsZW1lbnRlZCBpbiB7QGxpbmsgQmFzZVNlbGVjdGlvbi5nZXROb2Rlc30gdG8gZGV0ZXJtaW5lXG4gICAqIHdoYXQncyBpbmNsdWRlZC5cbiAgICpcbiAgICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gdGhhdCB3ZSB3YW50IHRvIGRldGVybWluZSBpZiB0aGUgbm9kZSBpcyBpbi5cbiAgICovXG5cblxuICBpc1NlbGVjdGVkKHNlbGVjdGlvbikge1xuICAgIGNvbnN0IHRhcmdldFNlbGVjdGlvbiA9IHNlbGVjdGlvbiB8fCAkZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAodGFyZ2V0U2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1NlbGVjdGVkID0gdGFyZ2V0U2VsZWN0aW9uLmdldE5vZGVzKCkuc29tZShuID0+IG4uX19rZXkgPT09IHRoaXMuX19rZXkpO1xuXG4gICAgaWYgKCRpc1RleHROb2RlKHRoaXMpKSB7XG4gICAgICByZXR1cm4gaXNTZWxlY3RlZDtcbiAgICB9IC8vIEZvciBpbmxpbmUgaW1hZ2VzIGluc2lkZSBvZiBlbGVtZW50IG5vZGVzLlxuICAgIC8vIFdpdGhvdXQgdGhpcyBjaGFuZ2UgdGhlIGltYWdlIHdpbGwgYmUgc2VsZWN0ZWQgaWYgdGhlIGN1cnNvciBpcyBiZWZvcmUgb3IgYWZ0ZXIgaXQuXG5cblxuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbih0YXJnZXRTZWxlY3Rpb24pICYmIHRhcmdldFNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHRhcmdldFNlbGVjdGlvbi5mb2N1cy50eXBlID09PSAnZWxlbWVudCcgJiYgdGFyZ2V0U2VsZWN0aW9uLmFuY2hvci5rZXkgPT09IHRhcmdldFNlbGVjdGlvbi5mb2N1cy5rZXkgJiYgdGFyZ2V0U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IHRhcmdldFNlbGVjdGlvbi5mb2N1cy5vZmZzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNTZWxlY3RlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGlzIG5vZGVzIGtleS5cbiAgICovXG5cblxuICBnZXRLZXkoKSB7XG4gICAgLy8gS2V5IGlzIHN0YWJsZSBiZXR3ZWVuIGNvcGllc1xuICAgIHJldHVybiB0aGlzLl9fa2V5O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB6ZXJvLWJhc2VkIGluZGV4IG9mIHRoaXMgbm9kZSB3aXRoaW4gdGhlIHBhcmVudC5cbiAgICovXG5cblxuICBnZXRJbmRleFdpdGhpblBhcmVudCgpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGxldCBub2RlID0gcGFyZW50LmdldEZpcnN0Q2hpbGQoKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmlzKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cblxuICAgICAgaW5kZXgrKztcbiAgICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgb2YgdGhpcyBub2RlLCBvciBudWxsIGlmIG5vbmUgaXMgZm91bmQuXG4gICAqL1xuXG5cbiAgZ2V0UGFyZW50KCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0TGF0ZXN0KCkuX19wYXJlbnQ7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gJGdldE5vZGVCeUtleShwYXJlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgb2YgdGhpcyBub2RlLCBvciB0aHJvd3MgaWYgbm9uZSBpcyBmb3VuZC5cbiAgICovXG5cblxuICBnZXRQYXJlbnRPclRocm93KCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBub2RlICR7dGhpcy5fX2tleX0gdG8gaGF2ZSBhIHBhcmVudC5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaWdoZXN0IChpbiB0aGUgRWRpdG9yU3RhdGUgdHJlZSlcbiAgICogbm9uLXJvb3QgYW5jZXN0b3Igb2YgdGhpcyBub2RlLCBvciBudWxsIGlmIG5vbmUgaXMgZm91bmQuIFNlZSB7QGxpbmsgbGV4aWNhbCEkaXNSb290T3JTaGFkb3dSb290fVxuICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB3aGljaCBFbGVtZW50cyBjb21wcmlzZSBcInJvb3RzXCIuXG4gICAqL1xuXG5cbiAgZ2V0VG9wTGV2ZWxFbGVtZW50KCkge1xuICAgIGxldCBub2RlID0gdGhpcztcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaWdoZXN0IChpbiB0aGUgRWRpdG9yU3RhdGUgdHJlZSlcbiAgICogbm9uLXJvb3QgYW5jZXN0b3Igb2YgdGhpcyBub2RlLCBvciB0aHJvd3MgaWYgbm9uZSBpcyBmb3VuZC4gU2VlIHtAbGluayBsZXhpY2FsISRpc1Jvb3RPclNoYWRvd1Jvb3R9XG4gICAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdoaWNoIEVsZW1lbnRzIGNvbXByaXNlIFwicm9vdHNcIi5cbiAgICovXG5cblxuICBnZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0VG9wTGV2ZWxFbGVtZW50KCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBub2RlICR7dGhpcy5fX2tleX0gdG8gaGF2ZSBhIHRvcCBwYXJlbnQgZWxlbWVudC5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgZXZlcnkgYW5jZXN0b3Igb2YgdGhpcyBub2RlLFxuICAgKiBhbGwgdGhlIHdheSB1cCB0byB0aGUgUm9vdE5vZGUuXG4gICAqXG4gICAqL1xuXG5cbiAgZ2V0UGFyZW50cygpIHtcbiAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgbGV0IG5vZGUgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnRzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUga2V5cyBvZiBldmVyeSBhbmNlc3RvciBvZiB0aGlzIG5vZGUsXG4gICAqIGFsbCB0aGUgd2F5IHVwIHRvIHRoZSBSb290Tm9kZS5cbiAgICpcbiAgICovXG5cblxuICBnZXRQYXJlbnRLZXlzKCkge1xuICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICBsZXQgbm9kZSA9IHRoaXMuZ2V0UGFyZW50KCk7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgcGFyZW50cy5wdXNoKG5vZGUuX19rZXkpO1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudHM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFwicHJldmlvdXNcIiBzaWJsaW5ncyAtIHRoYXQgaXMsIHRoZSBub2RlIHRoYXQgY29tZXNcbiAgICogYmVmb3JlIHRoaXMgb25lIGluIHRoZSBzYW1lIHBhcmVudC5cbiAgICpcbiAgICovXG5cblxuICBnZXRQcmV2aW91c1NpYmxpbmcoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgcHJldktleSA9IHNlbGYuX19wcmV2O1xuICAgIHJldHVybiBwcmV2S2V5ID09PSBudWxsID8gbnVsbCA6ICRnZXROb2RlQnlLZXkocHJldktleSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFwicHJldmlvdXNcIiBzaWJsaW5ncyAtIHRoYXQgaXMsIHRoZSBub2RlcyB0aGF0IGNvbWUgYmV0d2VlblxuICAgKiB0aGlzIG9uZSBhbmQgdGhlIGZpcnN0IGNoaWxkIG9mIGl0J3MgcGFyZW50LCBpbmNsdXNpdmUuXG4gICAqXG4gICAqL1xuXG5cbiAgZ2V0UHJldmlvdXNTaWJsaW5ncygpIHtcbiAgICBjb25zdCBzaWJsaW5ncyA9IFtdO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc2libGluZ3M7XG4gICAgfVxuXG4gICAgbGV0IG5vZGUgPSBwYXJlbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLmlzKHRoaXMpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzaWJsaW5ncy5wdXNoKG5vZGUpO1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2libGluZ3M7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFwibmV4dFwiIHNpYmxpbmdzIC0gdGhhdCBpcywgdGhlIG5vZGUgdGhhdCBjb21lc1xuICAgKiBhZnRlciB0aGlzIG9uZSBpbiB0aGUgc2FtZSBwYXJlbnRcbiAgICpcbiAgICovXG5cblxuICBnZXROZXh0U2libGluZygpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBuZXh0S2V5ID0gc2VsZi5fX25leHQ7XG4gICAgcmV0dXJuIG5leHRLZXkgPT09IG51bGwgPyBudWxsIDogJGdldE5vZGVCeUtleShuZXh0S2V5KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgXCJuZXh0XCIgc2libGluZ3MgLSB0aGF0IGlzLCB0aGUgbm9kZXMgdGhhdCBjb21lIGJldHdlZW4gdGhpc1xuICAgKiBvbmUgYW5kIHRoZSBsYXN0IGNoaWxkIG9mIGl0J3MgcGFyZW50LCBpbmNsdXNpdmUuXG4gICAqXG4gICAqL1xuXG5cbiAgZ2V0TmV4dFNpYmxpbmdzKCkge1xuICAgIGNvbnN0IHNpYmxpbmdzID0gW107XG4gICAgbGV0IG5vZGUgPSB0aGlzLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgc2libGluZ3MucHVzaChub2RlKTtcbiAgICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpYmxpbmdzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbG9zZXN0IGNvbW1vbiBhbmNlc3RvciBvZiB0aGlzIG5vZGUgYW5kIHRoZSBwcm92aWRlZCBvbmUgb3IgbnVsbFxuICAgKiBpZiBvbmUgY2Fubm90IGJlIGZvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZSAtIHRoZSBvdGhlciBub2RlIHRvIGZpbmQgdGhlIGNvbW1vbiBhbmNlc3RvciBvZi5cbiAgICovXG5cblxuICBnZXRDb21tb25BbmNlc3Rvcihub2RlKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuZ2V0UGFyZW50cygpO1xuICAgIGNvbnN0IGIgPSBub2RlLmdldFBhcmVudHMoKTtcblxuICAgIGlmICgkaXNFbGVtZW50Tm9kZSh0aGlzKSkge1xuICAgICAgYS51bnNoaWZ0KHRoaXMpO1xuICAgIH1cblxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgYi51bnNoaWZ0KG5vZGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGFMZW5ndGggPSBhLmxlbmd0aDtcbiAgICBjb25zdCBiTGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgICBpZiAoYUxlbmd0aCA9PT0gMCB8fCBiTGVuZ3RoID09PSAwIHx8IGFbYUxlbmd0aCAtIDFdICE9PSBiW2JMZW5ndGggLSAxXSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgYlNldCA9IG5ldyBTZXQoYik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYW5jZXN0b3IgPSBhW2ldO1xuXG4gICAgICBpZiAoYlNldC5oYXMoYW5jZXN0b3IpKSB7XG4gICAgICAgIHJldHVybiBhbmNlc3RvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBub2RlIGlzIHRoZSBleGFjdCBzYW1lIG9uZSBhcyB0aGlzIG5vZGUsIGZyb20gTGV4aWNhbCdzIHBlcnNwZWN0aXZlLlxuICAgKiBBbHdheXMgdXNlIHRoaXMgaW5zdGVhZCBvZiByZWZlcmVudGlhbCBlcXVhbGl0eS5cbiAgICpcbiAgICogQHBhcmFtIG9iamVjdCAtIHRoZSBub2RlIHRvIHBlcmZvcm0gdGhlIGVxdWFsaXR5IGNvbXBhcmlzb24gb24uXG4gICAqL1xuXG5cbiAgaXMob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19rZXkgPT09IG9iamVjdC5fX2tleTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbm9kZSBsb2dpY2FsIHByZWNlZGVzIHRoZSB0YXJnZXQgbm9kZSBpbiB0aGUgZWRpdG9yIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0Tm9kZSAtIHRoZSBub2RlIHdlJ3JlIHRlc3RpbmcgdG8gc2VlIGlmIGl0J3MgYWZ0ZXIgdGhpcyBvbmUuXG4gICAqL1xuXG5cbiAgaXNCZWZvcmUodGFyZ2V0Tm9kZSkge1xuICAgIGlmICh0aGlzID09PSB0YXJnZXROb2RlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldE5vZGUuaXNQYXJlbnRPZih0aGlzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNQYXJlbnRPZih0YXJnZXROb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbW1vbkFuY2VzdG9yID0gdGhpcy5nZXRDb21tb25BbmNlc3Rvcih0YXJnZXROb2RlKTtcbiAgICBsZXQgaW5kZXhBID0gMDtcbiAgICBsZXQgaW5kZXhCID0gMDtcbiAgICBsZXQgbm9kZSA9IHRoaXM7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgICAgIGlmIChwYXJlbnQgPT09IGNvbW1vbkFuY2VzdG9yKSB7XG4gICAgICAgIGluZGV4QSA9IG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IHRhcmdldE5vZGU7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgICAgIGlmIChwYXJlbnQgPT09IGNvbW1vbkFuY2VzdG9yKSB7XG4gICAgICAgIGluZGV4QiA9IG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4QSA8IGluZGV4QjtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbm9kZSBpcyB0aGUgcGFyZW50IG9mIHRoZSB0YXJnZXQgbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0Tm9kZSAtIHRoZSB3b3VsZC1iZSBjaGlsZCBub2RlLlxuICAgKi9cblxuXG4gIGlzUGFyZW50T2YodGFyZ2V0Tm9kZSkge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuX19rZXk7XG5cbiAgICBpZiAoa2V5ID09PSB0YXJnZXROb2RlLl9fa2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IG5vZGUgPSB0YXJnZXROb2RlO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLl9fa2V5ID09PSBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUTy1ETzogdGhpcyBmdW5jdGlvbiBjYW4gYmUgc2ltcGxpZmllZCBhIGxvdFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyB0aGF0IGFyZSBiZXR3ZWVuIHRoaXMgbm9kZSBhbmRcbiAgICogdGhlIHRhcmdldCBub2RlIGluIHRoZSBFZGl0b3JTdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHRhcmdldE5vZGUgLSB0aGUgbm9kZSB0aGF0IG1hcmtzIHRoZSBvdGhlciBlbmQgb2YgdGhlIHJhbmdlIG9mIG5vZGVzIHRvIGJlIHJldHVybmVkLlxuICAgKi9cblxuXG4gIGdldE5vZGVzQmV0d2Vlbih0YXJnZXROb2RlKSB7XG4gICAgY29uc3QgaXNCZWZvcmUgPSB0aGlzLmlzQmVmb3JlKHRhcmdldE5vZGUpO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICBsZXQgbm9kZSA9IHRoaXM7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3Qga2V5ID0gbm9kZS5fX2tleTtcblxuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhrZXkpKSB7XG4gICAgICAgIHZpc2l0ZWQuYWRkKGtleSk7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSB0YXJnZXROb2RlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGlsZCA9ICRpc0VsZW1lbnROb2RlKG5vZGUpID8gaXNCZWZvcmUgPyBub2RlLmdldEZpcnN0Q2hpbGQoKSA6IG5vZGUuZ2V0TGFzdENoaWxkKCkgOiBudWxsO1xuXG4gICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBpc0JlZm9yZSA/IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKSA6IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICAgIGlmIChuZXh0U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gbmV4dFNpYmxpbmc7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhwYXJlbnQuX19rZXkpKSB7XG4gICAgICAgIG5vZGVzLnB1c2gocGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudCA9PT0gdGFyZ2V0Tm9kZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbGV0IHBhcmVudFNpYmxpbmcgPSBudWxsO1xuICAgICAgbGV0IGFuY2VzdG9yID0gcGFyZW50O1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChhbmNlc3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBnZXROb2Rlc0JldHdlZW46IGFuY2VzdG9yIGlzIG51bGxgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRTaWJsaW5nID0gaXNCZWZvcmUgPyBhbmNlc3Rvci5nZXROZXh0U2libGluZygpIDogYW5jZXN0b3IuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgaWYgKGFuY2VzdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHBhcmVudFNpYmxpbmcgPT09IG51bGwgJiYgIXZpc2l0ZWQuaGFzKGFuY2VzdG9yLl9fa2V5KSkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChhbmNlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChwYXJlbnRTaWJsaW5nID09PSBudWxsKTtcblxuICAgICAgbm9kZSA9IHBhcmVudFNpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKCFpc0JlZm9yZSkge1xuICAgICAgbm9kZXMucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbm9kZSBoYXMgYmVlbiBtYXJrZWQgZGlydHkgZHVyaW5nIHRoaXMgdXBkYXRlIGN5Y2xlLlxuICAgKlxuICAgKi9cblxuXG4gIGlzRGlydHkoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gICAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICAgIHJldHVybiBkaXJ0eUxlYXZlcyAhPT0gbnVsbCAmJiBkaXJ0eUxlYXZlcy5oYXModGhpcy5fX2tleSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIHRoZSBub2RlIGZyb20gdGhlIGFjdGl2ZSBFZGl0b3JTdGF0ZS5cbiAgICogVGhpcyBpcyB1c2VkIHRvIGF2b2lkIGdldHRpbmcgdmFsdWVzIGZyb20gc3RhbGUgbm9kZSByZWZlcmVuY2VzLlxuICAgKlxuICAgKi9cblxuXG4gIGdldExhdGVzdCgpIHtcbiAgICBjb25zdCBsYXRlc3QgPSAkZ2V0Tm9kZUJ5S2V5KHRoaXMuX19rZXkpO1xuXG4gICAgaWYgKGxhdGVzdCA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbCBub2RlIGRvZXMgbm90IGV4aXN0IGluIGFjdGl2ZSBlZGl0b3Igc3RhdGUuIEF2b2lkIHVzaW5nIHRoZSBzYW1lIG5vZGUgcmVmZXJlbmNlcyBiZXR3ZWVuIG5lc3RlZCBjbG9zdXJlcyBmcm9tIGVkaXRvclN0YXRlLnJlYWQvZWRpdG9yLnVwZGF0ZS5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGF0ZXN0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbXV0YWJsZSB2ZXJzaW9uIG9mIHRoZSBub2RlLiBXaWxsIHRocm93IGFuIGVycm9yIGlmXG4gICAqIGNhbGxlZCBvdXRzaWRlIG9mIGEgTGV4aWNhbCBFZGl0b3Ige0BsaW5rIExleGljYWxFZGl0b3IudXBkYXRlfSBjYWxsYmFjay5cbiAgICpcbiAgICovXG5cblxuICBnZXRXcml0YWJsZSgpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gICAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gICAgY29uc3Qgbm9kZU1hcCA9IGVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICAgIGNvbnN0IGtleSA9IHRoaXMuX19rZXk7IC8vIEVuc3VyZSB3ZSBnZXQgdGhlIGxhdGVzdCBub2RlIGZyb20gcGVuZGluZyBzdGF0ZVxuXG4gICAgY29uc3QgbGF0ZXN0Tm9kZSA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgcGFyZW50ID0gbGF0ZXN0Tm9kZS5fX3BhcmVudDtcbiAgICBjb25zdCBjbG9uZU5vdE5lZWRlZCA9IGVkaXRvci5fY2xvbmVOb3ROZWVkZWQ7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgc2VsZWN0aW9uLl9jYWNoZWROb2RlcyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGNsb25lTm90TmVlZGVkLmhhcyhrZXkpKSB7XG4gICAgICAvLyBUcmFuc2Zvcm1zIGNsZWFyIHRoZSBkaXJ0eSBub2RlIHNldCBvbiBlYWNoIGl0ZXJhdGlvbiB0byBrZWVwIHRyYWNrIG9uIG5ld2x5IGRpcnR5IG5vZGVzXG4gICAgICBpbnRlcm5hbE1hcmtOb2RlQXNEaXJ0eShsYXRlc3ROb2RlKTtcbiAgICAgIHJldHVybiBsYXRlc3ROb2RlO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gbGF0ZXN0Tm9kZS5jb25zdHJ1Y3RvcjsgLy8gQHRzLWV4cGVjdC1lcnJvclxuXG4gICAgY29uc3QgbXV0YWJsZU5vZGUgPSBjb25zdHJ1Y3Rvci5jbG9uZShsYXRlc3ROb2RlKTtcbiAgICBtdXRhYmxlTm9kZS5fX3BhcmVudCA9IHBhcmVudDtcbiAgICBtdXRhYmxlTm9kZS5fX25leHQgPSBsYXRlc3ROb2RlLl9fbmV4dDtcbiAgICBtdXRhYmxlTm9kZS5fX3ByZXYgPSBsYXRlc3ROb2RlLl9fcHJldjtcblxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShsYXRlc3ROb2RlKSAmJiAkaXNFbGVtZW50Tm9kZShtdXRhYmxlTm9kZSkpIHtcbiAgICAgIG11dGFibGVOb2RlLl9fZmlyc3QgPSBsYXRlc3ROb2RlLl9fZmlyc3Q7XG4gICAgICBtdXRhYmxlTm9kZS5fX2xhc3QgPSBsYXRlc3ROb2RlLl9fbGFzdDtcbiAgICAgIG11dGFibGVOb2RlLl9fc2l6ZSA9IGxhdGVzdE5vZGUuX19zaXplO1xuICAgICAgbXV0YWJsZU5vZGUuX19pbmRlbnQgPSBsYXRlc3ROb2RlLl9faW5kZW50O1xuICAgICAgbXV0YWJsZU5vZGUuX19mb3JtYXQgPSBsYXRlc3ROb2RlLl9fZm9ybWF0O1xuICAgICAgbXV0YWJsZU5vZGUuX19kaXIgPSBsYXRlc3ROb2RlLl9fZGlyO1xuICAgIH0gZWxzZSBpZiAoJGlzVGV4dE5vZGUobGF0ZXN0Tm9kZSkgJiYgJGlzVGV4dE5vZGUobXV0YWJsZU5vZGUpKSB7XG4gICAgICBtdXRhYmxlTm9kZS5fX2Zvcm1hdCA9IGxhdGVzdE5vZGUuX19mb3JtYXQ7XG4gICAgICBtdXRhYmxlTm9kZS5fX3N0eWxlID0gbGF0ZXN0Tm9kZS5fX3N0eWxlO1xuICAgICAgbXV0YWJsZU5vZGUuX19tb2RlID0gbGF0ZXN0Tm9kZS5fX21vZGU7XG4gICAgICBtdXRhYmxlTm9kZS5fX2RldGFpbCA9IGxhdGVzdE5vZGUuX19kZXRhaWw7XG4gICAgfVxuXG4gICAgY2xvbmVOb3ROZWVkZWQuYWRkKGtleSk7XG4gICAgbXV0YWJsZU5vZGUuX19rZXkgPSBrZXk7XG4gICAgaW50ZXJuYWxNYXJrTm9kZUFzRGlydHkobXV0YWJsZU5vZGUpOyAvLyBVcGRhdGUgcmVmZXJlbmNlIGluIG5vZGUgbWFwXG5cbiAgICBub2RlTWFwLnNldChrZXksIG11dGFibGVOb2RlKTtcbiAgICByZXR1cm4gbXV0YWJsZU5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRleHQgY29udGVudCBvZiB0aGUgbm9kZS4gT3ZlcnJpZGUgdGhpcyBmb3JcbiAgICogY3VzdG9tIG5vZGVzIHRoYXQgc2hvdWxkIGhhdmUgYSByZXByZXNlbnRhdGlvbiBpbiBwbGFpbiB0ZXh0XG4gICAqIGZvcm1hdCAoZm9yIGNvcHkgKyBwYXN0ZSwgZm9yIGV4YW1wbGUpXG4gICAqXG4gICAqL1xuXG5cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyBwcm9kdWNlZCBieSBjYWxsaW5nIGdldFRleHRDb250ZW50IG9uIHRoaXMgbm9kZS5cbiAgICpcbiAgICovXG5cblxuICBnZXRUZXh0Q29udGVudFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGg7XG4gIH0gLy8gVmlld1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgZHVyaW5nIHRoZSByZWNvbmNpbGlhdGlvbiBwcm9jZXNzIHRvIGRldGVybWluZSB3aGljaCBub2Rlc1xuICAgKiB0byBpbnNlcnQgaW50byB0aGUgRE9NIGZvciB0aGlzIExleGljYWwgTm9kZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgbXVzdCByZXR1cm4gZXhhY3RseSBvbmUgSFRNTEVsZW1lbnQuIE5lc3RlZCBlbGVtZW50cyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICpcbiAgICogRG8gbm90IGF0dGVtcHQgdG8gdXBkYXRlIHRoZSBMZXhpY2FsIEVkaXRvclN0YXRlIGR1cmluZyB0aGlzIHBoYXNlIG9mIHRoZSB1cGRhdGUgbGlmZWN5bGUuXG4gICAqXG4gICAqIEBwYXJhbSBfY29uZmlnIC0gYWxsb3dzIGFjY2VzcyB0byB0aGluZ3MgbGlrZSB0aGUgRWRpdG9yVGhlbWUgKHRvIGFwcGx5IGNsYXNzZXMpIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAgICogQHBhcmFtIF9lZGl0b3IgLSBhbGxvd3MgYWNjZXNzIHRvIHRoZSBlZGl0b3IgZm9yIGNvbnRleHQgZHVyaW5nIHJlY29uY2lsaWF0aW9uLlxuICAgKlxuICAgKiAqL1xuXG5cbiAgY3JlYXRlRE9NKF9jb25maWcsIF9lZGl0b3IpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgY3JlYXRlRE9NOiBiYXNlIG1ldGhvZCBub3QgZXh0ZW5kZWRgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgbm9kZSBjaGFuZ2VzIGFuZCBzaG91bGQgdXBkYXRlIHRoZSBET01cbiAgICogaW4gd2hhdGV2ZXIgd2F5IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGl0IGFsaWduIHdpdGggYW55IGNoYW5nZXMgdGhhdCBtaWdodFxuICAgKiBoYXZlIGhhcHBlbmVkIGR1cmluZyB0aGUgdXBkYXRlLlxuICAgKlxuICAgKiBSZXR1cm5pbmcgXCJ0cnVlXCIgaGVyZSB3aWxsIGNhdXNlIGxleGljYWwgdG8gdW5tb3VudCBhbmQgcmVjcmVhdGUgdGhlIERPTSBub2RlXG4gICAqIChieSBjYWxsaW5nIGNyZWF0ZURPTSkuIFlvdSB3b3VsZCBuZWVkIHRvIGRvIHRoaXMgaWYgdGhlIGVsZW1lbnQgdGFnIGNoYW5nZXMsXG4gICAqIGZvciBpbnN0YW5jZS5cbiAgICpcbiAgICogKi9cblxuXG4gIHVwZGF0ZURPTShfcHJldk5vZGUsIF9kb20sIF9jb25maWcpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgdXBkYXRlRE9NOiBiYXNlIG1ldGhvZCBub3QgZXh0ZW5kZWRgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnRyb2xzIGhvdyB0aGUgdGhpcyBub2RlIGlzIHNlcmlhbGl6ZWQgdG8gSFRNTC4gVGhpcyBpcyBpbXBvcnRhbnQgZm9yXG4gICAqIGNvcHkgYW5kIHBhc3RlIGJldHdlZW4gTGV4aWNhbCBhbmQgbm9uLUxleGljYWwgZWRpdG9ycywgb3IgTGV4aWNhbCBlZGl0b3JzIHdpdGggZGlmZmVyZW50IG5hbWVzcGFjZXMsXG4gICAqIGluIHdoaWNoIGNhc2UgdGhlIHByaW1hcnkgdHJhbnNmZXIgZm9ybWF0IGlzIEhUTUwuIEl0J3MgYWxzbyBpbXBvcnRhbnQgaWYgeW91J3JlIHNlcmlhbGl6aW5nXG4gICAqIHRvIEhUTUwgZm9yIGFueSBvdGhlciByZWFzb24gdmlhIHtAbGluayBAbGV4aWNhbC9odG1sISRnZW5lcmF0ZUh0bWxGcm9tTm9kZXN9LiBZb3UgY291bGRcbiAgICogYWxzbyB1c2UgdGhpcyBtZXRob2QgdG8gYnVpbGQgeW91ciBvd24gSFRNTCByZW5kZXJlci5cbiAgICpcbiAgICogKi9cblxuXG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5jcmVhdGVET00oZWRpdG9yLl9jb25maWcsIGVkaXRvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDb250cm9scyBob3cgdGhlIHRoaXMgbm9kZSBpcyBzZXJpYWxpemVkIHRvIEpTT04uIFRoaXMgaXMgaW1wb3J0YW50IGZvclxuICAgKiBjb3B5IGFuZCBwYXN0ZSBiZXR3ZWVuIExleGljYWwgZWRpdG9ycyBzaGFyaW5nIHRoZSBzYW1lIG5hbWVzcGFjZS4gSXQncyBhbHNvIGltcG9ydGFudFxuICAgKiBpZiB5b3UncmUgc2VyaWFsaXppbmcgdG8gSlNPTiBmb3IgcGVyc2lzdGVudCBzdG9yYWdlIHNvbWV3aGVyZS5cbiAgICogU2VlIFtTZXJpYWxpemF0aW9uICYgRGVzZXJpYWxpemF0aW9uXShodHRwczovL2xleGljYWwuZGV2L2RvY3MvY29uY2VwdHMvc2VyaWFsaXphdGlvbiNsZXhpY2FsLS0taHRtbCkuXG4gICAqXG4gICAqICovXG5cblxuICBleHBvcnRKU09OKCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBleHBvcnRKU09OOiBiYXNlIG1ldGhvZCBub3QgZXh0ZW5kZWRgKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbnRyb2xzIGhvdyB0aGUgdGhpcyBub2RlIGlzIGRlc2VyaWFsaXplZCBmcm9tIEpTT04uIFRoaXMgaXMgdXN1YWxseSBib2lsZXJwbGF0ZSxcbiAgICogYnV0IHByb3ZpZGVzIGFuIGFic3RyYWN0aW9uIGJldHdlZW4gdGhlIG5vZGUgaW1wbGVtZW50YXRpb24gYW5kIHNlcmlhbGl6ZWQgaW50ZXJmYWNlIHRoYXQgY2FuXG4gICAqIGJlIGltcG9ydGFudCBpZiB5b3UgZXZlciBtYWtlIGJyZWFraW5nIGNoYW5nZXMgdG8gYSBub2RlIHNjaGVtYSAoYnkgYWRkaW5nIG9yIHJlbW92aW5nIHByb3BlcnRpZXMpLlxuICAgKiBTZWUgW1NlcmlhbGl6YXRpb24gJiBEZXNlcmlhbGl6YXRpb25dKGh0dHBzOi8vbGV4aWNhbC5kZXYvZG9jcy9jb25jZXB0cy9zZXJpYWxpemF0aW9uI2xleGljYWwtLS1odG1sKS5cbiAgICpcbiAgICogKi9cblxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKF9zZXJpYWxpemVkTm9kZSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsTm9kZTogTm9kZSAke3RoaXMubmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IC5pbXBvcnRKU09OKCkuYCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqXG4gICAqIFJlZ2lzdGVycyB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gYXMgYSB0cmFuc2Zvcm0gb24gdGhlIG5vZGUgZHVyaW5nXG4gICAqIEVkaXRvciBpbml0aWFsaXphdGlvbi4gTW9zdCBzdWNoIHVzZSBjYXNlcyBzaG91bGQgYmUgYWRkcmVzc2VkIHZpYVxuICAgKiB0aGUge0BsaW5rIExleGljYWxFZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtfSBBUEkuXG4gICAqXG4gICAqIEV4cGVyaW1lbnRhbCAtIHVzZSBhdCB5b3VyIG93biByaXNrLlxuICAgKi9cblxuXG4gIHN0YXRpYyB0cmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gU2V0dGVycyBhbmQgbXV0YXRvcnNcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGlzIExleGljYWxOb2RlIGZyb20gdGhlIEVkaXRvclN0YXRlLiBJZiB0aGUgbm9kZSBpc24ndCByZS1pbnNlcnRlZFxuICAgKiBzb21ld2hlcmUsIHRoZSBMZXhpY2FsIGdhcmJhZ2UgY29sbGVjdG9yIHdpbGwgZXZlbnR1YWxseSBjbGVhbiBpdCB1cC5cbiAgICpcbiAgICogQHBhcmFtIHByZXNlcnZlRW1wdHlQYXJlbnQgLSBJZiBmYWxzeSwgdGhlIG5vZGUncyBwYXJlbnQgd2lsbCBiZSByZW1vdmVkIGlmXG4gICAqIGl0J3MgZW1wdHkgYWZ0ZXIgdGhlIHJlbW92YWwgb3BlcmF0aW9uLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLCBzdWJqZWN0IHRvXG4gICAqIG90aGVyIG5vZGUgaGV1cmlzdGljcyBzdWNoIGFzIHtAbGluayBFbGVtZW50Tm9kZSNjYW5CZUVtcHR5fVxuICAgKiAqL1xuXG5cbiAgcmVtb3ZlKHByZXNlcnZlRW1wdHlQYXJlbnQpIHtcbiAgICByZW1vdmVOb2RlKHRoaXMsIHRydWUsIHByZXNlcnZlRW1wdHlQYXJlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGlzIExleGljYWxOb2RlIHdpdGggdGhlIHByb3ZpZGVkIG5vZGUsIG9wdGlvbmFsbHkgdHJhbnNmZXJyaW5nIHRoZSBjaGlsZHJlblxuICAgKiBvZiB0aGUgcmVwbGFjZWQgbm9kZSB0byB0aGUgcmVwbGFjaW5nIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSByZXBsYWNlV2l0aCAtIFRoZSBub2RlIHRvIHJlcGxhY2UgdGhpcyBvbmUgd2l0aC5cbiAgICogQHBhcmFtIGluY2x1ZGVDaGlsZHJlbiAtIFdoZXRoZXIgb3Igbm90IHRvIHRyYW5zZmVyIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUgdG8gdGhlIHJlcGxhY2luZyBub2RlLlxuICAgKiAqL1xuXG5cbiAgcmVwbGFjZShyZXBsYWNlV2l0aCwgaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgbGV0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSBzZWxlY3Rpb24gPSBzZWxlY3Rpb24uY2xvbmUoKTtcbiAgICBlcnJvck9uSW5zZXJ0VGV4dE5vZGVPblJvb3QodGhpcywgcmVwbGFjZVdpdGgpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IHRvUmVwbGFjZUtleSA9IHRoaXMuX19rZXk7XG4gICAgY29uc3Qga2V5ID0gcmVwbGFjZVdpdGguX19rZXk7XG4gICAgY29uc3Qgd3JpdGFibGVSZXBsYWNlV2l0aCA9IHJlcGxhY2VXaXRoLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3Qgd3JpdGFibGVQYXJlbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHNpemUgPSB3cml0YWJsZVBhcmVudC5fX3NpemU7XG4gICAgcmVtb3ZlRnJvbVBhcmVudCh3cml0YWJsZVJlcGxhY2VXaXRoKTtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHNlbGYuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBzZWxmLmdldE5leHRTaWJsaW5nKCk7XG4gICAgY29uc3QgcHJldktleSA9IHNlbGYuX19wcmV2O1xuICAgIGNvbnN0IG5leHRLZXkgPSBzZWxmLl9fbmV4dDtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBzZWxmLl9fcGFyZW50O1xuICAgIHJlbW92ZU5vZGUoc2VsZiwgZmFsc2UsIHRydWUpO1xuXG4gICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICB3cml0YWJsZVBhcmVudC5fX2ZpcnN0ID0ga2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cml0YWJsZVByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgIHdyaXRhYmxlUHJldlNpYmxpbmcuX19uZXh0ID0ga2V5O1xuICAgIH1cblxuICAgIHdyaXRhYmxlUmVwbGFjZVdpdGguX19wcmV2ID0gcHJldktleTtcblxuICAgIGlmIChuZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgd3JpdGFibGVQYXJlbnQuX19sYXN0ID0ga2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cml0YWJsZU5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgIHdyaXRhYmxlTmV4dFNpYmxpbmcuX19wcmV2ID0ga2V5O1xuICAgIH1cblxuICAgIHdyaXRhYmxlUmVwbGFjZVdpdGguX19uZXh0ID0gbmV4dEtleTtcbiAgICB3cml0YWJsZVJlcGxhY2VXaXRoLl9fcGFyZW50ID0gcGFyZW50S2V5O1xuICAgIHdyaXRhYmxlUGFyZW50Ll9fc2l6ZSA9IHNpemU7XG5cbiAgICBpZiAoaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgICB0aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIHdyaXRhYmxlUmVwbGFjZVdpdGguYXBwZW5kKGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAkc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG5cbiAgICAgIGlmIChhbmNob3Iua2V5ID09PSB0b1JlcGxhY2VLZXkpIHtcbiAgICAgICAgJG1vdmVTZWxlY3Rpb25Qb2ludFRvRW5kKGFuY2hvciwgd3JpdGFibGVSZXBsYWNlV2l0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb2N1cy5rZXkgPT09IHRvUmVwbGFjZUtleSkge1xuICAgICAgICAkbW92ZVNlbGVjdGlvblBvaW50VG9FbmQoZm9jdXMsIHdyaXRhYmxlUmVwbGFjZVdpdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgkZ2V0Q29tcG9zaXRpb25LZXkoKSA9PT0gdG9SZXBsYWNlS2V5KSB7XG4gICAgICAkc2V0Q29tcG9zaXRpb25LZXkoa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JpdGFibGVSZXBsYWNlV2l0aDtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBhIG5vZGUgYWZ0ZXIgdGhpcyBMZXhpY2FsTm9kZSAoYXMgdGhlIG5leHQgc2libGluZykuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlVG9JbnNlcnQgLSBUaGUgbm9kZSB0byBpbnNlcnQgYWZ0ZXIgdGhpcyBvbmUuXG4gICAqIEBwYXJhbSByZXN0b3JlU2VsZWN0aW9uIC0gV2hldGhlciBvciBub3QgdG8gYXR0ZW1wdCB0byByZXNvbHZlIHRoZVxuICAgKiBzZWxlY3Rpb24gdG8gdGhlIGFwcHJvcHJpYXRlIHBsYWNlIGFmdGVyIHRoZSBvcGVyYXRpb24gaXMgY29tcGxldGUuXG4gICAqICovXG5cblxuICBpbnNlcnRBZnRlcihub2RlVG9JbnNlcnQsIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgZXJyb3JPbkluc2VydFRleHROb2RlT25Sb290KHRoaXMsIG5vZGVUb0luc2VydCk7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHdyaXRhYmxlTm9kZVRvSW5zZXJ0ID0gbm9kZVRvSW5zZXJ0LmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3Qgb2xkUGFyZW50ID0gd3JpdGFibGVOb2RlVG9JbnNlcnQuZ2V0UGFyZW50KCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGxldCBlbGVtZW50QW5jaG9yU2VsZWN0aW9uT25Ob2RlID0gZmFsc2U7XG4gICAgbGV0IGVsZW1lbnRGb2N1c1NlbGVjdGlvbk9uTm9kZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9sZFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogdGhpcyBpcyBPKG4pLCBjYW4gd2UgaW1wcm92ZT9cbiAgICAgIGNvbnN0IG9sZEluZGV4ID0gbm9kZVRvSW5zZXJ0LmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICByZW1vdmVGcm9tUGFyZW50KHdyaXRhYmxlTm9kZVRvSW5zZXJ0KTtcblxuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3Qgb2xkUGFyZW50S2V5ID0gb2xkUGFyZW50Ll9fa2V5O1xuICAgICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICAgICAgZWxlbWVudEFuY2hvclNlbGVjdGlvbk9uTm9kZSA9IGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLmtleSA9PT0gb2xkUGFyZW50S2V5ICYmIGFuY2hvci5vZmZzZXQgPT09IG9sZEluZGV4ICsgMTtcbiAgICAgICAgZWxlbWVudEZvY3VzU2VsZWN0aW9uT25Ob2RlID0gZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGZvY3VzLmtleSA9PT0gb2xkUGFyZW50S2V5ICYmIGZvY3VzLm9mZnNldCA9PT0gb2xkSW5kZXggKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgIGNvbnN0IHdyaXRhYmxlUGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBpbnNlcnRLZXkgPSB3cml0YWJsZU5vZGVUb0luc2VydC5fX2tleTtcbiAgICBjb25zdCBuZXh0S2V5ID0gd3JpdGFibGVTZWxmLl9fbmV4dDtcblxuICAgIGlmIChuZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgd3JpdGFibGVQYXJlbnQuX19sYXN0ID0gaW5zZXJ0S2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cml0YWJsZU5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgIHdyaXRhYmxlTmV4dFNpYmxpbmcuX19wcmV2ID0gaW5zZXJ0S2V5O1xuICAgIH1cblxuICAgIHdyaXRhYmxlUGFyZW50Ll9fc2l6ZSsrO1xuICAgIHdyaXRhYmxlU2VsZi5fX25leHQgPSBpbnNlcnRLZXk7XG4gICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19uZXh0ID0gbmV4dEtleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3ByZXYgPSB3cml0YWJsZVNlbGYuX19rZXk7XG4gICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19wYXJlbnQgPSB3cml0YWJsZVNlbGYuX19wYXJlbnQ7XG5cbiAgICBpZiAocmVzdG9yZVNlbGVjdGlvbiAmJiAkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICR1cGRhdGVFbGVtZW50U2VsZWN0aW9uT25DcmVhdGVEZWxldGVOb2RlKHNlbGVjdGlvbiwgd3JpdGFibGVQYXJlbnQsIGluZGV4ICsgMSk7XG4gICAgICBjb25zdCB3cml0YWJsZVBhcmVudEtleSA9IHdyaXRhYmxlUGFyZW50Ll9fa2V5O1xuXG4gICAgICBpZiAoZWxlbWVudEFuY2hvclNlbGVjdGlvbk9uTm9kZSkge1xuICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldCh3cml0YWJsZVBhcmVudEtleSwgaW5kZXggKyAyLCAnZWxlbWVudCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudEZvY3VzU2VsZWN0aW9uT25Ob2RlKSB7XG4gICAgICAgIHNlbGVjdGlvbi5mb2N1cy5zZXQod3JpdGFibGVQYXJlbnRLZXksIGluZGV4ICsgMiwgJ2VsZW1lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZVRvSW5zZXJ0O1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIGEgbm9kZSBiZWZvcmUgdGhpcyBMZXhpY2FsTm9kZSAoYXMgdGhlIHByZXZpb3VzIHNpYmxpbmcpLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZVRvSW5zZXJ0IC0gVGhlIG5vZGUgdG8gaW5zZXJ0IGFmdGVyIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gcmVzdG9yZVNlbGVjdGlvbiAtIFdoZXRoZXIgb3Igbm90IHRvIGF0dGVtcHQgdG8gcmVzb2x2ZSB0aGVcbiAgICogc2VsZWN0aW9uIHRvIHRoZSBhcHByb3ByaWF0ZSBwbGFjZSBhZnRlciB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKiAqL1xuXG5cbiAgaW5zZXJ0QmVmb3JlKG5vZGVUb0luc2VydCwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBlcnJvck9uSW5zZXJ0VGV4dE5vZGVPblJvb3QodGhpcywgbm9kZVRvSW5zZXJ0KTtcbiAgICBjb25zdCB3cml0YWJsZVNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3Qgd3JpdGFibGVOb2RlVG9JbnNlcnQgPSBub2RlVG9JbnNlcnQuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBpbnNlcnRLZXkgPSB3cml0YWJsZU5vZGVUb0luc2VydC5fX2tleTtcbiAgICByZW1vdmVGcm9tUGFyZW50KHdyaXRhYmxlTm9kZVRvSW5zZXJ0KTtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgY29uc3Qgd3JpdGFibGVQYXJlbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHByZXZLZXkgPSB3cml0YWJsZVNlbGYuX19wcmV2OyAvLyBUT0RPOiB0aGlzIGlzIE8obiksIGNhbiB3ZSBpbXByb3ZlP1xuXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG5cbiAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50Ll9fZmlyc3QgPSBpbnNlcnRLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlUHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBpbnNlcnRLZXk7XG4gICAgfVxuXG4gICAgd3JpdGFibGVQYXJlbnQuX19zaXplKys7XG4gICAgd3JpdGFibGVTZWxmLl9fcHJldiA9IGluc2VydEtleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3ByZXYgPSBwcmV2S2V5O1xuICAgIHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fbmV4dCA9IHdyaXRhYmxlU2VsZi5fX2tleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3BhcmVudCA9IHdyaXRhYmxlU2VsZi5fX3BhcmVudDtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAocmVzdG9yZVNlbGVjdGlvbiAmJiAkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICR1cGRhdGVFbGVtZW50U2VsZWN0aW9uT25DcmVhdGVEZWxldGVOb2RlKHNlbGVjdGlvbiwgcGFyZW50LCBpbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVUb0luc2VydDtcbiAgfVxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhpcyBub2RlIGhhcyBhIHJlcXVpcmVkIHBhcmVudC4gVXNlZCBkdXJpbmcgY29weSArIHBhc3RlIG9wZXJhdGlvbnNcbiAgICogdG8gbm9ybWFsaXplIG5vZGVzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGJlIG9ycGhhbmVkLiBGb3IgZXhhbXBsZSwgTGlzdEl0ZW1Ob2RlcyB3aXRob3V0XG4gICAqIGEgTGlzdE5vZGUgcGFyZW50IG9yIFRleHROb2RlcyB3aXRoIGEgUGFyYWdyYXBoTm9kZSBwYXJlbnQuXG4gICAqXG4gICAqICovXG5cblxuICBpc1BhcmVudFJlcXVpcmVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogVGhlIGNyZWF0aW9uIGxvZ2ljIGZvciBhbnkgcmVxdWlyZWQgcGFyZW50LiBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaWYge0BsaW5rIGlzUGFyZW50UmVxdWlyZWR9IHJldHVybnMgdHJ1ZS5cbiAgICpcbiAgICogKi9cblxuXG4gIGNyZWF0ZVBhcmVudEVsZW1lbnROb2RlKCkge1xuICAgIHJldHVybiAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlcyBzZWxlY3Rpb24gdG8gdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhpcyBub2RlLCBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldHMuXG4gICAqXG4gICAqIEBwYXJhbSBhbmNob3JPZmZzZXQgLSBUaGUgYW5jaG9yIG9mZnNldCBmb3Igc2VsZWN0aW9uLlxuICAgKiBAcGFyYW0gZm9jdXNPZmZzZXQgLSAgVGhlIGZvY3VzIG9mZnNldCBmb3Igc2VsZWN0aW9uXG4gICAqICovXG5cblxuICBzZWxlY3RQcmV2aW91cyhhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0KSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSB0aGlzLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gcGFyZW50LnNlbGVjdCgwLCAwKTtcbiAgICB9XG5cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICByZXR1cm4gcHJldlNpYmxpbmcuc2VsZWN0KCk7XG4gICAgfSBlbHNlIGlmICghJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHByZXZTaWJsaW5nLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyAxO1xuICAgICAgcmV0dXJuIHBhcmVudC5zZWxlY3QoaW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJldlNpYmxpbmcuc2VsZWN0KGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQpO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlcyBzZWxlY3Rpb24gdG8gdGhlIG5leHQgc2libGluZyBvZiB0aGlzIG5vZGUsIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0cy5cbiAgICpcbiAgICogQHBhcmFtIGFuY2hvck9mZnNldCAtIFRoZSBhbmNob3Igb2Zmc2V0IGZvciBzZWxlY3Rpb24uXG4gICAqIEBwYXJhbSBmb2N1c09mZnNldCAtICBUaGUgZm9jdXMgb2Zmc2V0IGZvciBzZWxlY3Rpb25cbiAgICogKi9cblxuXG4gIHNlbGVjdE5leHQoYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gICAgaWYgKG5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gcGFyZW50LnNlbGVjdCgpO1xuICAgIH1cblxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIHJldHVybiBuZXh0U2libGluZy5zZWxlY3QoMCwgMCk7XG4gICAgfSBlbHNlIGlmICghJGlzVGV4dE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICBjb25zdCBpbmRleCA9IG5leHRTaWJsaW5nLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICByZXR1cm4gcGFyZW50LnNlbGVjdChpbmRleCwgaW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0U2libGluZy5zZWxlY3QoYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmtzIGEgbm9kZSBkaXJ0eSwgdHJpZ2dlcmluZyB0cmFuc2Zvcm1zIGFuZFxuICAgKiBmb3JjaW5nIGl0IHRvIGJlIHJlY29uY2lsZWQgZHVyaW5nIHRoZSB1cGRhdGUgY3ljbGUuXG4gICAqXG4gICAqICovXG5cblxuICBtYXJrRGlydHkoKSB7XG4gICAgdGhpcy5nZXRXcml0YWJsZSgpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gZXJyb3JPblR5cGVLbGFzc01pc21hdGNoKHR5cGUsIGtsYXNzKSB7XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gZ2V0QWN0aXZlRWRpdG9yKCkuX25vZGVzLmdldCh0eXBlKTsgLy8gQ29tbW9uIGVycm9yIC0gc3BsaXQgaW4gaXRzIG93biBpbnZhcmlhbnRcblxuXG4gIGlmIChyZWdpc3RlcmVkTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYENyZWF0ZSBub2RlOiBBdHRlbXB0ZWQgdG8gY3JlYXRlIG5vZGUgJHtrbGFzcy5uYW1lfSB0aGF0IHdhcyBub3QgY29uZmlndXJlZCB0byBiZSB1c2VkIG9uIHRoZSBlZGl0b3IuYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZWRpdG9yS2xhc3MgPSByZWdpc3RlcmVkTm9kZS5rbGFzcztcblxuICBpZiAoZWRpdG9yS2xhc3MgIT09IGtsYXNzKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYENyZWF0ZSBub2RlOiBUeXBlICR7dHlwZX0gaW4gbm9kZSAke2tsYXNzLm5hbWV9IGRvZXMgbm90IG1hdGNoIHJlZ2lzdGVyZWQgbm9kZSAke2VkaXRvcktsYXNzLm5hbWV9IHdpdGggdGhlIHNhbWUgdHlwZWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBMaW5lQnJlYWtOb2RlIGV4dGVuZHMgTGV4aWNhbE5vZGUge1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2xpbmVicmVhayc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgTGluZUJyZWFrTm9kZShub2RlLl9fa2V5KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gIH1cblxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICByZXR1cm4gJ1xcbic7XG4gIH1cblxuICBjcmVhdGVET00oKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJyk7XG4gIH1cblxuICB1cGRhdGVET00oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnI6IG5vZGUgPT4ge1xuICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50OyAvLyBJZiB0aGUgPGJyPiBpcyB0aGUgb25seSBjaGlsZCwgdGhlbiBza2lwIGluY2x1ZGluZyBpdFxuXG4gICAgICAgIGxldCBmaXJzdENoaWxkO1xuICAgICAgICBsZXQgbGFzdENoaWxkO1xuXG4gICAgICAgIGlmIChwYXJlbnRFbGVtZW50ICE9PSBudWxsICYmICgoZmlyc3RDaGlsZCA9IHBhcmVudEVsZW1lbnQuZmlyc3RDaGlsZCkgPT09IG5vZGUgfHwgZmlyc3RDaGlsZC5uZXh0U2libGluZyA9PT0gbm9kZSAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09PSBET01fVEVYVF9UWVBFICYmIChmaXJzdENoaWxkLnRleHRDb250ZW50IHx8ICcnKS5tYXRjaCgvXltcXHN8XFxyP1xcbnxcXHRdKyQvKSAhPT0gbnVsbCkgJiYgKChsYXN0Q2hpbGQgPSBwYXJlbnRFbGVtZW50Lmxhc3RDaGlsZCkgPT09IG5vZGUgfHwgbGFzdENoaWxkLnByZXZpb3VzU2libGluZyA9PT0gbm9kZSAmJiBsYXN0Q2hpbGQubm9kZVR5cGUgPT09IERPTV9URVhUX1RZUEUgJiYgKGxhc3RDaGlsZC50ZXh0Q29udGVudCB8fCAnJykubWF0Y2goL15bXFxzfFxccj9cXG58XFx0XSskLykgIT09IG51bGwpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRMaW5lQnJlYWtFbGVtZW50LFxuICAgICAgICAgIHByaW9yaXR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWRMaW5lQnJlYWtOb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVMaW5lQnJlYWtOb2RlKCk7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnbGluZWJyZWFrJyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG5cbn1cblxuZnVuY3Rpb24gY29udmVydExpbmVCcmVha0VsZW1lbnQobm9kZSkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVMaW5lQnJlYWtOb2RlKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gJGNyZWF0ZUxpbmVCcmVha05vZGUoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IExpbmVCcmVha05vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaW5lQnJlYWtOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRPdXRlclRhZyhub2RlLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCAmIElTX0NPREUpIHtcbiAgICByZXR1cm4gJ2NvZGUnO1xuICB9XG5cbiAgaWYgKGZvcm1hdCAmIElTX0hJR0hMSUdIVCkge1xuICAgIHJldHVybiAnbWFyayc7XG4gIH1cblxuICBpZiAoZm9ybWF0ICYgSVNfU1VCU0NSSVBUKSB7XG4gICAgcmV0dXJuICdzdWInO1xuICB9XG5cbiAgaWYgKGZvcm1hdCAmIElTX1NVUEVSU0NSSVBUKSB7XG4gICAgcmV0dXJuICdzdXAnO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRJbm5lclRhZyhub2RlLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCAmIElTX0JPTEQpIHtcbiAgICByZXR1cm4gJ3N0cm9uZyc7XG4gIH1cblxuICBpZiAoZm9ybWF0ICYgSVNfSVRBTElDKSB7XG4gICAgcmV0dXJuICdlbSc7XG4gIH1cblxuICByZXR1cm4gJ3NwYW4nO1xufVxuXG5mdW5jdGlvbiBzZXRUZXh0VGhlbWVDbGFzc05hbWVzKHRhZywgcHJldkZvcm1hdCwgbmV4dEZvcm1hdCwgZG9tLCB0ZXh0Q2xhc3NOYW1lcykge1xuICBjb25zdCBkb21DbGFzc0xpc3QgPSBkb20uY2xhc3NMaXN0OyAvLyBGaXJzdGx5IHdlIGhhbmRsZSB0aGUgYmFzZSB0aGVtZS5cblxuICBsZXQgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KHRleHRDbGFzc05hbWVzLCAnYmFzZScpO1xuXG4gIGlmIChjbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBkb21DbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICB9IC8vIFNlY29uZGx5IHdlIGhhbmRsZSB0aGUgc3BlY2lhbCBjYXNlOiB1bmRlcmxpbmUgKyBzdHJpa2V0aHJvdWdoLlxuICAvLyBXZSBoYXZlIHRvIGRvIHRoaXMgYXMgd2UgbmVlZCBhIHdheSB0byBjb21wb3NlIHRoZSBmYWN0IHRoYXRcbiAgLy8gdGhlIHNhbWUgQ1NTIHByb3BlcnR5IHdpbGwgbmVlZCB0byBiZSB1c2VkOiB0ZXh0LWRlY29yYXRpb24uXG4gIC8vIEluIGFuIGlkZWFsIHdvcmxkIHdlIHNob3VsZG4ndCBoYXZlIHRvIGRvIHRoaXMsIGJ1dCB0aGVyZSdzIG5vXG4gIC8vIGVhc3kgd29ya2Fyb3VuZCBmb3IgbWFueSBhdG9taWMgQ1NTIHN5c3RlbXMgdG9kYXkuXG5cblxuICBjbGFzc05hbWVzID0gZ2V0Q2FjaGVkQ2xhc3NOYW1lQXJyYXkodGV4dENsYXNzTmFtZXMsICd1bmRlcmxpbmVTdHJpa2V0aHJvdWdoJyk7XG4gIGxldCBoYXNVbmRlcmxpbmVTdHJpa2V0aHJvdWdoID0gZmFsc2U7XG4gIGNvbnN0IHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoID0gcHJldkZvcm1hdCAmIElTX1VOREVSTElORSAmJiBwcmV2Rm9ybWF0ICYgSVNfU1RSSUtFVEhST1VHSDtcbiAgY29uc3QgbmV4dFVuZGVybGluZVN0cmlrZXRocm91Z2ggPSBuZXh0Rm9ybWF0ICYgSVNfVU5ERVJMSU5FICYmIG5leHRGb3JtYXQgJiBJU19TVFJJS0VUSFJPVUdIO1xuXG4gIGlmIChjbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAobmV4dFVuZGVybGluZVN0cmlrZXRocm91Z2gpIHtcbiAgICAgIGhhc1VuZGVybGluZVN0cmlrZXRocm91Z2ggPSB0cnVlO1xuXG4gICAgICBpZiAoIXByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoKSB7XG4gICAgICAgIGRvbUNsYXNzTGlzdC5hZGQoLi4uY2xhc3NOYW1lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2VW5kZXJsaW5lU3RyaWtldGhyb3VnaCkge1xuICAgICAgZG9tQ2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc05hbWVzKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBpbiBURVhUX1RZUEVfVE9fRk9STUFUKSB7XG4gICAgY29uc3QgZm9ybWF0ID0ga2V5O1xuICAgIGNvbnN0IGZsYWcgPSBURVhUX1RZUEVfVE9fRk9STUFUW2Zvcm1hdF07XG4gICAgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KHRleHRDbGFzc05hbWVzLCBrZXkpO1xuXG4gICAgaWYgKGNsYXNzTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG5leHRGb3JtYXQgJiBmbGFnKSB7XG4gICAgICAgIGlmIChoYXNVbmRlcmxpbmVTdHJpa2V0aHJvdWdoICYmIChrZXkgPT09ICd1bmRlcmxpbmUnIHx8IGtleSA9PT0gJ3N0cmlrZXRocm91Z2gnKSkge1xuICAgICAgICAgIGlmIChwcmV2Rm9ybWF0ICYgZmxhZykge1xuICAgICAgICAgICAgZG9tQ2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc05hbWVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgocHJldkZvcm1hdCAmIGZsYWcpID09PSAwIHx8IHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoICYmIGtleSA9PT0gJ3VuZGVybGluZScgfHwga2V5ID09PSAnc3RyaWtldGhyb3VnaCcpIHtcbiAgICAgICAgICBkb21DbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXZGb3JtYXQgJiBmbGFnKSB7XG4gICAgICAgIGRvbUNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRpZmZDb21wb3NlZFRleHQoYSwgYikge1xuICBjb25zdCBhTGVuZ3RoID0gYS5sZW5ndGg7XG4gIGNvbnN0IGJMZW5ndGggPSBiLmxlbmd0aDtcbiAgbGV0IGxlZnQgPSAwO1xuICBsZXQgcmlnaHQgPSAwO1xuXG4gIHdoaWxlIChsZWZ0IDwgYUxlbmd0aCAmJiBsZWZ0IDwgYkxlbmd0aCAmJiBhW2xlZnRdID09PSBiW2xlZnRdKSB7XG4gICAgbGVmdCsrO1xuICB9XG5cbiAgd2hpbGUgKHJpZ2h0ICsgbGVmdCA8IGFMZW5ndGggJiYgcmlnaHQgKyBsZWZ0IDwgYkxlbmd0aCAmJiBhW2FMZW5ndGggLSByaWdodCAtIDFdID09PSBiW2JMZW5ndGggLSByaWdodCAtIDFdKSB7XG4gICAgcmlnaHQrKztcbiAgfVxuXG4gIHJldHVybiBbbGVmdCwgYUxlbmd0aCAtIGxlZnQgLSByaWdodCwgYi5zbGljZShsZWZ0LCBiTGVuZ3RoIC0gcmlnaHQpXTtcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQobmV4dFRleHQsIGRvbSwgbm9kZSkge1xuICBjb25zdCBmaXJzdENoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7XG4gIGNvbnN0IGlzQ29tcG9zaW5nID0gbm9kZS5pc0NvbXBvc2luZygpOyAvLyBBbHdheXMgYWRkIGEgc3VmZml4IGlmIHdlJ3JlIGNvbXBvc2luZyBhIG5vZGVcblxuICBjb25zdCBzdWZmaXggPSBpc0NvbXBvc2luZyA/IENPTVBPU0lUSU9OX1NVRkZJWCA6ICcnO1xuICBjb25zdCB0ZXh0ID0gbmV4dFRleHQgKyBzdWZmaXg7XG5cbiAgaWYgKGZpcnN0Q2hpbGQgPT0gbnVsbCkge1xuICAgIGRvbS50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgbm9kZVZhbHVlID0gZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG5cbiAgICBpZiAobm9kZVZhbHVlICE9PSB0ZXh0KSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcgfHwgSVNfRklSRUZPWCkge1xuICAgICAgICAvLyBXZSBhbHNvIHVzZSB0aGUgZGlmZiBjb21wb3NlZCB0ZXh0IGZvciBnZW5lcmFsIHRleHQgaW4gRkYgdG8gYXZvaWRcbiAgICAgICAgLy8gdGhlIHNwZWxsY2hlY2sgcmVkIGxpbmUgZnJvbSBmbGlja2VyaW5nLlxuICAgICAgICBjb25zdCBbaW5kZXgsIHJlbW92ZSwgaW5zZXJ0XSA9IGRpZmZDb21wb3NlZFRleHQobm9kZVZhbHVlLCB0ZXh0KTtcblxuICAgICAgICBpZiAocmVtb3ZlICE9PSAwKSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGZpcnN0Q2hpbGQuZGVsZXRlRGF0YShpbmRleCwgcmVtb3ZlKTtcbiAgICAgICAgfSAvLyBAdHMtZXhwZWN0LWVycm9yXG5cblxuICAgICAgICBmaXJzdENoaWxkLmluc2VydERhdGEoaW5kZXgsIGluc2VydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRJbm5lckRPTShpbm5lckRPTSwgbm9kZSwgaW5uZXJUYWcsIGZvcm1hdCwgdGV4dCwgY29uZmlnKSB7XG4gIHNldFRleHRDb250ZW50KHRleHQsIGlubmVyRE9NLCBub2RlKTtcbiAgY29uc3QgdGhlbWUgPSBjb25maWcudGhlbWU7IC8vIEFwcGx5IHRoZW1lIGNsYXNzIG5hbWVzXG5cbiAgY29uc3QgdGV4dENsYXNzTmFtZXMgPSB0aGVtZS50ZXh0O1xuXG4gIGlmICh0ZXh0Q2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2V0VGV4dFRoZW1lQ2xhc3NOYW1lcyhpbm5lclRhZywgMCwgZm9ybWF0LCBpbm5lckRPTSwgdGV4dENsYXNzTmFtZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCB0YWcpIHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGVsLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICByZXR1cm4gZWw7XG59XG4vKiogQG5vSW5oZXJpdERvYyAqL1xuXG5cbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgTGV4aWNhbE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAndGV4dCc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgVGV4dE5vZGUobm9kZS5fX3RleHQsIG5vZGUuX19rZXkpO1xuICB9XG5cbiAgY29uc3RydWN0b3IodGV4dCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fdGV4dCA9IHRleHQ7XG4gICAgdGhpcy5fX2Zvcm1hdCA9IDA7XG4gICAgdGhpcy5fX3N0eWxlID0gJyc7XG4gICAgdGhpcy5fX21vZGUgPSAwO1xuICAgIHRoaXMuX19kZXRhaWwgPSAwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgMzItYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBUZXh0Rm9ybWF0VHlwZXMgY3VycmVudGx5IGFwcGxpZWQgdG8gdGhlXG4gICAqIFRleHROb2RlLiBZb3UgcHJvYmFibHkgZG9uJ3Qgd2FudCB0byB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkgLSBjb25zaWRlciB1c2luZyBUZXh0Tm9kZS5oYXNGb3JtYXQgaW5zdGVhZC5cbiAgICpcbiAgICogQHJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBmb3JtYXQgb2YgdGhlIHRleHQgbm9kZS5cbiAgICovXG5cblxuICBnZXRGb3JtYXQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19mb3JtYXQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSAzMi1iaXQgaW50ZWdlciB0aGF0IHJlcHJlc2VudHMgdGhlIFRleHREZXRhaWxUeXBlcyBjdXJyZW50bHkgYXBwbGllZCB0byB0aGVcbiAgICogVGV4dE5vZGUuIFlvdSBwcm9iYWJseSBkb24ndCB3YW50IHRvIHVzZSB0aGlzIG1ldGhvZCBkaXJlY3RseSAtIGNvbnNpZGVyIHVzaW5nIFRleHROb2RlLmlzRGlyZWN0aW9ubGVzc1xuICAgKiBvciBUZXh0Tm9kZS5pc1VubWVyZ2VhYmxlIGluc3RlYWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgZGV0YWlsIG9mIHRoZSB0ZXh0IG5vZGUuXG4gICAqL1xuXG5cbiAgZ2V0RGV0YWlsKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fZGV0YWlsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBtb2RlIChUZXh0TW9kZVR5cGUpIG9mIHRoZSBUZXh0Tm9kZSwgd2hpY2ggbWF5IGJlIFwibm9ybWFsXCIsIFwidG9rZW5cIiwgb3IgXCJzZWdtZW50ZWRcIlxuICAgKlxuICAgKiBAcmV0dXJucyBUZXh0TW9kZVR5cGUuXG4gICAqL1xuXG5cbiAgZ2V0TW9kZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gVEVYVF9UWVBFX1RPX01PREVbc2VsZi5fX21vZGVdO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZXMgY3VycmVudGx5IGFwcGxpZWQgdG8gdGhlIG5vZGUuIFRoaXMgaXMgYW5hbG9nb3VzIHRvIENTU1RleHQgaW4gdGhlIERPTS5cbiAgICpcbiAgICogQHJldHVybnMgQ1NTVGV4dC1saWtlIHN0cmluZyBvZiBzdHlsZXMgYXBwbGllZCB0byB0aGUgdW5kZXJseWluZyBET00gbm9kZS5cbiAgICovXG5cblxuICBnZXRTdHlsZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX3N0eWxlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGluIFwidG9rZW5cIiBtb2RlLiBUZXh0Tm9kZXMgaW4gdG9rZW4gbW9kZSBjYW4gYmUgbmF2aWdhdGVkIHRocm91Z2ggY2hhcmFjdGVyLWJ5LWNoYXJhY3RlclxuICAgKiB3aXRoIGEgUmFuZ2VTZWxlY3Rpb24sIGJ1dCBhcmUgZGVsZXRlZCBhcyBhIHNpbmdsZSBlbnRpdHkgKG5vdCBpbnZkaXZpZHVhbGx5IGJ5IGNoYXJhY3RlcikuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgaW4gdG9rZW4gbW9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cblxuXG4gIGlzVG9rZW4oKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19tb2RlID09PSBJU19UT0tFTjtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBMZXhpY2FsIGRldGVjdHMgdGhhdCBhbiBJTUUgb3Igb3RoZXIgM3JkLXBhcnR5IHNjcmlwdCBpcyBhdHRlbXB0aW5nIHRvXG4gICAqIG11dGF0ZSB0aGUgVGV4dE5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBpc0NvbXBvc2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5fX2tleSA9PT0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgaW4gXCJzZWdlbWVudGVkXCIgbW9kZS4gVGV4dE5vZGVzIGluIHNlZ2VtZW50ZWQgbW9kZSBjYW4gYmUgbmF2aWdhdGVkIHRocm91Z2ggY2hhcmFjdGVyLWJ5LWNoYXJhY3RlclxuICAgKiB3aXRoIGEgUmFuZ2VTZWxlY3Rpb24sIGJ1dCBhcmUgZGVsZXRlZCBpbiBzcGFjZS1kZWxpbWl0ZWQgXCJzZWdtZW50c1wiLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGluIHNlZ21lbnRlZCBtb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgaXNTZWdtZW50ZWQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19tb2RlID09PSBJU19TRUdNRU5URUQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgXCJkaXJlY3Rpb25sZXNzXCIuIERpcmVjdGlvbmxlc3Mgbm9kZXMgZG9uJ3QgcmVzcGVjdCBjaGFuZ2VzIGJldHdlZW4gUlRMIGFuZCBMVFIgbW9kZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgZGlyZWN0aW9ubGVzcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cblxuXG4gIGlzRGlyZWN0aW9ubGVzcygpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gKHNlbGYuX19kZXRhaWwgJiBJU19ESVJFQ1RJT05MRVNTKSAhPT0gMDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyB1bm1lcmdlYWJsZS4gSW4gc29tZSBzY2VuYXJpb3MsIExleGljYWwgdHJpZXMgdG8gbWVyZ2VcbiAgICogYWRqYWNlbnQgVGV4dE5vZGVzIGludG8gYSBzaW5nbGUgVGV4dE5vZGUuIElmIGEgVGV4dE5vZGUgaXMgdW5tZXJnZWFibGUsIHRoaXMgd29uJ3QgaGFwcGVuLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIHVubWVyZ2VhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgaXNVbm1lcmdlYWJsZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gKHNlbGYuX19kZXRhaWwgJiBJU19VTk1FUkdFQUJMRSkgIT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaGFzIHRoZSBwcm92aWRlZCBmb3JtYXQgYXBwbGllZC4gVXNlIHRoaXMgd2l0aCB0aGUgaHVtYW4tcmVhZGFibGUgVGV4dEZvcm1hdFR5cGVcbiAgICogc3RyaW5nIHZhbHVlcyB0byBnZXQgdGhlIGZvcm1hdCBvZiBhIFRleHROb2RlLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSBUZXh0Rm9ybWF0VHlwZSB0byBjaGVjayBmb3IuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaGFzIHRoZSBwcm92aWRlZCBmb3JtYXQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBoYXNGb3JtYXQodHlwZSkge1xuICAgIGNvbnN0IGZvcm1hdEZsYWcgPSBURVhUX1RZUEVfVE9fRk9STUFUW3R5cGVdO1xuICAgIHJldHVybiAodGhpcy5nZXRGb3JtYXQoKSAmIGZvcm1hdEZsYWcpICE9PSAwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIHNpbXBsZSB0ZXh0LiBTaW1wbGUgdGV4dCBpcyBkZWZpbmVkIGFzIGEgVGV4dE5vZGUgdGhhdCBoYXMgdGhlIHN0cmluZyB0eXBlIFwidGV4dFwiXG4gICAqIChpLmUuLCBub3QgYSBzdWJjbGFzcykgYW5kIGhhcyBubyBtb2RlIGFwcGxpZWQgdG8gaXQgKGkuZS4sIG5vdCBzZWdtZW50ZWQgb3IgdG9rZW4pLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIHNpbXBsZSB0ZXh0LCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgaXNTaW1wbGVUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9fdHlwZSA9PT0gJ3RleHQnICYmIHRoaXMuX19tb2RlID09PSAwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGUgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBub2RlLlxuICAgKi9cblxuXG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fdGV4dDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZm9ybWF0IGZsYWdzIGFwcGxpZWQgdG8gdGhlIG5vZGUgYXMgYSAzMi1iaXQgaW50ZWdlci5cbiAgICpcbiAgICogQHJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBUZXh0Rm9ybWF0VHlwZXMgYXBwbGllZCB0byB0aGUgbm9kZS5cbiAgICovXG5cblxuICBnZXRGb3JtYXRGbGFncyh0eXBlLCBhbGlnbldpdGhGb3JtYXQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBmb3JtYXQgPSBzZWxmLl9fZm9ybWF0O1xuICAgIHJldHVybiB0b2dnbGVUZXh0Rm9ybWF0VHlwZShmb3JtYXQsIHR5cGUsIGFsaWduV2l0aEZvcm1hdCk7XG4gIH0gLy8gVmlld1xuXG5cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuX19mb3JtYXQ7XG4gICAgY29uc3Qgb3V0ZXJUYWcgPSBnZXRFbGVtZW50T3V0ZXJUYWcodGhpcywgZm9ybWF0KTtcbiAgICBjb25zdCBpbm5lclRhZyA9IGdldEVsZW1lbnRJbm5lclRhZyh0aGlzLCBmb3JtYXQpO1xuICAgIGNvbnN0IHRhZyA9IG91dGVyVGFnID09PSBudWxsID8gaW5uZXJUYWcgOiBvdXRlclRhZztcbiAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgbGV0IGlubmVyRE9NID0gZG9tO1xuXG4gICAgaWYgKG91dGVyVGFnICE9PSBudWxsKSB7XG4gICAgICBpbm5lckRPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaW5uZXJUYWcpO1xuICAgICAgZG9tLmFwcGVuZENoaWxkKGlubmVyRE9NKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5fX3RleHQ7XG4gICAgY3JlYXRlVGV4dElubmVyRE9NKGlubmVyRE9NLCB0aGlzLCBpbm5lclRhZywgZm9ybWF0LCB0ZXh0LCBjb25maWcpO1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5fX3N0eWxlO1xuXG4gICAgaWYgKHN0eWxlICE9PSAnJykge1xuICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tO1xuICB9XG5cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIGNvbnN0IG5leHRUZXh0ID0gdGhpcy5fX3RleHQ7XG4gICAgY29uc3QgcHJldkZvcm1hdCA9IHByZXZOb2RlLl9fZm9ybWF0O1xuICAgIGNvbnN0IG5leHRGb3JtYXQgPSB0aGlzLl9fZm9ybWF0O1xuICAgIGNvbnN0IHByZXZPdXRlclRhZyA9IGdldEVsZW1lbnRPdXRlclRhZyh0aGlzLCBwcmV2Rm9ybWF0KTtcbiAgICBjb25zdCBuZXh0T3V0ZXJUYWcgPSBnZXRFbGVtZW50T3V0ZXJUYWcodGhpcywgbmV4dEZvcm1hdCk7XG4gICAgY29uc3QgcHJldklubmVyVGFnID0gZ2V0RWxlbWVudElubmVyVGFnKHRoaXMsIHByZXZGb3JtYXQpO1xuICAgIGNvbnN0IG5leHRJbm5lclRhZyA9IGdldEVsZW1lbnRJbm5lclRhZyh0aGlzLCBuZXh0Rm9ybWF0KTtcbiAgICBjb25zdCBwcmV2VGFnID0gcHJldk91dGVyVGFnID09PSBudWxsID8gcHJldklubmVyVGFnIDogcHJldk91dGVyVGFnO1xuICAgIGNvbnN0IG5leHRUYWcgPSBuZXh0T3V0ZXJUYWcgPT09IG51bGwgPyBuZXh0SW5uZXJUYWcgOiBuZXh0T3V0ZXJUYWc7XG5cbiAgICBpZiAocHJldlRhZyAhPT0gbmV4dFRhZykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByZXZPdXRlclRhZyA9PT0gbmV4dE91dGVyVGFnICYmIHByZXZJbm5lclRhZyAhPT0gbmV4dElubmVyVGFnKSB7XG4gICAgICAvLyBzaG91bGQgYWx3YXlzIGJlIGFuIGVsZW1lbnRcbiAgICAgIGNvbnN0IHByZXZJbm5lckRPTSA9IGRvbS5maXJzdENoaWxkO1xuXG4gICAgICBpZiAocHJldklubmVyRE9NID09IG51bGwpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKGB1cGRhdGVET006IHByZXZJbm5lckRPTSBpcyBudWxsIG9yIHVuZGVmaW5lZGApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5leHRJbm5lckRPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmV4dElubmVyVGFnKTtcbiAgICAgIGNyZWF0ZVRleHRJbm5lckRPTShuZXh0SW5uZXJET00sIHRoaXMsIG5leHRJbm5lclRhZywgbmV4dEZvcm1hdCwgbmV4dFRleHQsIGNvbmZpZyk7XG4gICAgICBkb20ucmVwbGFjZUNoaWxkKG5leHRJbm5lckRPTSwgcHJldklubmVyRE9NKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgaW5uZXJET00gPSBkb207XG5cbiAgICBpZiAobmV4dE91dGVyVGFnICE9PSBudWxsKSB7XG4gICAgICBpZiAocHJldk91dGVyVGFnICE9PSBudWxsKSB7XG4gICAgICAgIGlubmVyRE9NID0gZG9tLmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgaWYgKGlubmVyRE9NID09IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgdXBkYXRlRE9NOiBpbm5lckRPTSBpcyBudWxsIG9yIHVuZGVmaW5lZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNldFRleHRDb250ZW50KG5leHRUZXh0LCBpbm5lckRPTSwgdGhpcyk7XG4gICAgY29uc3QgdGhlbWUgPSBjb25maWcudGhlbWU7IC8vIEFwcGx5IHRoZW1lIGNsYXNzIG5hbWVzXG5cbiAgICBjb25zdCB0ZXh0Q2xhc3NOYW1lcyA9IHRoZW1lLnRleHQ7XG5cbiAgICBpZiAodGV4dENsYXNzTmFtZXMgIT09IHVuZGVmaW5lZCAmJiBwcmV2Rm9ybWF0ICE9PSBuZXh0Rm9ybWF0KSB7XG4gICAgICBzZXRUZXh0VGhlbWVDbGFzc05hbWVzKG5leHRJbm5lclRhZywgcHJldkZvcm1hdCwgbmV4dEZvcm1hdCwgaW5uZXJET00sIHRleHRDbGFzc05hbWVzKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2U3R5bGUgPSBwcmV2Tm9kZS5fX3N0eWxlO1xuICAgIGNvbnN0IG5leHRTdHlsZSA9IHRoaXMuX19zdHlsZTtcblxuICAgIGlmIChwcmV2U3R5bGUgIT09IG5leHRTdHlsZSkge1xuICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBuZXh0U3R5bGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJyN0ZXh0JzogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRET01Ob2RlLFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBiOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0QnJpbmdBdHRlbnRpb25Ub0VsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIGNvZGU6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgZW06ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaTogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBzOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHNwYW46ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRTcGFuRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgc3Ryb25nOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHN1YjogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBzdXA6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgdTogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZVRleHROb2RlKHNlcmlhbGl6ZWROb2RlLnRleHQpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXREZXRhaWwoc2VyaWFsaXplZE5vZGUuZGV0YWlsKTtcbiAgICBub2RlLnNldE1vZGUoc2VyaWFsaXplZE5vZGUubW9kZSk7XG4gICAgbm9kZS5zZXRTdHlsZShzZXJpYWxpemVkTm9kZS5zdHlsZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0gLy8gVGhpcyBpbXByb3ZlcyBMZXhpY2FsJ3MgYmFzaWMgdGV4dCBvdXRwdXQgaW4gY29weStwYXN0ZSBwbHVzXG4gIC8vIGZvciBoZWFkbGVzcyBtb2RlIHdoZXJlIHBlb3BsZSBtaWdodCB1c2UgTGV4aWNhbCB0byBnZW5lcmF0ZVxuICAvLyBIVE1MIGNvbnRlbnQgYW5kIG5vdCBoYXZlIHRoZSBhYmlsaXR5IHRvIHVzZSBDU1MgY2xhc3Nlcy5cblxuXG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBsZXQge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTsgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gcHJvcGVybHkgYWRkIHN1cHBvcnQgZm9yIG1vc3QgY2xpZW50cyxcbiAgICAvLyBldmVuIGlmIGl0J3Mgc2VtYW50aWNhbGx5IGluY29ycmVjdCB0byBoYXZlIHRvIHJlc29ydCB0byB1c2luZ1xuICAgIC8vIDxiPiwgPHU+LCA8cz4sIDxpPiBlbGVtZW50cy5cblxuICAgIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5oYXNGb3JtYXQoJ2JvbGQnKSkge1xuICAgICAgICBlbGVtZW50ID0gd3JhcEVsZW1lbnRXaXRoKGVsZW1lbnQsICdiJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc0Zvcm1hdCgnaXRhbGljJykpIHtcbiAgICAgICAgZWxlbWVudCA9IHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCAnaScpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYXNGb3JtYXQoJ3N0cmlrZXRocm91Z2gnKSkge1xuICAgICAgICBlbGVtZW50ID0gd3JhcEVsZW1lbnRXaXRoKGVsZW1lbnQsICdzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc0Zvcm1hdCgndW5kZXJsaW5lJykpIHtcbiAgICAgICAgZWxlbWVudCA9IHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCAndScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRldGFpbDogdGhpcy5nZXREZXRhaWwoKSxcbiAgICAgIGZvcm1hdDogdGhpcy5nZXRGb3JtYXQoKSxcbiAgICAgIG1vZGU6IHRoaXMuZ2V0TW9kZSgpLFxuICAgICAgc3R5bGU6IHRoaXMuZ2V0U3R5bGUoKSxcbiAgICAgIHRleHQ6IHRoaXMuZ2V0VGV4dENvbnRlbnQoKSxcbiAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9IC8vIE11dGF0b3JzXG5cblxuICBzZWxlY3Rpb25UcmFuc2Zvcm0ocHJldlNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbm9kZSBmb3JtYXQgdG8gdGhlIHByb3ZpZGVkIFRleHRGb3JtYXRUeXBlIG9yIDMyLWJpdCBpbnRlZ2VyLiBOb3RlIHRoYXQgdGhlIFRleHRGb3JtYXRUeXBlXG4gICAqIHZlcnNpb24gb2YgdGhlIGFyZ3VtZW50IGNhbiBvbmx5IHNwZWNpZnkgb25lIGZvcm1hdCBhbmQgZG9pbmcgc28gd2lsbCByZW1vdmUgYWxsIG90aGVyIGZvcm1hdHMgdGhhdFxuICAgKiBtYXkgYmUgYXBwbGllZCB0byB0aGUgbm9kZS4gRm9yIHRvZ2dsaW5nIGJlaGF2aW9yLCBjb25zaWRlciB1c2luZyB7QGxpbmsgVGV4dE5vZGUudG9nZ2xlRm9ybWF0fVxuICAgKlxuICAgKiBAcGFyYW0gZm9ybWF0IC0gVGV4dEZvcm1hdFR5cGUgb3IgMzItYml0IGludGVnZXIgcmVwcmVzZW50aW5nIHRoZSBub2RlIGZvcm1hdC5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICogLy8gVE9ETyAwLjEyIFRoaXMgc2hvdWxkIGp1c3QgYmUgYSBgc3RyaW5nYC5cbiAgICovXG5cblxuICBzZXRGb3JtYXQoZm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fZm9ybWF0ID0gdHlwZW9mIGZvcm1hdCA9PT0gJ3N0cmluZycgPyBURVhUX1RZUEVfVE9fRk9STUFUW2Zvcm1hdF0gOiBmb3JtYXQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5vZGUgZGV0YWlsIHRvIHRoZSBwcm92aWRlZCBUZXh0RGV0YWlsVHlwZSBvciAzMi1iaXQgaW50ZWdlci4gTm90ZSB0aGF0IHRoZSBUZXh0RGV0YWlsVHlwZVxuICAgKiB2ZXJzaW9uIG9mIHRoZSBhcmd1bWVudCBjYW4gb25seSBzcGVjaWZ5IG9uZSBkZXRhaWwgdmFsdWUgYW5kIGRvaW5nIHNvIHdpbGwgcmVtb3ZlIGFsbCBvdGhlciBkZXRhaWwgdmFsdWVzIHRoYXRcbiAgICogbWF5IGJlIGFwcGxpZWQgdG8gdGhlIG5vZGUuIEZvciB0b2dnbGluZyBiZWhhdmlvciwgY29uc2lkZXIgdXNpbmcge0BsaW5rIFRleHROb2RlLnRvZ2dsZURpcmVjdGlvbmxlc3N9XG4gICAqIG9yIHtAbGluayBUZXh0Tm9kZS50b2dnbGVyVW5tZXJnZWFibGV9XG4gICAqXG4gICAqIEBwYXJhbSBkZXRhaWwgLSBUZXh0RGV0YWlsVHlwZSBvciAzMi1iaXQgaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIG5vZGUgZGV0YWlsLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKiAvLyBUT0RPIDAuMTIgVGhpcyBzaG91bGQganVzdCBiZSBhIGBzdHJpbmdgLlxuICAgKi9cblxuXG4gIHNldERldGFpbChkZXRhaWwpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19kZXRhaWwgPSB0eXBlb2YgZGV0YWlsID09PSAnc3RyaW5nJyA/IERFVEFJTF9UWVBFX1RPX0RFVEFJTFtkZXRhaWxdIDogZGV0YWlsO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub2RlIHN0eWxlIHRvIHRoZSBwcm92aWRlZCBDU1NUZXh0LWxpa2Ugc3RyaW5nLiBTZXQgdGhpcyBwcm9wZXJ0eSBhcyB5b3VcbiAgICogd291bGQgYW4gSFRNTEVsZW1lbnQgc3R5bGUgYXR0cmlidXRlIHRvIGFwcGx5IGlubGluZSBzdHlsZXMgdG8gdGhlIHVuZGVybHlpbmcgRE9NIEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBzdHlsZSAtIENTU1RleHQgdG8gYmUgYXBwbGllZCB0byB0aGUgdW5kZXJseWluZyBIVE1MRWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG5cblxuICBzZXRTdHlsZShzdHlsZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3N0eWxlID0gc3R5bGU7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIHByb3ZpZGVkIGZvcm1hdCB0byB0aGlzIFRleHROb2RlIGlmIGl0J3Mgbm90IHByZXNlbnQuIFJlbW92ZXMgaXQgaWYgaXQgaXMgcHJlc2VudC5cbiAgICogUHJlZmVyIHVzaW5nIHRoaXMgbWV0aG9kIHRvIHR1cm4gc3BlY2lmaWMgZm9ybWF0cyBvbiBhbmQgb2ZmLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSAtIFRleHRGb3JtYXRUeXBlIHRvIHRvZ2dsZS5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG5cblxuICB0b2dnbGVGb3JtYXQodHlwZSkge1xuICAgIGNvbnN0IGZvcm1hdEZsYWcgPSBURVhUX1RZUEVfVE9fRk9STUFUW3R5cGVdO1xuICAgIHJldHVybiB0aGlzLnNldEZvcm1hdCh0aGlzLmdldEZvcm1hdCgpIF4gZm9ybWF0RmxhZyk7XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGRpcmVjdGlvbmxlc3MgZGV0YWlsIHZhbHVlIG9mIHRoZSBub2RlLiBQcmVmZXIgdXNpbmcgdGhpcyBtZXRob2Qgb3ZlciBzZXREZXRhaWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqL1xuXG5cbiAgdG9nZ2xlRGlyZWN0aW9ubGVzcygpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19kZXRhaWwgXj0gSVNfRElSRUNUSU9OTEVTUztcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgdW5tZXJnZWFibGUgZGV0YWlsIHZhbHVlIG9mIHRoZSBub2RlLiBQcmVmZXIgdXNpbmcgdGhpcyBtZXRob2Qgb3ZlciBzZXREZXRhaWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqL1xuXG5cbiAgdG9nZ2xlVW5tZXJnZWFibGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fZGV0YWlsIF49IElTX1VOTUVSR0VBQkxFO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtb2RlIG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cblxuXG4gIHNldE1vZGUodHlwZSkge1xuICAgIGNvbnN0IG1vZGUgPSBURVhUX01PREVfVE9fVFlQRVt0eXBlXTtcblxuICAgIGlmICh0aGlzLl9fbW9kZSA9PT0gbW9kZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fbW9kZSA9IG1vZGU7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleHQgY29udGVudCBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHRleHQgLSB0aGUgc3RyaW5nIHRvIHNldCBhcyB0aGUgdGV4dCB2YWx1ZSBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG5cblxuICBzZXRUZXh0Q29udGVudCh0ZXh0KSB7XG4gICAgaWYgKHRoaXMuX190ZXh0ID09PSB0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX190ZXh0ID0gdGV4dDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBMZXhpY2FsIHNlbGVjdGlvbiB0byBiZSBhIFJhbmdlU2VsZWN0aW9uIHdpdGggYW5jaG9yIGFuZCBmb2N1cyBvbiB0aGlzIFRleHROb2RlIGF0IHRoZSBwcm92aWRlZCBvZmZzZXRzLlxuICAgKlxuICAgKiBAcGFyYW0gX2FuY2hvck9mZnNldCAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIFNlbGVjdGlvbiBhbmNob3Igd2lsbCBiZSBwbGFjZWQuXG4gICAqIEBwYXJhbSBfZm9jdXNPZmZzZXQgLSB0aGUgb2Zmc2V0IGF0IHdoaWNoIHRoZSBTZWxlY3Rpb24gZm9jdXMgd2lsbCBiZSBwbGFjZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBuZXcgUmFuZ2VTZWxlY3Rpb24uXG4gICAqL1xuXG5cbiAgc2VsZWN0KF9hbmNob3JPZmZzZXQsIF9mb2N1c09mZnNldCkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGxldCBhbmNob3JPZmZzZXQgPSBfYW5jaG9yT2Zmc2V0O1xuICAgIGxldCBmb2N1c09mZnNldCA9IF9mb2N1c09mZnNldDtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3QgdGV4dCA9IHRoaXMuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBjb25zdCBrZXkgPSB0aGlzLl9fa2V5O1xuXG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgbGFzdE9mZnNldCA9IHRleHQubGVuZ3RoO1xuXG4gICAgICBpZiAoYW5jaG9yT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW5jaG9yT2Zmc2V0ID0gbGFzdE9mZnNldDtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvY3VzT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9jdXNPZmZzZXQgPSBsYXN0T2Zmc2V0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhbmNob3JPZmZzZXQgPSAwO1xuICAgICAgZm9jdXNPZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGludGVybmFsTWFrZVJhbmdlU2VsZWN0aW9uKGtleSwgYW5jaG9yT2Zmc2V0LCBrZXksIGZvY3VzT2Zmc2V0LCAndGV4dCcsICd0ZXh0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG5cbiAgICAgIGlmIChjb21wb3NpdGlvbktleSA9PT0gc2VsZWN0aW9uLmFuY2hvci5rZXkgfHwgY29tcG9zaXRpb25LZXkgPT09IHNlbGVjdGlvbi5mb2N1cy5rZXkpIHtcbiAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KGtleSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKHRoaXMsIGFuY2hvck9mZnNldCwgdGhpcywgZm9jdXNPZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgdGhlIHByb3ZpZGVkIHRleHQgaW50byB0aGlzIFRleHROb2RlIGF0IHRoZSBwcm92aWRlZCBvZmZzZXQsIGRlbGV0aW5nIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICAgKiBzcGVjaWZpZWQuIENhbiBvcHRpb25hbGx5IGNhbGN1bGF0ZSBhIG5ldyBzZWxlY3Rpb24gYWZ0ZXIgdGhlIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cbiAgICpcbiAgICogQHBhcmFtIG9mZnNldCAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIHNwbGljZSBvcGVyYXRpb24gc2hvdWxkIGJlZ2luLlxuICAgKiBAcGFyYW0gZGVsQ291bnQgLSB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gZGVsZXRlLCBzdGFydGluZyBmcm9tIHRoZSBvZmZzZXQuXG4gICAqIEBwYXJhbSBuZXdUZXh0IC0gdGhlIHRleHQgdG8gaW5zZXJ0IGludG8gdGhlIFRleHROb2RlIGF0IHRoZSBvZmZzZXQuXG4gICAqIEBwYXJhbSBtb3ZlU2VsZWN0aW9uIC0gb3B0aW9uYWwsIHdoZXRoZXIgb3Igbm90IHRvIG1vdmUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGluc2VydGVkIHN1YnN0cmluZy5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG5cblxuICBzcGxpY2VUZXh0KG9mZnNldCwgZGVsQ291bnQsIG5ld1RleHQsIG1vdmVTZWxlY3Rpb24pIHtcbiAgICBjb25zdCB3cml0YWJsZVNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3QgdGV4dCA9IHdyaXRhYmxlU2VsZi5fX3RleHQ7XG4gICAgY29uc3QgaGFuZGxlZFRleHRMZW5ndGggPSBuZXdUZXh0Lmxlbmd0aDtcbiAgICBsZXQgaW5kZXggPSBvZmZzZXQ7XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IGhhbmRsZWRUZXh0TGVuZ3RoICsgaW5kZXg7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChtb3ZlU2VsZWN0aW9uICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IG5ld09mZnNldCA9IG9mZnNldCArIGhhbmRsZWRUZXh0TGVuZ3RoO1xuICAgICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2Uod3JpdGFibGVTZWxmLCBuZXdPZmZzZXQsIHdyaXRhYmxlU2VsZiwgbmV3T2Zmc2V0KTtcbiAgICB9XG5cbiAgICBjb25zdCB1cGRhdGVkVGV4dCA9IHRleHQuc2xpY2UoMCwgaW5kZXgpICsgbmV3VGV4dCArIHRleHQuc2xpY2UoaW5kZXggKyBkZWxDb3VudCk7XG4gICAgd3JpdGFibGVTZWxmLl9fdGV4dCA9IHVwZGF0ZWRUZXh0O1xuICAgIHJldHVybiB3cml0YWJsZVNlbGY7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRlbiBieSBUZXh0Tm9kZSBzdWJjbGFzc2VzIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yIG9mIHRob3NlIG5vZGVzXG4gICAqIHdoZW4gYSB1c2VyIGV2ZW50IHdvdWxkIGNhdXNlIHRleHQgdG8gYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZW0gaW4gdGhlIGVkaXRvci4gSWYgdHJ1ZSwgTGV4aWNhbCB3aWxsIGF0dGVtcHRcbiAgICogdG8gaW5zZXJ0IHRleHQgaW50byB0aGlzIG5vZGUuIElmIGZhbHNlLCBpdCB3aWxsIGluc2VydCB0aGUgdGV4dCBpbiBhIG5ldyBzaWJsaW5nIG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGV4dCBjYW4gYmUgaW5zZXJ0ZWQgYmVmb3JlIHRoZSBub2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuIGJ5IFRleHROb2RlIHN1YmNsYXNzZXMgdG8gY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgdGhvc2Ugbm9kZXNcbiAgICogd2hlbiBhIHVzZXIgZXZlbnQgd291bGQgY2F1c2UgdGV4dCB0byBiZSBpbnNlcnRlZCBhZnRlciB0aGVtIGluIHRoZSBlZGl0b3IuIElmIHRydWUsIExleGljYWwgd2lsbCBhdHRlbXB0XG4gICAqIHRvIGluc2VydCB0ZXh0IGludG8gdGhpcyBub2RlLiBJZiBmYWxzZSwgaXQgd2lsbCBpbnNlcnQgdGhlIHRleHQgaW4gYSBuZXcgc2libGluZyBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRleHQgY2FuIGJlIGluc2VydGVkIGFmdGVyIHRoZSBub2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgY2FuSW5zZXJ0VGV4dEFmdGVyKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTcGxpdHMgdGhpcyBUZXh0Tm9kZSBhdCB0aGUgcHJvdmlkZWQgY2hhcmFjdGVyIG9mZnNldHMsIGZvcm1pbmcgbmV3IFRleHROb2RlcyBmcm9tIHRoZSBzdWJzdHJpbmdzXG4gICAqIGZvcm1lZCBieSB0aGUgc3BsaXQsIGFuZCBpbnNlcnRpbmcgdGhvc2UgbmV3IFRleHROb2RlcyBpbnRvIHRoZSBlZGl0b3IsIHJlcGxhY2luZyB0aGUgb25lIHRoYXQgd2FzIHNwbGl0LlxuICAgKlxuICAgKiBAcGFyYW0gc3BsaXRPZmZzZXRzIC0gcmVzdCBwYXJhbSBvZiB0aGUgdGV4dCBjb250ZW50IGNoYXJhY3RlciBvZmZzZXRzIGF0IHdoaWNoIHRoaXMgbm9kZSBzaG91bGQgYmUgc3BsaXQuXG4gICAqXG4gICAqIEByZXR1cm5zIGFuIEFycmF5IGNvbnRhaW5pbmcgdGhlIG5ld2x5LWNyZWF0ZWQgVGV4dE5vZGVzLlxuICAgKi9cblxuXG4gIHNwbGl0VGV4dCguLi5zcGxpdE9mZnNldHMpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCB0ZXh0Q29udGVudCA9IHNlbGYuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBjb25zdCBrZXkgPSBzZWxmLl9fa2V5O1xuICAgIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG4gICAgY29uc3Qgb2Zmc2V0c1NldCA9IG5ldyBTZXQoc3BsaXRPZmZzZXRzKTtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGNvbnN0IHRleHRMZW5ndGggPSB0ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgbGV0IHN0cmluZyA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0TGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdHJpbmcgIT09ICcnICYmIG9mZnNldHNTZXQuaGFzKGkpKSB7XG4gICAgICAgIHBhcnRzLnB1c2goc3RyaW5nKTtcbiAgICAgICAgc3RyaW5nID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyArPSB0ZXh0Q29udGVudFtpXTtcbiAgICB9XG5cbiAgICBpZiAoc3RyaW5nICE9PSAnJykge1xuICAgICAgcGFydHMucHVzaChzdHJpbmcpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnRzTGVuZ3RoID0gcGFydHMubGVuZ3RoO1xuXG4gICAgaWYgKHBhcnRzTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChwYXJ0c1swXSA9PT0gdGV4dENvbnRlbnQpIHtcbiAgICAgIHJldHVybiBbc2VsZl07XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RQYXJ0ID0gcGFydHNbMF07XG4gICAgY29uc3QgcGFyZW50ID0gc2VsZi5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgbGV0IHdyaXRhYmxlTm9kZTtcbiAgICBjb25zdCBmb3JtYXQgPSBzZWxmLmdldEZvcm1hdCgpO1xuICAgIGNvbnN0IHN0eWxlID0gc2VsZi5nZXRTdHlsZSgpO1xuICAgIGNvbnN0IGRldGFpbCA9IHNlbGYuX19kZXRhaWw7XG4gICAgbGV0IGhhc1JlcGxhY2VkU2VsZiA9IGZhbHNlO1xuXG4gICAgaWYgKHNlbGYuaXNTZWdtZW50ZWQoKSkge1xuICAgICAgLy8gQ3JlYXRlIGEgbmV3IFRleHROb2RlXG4gICAgICB3cml0YWJsZU5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoZmlyc3RQYXJ0KTtcbiAgICAgIHdyaXRhYmxlTm9kZS5fX2Zvcm1hdCA9IGZvcm1hdDtcbiAgICAgIHdyaXRhYmxlTm9kZS5fX3N0eWxlID0gc3R5bGU7XG4gICAgICB3cml0YWJsZU5vZGUuX19kZXRhaWwgPSBkZXRhaWw7XG4gICAgICBoYXNSZXBsYWNlZFNlbGYgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgdGhlIGZpcnN0IHBhcnQsIHVwZGF0ZSB0aGUgZXhpc3Rpbmcgbm9kZVxuICAgICAgd3JpdGFibGVOb2RlID0gc2VsZi5nZXRXcml0YWJsZSgpO1xuICAgICAgd3JpdGFibGVOb2RlLl9fdGV4dCA9IGZpcnN0UGFydDtcbiAgICB9IC8vIEhhbmRsZSBzZWxlY3Rpb25cblxuXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpOyAvLyBUaGVuIGhhbmRsZSBhbGwgb3RoZXIgcGFydHNcblxuICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBbd3JpdGFibGVOb2RlXTtcbiAgICBsZXQgdGV4dFNpemUgPSBmaXJzdFBhcnQubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwYXJ0c0xlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBjb25zdCBwYXJ0U2l6ZSA9IHBhcnQubGVuZ3RoO1xuICAgICAgY29uc3Qgc2libGluZyA9ICRjcmVhdGVUZXh0Tm9kZShwYXJ0KS5nZXRXcml0YWJsZSgpO1xuICAgICAgc2libGluZy5fX2Zvcm1hdCA9IGZvcm1hdDtcbiAgICAgIHNpYmxpbmcuX19zdHlsZSA9IHN0eWxlO1xuICAgICAgc2libGluZy5fX2RldGFpbCA9IGRldGFpbDtcbiAgICAgIGNvbnN0IHNpYmxpbmdLZXkgPSBzaWJsaW5nLl9fa2V5O1xuICAgICAgY29uc3QgbmV4dFRleHRTaXplID0gdGV4dFNpemUgKyBwYXJ0U2l6ZTtcblxuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG5cbiAgICAgICAgaWYgKGFuY2hvci5rZXkgPT09IGtleSAmJiBhbmNob3IudHlwZSA9PT0gJ3RleHQnICYmIGFuY2hvci5vZmZzZXQgPiB0ZXh0U2l6ZSAmJiBhbmNob3Iub2Zmc2V0IDw9IG5leHRUZXh0U2l6ZSkge1xuICAgICAgICAgIGFuY2hvci5rZXkgPSBzaWJsaW5nS2V5O1xuICAgICAgICAgIGFuY2hvci5vZmZzZXQgLT0gdGV4dFNpemU7XG4gICAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb2N1cy5rZXkgPT09IGtleSAmJiBmb2N1cy50eXBlID09PSAndGV4dCcgJiYgZm9jdXMub2Zmc2V0ID4gdGV4dFNpemUgJiYgZm9jdXMub2Zmc2V0IDw9IG5leHRUZXh0U2l6ZSkge1xuICAgICAgICAgIGZvY3VzLmtleSA9IHNpYmxpbmdLZXk7XG4gICAgICAgICAgZm9jdXMub2Zmc2V0IC09IHRleHRTaXplO1xuICAgICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvc2l0aW9uS2V5ID09PSBrZXkpIHtcbiAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KHNpYmxpbmdLZXkpO1xuICAgICAgfVxuXG4gICAgICB0ZXh0U2l6ZSA9IG5leHRUZXh0U2l6ZTtcbiAgICAgIHNwbGl0Tm9kZXMucHVzaChzaWJsaW5nKTtcbiAgICB9IC8vIEluc2VydCB0aGUgbm9kZXMgaW50byB0aGUgcGFyZW50J3MgY2hpbGRyZW5cblxuXG4gICAgaW50ZXJuYWxNYXJrU2libGluZ3NBc0RpcnR5KHRoaXMpO1xuICAgIGNvbnN0IHdyaXRhYmxlUGFyZW50ID0gcGFyZW50LmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3QgaW5zZXJ0aW9uSW5kZXggPSB0aGlzLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG5cbiAgICBpZiAoaGFzUmVwbGFjZWRTZWxmKSB7XG4gICAgICB3cml0YWJsZVBhcmVudC5zcGxpY2UoaW5zZXJ0aW9uSW5kZXgsIDAsIHNwbGl0Tm9kZXMpO1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3JpdGFibGVQYXJlbnQuc3BsaWNlKGluc2VydGlvbkluZGV4LCAxLCBzcGxpdE5vZGVzKTtcbiAgICB9XG5cbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgJHVwZGF0ZUVsZW1lbnRTZWxlY3Rpb25PbkNyZWF0ZURlbGV0ZU5vZGUoc2VsZWN0aW9uLCBwYXJlbnQsIGluc2VydGlvbkluZGV4LCBwYXJ0c0xlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBzcGxpdE5vZGVzO1xuICB9XG4gIC8qKlxuICAgKiBNZXJnZXMgdGhlIHRhcmdldCBUZXh0Tm9kZSBpbnRvIHRoaXMgVGV4dE5vZGUsIHJlbW92aW5nIHRoZSB0YXJnZXQgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHRhcmdldCAtIHRoZSBUZXh0Tm9kZSB0byBtZXJnZSBpbnRvIHRoaXMgb25lLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cblxuXG4gIG1lcmdlV2l0aFNpYmxpbmcodGFyZ2V0KSB7XG4gICAgY29uc3QgaXNCZWZvcmUgPSB0YXJnZXQgPT09IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICBpZiAoIWlzQmVmb3JlICYmIHRhcmdldCAhPT0gdGhpcy5nZXROZXh0U2libGluZygpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBtZXJnZVdpdGhTaWJsaW5nOiBzaWJsaW5nIG11c3QgYmUgYSBwcmV2aW91cyBvciBuZXh0IHNpYmxpbmdgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSB0aGlzLl9fa2V5O1xuICAgIGNvbnN0IHRhcmdldEtleSA9IHRhcmdldC5fX2tleTtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5fX3RleHQ7XG4gICAgY29uc3QgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG5cbiAgICBpZiAoY29tcG9zaXRpb25LZXkgPT09IHRhcmdldEtleSkge1xuICAgICAgJHNldENvbXBvc2l0aW9uS2V5KGtleSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcblxuICAgICAgaWYgKGFuY2hvciAhPT0gbnVsbCAmJiBhbmNob3Iua2V5ID09PSB0YXJnZXRLZXkpIHtcbiAgICAgICAgYWRqdXN0UG9pbnRPZmZzZXRGb3JNZXJnZWRTaWJsaW5nKGFuY2hvciwgaXNCZWZvcmUsIGtleSwgdGFyZ2V0LCB0ZXh0TGVuZ3RoKTtcbiAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvY3VzICE9PSBudWxsICYmIGZvY3VzLmtleSA9PT0gdGFyZ2V0S2V5KSB7XG4gICAgICAgIGFkanVzdFBvaW50T2Zmc2V0Rm9yTWVyZ2VkU2libGluZyhmb2N1cywgaXNCZWZvcmUsIGtleSwgdGFyZ2V0LCB0ZXh0TGVuZ3RoKTtcbiAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRUZXh0ID0gdGFyZ2V0Ll9fdGV4dDtcbiAgICBjb25zdCBuZXdUZXh0ID0gaXNCZWZvcmUgPyB0YXJnZXRUZXh0ICsgdGV4dCA6IHRleHQgKyB0YXJnZXRUZXh0O1xuICAgIHRoaXMuc2V0VGV4dENvbnRlbnQobmV3VGV4dCk7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICByZXR1cm4gd3JpdGFibGVTZWxmO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZSBvdmVycmlkZW4gYnkgVGV4dE5vZGUgc3ViY2xhc3NlcyB0byBjb250cm9sIHRoZSBiZWhhdmlvciBvZiB0aG9zZSBub2Rlc1xuICAgKiB3aGVuIHVzZWQgd2l0aCB0aGUgcmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eSBmdW5jdGlvbi4gSWYgeW91J3JlIHVzaW5nIHJlZ2lzdGVyTGV4aWNhbFRleHRFbnRpdHksIHRoZVxuICAgKiBub2RlIGNsYXNzIHRoYXQgeW91IGNyZWF0ZSBhbmQgcmVwbGFjZSBtYXRjaGVkIHRleHQgd2l0aCBzaG91bGQgcmV0dXJuIHRydWUgZnJvbSB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyB0byBiZSB0cmVhdGVkIGFzIGEgXCJ0ZXh0IGVudGl0eVwiLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgaXNUZXh0RW50aXR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRTcGFuRWxlbWVudChkb21Ob2RlKSB7XG4gIC8vIGRvbU5vZGUgaXMgYSA8c3Bhbj4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICBjb25zdCBzcGFuID0gZG9tTm9kZTsgLy8gR29vZ2xlIERvY3MgdXNlcyBzcGFuIHRhZ3MgKyBmb250LXdlaWdodCBmb3IgYm9sZCB0ZXh0XG5cbiAgY29uc3QgaGFzQm9sZEZvbnRXZWlnaHQgPSBzcGFuLnN0eWxlLmZvbnRXZWlnaHQgPT09ICc3MDAnOyAvLyBHb29nbGUgRG9jcyB1c2VzIHNwYW4gdGFncyArIHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoIGZvciBzdHJpa2V0aHJvdWdoIHRleHRcblxuICBjb25zdCBoYXNMaW5ldGhyb3VnaFRleHREZWNvcmF0aW9uID0gc3Bhbi5zdHlsZS50ZXh0RGVjb3JhdGlvbiA9PT0gJ2xpbmUtdGhyb3VnaCc7IC8vIEdvb2dsZSBEb2NzIHVzZXMgc3BhbiB0YWdzICsgZm9udC1zdHlsZSBmb3IgaXRhbGljIHRleHRcblxuICBjb25zdCBoYXNJdGFsaWNGb250U3R5bGUgPSBzcGFuLnN0eWxlLmZvbnRTdHlsZSA9PT0gJ2l0YWxpYyc7IC8vIEdvb2dsZSBEb2NzIHVzZXMgc3BhbiB0YWdzICsgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZm9yIHVuZGVybGluZSB0ZXh0XG5cbiAgY29uc3QgaGFzVW5kZXJsaW5lVGV4dERlY29yYXRpb24gPSBzcGFuLnN0eWxlLnRleHREZWNvcmF0aW9uID09PSAndW5kZXJsaW5lJzsgLy8gR29vZ2xlIERvY3MgdXNlcyBzcGFuIHRhZ3MgKyB2ZXJ0aWNhbC1hbGlnbiB0byBzcGVjaWZ5IHN1YnNjcmlwdCBhbmQgc3VwZXJzY3JpcHRcblxuICBjb25zdCB2ZXJ0aWNhbEFsaWduID0gc3Bhbi5zdHlsZS52ZXJ0aWNhbEFsaWduO1xuICByZXR1cm4ge1xuICAgIGZvckNoaWxkOiBsZXhpY2FsTm9kZSA9PiB7XG4gICAgICBpZiAoISRpc1RleHROb2RlKGxleGljYWxOb2RlKSkge1xuICAgICAgICByZXR1cm4gbGV4aWNhbE5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNCb2xkRm9udFdlaWdodCkge1xuICAgICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoJ2JvbGQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0xpbmV0aHJvdWdoVGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgbGV4aWNhbE5vZGUudG9nZ2xlRm9ybWF0KCdzdHJpa2V0aHJvdWdoJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNJdGFsaWNGb250U3R5bGUpIHtcbiAgICAgICAgbGV4aWNhbE5vZGUudG9nZ2xlRm9ybWF0KCdpdGFsaWMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1VuZGVybGluZVRleHREZWNvcmF0aW9uKSB7XG4gICAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgndW5kZXJsaW5lJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJ0aWNhbEFsaWduID09PSAnc3ViJykge1xuICAgICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoJ3N1YnNjcmlwdCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodmVydGljYWxBbGlnbiA9PT0gJ3N1cGVyJykge1xuICAgICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoJ3N1cGVyc2NyaXB0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsZXhpY2FsTm9kZTtcbiAgICB9LFxuICAgIG5vZGU6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydEJyaW5nQXR0ZW50aW9uVG9FbGVtZW50KGRvbU5vZGUpIHtcbiAgLy8gZG9tTm9kZSBpcyBhIDxiPiBzaW5jZSB3ZSBtYXRjaGVkIGl0IGJ5IG5vZGVOYW1lXG4gIGNvbnN0IGIgPSBkb21Ob2RlOyAvLyBHb29nbGUgRG9jcyB3cmFwcyBhbGwgY29waWVkIEhUTUwgaW4gYSA8Yj4gd2l0aCBmb250LXdlaWdodCBub3JtYWxcblxuICBjb25zdCBoYXNOb3JtYWxGb250V2VpZ2h0ID0gYi5zdHlsZS5mb250V2VpZ2h0ID09PSAnbm9ybWFsJztcbiAgcmV0dXJuIHtcbiAgICBmb3JDaGlsZDogbGV4aWNhbE5vZGUgPT4ge1xuICAgICAgaWYgKCRpc1RleHROb2RlKGxleGljYWxOb2RlKSAmJiAhaGFzTm9ybWFsRm9udFdlaWdodCkge1xuICAgICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoJ2JvbGQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxleGljYWxOb2RlO1xuICAgIH0sXG4gICAgbm9kZTogbnVsbFxuICB9O1xufVxuXG5jb25zdCBwcmVQYXJlbnRDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIGlzTm9kZVByZShub2RlKSB7XG4gIHJldHVybiBub2RlLm5vZGVOYW1lID09PSAnUFJFJyB8fCBub2RlLm5vZGVUeXBlID09PSBET01fRUxFTUVOVF9UWVBFICYmIG5vZGUuc3R5bGUud2hpdGVTcGFjZS5zdGFydHNXaXRoKCdwcmUnKTtcbn1cblxuZnVuY3Rpb24gZmluZFBhcmVudFByZURPTU5vZGUobm9kZSkge1xuICBsZXQgY2FjaGVkO1xuICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICBjb25zdCB2aXNpdGVkID0gW25vZGVdO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgKGNhY2hlZCA9IHByZVBhcmVudENhY2hlLmdldChwYXJlbnQpKSA9PT0gdW5kZWZpbmVkICYmICFpc05vZGVQcmUocGFyZW50KSkge1xuICAgIHZpc2l0ZWQucHVzaChwYXJlbnQpO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0Tm9kZSA9IGNhY2hlZCA9PT0gdW5kZWZpbmVkID8gcGFyZW50IDogY2FjaGVkO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaXRlZC5sZW5ndGg7IGkrKykge1xuICAgIHByZVBhcmVudENhY2hlLnNldCh2aXNpdGVkW2ldLCByZXN1bHROb2RlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHROb2RlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VGV4dERPTU5vZGUoZG9tTm9kZSkge1xuICBjb25zdCBkb21Ob2RlXyA9IGRvbU5vZGU7XG4gIGNvbnN0IHBhcmVudERvbSA9IGRvbU5vZGUucGFyZW50RWxlbWVudDtcblxuICBpZiAoIShwYXJlbnREb20gIT09IG51bGwpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHBhcmVudEVsZW1lbnQgb2YgVGV4dCBub3QgdG8gYmUgbnVsbGApO1xuICB9XG5cbiAgbGV0IHRleHRDb250ZW50ID0gZG9tTm9kZV8udGV4dENvbnRlbnQgfHwgJyc7IC8vIE5vIGNvbGxhcHNlIGFuZCBwcmVzZXJ2ZSBzZWdtZW50IGJyZWFrIGZvciBwcmUsIHByZS13cmFwIGFuZCBwcmUtbGluZVxuXG4gIGlmIChmaW5kUGFyZW50UHJlRE9NTm9kZShkb21Ob2RlXykgIT09IG51bGwpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHRleHRDb250ZW50LnNwbGl0KC8oXFxyP1xcbnxcXHQpLyk7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJ0cy5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgIGlmIChwYXJ0ID09PSAnXFxuJyB8fCBwYXJ0ID09PSAnXFxyXFxuJykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVMaW5lQnJlYWtOb2RlKCkpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnXFx0Jykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVUYWJOb2RlKCkpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0ICE9PSAnJykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVUZXh0Tm9kZShwYXJ0KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IG5vZGVzXG4gICAgfTtcbiAgfVxuXG4gIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQucmVwbGFjZSgvXFxyP1xcbnxcXHQvZ20sICcgJykucmVwbGFjZSgnXFxyJywgJycpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcblxuICBpZiAodGV4dENvbnRlbnQgPT09ICcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgaWYgKHRleHRDb250ZW50WzBdID09PSAnICcpIHtcbiAgICAvLyBUcmF2ZXJzZSBiYWNrd2FyZCB3aGlsZSBpbiB0aGUgc2FtZSBsaW5lLiBJZiBjb250ZW50IGNvbnRhaW5zIG5ldyBsaW5lIG9yIHRhYiAtPiBwb250ZW50aWFsXG4gICAgLy8gZGVsZXRlLCBvdGhlciBlbGVtZW50cyBjYW4gYm9ycm93IGZyb20gdGhpcyBvbmUuIERlbGV0aW9uIGRlcGVuZHMgb24gd2hldGhlciBpdCdzIGFsc28gdGhlXG4gICAgLy8gbGFzdCBzcGFjZSAoc2VlIG5leHQgY29uZGl0aW9uOiB0ZXh0Q29udGVudFt0ZXh0Q29udGVudC5sZW5ndGggLSAxXSA9PT0gJyAnKSlcbiAgICBsZXQgcHJldmlvdXNUZXh0ID0gZG9tTm9kZV87XG4gICAgbGV0IGlzU3RhcnRPZkxpbmUgPSB0cnVlO1xuXG4gICAgd2hpbGUgKHByZXZpb3VzVGV4dCAhPT0gbnVsbCAmJiAocHJldmlvdXNUZXh0ID0gZmluZFRleHRJbkxpbmUocHJldmlvdXNUZXh0LCBmYWxzZSkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1RleHRDb250ZW50ID0gcHJldmlvdXNUZXh0LnRleHRDb250ZW50IHx8ICcnO1xuXG4gICAgICBpZiAocHJldmlvdXNUZXh0Q29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChwcmV2aW91c1RleHRDb250ZW50Lm1hdGNoKC8oPzpcXHN8XFxyP1xcbnxcXHQpJC8pKSB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzU3RhcnRPZkxpbmUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzU3RhcnRPZkxpbmUpIHtcbiAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRleHRDb250ZW50W3RleHRDb250ZW50Lmxlbmd0aCAtIDFdID09PSAnICcpIHtcbiAgICAvLyBUcmF2ZXJzZSBmb3J3YXJkIHdoaWxlIGluIHRoZSBzYW1lIGxpbmUsIHByZXNlcnZlIGlmIG5leHQgaW5saW5lIHdpbGwgcmVxdWlyZSBhIHNwYWNlXG4gICAgbGV0IG5leHRUZXh0ID0gZG9tTm9kZV87XG4gICAgbGV0IGlzRW5kT2ZMaW5lID0gdHJ1ZTtcblxuICAgIHdoaWxlIChuZXh0VGV4dCAhPT0gbnVsbCAmJiAobmV4dFRleHQgPSBmaW5kVGV4dEluTGluZShuZXh0VGV4dCwgdHJ1ZSkpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBuZXh0VGV4dENvbnRlbnQgPSAobmV4dFRleHQudGV4dENvbnRlbnQgfHwgJycpLnJlcGxhY2UoL15bXFxzfFxccj9cXG58XFx0XSsvLCAnJyk7XG5cbiAgICAgIGlmIChuZXh0VGV4dENvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICBpc0VuZE9mTGluZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNFbmRPZkxpbmUpIHtcbiAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgdGV4dENvbnRlbnQubGVuZ3RoIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRleHRDb250ZW50ID09PSAnJykge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZVRleHROb2RlKHRleHRDb250ZW50KVxuICB9O1xufVxuXG5jb25zdCBpbmxpbmVQYXJlbnRzID0gbmV3IFJlZ0V4cCgvXihhfGFiYnJ8YWNyb255bXxifGNpdGV8Y29kZXxkZWx8ZW18aXxpbnN8a2JkfGxhYmVsfG91dHB1dHxxfHJ1Ynl8c3xzYW1wfHNwYW58c3Ryb25nfHN1YnxzdXB8dGltZXx1fHR0fHZhcikkLywgJ2knKTtcblxuZnVuY3Rpb24gZmluZFRleHRJbkxpbmUodGV4dCwgZm9yd2FyZCkge1xuICBsZXQgbm9kZSA9IHRleHQ7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxldCBzaWJsaW5nO1xuXG4gICAgd2hpbGUgKChzaWJsaW5nID0gZm9yd2FyZCA/IG5vZGUubmV4dFNpYmxpbmcgOiBub2RlLnByZXZpb3VzU2libGluZykgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG5cbiAgICAgIGlmIChwYXJlbnRFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gcGFyZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICBub2RlID0gc2libGluZztcblxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBET01fRUxFTUVOVF9UWVBFKSB7XG4gICAgICBjb25zdCBkaXNwbGF5ID0gbm9kZS5zdHlsZS5kaXNwbGF5O1xuXG4gICAgICBpZiAoZGlzcGxheSA9PT0gJycgJiYgbm9kZS5ub2RlTmFtZS5tYXRjaChpbmxpbmVQYXJlbnRzKSA9PT0gbnVsbCB8fCBkaXNwbGF5ICE9PSAnJyAmJiAhZGlzcGxheS5zdGFydHNXaXRoKCdpbmxpbmUnKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgZGVzY2VuZGFudCA9IG5vZGU7XG5cbiAgICB3aGlsZSAoKGRlc2NlbmRhbnQgPSBmb3J3YXJkID8gbm9kZS5maXJzdENoaWxkIDogbm9kZS5sYXN0Q2hpbGQpICE9PSBudWxsKSB7XG4gICAgICBub2RlID0gZGVzY2VuZGFudDtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRE9NX1RFWFRfVFlQRSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLm5vZGVOYW1lID09PSAnQlInKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuY29uc3Qgbm9kZU5hbWVUb1RleHRGb3JtYXQgPSB7XG4gIGNvZGU6ICdjb2RlJyxcbiAgZW06ICdpdGFsaWMnLFxuICBpOiAnaXRhbGljJyxcbiAgczogJ3N0cmlrZXRocm91Z2gnLFxuICBzdHJvbmc6ICdib2xkJyxcbiAgc3ViOiAnc3Vic2NyaXB0JyxcbiAgc3VwOiAnc3VwZXJzY3JpcHQnLFxuICB1OiAndW5kZXJsaW5lJ1xufTtcblxuZnVuY3Rpb24gY29udmVydFRleHRGb3JtYXRFbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgZm9ybWF0ID0gbm9kZU5hbWVUb1RleHRGb3JtYXRbZG9tTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXTtcblxuICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvckNoaWxkOiBsZXhpY2FsTm9kZSA9PiB7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUobGV4aWNhbE5vZGUpICYmICFsZXhpY2FsTm9kZS5oYXNGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoZm9ybWF0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxleGljYWxOb2RlO1xuICAgIH0sXG4gICAgbm9kZTogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiAkY3JlYXRlVGV4dE5vZGUodGV4dCA9ICcnKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRleHROb2RlKHRleHQpKTtcbn1cbmZ1bmN0aW9uICRpc1RleHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUZXh0Tm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgVGFiTm9kZSBleHRlbmRzIFRleHROb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWInO1xuICB9XG5cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICBjb25zdCBuZXdOb2RlID0gbmV3IFRhYk5vZGUobm9kZS5fX2tleSk7IC8vIFRhYk5vZGUgX190ZXh0IGNhbiBiZSBlaXRoZXIgJ1xcdCcgb3IgJycuIGluc2VydFRleHQgd2lsbCByZW1vdmUgdGhlIGVtcHR5IE5vZGVcblxuICAgIG5ld05vZGUuX190ZXh0ID0gbm9kZS5fX3RleHQ7XG4gICAgbmV3Tm9kZS5fX2Zvcm1hdCA9IG5vZGUuX19mb3JtYXQ7XG4gICAgbmV3Tm9kZS5fX3N0eWxlID0gbm9kZS5fX3N0eWxlO1xuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoJ1xcdCcsIGtleSk7XG4gICAgdGhpcy5fX2RldGFpbCA9IElTX1VOTUVSR0VBQkxFO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWRUYWJOb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVUYWJOb2RlKCk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZFRhYk5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldFN0eWxlKHNlcmlhbGl6ZWRUYWJOb2RlLnN0eWxlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgdHlwZTogJ3RhYicsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIHNldFRleHRDb250ZW50KF90ZXh0KSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYFRhYk5vZGUgZG9lcyBub3Qgc3VwcG9ydCBzZXRUZXh0Q29udGVudGApO1xuICAgIH1cbiAgfVxuXG4gIHNldERldGFpbChfZGV0YWlsKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYFRhYk5vZGUgZG9lcyBub3Qgc3VwcG9ydCBzZXREZXRhaWxgKTtcbiAgICB9XG4gIH1cblxuICBzZXRNb2RlKF90eXBlKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYFRhYk5vZGUgZG9lcyBub3Qgc3VwcG9ydCBzZXRNb2RlYCk7XG4gICAgfVxuICB9XG5cbiAgY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJOb2RlKCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUYWJOb2RlKCkpO1xufVxuZnVuY3Rpb24gJGlzVGFiTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGFiTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY2xhc3MgUG9pbnQge1xuICBjb25zdHJ1Y3RvcihrZXksIG9mZnNldCwgdHlwZSkge1xuICAgIHRoaXMuX3NlbGVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIGlzKHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMua2V5ID09PSBwb2ludC5rZXkgJiYgdGhpcy5vZmZzZXQgPT09IHBvaW50Lm9mZnNldCAmJiB0aGlzLnR5cGUgPT09IHBvaW50LnR5cGU7XG4gIH1cblxuICBpc0JlZm9yZShiKSB7XG4gICAgbGV0IGFOb2RlID0gdGhpcy5nZXROb2RlKCk7XG4gICAgbGV0IGJOb2RlID0gYi5nZXROb2RlKCk7XG4gICAgY29uc3QgYU9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgIGNvbnN0IGJPZmZzZXQgPSBiLm9mZnNldDtcblxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShhTm9kZSkpIHtcbiAgICAgIGNvbnN0IGFOb2RlRGVzY2VuZGFudCA9IGFOb2RlLmdldERlc2NlbmRhbnRCeUluZGV4KGFPZmZzZXQpO1xuICAgICAgYU5vZGUgPSBhTm9kZURlc2NlbmRhbnQgIT0gbnVsbCA/IGFOb2RlRGVzY2VuZGFudCA6IGFOb2RlO1xuICAgIH1cblxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShiTm9kZSkpIHtcbiAgICAgIGNvbnN0IGJOb2RlRGVzY2VuZGFudCA9IGJOb2RlLmdldERlc2NlbmRhbnRCeUluZGV4KGJPZmZzZXQpO1xuICAgICAgYk5vZGUgPSBiTm9kZURlc2NlbmRhbnQgIT0gbnVsbCA/IGJOb2RlRGVzY2VuZGFudCA6IGJOb2RlO1xuICAgIH1cblxuICAgIGlmIChhTm9kZSA9PT0gYk5vZGUpIHtcbiAgICAgIHJldHVybiBhT2Zmc2V0IDwgYk9mZnNldDtcbiAgICB9XG5cbiAgICByZXR1cm4gYU5vZGUuaXNCZWZvcmUoYk5vZGUpO1xuICB9XG5cbiAgZ2V0Tm9kZSgpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmtleTtcbiAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShrZXkpO1xuXG4gICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFBvaW50LmdldE5vZGU6IG5vZGUgbm90IGZvdW5kYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBzZXQoa2V5LCBvZmZzZXQsIHR5cGUpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb247XG4gICAgY29uc3Qgb2xkS2V5ID0gdGhpcy5rZXk7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgIGlmICghaXNDdXJyZW50bHlSZWFkT25seU1vZGUoKSkge1xuICAgICAgaWYgKCRnZXRDb21wb3NpdGlvbktleSgpID09PSBvbGRLZXkpIHtcbiAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KGtleSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgc2VsZWN0aW9uLl9jYWNoZWROb2RlcyA9IG51bGw7XG4gICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuZnVuY3Rpb24gJGNyZWF0ZVBvaW50KGtleSwgb2Zmc2V0LCB0eXBlKSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVudGlvbmFsbHkgY2FzdCBhcyB3ZSB1c2UgYSBjbGFzcyBmb3IgcGVyZiByZWFzb25zXG4gIHJldHVybiBuZXcgUG9pbnQoa2V5LCBvZmZzZXQsIHR5cGUpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RQb2ludE9uTm9kZShwb2ludCwgbm9kZSkge1xuICBsZXQga2V5ID0gbm9kZS5fX2tleTtcbiAgbGV0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgbGV0IHR5cGUgPSAnZWxlbWVudCc7XG5cbiAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgdHlwZSA9ICd0ZXh0JztcbiAgICBjb25zdCB0ZXh0Q29udGVudExlbmd0aCA9IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG5cbiAgICBpZiAob2Zmc2V0ID4gdGV4dENvbnRlbnRMZW5ndGgpIHtcbiAgICAgIG9mZnNldCA9IHRleHRDb250ZW50TGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmICghJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIGtleSA9IG5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIHR5cGUgPSAndGV4dCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICBrZXkgPSBwYXJlbnROb2RlLl9fa2V5O1xuICAgICAgICBvZmZzZXQgPSBub2RlLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBvaW50LnNldChrZXksIG9mZnNldCwgdHlwZSk7XG59XG5cbmZ1bmN0aW9uICRtb3ZlU2VsZWN0aW9uUG9pbnRUb0VuZChwb2ludCwgbm9kZSkge1xuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBsYXN0Tm9kZSA9IG5vZGUuZ2V0TGFzdERlc2NlbmRhbnQoKTtcblxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShsYXN0Tm9kZSkgfHwgJGlzVGV4dE5vZGUobGFzdE5vZGUpKSB7XG4gICAgICBzZWxlY3RQb2ludE9uTm9kZShwb2ludCwgbGFzdE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RQb2ludE9uTm9kZShwb2ludCwgbm9kZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlbGVjdFBvaW50T25Ob2RlKHBvaW50LCBub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiAkdHJhbnNmZXJTdGFydGluZ0VsZW1lbnRQb2ludFRvVGV4dFBvaW50KHN0YXJ0LCBlbmQsIGZvcm1hdCwgc3R5bGUpIHtcbiAgY29uc3QgZWxlbWVudCA9IHN0YXJ0LmdldE5vZGUoKTtcbiAgY29uc3QgcGxhY2VtZW50Tm9kZSA9IGVsZW1lbnQuZ2V0Q2hpbGRBdEluZGV4KHN0YXJ0Lm9mZnNldCk7XG4gIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKCk7XG4gIGNvbnN0IHRhcmdldCA9ICRpc1Jvb3ROb2RlKGVsZW1lbnQpID8gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKS5hcHBlbmQodGV4dE5vZGUpIDogdGV4dE5vZGU7XG4gIHRleHROb2RlLnNldEZvcm1hdChmb3JtYXQpO1xuICB0ZXh0Tm9kZS5zZXRTdHlsZShzdHlsZSk7XG5cbiAgaWYgKHBsYWNlbWVudE5vZGUgPT09IG51bGwpIHtcbiAgICBlbGVtZW50LmFwcGVuZCh0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIHBsYWNlbWVudE5vZGUuaW5zZXJ0QmVmb3JlKHRhcmdldCk7IC8vIEZpeCB0aGUgZW5kIHBvaW50IG9mZnNldCBpZiBpdCByZWZlcnMgdG8gdGhlIHNhbWUgZWxlbWVudCBhcyBzdGFydCxcbiAgICAvLyBhcyB3ZSd2ZSBub3cgaW5zZXJ0ZWQgYW5vdGhlciBlbGVtZW50IGJlZm9yZSBpdC4gTm90ZSB0aGF0IHdlIG9ubHlcbiAgICAvLyBkbyBpdCBpZiBzZWxlY3Rpb24gaXMgbm90IGNvbGxhcHNlZCBhcyBvdGhlcndpc2UgaXQnbGwgdHJhbnNmZXJcbiAgICAvLyBib3RoIGZvY3VzIGFuZCBhbmNob3IgdG8gdGhlIHRleHQgbm9kZSBiZWxvd1xuXG4gICAgaWYgKGVuZC50eXBlID09PSAnZWxlbWVudCcgJiYgZW5kLmtleSA9PT0gc3RhcnQua2V5ICYmIGVuZC5vZmZzZXQgIT09IHN0YXJ0Lm9mZnNldCkge1xuICAgICAgZW5kLnNldChlbmQua2V5LCBlbmQub2Zmc2V0ICsgMSwgJ2VsZW1lbnQnKTtcbiAgICB9XG4gIH0gLy8gVHJhbnNmZXIgdGhlIGVsZW1lbnQgcG9pbnQgdG8gYSB0ZXh0IHBvaW50LlxuXG5cbiAgaWYgKHN0YXJ0LmlzKGVuZCkpIHtcbiAgICBlbmQuc2V0KHRleHROb2RlLl9fa2V5LCAwLCAndGV4dCcpO1xuICB9XG5cbiAgc3RhcnQuc2V0KHRleHROb2RlLl9fa2V5LCAwLCAndGV4dCcpO1xufVxuXG5mdW5jdGlvbiAkc2V0UG9pbnRWYWx1ZXMocG9pbnQsIGtleSwgb2Zmc2V0LCB0eXBlKSB7XG4gIHBvaW50LmtleSA9IGtleTtcbiAgcG9pbnQub2Zmc2V0ID0gb2Zmc2V0O1xuICBwb2ludC50eXBlID0gdHlwZTtcbn1cblxuY2xhc3MgTm9kZVNlbGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG9iamVjdHMpIHtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5fbm9kZXMgPSBvYmplY3RzO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgfVxuXG4gIGlzKHNlbGVjdGlvbikge1xuICAgIGlmICghJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgYSA9IHRoaXMuX25vZGVzO1xuICAgIGNvbnN0IGIgPSBzZWxlY3Rpb24uX25vZGVzO1xuICAgIHJldHVybiBhLnNpemUgPT09IGIuc2l6ZSAmJiBBcnJheS5mcm9tKGEpLmV2ZXJ5KGtleSA9PiBiLmhhcyhrZXkpKTtcbiAgfVxuXG4gIGFkZChrZXkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHRoaXMuX25vZGVzLmFkZChrZXkpO1xuXG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG5cbiAgZGVsZXRlKGtleSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgdGhpcy5fbm9kZXMuZGVsZXRlKGtleSk7XG5cbiAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG51bGw7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcblxuICAgIHRoaXMuX25vZGVzLmNsZWFyKCk7XG5cbiAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG51bGw7XG4gIH1cblxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzLmhhcyhrZXkpO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKG5ldyBTZXQodGhpcy5fbm9kZXMpKTtcbiAgfVxuXG4gIGV4dHJhY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXMoKTtcbiAgfVxuXG4gIGluc2VydFJhd1RleHQodGV4dCkgey8vIERvIG5vdGhpbmc/XG4gIH1cblxuICBpbnNlcnRUZXh0KCkgey8vIERvIG5vdGhpbmc/XG4gIH1cblxuICBpbnNlcnROb2Rlcyhub2Rlcywgc2VsZWN0U3RhcnQpIHtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXNMZW5ndGggPSBzZWxlY3RlZE5vZGVzLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0U2VsZWN0ZWROb2RlID0gc2VsZWN0ZWROb2Rlc1tzZWxlY3RlZE5vZGVzTGVuZ3RoIC0gMV07XG4gICAgbGV0IHNlbGVjdGlvbkF0RW5kOyAvLyBJbnNlcnQgbm9kZXNcblxuICAgIGlmICgkaXNUZXh0Tm9kZShsYXN0U2VsZWN0ZWROb2RlKSkge1xuICAgICAgc2VsZWN0aW9uQXRFbmQgPSBsYXN0U2VsZWN0ZWROb2RlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxhc3RTZWxlY3RlZE5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDE7XG4gICAgICBzZWxlY3Rpb25BdEVuZCA9IGxhc3RTZWxlY3RlZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdChpbmRleCwgaW5kZXgpO1xuICAgIH1cblxuICAgIHNlbGVjdGlvbkF0RW5kLmluc2VydE5vZGVzKG5vZGVzLCBzZWxlY3RTdGFydCk7IC8vIFJlbW92ZSBzZWxlY3RlZCBub2Rlc1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RlZE5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdGVkTm9kZXNbaV0ucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBnZXROb2RlcygpIHtcbiAgICBjb25zdCBjYWNoZWROb2RlcyA9IHRoaXMuX2NhY2hlZE5vZGVzO1xuXG4gICAgaWYgKGNhY2hlZE5vZGVzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTm9kZXM7XG4gICAgfVxuXG4gICAgY29uc3Qgb2JqZWN0cyA9IHRoaXMuX25vZGVzO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBvYmplY3RzKSB7XG4gICAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShvYmplY3QpO1xuXG4gICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNDdXJyZW50bHlSZWFkT25seU1vZGUoKSkge1xuICAgICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBub2RlcztcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cblxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRleHRDb250ZW50ICs9IG5vZGVzW2ldLmdldFRleHRDb250ZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHRDb250ZW50O1xuICB9XG5cbn1cbmZ1bmN0aW9uICRpc1JhbmdlU2VsZWN0aW9uKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBSYW5nZVNlbGVjdGlvbjtcbn1cbmNsYXNzIEdyaWRTZWxlY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihncmlkS2V5LCBhbmNob3IsIGZvY3VzKSB7XG4gICAgdGhpcy5ncmlkS2V5ID0gZ3JpZEtleTtcbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB0aGlzLmZvY3VzID0gZm9jdXM7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICBhbmNob3IuX3NlbGVjdGlvbiA9IHRoaXM7XG4gICAgZm9jdXMuX3NlbGVjdGlvbiA9IHRoaXM7XG4gIH1cblxuICBpcyhzZWxlY3Rpb24pIHtcbiAgICBpZiAoIURFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ3JpZEtleSA9PT0gc2VsZWN0aW9uLmdyaWRLZXkgJiYgdGhpcy5hbmNob3IuaXMoc2VsZWN0aW9uLmFuY2hvcikgJiYgdGhpcy5mb2N1cy5pcyhzZWxlY3Rpb24uZm9jdXMpO1xuICB9XG5cbiAgc2V0KGdyaWRLZXksIGFuY2hvckNlbGxLZXksIGZvY3VzQ2VsbEtleSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuZ3JpZEtleSA9IGdyaWRLZXk7XG4gICAgdGhpcy5hbmNob3Iua2V5ID0gYW5jaG9yQ2VsbEtleTtcbiAgICB0aGlzLmZvY3VzLmtleSA9IGZvY3VzQ2VsbEtleTtcbiAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG51bGw7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IEdyaWRTZWxlY3Rpb24odGhpcy5ncmlkS2V5LCB0aGlzLmFuY2hvciwgdGhpcy5mb2N1cyk7XG4gIH1cblxuICBpc0NvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpc0JhY2t3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLmZvY3VzLmlzQmVmb3JlKHRoaXMuYW5jaG9yKTtcbiAgfVxuXG4gIGdldENoYXJhY3Rlck9mZnNldHMoKSB7XG4gICAgcmV0dXJuIGdldENoYXJhY3Rlck9mZnNldHModGhpcyk7XG4gIH1cblxuICBleHRyYWN0KCkge1xuICAgIHJldHVybiB0aGlzLmdldE5vZGVzKCk7XG4gIH1cblxuICBpbnNlcnRSYXdUZXh0KHRleHQpIHsvLyBEbyBub3RoaW5nP1xuICB9XG5cbiAgaW5zZXJ0VGV4dCgpIHsvLyBEbyBub3RoaW5nP1xuICB9XG5cbiAgaW5zZXJ0Tm9kZXMobm9kZXMsIHNlbGVjdFN0YXJ0KSB7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gdGhpcy5mb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJG5vcm1hbGl6ZVNlbGVjdGlvbihmb2N1c05vZGUuc2VsZWN0KDAsIGZvY3VzTm9kZS5nZXRDaGlsZHJlblNpemUoKSkpO1xuICAgIHJldHVybiBzZWxlY3Rpb24uaW5zZXJ0Tm9kZXMobm9kZXMsIHNlbGVjdFN0YXJ0KTtcbiAgfSAvLyBUT0RPIERlcHJlY2F0ZSB0aGlzIG1ldGhvZC4gSXQncyBjb25mdXNpbmcgd2hlbiB1c2VkIHdpdGggY29sc3Bhbnxyb3dzcGFuXG5cblxuICBnZXRTaGFwZSgpIHtcbiAgICBjb25zdCBhbmNob3JDZWxsTm9kZSA9ICRnZXROb2RlQnlLZXkodGhpcy5hbmNob3Iua2V5KTtcblxuICAgIGlmICghKGFuY2hvckNlbGxOb2RlICE9PSBudWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYGdldE5vZGVzOiBleHBlY3RlZCB0byBmaW5kIEFuY2hvck5vZGVgKTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmNob3JDZWxsTm9kZUluZGV4ID0gYW5jaG9yQ2VsbE5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICBjb25zdCBhbmNob3JDZWxSb3dlSW5kZXggPSBhbmNob3JDZWxsTm9kZS5nZXRQYXJlbnRPclRocm93KCkuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGdldE5vZGVCeUtleSh0aGlzLmZvY3VzLmtleSk7XG5cbiAgICBpZiAoIShmb2N1c0NlbGxOb2RlICE9PSBudWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYGdldE5vZGVzOiBleHBlY3RlZCB0byBmaW5kIEZvY3VzTm9kZWApO1xuICAgIH1cblxuICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGVJbmRleCA9IGZvY3VzQ2VsbE5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICBjb25zdCBmb2N1c0NlbGxSb3dJbmRleCA9IGZvY3VzQ2VsbE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgY29uc3Qgc3RhcnRYID0gTWF0aC5taW4oYW5jaG9yQ2VsbE5vZGVJbmRleCwgZm9jdXNDZWxsTm9kZUluZGV4KTtcbiAgICBjb25zdCBzdG9wWCA9IE1hdGgubWF4KGFuY2hvckNlbGxOb2RlSW5kZXgsIGZvY3VzQ2VsbE5vZGVJbmRleCk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5taW4oYW5jaG9yQ2VsUm93ZUluZGV4LCBmb2N1c0NlbGxSb3dJbmRleCk7XG4gICAgY29uc3Qgc3RvcFkgPSBNYXRoLm1heChhbmNob3JDZWxSb3dlSW5kZXgsIGZvY3VzQ2VsbFJvd0luZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVg6IE1hdGgubWluKHN0YXJ0WCwgc3RvcFgpLFxuICAgICAgZnJvbVk6IE1hdGgubWluKHN0YXJ0WSwgc3RvcFkpLFxuICAgICAgdG9YOiBNYXRoLm1heChzdGFydFgsIHN0b3BYKSxcbiAgICAgIHRvWTogTWF0aC5tYXgoc3RhcnRZLCBzdG9wWSlcbiAgICB9O1xuICB9XG5cbiAgZ2V0Tm9kZXMoKSB7XG4gICAgY29uc3QgY2FjaGVkTm9kZXMgPSB0aGlzLl9jYWNoZWROb2RlcztcblxuICAgIGlmIChjYWNoZWROb2RlcyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZE5vZGVzO1xuICAgIH1cblxuICAgIGNvbnN0IGFuY2hvck5vZGUgPSB0aGlzLmFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gdGhpcy5mb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgYW5jaG9yQ2VsbCA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yTm9kZSwgREVQUkVDQVRFRF8kaXNHcmlkQ2VsbE5vZGUpOyAvLyB0b2RvIHJlcGxhY2Ugd2l0aCB0cmlwbGV0XG5cbiAgICBjb25zdCBmb2N1c0NlbGwgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzTm9kZSwgREVQUkVDQVRFRF8kaXNHcmlkQ2VsbE5vZGUpO1xuXG4gICAgaWYgKCFERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZShhbmNob3JDZWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIEdyaWRTZWxlY3Rpb24gYW5jaG9yIHRvIGJlIChvciBhIGNoaWxkIG9mKSBHcmlkQ2VsbE5vZGVgKTtcbiAgICB9XG5cbiAgICBpZiAoIURFUFJFQ0FURURfJGlzR3JpZENlbGxOb2RlKGZvY3VzQ2VsbCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBHcmlkU2VsZWN0aW9uIGZvY3VzIHRvIGJlIChvciBhIGNoaWxkIG9mKSBHcmlkQ2VsbE5vZGVgKTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmNob3JSb3cgPSBhbmNob3JDZWxsLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKCFERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlKGFuY2hvclJvdykpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhbmNob3JDZWxsIHRvIGhhdmUgYSBwYXJlbnQgR3JpZFJvd05vZGVgKTtcbiAgICB9XG5cbiAgICBjb25zdCBncmlkTm9kZSA9IGFuY2hvclJvdy5nZXRQYXJlbnQoKTtcblxuICAgIGlmICghREVQUkVDQVRFRF8kaXNHcmlkTm9kZShncmlkTm9kZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0YWJsZU5vZGUgdG8gaGF2ZSBhIHBhcmVudCBHcmlkTm9kZWApO1xuICAgIH0gLy8gVE9ETyBNYXBwaW5nIHRoZSB3aG9sZSBHcmlkIGV2ZXJ5IHRpbWUgbm90IGVmZmljaWVudC4gV2UgbmVlZCB0byBjb21wdXRlIHRoZSBlbnRpcmUgc3RhdGUgb25seVxuICAgIC8vIG9uY2UgKG9uIGxvYWQpIGFuZCBpdGVyYXRlIG9uIGl0IGFzIHVwZGF0ZXMgb2NjdXIuIEhvd2V2ZXIsIHRvIGRvIHRoaXMgd2UgbmVlZCB0byBoYXZlIHRoZVxuICAgIC8vIGFiaWxpdHkgdG8gc3RvcmUgYSBzdGF0ZS4gS2lsbGluZyBHcmlkU2VsZWN0aW9uIGFuZCBtb3ZpbmcgdGhlIGxvZ2ljIHRvIHRoZSBwbHVnaW4gd291bGQgbWFrZVxuICAgIC8vIHRoaXMgcG9zc2libGUuXG5cblxuICAgIGNvbnN0IFttYXAsIGNlbGxBTWFwLCBjZWxsQk1hcF0gPSBERVBSRUNBVEVEXyRjb21wdXRlR3JpZE1hcChncmlkTm9kZSwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKTtcbiAgICBsZXQgbWluQ29sdW1uID0gTWF0aC5taW4oY2VsbEFNYXAuc3RhcnRDb2x1bW4sIGNlbGxCTWFwLnN0YXJ0Q29sdW1uKTtcbiAgICBsZXQgbWluUm93ID0gTWF0aC5taW4oY2VsbEFNYXAuc3RhcnRSb3csIGNlbGxCTWFwLnN0YXJ0Um93KTtcbiAgICBsZXQgbWF4Q29sdW1uID0gTWF0aC5tYXgoY2VsbEFNYXAuc3RhcnRDb2x1bW4gKyBjZWxsQU1hcC5jZWxsLl9fY29sU3BhbiAtIDEsIGNlbGxCTWFwLnN0YXJ0Q29sdW1uICsgY2VsbEJNYXAuY2VsbC5fX2NvbFNwYW4gLSAxKTtcbiAgICBsZXQgbWF4Um93ID0gTWF0aC5tYXgoY2VsbEFNYXAuc3RhcnRSb3cgKyBjZWxsQU1hcC5jZWxsLl9fcm93U3BhbiAtIDEsIGNlbGxCTWFwLnN0YXJ0Um93ICsgY2VsbEJNYXAuY2VsbC5fX3Jvd1NwYW4gLSAxKTtcbiAgICBsZXQgZXhwbG9yZWRNaW5Db2x1bW4gPSBtaW5Db2x1bW47XG4gICAgbGV0IGV4cGxvcmVkTWluUm93ID0gbWluUm93O1xuICAgIGxldCBleHBsb3JlZE1heENvbHVtbiA9IG1pbkNvbHVtbjtcbiAgICBsZXQgZXhwbG9yZWRNYXhSb3cgPSBtaW5Sb3c7XG5cbiAgICBmdW5jdGlvbiBleHBhbmRCb3VuZGFyeShtYXBWYWx1ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydENvbHVtbjogY2VsbFN0YXJ0Q29sdW1uLFxuICAgICAgICBzdGFydFJvdzogY2VsbFN0YXJ0Um93XG4gICAgICB9ID0gbWFwVmFsdWU7XG4gICAgICBtaW5Db2x1bW4gPSBNYXRoLm1pbihtaW5Db2x1bW4sIGNlbGxTdGFydENvbHVtbik7XG4gICAgICBtaW5Sb3cgPSBNYXRoLm1pbihtaW5Sb3csIGNlbGxTdGFydFJvdyk7XG4gICAgICBtYXhDb2x1bW4gPSBNYXRoLm1heChtYXhDb2x1bW4sIGNlbGxTdGFydENvbHVtbiArIGNlbGwuX19jb2xTcGFuIC0gMSk7XG4gICAgICBtYXhSb3cgPSBNYXRoLm1heChtYXhSb3csIGNlbGxTdGFydFJvdyArIGNlbGwuX19yb3dTcGFuIC0gMSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG1pbkNvbHVtbiA8IGV4cGxvcmVkTWluQ29sdW1uIHx8IG1pblJvdyA8IGV4cGxvcmVkTWluUm93IHx8IG1heENvbHVtbiA+IGV4cGxvcmVkTWF4Q29sdW1uIHx8IG1heFJvdyA+IGV4cGxvcmVkTWF4Um93KSB7XG4gICAgICBpZiAobWluQ29sdW1uIDwgZXhwbG9yZWRNaW5Db2x1bW4pIHtcbiAgICAgICAgLy8gRXhwYW5kIG9uIHRoZSBsZWZ0XG4gICAgICAgIGNvbnN0IHJvd0RpZmYgPSBleHBsb3JlZE1heFJvdyAtIGV4cGxvcmVkTWluUm93O1xuICAgICAgICBjb25zdCBwcmV2aW91c0NvbHVtbiA9IGV4cGxvcmVkTWluQ29sdW1uIC0gMTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSByb3dEaWZmOyBpKyspIHtcbiAgICAgICAgICBleHBhbmRCb3VuZGFyeShtYXBbZXhwbG9yZWRNaW5Sb3cgKyBpXVtwcmV2aW91c0NvbHVtbl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwbG9yZWRNaW5Db2x1bW4gPSBwcmV2aW91c0NvbHVtbjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1pblJvdyA8IGV4cGxvcmVkTWluUm93KSB7XG4gICAgICAgIC8vIEV4cGFuZCBvbiB0b3BcbiAgICAgICAgY29uc3QgY29sdW1uRGlmZiA9IGV4cGxvcmVkTWF4Q29sdW1uIC0gZXhwbG9yZWRNaW5Db2x1bW47XG4gICAgICAgIGNvbnN0IHByZXZpb3VzUm93ID0gZXhwbG9yZWRNaW5Sb3cgLSAxO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGNvbHVtbkRpZmY7IGkrKykge1xuICAgICAgICAgIGV4cGFuZEJvdW5kYXJ5KG1hcFtwcmV2aW91c1Jvd11bZXhwbG9yZWRNaW5Db2x1bW4gKyBpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBsb3JlZE1pblJvdyA9IHByZXZpb3VzUm93O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4Q29sdW1uID4gZXhwbG9yZWRNYXhDb2x1bW4pIHtcbiAgICAgICAgLy8gRXhwYW5kIG9uIHRoZSByaWdodFxuICAgICAgICBjb25zdCByb3dEaWZmID0gZXhwbG9yZWRNYXhSb3cgLSBleHBsb3JlZE1pblJvdztcbiAgICAgICAgY29uc3QgbmV4dENvbHVtbiA9IGV4cGxvcmVkTWF4Q29sdW1uICsgMTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSByb3dEaWZmOyBpKyspIHtcbiAgICAgICAgICBleHBhbmRCb3VuZGFyeShtYXBbZXhwbG9yZWRNaW5Sb3cgKyBpXVtuZXh0Q29sdW1uXSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBsb3JlZE1heENvbHVtbiA9IG5leHRDb2x1bW47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXhSb3cgPiBleHBsb3JlZE1heFJvdykge1xuICAgICAgICAvLyBFeHBhbmQgb24gdGhlIGJvdHRvbVxuICAgICAgICBjb25zdCBjb2x1bW5EaWZmID0gZXhwbG9yZWRNYXhDb2x1bW4gLSBleHBsb3JlZE1pbkNvbHVtbjtcbiAgICAgICAgY29uc3QgbmV4dFJvdyA9IGV4cGxvcmVkTWF4Um93ICsgMTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBjb2x1bW5EaWZmOyBpKyspIHtcbiAgICAgICAgICBleHBhbmRCb3VuZGFyeShtYXBbbmV4dFJvd11bZXhwbG9yZWRNaW5Db2x1bW4gKyBpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBsb3JlZE1heFJvdyA9IG5leHRSb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZXMgPSBbZ3JpZE5vZGVdO1xuICAgIGxldCBsYXN0Um93ID0gbnVsbDtcblxuICAgIGZvciAobGV0IGkgPSBtaW5Sb3c7IGkgPD0gbWF4Um93OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBtaW5Db2x1bW47IGogPD0gbWF4Q29sdW1uOyBqKyspIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNlbGxcbiAgICAgICAgfSA9IG1hcFtpXVtqXTtcbiAgICAgICAgY29uc3QgY3VycmVudFJvdyA9IGNlbGwuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgaWYgKCFERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlKGN1cnJlbnRSb3cpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIEdyaWRDZWxsTm9kZSBwYXJlbnQgdG8gYmUgYSBHcmlkUm93Tm9kZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRSb3cgIT09IGxhc3RSb3cpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKGN1cnJlbnRSb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZXMucHVzaChjZWxsLCAuLi4kZ2V0Q2hpbGRyZW5SZWN1cnNpdmVseShjZWxsKSk7XG4gICAgICAgIGxhc3RSb3cgPSBjdXJyZW50Um93O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNDdXJyZW50bHlSZWFkT25seU1vZGUoKSkge1xuICAgICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBub2RlcztcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cblxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRleHRDb250ZW50ICs9IG5vZGVzW2ldLmdldFRleHRDb250ZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHRDb250ZW50O1xuICB9XG5cbn1cbmZ1bmN0aW9uIERFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbih4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgR3JpZFNlbGVjdGlvbjtcbn1cbmNsYXNzIFJhbmdlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoYW5jaG9yLCBmb2N1cywgZm9ybWF0LCBzdHlsZSkge1xuICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIHRoaXMuZm9jdXMgPSBmb2N1cztcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICBhbmNob3IuX3NlbGVjdGlvbiA9IHRoaXM7XG4gICAgZm9jdXMuX3NlbGVjdGlvbiA9IHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgdG8gY2hlY2sgaWYgdGhlIHByb3ZpZGVkIHNlbGVjdGlvbnMgaXMgZXF1YWwgdG8gdGhpcyBvbmUgYnkgdmFsdWUsXG4gICAqIGlubHVkaW5nIGFuY2hvciwgZm9jdXMsIGZvcm1hdCwgYW5kIHN0eWxlIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSBzZWxlY3Rpb24gLSB0aGUgU2VsZWN0aW9uIHRvIGNvbXBhcmUgdGhpcyBvbmUgdG8uXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFNlbGVjdGlvbnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgaXMoc2VsZWN0aW9uKSB7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYW5jaG9yLmlzKHNlbGVjdGlvbi5hbmNob3IpICYmIHRoaXMuZm9jdXMuaXMoc2VsZWN0aW9uLmZvY3VzKSAmJiB0aGlzLmZvcm1hdCA9PT0gc2VsZWN0aW9uLmZvcm1hdCAmJiB0aGlzLnN0eWxlID09PSBzZWxlY3Rpb24uc3R5bGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgU2VsZWN0aW9uIGlzIFwiYmFja3dhcmRzXCIsIG1lYW5pbmcgdGhlIGZvY3VzXG4gICAqIGxvZ2ljYWxseSBwcmVjZWRlcyB0aGUgYW5jaG9yIGluIHRoZSBFZGl0b3JTdGF0ZS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgU2VsZWN0aW9uIGlzIGJhY2t3YXJkcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cblxuXG4gIGlzQmFja3dhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXMuaXNCZWZvcmUodGhpcy5hbmNob3IpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFNlbGVjdGlvbiBpcyBcImNvbGxhcHNlZFwiLCBtZWFuaW5nIHRoZSBhbmNob3IgYW5kIGZvY3VzIGFyZVxuICAgKiB0aGUgc2FtZSBub2RlIGFuZCBoYXZlIHRoZSBzYW1lIG9mZnNldC5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgU2VsZWN0aW9uIGlzIGNvbGxhcHNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cblxuXG4gIGlzQ29sbGFwc2VkKCkge1xuICAgIHJldHVybiB0aGlzLmFuY2hvci5pcyh0aGlzLmZvY3VzKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhbGwgdGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb24uIFVzZXMgY2FjaGluZyB0byBtYWtlIGl0IGdlbmVyYWxseSBzdWl0YWJsZVxuICAgKiBmb3IgdXNlIGluIGhvdCBwYXRocy5cbiAgICpcbiAgICogQHJldHVybnMgYW4gQXJyYXkgY29udGFpbmluZyBhbGwgdGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb25cbiAgICovXG5cblxuICBnZXROb2RlcygpIHtcbiAgICBjb25zdCBjYWNoZWROb2RlcyA9IHRoaXMuX2NhY2hlZE5vZGVzO1xuXG4gICAgaWYgKGNhY2hlZE5vZGVzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTm9kZXM7XG4gICAgfVxuXG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgIGNvbnN0IGlzQmVmb3JlID0gYW5jaG9yLmlzQmVmb3JlKGZvY3VzKTtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gaXNCZWZvcmUgPyBhbmNob3IgOiBmb2N1cztcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBpc0JlZm9yZSA/IGZvY3VzIDogYW5jaG9yO1xuICAgIGxldCBmaXJzdE5vZGUgPSBmaXJzdFBvaW50LmdldE5vZGUoKTtcbiAgICBsZXQgbGFzdE5vZGUgPSBsYXN0UG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gZmlyc3RQb2ludC5vZmZzZXQ7XG4gICAgY29uc3QgZW5kT2Zmc2V0ID0gbGFzdFBvaW50Lm9mZnNldDtcblxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpKSB7XG4gICAgICBjb25zdCBmaXJzdE5vZGVEZXNjZW5kYW50ID0gZmlyc3ROb2RlLmdldERlc2NlbmRhbnRCeUluZGV4KHN0YXJ0T2Zmc2V0KTtcbiAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZURlc2NlbmRhbnQgIT0gbnVsbCA/IGZpcnN0Tm9kZURlc2NlbmRhbnQgOiBmaXJzdE5vZGU7XG4gICAgfVxuXG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGxhc3ROb2RlKSkge1xuICAgICAgbGV0IGxhc3ROb2RlRGVzY2VuZGFudCA9IGxhc3ROb2RlLmdldERlc2NlbmRhbnRCeUluZGV4KGVuZE9mZnNldCk7IC8vIFdlIGRvbid0IHdhbnQgdG8gb3Zlci1zZWxlY3QsIGFzIG5vZGUgc2VsZWN0aW9uIGluZmVycyB0aGUgY2hpbGQgYmVmb3JlXG4gICAgICAvLyB0aGUgbGFzdCBkZXNjZW5kYW50LCBub3QgaW5jbHVkaW5nIHRoYXQgZGVzY2VuZGFudC5cblxuICAgICAgaWYgKGxhc3ROb2RlRGVzY2VuZGFudCAhPT0gbnVsbCAmJiBsYXN0Tm9kZURlc2NlbmRhbnQgIT09IGZpcnN0Tm9kZSAmJiBsYXN0Tm9kZS5nZXRDaGlsZEF0SW5kZXgoZW5kT2Zmc2V0KSA9PT0gbGFzdE5vZGVEZXNjZW5kYW50KSB7XG4gICAgICAgIGxhc3ROb2RlRGVzY2VuZGFudCA9IGxhc3ROb2RlRGVzY2VuZGFudC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIH1cblxuICAgICAgbGFzdE5vZGUgPSBsYXN0Tm9kZURlc2NlbmRhbnQgIT0gbnVsbCA/IGxhc3ROb2RlRGVzY2VuZGFudCA6IGxhc3ROb2RlO1xuICAgIH1cblxuICAgIGxldCBub2RlcztcblxuICAgIGlmIChmaXJzdE5vZGUuaXMobGFzdE5vZGUpKSB7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoZmlyc3ROb2RlKSAmJiBmaXJzdE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPiAwKSB7XG4gICAgICAgIG5vZGVzID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlcyA9IFtmaXJzdE5vZGVdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlcyA9IGZpcnN0Tm9kZS5nZXROb2Rlc0JldHdlZW4obGFzdE5vZGUpO1xuICAgIH1cblxuICAgIGlmICghaXNDdXJyZW50bHlSZWFkT25seU1vZGUoKSkge1xuICAgICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBub2RlcztcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBTZWxlY3Rpb24gdG8gYmUgb2YgdHlwZSBcInRleHRcIiBhdCB0aGUgcHJvdmlkZWQgYW5jaG9yIGFuZCBmb2N1cyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBhbmNob3JOb2RlIC0gdGhlIGFuY2hvciBub2RlIHRvIHNldCBvbiB0aGUgU2VsZWN0aW9uXG4gICAqIEBwYXJhbSBhbmNob3JPZmZzZXQgLSB0aGUgb2Zmc2V0IHRvIHNldCBvbiB0aGUgU2VsZWN0aW9uXG4gICAqIEBwYXJhbSBmb2N1c05vZGUgLSB0aGUgZm9jdXMgbm9kZSB0byBzZXQgb24gdGhlIFNlbGVjdGlvblxuICAgKiBAcGFyYW0gZm9jdXNPZmZzZXQgLSB0aGUgZm9jdXMgb2Zmc2V0IHRvIHNldCBvbiB0aGUgU2VsZWN0aW9uXG4gICAqL1xuXG5cbiAgc2V0VGV4dE5vZGVSYW5nZShhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgICAkc2V0UG9pbnRWYWx1ZXModGhpcy5hbmNob3IsIGFuY2hvck5vZGUuX19rZXksIGFuY2hvck9mZnNldCwgJ3RleHQnKTtcbiAgICAkc2V0UG9pbnRWYWx1ZXModGhpcy5mb2N1cywgZm9jdXNOb2RlLl9fa2V5LCBmb2N1c09mZnNldCwgJ3RleHQnKTtcbiAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG51bGw7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIChwbGFpbikgdGV4dCBjb250ZW50IG9mIGFsbCB0aGUgbm9kZXMgaW4gdGhlIHNlbGVjdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYWxsIHRoZSBub2RlcyBpbiB0aGUgU2VsZWN0aW9uXG4gICAqL1xuXG5cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG5cbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3ROb2RlID0gbm9kZXNbMF07XG4gICAgY29uc3QgbGFzdE5vZGUgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICBjb25zdCBmb2N1cyA9IHRoaXMuZm9jdXM7XG4gICAgY29uc3QgaXNCZWZvcmUgPSBhbmNob3IuaXNCZWZvcmUoZm9jdXMpO1xuICAgIGNvbnN0IFthbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0XSA9IGdldENoYXJhY3Rlck9mZnNldHModGhpcyk7XG4gICAgbGV0IHRleHRDb250ZW50ID0gJyc7XG4gICAgbGV0IHByZXZXYXNFbGVtZW50ID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgaWYgKCFwcmV2V2FzRWxlbWVudCkge1xuICAgICAgICAgIHRleHRDb250ZW50ICs9ICdcXG4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgcHJldldhc0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2V2FzRWxlbWVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZXYXNFbGVtZW50ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgbGV0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG5cbiAgICAgICAgICBpZiAobm9kZSA9PT0gZmlyc3ROb2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gbGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKGFuY2hvci50eXBlICE9PSAnZWxlbWVudCcgfHwgZm9jdXMudHlwZSAhPT0gJ2VsZW1lbnQnIHx8IGZvY3VzLm9mZnNldCA9PT0gYW5jaG9yLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRleHQgPSBhbmNob3JPZmZzZXQgPCBmb2N1c09mZnNldCA/IHRleHQuc2xpY2UoYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCkgOiB0ZXh0LnNsaWNlKGZvY3VzT2Zmc2V0LCBhbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0ZXh0ID0gaXNCZWZvcmUgPyB0ZXh0LnNsaWNlKGFuY2hvck9mZnNldCkgOiB0ZXh0LnNsaWNlKGZvY3VzT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUgPT09IGxhc3ROb2RlKSB7XG4gICAgICAgICAgICB0ZXh0ID0gaXNCZWZvcmUgPyB0ZXh0LnNsaWNlKDAsIGZvY3VzT2Zmc2V0KSA6IHRleHQuc2xpY2UoMCwgYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0ZXh0Q29udGVudCArPSB0ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKCgkaXNEZWNvcmF0b3JOb2RlKG5vZGUpIHx8ICRpc0xpbmVCcmVha05vZGUobm9kZSkpICYmIChub2RlICE9PSBsYXN0Tm9kZSB8fCAhdGhpcy5pc0NvbGxhcHNlZCgpKSkge1xuICAgICAgICAgIHRleHRDb250ZW50ICs9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0ZXh0Q29udGVudDtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gbWFwIGEgRE9NIHNlbGVjdGlvbiByYW5nZSBvbnRvIHRoaXMgTGV4aWNhbCBTZWxlY3Rpb24sXG4gICAqIHNldHRpbmcgdGhlIGFuY2hvciwgZm9jdXMsIGFuZCB0eXBlIGFjY29yZGluZ2x5XG4gICAqXG4gICAqIEBwYXJhbSByYW5nZSBhIERPTSBTZWxlY3Rpb24gcmFuZ2UgY29uZm9ybWluZyB0byB0aGUgU3RhdGljUmFuZ2UgaW50ZXJmYWNlLlxuICAgKi9cblxuXG4gIGFwcGx5RE9NUmFuZ2UocmFuZ2UpIHtcbiAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgICBjb25zdCBjdXJyZW50RWRpdG9yU3RhdGUgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKTtcbiAgICBjb25zdCBsYXN0U2VsZWN0aW9uID0gY3VycmVudEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICAgY29uc3QgcmVzb2x2ZWRTZWxlY3Rpb25Qb2ludHMgPSBpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludHMocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCwgZWRpdG9yLCBsYXN0U2VsZWN0aW9uKTtcblxuICAgIGlmIChyZXNvbHZlZFNlbGVjdGlvblBvaW50cyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IFthbmNob3JQb2ludCwgZm9jdXNQb2ludF0gPSByZXNvbHZlZFNlbGVjdGlvblBvaW50cztcbiAgICAkc2V0UG9pbnRWYWx1ZXModGhpcy5hbmNob3IsIGFuY2hvclBvaW50LmtleSwgYW5jaG9yUG9pbnQub2Zmc2V0LCBhbmNob3JQb2ludC50eXBlKTtcbiAgICAkc2V0UG9pbnRWYWx1ZXModGhpcy5mb2N1cywgZm9jdXNQb2ludC5rZXksIGZvY3VzUG9pbnQub2Zmc2V0LCBmb2N1c1BvaW50LnR5cGUpO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBSYW5nZVNlbGVjdGlvbiwgY29weWluZyBvdmVyIGFsbCB0aGUgcHJvcGVydHkgdmFsdWVzIGZyb20gdGhpcyBvbmUuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbmV3IFJhbmdlU2VsZWN0aW9uIHdpdGggdGhlIHNhbWUgcHJvcGVydHkgdmFsdWVzIGFzIHRoaXMgb25lLlxuICAgKi9cblxuXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBuZXcgUmFuZ2VTZWxlY3Rpb24oJGNyZWF0ZVBvaW50KGFuY2hvci5rZXksIGFuY2hvci5vZmZzZXQsIGFuY2hvci50eXBlKSwgJGNyZWF0ZVBvaW50KGZvY3VzLmtleSwgZm9jdXMub2Zmc2V0LCBmb2N1cy50eXBlKSwgdGhpcy5mb3JtYXQsIHRoaXMuc3R5bGUpO1xuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIHByb3ZpZGVkIGZvcm1hdCBvbiBhbGwgdGhlIFRleHROb2RlcyBpbiB0aGUgU2VsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gZm9ybWF0IGEgc3RyaW5nIFRleHRGb3JtYXRUeXBlIHRvIHRvZ2dsZSBvbiB0aGUgVGV4dE5vZGVzIGluIHRoZSBzZWxlY3Rpb25cbiAgICovXG5cblxuICB0b2dnbGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgdGhpcy5mb3JtYXQgPSB0b2dnbGVUZXh0Rm9ybWF0VHlwZSh0aGlzLmZvcm1hdCwgZm9ybWF0LCBudWxsKTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHN0eWxlIHByb3BlcnR5IG9uIHRoZSBTZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHN0eWxlIC0gdGhlIHN0eWxlIHRvIHNldCBhdCB0aGUgdmFsdWUgb2YgdGhlIHN0eWxlIHByb3BlcnR5LlxuICAgKi9cblxuXG4gIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIFRleHRGb3JtYXRUeXBlIGlzIHByZXNlbnQgb24gdGhlIFNlbGVjdGlvbi4gVGhpcyB3aWxsIGJlIHRydWUgaWYgYW55IG5vZGUgaW4gdGhlIFNlbGVjdGlvblxuICAgKiBoYXMgdGhlIHNwZWNpZmllZCBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIHRoZSBUZXh0Rm9ybWF0VHlwZSB0byBjaGVjayBmb3IuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIGZvcm1hdCBpcyBjdXJyZW50bHkgdG9nZ2xlZCBvbiBvbiB0aGUgU2VsZWN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgaGFzRm9ybWF0KHR5cGUpIHtcbiAgICBjb25zdCBmb3JtYXRGbGFnID0gVEVYVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXTtcbiAgICByZXR1cm4gKHRoaXMuZm9ybWF0ICYgZm9ybWF0RmxhZykgIT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGluc2VydCB0aGUgcHJvdmlkZWQgdGV4dCBpbnRvIHRoZSBFZGl0b3JTdGF0ZSBhdCB0aGUgY3VycmVudCBTZWxlY3Rpb24uXG4gICAqIGNvbnZlcnRzIHRhYnMsIG5ld2xpbmVzLCBhbmQgY2FycmlhZ2UgcmV0dXJucyBpbnRvIExleGljYWxOb2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHRleHQgdGhlIHRleHQgdG8gaW5zZXJ0IGludG8gdGhlIFNlbGVjdGlvblxuICAgKi9cblxuXG4gIGluc2VydFJhd1RleHQodGV4dCkge1xuICAgIGNvbnN0IHBhcnRzID0gdGV4dC5zcGxpdCgvKFxccj9cXG58XFx0KS8pO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gcGFydHMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuXG4gICAgICBpZiAocGFydCA9PT0gJ1xcbicgfHwgcGFydCA9PT0gJ1xcclxcbicpIHtcbiAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlTGluZUJyZWFrTm9kZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlVGFiTm9kZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZVRleHROb2RlKHBhcnQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluc2VydE5vZGVzKG5vZGVzKTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gaW5zZXJ0IHRoZSBwcm92aWRlZCB0ZXh0IGludG8gdGhlIEVkaXRvclN0YXRlIGF0IHRoZSBjdXJyZW50IFNlbGVjdGlvbiBhcyBhIG5ld1xuICAgKiBMZXhpY2FsIFRleHROb2RlLCBhY2NvcmRpbmcgdG8gYSBzZXJpZXMgb2YgaW5zZXJ0aW9uIGhldXJpc3RpY3MgYmFzZWQgb24gdGhlIHNlbGVjdGlvbiB0eXBlIGFuZCBwb3NpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHRleHQgdGhlIHRleHQgdG8gaW5zZXJ0IGludG8gdGhlIFNlbGVjdGlvblxuICAgKi9cblxuXG4gIGluc2VydFRleHQodGV4dCkge1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBpc0JlZm9yZSA9IHRoaXMuaXNDb2xsYXBzZWQoKSB8fCBhbmNob3IuaXNCZWZvcmUoZm9jdXMpO1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuICAgIGNvbnN0IHN0eWxlID0gdGhpcy5zdHlsZTtcblxuICAgIGlmIChpc0JlZm9yZSAmJiBhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICAkdHJhbnNmZXJTdGFydGluZ0VsZW1lbnRQb2ludFRvVGV4dFBvaW50KGFuY2hvciwgZm9jdXMsIGZvcm1hdCwgc3R5bGUpO1xuICAgIH0gZWxzZSBpZiAoIWlzQmVmb3JlICYmIGZvY3VzLnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgICAgJHRyYW5zZmVyU3RhcnRpbmdFbGVtZW50UG9pbnRUb1RleHRQb2ludChmb2N1cywgYW5jaG9yLCBmb3JtYXQsIHN0eWxlKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXNMZW5ndGggPSBzZWxlY3RlZE5vZGVzLmxlbmd0aDtcbiAgICBjb25zdCBmaXJzdFBvaW50ID0gaXNCZWZvcmUgPyBhbmNob3IgOiBmb2N1cztcbiAgICBjb25zdCBlbmRQb2ludCA9IGlzQmVmb3JlID8gZm9jdXMgOiBhbmNob3I7XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBmaXJzdFBvaW50Lm9mZnNldDtcbiAgICBjb25zdCBlbmRPZmZzZXQgPSBlbmRQb2ludC5vZmZzZXQ7XG4gICAgbGV0IGZpcnN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbMF07XG5cbiAgICBpZiAoISRpc1RleHROb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYGluc2VydFRleHQ6IGZpcnN0IG5vZGUgaXMgbm90IGEgdGV4dCBub2RlYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3ROb2RlVGV4dCA9IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IGZpcnN0Tm9kZVRleHRMZW5ndGggPSBmaXJzdE5vZGVUZXh0Lmxlbmd0aDtcbiAgICBjb25zdCBmaXJzdE5vZGVQYXJlbnQgPSBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IHNlbGVjdGVkTm9kZXNMZW5ndGggLSAxO1xuICAgIGxldCBsYXN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbbGFzdEluZGV4XTtcblxuICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkgJiYgc3RhcnRPZmZzZXQgPT09IGZpcnN0Tm9kZVRleHRMZW5ndGggJiYgKGZpcnN0Tm9kZS5pc1NlZ21lbnRlZCgpIHx8IGZpcnN0Tm9kZS5pc1Rva2VuKCkgfHwgIWZpcnN0Tm9kZS5jYW5JbnNlcnRUZXh0QWZ0ZXIoKSB8fCAhZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRBZnRlcigpICYmIGZpcnN0Tm9kZS5nZXROZXh0U2libGluZygpID09PSBudWxsKSkge1xuICAgICAgbGV0IG5leHRTaWJsaW5nID0gZmlyc3ROb2RlLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICAgIGlmICghJGlzVGV4dE5vZGUobmV4dFNpYmxpbmcpIHx8ICFuZXh0U2libGluZy5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgfHwgJGlzVG9rZW5PclNlZ21lbnRlZChuZXh0U2libGluZykpIHtcbiAgICAgICAgbmV4dFNpYmxpbmcgPSAkY3JlYXRlVGV4dE5vZGUoKTtcbiAgICAgICAgbmV4dFNpYmxpbmcuc2V0Rm9ybWF0KGZvcm1hdCk7XG5cbiAgICAgICAgaWYgKCFmaXJzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEFmdGVyKCkpIHtcbiAgICAgICAgICBmaXJzdE5vZGVQYXJlbnQuaW5zZXJ0QWZ0ZXIobmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpcnN0Tm9kZS5pbnNlcnRBZnRlcihuZXh0U2libGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dFNpYmxpbmcuc2VsZWN0KDAsIDApO1xuICAgICAgZmlyc3ROb2RlID0gbmV4dFNpYmxpbmc7XG5cbiAgICAgIGlmICh0ZXh0ICE9PSAnJykge1xuICAgICAgICB0aGlzLmluc2VydFRleHQodGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSAmJiBzdGFydE9mZnNldCA9PT0gMCAmJiAoZmlyc3ROb2RlLmlzU2VnbWVudGVkKCkgfHwgZmlyc3ROb2RlLmlzVG9rZW4oKSB8fCAhZmlyc3ROb2RlLmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAhZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSAmJiBmaXJzdE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpKSB7XG4gICAgICBsZXQgcHJldlNpYmxpbmcgPSBmaXJzdE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICAgIGlmICghJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpIHx8ICRpc1Rva2VuT3JTZWdtZW50ZWQocHJldlNpYmxpbmcpKSB7XG4gICAgICAgIHByZXZTaWJsaW5nID0gJGNyZWF0ZVRleHROb2RlKCk7XG4gICAgICAgIHByZXZTaWJsaW5nLnNldEZvcm1hdChmb3JtYXQpO1xuXG4gICAgICAgIGlmICghZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSkge1xuICAgICAgICAgIGZpcnN0Tm9kZVBhcmVudC5pbnNlcnRCZWZvcmUocHJldlNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpcnN0Tm9kZS5pbnNlcnRCZWZvcmUocHJldlNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByZXZTaWJsaW5nLnNlbGVjdCgpO1xuICAgICAgZmlyc3ROb2RlID0gcHJldlNpYmxpbmc7XG5cbiAgICAgIGlmICh0ZXh0ICE9PSAnJykge1xuICAgICAgICB0aGlzLmluc2VydFRleHQodGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpcnN0Tm9kZS5pc1NlZ21lbnRlZCgpICYmIHN0YXJ0T2Zmc2V0ICE9PSBmaXJzdE5vZGVUZXh0TGVuZ3RoKSB7XG4gICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgICB0ZXh0Tm9kZS5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgIGZpcnN0Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgIGZpcnN0Tm9kZSA9IHRleHROb2RlO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNDb2xsYXBzZWQoKSAmJiB0ZXh0ICE9PSAnJykge1xuICAgICAgLy8gV2hlbiB0aGUgZmlyc3ROb2RlIG9yIGxhc3ROb2RlIHBhcmVudHMgYXJlIGVsZW1lbnRzIHRoYXRcbiAgICAgIC8vIGRvIG5vdCBhbGxvdyB0ZXh0IHRvIGJlIGluc2VydGVkIGJlZm9yZSBvciBhZnRlciwgd2UgZmlyc3RcbiAgICAgIC8vIGNsZWFyIHRoZSBjb250ZW50LiBUaGVuIHdlIG5vcm1hbGl6ZSBzZWxlY3Rpb24sIHRoZW4gaW5zZXJ0XG4gICAgICAvLyB0aGUgbmV3IGNvbnRlbnQuXG4gICAgICBjb25zdCBsYXN0Tm9kZVBhcmVudCA9IGxhc3ROb2RlLmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAoIWZpcnN0Tm9kZVBhcmVudC5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgfHwgIWZpcnN0Tm9kZVBhcmVudC5jYW5JbnNlcnRUZXh0QWZ0ZXIoKSB8fCAkaXNFbGVtZW50Tm9kZShsYXN0Tm9kZVBhcmVudCkgJiYgKCFsYXN0Tm9kZVBhcmVudC5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgfHwgIWxhc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRBZnRlcigpKSkge1xuICAgICAgICB0aGlzLmluc2VydFRleHQoJycpO1xuICAgICAgICBub3JtYWxpemVTZWxlY3Rpb25Qb2ludHNGb3JCb3VuZGFyaWVzKHRoaXMuYW5jaG9yLCB0aGlzLmZvY3VzLCBudWxsKTtcbiAgICAgICAgdGhpcy5pbnNlcnRUZXh0KHRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGVkTm9kZXNMZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChmaXJzdE5vZGUuaXNUb2tlbigpKSB7XG4gICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgICB0ZXh0Tm9kZS5zZWxlY3QoKTtcbiAgICAgICAgZmlyc3ROb2RlLnJlcGxhY2UodGV4dE5vZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZpcnN0Tm9kZUZvcm1hdCA9IGZpcnN0Tm9kZS5nZXRGb3JtYXQoKTtcbiAgICAgIGNvbnN0IGZpcnN0Tm9kZVN0eWxlID0gZmlyc3ROb2RlLmdldFN0eWxlKCk7XG5cbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gZW5kT2Zmc2V0ICYmIChmaXJzdE5vZGVGb3JtYXQgIT09IGZvcm1hdCB8fCBmaXJzdE5vZGVTdHlsZSAhPT0gc3R5bGUpKSB7XG4gICAgICAgIGlmIChmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKSA9PT0gJycpIHtcbiAgICAgICAgICBmaXJzdE5vZGUuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgZmlyc3ROb2RlLnNldFN0eWxlKHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgICB0ZXh0Tm9kZS5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICB0ZXh0Tm9kZS5zZXRTdHlsZShzdHlsZSk7XG4gICAgICAgICAgdGV4dE5vZGUuc2VsZWN0KCk7XG5cbiAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIGZpcnN0Tm9kZS5pbnNlcnRCZWZvcmUodGV4dE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgW3RhcmdldE5vZGVdID0gZmlyc3ROb2RlLnNwbGl0VGV4dChzdGFydE9mZnNldCk7XG4gICAgICAgICAgICB0YXJnZXROb2RlLmluc2VydEFmdGVyKHRleHROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgfSAvLyBXaGVuIGNvbXBvc2luZywgd2UgbmVlZCB0byBhZGp1c3QgdGhlIGFuY2hvciBvZmZzZXQgc28gdGhhdFxuICAgICAgICAgIC8vIHdlIGNvcnJlY3RseSByZXBsYWNlIHRoYXQgcmlnaHQgcmFuZ2UuXG5cblxuICAgICAgICAgIGlmICh0ZXh0Tm9kZS5pc0NvbXBvc2luZygpICYmIHRoaXMuYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGhpcy5hbmNob3Iub2Zmc2V0IC09IHRleHQubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkZWxDb3VudCA9IGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0O1xuICAgICAgZmlyc3ROb2RlID0gZmlyc3ROb2RlLnNwbGljZVRleHQoc3RhcnRPZmZzZXQsIGRlbENvdW50LCB0ZXh0LCB0cnVlKTtcblxuICAgICAgaWYgKGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpID09PSAnJykge1xuICAgICAgICBmaXJzdE5vZGUucmVtb3ZlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICBpZiAoZmlyc3ROb2RlLmlzQ29tcG9zaW5nKCkpIHtcbiAgICAgICAgICAvLyBXaGVuIGNvbXBvc2luZywgd2UgbmVlZCB0byBhZGp1c3QgdGhlIGFuY2hvciBvZmZzZXQgc28gdGhhdFxuICAgICAgICAgIC8vIHdlIGNvcnJlY3RseSByZXBsYWNlIHRoYXQgcmlnaHQgcmFuZ2UuXG4gICAgICAgICAgdGhpcy5hbmNob3Iub2Zmc2V0IC09IHRleHQubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZm9ybWF0ID0gZmlyc3ROb2RlRm9ybWF0O1xuICAgICAgICAgIHRoaXMuc3R5bGUgPSBmaXJzdE5vZGVTdHlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXJrZWROb2RlS2V5c0ZvcktlZXAgPSBuZXcgU2V0KFsuLi5maXJzdE5vZGUuZ2V0UGFyZW50S2V5cygpLCAuLi5sYXN0Tm9kZS5nZXRQYXJlbnRLZXlzKCldKTsgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIHBhcmVudCBlbGVtZW50cyBiZWZvcmUgdGhlIG5leHQgc2VjdGlvbixcbiAgICAgIC8vIGFzIGluIHRoYXQgc2VjdGlvbiB3ZSBtaWdodCBtdXRhdGUgdGhlIGxhc3ROb2RlLlxuXG4gICAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSAkaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpID8gZmlyc3ROb2RlIDogZmlyc3ROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGxldCBsYXN0RWxlbWVudCA9ICRpc0VsZW1lbnROb2RlKGxhc3ROb2RlKSA/IGxhc3ROb2RlIDogbGFzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgbGV0IGxhc3RFbGVtZW50Q2hpbGQgPSBsYXN0Tm9kZTsgLy8gSWYgdGhlIGxhc3QgZWxlbWVudCBpcyBpbmxpbmUsIHdlIHNob3VsZCBpbnN0ZWFkIGxvb2sgYXQgZ2V0dGluZ1xuICAgICAgLy8gdGhlIG5vZGVzIG9mIGl0cyBwYXJlbnQsIHJhdGhlciB0aGFuIGl0c2VsZi4gVGhpcyBiZWhhdmlvciB3aWxsXG4gICAgICAvLyB0aGVuIGJldHRlciBtYXRjaCBob3cgdGV4dCBub2RlIGluc2VydGlvbnMgd29yay4gV2Ugd2lsbCBuZWVkIHRvXG4gICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgbGFzdCBlbGVtZW50J3MgY2hpbGQgYWNjb3JkaW5nbHkgYXMgd2UgZG8gdGhpcy5cblxuICAgICAgaWYgKCFmaXJzdEVsZW1lbnQuaXMobGFzdEVsZW1lbnQpICYmIGxhc3RFbGVtZW50LmlzSW5saW5lKCkpIHtcbiAgICAgICAgLy8gS2VlcCB0cmF2ZXJzaW5nIHRpbGwgd2UgaGF2ZSBhIG5vbi1pbmxpbmUgZWxlbWVudCBwYXJlbnQuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBsYXN0RWxlbWVudENoaWxkID0gbGFzdEVsZW1lbnQ7XG4gICAgICAgICAgbGFzdEVsZW1lbnQgPSBsYXN0RWxlbWVudC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgIH0gd2hpbGUgKGxhc3RFbGVtZW50LmlzSW5saW5lKCkpO1xuICAgICAgfSAvLyBIYW5kbGUgbXV0YXRpb25zIHRvIHRoZSBsYXN0IG5vZGUuXG5cblxuICAgICAgaWYgKGVuZFBvaW50LnR5cGUgPT09ICd0ZXh0JyAmJiAoZW5kT2Zmc2V0ICE9PSAwIHx8IGxhc3ROb2RlLmdldFRleHRDb250ZW50KCkgPT09ICcnKSB8fCBlbmRQb2ludC50eXBlID09PSAnZWxlbWVudCcgJiYgbGFzdE5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSA8IGVuZE9mZnNldCkge1xuICAgICAgICBpZiAoJGlzVGV4dE5vZGUobGFzdE5vZGUpICYmICFsYXN0Tm9kZS5pc1Rva2VuKCkgJiYgZW5kT2Zmc2V0ICE9PSBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgICAgICAgIGlmIChsYXN0Tm9kZS5pc1NlZ21lbnRlZCgpKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShsYXN0Tm9kZS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICAgICAgICAgIGxhc3ROb2RlLnJlcGxhY2UodGV4dE5vZGUpO1xuICAgICAgICAgICAgbGFzdE5vZGUgPSB0ZXh0Tm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsYXN0Tm9kZSA9IGxhc3ROb2RlLnNwbGljZVRleHQoMCwgZW5kT2Zmc2V0LCAnJyk7XG4gICAgICAgICAgbWFya2VkTm9kZUtleXNGb3JLZWVwLmFkZChsYXN0Tm9kZS5fX2tleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbGFzdE5vZGVQYXJlbnQgPSBsYXN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgICAgICAgICBpZiAoIWxhc3ROb2RlUGFyZW50LmNhbkJlRW1wdHkoKSAmJiBsYXN0Tm9kZVBhcmVudC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSkge1xuICAgICAgICAgICAgbGFzdE5vZGVQYXJlbnQucmVtb3ZlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3ROb2RlLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFya2VkTm9kZUtleXNGb3JLZWVwLmFkZChsYXN0Tm9kZS5fX2tleSk7XG4gICAgICB9IC8vIEVpdGhlciBtb3ZlIHRoZSByZW1haW5pbmcgbm9kZXMgb2YgdGhlIGxhc3QgcGFyZW50IHRvIGFmdGVyXG4gICAgICAvLyB0aGUgZmlyc3QgY2hpbGQsIG9yIHJlbW92ZSB0aGVtIGVudGlyZWx5LiBJZiB0aGUgbGFzdCBwYXJlbnRcbiAgICAgIC8vIGlzIHRoZSBzYW1lIGFzIHRoZSBmaXJzdCBwYXJlbnQsIHRoaXMgbG9naWMgYWxzbyB3b3Jrcy5cblxuXG4gICAgICBjb25zdCBsYXN0Tm9kZUNoaWxkcmVuID0gbGFzdEVsZW1lbnQuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZXNTZXQgPSBuZXcgU2V0KHNlbGVjdGVkTm9kZXMpO1xuICAgICAgY29uc3QgZmlyc3RBbmRMYXN0RWxlbWVudHNBcmVFcXVhbCA9IGZpcnN0RWxlbWVudC5pcyhsYXN0RWxlbWVudCk7IC8vIFdlIGNob29zZSBhIHRhcmdldCB0byBpbnNlcnQgYWxsIG5vZGVzIGFmdGVyLiBJbiB0aGUgY2FzZSBvZiBoYXZpbmdcbiAgICAgIC8vIGFuZCBpbmxpbmUgc3RhcnRpbmcgcGFyZW50IGVsZW1lbnQgd2l0aCBhIHN0YXJ0aW5nIG5vZGUgdGhhdCBoYXMgbm9cbiAgICAgIC8vIHNpYmxpbmdzLCB3ZSBzaG91bGQgaW5zZXJ0IGFmdGVyIHRoZSBzdGFydGluZyBwYXJlbnQgZWxlbWVudCwgb3RoZXJ3aXNlXG4gICAgICAvLyB3ZSB3aWxsIGluY29ycmVjdGx5IG1lcmdlIGludG8gdGhlIHN0YXJ0aW5nIHBhcmVudCBlbGVtZW50LlxuICAgICAgLy8gVE9ETzogc2hvdWxkIHdlIGtlZXAgb24gdHJhdmVyc2luZyBwYXJlbnRzIGlmIHdlJ3JlIGluc2lkZSBhbm90aGVyXG4gICAgICAvLyBuZXN0ZWQgaW5saW5lIGVsZW1lbnQ/XG5cbiAgICAgIGNvbnN0IGluc2VydGlvblRhcmdldCA9IGZpcnN0RWxlbWVudC5pc0lubGluZSgpICYmIGZpcnN0Tm9kZS5nZXROZXh0U2libGluZygpID09PSBudWxsID8gZmlyc3RFbGVtZW50IDogZmlyc3ROb2RlO1xuXG4gICAgICBmb3IgKGxldCBpID0gbGFzdE5vZGVDaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBsYXN0Tm9kZUNoaWxkID0gbGFzdE5vZGVDaGlsZHJlbltpXTtcblxuICAgICAgICBpZiAobGFzdE5vZGVDaGlsZC5pcyhmaXJzdE5vZGUpIHx8ICRpc0VsZW1lbnROb2RlKGxhc3ROb2RlQ2hpbGQpICYmIGxhc3ROb2RlQ2hpbGQuaXNQYXJlbnRPZihmaXJzdE5vZGUpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdE5vZGVDaGlsZC5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICBpZiAoIXNlbGVjdGVkTm9kZXNTZXQuaGFzKGxhc3ROb2RlQ2hpbGQpIHx8IGxhc3ROb2RlQ2hpbGQuaXMobGFzdEVsZW1lbnRDaGlsZCkpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3RBbmRMYXN0RWxlbWVudHNBcmVFcXVhbCkge1xuICAgICAgICAgICAgICBpbnNlcnRpb25UYXJnZXQuaW5zZXJ0QWZ0ZXIobGFzdE5vZGVDaGlsZCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0Tm9kZUNoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWZpcnN0QW5kTGFzdEVsZW1lbnRzQXJlRXF1YWwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhbHJlYWR5IG1vdmVkIG91dCBhbGwgdGhlIG5vZGVzIG9mIHRoZVxuICAgICAgICAvLyBsYXN0IHBhcmVudCwgYW5kIGlmIHNvLCB0cmF2ZXJzZSB0aGUgcGFyZW50IHRyZWUgYW5kIG1hcmtcbiAgICAgICAgLy8gdGhlbSBhbGwgYXMgYmVpbmcgYWJsZSB0byBkZWxldGVkIHRvby5cbiAgICAgICAgbGV0IHBhcmVudCA9IGxhc3RFbGVtZW50O1xuICAgICAgICBsZXQgbGFzdFJlbW92ZWRQYXJlbnQgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAwIHx8IGNoaWxkcmVuW2NoaWxkcmVuTGVuZ3RoIC0gMV0uaXMobGFzdFJlbW92ZWRQYXJlbnQpKSB7XG4gICAgICAgICAgICBtYXJrZWROb2RlS2V5c0ZvcktlZXAuZGVsZXRlKHBhcmVudC5fX2tleSk7XG4gICAgICAgICAgICBsYXN0UmVtb3ZlZFBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRW5zdXJlIHdlIGRvIHNwbGljaW5nIGFmdGVyIG1vdmluZyBvZiBub2RlcywgYXMgc3BsaWNpbmdcbiAgICAgIC8vIGNhbiBoYXZlIHNpZGUtZWZmZWN0cyAoaW4gdGhlIGNhc2Ugb2YgaGFzaHRhZ3MpLlxuXG5cbiAgICAgIGlmICghZmlyc3ROb2RlLmlzVG9rZW4oKSkge1xuICAgICAgICBmaXJzdE5vZGUgPSBmaXJzdE5vZGUuc3BsaWNlVGV4dChzdGFydE9mZnNldCwgZmlyc3ROb2RlVGV4dExlbmd0aCAtIHN0YXJ0T2Zmc2V0LCB0ZXh0LCB0cnVlKTtcblxuICAgICAgICBpZiAoZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCkgPT09ICcnKSB7XG4gICAgICAgICAgZmlyc3ROb2RlLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0Tm9kZS5pc0NvbXBvc2luZygpICYmIHRoaXMuYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIC8vIFdoZW4gY29tcG9zaW5nLCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgYW5jaG9yIG9mZnNldCBzbyB0aGF0XG4gICAgICAgICAgLy8gd2UgY29ycmVjdGx5IHJlcGxhY2UgdGhhdCByaWdodCByYW5nZS5cbiAgICAgICAgICB0aGlzLmFuY2hvci5vZmZzZXQgLT0gdGV4dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRPZmZzZXQgPT09IGZpcnN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgICAgZmlyc3ROb2RlLnNlbGVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgIHRleHROb2RlLnNlbGVjdCgpO1xuICAgICAgICBmaXJzdE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICB9IC8vIFJlbW92ZSBhbGwgc2VsZWN0ZWQgbm9kZXMgdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiByZW1vdmVkLlxuXG5cbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc2VsZWN0ZWROb2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IHNlbGVjdGVkTm9kZXNbaV07XG4gICAgICAgIGNvbnN0IGtleSA9IHNlbGVjdGVkTm9kZS5fX2tleTtcblxuICAgICAgICBpZiAoIW1hcmtlZE5vZGVLZXlzRm9yS2VlcC5oYXMoa2V5KSkge1xuICAgICAgICAgIHNlbGVjdGVkTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgdGV4dCBpbiB0aGUgU2VsZWN0aW9uLCBhZGp1c3RpbmcgdGhlIEVkaXRvclN0YXRlIGFjY29yZGluZ2x5LlxuICAgKi9cblxuXG4gIHJlbW92ZVRleHQoKSB7XG4gICAgdGhpcy5pbnNlcnRUZXh0KCcnKTtcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyB0aGUgcHJvdmlkZWQgZm9ybWF0IHRvIHRoZSBUZXh0Tm9kZXMgaW4gdGhlIFNlbGVjdGlvbiwgc3BsaXR0aW5nIG9yXG4gICAqIG1lcmdpbmcgbm9kZXMgYXMgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBAcGFyYW0gZm9ybWF0VHlwZSB0aGUgZm9ybWF0IHR5cGUgdG8gYXBwbHkgdG8gdGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb24uXG4gICAqL1xuXG5cbiAgZm9ybWF0VGV4dChmb3JtYXRUeXBlKSB7XG4gICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgdGhpcy50b2dnbGVGb3JtYXQoZm9ybWF0VHlwZSk7IC8vIFdoZW4gY2hhbmdpbmcgZm9ybWF0LCB3ZSBzaG91bGQgc3RvcCBjb21wb3NpdGlvblxuXG4gICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICBjb25zdCBzZWxlY3RlZFRleHROb2RlcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBzZWxlY3RlZE5vZGUgb2Ygc2VsZWN0ZWROb2Rlcykge1xuICAgICAgaWYgKCRpc1RleHROb2RlKHNlbGVjdGVkTm9kZSkpIHtcbiAgICAgICAgc2VsZWN0ZWRUZXh0Tm9kZXMucHVzaChzZWxlY3RlZE5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdGVkVGV4dE5vZGVzTGVuZ3RoID0gc2VsZWN0ZWRUZXh0Tm9kZXMubGVuZ3RoO1xuXG4gICAgaWYgKHNlbGVjdGVkVGV4dE5vZGVzTGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnRvZ2dsZUZvcm1hdChmb3JtYXRUeXBlKTsgLy8gV2hlbiBjaGFuZ2luZyBmb3JtYXQsIHdlIHNob3VsZCBzdG9wIGNvbXBvc2l0aW9uXG5cbiAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICBjb25zdCBmb2N1cyA9IHRoaXMuZm9jdXM7XG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IHRoaXMuaXNCYWNrd2FyZCgpO1xuICAgIGNvbnN0IHN0YXJ0UG9pbnQgPSBpc0JhY2t3YXJkID8gZm9jdXMgOiBhbmNob3I7XG4gICAgY29uc3QgZW5kUG9pbnQgPSBpc0JhY2t3YXJkID8gYW5jaG9yIDogZm9jdXM7XG4gICAgbGV0IGZpcnN0SW5kZXggPSAwO1xuICAgIGxldCBmaXJzdE5vZGUgPSBzZWxlY3RlZFRleHROb2Rlc1swXTtcbiAgICBsZXQgc3RhcnRPZmZzZXQgPSBzdGFydFBvaW50LnR5cGUgPT09ICdlbGVtZW50JyA/IDAgOiBzdGFydFBvaW50Lm9mZnNldDsgLy8gSW4gY2FzZSBzZWxlY3Rpb24gc3RhcnRlZCBhdCB0aGUgZW5kIG9mIHRleHQgbm9kZSB1c2UgbmV4dCB0ZXh0IG5vZGVcblxuICAgIGlmIChzdGFydFBvaW50LnR5cGUgPT09ICd0ZXh0JyAmJiBzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICBmaXJzdEluZGV4ID0gMTtcbiAgICAgIGZpcnN0Tm9kZSA9IHNlbGVjdGVkVGV4dE5vZGVzWzFdO1xuICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChmaXJzdE5vZGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZpcnN0TmV4dEZvcm1hdCA9IGZpcnN0Tm9kZS5nZXRGb3JtYXRGbGFncyhmb3JtYXRUeXBlLCBudWxsKTtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBzZWxlY3RlZFRleHROb2Rlc0xlbmd0aCAtIDE7XG4gICAgbGV0IGxhc3ROb2RlID0gc2VsZWN0ZWRUZXh0Tm9kZXNbbGFzdEluZGV4XTtcbiAgICBjb25zdCBlbmRPZmZzZXQgPSBlbmRQb2ludC50eXBlID09PSAndGV4dCcgPyBlbmRQb2ludC5vZmZzZXQgOiBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTsgLy8gU2luZ2xlIG5vZGUgc2VsZWN0ZWRcblxuICAgIGlmIChmaXJzdE5vZGUuaXMobGFzdE5vZGUpKSB7XG4gICAgICAvLyBObyBhY3R1YWwgdGV4dCBpcyBzZWxlY3RlZCwgc28gZG8gbm90aGluZy5cbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gZW5kT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gVGhlIGVudGlyZSBub2RlIGlzIHNlbGVjdGVkLCBzbyBqdXN0IGZvcm1hdCBpdFxuXG5cbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCAmJiBlbmRPZmZzZXQgPT09IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgICAgICBmaXJzdE5vZGUuc2V0Rm9ybWF0KGZpcnN0TmV4dEZvcm1hdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb2RlIGlzIHBhcnRpYWxseSBzZWxlY3RlZCwgc28gc3BsaXQgaXQgaW50byB0d28gbm9kZXNcbiAgICAgICAgLy8gYWRkIHN0eWxlIHRoZSBzZWxlY3RlZCBvbmUuXG4gICAgICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHN0YXJ0T2Zmc2V0ID09PSAwID8gc3BsaXROb2Rlc1swXSA6IHNwbGl0Tm9kZXNbMV07XG4gICAgICAgIHJlcGxhY2VtZW50LnNldEZvcm1hdChmaXJzdE5leHRGb3JtYXQpOyAvLyBVcGRhdGUgc2VsZWN0aW9uIG9ubHkgaWYgc3RhcnRzL2VuZHMgb24gdGV4dCBub2RlXG5cbiAgICAgICAgaWYgKHN0YXJ0UG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgc3RhcnRQb2ludC5zZXQocmVwbGFjZW1lbnQuX19rZXksIDAsICd0ZXh0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kUG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgZW5kUG9pbnQuc2V0KHJlcGxhY2VtZW50Ll9fa2V5LCBlbmRPZmZzZXQgLSBzdGFydE9mZnNldCwgJ3RleHQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmZvcm1hdCA9IGZpcnN0TmV4dEZvcm1hdDtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIE11bHRpcGxlIG5vZGVzIHNlbGVjdGVkXG4gICAgLy8gVGhlIGVudGlyZSBmaXJzdCBub2RlIGlzbid0IHNlbGVjdGVkLCBzbyBzcGxpdCBpdFxuXG5cbiAgICBpZiAoc3RhcnRPZmZzZXQgIT09IDApIHtcbiAgICAgIFssIGZpcnN0Tm9kZV0gPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0KTtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICB9XG5cbiAgICBmaXJzdE5vZGUuc2V0Rm9ybWF0KGZpcnN0TmV4dEZvcm1hdCk7XG4gICAgY29uc3QgbGFzdE5leHRGb3JtYXQgPSBsYXN0Tm9kZS5nZXRGb3JtYXRGbGFncyhmb3JtYXRUeXBlLCBmaXJzdE5leHRGb3JtYXQpOyAvLyBJZiB0aGUgb2Zmc2V0IGlzIDAsIGl0IG1lYW5zIG5vIGFjdHVhbCBjaGFyYWN0ZXJzIGFyZSBzZWxlY3RlZCxcbiAgICAvLyBzbyB3ZSBza2lwIGZvcm1hdHRpbmcgdGhlIGxhc3Qgbm9kZSBhbHRvZ2V0aGVyLlxuXG4gICAgaWYgKGVuZE9mZnNldCA+IDApIHtcbiAgICAgIGlmIChlbmRPZmZzZXQgIT09IGxhc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICAgIFtsYXN0Tm9kZV0gPSBsYXN0Tm9kZS5zcGxpdFRleHQoZW5kT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgbGFzdE5vZGUuc2V0Rm9ybWF0KGxhc3ROZXh0Rm9ybWF0KTtcbiAgICB9IC8vIFByb2Nlc3MgYWxsIHRleHQgbm9kZXMgaW4gYmV0d2VlblxuXG5cbiAgICBmb3IgKGxldCBpID0gZmlyc3RJbmRleCArIDE7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgICAgY29uc3QgdGV4dE5vZGUgPSBzZWxlY3RlZFRleHROb2Rlc1tpXTtcblxuICAgICAgaWYgKCF0ZXh0Tm9kZS5pc1Rva2VuKCkpIHtcbiAgICAgICAgY29uc3QgbmV4dEZvcm1hdCA9IHRleHROb2RlLmdldEZvcm1hdEZsYWdzKGZvcm1hdFR5cGUsIGxhc3ROZXh0Rm9ybWF0KTtcbiAgICAgICAgdGV4dE5vZGUuc2V0Rm9ybWF0KG5leHRGb3JtYXQpO1xuICAgICAgfVxuICAgIH0gLy8gVXBkYXRlIHNlbGVjdGlvbiBvbmx5IGlmIHN0YXJ0cy9lbmRzIG9uIHRleHQgbm9kZVxuXG5cbiAgICBpZiAoc3RhcnRQb2ludC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHN0YXJ0UG9pbnQuc2V0KGZpcnN0Tm9kZS5fX2tleSwgc3RhcnRPZmZzZXQsICd0ZXh0Jyk7XG4gICAgfVxuXG4gICAgaWYgKGVuZFBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgZW5kUG9pbnQuc2V0KGxhc3ROb2RlLl9fa2V5LCBlbmRPZmZzZXQsICd0ZXh0Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5mb3JtYXQgPSBmaXJzdE5leHRGb3JtYXQgfCBsYXN0TmV4dEZvcm1hdDtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gXCJpbnRlbGxpZ2VudGx5XCIgaW5zZXJ0IGFuIGFyYml0cmFyeSBsaXN0IG9mIExleGljYWwgbm9kZXMgaW50byB0aGUgRWRpdG9yU3RhdGUgYXQgdGhlXG4gICAqIGN1cnJlbnQgU2VsZWN0aW9uIGFjY29yZGluZyB0byBhIHNldCBvZiBoZXVyaXN0aWNzIHRoYXQgZGV0ZXJtaW5lIGhvdyBzdXJyb3VuZGluZyBub2Rlc1xuICAgKiBzaG91bGQgYmUgY2hhbmdlZCwgcmVwbGFjZWQsIG9yIG1vdmVkIHRvIGFjY29tb2RhdGUgdGhlIGluY29taW5nIG9uZXMuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlcyAtIHRoZSBub2RlcyB0byBpbnNlcnRcbiAgICogQHBhcmFtIHNlbGVjdFN0YXJ0IC0gd2hldGhlciBvciBub3QgdG8gc2VsZWN0IHRoZSBzdGFydCBhZnRlciB0aGUgaW5zZXJ0aW9uLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlcyB3ZXJlIGluc2VydGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cblxuXG4gIGluc2VydE5vZGVzKG5vZGVzLCBzZWxlY3RTdGFydCkge1xuICAgIC8vIElmIHRoZXJlIGlzIGEgcmFuZ2Ugc2VsZWN0ZWQgcmVtb3ZlIHRoZSB0ZXh0IGluIGl0XG4gICAgaWYgKCF0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkVuZCA9IHRoaXMuaXNCYWNrd2FyZCgpID8gdGhpcy5hbmNob3IgOiB0aGlzLmZvY3VzO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBzZWxlY3Rpb25FbmQuZ2V0Tm9kZSgpLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBjb25zdCBuZXh0U2libGluZ0tleSA9IG5leHRTaWJsaW5nID8gbmV4dFNpYmxpbmcuZ2V0S2V5KCkgOiBudWxsO1xuICAgICAgY29uc3QgcHJldlNpYmxpbmcgPSBzZWxlY3Rpb25FbmQuZ2V0Tm9kZSgpLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgY29uc3QgcHJldlNpYmxpbmdLZXkgPSBwcmV2U2libGluZyA/IHByZXZTaWJsaW5nLmdldEtleSgpIDogbnVsbDtcbiAgICAgIHRoaXMucmVtb3ZlVGV4dCgpOyAvLyBJZiB0aGUgc2VsZWN0aW9uIGhhcyBiZWVuIG1vdmVkIHRvIGFuIGFkamFjZW50IGlubGluZSBlbGVtZW50LCBjcmVhdGVcbiAgICAgIC8vIGEgdGVtcG9yYXJ5IHRleHQgbm9kZSB0aGF0IHdlIGNhbiBpbnNlcnQgdGhlIG5vZGVzIGFmdGVyLlxuXG4gICAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCgpICYmIHRoaXMuZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICAgIGxldCB0ZXh0Tm9kZTtcblxuICAgICAgICBpZiAodGhpcy5mb2N1cy5rZXkgPT09IG5leHRTaWJsaW5nS2V5ICYmIHRoaXMuZm9jdXMub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoKTtcbiAgICAgICAgICB0aGlzLmZvY3VzLmdldE5vZGUoKS5pbnNlcnRCZWZvcmUodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZm9jdXMua2V5ID09PSBwcmV2U2libGluZ0tleSAmJiB0aGlzLmZvY3VzLm9mZnNldCA9PT0gdGhpcy5mb2N1cy5nZXROb2RlKCkuZ2V0Q2hpbGRyZW5TaXplKCkpIHtcbiAgICAgICAgICB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMuZm9jdXMuZ2V0Tm9kZSgpLmluc2VydEFmdGVyKHRleHROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0Tm9kZSkge1xuICAgICAgICAgIHRoaXMuZm9jdXMuc2V0KHRleHROb2RlLl9fa2V5LCAwLCAndGV4dCcpO1xuICAgICAgICAgIHRoaXMuYW5jaG9yLnNldCh0ZXh0Tm9kZS5fX2tleSwgMCwgJ3RleHQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgbGV0IHRhcmdldCA9IGFuY2hvck5vZGU7XG5cbiAgICBpZiAoYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBwbGFjZW1lbnROb2RlID0gZWxlbWVudC5nZXRDaGlsZEF0SW5kZXgoYW5jaG9yT2Zmc2V0IC0gMSk7XG5cbiAgICAgIGlmIChwbGFjZW1lbnROb2RlID09PSBudWxsKSB7XG4gICAgICAgIHRhcmdldCA9IGVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXQgPSBwbGFjZW1lbnROb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNpYmxpbmdzID0gW107IC8vIEdldCBhbGwgcmVtYWluaW5nIHRleHQgbm9kZSBzaWJsaW5ncyBpbiB0aGlzIGVsZW1lbnQgc28gd2UgY2FuXG4gICAgLy8gYXBwZW5kIHRoZW0gYWZ0ZXIgdGhlIGxhc3Qgbm9kZSB3ZSdyZSBpbnNlcnRpbmcuXG5cbiAgICBjb25zdCBuZXh0U2libGluZ3MgPSBhbmNob3JOb2RlLmdldE5leHRTaWJsaW5ncygpO1xuICAgIGNvbnN0IHRvcExldmVsRWxlbWVudCA9ICRpc1Jvb3RPclNoYWRvd1Jvb3QoYW5jaG9yTm9kZSkgPyBudWxsIDogYW5jaG9yTm9kZS5nZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCk7XG5cbiAgICBpZiAoJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgY29uc3QgdGV4dENvbnRlbnRMZW5ndGggPSB0ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChhbmNob3JPZmZzZXQgPT09IDAgJiYgdGV4dENvbnRlbnRMZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc3QgcHJldlNpYmxpbmcgPSBhbmNob3JOb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuXG4gICAgICAgIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIHRhcmdldCA9IHByZXZTaWJsaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldCA9IGFuY2hvck5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2libGluZ3MucHVzaChhbmNob3JOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoYW5jaG9yT2Zmc2V0ID09PSB0ZXh0Q29udGVudExlbmd0aCkge1xuICAgICAgICB0YXJnZXQgPSBhbmNob3JOb2RlO1xuICAgICAgfSBlbHNlIGlmIChhbmNob3JOb2RlLmlzVG9rZW4oKSkge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHdlJ3JlIGluc2lkZSBhIHRva2VuIG5vZGVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgd2Ugc3RhcnRlZCB3aXRoIGEgcmFuZ2Ugc2VsZWN0ZWQgZ3JhYiB0aGUgZGFuZ2xpbmdUZXh0IGFmdGVyIHRoZVxuICAgICAgICAvLyBlbmQgb2YgdGhlIHNlbGVjdGlvbiBhbmQgcHV0IGl0IG9uIG91ciBzaWJsaW5ncyBhcnJheSBzbyB3ZSBjYW5cbiAgICAgICAgLy8gYXBwZW5kIGl0IGFmdGVyIHRoZSBsYXN0IG5vZGUgd2UncmUgaW5zZXJ0aW5nXG4gICAgICAgIGxldCBkYW5nbGluZ1RleHQ7XG4gICAgICAgIFt0YXJnZXQsIGRhbmdsaW5nVGV4dF0gPSBhbmNob3JOb2RlLnNwbGl0VGV4dChhbmNob3JPZmZzZXQpO1xuICAgICAgICBzaWJsaW5ncy5wdXNoKGRhbmdsaW5nVGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRpbmdOb2RlID0gdGFyZ2V0O1xuICAgIHNpYmxpbmdzLnB1c2goLi4ubmV4dFNpYmxpbmdzKTtcbiAgICBjb25zdCBmaXJzdE5vZGUgPSBub2Rlc1swXTtcbiAgICBsZXQgZGlkUmVwbGFjZU9yTWVyZ2UgPSBmYWxzZTtcbiAgICBsZXQgbGFzdE5vZGUgPSBudWxsOyAvLyBUaW1lIHRvIGluc2VydCB0aGUgbm9kZXMhXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgIGlmICghJGlzUm9vdE9yU2hhZG93Um9vdCh0YXJnZXQpICYmICEkaXNEZWNvcmF0b3JOb2RlKHRhcmdldCkgJiYgJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICAvLyAtLS0tLVxuICAgICAgICAvLyBIZXVyaXN0aWNzIGZvciB0aGUgcmVwbGFjZW1lbnQgb3IgbWVyZ2luZyBvZiBlbGVtZW50c1xuICAgICAgICAvLyAtLS0tLVxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGluY29taW5nIGVsZW1lbnQgbm9kZSBhcyB0aGUgZmlyc3Qgbm9kZSwgdGhlbiB3ZSdsbCBuZWVkXG4gICAgICAgIC8vIHNlZSBpZiB3ZSBjYW4gbWVyZ2UgYW55IGRlc2NlbmRhbnQgbGVhZiBub2RlcyBpbnRvIG91ciBleGlzdGluZyB0YXJnZXQuXG4gICAgICAgIC8vIFdlIGNhbiBkbyB0aGlzIGJ5IGZpbmRpbmcgdGhlIGZpcnN0IGRlc2NlbmRhbnQgaW4gb3VyIG5vZGUgYW5kIHRoZW4gd2UgY2FuXG4gICAgICAgIC8vIHBsdWNrIGl0IGFuZCBpdHMgcGFyZW50IChzaWJsaW5ncyBpbmNsdWRlZCkgb3V0IGFuZCBpbnNlcnQgdGhlbSBkaXJlY3RseVxuICAgICAgICAvLyBpbnRvIG91ciB0YXJnZXQuIFdlIG9ubHkgZG8gdGhpcyBmb3IgdGhlIGZpcnN0IG5vZGUsIGFzIHdlIGFyZSBvbmx5XG4gICAgICAgIC8vIGludGVyZXN0ZWQgaW4gbWVyZ2luZyB3aXRoIHRoZSBhbmNob3IsIHdoaWNoIGlzIG91ciB0YXJnZXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHdlIGFwcGx5IGVpdGhlciB0aGUgcmVwbGFjZW1lbnQgb3IgbWVyZ2luZyBoZXVyaXN0aWNzLCB3ZSBuZWVkIHRvIGJlXG4gICAgICAgIC8vIGNhcmVmdWwgdGhhdCB3ZSdyZSBub3QgdHJ5aW5nIHRvIGluc2VydCBhIG5vbi1lbGVtZW50IG5vZGUgaW50byBhIHJvb3Qgbm9kZSxcbiAgICAgICAgLy8gc28gd2UgY2hlY2sgaWYgdGhlIHRhcmdldCdzIHBhcmVudCBhZnRlciB0aGlzIGxvZ2ljIGlzIHRoZSByb290IG5vZGUgYW5kIGlmXG4gICAgICAgIC8vIHNvIHdlIHRyaWdnZXIgYW4gaW52YXJpYW50IHRvIGVuc3VyZSB0aGlzIHByb2JsZW0gaXMgY2F1Z2h0IGluIGRldmVsb3BtZW50XG4gICAgICAgIC8vIGFuZCBmaXhlZCBhY2NvcmRpbmdseS5cbiAgICAgICAgaWYgKG5vZGUuaXMoZmlyc3ROb2RlKSkge1xuICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZSh0YXJnZXQpICYmIHRhcmdldC5pc0VtcHR5KCkgJiYgdGFyZ2V0LmNhblJlcGxhY2VXaXRoKG5vZGUpKSB7XG4gICAgICAgICAgICB0YXJnZXQucmVwbGFjZShub2RlKTtcbiAgICAgICAgICAgIHRhcmdldCA9IG5vZGU7XG4gICAgICAgICAgICBkaWRSZXBsYWNlT3JNZXJnZSA9IHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IC8vIFdlIG1heSBoYXZlIGEgbm9kZSB0cmVlIHdoZXJlIHRoZXJlIGFyZSBtYW55IGxldmVscywgZm9yIGV4YW1wbGUgd2l0aFxuICAgICAgICAgIC8vIGxpc3RzIGFuZCB0YWJsZXMuIFNvIGxldCdzIGZpbmQgdGhlIGZpcnN0IGRlc2NlbmRhbnQgdG8gdHJ5IGFuZCBtZXJnZVxuICAgICAgICAgIC8vIHdpdGguIFNvIGlmIHdlIGhhdmUgdGhlIHRhcmdldDpcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFBhcmFncmFwaCAoMSlcbiAgICAgICAgICAvLyAgIFRleHQgKDIpXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBhbmQgd2UgYXJlIHRyeWluZyB0byBpbnNlcnQ6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBMaXN0Tm9kZSAoMylcbiAgICAgICAgICAvLyAgIExpc3RJdGVtTm9kZSAoNClcbiAgICAgICAgICAvLyAgICAgVGV4dCAoNSlcbiAgICAgICAgICAvLyAgIExpc3RJdGVtTm9kZSAoNilcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoZSByZXN1bHQgd291bGQgYmU6XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBQYXJhZ3JhcGggKDEpXG4gICAgICAgICAgLy8gICBUZXh0ICgyKVxuICAgICAgICAgIC8vICAgVGV4dCAoNSlcbiAgICAgICAgICAvL1xuXG5cbiAgICAgICAgICBjb25zdCBmaXJzdERlc2NlbmRhbnQgPSBub2RlLmdldEZpcnN0RGVzY2VuZGFudCgpO1xuXG4gICAgICAgICAgaWYgKCRpc0xlYWZOb2RlKGZpcnN0RGVzY2VuZGFudCkpIHtcbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZmlyc3REZXNjZW5kYW50LmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQuaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZWxlbWVudC5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIGxldCBmaXJzdENoaWxkID0gdGFyZ2V0LmdldEZpcnN0Q2hpbGQoKTtcblxuICAgICAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGNoaWxkcmVuTGVuZ3RoOyBzKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW3NdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRhcmdldC5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmaXJzdENoaWxkLmluc2VydEFmdGVyKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmaXJzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IHMgPSBjaGlsZHJlbkxlbmd0aCAtIDE7IHMgPj0gMDsgcy0tKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKGNoaWxkcmVuW3NdKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3ROb2RlID0gY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICBkaWRSZXBsYWNlT3JNZXJnZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50LmlzKG5vZGUpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZSh0YXJnZXQpKSB7XG4gICAgICAgICAgaWYgKHRvcExldmVsRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0Tm9kZTogdG9wTGV2ZWxFbGVtZW50IGlzIHJvb3Qgbm9kZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhcmdldCA9IHRvcExldmVsRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkaWRSZXBsYWNlT3JNZXJnZSAmJiAhJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgISRpc0RlY29yYXRvck5vZGUobm9kZSkgJiYgJGlzUm9vdE9yU2hhZG93Um9vdCh0YXJnZXQuZ2V0UGFyZW50KCkpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0Tm9kZXM6IGNhbm5vdCBpbnNlcnQgYSBub24tZWxlbWVudCBpbnRvIGEgcm9vdCBub2RlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGlkUmVwbGFjZU9yTWVyZ2UgPSBmYWxzZTtcblxuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHRhcmdldCkgJiYgIXRhcmdldC5pc0lubGluZSgpKSB7XG4gICAgICAgIGxhc3ROb2RlID0gbm9kZTtcblxuICAgICAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShub2RlKSAmJiAhbm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0Lmluc2VydEFmdGVyKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmICghJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gdGFyZ2V0LmdldEZpcnN0Q2hpbGQoKTtcblxuICAgICAgICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZChub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YXJnZXQgPSBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbm9kZS5jYW5CZUVtcHR5KCkgJiYgbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgkaXNSb290Tm9kZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICBjb25zdCBwbGFjZW1lbnROb2RlID0gdGFyZ2V0LmdldENoaWxkQXRJbmRleChhbmNob3JPZmZzZXQpO1xuXG4gICAgICAgICAgICBpZiAocGxhY2VtZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwbGFjZW1lbnROb2RlLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRhcmdldC5hcHBlbmQobm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhcmdldCA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hcHBlbmQobm9kZSk7XG4gICAgICAgICAgICB0YXJnZXQgPSBub2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaW5zZXJ0QWZ0ZXIobm9kZSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghJGlzRWxlbWVudE5vZGUobm9kZSkgfHwgJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpIHx8ICRpc0RlY29yYXRvck5vZGUodGFyZ2V0KSAmJiAhdGFyZ2V0LmlzSW5saW5lKCkpIHtcbiAgICAgICAgbGFzdE5vZGUgPSBub2RlOyAvLyB3aGVuIHBhc3RpbmcgdG9wIGxldmVsIG5vZGUgaW4gdGhlIG1pZGRsZSBvZiBwYXJhZ3JhcGhcbiAgICAgICAgLy8gd2UgbmVlZCB0byBzcGxpdCBwYXJhZ3JhcGggaW5zdGVhZCBvZiBwbGFjaW5nIGl0IGlubGluZVxuXG4gICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbih0aGlzKSAmJiAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpICYmICgkaXNFbGVtZW50Tm9kZSh0YXJnZXQpIHx8ICRpc1RleHROb2RlKHRhcmdldCkpICYmICFub2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICBsZXQgc3BsaXROb2RlO1xuICAgICAgICAgIGxldCBzcGxpdE9mZnNldDtcblxuICAgICAgICAgIGlmICgkaXNUZXh0Tm9kZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICBzcGxpdE5vZGUgPSB0YXJnZXQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICAgICAgY29uc3QgW3RleHROb2RlXSA9IHRhcmdldC5zcGxpdFRleHQoYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgIHNwbGl0T2Zmc2V0ID0gdGV4dE5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwbGl0Tm9kZSA9IHRhcmdldDtcbiAgICAgICAgICAgIHNwbGl0T2Zmc2V0ID0gYW5jaG9yT2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IFssIHJpZ2h0VHJlZV0gPSAkc3BsaXROb2RlKHNwbGl0Tm9kZSwgc3BsaXRPZmZzZXQpO1xuICAgICAgICAgIHRhcmdldCA9IHJpZ2h0VHJlZS5pbnNlcnRCZWZvcmUobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0Lmluc2VydEFmdGVyKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbmV4dFRhcmdldCA9IHRhcmdldC5nZXRQYXJlbnRPclRocm93KCk7IC8vIGlmIHdlJ3JlIGluc2VydGluZyBhbiBFbGVtZW50IGFmdGVyIGEgTGluZUJyZWFrLCB3ZSB3YW50IHRvIG1vdmUgdGhlIHRhcmdldCB0byB0aGUgcGFyZW50XG4gICAgICAgIC8vIGFuZCByZW1vdmUgdGhlIExpbmVCcmVhayBzbyB3ZSBkb24ndCBoYXZlIGVtcHR5IHNwYWNlLlxuXG4gICAgICAgIGlmICgkaXNMaW5lQnJlYWtOb2RlKHRhcmdldCkpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXQgPSBuZXh0VGFyZ2V0OyAvLyBSZS10cnkgYWdhaW4gd2l0aCB0aGUgdGFyZ2V0IGJlaW5nIHRoZSBwYXJlbnRcblxuICAgICAgICBpLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RTdGFydCkge1xuICAgICAgLy8gSGFuZGxlIG1vdmluZyBzZWxlY3Rpb24gdG8gc3RhcnQgZm9yIGFsbCBub2Rlc1xuICAgICAgaWYgKCRpc1RleHROb2RlKHN0YXJ0aW5nTm9kZSkpIHtcbiAgICAgICAgc3RhcnRpbmdOb2RlLnNlbGVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJldlNpYmxpbmcgPSB0YXJnZXQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICAgICAgaWYgKCRpc1RleHROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgICAgIHByZXZTaWJsaW5nLnNlbGVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGFyZ2V0LmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICAgICAgdGFyZ2V0LmdldFBhcmVudE9yVGhyb3coKS5zZWxlY3QoaW5kZXgsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgkaXNFbGVtZW50Tm9kZSh0YXJnZXQpKSB7XG4gICAgICAvLyBJZiB0aGUgbGFzdCBub2RlIHRvIGJlIGluc2VydGVkIHdhcyBhIHRleHQgbm9kZSxcbiAgICAgIC8vIHRoZW4gd2Ugc2hvdWxkIGF0dGVtcHQgdG8gbW92ZSBzZWxlY3Rpb24gdG8gdGhhdC5cbiAgICAgIGNvbnN0IGxhc3RDaGlsZCA9ICRpc1RleHROb2RlKGxhc3ROb2RlKSA/IGxhc3ROb2RlIDogJGlzRWxlbWVudE5vZGUobGFzdE5vZGUpICYmIGxhc3ROb2RlLmlzSW5saW5lKCkgPyBsYXN0Tm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpIDogdGFyZ2V0LmdldExhc3REZXNjZW5kYW50KCk7XG5cbiAgICAgIGlmICghc2VsZWN0U3RhcnQpIHtcbiAgICAgICAgLy8gSGFuZGxlIG1vdmluZyBzZWxlY3Rpb24gdG8gZW5kIGZvciBlbGVtZW50c1xuICAgICAgICBpZiAobGFzdENoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgdGFyZ2V0LnNlbGVjdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKCRpc1RleHROb2RlKGxhc3RDaGlsZCkpIHtcbiAgICAgICAgICBpZiAobGFzdENoaWxkLmdldFRleHRDb250ZW50KCkgPT09ICcnKSB7XG4gICAgICAgICAgICBsYXN0Q2hpbGQuc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdENoaWxkLnNlbGVjdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0Q2hpbGQuc2VsZWN0TmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaWJsaW5ncy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUYXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHNpYmxpbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IHNpYmxpbmdzW2ldO1xuICAgICAgICAgIGNvbnN0IHByZXZQYXJlbnQgPSBzaWJsaW5nLmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZSh0YXJnZXQpICYmICEkaXNCbG9ja0VsZW1lbnROb2RlKHNpYmxpbmcpICYmICEoJGlzRGVjb3JhdG9yTm9kZShzaWJsaW5nKSAmJiAoIC8vIE5vdGU6IFdlIGFyZSBvbmx5IGxvb2tpbmcgZm9yIGRlY29yYXRvcnMgdGhhdCBhcmUgaW5saW5lIGFuZCBub3QgaXNvbGF0ZWQuXG4gICAgICAgICAgIXNpYmxpbmcuaXNJbmxpbmUoKSB8fCBzaWJsaW5nLmlzSXNvbGF0ZWQoKSkpKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxUYXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgICB0YXJnZXQuYXBwZW5kKHNpYmxpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShzaWJsaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0ID0gc2libGluZztcbiAgICAgICAgICB9IGVsc2UgaWYgKCEkaXNFbGVtZW50Tm9kZSh0YXJnZXQpICYmICEkaXNCbG9ja0VsZW1lbnROb2RlKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHNpYmxpbmcpO1xuICAgICAgICAgICAgdGFyZ2V0ID0gc2libGluZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHNpYmxpbmcpICYmICFzaWJsaW5nLmNhbkluc2VydEFmdGVyKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBUaGUgY2xvbmUgbWV0aG9kIGRvZXMgZXhpc3Qgb24gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgICBjb25zdCBwcmV2UGFyZW50Q2xvbmUgPSBwcmV2UGFyZW50LmNvbnN0cnVjdG9yLmNsb25lKHByZXZQYXJlbnQpO1xuXG4gICAgICAgICAgICAgIGlmICghJGlzRWxlbWVudE5vZGUocHJldlBhcmVudENsb25lKSkge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBpbnNlcnROb2RlczogY2xvbmVkIHBhcmVudCBjbG9uZSBpcyBub3QgYW4gZWxlbWVudGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHByZXZQYXJlbnRDbG9uZS5hcHBlbmQoc2libGluZyk7XG4gICAgICAgICAgICAgIHRhcmdldC5pbnNlcnRBZnRlcihwcmV2UGFyZW50Q2xvbmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKHNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gQ2hlY2sgaWYgdGhlIHByZXYgcGFyZW50IGlzIGVtcHR5LCBhcyBpdCBtaWdodCBuZWVkXG4gICAgICAgICAgLy8gcmVtb3ZpbmcuXG5cblxuICAgICAgICAgIGlmIChwcmV2UGFyZW50LmlzRW1wdHkoKSAmJiAhcHJldlBhcmVudC5jYW5CZUVtcHR5KCkpIHtcbiAgICAgICAgICAgIHByZXZQYXJlbnQucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghc2VsZWN0U3RhcnQpIHtcbiAgICAgIC8vIEhhbmRsZSBtb3Zpbmcgc2VsZWN0aW9uIHRvIGVuZCBmb3Igb3RoZXIgbm9kZXNcbiAgICAgIGlmICgkaXNUZXh0Tm9kZSh0YXJnZXQpKSB7XG4gICAgICAgIHRhcmdldC5zZWxlY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0YXJnZXQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRhcmdldC5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgMTtcbiAgICAgICAgZWxlbWVudC5zZWxlY3QoaW5kZXgsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBhIG5ldyBQYXJhZ3JhcGhOb2RlIGludG8gdGhlIEVkaXRvclN0YXRlIGF0IHRoZSBjdXJyZW50IFNlbGVjdGlvblxuICAgKi9cblxuXG4gIGluc2VydFBhcmFncmFwaCgpIHtcbiAgICBpZiAoIXRoaXMuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgdGhpcy5yZW1vdmVUZXh0KCk7XG4gICAgfVxuXG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICBsZXQgY3VycmVudEVsZW1lbnQ7XG4gICAgbGV0IG5vZGVzVG9Nb3ZlID0gW107XG4gICAgbGV0IHNpYmxpbmdzVG9Nb3ZlID0gW107XG5cbiAgICBpZiAoYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBub2Rlc1RvTW92ZSA9IGFuY2hvck5vZGUuZ2V0TmV4dFNpYmxpbmdzKCkucmV2ZXJzZSgpO1xuICAgICAgY3VycmVudEVsZW1lbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGNvbnN0IGlzSW5saW5lID0gY3VycmVudEVsZW1lbnQuaXNJbmxpbmUoKTtcbiAgICAgIGNvbnN0IHRleHRDb250ZW50TGVuZ3RoID0gaXNJbmxpbmUgPyBjdXJyZW50RWxlbWVudC5nZXRUZXh0Q29udGVudFNpemUoKSA6IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG5cbiAgICAgIGlmIChhbmNob3JPZmZzZXQgPT09IDApIHtcbiAgICAgICAgbm9kZXNUb01vdmUucHVzaChhbmNob3JOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0lubGluZSkge1xuICAgICAgICAgIC8vIEZvciBpbmxpbmUgbm9kZXMsIHdlIHdhbnQgdG8gbW92ZSBhbGwgdGhlIHNpYmxpbmdzIHRvIHRoZSBuZXcgcGFyYWdyYXBoXG4gICAgICAgICAgLy8gaWYgc2VsZWN0aW9uIGlzIGF0IHRoZSBlbmQsIHdlIGp1c3QgbW92ZSB0aGUgc2libGluZ3MuIE90aGVyd2lzZSwgd2UgYWxzb1xuICAgICAgICAgIC8vIHNwbGl0IHRoZSB0ZXh0IG5vZGUgYW5kIGFkZCB0aGF0IGFuZCBpdCdzIHNpYmxpbmdzIGJlbG93LlxuICAgICAgICAgIHNpYmxpbmdzVG9Nb3ZlID0gY3VycmVudEVsZW1lbnQuZ2V0TmV4dFNpYmxpbmdzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5jaG9yT2Zmc2V0ICE9PSB0ZXh0Q29udGVudExlbmd0aCkge1xuICAgICAgICAgIGlmICghaXNJbmxpbmUgfHwgYW5jaG9yT2Zmc2V0ICE9PSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBbLCBzcGxpdE5vZGVdID0gYW5jaG9yTm9kZS5zcGxpdFRleHQoYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgIG5vZGVzVG9Nb3ZlLnB1c2goc3BsaXROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudEVsZW1lbnQgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuXG4gICAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChjdXJyZW50RWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjdXJyZW50RWxlbWVudC5nZXRDaGlsZEF0SW5kZXgoYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgcGFyYWdyYXBoLnNlbGVjdCgpO1xuXG4gICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNoaWxkLmluc2VydEJlZm9yZShwYXJhZ3JhcGgsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50RWxlbWVudC5hcHBlbmQocGFyYWdyYXBoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZXNUb01vdmUgPSBjdXJyZW50RWxlbWVudC5nZXRDaGlsZHJlbigpLnNsaWNlKGFuY2hvck9mZnNldCkucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGVzVG9Nb3ZlTGVuZ3RoID0gbm9kZXNUb01vdmUubGVuZ3RoO1xuXG4gICAgaWYgKGFuY2hvck9mZnNldCA9PT0gMCAmJiBub2Rlc1RvTW92ZUxlbmd0aCA+IDAgJiYgY3VycmVudEVsZW1lbnQuaXNJbmxpbmUoKSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gY3VycmVudEVsZW1lbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgY29uc3QgbmV3RWxlbWVudCA9IHBhcmVudC5pbnNlcnROZXdBZnRlcih0aGlzLCBmYWxzZSk7XG5cbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShuZXdFbGVtZW50KSkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5nZXRDaGlsZHJlbigpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBuZXdFbGVtZW50LmFwcGVuZChjaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBjdXJyZW50RWxlbWVudC5pbnNlcnROZXdBZnRlcih0aGlzLCBmYWxzZSk7XG5cbiAgICBpZiAobmV3RWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gSGFuZGxlIGFzIGEgbGluZSBicmVhayBpbnNlcnRpb25cbiAgICAgIHRoaXMuaW5zZXJ0TGluZUJyZWFrKCk7XG4gICAgfSBlbHNlIGlmICgkaXNFbGVtZW50Tm9kZShuZXdFbGVtZW50KSkge1xuICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBlbGVtZW50LCBtb3ZlIHRoZSBuZXcgZWxlbWVudCB0byBiZSBiZWZvcmUgdGhlIGN1cnJlbnQgZWxlbWVudFxuICAgICAgY29uc3QgY3VycmVudEVsZW1lbnRGaXJzdENoaWxkID0gY3VycmVudEVsZW1lbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgY29uc3QgaXNCZWdpbm5pbmcgPSBhbmNob3JPZmZzZXQgPT09IDAgJiYgKGN1cnJlbnRFbGVtZW50LmlzKGFuY2hvci5nZXROb2RlKCkpIHx8IGN1cnJlbnRFbGVtZW50Rmlyc3RDaGlsZCAmJiBjdXJyZW50RWxlbWVudEZpcnN0Q2hpbGQuaXMoYW5jaG9yLmdldE5vZGUoKSkpO1xuXG4gICAgICBpZiAoaXNCZWdpbm5pbmcgJiYgbm9kZXNUb01vdmVMZW5ndGggPiAwKSB7XG4gICAgICAgIGN1cnJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShuZXdFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZmlyc3RDaGlsZCA9IG51bGw7XG4gICAgICBjb25zdCBzaWJsaW5nc1RvTW92ZUxlbmd0aCA9IHNpYmxpbmdzVG9Nb3ZlLmxlbmd0aDtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG5ld0VsZW1lbnQuZ2V0UGFyZW50T3JUaHJvdygpOyAvLyBGb3IgaW5saW5lIGVsZW1lbnRzLCB3ZSBhcHBlbmQgdGhlIHNpYmxpbmdzIHRvIHRoZSBwYXJlbnQuXG5cbiAgICAgIGlmIChzaWJsaW5nc1RvTW92ZUxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWJsaW5nc1RvTW92ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZ1RvTW92ZSA9IHNpYmxpbmdzVG9Nb3ZlW2ldO1xuICAgICAgICAgIHBhcmVudC5hcHBlbmQoc2libGluZ1RvTW92ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVzVG9Nb3ZlTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNUb01vdmVMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5vZGVUb01vdmUgPSBub2Rlc1RvTW92ZVtpXTtcblxuICAgICAgICAgIGlmIChmaXJzdENoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgICBuZXdFbGVtZW50LmFwcGVuZChub2RlVG9Nb3ZlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUobm9kZVRvTW92ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlyc3RDaGlsZCA9IG5vZGVUb01vdmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFuZXdFbGVtZW50LmNhbkJlRW1wdHkoKSAmJiBuZXdFbGVtZW50LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICAgIG5ld0VsZW1lbnQuc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgICAgbmV3RWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0VsZW1lbnQuc2VsZWN0U3RhcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgYSBsb2dpY2FsIGxpbmVicmVhaywgd2hpY2ggbWF5IGJlIGEgbmV3IExpbmVCcmVha05vZGUgb3IgYSBuZXcgUGFyYWdyYXBoTm9kZSwgaW50byB0aGUgRWRpdG9yU3RhdGUgYXQgdGhlXG4gICAqIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0U3RhcnQgd2hldGhlciBvciBub3QgdG8gc2VsZWN0IHRoZSBzdGFydCBvZiB0aGUgaW5zZXJ0aW9uIHJhbmdlIGFmdGVyIHRoZSBvcGVyYXRpb24gY29tcGxldGVzLlxuICAgKi9cblxuXG4gIGluc2VydExpbmVCcmVhayhzZWxlY3RTdGFydCkge1xuICAgIGNvbnN0IGxpbmVCcmVha05vZGUgPSAkY3JlYXRlTGluZUJyZWFrTm9kZSgpO1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuXG4gICAgaWYgKGFuY2hvci50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuXG4gICAgICBpZiAoJGlzUm9vdE5vZGUoZWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRQYXJhZ3JhcGgoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0U3RhcnQpIHtcbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZXMoW2xpbmVCcmVha05vZGVdLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuaW5zZXJ0Tm9kZXMoW2xpbmVCcmVha05vZGVdKSkge1xuICAgICAgICBsaW5lQnJlYWtOb2RlLnNlbGVjdE5leHQoMCwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjaGFyYWN0ZXItYmFzZWQgb2Zmc2V0cyBvZiB0aGUgU2VsZWN0aW9uLCBhY2NvdW50aW5nIGZvciBub24tdGV4dCBQb2ludHNcbiAgICogYnkgdXNpbmcgdGhlIGNoaWxkcmVuIHNpemUgb3IgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgY2hhcmFjdGVyIG9mZnNldHMgZm9yIHRoZSBTZWxlY3Rpb25cbiAgICovXG5cblxuICBnZXRDaGFyYWN0ZXJPZmZzZXRzKCkge1xuICAgIHJldHVybiBnZXRDaGFyYWN0ZXJPZmZzZXRzKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBFeHRyYWN0cyB0aGUgbm9kZXMgaW4gdGhlIFNlbGVjdGlvbiwgc3BsaXR0aW5nIG5vZGVzIHdoZXJlIG5lY2Vzc2FyeVxuICAgKiB0byBnZXQgb2Zmc2V0LWxldmVsIHByZWNpc2lvbi5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb25cbiAgICovXG5cblxuICBleHRyYWN0KCkge1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2Rlc0xlbmd0aCA9IHNlbGVjdGVkTm9kZXMubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IHNlbGVjdGVkTm9kZXNMZW5ndGggLSAxO1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBsZXQgZmlyc3ROb2RlID0gc2VsZWN0ZWROb2Rlc1swXTtcbiAgICBsZXQgbGFzdE5vZGUgPSBzZWxlY3RlZE5vZGVzW2xhc3RJbmRleF07XG4gICAgY29uc3QgW2FuY2hvck9mZnNldCwgZm9jdXNPZmZzZXRdID0gZ2V0Q2hhcmFjdGVyT2Zmc2V0cyh0aGlzKTtcblxuICAgIGlmIChzZWxlY3RlZE5vZGVzTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChzZWxlY3RlZE5vZGVzTGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSAmJiAhdGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICAgICAgY29uc3Qgc3BsaXROb2RlcyA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzdGFydE9mZnNldCA9PT0gMCA/IHNwbGl0Tm9kZXNbMF0gOiBzcGxpdE5vZGVzWzFdO1xuICAgICAgICByZXR1cm4gbm9kZSAhPSBudWxsID8gW25vZGVdIDogW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbZmlyc3ROb2RlXTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG5cbiAgICBpZiAoJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSkge1xuICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBpc0JlZm9yZSA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuXG4gICAgICBpZiAoc3RhcnRPZmZzZXQgPT09IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgICAgICBzZWxlY3RlZE5vZGVzLnNoaWZ0KCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0T2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgIFssIGZpcnN0Tm9kZV0gPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgc2VsZWN0ZWROb2Rlc1swXSA9IGZpcnN0Tm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJGlzVGV4dE5vZGUobGFzdE5vZGUpKSB7XG4gICAgICBjb25zdCBsYXN0Tm9kZVRleHQgPSBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgY29uc3QgbGFzdE5vZGVUZXh0TGVuZ3RoID0gbGFzdE5vZGVUZXh0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzQmVmb3JlID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG5cbiAgICAgIGlmIChlbmRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgc2VsZWN0ZWROb2Rlcy5wb3AoKTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kT2Zmc2V0ICE9PSBsYXN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgICAgW2xhc3ROb2RlXSA9IGxhc3ROb2RlLnNwbGl0VGV4dChlbmRPZmZzZXQpO1xuICAgICAgICBzZWxlY3RlZE5vZGVzW2xhc3RJbmRleF0gPSBsYXN0Tm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0ZWROb2RlcztcbiAgfVxuICAvKipcbiAgICogTW9kaWZpZXMgdGhlIFNlbGVjdGlvbiBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtZXRlcnMgYW5kIGEgc2V0IG9mIGhldXJpc3RpY3MgdGhhdCBhY2NvdW50IGZvclxuICAgKiB2YXJpb3VzIG5vZGUgdHlwZXMuIENhbiBiZSB1c2VkIHRvIHNhZmVseSBtb3ZlIG9yIGV4dGVuZCBzZWxlY3Rpb24gYnkgb25lIGxvZ2ljYWwgXCJ1bml0XCIgd2l0aG91dFxuICAgKiBkZWFsaW5nIGV4cGxpY2l0bHkgd2l0aCBhbGwgdGhlIHBvc3NpYmxlIG5vZGUgdHlwZXMuXG4gICAqXG4gICAqIEBwYXJhbSBhbHRlciB0aGUgdHlwZSBvZiBtb2RpZmljYXRpb24gdG8gcGVyZm9ybVxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCBzZWxlY3Rpb24gaXMgYmFja3dhcmRzXG4gICAqIEBwYXJhbSBncmFudWxhcml0eSB0aGUgZ3JhbnVsYXJpdHkgYXQgd2hpY2ggdG8gYXBwbHkgdGhlIG1vZGlmaWNhdGlvblxuICAgKi9cblxuXG4gIG1vZGlmeShhbHRlciwgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHkpIHtcbiAgICBjb25zdCBmb2N1cyA9IHRoaXMuZm9jdXM7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgY29sbGFwc2UgPSBhbHRlciA9PT0gJ21vdmUnOyAvLyBIYW5kbGUgdGhlIHNlbGVjdGlvbiBtb3ZlbWVudCBhcm91bmQgZGVjb3JhdG9ycy5cblxuICAgIGNvbnN0IHBvc3NpYmxlTm9kZSA9ICRnZXRBZGphY2VudE5vZGUoZm9jdXMsIGlzQmFja3dhcmQpO1xuXG4gICAgaWYgKCRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSkge1xuICAgICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byBtb3ZlIHNlbGVjdGlvbiBmcm9tIHJhbmdlIHNlbGVjdGlvbiB0b1xuICAgICAgLy8gbm9kZSBzZWxlY3Rpb24gb24gdGhlIG5vZGUuXG4gICAgICBpZiAoY29sbGFwc2UgJiYgcG9zc2libGVOb2RlLmlzS2V5Ym9hcmRTZWxlY3RhYmxlKCkpIHtcbiAgICAgICAgY29uc3Qgbm9kZVNlbGVjdGlvbiA9ICRjcmVhdGVOb2RlU2VsZWN0aW9uKCk7XG4gICAgICAgIG5vZGVTZWxlY3Rpb24uYWRkKHBvc3NpYmxlTm9kZS5fX2tleSk7XG4gICAgICAgICRzZXRTZWxlY3Rpb24obm9kZVNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2libGluZyA9IGlzQmFja3dhcmQgPyBwb3NzaWJsZU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBwb3NzaWJsZU5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgaWYgKCEkaXNUZXh0Tm9kZShzaWJsaW5nKSkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBwb3NzaWJsZU5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICBsZXQgb2Zmc2V0O1xuICAgICAgICBsZXQgZWxlbWVudEtleTtcblxuICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoc2libGluZykpIHtcbiAgICAgICAgICBlbGVtZW50S2V5ID0gc2libGluZy5fX2tleTtcbiAgICAgICAgICBvZmZzZXQgPSBpc0JhY2t3YXJkID8gc2libGluZy5nZXRDaGlsZHJlblNpemUoKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gcG9zc2libGVOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICAgICAgZWxlbWVudEtleSA9IHBhcmVudC5fX2tleTtcblxuICAgICAgICAgIGlmICghaXNCYWNrd2FyZCkge1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9jdXMuc2V0KGVsZW1lbnRLZXksIG9mZnNldCwgJ2VsZW1lbnQnKTtcblxuICAgICAgICBpZiAoY29sbGFwc2UpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KGVsZW1lbnRLZXksIG9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdLZXkgPSBzaWJsaW5nLl9fa2V5O1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpc0JhY2t3YXJkID8gc2libGluZy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aCA6IDA7XG4gICAgICAgIGZvY3VzLnNldChzaWJsaW5nS2V5LCBvZmZzZXQsICd0ZXh0Jyk7XG5cbiAgICAgICAgaWYgKGNvbGxhcHNlKSB7XG4gICAgICAgICAgYW5jaG9yLnNldChzaWJsaW5nS2V5LCBvZmZzZXQsICd0ZXh0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcblxuICAgIGlmICghZG9tU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYmxvY2tDdXJzb3JFbGVtZW50ID0gZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQ7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuX3Jvb3RFbGVtZW50OyAvLyBSZW1vdmUgdGhlIGJsb2NrIGN1cnNvciBlbGVtZW50IGlmIGl0IGV4aXN0cy4gVGhpcyB3aWxsIGVuc3VyZSBzZWxlY3Rpb25cbiAgICAvLyB3b3JrcyBhcyBpbnRlbmRlZC4gSWYgd2UgbGVhdmUgaXQgaW4gdGhlIERPTSBhbGwgc29ydHMgb2Ygc3RyYW5nZSBidWdzXG4gICAgLy8gb2NjdXIuIDovXG5cbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwgJiYgYmxvY2tDdXJzb3JFbGVtZW50ICE9PSBudWxsICYmICRpc0VsZW1lbnROb2RlKHBvc3NpYmxlTm9kZSkgJiYgIXBvc3NpYmxlTm9kZS5pc0lubGluZSgpICYmICFwb3NzaWJsZU5vZGUuY2FuQmVFbXB0eSgpKSB7XG4gICAgICByZW1vdmVET01CbG9ja0N1cnNvckVsZW1lbnQoYmxvY2tDdXJzb3JFbGVtZW50LCBlZGl0b3IsIHJvb3RFbGVtZW50KTtcbiAgICB9IC8vIFdlIHVzZSB0aGUgRE9NIHNlbGVjdGlvbi5tb2RpZnkgQVBJIGhlcmUgdG8gXCJ0ZWxsXCIgdXMgd2hhdCB0aGUgc2VsZWN0aW9uXG4gICAgLy8gd2lsbCBiZS4gV2UgdGhlbiB1c2UgaXQgdG8gdXBkYXRlIHRoZSBMZXhpY2FsIHNlbGVjdGlvbiBhY2NvcmRpbmdseS4gVGhpc1xuICAgIC8vIGlzIG11Y2ggbW9yZSByZWxpYWJsZSB0aGFuIHdhaXRpbmcgZm9yIGEgYmVmb3JlaW5wdXQgYW5kIHVzaW5nIHRoZSByYW5nZXNcbiAgICAvLyBmcm9tIGdldFRhcmdldFJhbmdlcygpLCBhbmQgaXMgYWxzbyBiZXR0ZXIgdGhhbiB0cnlpbmcgdG8gZG8gaXQgb3Vyc2VsdmVzXG4gICAgLy8gdXNpbmcgSW50bC5TZWdtZW50ZXIgb3Igb3RoZXIgd29ya2Fyb3VuZHMgdGhhdCBzdHJ1Z2dsZSB3aXRoIHdvcmQgc2VnbWVudHNcbiAgICAvLyBhbmQgbGluZSBzZWdtZW50cyAoZXNwZWNpYWxseSB3aXRoIHdvcmQgd3JhcHBpbmcgYW5kIG5vbi1Sb21hbiBsYW5ndWFnZXMpLlxuXG5cbiAgICBtb3ZlTmF0aXZlU2VsZWN0aW9uKGRvbVNlbGVjdGlvbiwgYWx0ZXIsIGlzQmFja3dhcmQgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnLCBncmFudWxhcml0eSk7IC8vIEd1YXJkIGFnYWluc3Qgbm8gcmFuZ2VzXG5cbiAgICBpZiAoZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGRvbVNlbGVjdGlvbi5nZXRSYW5nZUF0KDApOyAvLyBBcHBseSB0aGUgRE9NIHNlbGVjdGlvbiB0byBvdXIgTGV4aWNhbCBzZWxlY3Rpb24uXG5cbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSB0aGlzLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCByb290ID0gJGlzUm9vdE5vZGUoYW5jaG9yTm9kZSkgPyBhbmNob3JOb2RlIDogJGdldE5lYXJlc3RSb290T3JTaGFkb3dSb290KGFuY2hvck5vZGUpO1xuICAgICAgdGhpcy5hcHBseURPTVJhbmdlKHJhbmdlKTtcbiAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgICBpZiAoIWNvbGxhcHNlKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIHNlbGVjdGlvbjsgbWFrZSBzdXJlIHRoYXQgdGhlIG5ldyBleHRlbmRlZCBzZWxlY3Rpb24gcmVzcGVjdHMgc2hhZG93IHJvb3RzXG4gICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgICAgICBjb25zdCB2YWxpZE5vZGVzID0gW107XG4gICAgICAgIGxldCBzaHJpbmtTZWxlY3Rpb24gPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbmV4dE5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgICAgIGlmICgkaGFzQW5jZXN0b3IobmV4dE5vZGUsIHJvb3QpKSB7XG4gICAgICAgICAgICB2YWxpZE5vZGVzLnB1c2gobmV4dE5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaHJpbmtTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaHJpbmtTZWxlY3Rpb24gJiYgdmFsaWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gdmFsaWROb2RlcyBsZW5ndGggY2hlY2sgaXMgYSBzYWZlZ3VhcmQgYWdhaW5zdCBhbiBpbnZhbGlkIHNlbGVjdGlvbjsgYXMgZ2V0Tm9kZXMoKVxuICAgICAgICAgIC8vIHdpbGwgcmV0dXJuIGFuIGVtcHR5IGFycmF5IGluIHRoaXMgY2FzZVxuICAgICAgICAgIGlmIChpc0JhY2t3YXJkKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFZhbGlkTm9kZSA9IHZhbGlkTm9kZXNbMF07XG5cbiAgICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShmaXJzdFZhbGlkTm9kZSkpIHtcbiAgICAgICAgICAgICAgZmlyc3RWYWxpZE5vZGUuc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpcnN0VmFsaWROb2RlLmdldFBhcmVudE9yVGhyb3coKS5zZWxlY3RTdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0VmFsaWROb2RlID0gdmFsaWROb2Rlc1t2YWxpZE5vZGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUobGFzdFZhbGlkTm9kZSkpIHtcbiAgICAgICAgICAgICAgbGFzdFZhbGlkTm9kZS5zZWxlY3RFbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxhc3RWYWxpZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdEVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBCZWNhdXNlIGEgcmFuZ2Ugd29ya3Mgb24gc3RhcnQgYW5kIGVuZCwgd2UgbWlnaHQgbmVlZCB0byBmbGlwXG4gICAgICAgIC8vIHRoZSBhbmNob3IgYW5kIGZvY3VzIHBvaW50cyB0byBtYXRjaCB3aGF0IHRoZSBET00gaGFzLCBub3Qgd2hhdFxuICAgICAgICAvLyB0aGUgcmFuZ2UgaGFzIHNwZWNpZmljYWxseS5cblxuXG4gICAgICAgIGlmIChkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSAhPT0gcmFuZ2Uuc3RhcnRDb250YWluZXIgfHwgZG9tU2VsZWN0aW9uLmFuY2hvck9mZnNldCAhPT0gcmFuZ2Uuc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICAkc3dhcFBvaW50cyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgb25lIGxvZ2ljYWwgY2hhcmFjdGVyIGRlbGV0aW9uIG9wZXJhdGlvbiBvbiB0aGUgRWRpdG9yU3RhdGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKiBIYW5kbGVzIGRpZmZlcmVudCBub2RlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkcy5cbiAgICovXG5cblxuICBkZWxldGVDaGFyYWN0ZXIoaXNCYWNrd2FyZCkge1xuICAgIGNvbnN0IHdhc0NvbGxhcHNlZCA9IHRoaXMuaXNDb2xsYXBzZWQoKTtcblxuICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgICAgbGV0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuXG4gICAgICBpZiAoIWlzQmFja3dhcmQgJiYgKCAvLyBEZWxldGUgZm9yd2FyZCBoYW5kbGUgY2FzZVxuICAgICAgYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiAkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSAmJiBhbmNob3Iub2Zmc2V0ID09PSBhbmNob3JOb2RlLmdldENoaWxkcmVuU2l6ZSgpIHx8IGFuY2hvci50eXBlID09PSAndGV4dCcgJiYgYW5jaG9yLm9mZnNldCA9PT0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gYW5jaG9yTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBhbmNob3JOb2RlLmdldE5leHRTaWJsaW5nKCkgfHwgKHBhcmVudCA9PT0gbnVsbCA/IG51bGwgOiBwYXJlbnQuZ2V0TmV4dFNpYmxpbmcoKSk7XG5cbiAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5leHRTaWJsaW5nKSAmJiBuZXh0U2libGluZy5pc1NoYWRvd1Jvb3QoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBIYW5kbGUgdGhlIGRlbGV0aW9uIGFyb3VuZCBkZWNvcmF0b3JzLlxuXG5cbiAgICAgIGNvbnN0IHBvc3NpYmxlTm9kZSA9ICRnZXRBZGphY2VudE5vZGUoZm9jdXMsIGlzQmFja3dhcmQpO1xuXG4gICAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJc29sYXRlZCgpKSB7XG4gICAgICAgIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gbW92ZSBzZWxlY3Rpb24gZnJvbSByYW5nZSBzZWxlY3Rpb24gdG9cbiAgICAgICAgLy8gbm9kZSBzZWxlY3Rpb24gb24gdGhlIG5vZGUuXG4gICAgICAgIGlmIChwb3NzaWJsZU5vZGUuaXNLZXlib2FyZFNlbGVjdGFibGUoKSAmJiAkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSAmJiBhbmNob3JOb2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgYW5jaG9yTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICBjb25zdCBub2RlU2VsZWN0aW9uID0gJGNyZWF0ZU5vZGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICBub2RlU2VsZWN0aW9uLmFkZChwb3NzaWJsZU5vZGUuX19rZXkpO1xuICAgICAgICAgICRzZXRTZWxlY3Rpb24obm9kZVNlbGVjdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zc2libGVOb2RlLnJlbW92ZSgpO1xuICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICghaXNCYWNrd2FyZCAmJiAkaXNFbGVtZW50Tm9kZShwb3NzaWJsZU5vZGUpICYmICRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpICYmIGFuY2hvck5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgIGFuY2hvck5vZGUucmVtb3ZlKCk7XG4gICAgICAgIHBvc3NpYmxlTm9kZS5zZWxlY3RTdGFydCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubW9kaWZ5KCdleHRlbmQnLCBpc0JhY2t3YXJkLCAnY2hhcmFjdGVyJyk7XG5cbiAgICAgIGlmICghdGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLnR5cGUgPT09ICd0ZXh0JyA/IGZvY3VzLmdldE5vZGUoKSA6IG51bGw7XG4gICAgICAgIGFuY2hvck5vZGUgPSBhbmNob3IudHlwZSA9PT0gJ3RleHQnID8gYW5jaG9yLmdldE5vZGUoKSA6IG51bGw7XG5cbiAgICAgICAgaWYgKGZvY3VzTm9kZSAhPT0gbnVsbCAmJiBmb2N1c05vZGUuaXNTZWdtZW50ZWQoKSkge1xuICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgICAgICAgICBjb25zdCB0ZXh0Q29udGVudFNpemUgPSBmb2N1c05vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG5cbiAgICAgICAgICBpZiAoZm9jdXNOb2RlLmlzKGFuY2hvck5vZGUpIHx8IGlzQmFja3dhcmQgJiYgb2Zmc2V0ICE9PSB0ZXh0Q29udGVudFNpemUgfHwgIWlzQmFja3dhcmQgJiYgb2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICAkcmVtb3ZlU2VnbWVudChmb2N1c05vZGUsIGlzQmFja3dhcmQsIG9mZnNldCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFuY2hvck5vZGUgIT09IG51bGwgJiYgYW5jaG9yTm9kZS5pc1NlZ21lbnRlZCgpKSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICAgICAgICBjb25zdCB0ZXh0Q29udGVudFNpemUgPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuXG4gICAgICAgICAgaWYgKGFuY2hvck5vZGUuaXMoZm9jdXNOb2RlKSB8fCBpc0JhY2t3YXJkICYmIG9mZnNldCAhPT0gMCB8fCAhaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IHRleHRDb250ZW50U2l6ZSkge1xuICAgICAgICAgICAgJHJlbW92ZVNlZ21lbnQoYW5jaG9yTm9kZSwgaXNCYWNrd2FyZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAkdXBkYXRlQ2FyZXRTZWxlY3Rpb25Gb3JVbmljb2RlQ2hhcmFjdGVyKHRoaXMsIGlzQmFja3dhcmQpO1xuICAgICAgfSBlbHNlIGlmIChpc0JhY2t3YXJkICYmIGFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBhcm91bmQgcmljaCB0ZXh0IG5vZGVzXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnID8gYW5jaG9yLmdldE5vZGUoKSA6IGFuY2hvci5nZXROb2RlKCkuZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gICAgICAgIGlmIChlbGVtZW50LmNvbGxhcHNlQXRTdGFydCh0aGlzKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlVGV4dCgpO1xuXG4gICAgaWYgKGlzQmFja3dhcmQgJiYgIXdhc0NvbGxhcHNlZCAmJiB0aGlzLmlzQ29sbGFwc2VkKCkgJiYgdGhpcy5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHRoaXMuYW5jaG9yLm9mZnNldCA9PT0gMCkge1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHRoaXMuYW5jaG9yLmdldE5vZGUoKTtcblxuICAgICAgaWYgKGFuY2hvck5vZGUuaXNFbXB0eSgpICYmICRpc1Jvb3ROb2RlKGFuY2hvck5vZGUuZ2V0UGFyZW50KCkpICYmIGFuY2hvck5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSA9PT0gMCkge1xuICAgICAgICBhbmNob3JOb2RlLmNvbGxhcHNlQXRTdGFydCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFBlcmZvcm1zIG9uZSBsb2dpY2FsIGxpbmUgZGVsZXRpb24gb3BlcmF0aW9uIG9uIHRoZSBFZGl0b3JTdGF0ZSBiYXNlZCBvbiB0aGUgY3VycmVudCBTZWxlY3Rpb24uXG4gICAqIEhhbmRsZXMgZGlmZmVyZW50IG5vZGUgdHlwZXMuXG4gICAqXG4gICAqIEBwYXJhbSBpc0JhY2t3YXJkIHdoZXRoZXIgb3Igbm90IHRoZSBzZWxlY3Rpb24gaXMgYmFja3dhcmRzLlxuICAgKi9cblxuXG4gIGRlbGV0ZUxpbmUoaXNCYWNrd2FyZCkge1xuICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGlmICh0aGlzLmFuY2hvci50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgdGhpcy5tb2RpZnkoJ2V4dGVuZCcsIGlzQmFja3dhcmQsICdsaW5lYm91bmRhcnknKTtcbiAgICAgIH0gLy8gSWYgc2VsZWN0aW9uIGlzIGV4dGVuZGVkIHRvIGNvdmVyIHRleHQgZWRnZSB0aGVuIGV4dGVuZCBpdCBvbmUgY2hhcmFjdGVyIG1vcmVcbiAgICAgIC8vIHRvIGRlbGV0ZSBpdHMgcGFyZW50IGVsZW1lbnQuIE90aGVyd2lzZSB0ZXh0IGNvbnRlbnQgd2lsbCBiZSBkZWxldGVkIGJ1dCBlbXB0eVxuICAgICAgLy8gcGFyZW50IG5vZGUgd2lsbCByZW1haW5cblxuXG4gICAgICBjb25zdCBlbmRQb2ludCA9IGlzQmFja3dhcmQgPyB0aGlzLmZvY3VzIDogdGhpcy5hbmNob3I7XG5cbiAgICAgIGlmIChlbmRQb2ludC5vZmZzZXQgPT09IDApIHtcbiAgICAgICAgdGhpcy5tb2RpZnkoJ2V4dGVuZCcsIGlzQmFja3dhcmQsICdjaGFyYWN0ZXInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZVRleHQoKTtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgb25lIGxvZ2ljYWwgd29yZCBkZWxldGlvbiBvcGVyYXRpb24gb24gdGhlIEVkaXRvclN0YXRlIGJhc2VkIG9uIHRoZSBjdXJyZW50IFNlbGVjdGlvbi5cbiAgICogSGFuZGxlcyBkaWZmZXJlbnQgbm9kZSB0eXBlcy5cbiAgICpcbiAgICogQHBhcmFtIGlzQmFja3dhcmQgd2hldGhlciBvciBub3QgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZHMuXG4gICAqL1xuXG5cbiAgZGVsZXRlV29yZChpc0JhY2t3YXJkKSB7XG4gICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgdGhpcy5tb2RpZnkoJ2V4dGVuZCcsIGlzQmFja3dhcmQsICd3b3JkJyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVUZXh0KCk7XG4gIH1cblxufVxuZnVuY3Rpb24gJGlzTm9kZVNlbGVjdGlvbih4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyT2Zmc2V0KHBvaW50KSB7XG4gIGNvbnN0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcblxuICBpZiAocG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfVxuXG4gIGNvbnN0IHBhcmVudCA9IHBvaW50LmdldE5vZGUoKTtcbiAgcmV0dXJuIG9mZnNldCA9PT0gcGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID8gcGFyZW50LmdldFRleHRDb250ZW50KCkubGVuZ3RoIDogMDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyT2Zmc2V0cyhzZWxlY3Rpb24pIHtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG5cbiAgaWYgKGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGFuY2hvci5rZXkgPT09IGZvY3VzLmtleSAmJiBhbmNob3Iub2Zmc2V0ID09PSBmb2N1cy5vZmZzZXQpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG5cbiAgcmV0dXJuIFtnZXRDaGFyYWN0ZXJPZmZzZXQoYW5jaG9yKSwgZ2V0Q2hhcmFjdGVyT2Zmc2V0KGZvY3VzKV07XG59XG5cbmZ1bmN0aW9uICRzd2FwUG9pbnRzKHNlbGVjdGlvbikge1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yLmtleTtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgYW5jaG9yVHlwZSA9IGFuY2hvci50eXBlO1xuICAkc2V0UG9pbnRWYWx1ZXMoYW5jaG9yLCBmb2N1cy5rZXksIGZvY3VzLm9mZnNldCwgZm9jdXMudHlwZSk7XG4gICRzZXRQb2ludFZhbHVlcyhmb2N1cywgYW5jaG9yS2V5LCBhbmNob3JPZmZzZXQsIGFuY2hvclR5cGUpO1xuICBzZWxlY3Rpb24uX2NhY2hlZE5vZGVzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gbW92ZU5hdGl2ZVNlbGVjdGlvbihkb21TZWxlY3Rpb24sIGFsdGVyLCBkaXJlY3Rpb24sIGdyYW51bGFyaXR5KSB7XG4gIC8vIFNlbGVjdGlvbi5tb2RpZnkoKSBtZXRob2QgYXBwbGllcyBhIGNoYW5nZSB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gb3IgY3Vyc29yIHBvc2l0aW9uLFxuICAvLyBidXQgaXMgc3RpbGwgbm9uLXN0YW5kYXJkIGluIHNvbWUgYnJvd3NlcnMuXG4gIGRvbVNlbGVjdGlvbi5tb2RpZnkoYWx0ZXIsIGRpcmVjdGlvbiwgZ3JhbnVsYXJpdHkpO1xufVxuXG5mdW5jdGlvbiAkdXBkYXRlQ2FyZXRTZWxlY3Rpb25Gb3JVbmljb2RlQ2hhcmFjdGVyKHNlbGVjdGlvbiwgaXNCYWNrd2FyZCkge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcblxuICBpZiAoYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvci50eXBlID09PSAndGV4dCcgJiYgZm9jdXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgLy8gSGFuZGxpbmcgb2YgbXVsdGlieXRlIGNoYXJhY3RlcnNcbiAgICBjb25zdCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICAgIGNvbnN0IGlzQmVmb3JlID0gYW5jaG9yT2Zmc2V0IDwgZm9jdXNPZmZzZXQ7XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBpc0JlZm9yZSA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzQmVmb3JlID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgY29uc3QgY2hhcmFjdGVyT2Zmc2V0ID0gZW5kT2Zmc2V0IC0gMTtcblxuICAgIGlmIChzdGFydE9mZnNldCAhPT0gY2hhcmFjdGVyT2Zmc2V0KSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpLnNsaWNlKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuXG4gICAgICBpZiAoIWRvZXNDb250YWluR3JhcGhlbWUodGV4dCkpIHtcbiAgICAgICAgaWYgKGlzQmFja3dhcmQpIHtcbiAgICAgICAgICBmb2N1cy5vZmZzZXQgPSBjaGFyYWN0ZXJPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5jaG9yLm9mZnNldCA9IGNoYXJhY3Rlck9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiAkcmVtb3ZlU2VnbWVudChub2RlLCBpc0JhY2t3YXJkLCBvZmZzZXQpIHtcbiAgY29uc3QgdGV4dE5vZGUgPSBub2RlO1xuICBjb25zdCB0ZXh0Q29udGVudCA9IHRleHROb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IHNwbGl0ID0gdGV4dENvbnRlbnQuc3BsaXQoLyg/PVxccykvZyk7XG4gIGNvbnN0IHNwbGl0TGVuZ3RoID0gc3BsaXQubGVuZ3RoO1xuICBsZXQgc2VnbWVudE9mZnNldCA9IDA7XG4gIGxldCByZXN0b3JlT2Zmc2V0ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNwbGl0TGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0ZXh0ID0gc3BsaXRbaV07XG4gICAgY29uc3QgaXNMYXN0ID0gaSA9PT0gc3BsaXRMZW5ndGggLSAxO1xuICAgIHJlc3RvcmVPZmZzZXQgPSBzZWdtZW50T2Zmc2V0O1xuICAgIHNlZ21lbnRPZmZzZXQgKz0gdGV4dC5sZW5ndGg7XG5cbiAgICBpZiAoaXNCYWNrd2FyZCAmJiBzZWdtZW50T2Zmc2V0ID09PSBvZmZzZXQgfHwgc2VnbWVudE9mZnNldCA+IG9mZnNldCB8fCBpc0xhc3QpIHtcbiAgICAgIHNwbGl0LnNwbGljZShpLCAxKTtcblxuICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICByZXN0b3JlT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjb25zdCBuZXh0VGV4dENvbnRlbnQgPSBzcGxpdC5qb2luKCcnKS50cmltKCk7XG5cbiAgaWYgKG5leHRUZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICB0ZXh0Tm9kZS5yZW1vdmUoKTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0Tm9kZS5zZXRUZXh0Q29udGVudChuZXh0VGV4dENvbnRlbnQpO1xuICAgIHRleHROb2RlLnNlbGVjdChyZXN0b3JlT2Zmc2V0LCByZXN0b3JlT2Zmc2V0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRSZXNvbHZlQW5jZXN0b3IocmVzb2x2ZWRFbGVtZW50LCByZXNvbHZlZE9mZnNldCwgbGFzdFBvaW50KSB7XG4gIGNvbnN0IHBhcmVudCA9IHJlc29sdmVkRWxlbWVudC5nZXRQYXJlbnQoKTtcbiAgcmV0dXJuIGxhc3RQb2ludCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IG51bGwgfHwgIXBhcmVudC5jYW5CZUVtcHR5KCkgfHwgcGFyZW50ICE9PSBsYXN0UG9pbnQuZ2V0Tm9kZSgpO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludChkb20sIG9mZnNldCwgbGFzdFBvaW50LCBlZGl0b3IpIHtcbiAgbGV0IHJlc29sdmVkT2Zmc2V0ID0gb2Zmc2V0O1xuICBsZXQgcmVzb2x2ZWROb2RlOyAvLyBJZiB3ZSBoYXZlIHNlbGVjdGlvbiBvbiBhbiBlbGVtZW50LCB3ZSB3aWxsXG4gIC8vIG5lZWQgdG8gZmlndXJlIG91dCAodXNpbmcgdGhlIG9mZnNldCkgd2hhdCB0ZXh0XG4gIC8vIG5vZGUgc2hvdWxkIGJlIHNlbGVjdGVkLlxuXG4gIGlmIChkb20ubm9kZVR5cGUgPT09IERPTV9FTEVNRU5UX1RZUEUpIHtcbiAgICAvLyBSZXNvbHZlIGVsZW1lbnQgdG8gYSBFbGVtZW50Tm9kZSwgb3IgVGV4dE5vZGUsIG9yIG51bGxcbiAgICBsZXQgbW92ZVNlbGVjdGlvblRvRW5kID0gZmFsc2U7IC8vIEdpdmVuIHdlJ3JlIG1vdmluZyBzZWxlY3Rpb24gdG8gYW5vdGhlciBub2RlLCBzZWxlY3Rpb24gaXNcbiAgICAvLyBkZWZpbml0ZWx5IGRpcnR5LlxuICAgIC8vIFdlIHVzZSB0aGUgYW5jaG9yIHRvIGZpbmQgd2hpY2ggY2hpbGQgbm9kZSB0byBzZWxlY3RcblxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBkb20uY2hpbGROb2RlcztcbiAgICBjb25zdCBjaGlsZE5vZGVzTGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGg7IC8vIElmIHRoZSBhbmNob3IgaXMgdGhlIHNhbWUgYXMgbGVuZ3RoLCB0aGVuIHRoaXMgbWVhbnMgd2VcbiAgICAvLyBuZWVkIHRvIHNlbGVjdCB0aGUgdmVyeSBsYXN0IHRleHQgbm9kZS5cblxuICAgIGlmIChyZXNvbHZlZE9mZnNldCA9PT0gY2hpbGROb2Rlc0xlbmd0aCkge1xuICAgICAgbW92ZVNlbGVjdGlvblRvRW5kID0gdHJ1ZTtcbiAgICAgIHJlc29sdmVkT2Zmc2V0ID0gY2hpbGROb2Rlc0xlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgbGV0IGNoaWxkRE9NID0gY2hpbGROb2Rlc1tyZXNvbHZlZE9mZnNldF07XG4gICAgbGV0IGhhc0Jsb2NrQ3Vyc29yID0gZmFsc2U7XG5cbiAgICBpZiAoY2hpbGRET00gPT09IGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50KSB7XG4gICAgICBjaGlsZERPTSA9IGNoaWxkTm9kZXNbcmVzb2x2ZWRPZmZzZXQgKyAxXTtcbiAgICAgIGhhc0Jsb2NrQ3Vyc29yID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICByZXNvbHZlZE9mZnNldC0tO1xuICAgIH1cblxuICAgIHJlc29sdmVkTm9kZSA9IGdldE5vZGVGcm9tRE9NKGNoaWxkRE9NKTtcblxuICAgIGlmICgkaXNUZXh0Tm9kZShyZXNvbHZlZE5vZGUpKSB7XG4gICAgICByZXNvbHZlZE9mZnNldCA9IGdldFRleHROb2RlT2Zmc2V0KHJlc29sdmVkTm9kZSwgbW92ZVNlbGVjdGlvblRvRW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJlc29sdmVkRWxlbWVudCA9IGdldE5vZGVGcm9tRE9NKGRvbSk7IC8vIEVuc3VyZSByZXNvbHZlZEVsZW1lbnQgaXMgYWN0dWFsbHkgYSBlbGVtZW50LlxuXG4gICAgICBpZiAocmVzb2x2ZWRFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUocmVzb2x2ZWRFbGVtZW50KSkge1xuICAgICAgICBsZXQgY2hpbGQgPSByZXNvbHZlZEVsZW1lbnQuZ2V0Q2hpbGRBdEluZGV4KHJlc29sdmVkT2Zmc2V0KTtcblxuICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpICYmIHNob3VsZFJlc29sdmVBbmNlc3RvcihjaGlsZCwgcmVzb2x2ZWRPZmZzZXQsIGxhc3RQb2ludCkpIHtcbiAgICAgICAgICBjb25zdCBkZXNjZW5kYW50ID0gbW92ZVNlbGVjdGlvblRvRW5kID8gY2hpbGQuZ2V0TGFzdERlc2NlbmRhbnQoKSA6IGNoaWxkLmdldEZpcnN0RGVzY2VuZGFudCgpO1xuXG4gICAgICAgICAgaWYgKGRlc2NlbmRhbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc29sdmVkRWxlbWVudCA9IGNoaWxkO1xuICAgICAgICAgICAgcmVzb2x2ZWRPZmZzZXQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGlsZCA9IGRlc2NlbmRhbnQ7XG4gICAgICAgICAgICByZXNvbHZlZEVsZW1lbnQgPSAkaXNFbGVtZW50Tm9kZShjaGlsZCkgPyBjaGlsZCA6IGNoaWxkLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgcmVzb2x2ZWROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgcmVzb2x2ZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlZE9mZnNldCA9IGdldFRleHROb2RlT2Zmc2V0KGNoaWxkLCBtb3ZlU2VsZWN0aW9uVG9FbmQpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkICE9PSByZXNvbHZlZEVsZW1lbnQgJiYgbW92ZVNlbGVjdGlvblRvRW5kICYmICFoYXNCbG9ja0N1cnNvcikge1xuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcmVzb2x2ZWRFbGVtZW50LmdldEluZGV4V2l0aGluUGFyZW50KCk7IC8vIFdoZW4gc2VsZWN0aW5nIGRlY29yYXRvcnMsIHRoZXJlIGNhbiBiZSBzb21lIHNlbGVjdGlvbiBpc3N1ZXMgd2hlbiB1c2luZyByZXNvbHZlZE9mZnNldCxcbiAgICAgICAgLy8gYW5kIGluc3RlYWQgd2Ugc2hvdWxkIGJlIGNoZWNraW5nIGlmIHdlJ3JlIHVzaW5nIHRoZSBvZmZzZXRcblxuICAgICAgICBpZiAob2Zmc2V0ID09PSAwICYmICRpc0RlY29yYXRvck5vZGUocmVzb2x2ZWRFbGVtZW50KSAmJiBnZXROb2RlRnJvbURPTShkb20pID09PSByZXNvbHZlZEVsZW1lbnQpIHtcbiAgICAgICAgICByZXNvbHZlZE9mZnNldCA9IGluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0ID0gaW5kZXggKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZWRFbGVtZW50ID0gcmVzb2x2ZWRFbGVtZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHJlc29sdmVkRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuICRjcmVhdGVQb2ludChyZXNvbHZlZEVsZW1lbnQuX19rZXksIHJlc29sdmVkT2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUZXh0Tm9kZSBvciBudWxsXG4gICAgcmVzb2x2ZWROb2RlID0gZ2V0Tm9kZUZyb21ET00oZG9tKTtcbiAgfVxuXG4gIGlmICghJGlzVGV4dE5vZGUocmVzb2x2ZWROb2RlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuICRjcmVhdGVQb2ludChyZXNvbHZlZE5vZGUuX19rZXksIHJlc29sdmVkT2Zmc2V0LCAndGV4dCcpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2VsZWN0aW9uUG9pbnRPbkJvdW5kYXJ5KHBvaW50LCBpc0JhY2t3YXJkLCBpc0NvbGxhcHNlZCkge1xuICBjb25zdCBvZmZzZXQgPSBwb2ludC5vZmZzZXQ7XG4gIGNvbnN0IG5vZGUgPSBwb2ludC5nZXROb2RlKCk7XG5cbiAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKCFpc0JhY2t3YXJkKSB7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUocHJldlNpYmxpbmcpICYmICFpc0NvbGxhcHNlZCAmJiBwcmV2U2libGluZy5pc0lubGluZSgpKSB7XG4gICAgICAgIHBvaW50LmtleSA9IHByZXZTaWJsaW5nLl9fa2V5O1xuICAgICAgICBwb2ludC5vZmZzZXQgPSBwcmV2U2libGluZy5nZXRDaGlsZHJlblNpemUoKTsgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZW50aW9uYWxcblxuICAgICAgICBwb2ludC50eXBlID0gJ2VsZW1lbnQnO1xuICAgICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZShwcmV2U2libGluZykpIHtcbiAgICAgICAgcG9pbnQua2V5ID0gcHJldlNpYmxpbmcuX19rZXk7XG4gICAgICAgIHBvaW50Lm9mZnNldCA9IHByZXZTaWJsaW5nLmdldFRleHRDb250ZW50KCkubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGlzQ29sbGFwc2VkIHx8ICFpc0JhY2t3YXJkKSAmJiBwcmV2U2libGluZyA9PT0gbnVsbCAmJiAkaXNFbGVtZW50Tm9kZShwYXJlbnQpICYmIHBhcmVudC5pc0lubGluZSgpKSB7XG4gICAgICBjb25zdCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpO1xuXG4gICAgICBpZiAoJGlzVGV4dE5vZGUocGFyZW50U2libGluZykpIHtcbiAgICAgICAgcG9pbnQua2V5ID0gcGFyZW50U2libGluZy5fX2tleTtcbiAgICAgICAgcG9pbnQub2Zmc2V0ID0gcGFyZW50U2libGluZy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAob2Zmc2V0ID09PSBub2RlLmdldFRleHRDb250ZW50KCkubGVuZ3RoKSB7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChpc0JhY2t3YXJkICYmICRpc0VsZW1lbnROb2RlKG5leHRTaWJsaW5nKSAmJiBuZXh0U2libGluZy5pc0lubGluZSgpKSB7XG4gICAgICBwb2ludC5rZXkgPSBuZXh0U2libGluZy5fX2tleTtcbiAgICAgIHBvaW50Lm9mZnNldCA9IDA7IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVudGlvbmFsXG5cbiAgICAgIHBvaW50LnR5cGUgPSAnZWxlbWVudCc7XG4gICAgfSBlbHNlIGlmICgoaXNDb2xsYXBzZWQgfHwgaXNCYWNrd2FyZCkgJiYgbmV4dFNpYmxpbmcgPT09IG51bGwgJiYgJGlzRWxlbWVudE5vZGUocGFyZW50KSAmJiBwYXJlbnQuaXNJbmxpbmUoKSAmJiAhcGFyZW50LmNhbkluc2VydFRleHRBZnRlcigpKSB7XG4gICAgICBjb25zdCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICAgIGlmICgkaXNUZXh0Tm9kZShwYXJlbnRTaWJsaW5nKSkge1xuICAgICAgICBwb2ludC5rZXkgPSBwYXJlbnRTaWJsaW5nLl9fa2V5O1xuICAgICAgICBwb2ludC5vZmZzZXQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTZWxlY3Rpb25Qb2ludHNGb3JCb3VuZGFyaWVzKGFuY2hvciwgZm9jdXMsIGxhc3RTZWxlY3Rpb24pIHtcbiAgaWYgKGFuY2hvci50eXBlID09PSAndGV4dCcgJiYgZm9jdXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgY29uc3QgaXNDb2xsYXBzZWQgPSBhbmNob3IuaXMoZm9jdXMpOyAvLyBBdHRlbXB0IHRvIG5vcm1hbGl6ZSB0aGUgb2Zmc2V0IHRvIHRoZSBwcmV2aW91cyBzaWJsaW5nIGlmIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHN0YXJ0IG9mIGEgdGV4dCBub2RlIGFuZCB0aGUgc2libGluZyBpcyBhIHRleHQgbm9kZSBvciBpbmxpbmUgZWxlbWVudC5cblxuICAgIHJlc29sdmVTZWxlY3Rpb25Qb2ludE9uQm91bmRhcnkoYW5jaG9yLCBpc0JhY2t3YXJkLCBpc0NvbGxhcHNlZCk7XG4gICAgcmVzb2x2ZVNlbGVjdGlvblBvaW50T25Cb3VuZGFyeShmb2N1cywgIWlzQmFja3dhcmQsIGlzQ29sbGFwc2VkKTtcblxuICAgIGlmIChpc0NvbGxhcHNlZCkge1xuICAgICAgZm9jdXMua2V5ID0gYW5jaG9yLmtleTtcbiAgICAgIGZvY3VzLm9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICBmb2N1cy50eXBlID0gYW5jaG9yLnR5cGU7XG4gICAgfVxuXG4gICAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG5cbiAgICBpZiAoZWRpdG9yLmlzQ29tcG9zaW5nKCkgJiYgZWRpdG9yLl9jb21wb3NpdGlvbktleSAhPT0gYW5jaG9yLmtleSAmJiAkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgbGFzdEFuY2hvciA9IGxhc3RTZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgbGFzdEZvY3VzID0gbGFzdFNlbGVjdGlvbi5mb2N1cztcbiAgICAgICRzZXRQb2ludFZhbHVlcyhhbmNob3IsIGxhc3RBbmNob3Iua2V5LCBsYXN0QW5jaG9yLm9mZnNldCwgbGFzdEFuY2hvci50eXBlKTtcbiAgICAgICRzZXRQb2ludFZhbHVlcyhmb2N1cywgbGFzdEZvY3VzLmtleSwgbGFzdEZvY3VzLm9mZnNldCwgbGFzdEZvY3VzLnR5cGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludHMoYW5jaG9yRE9NLCBhbmNob3JPZmZzZXQsIGZvY3VzRE9NLCBmb2N1c09mZnNldCwgZWRpdG9yLCBsYXN0U2VsZWN0aW9uKSB7XG4gIGlmIChhbmNob3JET00gPT09IG51bGwgfHwgZm9jdXNET00gPT09IG51bGwgfHwgIWlzU2VsZWN0aW9uV2l0aGluRWRpdG9yKGVkaXRvciwgYW5jaG9yRE9NLCBmb2N1c0RPTSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkQW5jaG9yUG9pbnQgPSBpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludChhbmNob3JET00sIGFuY2hvck9mZnNldCwgJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgPyBsYXN0U2VsZWN0aW9uLmFuY2hvciA6IG51bGwsIGVkaXRvcik7XG5cbiAgaWYgKHJlc29sdmVkQW5jaG9yUG9pbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHJlc29sdmVkRm9jdXNQb2ludCA9IGludGVybmFsUmVzb2x2ZVNlbGVjdGlvblBvaW50KGZvY3VzRE9NLCBmb2N1c09mZnNldCwgJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgPyBsYXN0U2VsZWN0aW9uLmZvY3VzIDogbnVsbCwgZWRpdG9yKTtcblxuICBpZiAocmVzb2x2ZWRGb2N1c1BvaW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocmVzb2x2ZWRBbmNob3JQb2ludC50eXBlID09PSAnZWxlbWVudCcgJiYgcmVzb2x2ZWRGb2N1c1BvaW50LnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBnZXROb2RlRnJvbURPTShhbmNob3JET00pO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IGdldE5vZGVGcm9tRE9NKGZvY3VzRE9NKTsgLy8gRW5zdXJlIGlmIHdlJ3JlIHNlbGVjdGluZyB0aGUgY29udGVudCBvZiBhIGRlY29yYXRvciB0aGF0IHdlXG4gICAgLy8gcmV0dXJuIG51bGwgZm9yIHRoaXMgcG9pbnQsIGFzIGl0J3Mgbm90IGluIHRoZSBjb250cm9sbGVkIHNjb3BlXG4gICAgLy8gb2YgTGV4aWNhbC5cblxuICAgIGlmICgkaXNEZWNvcmF0b3JOb2RlKGFuY2hvck5vZGUpICYmICRpc0RlY29yYXRvck5vZGUoZm9jdXNOb2RlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IC8vIEhhbmRsZSBub3JtYWxpemF0aW9uIG9mIHNlbGVjdGlvbiB3aGVuIGl0IGlzIGF0IHRoZSBib3VuZGFyaWVzLlxuXG5cbiAgbm9ybWFsaXplU2VsZWN0aW9uUG9pbnRzRm9yQm91bmRhcmllcyhyZXNvbHZlZEFuY2hvclBvaW50LCByZXNvbHZlZEZvY3VzUG9pbnQsIGxhc3RTZWxlY3Rpb24pO1xuICByZXR1cm4gW3Jlc29sdmVkQW5jaG9yUG9pbnQsIHJlc29sdmVkRm9jdXNQb2ludF07XG59XG5cbmZ1bmN0aW9uICRpc0Jsb2NrRWxlbWVudE5vZGUobm9kZSkge1xuICByZXR1cm4gJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuaXNJbmxpbmUoKTtcbn0gLy8gVGhpcyBpcyB1c2VkIHRvIG1ha2UgYSBzZWxlY3Rpb24gd2hlbiB0aGUgZXhpc3Rpbmdcbi8vIHNlbGVjdGlvbiBpcyBudWxsLCBpLmUuIGZvcmNpbmcgc2VsZWN0aW9uIG9uIHRoZSBlZGl0b3Jcbi8vIHdoZW4gaXQgY3VycmVudCBleGlzdHMgb3V0c2lkZSB0aGUgZWRpdG9yLlxuXG5mdW5jdGlvbiBpbnRlcm5hbE1ha2VSYW5nZVNlbGVjdGlvbihhbmNob3JLZXksIGFuY2hvck9mZnNldCwgZm9jdXNLZXksIGZvY3VzT2Zmc2V0LCBhbmNob3JUeXBlLCBmb2N1c1R5cGUpIHtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBzZWxlY3Rpb24gPSBuZXcgUmFuZ2VTZWxlY3Rpb24oJGNyZWF0ZVBvaW50KGFuY2hvcktleSwgYW5jaG9yT2Zmc2V0LCBhbmNob3JUeXBlKSwgJGNyZWF0ZVBvaW50KGZvY3VzS2V5LCBmb2N1c09mZnNldCwgZm9jdXNUeXBlKSwgMCwgJycpO1xuICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICByZXR1cm4gc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCkge1xuICBjb25zdCBhbmNob3IgPSAkY3JlYXRlUG9pbnQoJ3Jvb3QnLCAwLCAnZWxlbWVudCcpO1xuICBjb25zdCBmb2N1cyA9ICRjcmVhdGVQb2ludCgncm9vdCcsIDAsICdlbGVtZW50Jyk7XG4gIHJldHVybiBuZXcgUmFuZ2VTZWxlY3Rpb24oYW5jaG9yLCBmb2N1cywgMCwgJycpO1xufVxuZnVuY3Rpb24gJGNyZWF0ZU5vZGVTZWxlY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbihuZXcgU2V0KCkpO1xufVxuZnVuY3Rpb24gREVQUkVDQVRFRF8kY3JlYXRlR3JpZFNlbGVjdGlvbigpIHtcbiAgY29uc3QgYW5jaG9yID0gJGNyZWF0ZVBvaW50KCdyb290JywgMCwgJ2VsZW1lbnQnKTtcbiAgY29uc3QgZm9jdXMgPSAkY3JlYXRlUG9pbnQoJ3Jvb3QnLCAwLCAnZWxlbWVudCcpO1xuICByZXR1cm4gbmV3IEdyaWRTZWxlY3Rpb24oJ3Jvb3QnLCBhbmNob3IsIGZvY3VzKTtcbn1cbmZ1bmN0aW9uIGludGVybmFsQ3JlYXRlU2VsZWN0aW9uKGVkaXRvcikge1xuICBjb25zdCBjdXJyZW50RWRpdG9yU3RhdGUgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuXG4gIGlmICgkaXNOb2RlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24pIHx8IERFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBsYXN0U2VsZWN0aW9uLmNsb25lKCk7XG4gIH1cblxuICByZXR1cm4gaW50ZXJuYWxDcmVhdGVSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uLCBkb21TZWxlY3Rpb24sIGVkaXRvcik7XG59XG5mdW5jdGlvbiBpbnRlcm5hbENyZWF0ZVJhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24sIGRvbVNlbGVjdGlvbiwgZWRpdG9yKSB7XG4gIGNvbnN0IHdpbmRvd09iaiA9IGVkaXRvci5fd2luZG93O1xuXG4gIGlmICh3aW5kb3dPYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBXaGVuIHdlIGNyZWF0ZSBhIHNlbGVjdGlvbiwgd2UgdHJ5IHRvIHVzZSB0aGUgcHJldmlvdXNcbiAgLy8gc2VsZWN0aW9uIHdoZXJlIHBvc3NpYmxlLCB1bmxlc3MgYW4gYWN0dWFsIHVzZXIgc2VsZWN0aW9uXG4gIC8vIGNoYW5nZSBoYXMgb2NjdXJyZWQuIFdoZW4gd2UgZG8gbmVlZCB0byBjcmVhdGUgYSBuZXcgc2VsZWN0aW9uXG4gIC8vIHdlIHZhbGlkYXRlIHdlIGNhbiBoYXZlIHRleHQgbm9kZXMgZm9yIGJvdGggYW5jaG9yIGFuZCBmb2N1c1xuICAvLyBub2Rlcy4gSWYgdGhhdCBob2xkcyB0cnVlLCB3ZSB0aGVuIHJldHVybiB0aGF0IHNlbGVjdGlvblxuICAvLyBhcyBhIG11dGFibGUgb2JqZWN0IHRoYXQgd2UgdXNlIGZvciB0aGUgZWRpdG9yIHN0YXRlIGZvciB0aGlzXG4gIC8vIHVwZGF0ZSBjeWNsZS4gSWYgYSBzZWxlY3Rpb24gZ2V0cyBjaGFuZ2VkLCBhbmQgcmVxdWlyZXMgYVxuICAvLyB1cGRhdGUgdG8gbmF0aXZlIERPTSBzZWxlY3Rpb24sIGl0IGdldHMgbWFya2VkIGFzIFwiZGlydHlcIi5cbiAgLy8gSWYgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLCBidXQgbWF0Y2hlcyB3aXRoIHRoZSBleGlzdGluZ1xuICAvLyBET00gc2VsZWN0aW9uLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBzeW5jIGl0LiBPdGhlcndpc2UsXG4gIC8vIHdlIGdlbmVyYWxseSBiYWlsIG91dCBvZiBkb2luZyBhbiB1cGRhdGUgdG8gc2VsZWN0aW9uIGR1cmluZ1xuICAvLyByZWNvbmNpbGlhdGlvbiB1bmxlc3MgdGhlcmUgYXJlIGRpcnR5IG5vZGVzIHRoYXQgbmVlZFxuICAvLyByZWNvbmNpbGluZy5cblxuXG4gIGNvbnN0IHdpbmRvd0V2ZW50ID0gd2luZG93T2JqLmV2ZW50O1xuICBjb25zdCBldmVudFR5cGUgPSB3aW5kb3dFdmVudCA/IHdpbmRvd0V2ZW50LnR5cGUgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGlzU2VsZWN0aW9uQ2hhbmdlID0gZXZlbnRUeXBlID09PSAnc2VsZWN0aW9uY2hhbmdlJztcbiAgY29uc3QgdXNlRE9NU2VsZWN0aW9uID0gIWdldElzUHJvY2Vzc3NpbmdNdXRhdGlvbnMoKSAmJiAoaXNTZWxlY3Rpb25DaGFuZ2UgfHwgZXZlbnRUeXBlID09PSAnYmVmb3JlaW5wdXQnIHx8IGV2ZW50VHlwZSA9PT0gJ2NvbXBvc2l0aW9uc3RhcnQnIHx8IGV2ZW50VHlwZSA9PT0gJ2NvbXBvc2l0aW9uZW5kJyB8fCBldmVudFR5cGUgPT09ICdjbGljaycgJiYgd2luZG93RXZlbnQgJiYgd2luZG93RXZlbnQuZGV0YWlsID09PSAzIHx8IGV2ZW50VHlwZSA9PT0gJ2Ryb3AnIHx8IGV2ZW50VHlwZSA9PT0gdW5kZWZpbmVkKTtcbiAgbGV0IGFuY2hvckRPTSwgZm9jdXNET00sIGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQ7XG5cbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSB8fCB1c2VET01TZWxlY3Rpb24pIHtcbiAgICBpZiAoZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNob3JET00gPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgICBmb2N1c0RPTSA9IGRvbVNlbGVjdGlvbi5mb2N1c05vZGU7XG4gICAgYW5jaG9yT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgICBmb2N1c09mZnNldCA9IGRvbVNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICAgIGlmIChpc1NlbGVjdGlvbkNoYW5nZSAmJiAkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSAmJiAhaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET00sIGZvY3VzRE9NKSkge1xuICAgICAgcmV0dXJuIGxhc3RTZWxlY3Rpb24uY2xvbmUoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhc3RTZWxlY3Rpb24uY2xvbmUoKTtcbiAgfSAvLyBMZXQncyByZXNvbHZlIHRoZSB0ZXh0IG5vZGVzIGZyb20gdGhlIG9mZnNldHMgYW5kIERPTSBub2RlcyB3ZSBoYXZlIGZyb21cbiAgLy8gbmF0aXZlIHNlbGVjdGlvbi5cblxuXG4gIGNvbnN0IHJlc29sdmVkU2VsZWN0aW9uUG9pbnRzID0gaW50ZXJuYWxSZXNvbHZlU2VsZWN0aW9uUG9pbnRzKGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0LCBmb2N1c0RPTSwgZm9jdXNPZmZzZXQsIGVkaXRvciwgbGFzdFNlbGVjdGlvbik7XG5cbiAgaWYgKHJlc29sdmVkU2VsZWN0aW9uUG9pbnRzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBbcmVzb2x2ZWRBbmNob3JQb2ludCwgcmVzb2x2ZWRGb2N1c1BvaW50XSA9IHJlc29sdmVkU2VsZWN0aW9uUG9pbnRzO1xuICByZXR1cm4gbmV3IFJhbmdlU2VsZWN0aW9uKHJlc29sdmVkQW5jaG9yUG9pbnQsIHJlc29sdmVkRm9jdXNQb2ludCwgISRpc1JhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24pID8gMCA6IGxhc3RTZWxlY3Rpb24uZm9ybWF0LCAhJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgPyAnJyA6IGxhc3RTZWxlY3Rpb24uc3R5bGUpO1xufVxuZnVuY3Rpb24gJGdldFNlbGVjdGlvbigpIHtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpO1xuICByZXR1cm4gZWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uICRnZXRQcmV2aW91c1NlbGVjdGlvbigpIHtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIHJldHVybiBlZGl0b3IuX2VkaXRvclN0YXRlLl9zZWxlY3Rpb247XG59XG5mdW5jdGlvbiAkdXBkYXRlRWxlbWVudFNlbGVjdGlvbk9uQ3JlYXRlRGVsZXRlTm9kZShzZWxlY3Rpb24sIHBhcmVudE5vZGUsIG5vZGVPZmZzZXQsIHRpbWVzID0gMSkge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcblxuICBpZiAoIXBhcmVudE5vZGUuaXMoYW5jaG9yTm9kZSkgJiYgIXBhcmVudE5vZGUuaXMoZm9jdXNOb2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBhcmVudEtleSA9IHBhcmVudE5vZGUuX19rZXk7IC8vIFNpbmdsZSBub2RlLiBXZSBzaGlmdCBzZWxlY3Rpb24gYnV0IG5ldmVyIHJlZGltZW5zaW9uIGl0XG5cbiAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcblxuICAgIGlmIChub2RlT2Zmc2V0IDw9IHNlbGVjdGlvbk9mZnNldCAmJiB0aW1lcyA+IDAgfHwgbm9kZU9mZnNldCA8IHNlbGVjdGlvbk9mZnNldCAmJiB0aW1lcyA8IDApIHtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbk9mZnNldCA9IE1hdGgubWF4KDAsIHNlbGVjdGlvbk9mZnNldCArIHRpbWVzKTtcbiAgICAgIGFuY2hvci5zZXQocGFyZW50S2V5LCBuZXdTZWxlY3Rpb25PZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICBmb2N1cy5zZXQocGFyZW50S2V5LCBuZXdTZWxlY3Rpb25PZmZzZXQsICdlbGVtZW50Jyk7IC8vIFRoZSBuZXcgc2VsZWN0aW9uIG1pZ2h0IHBvaW50IHRvIHRleHQgbm9kZXMsIHRyeSB0byByZXNvbHZlIHRoZW1cblxuICAgICAgJHVwZGF0ZVNlbGVjdGlvblJlc29sdmVUZXh0Tm9kZXMoc2VsZWN0aW9uKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gTXVsdGlwbGUgbm9kZXMgc2VsZWN0ZWQuIFdlIHNoaWZ0IG9yIHJlZGltZW5zaW9uIHNlbGVjdGlvblxuICAgIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBpc0JhY2t3YXJkID8gZm9jdXMgOiBhbmNob3I7XG4gICAgY29uc3QgZmlyc3RQb2ludE5vZGUgPSBmaXJzdFBvaW50LmdldE5vZGUoKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBpc0JhY2t3YXJkID8gYW5jaG9yIDogZm9jdXM7XG4gICAgY29uc3QgbGFzdFBvaW50Tm9kZSA9IGxhc3RQb2ludC5nZXROb2RlKCk7XG5cbiAgICBpZiAocGFyZW50Tm9kZS5pcyhmaXJzdFBvaW50Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGZpcnN0UG9pbnRPZmZzZXQgPSBmaXJzdFBvaW50Lm9mZnNldDtcblxuICAgICAgaWYgKG5vZGVPZmZzZXQgPD0gZmlyc3RQb2ludE9mZnNldCAmJiB0aW1lcyA+IDAgfHwgbm9kZU9mZnNldCA8IGZpcnN0UG9pbnRPZmZzZXQgJiYgdGltZXMgPCAwKSB7XG4gICAgICAgIGZpcnN0UG9pbnQuc2V0KHBhcmVudEtleSwgTWF0aC5tYXgoMCwgZmlyc3RQb2ludE9mZnNldCArIHRpbWVzKSwgJ2VsZW1lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGFyZW50Tm9kZS5pcyhsYXN0UG9pbnROb2RlKSkge1xuICAgICAgY29uc3QgbGFzdFBvaW50T2Zmc2V0ID0gbGFzdFBvaW50Lm9mZnNldDtcblxuICAgICAgaWYgKG5vZGVPZmZzZXQgPD0gbGFzdFBvaW50T2Zmc2V0ICYmIHRpbWVzID4gMCB8fCBub2RlT2Zmc2V0IDwgbGFzdFBvaW50T2Zmc2V0ICYmIHRpbWVzIDwgMCkge1xuICAgICAgICBsYXN0UG9pbnQuc2V0KHBhcmVudEtleSwgTWF0aC5tYXgoMCwgbGFzdFBvaW50T2Zmc2V0ICsgdGltZXMpLCAnZWxlbWVudCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGUgbmV3IHNlbGVjdGlvbiBtaWdodCBwb2ludCB0byB0ZXh0IG5vZGVzLCB0cnkgdG8gcmVzb2x2ZSB0aGVtXG5cblxuICAkdXBkYXRlU2VsZWN0aW9uUmVzb2x2ZVRleHROb2RlcyhzZWxlY3Rpb24pO1xufVxuXG5mdW5jdGlvbiAkdXBkYXRlU2VsZWN0aW9uUmVzb2x2ZVRleHROb2RlcyhzZWxlY3Rpb24pIHtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuXG4gIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgIGlmICghJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjaGlsZFNpemUgPSBhbmNob3JOb2RlLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgIGNvbnN0IGFuY2hvck9mZnNldEF0RW5kID0gYW5jaG9yT2Zmc2V0ID49IGNoaWxkU2l6ZTtcbiAgICBjb25zdCBjaGlsZCA9IGFuY2hvck9mZnNldEF0RW5kID8gYW5jaG9yTm9kZS5nZXRDaGlsZEF0SW5kZXgoY2hpbGRTaXplIC0gMSkgOiBhbmNob3JOb2RlLmdldENoaWxkQXRJbmRleChhbmNob3JPZmZzZXQpO1xuXG4gICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgbGV0IG5ld09mZnNldCA9IDA7XG5cbiAgICAgIGlmIChhbmNob3JPZmZzZXRBdEVuZCkge1xuICAgICAgICBuZXdPZmZzZXQgPSBjaGlsZC5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIH1cblxuICAgICAgYW5jaG9yLnNldChjaGlsZC5fX2tleSwgbmV3T2Zmc2V0LCAndGV4dCcpO1xuICAgICAgZm9jdXMuc2V0KGNoaWxkLl9fa2V5LCBuZXdPZmZzZXQsICd0ZXh0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgY29uc3QgY2hpbGRTaXplID0gYW5jaG9yTm9kZS5nZXRDaGlsZHJlblNpemUoKTtcbiAgICBjb25zdCBhbmNob3JPZmZzZXRBdEVuZCA9IGFuY2hvck9mZnNldCA+PSBjaGlsZFNpemU7XG4gICAgY29uc3QgY2hpbGQgPSBhbmNob3JPZmZzZXRBdEVuZCA/IGFuY2hvck5vZGUuZ2V0Q2hpbGRBdEluZGV4KGNoaWxkU2l6ZSAtIDEpIDogYW5jaG9yTm9kZS5nZXRDaGlsZEF0SW5kZXgoYW5jaG9yT2Zmc2V0KTtcblxuICAgIGlmICgkaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgIGxldCBuZXdPZmZzZXQgPSAwO1xuXG4gICAgICBpZiAoYW5jaG9yT2Zmc2V0QXRFbmQpIHtcbiAgICAgICAgbmV3T2Zmc2V0ID0gY2hpbGQuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICB9XG5cbiAgICAgIGFuY2hvci5zZXQoY2hpbGQuX19rZXksIG5ld09mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoJGlzRWxlbWVudE5vZGUoZm9jdXNOb2RlKSkge1xuICAgIGNvbnN0IGNoaWxkU2l6ZSA9IGZvY3VzTm9kZS5nZXRDaGlsZHJlblNpemUoKTtcbiAgICBjb25zdCBmb2N1c09mZnNldEF0RW5kID0gZm9jdXNPZmZzZXQgPj0gY2hpbGRTaXplO1xuICAgIGNvbnN0IGNoaWxkID0gZm9jdXNPZmZzZXRBdEVuZCA/IGZvY3VzTm9kZS5nZXRDaGlsZEF0SW5kZXgoY2hpbGRTaXplIC0gMSkgOiBmb2N1c05vZGUuZ2V0Q2hpbGRBdEluZGV4KGZvY3VzT2Zmc2V0KTtcblxuICAgIGlmICgkaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgIGxldCBuZXdPZmZzZXQgPSAwO1xuXG4gICAgICBpZiAoZm9jdXNPZmZzZXRBdEVuZCkge1xuICAgICAgICBuZXdPZmZzZXQgPSBjaGlsZC5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIH1cblxuICAgICAgZm9jdXMuc2V0KGNoaWxkLl9fa2V5LCBuZXdPZmZzZXQsICd0ZXh0Jyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5U2VsZWN0aW9uVHJhbnNmb3JtcyhuZXh0RWRpdG9yU3RhdGUsIGVkaXRvcikge1xuICBjb25zdCBwcmV2RWRpdG9yU3RhdGUgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgcHJldlNlbGVjdGlvbiA9IHByZXZFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG5cbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKG5leHRTZWxlY3Rpb24pKSB7XG4gICAgY29uc3QgYW5jaG9yID0gbmV4dFNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSBuZXh0U2VsZWN0aW9uLmZvY3VzO1xuICAgIGxldCBhbmNob3JOb2RlO1xuXG4gICAgaWYgKGFuY2hvci50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgYW5jaG9yTm9kZS5zZWxlY3Rpb25UcmFuc2Zvcm0ocHJldlNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGZvY3VzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuXG4gICAgICBpZiAoYW5jaG9yTm9kZSAhPT0gZm9jdXNOb2RlKSB7XG4gICAgICAgIGZvY3VzTm9kZS5zZWxlY3Rpb25UcmFuc2Zvcm0ocHJldlNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtb3ZlU2VsZWN0aW9uUG9pbnRUb1NpYmxpbmcocG9pbnQsIG5vZGUsIHBhcmVudCwgcHJldlNpYmxpbmcsIG5leHRTaWJsaW5nKSB7XG4gIGxldCBzaWJsaW5nS2V5ID0gbnVsbDtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGxldCB0eXBlID0gbnVsbDtcblxuICBpZiAocHJldlNpYmxpbmcgIT09IG51bGwpIHtcbiAgICBzaWJsaW5nS2V5ID0gcHJldlNpYmxpbmcuX19rZXk7XG5cbiAgICBpZiAoJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICBvZmZzZXQgPSBwcmV2U2libGluZy5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIHR5cGUgPSAndGV4dCc7XG4gICAgfSBlbHNlIGlmICgkaXNFbGVtZW50Tm9kZShwcmV2U2libGluZykpIHtcbiAgICAgIG9mZnNldCA9IHByZXZTaWJsaW5nLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgICAgdHlwZSA9ICdlbGVtZW50JztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nS2V5ID0gbmV4dFNpYmxpbmcuX19rZXk7XG5cbiAgICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgICAgdHlwZSA9ICd0ZXh0JztcbiAgICAgIH0gZWxzZSBpZiAoJGlzRWxlbWVudE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgIHR5cGUgPSAnZWxlbWVudCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNpYmxpbmdLZXkgIT09IG51bGwgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIHBvaW50LnNldChzaWJsaW5nS2V5LCBvZmZzZXQsIHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldCA9IG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcblxuICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAvLyBNb3ZlIHNlbGVjdGlvbiB0byBlbmQgb2YgcGFyZW50XG4gICAgICBvZmZzZXQgPSBwYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgfVxuXG4gICAgcG9pbnQuc2V0KHBhcmVudC5fX2tleSwgb2Zmc2V0LCAnZWxlbWVudCcpO1xuICB9XG59XG5mdW5jdGlvbiBhZGp1c3RQb2ludE9mZnNldEZvck1lcmdlZFNpYmxpbmcocG9pbnQsIGlzQmVmb3JlLCBrZXksIHRhcmdldCwgdGV4dExlbmd0aCkge1xuICBpZiAocG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgcG9pbnQua2V5ID0ga2V5O1xuXG4gICAgaWYgKCFpc0JlZm9yZSkge1xuICAgICAgcG9pbnQub2Zmc2V0ICs9IHRleHRMZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBvaW50Lm9mZnNldCA+IHRhcmdldC5nZXRJbmRleFdpdGhpblBhcmVudCgpKSB7XG4gICAgcG9pbnQub2Zmc2V0IC09IDE7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZURPTVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uLCBlZGl0b3IsIGRvbVNlbGVjdGlvbiwgdGFncywgcm9vdEVsZW1lbnQsIG5vZGVDb3VudCkge1xuICBjb25zdCBhbmNob3JET01Ob2RlID0gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIGNvbnN0IGZvY3VzRE9NTm9kZSA9IGRvbVNlbGVjdGlvbi5mb2N1c05vZGU7XG4gIGNvbnN0IGFuY2hvck9mZnNldCA9IGRvbVNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDsgLy8gVE9ETzogbWFrZSB0aGlzIG5vdCBoYXJkLWNvZGVkLCBhbmQgYWRkIGFub3RoZXIgY29uZmlnIG9wdGlvblxuICAvLyB0aGF0IG1ha2VzIHRoaXMgY29uZmlndXJhYmxlLlxuXG4gIGlmICh0YWdzLmhhcygnY29sbGFib3JhdGlvbicpICYmIGFjdGl2ZUVsZW1lbnQgIT09IHJvb3RFbGVtZW50IHx8IGFjdGl2ZUVsZW1lbnQgIT09IG51bGwgJiYgaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9ySW5wdXQoYWN0aXZlRWxlbWVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKG5leHRTZWxlY3Rpb24pKSB7XG4gICAgLy8gV2UgZG9uJ3QgcmVtb3ZlIHNlbGVjdGlvbiBpZiB0aGUgcHJldlNlbGVjdGlvbiBpcyBudWxsIGJlY2F1c2VcbiAgICAvLyBvZiBlZGl0b3Iuc2V0Um9vdEVsZW1lbnQoKS4gSWYgdGhpcyBvY2N1cnMgb24gaW5pdCB3aGVuIHRoZVxuICAgIC8vIGVkaXRvciBpcyBhbHJlYWR5IGZvY3VzZWQsIHRoZW4gdGhpcyBjYW4gY2F1c2UgdGhlIGVkaXRvciB0b1xuICAgIC8vIGxvc2UgZm9jdXMuXG4gICAgaWYgKHByZXZTZWxlY3Rpb24gIT09IG51bGwgJiYgaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET01Ob2RlLCBmb2N1c0RPTU5vZGUpKSB7XG4gICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYW5jaG9yID0gbmV4dFNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gbmV4dFNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yLmtleTtcbiAgY29uc3QgZm9jdXNLZXkgPSBmb2N1cy5rZXk7XG4gIGNvbnN0IGFuY2hvckRPTSA9IGdldEVsZW1lbnRCeUtleU9yVGhyb3coZWRpdG9yLCBhbmNob3JLZXkpO1xuICBjb25zdCBmb2N1c0RPTSA9IGdldEVsZW1lbnRCeUtleU9yVGhyb3coZWRpdG9yLCBmb2N1c0tleSk7XG4gIGNvbnN0IG5leHRBbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBuZXh0Rm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gIGNvbnN0IG5leHRGb3JtYXQgPSBuZXh0U2VsZWN0aW9uLmZvcm1hdDtcbiAgY29uc3QgbmV4dFN0eWxlID0gbmV4dFNlbGVjdGlvbi5zdHlsZTtcbiAgY29uc3QgaXNDb2xsYXBzZWQgPSBuZXh0U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCk7XG4gIGxldCBuZXh0QW5jaG9yTm9kZSA9IGFuY2hvckRPTTtcbiAgbGV0IG5leHRGb2N1c05vZGUgPSBmb2N1c0RPTTtcbiAgbGV0IGFuY2hvckZvcm1hdE9yU3R5bGVDaGFuZ2VkID0gZmFsc2U7XG5cbiAgaWYgKGFuY2hvci50eXBlID09PSAndGV4dCcpIHtcbiAgICBuZXh0QW5jaG9yTm9kZSA9IGdldERPTVRleHROb2RlKGFuY2hvckRPTSk7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgYW5jaG9yRm9ybWF0T3JTdHlsZUNoYW5nZWQgPSBhbmNob3JOb2RlLmdldEZvcm1hdCgpICE9PSBuZXh0Rm9ybWF0IHx8IGFuY2hvck5vZGUuZ2V0U3R5bGUoKSAhPT0gbmV4dFN0eWxlO1xuICB9IGVsc2UgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIHByZXZTZWxlY3Rpb24uYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGFuY2hvckZvcm1hdE9yU3R5bGVDaGFuZ2VkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChmb2N1cy50eXBlID09PSAndGV4dCcpIHtcbiAgICBuZXh0Rm9jdXNOb2RlID0gZ2V0RE9NVGV4dE5vZGUoZm9jdXNET00pO1xuICB9IC8vIElmIHdlIGNhbid0IGdldCBhbiB1bmRlcmx5aW5nIHRleHQgbm9kZSBmb3Igc2VsZWN0aW9uLCB0aGVuXG4gIC8vIHdlIHNob3VsZCBhdm9pZCBzZXR0aW5nIHNlbGVjdGlvbiB0byBzb21ldGhpbmcgaW5jb3JyZWN0LlxuXG5cbiAgaWYgKG5leHRBbmNob3JOb2RlID09PSBudWxsIHx8IG5leHRGb2N1c05vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNDb2xsYXBzZWQgJiYgKHByZXZTZWxlY3Rpb24gPT09IG51bGwgfHwgYW5jaG9yRm9ybWF0T3JTdHlsZUNoYW5nZWQgfHwgJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgKHByZXZTZWxlY3Rpb24uZm9ybWF0ICE9PSBuZXh0Rm9ybWF0IHx8IHByZXZTZWxlY3Rpb24uc3R5bGUgIT09IG5leHRTdHlsZSkpKSB7XG4gICAgbWFya0NvbGxhcHNlZFNlbGVjdGlvbkZvcm1hdChuZXh0Rm9ybWF0LCBuZXh0U3R5bGUsIG5leHRBbmNob3JPZmZzZXQsIGFuY2hvcktleSwgcGVyZm9ybWFuY2Uubm93KCkpO1xuICB9IC8vIERpZmYgYWdhaW5zdCB0aGUgbmF0aXZlIERPTSBzZWxlY3Rpb24gdG8gZW5zdXJlIHdlIGRvbid0IGRvXG4gIC8vIGFuIHVubmVjZXNzYXJ5IHNlbGVjdGlvbiB1cGRhdGUuIFdlIGFsc28gc2tpcCB0aGlzIGNoZWNrIGlmXG4gIC8vIHdlJ3JlIG1vdmluZyBzZWxlY3Rpb24gdG8gd2l0aGluIGFuIGVsZW1lbnQsIGFzIHRoaXMgY2FuXG4gIC8vIHNvbWV0aW1lcyBiZSBwcm9ibGVtYXRpYyBhcm91bmQgc2Nyb2xsaW5nLlxuXG5cbiAgaWYgKGFuY2hvck9mZnNldCA9PT0gbmV4dEFuY2hvck9mZnNldCAmJiBmb2N1c09mZnNldCA9PT0gbmV4dEZvY3VzT2Zmc2V0ICYmIGFuY2hvckRPTU5vZGUgPT09IG5leHRBbmNob3JOb2RlICYmIGZvY3VzRE9NTm9kZSA9PT0gbmV4dEZvY3VzTm9kZSAmJiAvLyBCYWRseSBpbnRlcnByZXRlZCByYW5nZSBzZWxlY3Rpb24gd2hlbiBjb2xsYXBzZWQgLSAjMTQ4MlxuICAhKGRvbVNlbGVjdGlvbi50eXBlID09PSAnUmFuZ2UnICYmIGlzQ29sbGFwc2VkKSkge1xuICAgIC8vIElmIHRoZSByb290IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBmb2N1cywgZW5zdXJlIGl0IGhhcyBmb2N1c1xuICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBudWxsIHx8ICFyb290RWxlbWVudC5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgcm9vdEVsZW1lbnQuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYW5jaG9yLnR5cGUgIT09ICdlbGVtZW50Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSAvLyBBcHBseSB0aGUgdXBkYXRlZCBzZWxlY3Rpb24gdG8gdGhlIERPTS4gTm90ZTogdGhpcyB3aWxsIHRyaWdnZXJcbiAgLy8gYSBcInNlbGVjdGlvbmNoYW5nZVwiIGV2ZW50LCBhbHRob3VnaCBpdCB3aWxsIGJlIGFzeW5jaHJvbm91cy5cblxuXG4gIHRyeSB7XG4gICAgZG9tU2VsZWN0aW9uLnNldEJhc2VBbmRFeHRlbnQobmV4dEFuY2hvck5vZGUsIG5leHRBbmNob3JPZmZzZXQsIG5leHRGb2N1c05vZGUsIG5leHRGb2N1c09mZnNldCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVycm9yLCBjb250aW51ZS4gVGhpcyBjYW4gc29tZXRpbWVzXG4gICAgLy8gb2NjdXIgd2l0aCBGRiBhbmQgdGhlcmUncyBubyBnb29kIHJlYXNvbiBhcyB0byB3aHkgaXRcbiAgICAvLyBzaG91bGQgaGFwcGVuLlxuICB9XG5cbiAgaWYgKCF0YWdzLmhhcygnc2tpcC1zY3JvbGwtaW50by12aWV3JykgJiYgbmV4dFNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIHJvb3RFbGVtZW50ICE9PSBudWxsICYmIHJvb3RFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uVGFyZ2V0ID0gbmV4dFNlbGVjdGlvbiBpbnN0YW5jZW9mIFJhbmdlU2VsZWN0aW9uICYmIG5leHRTZWxlY3Rpb24uYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyA/IG5leHRBbmNob3JOb2RlLmNoaWxkTm9kZXNbbmV4dEFuY2hvck9mZnNldF0gfHwgbnVsbCA6IGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCA/IGRvbVNlbGVjdGlvbi5nZXRSYW5nZUF0KDApIDogbnVsbDtcblxuICAgIGlmIChzZWxlY3Rpb25UYXJnZXQgIT09IG51bGwpIHtcbiAgICAgIGxldCBzZWxlY3Rpb25SZWN0O1xuXG4gICAgICBpZiAoc2VsZWN0aW9uVGFyZ2V0IGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGUoc2VsZWN0aW9uVGFyZ2V0KTtcbiAgICAgICAgc2VsZWN0aW9uUmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uUmVjdCA9IHNlbGVjdGlvblRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH1cblxuICAgICAgc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChlZGl0b3IsIHNlbGVjdGlvblJlY3QsIHJvb3RFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBtYXJrU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSgpO1xufVxuZnVuY3Rpb24gJGluc2VydE5vZGVzKG5vZGVzLCBzZWxlY3RTdGFydCkge1xuICBsZXQgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpIHx8ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuXG4gIGlmIChzZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICBzZWxlY3Rpb24gPSAkZ2V0Um9vdCgpLnNlbGVjdEVuZCgpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbi5pbnNlcnROb2Rlcyhub2Rlcywgc2VsZWN0U3RhcnQpO1xufVxuZnVuY3Rpb24gJGdldFRleHRDb250ZW50KCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKTtcbn1cbmZ1bmN0aW9uIERFUFJFQ0FURURfJGNvbXB1dGVHcmlkTWFwKGdyaWQsIGNlbGxBLCBjZWxsQikge1xuICBjb25zdCB0YWJsZU1hcCA9IFtdO1xuICBsZXQgY2VsbEFWYWx1ZSA9IG51bGw7XG4gIGxldCBjZWxsQlZhbHVlID0gbnVsbDtcblxuICBmdW5jdGlvbiB3cml0ZShzdGFydFJvdywgc3RhcnRDb2x1bW4sIGNlbGwpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHtcbiAgICAgIGNlbGwsXG4gICAgICBzdGFydENvbHVtbixcbiAgICAgIHN0YXJ0Um93XG4gICAgfTtcbiAgICBjb25zdCByb3dTcGFuID0gY2VsbC5fX3Jvd1NwYW47XG4gICAgY29uc3QgY29sU3BhbiA9IGNlbGwuX19jb2xTcGFuO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dTcGFuOyBpKyspIHtcbiAgICAgIGlmICh0YWJsZU1hcFtzdGFydFJvdyArIGldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGFibGVNYXBbc3RhcnRSb3cgKyBpXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbFNwYW47IGorKykge1xuICAgICAgICB0YWJsZU1hcFtzdGFydFJvdyArIGldW3N0YXJ0Q29sdW1uICsgal0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2VsbEEuaXMoY2VsbCkpIHtcbiAgICAgIGNlbGxBVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2VsbEIuaXMoY2VsbCkpIHtcbiAgICAgIGNlbGxCVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0VtcHR5KHJvdywgY29sdW1uKSB7XG4gICAgcmV0dXJuIHRhYmxlTWFwW3Jvd10gPT09IHVuZGVmaW5lZCB8fCB0YWJsZU1hcFtyb3ddW2NvbHVtbl0gPT09IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGdyaWRDaGlsZHJlbiA9IGdyaWQuZ2V0Q2hpbGRyZW4oKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGdyaWRDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHJvdyA9IGdyaWRDaGlsZHJlbltpXTtcblxuICAgIGlmICghREVQUkVDQVRFRF8kaXNHcmlkUm93Tm9kZShyb3cpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgR3JpZE5vZGUgY2hpbGRyZW4gdG8gYmUgR3JpZFJvd05vZGVgKTtcbiAgICB9XG5cbiAgICBjb25zdCByb3dDaGlsZHJlbiA9IHJvdy5nZXRDaGlsZHJlbigpO1xuICAgIGxldCBqID0gMDtcblxuICAgIGZvciAoY29uc3QgY2VsbCBvZiByb3dDaGlsZHJlbikge1xuICAgICAgaWYgKCFERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZShjZWxsKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgR3JpZFJvd05vZGUgY2hpbGRyZW4gdG8gYmUgR3JpZENlbGxOb2RlYCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICghaXNFbXB0eShpLCBqKSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG5cbiAgICAgIHdyaXRlKGksIGosIGNlbGwpO1xuICAgICAgaiArPSBjZWxsLl9fY29sU3BhbjtcbiAgICB9XG4gIH1cblxuICBpZiAoIShjZWxsQVZhbHVlICE9PSBudWxsKSkge1xuICAgIHRocm93IEVycm9yKGBBbmNob3Igbm90IGZvdW5kIGluIEdyaWRgKTtcbiAgfVxuXG4gIGlmICghKGNlbGxCVmFsdWUgIT09IG51bGwpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEZvY3VzIG5vdCBmb3VuZCBpbiBHcmlkYCk7XG4gIH1cblxuICByZXR1cm4gW3RhYmxlTWFwLCBjZWxsQVZhbHVlLCBjZWxsQlZhbHVlXTtcbn1cbmZ1bmN0aW9uIERFUFJFQ0FURURfJGdldE5vZGVUcmlwbGV0KHNvdXJjZSkge1xuICBsZXQgY2VsbDtcblxuICBpZiAoc291cmNlIGluc3RhbmNlb2YgREVQUkVDQVRFRF9HcmlkQ2VsbE5vZGUpIHtcbiAgICBjZWxsID0gc291cmNlO1xuICB9IGVsc2UgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIExleGljYWxOb2RlKSB7XG4gICAgY29uc3QgY2VsbF8gPSAkZmluZE1hdGNoaW5nUGFyZW50KHNvdXJjZSwgREVQUkVDQVRFRF8kaXNHcmlkQ2VsbE5vZGUpO1xuXG4gICAgaWYgKCFERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZShjZWxsXykpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0byBmaW5kIGEgcGFyZW50IEdyaWRDZWxsTm9kZWApO1xuICAgIH1cblxuICAgIGNlbGwgPSBjZWxsXztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjZWxsXyA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc291cmNlLmdldE5vZGUoKSwgREVQUkVDQVRFRF8kaXNHcmlkQ2VsbE5vZGUpO1xuXG4gICAgaWYgKCFERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZShjZWxsXykpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0byBmaW5kIGEgcGFyZW50IEdyaWRDZWxsTm9kZWApO1xuICAgIH1cblxuICAgIGNlbGwgPSBjZWxsXztcbiAgfVxuXG4gIGNvbnN0IHJvdyA9IGNlbGwuZ2V0UGFyZW50KCk7XG5cbiAgaWYgKCFERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlKHJvdykpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgR3JpZENlbGxOb2RlIHRvIGhhdmUgYSBwYXJlbnQgR3JpZFJvd05vZGVgKTtcbiAgfVxuXG4gIGNvbnN0IGdyaWQgPSByb3cuZ2V0UGFyZW50KCk7XG5cbiAgaWYgKCFERVBSRUNBVEVEXyRpc0dyaWROb2RlKGdyaWQpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIEdyaWRSb3dOb2RlIHRvIGhhdmUgYSBwYXJlbnQgR3JpZE5vZGVgKTtcbiAgfVxuXG4gIHJldHVybiBbY2VsbCwgcm93LCBncmlkXTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xubGV0IGFjdGl2ZUVkaXRvclN0YXRlID0gbnVsbDtcbmxldCBhY3RpdmVFZGl0b3IgPSBudWxsO1xubGV0IGlzUmVhZE9ubHlNb2RlID0gZmFsc2U7XG5sZXQgaXNBdHRlbXB0aW5nVG9SZWNvdmVyRnJvbVJlY29uY2lsZXJFcnJvciA9IGZhbHNlO1xubGV0IGluZmluaXRlVHJhbnNmb3JtQ291bnQgPSAwO1xuY29uc3Qgb2JzZXJ2ZXJPcHRpb25zID0ge1xuICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICBjaGlsZExpc3Q6IHRydWUsXG4gIHN1YnRyZWU6IHRydWVcbn07XG5mdW5jdGlvbiBpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSgpIHtcbiAgcmV0dXJuIGlzUmVhZE9ubHlNb2RlIHx8IGFjdGl2ZUVkaXRvclN0YXRlICE9PSBudWxsICYmIGFjdGl2ZUVkaXRvclN0YXRlLl9yZWFkT25seTtcbn1cbmZ1bmN0aW9uIGVycm9yT25SZWFkT25seSgpIHtcbiAgaWYgKGlzUmVhZE9ubHlNb2RlKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYENhbm5vdCB1c2UgbWV0aG9kIGluIHJlYWQtb25seSBtb2RlLmApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JPbkluZmluaXRlVHJhbnNmb3JtcygpIHtcbiAgaWYgKGluZmluaXRlVHJhbnNmb3JtQ291bnQgPiA5OSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBPbmUgb3IgbW9yZSB0cmFuc2Zvcm1zIGFyZSBlbmRsZXNzbHkgdHJpZ2dlcmluZyBhZGRpdGlvbmFsIHRyYW5zZm9ybXMuIE1heSBoYXZlIGVuY291bnRlcmVkIGluZmluaXRlIHJlY3Vyc2lvbiBjYXVzZWQgYnkgdHJhbnNmb3JtcyB0aGF0IGhhdmUgdGhlaXIgcHJlY29uZGl0aW9ucyB0b28gbG9zZSBhbmQvb3IgY29uZmxpY3Qgd2l0aCBlYWNoIG90aGVyLmApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0QWN0aXZlRWRpdG9yU3RhdGUoKSB7XG4gIGlmIChhY3RpdmVFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZmluZCBhbiBhY3RpdmUgZWRpdG9yIHN0YXRlLiBTdGF0ZSBoZWxwZXJzIG9yIG5vZGUgbWV0aG9kcyBjYW4gb25seSBiZSB1c2VkIHN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZSBjYWxsYmFjayBvZiBlZGl0b3IudXBkYXRlKCkgb3IgZWRpdG9yU3RhdGUucmVhZCgpLmApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhY3RpdmVFZGl0b3JTdGF0ZTtcbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZUVkaXRvcigpIHtcbiAgaWYgKGFjdGl2ZUVkaXRvciA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZmluZCBhbiBhY3RpdmUgZWRpdG9yLiBUaGlzIG1ldGhvZCBjYW4gb25seSBiZSB1c2VkIHN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZSBjYWxsYmFjayBvZiBlZGl0b3IudXBkYXRlKCkuYCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFjdGl2ZUVkaXRvcjtcbn1cbmZ1bmN0aW9uIGludGVybmFsR2V0QWN0aXZlRWRpdG9yKCkge1xuICByZXR1cm4gYWN0aXZlRWRpdG9yO1xufVxuZnVuY3Rpb24gJGFwcGx5VHJhbnNmb3JtcyhlZGl0b3IsIG5vZGUsIHRyYW5zZm9ybXNDYWNoZSkge1xuICBjb25zdCB0eXBlID0gbm9kZS5fX3R5cGU7XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gZ2V0UmVnaXN0ZXJlZE5vZGVPclRocm93KGVkaXRvciwgdHlwZSk7XG4gIGxldCB0cmFuc2Zvcm1zQXJyID0gdHJhbnNmb3Jtc0NhY2hlLmdldCh0eXBlKTtcblxuICBpZiAodHJhbnNmb3Jtc0FyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhbnNmb3Jtc0FyciA9IEFycmF5LmZyb20ocmVnaXN0ZXJlZE5vZGUudHJhbnNmb3Jtcyk7XG4gICAgdHJhbnNmb3Jtc0NhY2hlLnNldCh0eXBlLCB0cmFuc2Zvcm1zQXJyKTtcbiAgfVxuXG4gIGNvbnN0IHRyYW5zZm9ybXNBcnJMZW5ndGggPSB0cmFuc2Zvcm1zQXJyLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zZm9ybXNBcnJMZW5ndGg7IGkrKykge1xuICAgIHRyYW5zZm9ybXNBcnJbaV0obm9kZSk7XG5cbiAgICBpZiAoIW5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gJGlzTm9kZVZhbGlkRm9yVHJhbnNmb3JtKG5vZGUsIGNvbXBvc2l0aW9uS2V5KSB7XG4gIHJldHVybiBub2RlICE9PSB1bmRlZmluZWQgJiYgLy8gV2UgZG9uJ3Qgd2FudCB0byB0cmFuc2Zvcm0gbm9kZXMgYmVpbmcgY29tcG9zZWRcbiAgbm9kZS5fX2tleSAhPT0gY29tcG9zaXRpb25LZXkgJiYgbm9kZS5pc0F0dGFjaGVkKCk7XG59XG5cbmZ1bmN0aW9uICRub3JtYWxpemVBbGxEaXJ0eVRleHROb2RlcyhlZGl0b3JTdGF0ZSwgZWRpdG9yKSB7XG4gIGNvbnN0IGRpcnR5TGVhdmVzID0gZWRpdG9yLl9kaXJ0eUxlYXZlcztcbiAgY29uc3Qgbm9kZU1hcCA9IGVkaXRvclN0YXRlLl9ub2RlTWFwO1xuXG4gIGZvciAoY29uc3Qgbm9kZUtleSBvZiBkaXJ0eUxlYXZlcykge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcblxuICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSAmJiBub2RlLmlzQXR0YWNoZWQoKSAmJiBub2RlLmlzU2ltcGxlVGV4dCgpICYmICFub2RlLmlzVW5tZXJnZWFibGUoKSkge1xuICAgICAgJG5vcm1hbGl6ZVRleHROb2RlKG5vZGUpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBUcmFuc2Zvcm0gaGV1cmlzdGljOlxuICogMS4gV2UgdHJhbnNmb3JtIGxlYXZlcyBmaXJzdC4gSWYgdHJhbnNmb3JtcyBnZW5lcmF0ZSBhZGRpdGlvbmFsIGRpcnR5IG5vZGVzIHdlIHJlcGVhdCBzdGVwIDEuXG4gKiBUaGUgcmVhc29uaW5nIGJlaGluZCB0aGlzIGlzIHRoYXQgbWFya2luZyBhIGxlYWYgYXMgZGlydHkgbWFya3MgYWxsIGl0cyBwYXJlbnQgZWxlbWVudHMgYXMgZGlydHkgdG9vLlxuICogMi4gV2UgdHJhbnNmb3JtIGVsZW1lbnRzLiBJZiBlbGVtZW50IHRyYW5zZm9ybXMgZ2VuZXJhdGUgYWRkaXRpb25hbCBkaXJ0eSBub2RlcyB3ZSByZXBlYXQgc3RlcCAxLlxuICogSWYgZWxlbWVudCB0cmFuc2Zvcm1zIG9ubHkgZ2VuZXJhdGUgYWRkaXRpb25hbCBkaXJ0eSBlbGVtZW50cyB3ZSBvbmx5IHJlcGVhdCBzdGVwIDIuXG4gKlxuICogTm90ZSB0aGF0IHRvIGtlZXAgdHJhY2sgb2YgbmV3bHkgZGlydHkgbm9kZXMgYW5kIHN1YnRyZWVzIHdlIGxldmVyYWdlIHRoZSBlZGl0b3IuX2RpcnR5Tm9kZXMgYW5kXG4gKiBlZGl0b3IuX3N1YnRyZWVzIHdoaWNoIHdlIHJlc2V0IGluIGV2ZXJ5IGxvb3AuXG4gKi9cblxuXG5mdW5jdGlvbiAkYXBwbHlBbGxUcmFuc2Zvcm1zKGVkaXRvclN0YXRlLCBlZGl0b3IpIHtcbiAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG4gIGNvbnN0IHRyYW5zZm9ybXNDYWNoZSA9IG5ldyBNYXAoKTtcbiAgbGV0IHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlcyA9IGRpcnR5TGVhdmVzO1xuICBsZXQgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzTGVuZ3RoID0gdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzLnNpemU7XG4gIGxldCB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50cyA9IGRpcnR5RWxlbWVudHM7XG4gIGxldCB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50c0xlbmd0aCA9IHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzLnNpemU7XG5cbiAgd2hpbGUgKHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlc0xlbmd0aCA+IDAgfHwgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHNMZW5ndGggPiAwKSB7XG4gICAgaWYgKHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlc0xlbmd0aCA+IDApIHtcbiAgICAgIC8vIFdlIGxldmVyYWdlIGVkaXRvci5fZGlydHlMZWF2ZXMgdG8gdHJhY2sgdGhlIG5ldyBkaXJ0eSBsZWF2ZXMgYWZ0ZXIgdGhlIHRyYW5zZm9ybXNcbiAgICAgIGVkaXRvci5fZGlydHlMZWF2ZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgIGZvciAoY29uc3Qgbm9kZUtleSBvZiB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXMpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KG5vZGVLZXkpO1xuXG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSAmJiBub2RlLmlzQXR0YWNoZWQoKSAmJiBub2RlLmlzU2ltcGxlVGV4dCgpICYmICFub2RlLmlzVW5tZXJnZWFibGUoKSkge1xuICAgICAgICAgICRub3JtYWxpemVUZXh0Tm9kZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgJGlzTm9kZVZhbGlkRm9yVHJhbnNmb3JtKG5vZGUsIGNvbXBvc2l0aW9uS2V5KSkge1xuICAgICAgICAgICRhcHBseVRyYW5zZm9ybXMoZWRpdG9yLCBub2RlLCB0cmFuc2Zvcm1zQ2FjaGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlydHlMZWF2ZXMuYWRkKG5vZGVLZXkpO1xuICAgICAgfVxuXG4gICAgICB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICAgICAgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzTGVuZ3RoID0gdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzLnNpemU7IC8vIFdlIHdhbnQgdG8gcHJpb3JpdGl6ZSBub2RlIHRyYW5zZm9ybXMgb3ZlciBlbGVtZW50IHRyYW5zZm9ybXNcblxuICAgICAgaWYgKHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlc0xlbmd0aCA+IDApIHtcbiAgICAgICAgaW5maW5pdGVUcmFuc2Zvcm1Db3VudCsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IC8vIEFsbCBkaXJ0eSBsZWF2ZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gTGV0J3MgZG8gZWxlbWVudHMhXG4gICAgLy8gV2UgaGF2ZSBwcmV2aW91c2x5IHByb2Nlc3NlZCBkaXJ0eSBsZWF2ZXMsIHNvIGxldCdzIHJlc3RhcnQgdGhlIGVkaXRvciBsZWF2ZXMgU2V0IHRvIHRyYWNrXG4gICAgLy8gbmV3IG9uZXMgY2F1c2VkIGJ5IGVsZW1lbnQgdHJhbnNmb3Jtc1xuXG5cbiAgICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICAgIGVkaXRvci5fZGlydHlFbGVtZW50cyA9IG5ldyBNYXAoKTtcblxuICAgIGZvciAoY29uc3QgY3VycmVudFVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnQgb2YgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHMpIHtcbiAgICAgIGNvbnN0IG5vZGVLZXkgPSBjdXJyZW50VW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudFswXTtcbiAgICAgIGNvbnN0IGludGVudGlvbmFsbHlNYXJrZWRBc0RpcnR5ID0gY3VycmVudFVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRbMV07XG5cbiAgICAgIGlmIChub2RlS2V5ICE9PSAncm9vdCcgJiYgIWludGVudGlvbmFsbHlNYXJrZWRBc0RpcnR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQobm9kZUtleSk7XG5cbiAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgJGlzTm9kZVZhbGlkRm9yVHJhbnNmb3JtKG5vZGUsIGNvbXBvc2l0aW9uS2V5KSkge1xuICAgICAgICAkYXBwbHlUcmFuc2Zvcm1zKGVkaXRvciwgbm9kZSwgdHJhbnNmb3Jtc0NhY2hlKTtcbiAgICAgIH1cblxuICAgICAgZGlydHlFbGVtZW50cy5zZXQobm9kZUtleSwgaW50ZW50aW9uYWxseU1hcmtlZEFzRGlydHkpO1xuICAgIH1cblxuICAgIHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gICAgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzTGVuZ3RoID0gdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzLnNpemU7XG4gICAgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHMgPSBlZGl0b3IuX2RpcnR5RWxlbWVudHM7XG4gICAgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHNMZW5ndGggPSB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50cy5zaXplO1xuICAgIGluZmluaXRlVHJhbnNmb3JtQ291bnQrKztcbiAgfVxuXG4gIGVkaXRvci5fZGlydHlMZWF2ZXMgPSBkaXJ0eUxlYXZlcztcbiAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzID0gZGlydHlFbGVtZW50cztcbn1cblxuZnVuY3Rpb24gJHBhcnNlU2VyaWFsaXplZE5vZGUoc2VyaWFsaXplZE5vZGUpIHtcbiAgY29uc3QgaW50ZXJuYWxTZXJpYWxpemVkTm9kZSA9IHNlcmlhbGl6ZWROb2RlO1xuICByZXR1cm4gJHBhcnNlU2VyaWFsaXplZE5vZGVJbXBsKGludGVybmFsU2VyaWFsaXplZE5vZGUsIGdldEFjdGl2ZUVkaXRvcigpLl9ub2Rlcyk7XG59XG5cbmZ1bmN0aW9uICRwYXJzZVNlcmlhbGl6ZWROb2RlSW1wbChzZXJpYWxpemVkTm9kZSwgcmVnaXN0ZXJlZE5vZGVzKSB7XG4gIGNvbnN0IHR5cGUgPSBzZXJpYWxpemVkTm9kZS50eXBlO1xuICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IHJlZ2lzdGVyZWROb2Rlcy5nZXQodHlwZSk7XG5cbiAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgcGFyc2VFZGl0b3JTdGF0ZTogdHlwZSBcIiR7dHlwZX1cIiArIG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5vZGVDbGFzcyA9IHJlZ2lzdGVyZWROb2RlLmtsYXNzO1xuXG4gIGlmIChzZXJpYWxpemVkTm9kZS50eXBlICE9PSBub2RlQ2xhc3MuZ2V0VHlwZSgpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuaW1wb3J0SlNPTigpLmApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSBub2RlQ2xhc3MuaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSk7XG4gIGNvbnN0IGNoaWxkcmVuID0gc2VyaWFsaXplZE5vZGUuY2hpbGRyZW47XG5cbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZEpTT05DaGlsZE5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IGNoaWxkTm9kZSA9ICRwYXJzZVNlcmlhbGl6ZWROb2RlSW1wbChzZXJpYWxpemVkSlNPTkNoaWxkTm9kZSwgcmVnaXN0ZXJlZE5vZGVzKTtcbiAgICAgIG5vZGUuYXBwZW5kKGNoaWxkTm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRWRpdG9yU3RhdGUoc2VyaWFsaXplZEVkaXRvclN0YXRlLCBlZGl0b3IsIHVwZGF0ZUZuKSB7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gY3JlYXRlRW1wdHlFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlID0gYWN0aXZlRWRpdG9yU3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUmVhZE9ubHlNb2RlID0gaXNSZWFkT25seU1vZGU7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlRWRpdG9yID0gYWN0aXZlRWRpdG9yO1xuICBjb25zdCBwcmV2aW91c0RpcnR5RWxlbWVudHMgPSBlZGl0b3IuX2RpcnR5RWxlbWVudHM7XG4gIGNvbnN0IHByZXZpb3VzRGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICBjb25zdCBwcmV2aW91c0Nsb25lTm90TmVlZGVkID0gZWRpdG9yLl9jbG9uZU5vdE5lZWRlZDtcbiAgY29uc3QgcHJldmlvdXNEaXJ0eVR5cGUgPSBlZGl0b3IuX2RpcnR5VHlwZTtcbiAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICBlZGl0b3IuX2Nsb25lTm90TmVlZGVkID0gbmV3IFNldCgpO1xuICBlZGl0b3IuX2RpcnR5VHlwZSA9IDA7XG4gIGFjdGl2ZUVkaXRvclN0YXRlID0gZWRpdG9yU3RhdGU7XG4gIGlzUmVhZE9ubHlNb2RlID0gZmFsc2U7XG4gIGFjdGl2ZUVkaXRvciA9IGVkaXRvcjtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlZ2lzdGVyZWROb2RlcyA9IGVkaXRvci5fbm9kZXM7XG4gICAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBzZXJpYWxpemVkRWRpdG9yU3RhdGUucm9vdDtcbiAgICAkcGFyc2VTZXJpYWxpemVkTm9kZUltcGwoc2VyaWFsaXplZE5vZGUsIHJlZ2lzdGVyZWROb2Rlcyk7XG5cbiAgICBpZiAodXBkYXRlRm4pIHtcbiAgICAgIHVwZGF0ZUZuKCk7XG4gICAgfSAvLyBNYWtlIHRoZSBlZGl0b3JTdGF0ZSBpbW11dGFibGVcblxuXG4gICAgZWRpdG9yU3RhdGUuX3JlYWRPbmx5ID0gdHJ1ZTtcblxuICAgIHtcbiAgICAgIGhhbmRsZURFVk9ubHlQZW5kaW5nVXBkYXRlR3VhcmFudGVlcyhlZGl0b3JTdGF0ZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBlZGl0b3IuX29uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBlZGl0b3IuX2RpcnR5RWxlbWVudHMgPSBwcmV2aW91c0RpcnR5RWxlbWVudHM7XG4gICAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IHByZXZpb3VzRGlydHlMZWF2ZXM7XG4gICAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZCA9IHByZXZpb3VzQ2xvbmVOb3ROZWVkZWQ7XG4gICAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBwcmV2aW91c0RpcnR5VHlwZTtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgaXNSZWFkT25seU1vZGUgPSBwcmV2aW91c1JlYWRPbmx5TW9kZTtcbiAgICBhY3RpdmVFZGl0b3IgPSBwcmV2aW91c0FjdGl2ZUVkaXRvcjtcbiAgfVxuXG4gIHJldHVybiBlZGl0b3JTdGF0ZTtcbn0gLy8gVGhpcyB0ZWNobmljYWxseSBpc24ndCBhbiB1cGRhdGUgYnV0IGdpdmVuIHdlIG5lZWRcbi8vIGV4cG9zdXJlIHRvIHRoZSBtb2R1bGUncyBhY3RpdmUgYmluZGluZ3MsIHdlIGhhdmUgdGhpc1xuLy8gZnVuY3Rpb24gaGVyZVxuXG5mdW5jdGlvbiByZWFkRWRpdG9yU3RhdGUoZWRpdG9yU3RhdGUsIGNhbGxiYWNrRm4pIHtcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZSA9IGFjdGl2ZUVkaXRvclN0YXRlO1xuICBjb25zdCBwcmV2aW91c1JlYWRPbmx5TW9kZSA9IGlzUmVhZE9ubHlNb2RlO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvciA9IGFjdGl2ZUVkaXRvcjtcbiAgYWN0aXZlRWRpdG9yU3RhdGUgPSBlZGl0b3JTdGF0ZTtcbiAgaXNSZWFkT25seU1vZGUgPSB0cnVlO1xuICBhY3RpdmVFZGl0b3IgPSBudWxsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrRm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgaXNSZWFkT25seU1vZGUgPSBwcmV2aW91c1JlYWRPbmx5TW9kZTtcbiAgICBhY3RpdmVFZGl0b3IgPSBwcmV2aW91c0FjdGl2ZUVkaXRvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVERVZPbmx5UGVuZGluZ1VwZGF0ZUd1YXJhbnRlZXMocGVuZGluZ0VkaXRvclN0YXRlKSB7XG4gIC8vIEdpdmVuIHdlIGNhbid0IE9iamVjdC5mcmVlemUgdGhlIG5vZGVNYXAgYXMgaXQncyBhIE1hcCxcbiAgLy8gd2UgaW5zdGVhZCByZXBsYWNlIGl0cyBzZXQsIGNsZWFyIGFuZCBkZWxldGUgbWV0aG9kcy5cbiAgY29uc3Qgbm9kZU1hcCA9IHBlbmRpbmdFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcblxuICBub2RlTWFwLnNldCA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIHNldCgpIG9uIGEgZnJvemVuIExleGljYWwgbm9kZSBtYXAnKTtcbiAgfTtcblxuICBub2RlTWFwLmNsZWFyID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgY2xlYXIoKSBvbiBhIGZyb3plbiBMZXhpY2FsIG5vZGUgbWFwJyk7XG4gIH07XG5cbiAgbm9kZU1hcC5kZWxldGUgPSAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCBkZWxldGUoKSBvbiBhIGZyb3plbiBMZXhpY2FsIG5vZGUgbWFwJyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBlbmRpbmdVcGRhdGVzKGVkaXRvciwgcmVjb3ZlcnlFZGl0b3JTdGF0ZSkge1xuICBjb25zdCBwZW5kaW5nRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuX3Jvb3RFbGVtZW50O1xuICBjb25zdCBzaG91bGRTa2lwRE9NID0gZWRpdG9yLl9oZWFkbGVzcyB8fCByb290RWxlbWVudCA9PT0gbnVsbDtcblxuICBpZiAocGVuZGluZ0VkaXRvclN0YXRlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vID09PT09PVxuICAvLyBSZWNvbmNpbGlhdGlvbiBoYXMgc3RhcnRlZC5cbiAgLy8gPT09PT09XG5cblxuICBjb25zdCBjdXJyZW50RWRpdG9yU3RhdGUgPSBlZGl0b3IuX2VkaXRvclN0YXRlO1xuICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gY3VycmVudEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IHBlbmRpbmdTZWxlY3Rpb24gPSBwZW5kaW5nRWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgY29uc3QgbmVlZHNVcGRhdGUgPSBlZGl0b3IuX2RpcnR5VHlwZSAhPT0gTk9fRElSVFlfTk9ERVM7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGUgPSBhY3RpdmVFZGl0b3JTdGF0ZTtcbiAgY29uc3QgcHJldmlvdXNSZWFkT25seU1vZGUgPSBpc1JlYWRPbmx5TW9kZTtcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3IgPSBhY3RpdmVFZGl0b3I7XG4gIGNvbnN0IHByZXZpb3VzbHlVcGRhdGluZyA9IGVkaXRvci5fdXBkYXRpbmc7XG4gIGNvbnN0IG9ic2VydmVyID0gZWRpdG9yLl9vYnNlcnZlcjtcbiAgbGV0IG11dGF0ZWROb2RlcyA9IG51bGw7XG4gIGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlID0gbnVsbDtcbiAgZWRpdG9yLl9lZGl0b3JTdGF0ZSA9IHBlbmRpbmdFZGl0b3JTdGF0ZTtcblxuICBpZiAoIXNob3VsZFNraXBET00gJiYgbmVlZHNVcGRhdGUgJiYgb2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICBhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gICAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gICAgaXNSZWFkT25seU1vZGUgPSBmYWxzZTsgLy8gV2UgZG9uJ3Qgd2FudCB1cGRhdGVzIHRvIHN5bmMgYmxvY2sgdGhlIHJlY29uY2lsaWF0aW9uLlxuXG4gICAgZWRpdG9yLl91cGRhdGluZyA9IHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGlydHlUeXBlID0gZWRpdG9yLl9kaXJ0eVR5cGU7XG4gICAgICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICAgICAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgbXV0YXRlZE5vZGVzID0gcmVjb25jaWxlUm9vdChjdXJyZW50RWRpdG9yU3RhdGUsIHBlbmRpbmdFZGl0b3JTdGF0ZSwgZWRpdG9yLCBkaXJ0eVR5cGUsIGRpcnR5RWxlbWVudHMsIGRpcnR5TGVhdmVzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gUmVwb3J0IGVycm9yc1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgZWRpdG9yLl9vbkVycm9yKGVycm9yKTtcbiAgICAgIH0gLy8gUmVzZXQgZWRpdG9yIGFuZCByZXN0b3JlIGluY29taW5nIGVkaXRvciBzdGF0ZSB0byB0aGUgRE9NXG5cblxuICAgICAgaWYgKCFpc0F0dGVtcHRpbmdUb1JlY292ZXJGcm9tUmVjb25jaWxlckVycm9yKSB7XG4gICAgICAgIHJlc2V0RWRpdG9yKGVkaXRvciwgbnVsbCwgcm9vdEVsZW1lbnQsIHBlbmRpbmdFZGl0b3JTdGF0ZSk7XG4gICAgICAgIGluaXRNdXRhdGlvbk9ic2VydmVyKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gICAgICAgIGlzQXR0ZW1wdGluZ1RvUmVjb3ZlckZyb21SZWNvbmNpbGVyRXJyb3IgPSB0cnVlO1xuICAgICAgICBjb21taXRQZW5kaW5nVXBkYXRlcyhlZGl0b3IsIGN1cnJlbnRFZGl0b3JTdGF0ZSk7XG4gICAgICAgIGlzQXR0ZW1wdGluZ1RvUmVjb3ZlckZyb21SZWNvbmNpbGVyRXJyb3IgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRvIGF2b2lkIGEgcG9zc2libGUgc2l0dWF0aW9uIG9mIGluZmluaXRlIGxvb3BzLCBsZXRzIHRocm93XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUocm9vdEVsZW1lbnQsIG9ic2VydmVyT3B0aW9ucyk7XG4gICAgICBlZGl0b3IuX3VwZGF0aW5nID0gcHJldmlvdXNseVVwZGF0aW5nO1xuICAgICAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlO1xuICAgICAgaXNSZWFkT25seU1vZGUgPSBwcmV2aW91c1JlYWRPbmx5TW9kZTtcbiAgICAgIGFjdGl2ZUVkaXRvciA9IHByZXZpb3VzQWN0aXZlRWRpdG9yO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcGVuZGluZ0VkaXRvclN0YXRlLl9yZWFkT25seSkge1xuICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fcmVhZE9ubHkgPSB0cnVlO1xuXG4gICAge1xuICAgICAgaGFuZGxlREVWT25seVBlbmRpbmdVcGRhdGVHdWFyYW50ZWVzKHBlbmRpbmdFZGl0b3JTdGF0ZSk7XG5cbiAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihwZW5kaW5nU2VsZWN0aW9uKSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKHBlbmRpbmdTZWxlY3Rpb24uYW5jaG9yKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShwZW5kaW5nU2VsZWN0aW9uLmZvY3VzKTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmZyZWV6ZShwZW5kaW5nU2VsZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gIGNvbnN0IGRpcnR5RWxlbWVudHMgPSBlZGl0b3IuX2RpcnR5RWxlbWVudHM7XG4gIGNvbnN0IG5vcm1hbGl6ZWROb2RlcyA9IGVkaXRvci5fbm9ybWFsaXplZE5vZGVzO1xuICBjb25zdCB0YWdzID0gZWRpdG9yLl91cGRhdGVUYWdzO1xuICBjb25zdCBkZWZlcnJlZCA9IGVkaXRvci5fZGVmZXJyZWQ7XG5cbiAgaWYgKG5lZWRzVXBkYXRlKSB7XG4gICAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBOT19ESVJUWV9OT0RFUztcblxuICAgIGVkaXRvci5fY2xvbmVOb3ROZWVkZWQuY2xlYXIoKTtcblxuICAgIGVkaXRvci5fZGlydHlMZWF2ZXMgPSBuZXcgU2V0KCk7XG4gICAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGVkaXRvci5fbm9ybWFsaXplZE5vZGVzID0gbmV3IFNldCgpO1xuICAgIGVkaXRvci5fdXBkYXRlVGFncyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gICRnYXJiYWdlQ29sbGVjdERldGFjaGVkRGVjb3JhdG9ycyhlZGl0b3IsIHBlbmRpbmdFZGl0b3JTdGF0ZSk7IC8vID09PT09PVxuICAvLyBSZWNvbmNpbGlhdGlvbiBoYXMgZmluaXNoZWQuIE5vdyB1cGRhdGUgc2VsZWN0aW9uIGFuZCB0cmlnZ2VyIGxpc3RlbmVycy5cbiAgLy8gPT09PT09XG5cbiAgY29uc3QgZG9tU2VsZWN0aW9uID0gc2hvdWxkU2tpcERPTSA/IG51bGwgOiBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpOyAvLyBBdHRlbXB0IHRvIHVwZGF0ZSB0aGUgRE9NIHNlbGVjdGlvbiwgaW5jbHVkaW5nIGZvY3VzaW5nIG9mIHRoZSByb290IGVsZW1lbnQsXG4gIC8vIGFuZCBzY3JvbGwgaW50byB2aWV3IGlmIG5lZWRlZC5cblxuICBpZiAoZWRpdG9yLl9lZGl0YWJsZSAmJiAvLyBkb21TZWxlY3Rpb24gd2lsbCBiZSBudWxsIGluIGhlYWRsZXNzXG4gIGRvbVNlbGVjdGlvbiAhPT0gbnVsbCAmJiAobmVlZHNVcGRhdGUgfHwgcGVuZGluZ1NlbGVjdGlvbiA9PT0gbnVsbCB8fCBwZW5kaW5nU2VsZWN0aW9uLmRpcnR5KSkge1xuICAgIGFjdGl2ZUVkaXRvciA9IGVkaXRvcjtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHBlbmRpbmdFZGl0b3JTdGF0ZTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVlZHNVcGRhdGUgfHwgcGVuZGluZ1NlbGVjdGlvbiA9PT0gbnVsbCB8fCBwZW5kaW5nU2VsZWN0aW9uLmRpcnR5KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrQ3Vyc29yRWxlbWVudCA9IGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50O1xuXG4gICAgICAgIGlmIChibG9ja0N1cnNvckVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICByZW1vdmVET01CbG9ja0N1cnNvckVsZW1lbnQoYmxvY2tDdXJzb3JFbGVtZW50LCBlZGl0b3IsIHJvb3RFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZURPTVNlbGVjdGlvbihjdXJyZW50U2VsZWN0aW9uLCBwZW5kaW5nU2VsZWN0aW9uLCBlZGl0b3IsIGRvbVNlbGVjdGlvbiwgdGFncywgcm9vdEVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVET01CbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yLCByb290RWxlbWVudCwgcGVuZGluZ1NlbGVjdGlvbik7XG5cbiAgICAgIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHJvb3RFbGVtZW50LCBvYnNlcnZlck9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBhY3RpdmVFZGl0b3IgPSBwcmV2aW91c0FjdGl2ZUVkaXRvcjtcbiAgICAgIGFjdGl2ZUVkaXRvclN0YXRlID0gcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZTtcbiAgICB9XG4gIH1cblxuICBpZiAobXV0YXRlZE5vZGVzICE9PSBudWxsKSB7XG4gICAgdHJpZ2dlck11dGF0aW9uTGlzdGVuZXJzKGVkaXRvciwgbXV0YXRlZE5vZGVzLCB0YWdzLCBkaXJ0eUxlYXZlcywgY3VycmVudEVkaXRvclN0YXRlKTtcbiAgfVxuXG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24ocGVuZGluZ1NlbGVjdGlvbikgJiYgcGVuZGluZ1NlbGVjdGlvbiAhPT0gbnVsbCAmJiAoY3VycmVudFNlbGVjdGlvbiA9PT0gbnVsbCB8fCAhY3VycmVudFNlbGVjdGlvbi5pcyhwZW5kaW5nU2VsZWN0aW9uKSkpIHtcbiAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfVxuICAvKipcbiAgICogQ2FwdHVyZSBwZW5kaW5nRGVjb3JhdG9ycyBhZnRlciBnYXJiYWdlIGNvbGxlY3RpbmcgZGV0YWNoZWQgZGVjb3JhdG9yc1xuICAgKi9cblxuXG4gIGNvbnN0IHBlbmRpbmdEZWNvcmF0b3JzID0gZWRpdG9yLl9wZW5kaW5nRGVjb3JhdG9ycztcblxuICBpZiAocGVuZGluZ0RlY29yYXRvcnMgIT09IG51bGwpIHtcbiAgICBlZGl0b3IuX2RlY29yYXRvcnMgPSBwZW5kaW5nRGVjb3JhdG9ycztcbiAgICBlZGl0b3IuX3BlbmRpbmdEZWNvcmF0b3JzID0gbnVsbDtcbiAgICB0cmlnZ2VyTGlzdGVuZXJzKCdkZWNvcmF0b3InLCBlZGl0b3IsIHRydWUsIHBlbmRpbmdEZWNvcmF0b3JzKTtcbiAgfSAvLyBJZiByZWNvbmNpbGVyIGZhaWxzLCB3ZSByZXNldCB3aG9sZSBlZGl0b3IgKHNvIGN1cnJlbnQgZWRpdG9yIHN0YXRlIGJlY29tZXMgZW1wdHkpXG4gIC8vIGFuZCBhdHRlbXB0IHRvIHJlLXJlbmRlciBwZW5kaW5nRWRpdG9yU3RhdGUuIElmIHRoYXQgZ29lcyB0aHJvdWdoIHdlIHRyaWdnZXJcbiAgLy8gbGlzdGVuZXJzLCBidXQgaW5zdGVhZCB1c2UgcmVjb3ZlckVkaXRvclN0YXRlIHdoaWNoIGlzIGN1cnJlbnQgZWRpdG9yIHN0YXRlIGJlZm9yZSByZXNldFxuICAvLyBUaGlzIHNwZWNpZmljYWxseSBpbXBvcnRhbnQgZm9yIGNvbGxhYiB0aGF0IHJlbGllcyBvbiBwcmV2RWRpdG9yU3RhdGUgZnJvbSB1cGRhdGVcbiAgLy8gbGlzdGVuZXIgdG8gY2FsY3VsYXRlIGRlbHRhIG9mIGNoYW5nZWQgbm9kZXMvcHJvcGVydGllc1xuXG5cbiAgdHJpZ2dlclRleHRDb250ZW50TGlzdGVuZXJzKGVkaXRvciwgcmVjb3ZlcnlFZGl0b3JTdGF0ZSB8fCBjdXJyZW50RWRpdG9yU3RhdGUsIHBlbmRpbmdFZGl0b3JTdGF0ZSk7XG4gIHRyaWdnZXJMaXN0ZW5lcnMoJ3VwZGF0ZScsIGVkaXRvciwgdHJ1ZSwge1xuICAgIGRpcnR5RWxlbWVudHMsXG4gICAgZGlydHlMZWF2ZXMsXG4gICAgZWRpdG9yU3RhdGU6IHBlbmRpbmdFZGl0b3JTdGF0ZSxcbiAgICBub3JtYWxpemVkTm9kZXMsXG4gICAgcHJldkVkaXRvclN0YXRlOiByZWNvdmVyeUVkaXRvclN0YXRlIHx8IGN1cnJlbnRFZGl0b3JTdGF0ZSxcbiAgICB0YWdzXG4gIH0pO1xuICB0cmlnZ2VyRGVmZXJyZWRVcGRhdGVDYWxsYmFja3MoZWRpdG9yLCBkZWZlcnJlZCk7XG4gIHRyaWdnZXJFbnF1ZXVlZFVwZGF0ZXMoZWRpdG9yKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlclRleHRDb250ZW50TGlzdGVuZXJzKGVkaXRvciwgY3VycmVudEVkaXRvclN0YXRlLCBwZW5kaW5nRWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgY3VycmVudFRleHRDb250ZW50ID0gZ2V0RWRpdG9yU3RhdGVUZXh0Q29udGVudChjdXJyZW50RWRpdG9yU3RhdGUpO1xuICBjb25zdCBsYXRlc3RUZXh0Q29udGVudCA9IGdldEVkaXRvclN0YXRlVGV4dENvbnRlbnQocGVuZGluZ0VkaXRvclN0YXRlKTtcblxuICBpZiAoY3VycmVudFRleHRDb250ZW50ICE9PSBsYXRlc3RUZXh0Q29udGVudCkge1xuICAgIHRyaWdnZXJMaXN0ZW5lcnMoJ3RleHRjb250ZW50JywgZWRpdG9yLCB0cnVlLCBsYXRlc3RUZXh0Q29udGVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpZ2dlck11dGF0aW9uTGlzdGVuZXJzKGVkaXRvciwgbXV0YXRlZE5vZGVzLCB1cGRhdGVUYWdzLCBkaXJ0eUxlYXZlcywgcHJldkVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGxpc3RlbmVycyA9IEFycmF5LmZyb20oZWRpdG9yLl9saXN0ZW5lcnMubXV0YXRpb24pO1xuICBjb25zdCBsaXN0ZW5lcnNMZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBbbGlzdGVuZXIsIGtsYXNzXSA9IGxpc3RlbmVyc1tpXTtcbiAgICBjb25zdCBtdXRhdGVkTm9kZXNCeVR5cGUgPSBtdXRhdGVkTm9kZXMuZ2V0KGtsYXNzKTtcblxuICAgIGlmIChtdXRhdGVkTm9kZXNCeVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGlzdGVuZXIobXV0YXRlZE5vZGVzQnlUeXBlLCB7XG4gICAgICAgIGRpcnR5TGVhdmVzLFxuICAgICAgICBwcmV2RWRpdG9yU3RhdGUsXG4gICAgICAgIHVwZGF0ZVRhZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cmlnZ2VyTGlzdGVuZXJzKHR5cGUsIGVkaXRvciwgaXNDdXJyZW50bHlFbnF1ZXVpbmdVcGRhdGVzLCAuLi5wYXlsb2FkKSB7XG4gIGNvbnN0IHByZXZpb3VzbHlVcGRhdGluZyA9IGVkaXRvci5fdXBkYXRpbmc7XG4gIGVkaXRvci5fdXBkYXRpbmcgPSBpc0N1cnJlbnRseUVucXVldWluZ1VwZGF0ZXM7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBBcnJheS5mcm9tKGVkaXRvci5fbGlzdGVuZXJzW3R5cGVdKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkobnVsbCwgcGF5bG9hZCk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGVkaXRvci5fdXBkYXRpbmcgPSBwcmV2aW91c2x5VXBkYXRpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJDb21tYW5kTGlzdGVuZXJzKGVkaXRvciwgdHlwZSwgcGF5bG9hZCkge1xuICBpZiAoZWRpdG9yLl91cGRhdGluZyA9PT0gZmFsc2UgfHwgYWN0aXZlRWRpdG9yICE9PSBlZGl0b3IpIHtcbiAgICBsZXQgcmV0dXJuVmFsID0gZmFsc2U7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICByZXR1cm5WYWwgPSB0cmlnZ2VyQ29tbWFuZExpc3RlbmVycyhlZGl0b3IsIHR5cGUsIHBheWxvYWQpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXR1cm5WYWw7XG4gIH1cblxuICBjb25zdCBlZGl0b3JzID0gZ2V0RWRpdG9yc1RvUHJvcGFnYXRlKGVkaXRvcik7XG5cbiAgZm9yIChsZXQgaSA9IDQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgZm9yIChsZXQgZSA9IDA7IGUgPCBlZGl0b3JzLmxlbmd0aDsgZSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gZWRpdG9yc1tlXTtcbiAgICAgIGNvbnN0IGNvbW1hbmRMaXN0ZW5lcnMgPSBjdXJyZW50RWRpdG9yLl9jb21tYW5kcztcbiAgICAgIGNvbnN0IGxpc3RlbmVySW5Qcmlvcml0eU9yZGVyID0gY29tbWFuZExpc3RlbmVycy5nZXQodHlwZSk7XG5cbiAgICAgIGlmIChsaXN0ZW5lckluUHJpb3JpdHlPcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyc1NldCA9IGxpc3RlbmVySW5Qcmlvcml0eU9yZGVyW2ldO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnNTZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IEFycmF5LmZyb20obGlzdGVuZXJzU2V0KTtcbiAgICAgICAgICBjb25zdCBsaXN0ZW5lcnNMZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaXN0ZW5lcnNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tqXShwYXlsb2FkLCBlZGl0b3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlckVucXVldWVkVXBkYXRlcyhlZGl0b3IpIHtcbiAgY29uc3QgcXVldWVkVXBkYXRlcyA9IGVkaXRvci5fdXBkYXRlcztcblxuICBpZiAocXVldWVkVXBkYXRlcy5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBxdWV1ZWRVcGRhdGUgPSBxdWV1ZWRVcGRhdGVzLnNoaWZ0KCk7XG5cbiAgICBpZiAocXVldWVkVXBkYXRlKSB7XG4gICAgICBjb25zdCBbdXBkYXRlRm4sIG9wdGlvbnNdID0gcXVldWVkVXBkYXRlO1xuICAgICAgYmVnaW5VcGRhdGUoZWRpdG9yLCB1cGRhdGVGbiwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJEZWZlcnJlZFVwZGF0ZUNhbGxiYWNrcyhlZGl0b3IsIGRlZmVycmVkKSB7XG4gIGVkaXRvci5fZGVmZXJyZWQgPSBbXTtcblxuICBpZiAoZGVmZXJyZWQubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgcHJldmlvdXNseVVwZGF0aW5nID0gZWRpdG9yLl91cGRhdGluZztcbiAgICBlZGl0b3IuX3VwZGF0aW5nID0gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmVycmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlZmVycmVkW2ldKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVkaXRvci5fdXBkYXRpbmcgPSBwcmV2aW91c2x5VXBkYXRpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NOZXN0ZWRVcGRhdGVzKGVkaXRvciwgaW5pdGlhbFNraXBUcmFuc2Zvcm1zKSB7XG4gIGNvbnN0IHF1ZXVlZFVwZGF0ZXMgPSBlZGl0b3IuX3VwZGF0ZXM7XG4gIGxldCBza2lwVHJhbnNmb3JtcyA9IGluaXRpYWxTa2lwVHJhbnNmb3JtcyB8fCBmYWxzZTsgLy8gVXBkYXRlcyBtaWdodCBncm93IGFzIHdlIHByb2Nlc3MgdGhlbSwgd2Ugc28gd2UnbGwgbmVlZFxuICAvLyB0byBoYW5kbGUgZWFjaCB1cGRhdGUgYXMgd2UgZ28gdW50aWwgdGhlIHVwZGF0ZXMgYXJyYXkgaXNcbiAgLy8gZW1wdHkuXG5cbiAgd2hpbGUgKHF1ZXVlZFVwZGF0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgcXVldWVkVXBkYXRlID0gcXVldWVkVXBkYXRlcy5zaGlmdCgpO1xuXG4gICAgaWYgKHF1ZXVlZFVwZGF0ZSkge1xuICAgICAgY29uc3QgW25leHRVcGRhdGVGbiwgb3B0aW9uc10gPSBxdWV1ZWRVcGRhdGU7XG4gICAgICBsZXQgb25VcGRhdGU7XG4gICAgICBsZXQgdGFnO1xuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9uVXBkYXRlID0gb3B0aW9ucy5vblVwZGF0ZTtcbiAgICAgICAgdGFnID0gb3B0aW9ucy50YWc7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc2tpcFRyYW5zZm9ybXMpIHtcbiAgICAgICAgICBza2lwVHJhbnNmb3JtcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgICAgICBlZGl0b3IuX2RlZmVycmVkLnB1c2gob25VcGRhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgIGVkaXRvci5fdXBkYXRlVGFncy5hZGQodGFnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0VXBkYXRlRm4oKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2tpcFRyYW5zZm9ybXM7XG59XG5cbmZ1bmN0aW9uIGJlZ2luVXBkYXRlKGVkaXRvciwgdXBkYXRlRm4sIG9wdGlvbnMpIHtcbiAgY29uc3QgdXBkYXRlVGFncyA9IGVkaXRvci5fdXBkYXRlVGFncztcbiAgbGV0IG9uVXBkYXRlO1xuICBsZXQgdGFnO1xuICBsZXQgc2tpcFRyYW5zZm9ybXMgPSBmYWxzZTtcbiAgbGV0IGRpc2NyZXRlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIG9uVXBkYXRlID0gb3B0aW9ucy5vblVwZGF0ZTtcbiAgICB0YWcgPSBvcHRpb25zLnRhZztcblxuICAgIGlmICh0YWcgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlVGFncy5hZGQodGFnKTtcbiAgICB9XG5cbiAgICBza2lwVHJhbnNmb3JtcyA9IG9wdGlvbnMuc2tpcFRyYW5zZm9ybXMgfHwgZmFsc2U7XG4gICAgZGlzY3JldGUgPSBvcHRpb25zLmRpc2NyZXRlIHx8IGZhbHNlO1xuICB9XG5cbiAgaWYgKG9uVXBkYXRlKSB7XG4gICAgZWRpdG9yLl9kZWZlcnJlZC5wdXNoKG9uVXBkYXRlKTtcbiAgfVxuXG4gIGNvbnN0IGN1cnJlbnRFZGl0b3JTdGF0ZSA9IGVkaXRvci5fZWRpdG9yU3RhdGU7XG4gIGxldCBwZW5kaW5nRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgbGV0IGVkaXRvclN0YXRlV2FzQ2xvbmVkID0gZmFsc2U7XG5cbiAgaWYgKHBlbmRpbmdFZGl0b3JTdGF0ZSA9PT0gbnVsbCB8fCBwZW5kaW5nRWRpdG9yU3RhdGUuX3JlYWRPbmx5KSB7XG4gICAgcGVuZGluZ0VkaXRvclN0YXRlID0gZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBjbG9uZUVkaXRvclN0YXRlKHBlbmRpbmdFZGl0b3JTdGF0ZSB8fCBjdXJyZW50RWRpdG9yU3RhdGUpO1xuICAgIGVkaXRvclN0YXRlV2FzQ2xvbmVkID0gdHJ1ZTtcbiAgfVxuXG4gIHBlbmRpbmdFZGl0b3JTdGF0ZS5fZmx1c2hTeW5jID0gZGlzY3JldGU7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGUgPSBhY3RpdmVFZGl0b3JTdGF0ZTtcbiAgY29uc3QgcHJldmlvdXNSZWFkT25seU1vZGUgPSBpc1JlYWRPbmx5TW9kZTtcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3IgPSBhY3RpdmVFZGl0b3I7XG4gIGNvbnN0IHByZXZpb3VzbHlVcGRhdGluZyA9IGVkaXRvci5fdXBkYXRpbmc7XG4gIGFjdGl2ZUVkaXRvclN0YXRlID0gcGVuZGluZ0VkaXRvclN0YXRlO1xuICBpc1JlYWRPbmx5TW9kZSA9IGZhbHNlO1xuICBlZGl0b3IuX3VwZGF0aW5nID0gdHJ1ZTtcbiAgYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuXG4gIHRyeSB7XG4gICAgaWYgKGVkaXRvclN0YXRlV2FzQ2xvbmVkKSB7XG4gICAgICBpZiAoZWRpdG9yLl9oZWFkbGVzcykge1xuICAgICAgICBpZiAoY3VycmVudEVkaXRvclN0YXRlLl9zZWxlY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uID0gY3VycmVudEVkaXRvclN0YXRlLl9zZWxlY3Rpb24uY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVuZGluZ0VkaXRvclN0YXRlLl9zZWxlY3Rpb24gPSBpbnRlcm5hbENyZWF0ZVNlbGVjdGlvbihlZGl0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0aW5nQ29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICAgIHVwZGF0ZUZuKCk7XG4gICAgc2tpcFRyYW5zZm9ybXMgPSBwcm9jZXNzTmVzdGVkVXBkYXRlcyhlZGl0b3IsIHNraXBUcmFuc2Zvcm1zKTtcbiAgICBhcHBseVNlbGVjdGlvblRyYW5zZm9ybXMocGVuZGluZ0VkaXRvclN0YXRlLCBlZGl0b3IpO1xuXG4gICAgaWYgKGVkaXRvci5fZGlydHlUeXBlICE9PSBOT19ESVJUWV9OT0RFUykge1xuICAgICAgaWYgKHNraXBUcmFuc2Zvcm1zKSB7XG4gICAgICAgICRub3JtYWxpemVBbGxEaXJ0eVRleHROb2RlcyhwZW5kaW5nRWRpdG9yU3RhdGUsIGVkaXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkYXBwbHlBbGxUcmFuc2Zvcm1zKHBlbmRpbmdFZGl0b3JTdGF0ZSwgZWRpdG9yKTtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzc05lc3RlZFVwZGF0ZXMoZWRpdG9yKTtcbiAgICAgICRnYXJiYWdlQ29sbGVjdERldGFjaGVkTm9kZXMoY3VycmVudEVkaXRvclN0YXRlLCBwZW5kaW5nRWRpdG9yU3RhdGUsIGVkaXRvci5fZGlydHlMZWF2ZXMsIGVkaXRvci5fZGlydHlFbGVtZW50cyk7XG4gICAgfVxuXG4gICAgY29uc3QgZW5kaW5nQ29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuXG4gICAgaWYgKHN0YXJ0aW5nQ29tcG9zaXRpb25LZXkgIT09IGVuZGluZ0NvbXBvc2l0aW9uS2V5KSB7XG4gICAgICBwZW5kaW5nRWRpdG9yU3RhdGUuX2ZsdXNoU3luYyA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgcGVuZGluZ1NlbGVjdGlvbiA9IHBlbmRpbmdFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuXG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHBlbmRpbmdTZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBwZW5kaW5nTm9kZU1hcCA9IHBlbmRpbmdFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgICAgIGNvbnN0IGFuY2hvcktleSA9IHBlbmRpbmdTZWxlY3Rpb24uYW5jaG9yLmtleTtcbiAgICAgIGNvbnN0IGZvY3VzS2V5ID0gcGVuZGluZ1NlbGVjdGlvbi5mb2N1cy5rZXk7XG5cbiAgICAgIGlmIChwZW5kaW5nTm9kZU1hcC5nZXQoYW5jaG9yS2V5KSA9PT0gdW5kZWZpbmVkIHx8IHBlbmRpbmdOb2RlTWFwLmdldChmb2N1c0tleSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYHVwZGF0ZUVkaXRvcjogc2VsZWN0aW9uIGhhcyBiZWVuIGxvc3QgYmVjYXVzZSB0aGUgcHJldmlvdXNseSBzZWxlY3RlZCBub2RlcyBoYXZlIGJlZW4gcmVtb3ZlZCBhbmQgc2VsZWN0aW9uIHdhc24ndCBtb3ZlZCB0byBhbm90aGVyIG5vZGUuIEVuc3VyZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciByZW1vdmluZy9yZXBsYWNpbmcgYSBzZWxlY3RlZCBub2RlLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgkaXNOb2RlU2VsZWN0aW9uKHBlbmRpbmdTZWxlY3Rpb24pKSB7XG4gICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgYWxzbyB2YWxpZGF0ZSBub2RlIHNlbGVjdGlvbj9cbiAgICAgIGlmIChwZW5kaW5nU2VsZWN0aW9uLl9ub2Rlcy5zaXplID09PSAwKSB7XG4gICAgICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gUmVwb3J0IGVycm9yc1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBlZGl0b3IuX29uRXJyb3IoZXJyb3IpO1xuICAgIH0gLy8gUmVzdG9yZSBleGlzdGluZyBlZGl0b3Igc3RhdGUgdG8gdGhlIERPTVxuXG5cbiAgICBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IGN1cnJlbnRFZGl0b3JTdGF0ZTtcbiAgICBlZGl0b3IuX2RpcnR5VHlwZSA9IEZVTExfUkVDT05DSUxFO1xuXG4gICAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZC5jbGVhcigpO1xuXG4gICAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IG5ldyBTZXQoKTtcblxuICAgIGVkaXRvci5fZGlydHlFbGVtZW50cy5jbGVhcigpO1xuXG4gICAgY29tbWl0UGVuZGluZ1VwZGF0ZXMoZWRpdG9yKTtcbiAgICByZXR1cm47XG4gIH0gZmluYWxseSB7XG4gICAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlO1xuICAgIGlzUmVhZE9ubHlNb2RlID0gcHJldmlvdXNSZWFkT25seU1vZGU7XG4gICAgYWN0aXZlRWRpdG9yID0gcHJldmlvdXNBY3RpdmVFZGl0b3I7XG4gICAgZWRpdG9yLl91cGRhdGluZyA9IHByZXZpb3VzbHlVcGRhdGluZztcbiAgICBpbmZpbml0ZVRyYW5zZm9ybUNvdW50ID0gMDtcbiAgfVxuXG4gIGNvbnN0IHNob3VsZFVwZGF0ZSA9IGVkaXRvci5fZGlydHlUeXBlICE9PSBOT19ESVJUWV9OT0RFUyB8fCBlZGl0b3JTdGF0ZUhhc0RpcnR5U2VsZWN0aW9uKHBlbmRpbmdFZGl0b3JTdGF0ZSwgZWRpdG9yKTtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgaWYgKHBlbmRpbmdFZGl0b3JTdGF0ZS5fZmx1c2hTeW5jKSB7XG4gICAgICBwZW5kaW5nRWRpdG9yU3RhdGUuX2ZsdXNoU3luYyA9IGZhbHNlO1xuICAgICAgY29tbWl0UGVuZGluZ1VwZGF0ZXMoZWRpdG9yKTtcbiAgICB9IGVsc2UgaWYgKGVkaXRvclN0YXRlV2FzQ2xvbmVkKSB7XG4gICAgICBzY2hlZHVsZU1pY3JvVGFzaygoKSA9PiB7XG4gICAgICAgIGNvbW1pdFBlbmRpbmdVcGRhdGVzKGVkaXRvcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGVuZGluZ0VkaXRvclN0YXRlLl9mbHVzaFN5bmMgPSBmYWxzZTtcblxuICAgIGlmIChlZGl0b3JTdGF0ZVdhc0Nsb25lZCkge1xuICAgICAgdXBkYXRlVGFncy5jbGVhcigpO1xuICAgICAgZWRpdG9yLl9kZWZlcnJlZCA9IFtdO1xuICAgICAgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVFZGl0b3IoZWRpdG9yLCB1cGRhdGVGbiwgb3B0aW9ucykge1xuICBpZiAoZWRpdG9yLl91cGRhdGluZykge1xuICAgIGVkaXRvci5fdXBkYXRlcy5wdXNoKFt1cGRhdGVGbiwgb3B0aW9uc10pO1xuICB9IGVsc2Uge1xuICAgIGJlZ2luVXBkYXRlKGVkaXRvciwgdXBkYXRlRm4sIG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5cbmNsYXNzIERlY29yYXRvck5vZGUgZXh0ZW5kcyBMZXhpY2FsTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gIH1cblxuICBkZWNvcmF0ZShlZGl0b3IsIGNvbmZpZykge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBkZWNvcmF0ZTogYmFzZSBtZXRob2Qgbm90IGV4dGVuZGVkYCk7XG4gICAgfVxuICB9XG5cbiAgaXNJc29sYXRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlzS2V5Ym9hcmRTZWxlY3RhYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn1cbmZ1bmN0aW9uICRpc0RlY29yYXRvck5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIERlY29yYXRvck5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIEVsZW1lbnROb2RlIGV4dGVuZHMgTGV4aWNhbE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fZmlyc3QgPSBudWxsO1xuICAgIHRoaXMuX19sYXN0ID0gbnVsbDtcbiAgICB0aGlzLl9fc2l6ZSA9IDA7XG4gICAgdGhpcy5fX2Zvcm1hdCA9IDA7XG4gICAgdGhpcy5fX2luZGVudCA9IDA7XG4gICAgdGhpcy5fX2RpciA9IG51bGw7XG4gIH1cblxuICBnZXRGb3JtYXQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19mb3JtYXQ7XG4gIH1cblxuICBnZXRGb3JtYXRUeXBlKCkge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0Rm9ybWF0KCk7XG4gICAgcmV0dXJuIEVMRU1FTlRfRk9STUFUX1RPX1RZUEVbZm9ybWF0XSB8fCAnJztcbiAgfVxuXG4gIGdldEluZGVudCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2luZGVudDtcbiAgfVxuXG4gIGdldENoaWxkcmVuKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgbGV0IGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5nZXROZXh0U2libGluZygpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIGdldENoaWxkcmVuS2V5cygpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkLl9fa2V5KTtcbiAgICAgIGNoaWxkID0gY2hpbGQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICBnZXRDaGlsZHJlblNpemUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19zaXplO1xuICB9XG5cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDaGlsZHJlblNpemUoKSA9PT0gMDtcbiAgfVxuXG4gIGlzRGlydHkoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gICAgY29uc3QgZGlydHlFbGVtZW50cyA9IGVkaXRvci5fZGlydHlFbGVtZW50cztcbiAgICByZXR1cm4gZGlydHlFbGVtZW50cyAhPT0gbnVsbCAmJiBkaXJ0eUVsZW1lbnRzLmhhcyh0aGlzLl9fa2V5KTtcbiAgfVxuXG4gIGlzTGFzdENoaWxkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IHBhcmVudExhc3RDaGlsZCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpLmdldExhc3RDaGlsZCgpO1xuICAgIHJldHVybiBwYXJlbnRMYXN0Q2hpbGQgIT09IG51bGwgJiYgcGFyZW50TGFzdENoaWxkLmlzKHNlbGYpO1xuICB9XG5cbiAgZ2V0QWxsVGV4dE5vZGVzKCkge1xuICAgIGNvbnN0IHRleHROb2RlcyA9IFtdO1xuICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgIHRleHROb2Rlcy5wdXNoKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSkge1xuICAgICAgICBjb25zdCBzdWJDaGlsZHJlbk5vZGVzID0gY2hpbGQuZ2V0QWxsVGV4dE5vZGVzKCk7XG4gICAgICAgIHRleHROb2Rlcy5wdXNoKC4uLnN1YkNoaWxkcmVuTm9kZXMpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHROb2RlcztcbiAgfVxuXG4gIGdldEZpcnN0RGVzY2VuZGFudCgpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGdldExhc3REZXNjZW5kYW50KCkge1xuICAgIGxldCBub2RlID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmdldExhc3RDaGlsZCgpO1xuXG4gICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGdldERlc2NlbmRhbnRCeUluZGV4KGluZGV4KSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7IC8vIEZvciBub24tZW1wdHkgZWxlbWVudCBub2Rlcywgd2UgcmVzb2x2ZSBpdHMgZGVzY2VuZGFudFxuICAgIC8vIChlaXRoZXIgYSBsZWFmIG5vZGUgb3IgdGhlIGJvdHRvbS1tb3N0IGVsZW1lbnQpXG5cbiAgICBpZiAoaW5kZXggPj0gY2hpbGRyZW5MZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkTm9kZSA9IGNoaWxkcmVuW2NoaWxkcmVuTGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4gJGlzRWxlbWVudE5vZGUocmVzb2x2ZWROb2RlKSAmJiByZXNvbHZlZE5vZGUuZ2V0TGFzdERlc2NlbmRhbnQoKSB8fCByZXNvbHZlZE5vZGUgfHwgbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCByZXNvbHZlZE5vZGUgPSBjaGlsZHJlbltpbmRleF07XG4gICAgcmV0dXJuICRpc0VsZW1lbnROb2RlKHJlc29sdmVkTm9kZSkgJiYgcmVzb2x2ZWROb2RlLmdldEZpcnN0RGVzY2VuZGFudCgpIHx8IHJlc29sdmVkTm9kZSB8fCBudWxsO1xuICB9XG5cbiAgZ2V0Rmlyc3RDaGlsZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBmaXJzdEtleSA9IHNlbGYuX19maXJzdDtcbiAgICByZXR1cm4gZmlyc3RLZXkgPT09IG51bGwgPyBudWxsIDogJGdldE5vZGVCeUtleShmaXJzdEtleSk7XG4gIH1cblxuICBnZXRGaXJzdENoaWxkT3JUaHJvdygpIHtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICBpZiAoZmlyc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSAke3RoaXMuX19rZXl9IHRvIGhhdmUgYSBmaXJzdCBjaGlsZC5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmlyc3RDaGlsZDtcbiAgfVxuXG4gIGdldExhc3RDaGlsZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBsYXN0S2V5ID0gc2VsZi5fX2xhc3Q7XG4gICAgcmV0dXJuIGxhc3RLZXkgPT09IG51bGwgPyBudWxsIDogJGdldE5vZGVCeUtleShsYXN0S2V5KTtcbiAgfVxuXG4gIGdldExhc3RDaGlsZE9yVGhyb3coKSB7XG4gICAgY29uc3QgbGFzdENoaWxkID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcblxuICAgIGlmIChsYXN0Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIG5vZGUgJHt0aGlzLl9fa2V5fSB0byBoYXZlIGEgbGFzdCBjaGlsZC5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdENoaWxkO1xuICB9XG5cbiAgZ2V0Q2hpbGRBdEluZGV4KGluZGV4KSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGk7XG5cbiAgICBpZiAoaW5kZXggPCBzaXplIC8gMikge1xuICAgICAgbm9kZSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIGkgPD0gaW5kZXgpIHtcbiAgICAgICAgaWYgKGkgPT09IGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG5vZGUgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuICAgIGkgPSBzaXplIC0gMTtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIGkgPj0gaW5kZXgpIHtcbiAgICAgIGlmIChpID09PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHRleHRDb250ZW50ICs9IGNoaWxkLmdldFRleHRDb250ZW50KCk7XG5cbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkgJiYgaSAhPT0gY2hpbGRyZW5MZW5ndGggLSAxICYmICFjaGlsZC5pc0lubGluZSgpKSB7XG4gICAgICAgIHRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0ZXh0Q29udGVudDtcbiAgfVxuXG4gIGdldFRleHRDb250ZW50U2l6ZSgpIHtcbiAgICBsZXQgdGV4dENvbnRlbnRTaXplID0gMDtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHRleHRDb250ZW50U2l6ZSArPSBjaGlsZC5nZXRUZXh0Q29udGVudFNpemUoKTtcblxuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSAmJiBpICE9PSBjaGlsZHJlbkxlbmd0aCAtIDEgJiYgIWNoaWxkLmlzSW5saW5lKCkpIHtcbiAgICAgICAgdGV4dENvbnRlbnRTaXplICs9IERPVUJMRV9MSU5FX0JSRUFLLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dENvbnRlbnRTaXplO1xuICB9XG5cbiAgZ2V0RGlyZWN0aW9uKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fZGlyO1xuICB9XG5cbiAgaGFzRm9ybWF0KHR5cGUpIHtcbiAgICBpZiAodHlwZSAhPT0gJycpIHtcbiAgICAgIGNvbnN0IGZvcm1hdEZsYWcgPSBFTEVNRU5UX1RZUEVfVE9fRk9STUFUW3R5cGVdO1xuICAgICAgcmV0dXJuICh0aGlzLmdldEZvcm1hdCgpICYgZm9ybWF0RmxhZykgIT09IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIE11dGF0b3JzXG5cblxuICBzZWxlY3QoX2FuY2hvck9mZnNldCwgX2ZvY3VzT2Zmc2V0KSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGxldCBhbmNob3JPZmZzZXQgPSBfYW5jaG9yT2Zmc2V0O1xuICAgIGxldCBmb2N1c09mZnNldCA9IF9mb2N1c09mZnNldDtcbiAgICBjb25zdCBjaGlsZHJlbkNvdW50ID0gdGhpcy5nZXRDaGlsZHJlblNpemUoKTtcblxuICAgIGlmICghdGhpcy5jYW5CZUVtcHR5KCkpIHtcbiAgICAgIGlmIChfYW5jaG9yT2Zmc2V0ID09PSAwICYmIF9mb2N1c09mZnNldCA9PT0gMCkge1xuICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICAgICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Q2hpbGQpIHx8ICRpc0VsZW1lbnROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZpcnN0Q2hpbGQuc2VsZWN0KDAsIDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChfYW5jaG9yT2Zmc2V0ID09PSB1bmRlZmluZWQgfHwgX2FuY2hvck9mZnNldCA9PT0gY2hpbGRyZW5Db3VudCkgJiYgKF9mb2N1c09mZnNldCA9PT0gdW5kZWZpbmVkIHx8IF9mb2N1c09mZnNldCA9PT0gY2hpbGRyZW5Db3VudCkpIHtcbiAgICAgICAgY29uc3QgbGFzdENoaWxkID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcblxuICAgICAgICBpZiAoJGlzVGV4dE5vZGUobGFzdENoaWxkKSB8fCAkaXNFbGVtZW50Tm9kZShsYXN0Q2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIGxhc3RDaGlsZC5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbmNob3JPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYW5jaG9yT2Zmc2V0ID0gY2hpbGRyZW5Db3VudDtcbiAgICB9XG5cbiAgICBpZiAoZm9jdXNPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9jdXNPZmZzZXQgPSBjaGlsZHJlbkNvdW50O1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IHRoaXMuX19rZXk7XG5cbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBpbnRlcm5hbE1ha2VSYW5nZVNlbGVjdGlvbihrZXksIGFuY2hvck9mZnNldCwga2V5LCBmb2N1c09mZnNldCwgJ2VsZW1lbnQnLCAnZWxlbWVudCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldChrZXksIGFuY2hvck9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgIHNlbGVjdGlvbi5mb2N1cy5zZXQoa2V5LCBmb2N1c09mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgfVxuXG4gIHNlbGVjdFN0YXJ0KCkge1xuICAgIGNvbnN0IGZpcnN0Tm9kZSA9IHRoaXMuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG5cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoZmlyc3ROb2RlKSB8fCAkaXNUZXh0Tm9kZShmaXJzdE5vZGUpKSB7XG4gICAgICByZXR1cm4gZmlyc3ROb2RlLnNlbGVjdCgwLCAwKTtcbiAgICB9IC8vIERlY29yYXRvciBvciBMaW5lQnJlYWtcblxuXG4gICAgaWYgKGZpcnN0Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZpcnN0Tm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNlbGVjdCgwLCAwKTtcbiAgfVxuXG4gIHNlbGVjdEVuZCgpIHtcbiAgICBjb25zdCBsYXN0Tm9kZSA9IHRoaXMuZ2V0TGFzdERlc2NlbmRhbnQoKTtcblxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShsYXN0Tm9kZSkgfHwgJGlzVGV4dE5vZGUobGFzdE5vZGUpKSB7XG4gICAgICByZXR1cm4gbGFzdE5vZGUuc2VsZWN0KCk7XG4gICAgfSAvLyBEZWNvcmF0b3Igb3IgTGluZUJyZWFrXG5cblxuICAgIGlmIChsYXN0Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGxhc3ROb2RlLnNlbGVjdE5leHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZWxlY3QoKTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGNvbnN0IHdyaXRhYmxlU2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnJlbW92ZSgpKTtcbiAgICByZXR1cm4gd3JpdGFibGVTZWxmO1xuICB9XG5cbiAgYXBwZW5kKC4uLm5vZGVzVG9BcHBlbmQpIHtcbiAgICByZXR1cm4gdGhpcy5zcGxpY2UodGhpcy5nZXRDaGlsZHJlblNpemUoKSwgMCwgbm9kZXNUb0FwcGVuZCk7XG4gIH1cblxuICBzZXREaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fZGlyID0gZGlyZWN0aW9uO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgc2V0Rm9ybWF0KHR5cGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19mb3JtYXQgPSB0eXBlICE9PSAnJyA/IEVMRU1FTlRfVFlQRV9UT19GT1JNQVRbdHlwZV0gOiAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0SW5kZW50KGluZGVudExldmVsKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9faW5kZW50ID0gaW5kZW50TGV2ZWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCBub2Rlc1RvSW5zZXJ0KSB7XG4gICAgY29uc3Qgbm9kZXNUb0luc2VydExlbmd0aCA9IG5vZGVzVG9JbnNlcnQubGVuZ3RoO1xuICAgIGNvbnN0IG9sZFNpemUgPSB0aGlzLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgIGNvbnN0IHdyaXRhYmxlU2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCB3cml0YWJsZVNlbGZLZXkgPSB3cml0YWJsZVNlbGYuX19rZXk7XG4gICAgY29uc3Qgbm9kZXNUb0luc2VydEtleXMgPSBbXTtcbiAgICBjb25zdCBub2Rlc1RvUmVtb3ZlS2V5cyA9IFtdO1xuICAgIGNvbnN0IG5vZGVBZnRlclJhbmdlID0gdGhpcy5nZXRDaGlsZEF0SW5kZXgoc3RhcnQgKyBkZWxldGVDb3VudCk7XG4gICAgbGV0IG5vZGVCZWZvcmVSYW5nZSA9IG51bGw7XG4gICAgbGV0IG5ld1NpemUgPSBvbGRTaXplIC0gZGVsZXRlQ291bnQgKyBub2Rlc1RvSW5zZXJ0TGVuZ3RoO1xuXG4gICAgaWYgKHN0YXJ0ICE9PSAwKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IG9sZFNpemUpIHtcbiAgICAgICAgbm9kZUJlZm9yZVJhbmdlID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldENoaWxkQXRJbmRleChzdGFydCk7XG5cbiAgICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlQmVmb3JlUmFuZ2UgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlbGV0ZUNvdW50ID4gMCkge1xuICAgICAgbGV0IG5vZGVUb0RlbGV0ZSA9IG5vZGVCZWZvcmVSYW5nZSA9PT0gbnVsbCA/IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpIDogbm9kZUJlZm9yZVJhbmdlLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsZXRlQ291bnQ7IGkrKykge1xuICAgICAgICBpZiAobm9kZVRvRGVsZXRlID09PSBudWxsKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYHNwbGljZTogc2libGluZyBub3QgZm91bmRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGVUb0RlbGV0ZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICBjb25zdCBub2RlS2V5VG9EZWxldGUgPSBub2RlVG9EZWxldGUuX19rZXk7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlTm9kZVRvRGVsZXRlID0gbm9kZVRvRGVsZXRlLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9EZWxldGUpO1xuICAgICAgICBub2Rlc1RvUmVtb3ZlS2V5cy5wdXNoKG5vZGVLZXlUb0RlbGV0ZSk7XG4gICAgICAgIG5vZGVUb0RlbGV0ZSA9IG5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBwcmV2Tm9kZSA9IG5vZGVCZWZvcmVSYW5nZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNUb0luc2VydExlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlVG9JbnNlcnQgPSBub2Rlc1RvSW5zZXJ0W2ldO1xuXG4gICAgICBpZiAocHJldk5vZGUgIT09IG51bGwgJiYgbm9kZVRvSW5zZXJ0LmlzKHByZXZOb2RlKSkge1xuICAgICAgICBub2RlQmVmb3JlUmFuZ2UgPSBwcmV2Tm9kZSA9IHByZXZOb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3cml0YWJsZU5vZGVUb0luc2VydCA9IG5vZGVUb0luc2VydC5nZXRXcml0YWJsZSgpO1xuXG4gICAgICBpZiAod3JpdGFibGVOb2RlVG9JbnNlcnQuX19wYXJlbnQgPT09IHdyaXRhYmxlU2VsZktleSkge1xuICAgICAgICBuZXdTaXplLS07XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9JbnNlcnQpO1xuICAgICAgY29uc3Qgbm9kZUtleVRvSW5zZXJ0ID0gbm9kZVRvSW5zZXJ0Ll9fa2V5O1xuXG4gICAgICBpZiAocHJldk5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgd3JpdGFibGVTZWxmLl9fZmlyc3QgPSBub2RlS2V5VG9JbnNlcnQ7XG4gICAgICAgIHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fcHJldiA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB3cml0YWJsZVByZXZOb2RlID0gcHJldk5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVQcmV2Tm9kZS5fX25leHQgPSBub2RlS2V5VG9JbnNlcnQ7XG4gICAgICAgIHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fcHJldiA9IHdyaXRhYmxlUHJldk5vZGUuX19rZXk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlVG9JbnNlcnQuX19rZXkgPT09IHdyaXRhYmxlU2VsZktleSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYGFwcGVuZDogYXR0ZW1wdGluZyB0byBhcHBlbmQgc2VsZmApO1xuICAgICAgICB9XG4gICAgICB9IC8vIFNldCBjaGlsZCBwYXJlbnQgdG8gc2VsZlxuXG5cbiAgICAgIHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fcGFyZW50ID0gd3JpdGFibGVTZWxmS2V5O1xuICAgICAgbm9kZXNUb0luc2VydEtleXMucHVzaChub2RlS2V5VG9JbnNlcnQpO1xuICAgICAgcHJldk5vZGUgPSBub2RlVG9JbnNlcnQ7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ICsgZGVsZXRlQ291bnQgPT09IG9sZFNpemUpIHtcbiAgICAgIGlmIChwcmV2Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3cml0YWJsZVByZXZOb2RlID0gcHJldk5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVQcmV2Tm9kZS5fX25leHQgPSBudWxsO1xuICAgICAgICB3cml0YWJsZVNlbGYuX19sYXN0ID0gcHJldk5vZGUuX19rZXk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlQWZ0ZXJSYW5nZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgd3JpdGFibGVOb2RlQWZ0ZXJSYW5nZSA9IG5vZGVBZnRlclJhbmdlLmdldFdyaXRhYmxlKCk7XG5cbiAgICAgIGlmIChwcmV2Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3cml0YWJsZVByZXZOb2RlID0gcHJldk5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVOb2RlQWZ0ZXJSYW5nZS5fX3ByZXYgPSBwcmV2Tm9kZS5fX2tleTtcbiAgICAgICAgd3JpdGFibGVQcmV2Tm9kZS5fX25leHQgPSBub2RlQWZ0ZXJSYW5nZS5fX2tleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRhYmxlTm9kZUFmdGVyUmFuZ2UuX19wcmV2ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3cml0YWJsZVNlbGYuX19zaXplID0gbmV3U2l6ZTsgLy8gSW4gY2FzZSBvZiBkZWxldGlvbiB3ZSBuZWVkIHRvIGFkanVzdCBzZWxlY3Rpb24sIHVubGluayByZW1vdmVkIG5vZGVzXG4gICAgLy8gYW5kIGNsZWFuIHVwIG5vZGUgaXRzZWxmIGlmIGl0IGJlY29tZXMgZW1wdHkuIE5vbmUgb2YgdGhlc2UgbmVlZGVkXG4gICAgLy8gZm9yIGluc2VydGlvbi1vbmx5IGNhc2VzXG5cbiAgICBpZiAobm9kZXNUb1JlbW92ZUtleXMubGVuZ3RoKSB7XG4gICAgICAvLyBBZGp1c3Rpbmcgc2VsZWN0aW9uLCBpbiBjYXNlIG5vZGUgdGhhdCB3YXMgYW5jaG9yL2ZvY3VzIHdpbGwgYmUgZGVsZXRlZFxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBub2Rlc1RvUmVtb3ZlS2V5U2V0ID0gbmV3IFNldChub2Rlc1RvUmVtb3ZlS2V5cyk7XG4gICAgICAgIGNvbnN0IG5vZGVzVG9JbnNlcnRLZXlTZXQgPSBuZXcgU2V0KG5vZGVzVG9JbnNlcnRLZXlzKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBmb2N1c1xuICAgICAgICB9ID0gc2VsZWN0aW9uO1xuXG4gICAgICAgIGlmIChpc1BvaW50UmVtb3ZlZChhbmNob3IsIG5vZGVzVG9SZW1vdmVLZXlTZXQsIG5vZGVzVG9JbnNlcnRLZXlTZXQpKSB7XG4gICAgICAgICAgbW92ZVNlbGVjdGlvblBvaW50VG9TaWJsaW5nKGFuY2hvciwgYW5jaG9yLmdldE5vZGUoKSwgdGhpcywgbm9kZUJlZm9yZVJhbmdlLCBub2RlQWZ0ZXJSYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQb2ludFJlbW92ZWQoZm9jdXMsIG5vZGVzVG9SZW1vdmVLZXlTZXQsIG5vZGVzVG9JbnNlcnRLZXlTZXQpKSB7XG4gICAgICAgICAgbW92ZVNlbGVjdGlvblBvaW50VG9TaWJsaW5nKGZvY3VzLCBmb2N1cy5nZXROb2RlKCksIHRoaXMsIG5vZGVCZWZvcmVSYW5nZSwgbm9kZUFmdGVyUmFuZ2UpO1xuICAgICAgICB9IC8vIENsZWFudXAgaWYgbm9kZSBjYW4ndCBiZSBlbXB0eVxuXG5cbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDAgJiYgIXRoaXMuY2FuQmVFbXB0eSgpICYmICEkaXNSb290T3JTaGFkb3dSb290KHRoaXMpKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3cml0YWJsZVNlbGY7XG4gIH0gLy8gSlNPTiBzZXJpYWxpemF0aW9uXG5cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBkaXJlY3Rpb246IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICBmb3JtYXQ6IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpLFxuICAgICAgaW5kZW50OiB0aGlzLmdldEluZGVudCgpLFxuICAgICAgdHlwZTogJ2VsZW1lbnQnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH0gLy8gVGhlc2UgYXJlIGludGVuZGVkIHRvIGJlIGV4dGVuZHMgZm9yIHNwZWNpZmljIGVsZW1lbnQgaGV1cmlzdGljcy5cblxuXG4gIGluc2VydE5ld0FmdGVyKHNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qXG4gICAqIFRoaXMgbWV0aG9kIGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiBhIHRoZSBub2RlIGR1cmluZyBiYWNrd2FyZHNcbiAgICogZGVsZXRpb24gKGkuZS4sIGJhY2tzcGFjZSkgd2hlbiBzZWxlY3Rpb24gaXMgYXQgdGhlIGJlZ2lubmluZyBvZlxuICAgKiB0aGUgbm9kZSAob2Zmc2V0IDApXG4gICAqL1xuXG5cbiAgY29sbGFwc2VBdFN0YXJ0KHNlbGVjdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGV4Y2x1ZGVGcm9tQ29weShkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUT0RPIDAuMTAgZGVwcmVjYXRlXG5cblxuICBjYW5FeHRyYWN0Q29udGVudHMoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjYW5SZXBsYWNlV2l0aChyZXBsYWNlbWVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY2FuSW5zZXJ0QWZ0ZXIobm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNhbkluc2VydFRleHRCZWZvcmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQSBzaGFkb3cgcm9vdCBpcyBhIE5vZGUgdGhhdCBiZWhhdmVzIGxpa2UgUm9vdE5vZGUuIFRoZSBzaGFkb3cgcm9vdCAoYW5kIFJvb3ROb2RlKSBtYXJrIHRoZVxuICAvLyBlbmQgb2YgdGhlIGhpZXJjaGFyY2h5LCBtb3N0IGltcGxlbWVudGF0aW9ucyBzaG91bGQgdHJlYXQgaXQgYXMgdGhlcmUncyBub3RoaW5nICh1cHdhcmRzKVxuICAvLyBiZXlvbmQgdGhpcyBwb2ludC4gRm9yIGV4YW1wbGUsIG5vZGUuZ2V0VG9wTGV2ZWxFbGVtZW50KCksIHdoZW4gcGVyZm9ybWVkIGluc2lkZSBhIFRhYmxlQ2VsbE5vZGVcbiAgLy8gd2lsbCByZXR1cm4gdGhlIGltbWVkaWF0ZSBmaXJzdCBjaGlsZCB1bmRlcm5lYXRoIFRhYmxlQ2VsbE5vZGUgaW5zdGVhZCBvZiBSb290Tm9kZS5cblxuXG4gIGlzU2hhZG93Um9vdCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjYW5NZXJnZVdpdGgobm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbiwgZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxufVxuZnVuY3Rpb24gJGlzRWxlbWVudE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnROb2RlO1xufVxuXG5mdW5jdGlvbiBpc1BvaW50UmVtb3ZlZChwb2ludCwgbm9kZXNUb1JlbW92ZUtleVNldCwgbm9kZXNUb0luc2VydEtleVNldCkge1xuICBsZXQgbm9kZSA9IHBvaW50LmdldE5vZGUoKTtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGNvbnN0IG5vZGVLZXkgPSBub2RlLl9fa2V5O1xuXG4gICAgaWYgKG5vZGVzVG9SZW1vdmVLZXlTZXQuaGFzKG5vZGVLZXkpICYmICFub2Rlc1RvSW5zZXJ0S2V5U2V0Lmhhcyhub2RlS2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFJvb3ROb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAncm9vdCc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBSb290Tm9kZSgpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3Jvb3QnKTtcbiAgICB0aGlzLl9fY2FjaGVkVGV4dCA9IG51bGw7XG4gIH1cblxuICBnZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBnZXRUb3BMZXZlbEVsZW1lbnRPclRocm93OiByb290IG5vZGVzIGFyZSBub3QgdG9wIGxldmVsIGVsZW1lbnRzYCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgY29uc3QgY2FjaGVkVGV4dCA9IHRoaXMuX19jYWNoZWRUZXh0O1xuXG4gICAgaWYgKGlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkgfHwgZ2V0QWN0aXZlRWRpdG9yKCkuX2RpcnR5VHlwZSA9PT0gTk9fRElSVFlfTk9ERVMpIHtcbiAgICAgIGlmIChjYWNoZWRUZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRUZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5nZXRUZXh0Q29udGVudCgpO1xuICB9XG5cbiAgcmVtb3ZlKCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGByZW1vdmU6IGNhbm5vdCBiZSBjYWxsZWQgb24gcm9vdCBub2Rlc2ApO1xuICAgIH1cbiAgfVxuXG4gIHJlcGxhY2Uobm9kZSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGByZXBsYWNlOiBjYW5ub3QgYmUgY2FsbGVkIG9uIHJvb3Qgbm9kZXNgKTtcbiAgICB9XG4gIH1cblxuICBpbnNlcnRCZWZvcmUobm9kZVRvSW5zZXJ0KSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYGluc2VydEJlZm9yZTogY2Fubm90IGJlIGNhbGxlZCBvbiByb290IG5vZGVzYCk7XG4gICAgfVxuICB9XG5cbiAgaW5zZXJ0QWZ0ZXIobm9kZVRvSW5zZXJ0KSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYGluc2VydEFmdGVyOiBjYW5ub3QgYmUgY2FsbGVkIG9uIHJvb3Qgbm9kZXNgKTtcbiAgICB9XG4gIH0gLy8gVmlld1xuXG5cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gTXV0YXRlXG5cblxuICBhcHBlbmQoLi4ubm9kZXNUb0FwcGVuZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNUb0FwcGVuZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzVG9BcHBlbmRbaV07XG5cbiAgICAgIGlmICghJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgISRpc0RlY29yYXRvck5vZGUobm9kZSkpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKGByb290Tm9kZS5hcHBlbmQ6IE9ubHkgZWxlbWVudCBvciBkZWNvcmF0b3Igbm9kZXMgY2FuIGJlIGFwcGVuZGVkIHRvIHRoZSByb290IG5vZGVgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5hcHBlbmQoLi4ubm9kZXNUb0FwcGVuZCk7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIC8vIFdlIGRvbid0IGNyZWF0ZSBhIHJvb3QsIGFuZCBpbnN0ZWFkIHVzZSB0aGUgZXhpc3Rpbmcgcm9vdC5cbiAgICBjb25zdCBub2RlID0gJGdldFJvb3QoKTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5nZXREaXJlY3Rpb24oKSxcbiAgICAgIGZvcm1hdDogdGhpcy5nZXRGb3JtYXRUeXBlKCksXG4gICAgICBpbmRlbnQ6IHRoaXMuZ2V0SW5kZW50KCksXG4gICAgICB0eXBlOiAncm9vdCcsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIGNvbGxhcHNlQXRTdGFydCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG59XG5mdW5jdGlvbiAkY3JlYXRlUm9vdE5vZGUoKSB7XG4gIHJldHVybiBuZXcgUm9vdE5vZGUoKTtcbn1cbmZ1bmN0aW9uICRpc1Jvb3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBSb290Tm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gZWRpdG9yU3RhdGVIYXNEaXJ0eVNlbGVjdGlvbihlZGl0b3JTdGF0ZSwgZWRpdG9yKSB7XG4gIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb24gPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5fc2VsZWN0aW9uO1xuXG4gIGNvbnN0IHBlbmRpbmdTZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uOyAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSBiZWNhdXNlIG9mIGNoYW5nZXMgaW4gc2VsZWN0aW9uXG5cbiAgaWYgKHBlbmRpbmdTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBpZiAocGVuZGluZ1NlbGVjdGlvbi5kaXJ0eSB8fCAhcGVuZGluZ1NlbGVjdGlvbi5pcyhjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGN1cnJlbnRTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNsb25lRWRpdG9yU3RhdGUoY3VycmVudCkge1xuICByZXR1cm4gbmV3IEVkaXRvclN0YXRlKG5ldyBNYXAoY3VycmVudC5fbm9kZU1hcCkpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlFZGl0b3JTdGF0ZSgpIHtcbiAgcmV0dXJuIG5ldyBFZGl0b3JTdGF0ZShuZXcgTWFwKFtbJ3Jvb3QnLCAkY3JlYXRlUm9vdE5vZGUoKV1dKSk7XG59XG5cbmZ1bmN0aW9uIGV4cG9ydE5vZGVUb0pTT04obm9kZSkge1xuICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IG5vZGUuZXhwb3J0SlNPTigpO1xuICBjb25zdCBub2RlQ2xhc3MgPSBub2RlLmNvbnN0cnVjdG9yOyAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gUmVwbGFjZSBDbGFzcyB1dGlsaXR5IHR5cGUgd2l0aCBJbnN0YW5jZVR5cGVcblxuICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSAhPT0gbm9kZUNsYXNzLmdldFR5cGUoKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsTm9kZTogTm9kZSAke25vZGVDbGFzcy5uYW1lfSBkb2VzIG5vdCBtYXRjaCB0aGUgc2VyaWFsaXplZCB0eXBlLiBDaGVjayBpZiAuZXhwb3J0SlNPTigpIGlzIGltcGxlbWVudGVkIGFuZCBpdCBpcyByZXR1cm5pbmcgdGhlIGNvcnJlY3QgdHlwZS5gKTtcbiAgICB9XG4gIH0gLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIFJlcGxhY2UgQ2xhc3MgdXRpbGl0eSB0eXBlIHdpdGggSW5zdGFuY2VUeXBlXG5cblxuICBjb25zdCBzZXJpYWxpemVkQ2hpbGRyZW4gPSBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbjtcblxuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VyaWFsaXplZENoaWxkcmVuKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gaXMgYW4gZWxlbWVudCBidXQgLmV4cG9ydEpTT04oKSBkb2VzIG5vdCBoYXZlIGEgY2hpbGRyZW4gYXJyYXkuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY29uc3Qgc2VyaWFsaXplZENoaWxkTm9kZSA9IGV4cG9ydE5vZGVUb0pTT04oY2hpbGQpO1xuICAgICAgc2VyaWFsaXplZENoaWxkcmVuLnB1c2goc2VyaWFsaXplZENoaWxkTm9kZSk7XG4gICAgfVxuICB9IC8vIEB0cy1leHBlY3QtZXJyb3JcblxuXG4gIHJldHVybiBzZXJpYWxpemVkTm9kZTtcbn1cblxuY2xhc3MgRWRpdG9yU3RhdGUge1xuICBjb25zdHJ1Y3Rvcihub2RlTWFwLCBzZWxlY3Rpb24pIHtcbiAgICB0aGlzLl9ub2RlTWFwID0gbm9kZU1hcDtcbiAgICB0aGlzLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb24gfHwgbnVsbDtcbiAgICB0aGlzLl9mbHVzaFN5bmMgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkT25seSA9IGZhbHNlO1xuICB9XG5cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZU1hcC5zaXplID09PSAxICYmIHRoaXMuX3NlbGVjdGlvbiA9PT0gbnVsbDtcbiAgfVxuXG4gIHJlYWQoY2FsbGJhY2tGbikge1xuICAgIHJldHVybiByZWFkRWRpdG9yU3RhdGUodGhpcywgY2FsbGJhY2tGbik7XG4gIH1cblxuICBjbG9uZShzZWxlY3Rpb24pIHtcbiAgICBjb25zdCBlZGl0b3JTdGF0ZSA9IG5ldyBFZGl0b3JTdGF0ZSh0aGlzLl9ub2RlTWFwLCBzZWxlY3Rpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3NlbGVjdGlvbiA6IHNlbGVjdGlvbik7XG4gICAgZWRpdG9yU3RhdGUuX3JlYWRPbmx5ID0gdHJ1ZTtcbiAgICByZXR1cm4gZWRpdG9yU3RhdGU7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHJlYWRFZGl0b3JTdGF0ZSh0aGlzLCAoKSA9PiAoe1xuICAgICAgcm9vdDogZXhwb3J0Tm9kZVRvSlNPTigkZ2V0Um9vdCgpKVxuICAgIH0pKTtcbiAgfVxuXG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFBhcmFncmFwaE5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAncGFyYWdyYXBoJztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJhZ3JhcGhOb2RlKG5vZGUuX19rZXkpO1xuICB9IC8vIFZpZXdcblxuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KGNvbmZpZy50aGVtZSwgJ3BhcmFncmFwaCcpO1xuXG4gICAgaWYgKGNsYXNzTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZG9tQ2xhc3NMaXN0ID0gZG9tLmNsYXNzTGlzdDtcbiAgICAgIGRvbUNsYXNzTGlzdC5hZGQoLi4uY2xhc3NOYW1lcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbTtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRQYXJhZ3JhcGhFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG5cbiAgICBpZiAoZWxlbWVudCAmJiB0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgZWxlbWVudC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKSk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGZvcm1hdFR5cGUgPSB0aGlzLmdldEZvcm1hdFR5cGUoKTtcbiAgICAgIGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gZm9ybWF0VHlwZTtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCk7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgZWxlbWVudC5kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGluZGVudCA9IHRoaXMuZ2V0SW5kZW50KCk7XG5cbiAgICAgIGlmIChpbmRlbnQgPiAwKSB7XG4gICAgICAgIC8vIHBhZGRpbmctaW5saW5lLXN0YXJ0IGlzIG5vdCB3aWRlbHkgc3VwcG9ydGVkIGluIGVtYWlsIEhUTUwsIGJ1dFxuICAgICAgICAvLyBMZXhpY2FsIFJlY29uY2lsZXIgdXNlcyBwYWRkaW5nLWlubGluZS1zdGFydC4gVXNpbmcgdGV4dC1pbmRlbnQgaW5zdGVhZC5cbiAgICAgICAgZWxlbWVudC5zdHlsZS50ZXh0SW5kZW50ID0gYCR7aW5kZW50ICogMjB9cHhgO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldEluZGVudChzZXJpYWxpemVkTm9kZS5pbmRlbnQpO1xuICAgIG5vZGUuc2V0RGlyZWN0aW9uKHNlcmlhbGl6ZWROb2RlLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH0gLy8gTXV0YXRpb25cblxuXG4gIGluc2VydE5ld0FmdGVyKF8sIHJlc3RvcmVTZWxlY3Rpb24pIHtcbiAgICBjb25zdCBuZXdFbGVtZW50ID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldERpcmVjdGlvbigpO1xuICAgIG5ld0VsZW1lbnQuc2V0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgdGhpcy5pbnNlcnRBZnRlcihuZXdFbGVtZW50LCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuXG4gIGNvbGxhcHNlQXRTdGFydCgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTsgLy8gSWYgd2UgaGF2ZSBhbiBlbXB0eSAodHJpbW1lZCkgZmlyc3QgcGFyYWdyYXBoIGFuZCB0cnkgYW5kIHJlbW92ZSBpdCxcbiAgICAvLyBkZWxldGUgdGhlIHBhcmFncmFwaCBhcyBsb25nIGFzIHdlIGhhdmUgYW5vdGhlciBzaWJsaW5nIHRvIGdvIHRvXG5cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8ICRpc1RleHROb2RlKGNoaWxkcmVuWzBdKSAmJiBjaGlsZHJlblswXS5nZXRUZXh0Q29udGVudCgpLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuXG4gICAgICBpZiAobmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5zZWxlY3ROZXh0KCk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcmV2U2libGluZyA9IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICAgIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRQYXJhZ3JhcGhFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qgbm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG5cbiAgaWYgKGVsZW1lbnQuc3R5bGUpIHtcbiAgICBub2RlLnNldEZvcm1hdChlbGVtZW50LnN0eWxlLnRleHRBbGlnbik7XG4gICAgY29uc3QgaW5kZW50ID0gcGFyc2VJbnQoZWxlbWVudC5zdHlsZS50ZXh0SW5kZW50LCAxMCkgLyAyMDtcblxuICAgIGlmIChpbmRlbnQgPiAwKSB7XG4gICAgICBub2RlLnNldEluZGVudChpbmRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbm9kZVxuICB9O1xufVxuXG5mdW5jdGlvbiAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgUGFyYWdyYXBoTm9kZSgpKTtcbn1cbmZ1bmN0aW9uICRpc1BhcmFncmFwaE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFBhcmFncmFwaE5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENPTU1BTkRfUFJJT1JJVFlfRURJVE9SID0gMDtcbmNvbnN0IENPTU1BTkRfUFJJT1JJVFlfTE9XID0gMTtcbmNvbnN0IENPTU1BTkRfUFJJT1JJVFlfTk9STUFMID0gMjtcbmNvbnN0IENPTU1BTkRfUFJJT1JJVFlfSElHSCA9IDM7XG5jb25zdCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMID0gNDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuXG5mdW5jdGlvbiByZXNldEVkaXRvcihlZGl0b3IsIHByZXZSb290RWxlbWVudCwgbmV4dFJvb3RFbGVtZW50LCBwZW5kaW5nRWRpdG9yU3RhdGUpIHtcbiAgY29uc3Qga2V5Tm9kZU1hcCA9IGVkaXRvci5fa2V5VG9ET01NYXA7XG4gIGtleU5vZGVNYXAuY2xlYXIoKTtcbiAgZWRpdG9yLl9lZGl0b3JTdGF0ZSA9IGNyZWF0ZUVtcHR5RWRpdG9yU3RhdGUoKTtcbiAgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGVkaXRvci5fY29tcG9zaXRpb25LZXkgPSBudWxsO1xuICBlZGl0b3IuX2RpcnR5VHlwZSA9IE5PX0RJUlRZX05PREVTO1xuXG4gIGVkaXRvci5fY2xvbmVOb3ROZWVkZWQuY2xlYXIoKTtcblxuICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuXG4gIGVkaXRvci5fZGlydHlFbGVtZW50cy5jbGVhcigpO1xuXG4gIGVkaXRvci5fbm9ybWFsaXplZE5vZGVzID0gbmV3IFNldCgpO1xuICBlZGl0b3IuX3VwZGF0ZVRhZ3MgPSBuZXcgU2V0KCk7XG4gIGVkaXRvci5fdXBkYXRlcyA9IFtdO1xuICBlZGl0b3IuX2Jsb2NrQ3Vyc29yRWxlbWVudCA9IG51bGw7XG4gIGNvbnN0IG9ic2VydmVyID0gZWRpdG9yLl9vYnNlcnZlcjtcblxuICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgZWRpdG9yLl9vYnNlcnZlciA9IG51bGw7XG4gIH0gLy8gUmVtb3ZlIGFsbCB0aGUgRE9NIG5vZGVzIGZyb20gdGhlIHJvb3QgZWxlbWVudFxuXG5cbiAgaWYgKHByZXZSb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIHByZXZSb290RWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xuICB9XG5cbiAgaWYgKG5leHRSb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIG5leHRSb290RWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xuICAgIGtleU5vZGVNYXAuc2V0KCdyb290JywgbmV4dFJvb3RFbGVtZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplQ29udmVyc2lvbkNhY2hlKG5vZGVzKSB7XG4gIGNvbnN0IGNvbnZlcnNpb25DYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgaGFuZGxlZENvbnZlcnNpb25zID0gbmV3IFNldCgpO1xuICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgIGNvbnN0IGltcG9ydERPTSA9IG5vZGUua2xhc3MuaW1wb3J0RE9NICE9IG51bGwgPyBub2RlLmtsYXNzLmltcG9ydERPTS5iaW5kKG5vZGUua2xhc3MpIDogbnVsbDtcblxuICAgIGlmIChpbXBvcnRET00gPT0gbnVsbCB8fCBoYW5kbGVkQ29udmVyc2lvbnMuaGFzKGltcG9ydERPTSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYW5kbGVkQ29udmVyc2lvbnMuYWRkKGltcG9ydERPTSk7XG4gICAgY29uc3QgbWFwID0gaW1wb3J0RE9NKCk7XG5cbiAgICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgbGV0IGN1cnJlbnRDYWNoZSA9IGNvbnZlcnNpb25DYWNoZS5nZXQoa2V5KTtcblxuICAgICAgICBpZiAoY3VycmVudENhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdXJyZW50Q2FjaGUgPSBbXTtcbiAgICAgICAgICBjb252ZXJzaW9uQ2FjaGUuc2V0KGtleSwgY3VycmVudENhY2hlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRDYWNoZS5wdXNoKG1hcFtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb252ZXJzaW9uQ2FjaGU7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTGV4aWNhbEVkaXRvciBhdHRhY2hlZCB0byBhIHNpbmdsZSBjb250ZW50RWRpdGFibGUgKHByb3ZpZGVkIGluIHRoZSBjb25maWcpLiBUaGlzIGlzXG4gKiB0aGUgbG93ZXN0LWxldmVsIGluaXRpYWxpemF0aW9uIEFQSSBmb3IgYSBMZXhpY2FsRWRpdG9yLiBJZiB5b3UncmUgdXNpbmcgUmVhY3Qgb3IgYW5vdGhlciBmcmFtZXdvcmssXG4gKiBjb25zaWRlciB1c2luZyB0aGUgYXBwcm9wcmlhdGUgYWJzdHJhY3Rpb25zLCBzdWNoIGFzIExleGljYWxDb21wb3NlclxuICogQHBhcmFtIGVkaXRvckNvbmZpZyAtIHRoZSBlZGl0b3IgY29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm5zIGEgTGV4aWNhbEVkaXRvciBpbnN0YW5jZVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRWRpdG9yKGVkaXRvckNvbmZpZykge1xuICBjb25zdCBjb25maWcgPSBlZGl0b3JDb25maWcgfHwge307XG4gIGNvbnN0IGFjdGl2ZUVkaXRvciA9IGludGVybmFsR2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IHRoZW1lID0gY29uZmlnLnRoZW1lIHx8IHt9O1xuICBjb25zdCBwYXJlbnRFZGl0b3IgPSBlZGl0b3JDb25maWcgPT09IHVuZGVmaW5lZCA/IGFjdGl2ZUVkaXRvciA6IGNvbmZpZy5wYXJlbnRFZGl0b3IgfHwgbnVsbDtcbiAgY29uc3QgZGlzYWJsZUV2ZW50cyA9IGNvbmZpZy5kaXNhYmxlRXZlbnRzIHx8IGZhbHNlO1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGNyZWF0ZUVtcHR5RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgbmFtZXNwYWNlID0gY29uZmlnLm5hbWVzcGFjZSB8fCAocGFyZW50RWRpdG9yICE9PSBudWxsID8gcGFyZW50RWRpdG9yLl9jb25maWcubmFtZXNwYWNlIDogY3JlYXRlVUlEKCkpO1xuICBjb25zdCBpbml0aWFsRWRpdG9yU3RhdGUgPSBjb25maWcuZWRpdG9yU3RhdGU7XG4gIGNvbnN0IG5vZGVzID0gW1Jvb3ROb2RlLCBUZXh0Tm9kZSwgTGluZUJyZWFrTm9kZSwgVGFiTm9kZSwgUGFyYWdyYXBoTm9kZSwgLi4uKGNvbmZpZy5ub2RlcyB8fCBbXSldO1xuICBjb25zdCBvbkVycm9yID0gY29uZmlnLm9uRXJyb3I7XG4gIGNvbnN0IGlzRWRpdGFibGUgPSBjb25maWcuZWRpdGFibGUgIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5lZGl0YWJsZSA6IHRydWU7XG4gIGxldCByZWdpc3RlcmVkTm9kZXM7XG5cbiAgaWYgKGVkaXRvckNvbmZpZyA9PT0gdW5kZWZpbmVkICYmIGFjdGl2ZUVkaXRvciAhPT0gbnVsbCkge1xuICAgIHJlZ2lzdGVyZWROb2RlcyA9IGFjdGl2ZUVkaXRvci5fbm9kZXM7XG4gIH0gZWxzZSB7XG4gICAgcmVnaXN0ZXJlZE5vZGVzID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGtsYXNzID0gbm9kZXNbaV07XG4gICAgICBsZXQgcmVwbGFjZW1lbnRDbGFzcyA9IG51bGw7XG4gICAgICBsZXQgcmVwbGFjZW1lbnRLbGFzcyA9IG51bGw7XG5cbiAgICAgIGlmICh0eXBlb2Yga2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGtsYXNzO1xuICAgICAgICBrbGFzcyA9IG9wdGlvbnMucmVwbGFjZTtcbiAgICAgICAgcmVwbGFjZW1lbnRDbGFzcyA9IG9wdGlvbnMud2l0aDtcbiAgICAgICAgcmVwbGFjZW1lbnRLbGFzcyA9IG9wdGlvbnMud2l0aEtsYXNzID8gb3B0aW9ucy53aXRoS2xhc3MgOiBudWxsO1xuICAgICAgfSAvLyBFbnN1cmUgY3VzdG9tIG5vZGVzIGltcGxlbWVudCByZXF1aXJlZCBtZXRob2RzLlxuXG5cbiAgICAgIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGtsYXNzLm5hbWU7XG5cbiAgICAgICAgaWYgKG5hbWUgIT09ICdSb290Tm9kZScpIHtcbiAgICAgICAgICBjb25zdCBwcm90byA9IGtsYXNzLnByb3RvdHlwZTtcbiAgICAgICAgICBbJ2dldFR5cGUnLCAnY2xvbmUnXS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgICAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KG1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IG11c3QgaW1wbGVtZW50IHN0YXRpYyBcIiR7bWV0aG9kfVwiIG1ldGhvZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgICAgIWtsYXNzLmhhc093blByb3BlcnR5KCdpbXBvcnRET00nKSAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgICAga2xhc3MuaGFzT3duUHJvcGVydHkoJ2V4cG9ydERPTScpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gc2hvdWxkIGltcGxlbWVudCBcImltcG9ydERPTVwiIGlmIHVzaW5nIGEgY3VzdG9tIFwiZXhwb3J0RE9NXCIgbWV0aG9kIHRvIGVuc3VyZSBIVE1MIHNlcmlhbGl6YXRpb24gKGltcG9ydGFudCBmb3IgY29weSAmIHBhc3RlKSB3b3JrcyBhcyBleHBlY3RlZGApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcm90byBpbnN0YW5jZW9mIERlY29yYXRvck5vZGUpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAgIGlmICghcHJvdG8uaGFzT3duUHJvcGVydHkoJ2RlY29yYXRlJykpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAke3Byb3RvLmNvbnN0cnVjdG9yLm5hbWV9IG11c3QgaW1wbGVtZW50IFwiZGVjb3JhdGVcIiBtZXRob2RgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAha2xhc3MuaGFzT3duUHJvcGVydHkoJ2ltcG9ydEpTT04nKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IHNob3VsZCBpbXBsZW1lbnQgXCJpbXBvcnRKU09OXCIgbWV0aG9kIHRvIGVuc3VyZSBKU09OIGFuZCBkZWZhdWx0IEhUTUwgc2VyaWFsaXphdGlvbiB3b3JrcyBhcyBleHBlY3RlZGApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICFwcm90by5oYXNPd25Qcm9wZXJ0eSgnZXhwb3J0SlNPTicpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gc2hvdWxkIGltcGxlbWVudCBcImV4cG9ydEpTT05cIiBtZXRob2QgdG8gZW5zdXJlIEpTT04gYW5kIGRlZmF1bHQgSFRNTCBzZXJpYWxpemF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHR5cGUgPSBrbGFzcy5nZXRUeXBlKCk7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBrbGFzcy50cmFuc2Zvcm0oKTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0gIT09IG51bGwpIHtcbiAgICAgICAgdHJhbnNmb3Jtcy5hZGQodHJhbnNmb3JtKTtcbiAgICAgIH1cblxuICAgICAgcmVnaXN0ZXJlZE5vZGVzLnNldCh0eXBlLCB7XG4gICAgICAgIGtsYXNzLFxuICAgICAgICByZXBsYWNlOiByZXBsYWNlbWVudENsYXNzLFxuICAgICAgICByZXBsYWNlV2l0aEtsYXNzOiByZXBsYWNlbWVudEtsYXNzLFxuICAgICAgICB0cmFuc2Zvcm1zXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBlZGl0b3IgPSBuZXcgTGV4aWNhbEVkaXRvcihlZGl0b3JTdGF0ZSwgcGFyZW50RWRpdG9yLCByZWdpc3RlcmVkTm9kZXMsIHtcbiAgICBkaXNhYmxlRXZlbnRzLFxuICAgIG5hbWVzcGFjZSxcbiAgICB0aGVtZVxuICB9LCBvbkVycm9yID8gb25FcnJvciA6IGNvbnNvbGUuZXJyb3IsIGluaXRpYWxpemVDb252ZXJzaW9uQ2FjaGUocmVnaXN0ZXJlZE5vZGVzKSwgaXNFZGl0YWJsZSk7XG5cbiAgaWYgKGluaXRpYWxFZGl0b3JTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBpbml0aWFsRWRpdG9yU3RhdGU7XG4gICAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgfVxuXG4gIHJldHVybiBlZGl0b3I7XG59XG5jbGFzcyBMZXhpY2FsRWRpdG9yIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKGVkaXRvclN0YXRlLCBwYXJlbnRFZGl0b3IsIG5vZGVzLCBjb25maWcsIG9uRXJyb3IsIGh0bWxDb252ZXJzaW9ucywgZWRpdGFibGUpIHtcbiAgICB0aGlzLl9wYXJlbnRFZGl0b3IgPSBwYXJlbnRFZGl0b3I7IC8vIFRoZSByb290IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZWRpdG9yXG5cbiAgICB0aGlzLl9yb290RWxlbWVudCA9IG51bGw7IC8vIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZVxuXG4gICAgdGhpcy5fZWRpdG9yU3RhdGUgPSBlZGl0b3JTdGF0ZTsgLy8gSGFuZGxpbmcgb2YgZHJhZnRzIGFuZCB1cGRhdGVzXG5cbiAgICB0aGlzLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBudWxsOyAvLyBVc2VkIHRvIGhlbHAgY28tb3JkaW5hdGUgc2VsZWN0aW9uIGFuZCBldmVudHNcblxuICAgIHRoaXMuX2NvbXBvc2l0aW9uS2V5ID0gbnVsbDtcbiAgICB0aGlzLl9kZWZlcnJlZCA9IFtdOyAvLyBVc2VkIGR1cmluZyByZWNvbmNpbGlhdGlvblxuXG4gICAgdGhpcy5fa2V5VG9ET01NYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fdXBkYXRlcyA9IFtdO1xuICAgIHRoaXMuX3VwZGF0aW5nID0gZmFsc2U7IC8vIExpc3RlbmVyc1xuXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge1xuICAgICAgZGVjb3JhdG9yOiBuZXcgU2V0KCksXG4gICAgICBlZGl0YWJsZTogbmV3IFNldCgpLFxuICAgICAgbXV0YXRpb246IG5ldyBNYXAoKSxcbiAgICAgIHJvb3Q6IG5ldyBTZXQoKSxcbiAgICAgIHRleHRjb250ZW50OiBuZXcgU2V0KCksXG4gICAgICB1cGRhdGU6IG5ldyBTZXQoKVxuICAgIH07IC8vIENvbW1hbmRzXG5cbiAgICB0aGlzLl9jb21tYW5kcyA9IG5ldyBNYXAoKTsgLy8gRWRpdG9yIGNvbmZpZ3VyYXRpb24gZm9yIHRoZW1lL2NvbnRleHQuXG5cbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7IC8vIE1hcHBpbmcgb2YgdHlwZXMgdG8gdGhlaXIgbm9kZXNcblxuICAgIHRoaXMuX25vZGVzID0gbm9kZXM7IC8vIFJlYWN0IG5vZGUgZGVjb3JhdG9ycyBmb3IgcG9ydGFsc1xuXG4gICAgdGhpcy5fZGVjb3JhdG9ycyA9IHt9O1xuICAgIHRoaXMuX3BlbmRpbmdEZWNvcmF0b3JzID0gbnVsbDsgLy8gVXNlZCB0byBvcHRpbWl6ZSByZWNvbmNpbGlhdGlvblxuXG4gICAgdGhpcy5fZGlydHlUeXBlID0gTk9fRElSVFlfTk9ERVM7XG4gICAgdGhpcy5fY2xvbmVOb3ROZWVkZWQgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fZGlydHlMZWF2ZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fZGlydHlFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ub3JtYWxpemVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fdXBkYXRlVGFncyA9IG5ldyBTZXQoKTsgLy8gSGFuZGxpbmcgb2YgRE9NIG11dGF0aW9uc1xuXG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsOyAvLyBVc2VkIGZvciBpZGVudGlmeWluZyBvd25pbmcgZWRpdG9yc1xuXG4gICAgdGhpcy5fa2V5ID0gY3JlYXRlVUlEKCk7XG4gICAgdGhpcy5fb25FcnJvciA9IG9uRXJyb3I7XG4gICAgdGhpcy5faHRtbENvbnZlcnNpb25zID0gaHRtbENvbnZlcnNpb25zO1xuICAgIHRoaXMuX2VkaXRhYmxlID0gZWRpdGFibGU7XG4gICAgdGhpcy5faGVhZGxlc3MgPSBwYXJlbnRFZGl0b3IgIT09IG51bGwgJiYgcGFyZW50RWRpdG9yLl9oZWFkbGVzcztcbiAgICB0aGlzLl93aW5kb3cgPSBudWxsO1xuICAgIHRoaXMuX2Jsb2NrQ3Vyc29yRWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGVkaXRvciBpcyBjdXJyZW50bHkgaW4gXCJjb21wb3NpdGlvblwiIG1vZGUgZHVlIHRvIHJlY2VpdmluZyBpbnB1dFxuICAgKiB0aHJvdWdoIGFuIElNRSwgb3IgM1AgZXh0ZW5zaW9uLCBmb3IgZXhhbXBsZS4gUmV0dXJucyBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgaXNDb21wb3NpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvc2l0aW9uS2V5ICE9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciBFZGl0b3IgdXBkYXRlIGV2ZW50LiBXaWxsIHRyaWdnZXIgdGhlIHByb3ZpZGVkIGNhbGxiYWNrXG4gICAqIGVhY2ggdGltZSB0aGUgZWRpdG9yIGdvZXMgdGhyb3VnaCBhbiB1cGRhdGUgKHZpYSB7QGxpbmsgTGV4aWNhbEVkaXRvci51cGRhdGV9KSB1bnRpbCB0aGVcbiAgICogdGVhcmRvd24gZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuXG5cbiAgcmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVyU2V0T3JNYXAgPSB0aGlzLl9saXN0ZW5lcnMudXBkYXRlO1xuICAgIGxpc3RlbmVyU2V0T3JNYXAuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJTZXRPck1hcC5kZWxldGUobGlzdGVuZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciBmb3Igd2hlbiB0aGUgZWRpdG9yIGNoYW5nZXMgYmV0d2VlbiBlZGl0YWJsZSBhbmQgbm9uLWVkaXRhYmxlIHN0YXRlcy5cbiAgICogV2lsbCB0cmlnZ2VyIHRoZSBwcm92aWRlZCBjYWxsYmFjayBlYWNoIHRpbWUgdGhlIGVkaXRvciB0cmFuc2l0aW9ucyBiZXR3ZWVuIHRoZXNlIHN0YXRlcyB1bnRpbCB0aGVcbiAgICogdGVhcmRvd24gZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuXG5cbiAgcmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJTZXRPck1hcCA9IHRoaXMuX2xpc3RlbmVycy5lZGl0YWJsZTtcbiAgICBsaXN0ZW5lclNldE9yTWFwLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVyU2V0T3JNYXAuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciBmb3Igd2hlbiB0aGUgZWRpdG9yJ3MgZGVjb3JhdG9yIG9iamVjdCBjaGFuZ2VzLiBUaGUgZGVjb3JhdG9yIG9iamVjdCBjb250YWluc1xuICAgKiBhbGwgRGVjb3JhdG9yTm9kZSBrZXlzIC0+IHRoZWlyIGRlY29yYXRlZCB2YWx1ZS4gVGhpcyBpcyBwcmltYXJpbHkgdXNlZCB3aXRoIGV4dGVybmFsIFVJIGZyYW1ld29ya3MuXG4gICAqXG4gICAqIFdpbGwgdHJpZ2dlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZWFjaCB0aW1lIHRoZSBlZGl0b3IgdHJhbnNpdGlvbnMgYmV0d2VlbiB0aGVzZSBzdGF0ZXMgdW50aWwgdGhlXG4gICAqIHRlYXJkb3duIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cblxuXG4gIHJlZ2lzdGVyRGVjb3JhdG9yTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lclNldE9yTWFwID0gdGhpcy5fbGlzdGVuZXJzLmRlY29yYXRvcjtcbiAgICBsaXN0ZW5lclNldE9yTWFwLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVyU2V0T3JNYXAuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciBmb3Igd2hlbiBMZXhpY2FsIGNvbW1pdHMgYW4gdXBkYXRlIHRvIHRoZSBET00gYW5kIHRoZSB0ZXh0IGNvbnRlbnQgb2ZcbiAgICogdGhlIGVkaXRvciBjaGFuZ2VzIGZyb20gdGhlIHByZXZpb3VzIHN0YXRlIG9mIHRoZSBlZGl0b3IuIElmIHRoZSB0ZXh0IGNvbnRlbnQgaXMgdGhlXG4gICAqIHNhbWUgYmV0d2VlbiB1cGRhdGVzLCBubyBub3RpZmljYXRpb25zIHRvIHRoZSBsaXN0ZW5lcnMgd2lsbCBoYXBwZW4uXG4gICAqXG4gICAqIFdpbGwgdHJpZ2dlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZWFjaCB0aW1lIHRoZSBlZGl0b3IgdHJhbnNpdGlvbnMgYmV0d2VlbiB0aGVzZSBzdGF0ZXMgdW50aWwgdGhlXG4gICAqIHRlYXJkb3duIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cblxuXG4gIHJlZ2lzdGVyVGV4dENvbnRlbnRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVyU2V0T3JNYXAgPSB0aGlzLl9saXN0ZW5lcnMudGV4dGNvbnRlbnQ7XG4gICAgbGlzdGVuZXJTZXRPck1hcC5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lclNldE9yTWFwLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgZm9yIHdoZW4gdGhlIGVkaXRvcidzIHJvb3QgRE9NIGVsZW1lbnQgKHRoZSBjb250ZW50IGVkaXRhYmxlXG4gICAqIExleGljYWwgYXR0YWNoZXMgdG8pIGNoYW5nZXMuIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gYXR0YWNoIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgcm9vdFxuICAgKiAgZWxlbWVudC4gVGhlIHJvb3QgbGlzdGVuZXIgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgZGlyZWN0bHkgdXBvbiByZWdpc3RyYXRpb24gYW5kIHRoZW4gb25cbiAgICogYW55IHN1YnNlcXVlbnQgdXBkYXRlLlxuICAgKlxuICAgKiBXaWxsIHRyaWdnZXIgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGVhY2ggdGltZSB0aGUgZWRpdG9yIHRyYW5zaXRpb25zIGJldHdlZW4gdGhlc2Ugc3RhdGVzIHVudGlsIHRoZVxuICAgKiB0ZWFyZG93biBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVhcmRvd24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhbnVwIHRoZSBsaXN0ZW5lci5cbiAgICovXG5cblxuICByZWdpc3RlclJvb3RMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVyU2V0T3JNYXAgPSB0aGlzLl9saXN0ZW5lcnMucm9vdDtcbiAgICBsaXN0ZW5lcih0aGlzLl9yb290RWxlbWVudCwgbnVsbCk7XG4gICAgbGlzdGVuZXJTZXRPck1hcC5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lcihudWxsLCB0aGlzLl9yb290RWxlbWVudCk7XG4gICAgICBsaXN0ZW5lclNldE9yTWFwLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIHRyaWdnZXIgYW55dGltZSB0aGUgcHJvdmlkZWQgY29tbWFuZFxuICAgKiBpcyBkaXNwYXRjaGVkLCBzdWJqZWN0IHRvIHByaW9yaXR5LiBMaXN0ZW5lcnMgdGhhdCBydW4gYXQgYSBoaWdoZXIgcHJpb3JpdHkgY2FuIFwiaW50ZXJjZXB0XCJcbiAgICogY29tbWFuZHMgYW5kIHByZXZlbnQgdGhlbSBmcm9tIHByb3BhZ2F0aW5nIHRvIG90aGVyIGhhbmRsZXJzIGJ5IHJldHVybmluZyB0cnVlLlxuICAgKlxuICAgKiBMaXN0ZW5lcnMgcmVnaXN0ZXJlZCBhdCB0aGUgc2FtZSBwcmlvcml0eSBsZXZlbCB3aWxsIHJ1biBkZXRlcm1pbmlzdGljYWxseSBpbiB0aGUgb3JkZXIgb2YgcmVnaXN0cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gY29tbWFuZCAtIHRoZSBjb21tYW5kIHRoYXQgd2lsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gdGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBleGVjdXRlIHdoZW4gdGhlIGNvbW1hbmQgaXMgZGlzcGF0Y2hlZC5cbiAgICogQHBhcmFtIHByaW9yaXR5IC0gdGhlIHJlbGF0aXZlIHByaW9yaXR5IG9mIHRoZSBsaXN0ZW5lci4gMCB8IDEgfCAyIHwgMyB8IDRcbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cblxuXG4gIHJlZ2lzdGVyQ29tbWFuZChjb21tYW5kLCBsaXN0ZW5lciwgcHJpb3JpdHkpIHtcbiAgICBpZiAocHJpb3JpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTGlzdGVuZXIgZm9yIHR5cGUgXCJjb21tYW5kXCIgcmVxdWlyZXMgYSBcInByaW9yaXR5XCIuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY29tbWFuZHNNYXAgPSB0aGlzLl9jb21tYW5kcztcblxuICAgIGlmICghY29tbWFuZHNNYXAuaGFzKGNvbW1hbmQpKSB7XG4gICAgICBjb21tYW5kc01hcC5zZXQoY29tbWFuZCwgW25ldyBTZXQoKSwgbmV3IFNldCgpLCBuZXcgU2V0KCksIG5ldyBTZXQoKSwgbmV3IFNldCgpXSk7XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdGVuZXJzSW5Qcmlvcml0eU9yZGVyID0gY29tbWFuZHNNYXAuZ2V0KGNvbW1hbmQpO1xuXG4gICAgaWYgKGxpc3RlbmVyc0luUHJpb3JpdHlPcmRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGByZWdpc3RlckNvbW1hbmQ6IENvbW1hbmQgJHtTdHJpbmcoY29tbWFuZCl9IG5vdCBmb3VuZCBpbiBjb21tYW5kIG1hcGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxpc3RlbmVycyA9IGxpc3RlbmVyc0luUHJpb3JpdHlPcmRlcltwcmlvcml0eV07XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuXG4gICAgICBpZiAobGlzdGVuZXJzSW5Qcmlvcml0eU9yZGVyLmV2ZXJ5KGxpc3RlbmVyc1NldCA9PiBsaXN0ZW5lcnNTZXQuc2l6ZSA9PT0gMCkpIHtcbiAgICAgICAgY29tbWFuZHNNYXAuZGVsZXRlKGNvbW1hbmQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBydW4gd2hlbiBhIExleGljYWwgbm9kZSBvZiB0aGUgcHJvdmlkZWQgY2xhc3MgaXNcbiAgICogbXV0YXRlZC4gVGhlIGxpc3RlbmVyIHdpbGwgcmVjZWl2ZSBhIGxpc3Qgb2Ygbm9kZXMgYWxvbmcgd2l0aCB0aGUgdHlwZSBvZiBtdXRhdGlvblxuICAgKiB0aGF0IHdhcyBwZXJmb3JtZWQgb24gZWFjaDogY3JlYXRlZCwgZGVzdHJveWVkLCBvciB1cGRhdGVkLlxuICAgKlxuICAgKiBPbmUgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRvIGF0dGFjaCBET00gZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSB1bmRlcmx5aW5nIERPTSBub2RlcyBhcyBMZXhpY2FsIG5vZGVzIGFyZSBjcmVhdGVkLlxuICAgKiB7QGxpbmsgTGV4aWNhbEVkaXRvci5nZXRFbGVtZW50QnlLZXl9IGNhbiBiZSB1c2VkIGZvciB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ga2xhc3MgLSBUaGUgY2xhc3Mgb2YgdGhlIG5vZGUgdGhhdCB5b3Ugd2FudCB0byBsaXN0ZW4gdG8gbXV0YXRpb25zIG9uLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgbG9naWMgeW91IHdhbnQgdG8gcnVuIHdoZW4gdGhlIG5vZGUgaXMgbXV0YXRlZC5cbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cblxuXG4gIHJlZ2lzdGVyTXV0YXRpb25MaXN0ZW5lcihrbGFzcywgbGlzdGVuZXIpIHtcbiAgICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IHRoaXMuX25vZGVzLmdldChrbGFzcy5nZXRUeXBlKCkpO1xuXG4gICAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYE5vZGUgJHtrbGFzcy5uYW1lfSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC4gRW5zdXJlIG5vZGUgaGFzIGJlZW4gcGFzc2VkIHRvIGNyZWF0ZUVkaXRvci5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtdXRhdGlvbnMgPSB0aGlzLl9saXN0ZW5lcnMubXV0YXRpb247XG4gICAgbXV0YXRpb25zLnNldChsaXN0ZW5lciwga2xhc3MpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBtdXRhdGlvbnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuXG4gIHJlZ2lzdGVyTm9kZVRyYW5zZm9ybVRvS2xhc3Moa2xhc3MsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgdHlwZSA9IGtsYXNzLmdldFR5cGUoKTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gdGhpcy5fbm9kZXMuZ2V0KHR5cGUpO1xuXG4gICAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYE5vZGUgJHtrbGFzcy5uYW1lfSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC4gRW5zdXJlIG5vZGUgaGFzIGJlZW4gcGFzc2VkIHRvIGNyZWF0ZUVkaXRvci5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2Zvcm1zID0gcmVnaXN0ZXJlZE5vZGUudHJhbnNmb3JtcztcbiAgICB0cmFuc2Zvcm1zLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIHJlZ2lzdGVyZWROb2RlO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgcnVuIHdoZW4gYSBMZXhpY2FsIG5vZGUgb2YgdGhlIHByb3ZpZGVkIGNsYXNzIGlzXG4gICAqIG1hcmtlZCBkaXJ0eSBkdXJpbmcgYW4gdXBkYXRlLiBUaGUgbGlzdGVuZXIgd2lsbCBjb250aW51ZSB0byBydW4gYXMgbG9uZyBhcyB0aGUgbm9kZVxuICAgKiBpcyBtYXJrZWQgZGlydHkuIFRoZXJlIGFyZSBubyBndWFyYW50ZWVzIGFyb3VuZCB0aGUgb3JkZXIgb2YgdHJhbnNmb3JtIGV4ZWN1dGlvbiFcbiAgICpcbiAgICogV2F0Y2ggb3V0IGZvciBpbmZpbml0ZSBsb29wcy4gU2VlIFtOb2RlIFRyYW5zZm9ybXNdKGh0dHBzOi8vbGV4aWNhbC5kZXYvZG9jcy9jb25jZXB0cy90cmFuc2Zvcm1zKVxuICAgKiBAcGFyYW0ga2xhc3MgLSBUaGUgY2xhc3Mgb2YgdGhlIG5vZGUgdGhhdCB5b3Ugd2FudCB0byBydW4gdHJhbnNmb3JtcyBvbi5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGxvZ2ljIHlvdSB3YW50IHRvIHJ1biB3aGVuIHRoZSBub2RlIGlzIHVwZGF0ZWQuXG4gICAqIEByZXR1cm5zIGEgdGVhcmRvd24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhbnVwIHRoZSBsaXN0ZW5lci5cbiAgICovXG5cblxuICByZWdpc3Rlck5vZGVUcmFuc2Zvcm0oa2xhc3MsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSB0aGlzLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybVRvS2xhc3Moa2xhc3MsIGxpc3RlbmVyKTtcbiAgICBjb25zdCByZWdpc3RlcmVkTm9kZXMgPSBbcmVnaXN0ZXJlZE5vZGVdO1xuICAgIGNvbnN0IHJlcGxhY2VXaXRoS2xhc3MgPSByZWdpc3RlcmVkTm9kZS5yZXBsYWNlV2l0aEtsYXNzO1xuXG4gICAgaWYgKHJlcGxhY2VXaXRoS2xhc3MgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcmVnaXN0ZXJlZFJlcGxhY2VXaXRoTm9kZSA9IHRoaXMucmVnaXN0ZXJOb2RlVHJhbnNmb3JtVG9LbGFzcyhyZXBsYWNlV2l0aEtsYXNzLCBsaXN0ZW5lcik7XG4gICAgICByZWdpc3RlcmVkTm9kZXMucHVzaChyZWdpc3RlcmVkUmVwbGFjZVdpdGhOb2RlKTtcbiAgICB9XG5cbiAgICBtYXJrQWxsTm9kZXNBc0RpcnR5KHRoaXMsIGtsYXNzLmdldFR5cGUoKSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlZ2lzdGVyZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4gbm9kZS50cmFuc2Zvcm1zLmRlbGV0ZShsaXN0ZW5lcikpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgdG8gYXNzZXJ0IHRoYXQgYSBjZXJ0YWluIG5vZGUgaXMgcmVnaXN0ZXJlZCwgdXN1YWxseSBieSBwbHVnaW5zIHRvIGVuc3VyZSBub2RlcyB0aGF0IHRoZXlcbiAgICogZGVwZW5kIG9uIGhhdmUgYmVlbiByZWdpc3RlcmVkLlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBlZGl0b3IgaGFzIHJlZ2lzdGVyZWQgdGhlIHByb3ZpZGVkIG5vZGUgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cblxuXG4gIGhhc05vZGUobm9kZSkge1xuICAgIHJldHVybiB0aGlzLl9ub2Rlcy5oYXMobm9kZS5nZXRUeXBlKCkpO1xuICB9XG4gIC8qKlxuICAgKiBVc2VkIHRvIGFzc2VydCB0aGF0IGNlcnRhaW4gbm9kZXMgYXJlIHJlZ2lzdGVyZWQsIHVzdWFsbHkgYnkgcGx1Z2lucyB0byBlbnN1cmUgbm9kZXMgdGhhdCB0aGV5XG4gICAqIGRlcGVuZCBvbiBoYXZlIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZWRpdG9yIGhhcyByZWdpc3RlcmVkIGFsbCBvZiB0aGUgcHJvdmlkZWQgbm9kZSB0eXBlcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cblxuXG4gIGhhc05vZGVzKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLmV2ZXJ5KHRoaXMuaGFzTm9kZS5iaW5kKHRoaXMpKTtcbiAgfVxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIGNvbW1hbmQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIHdpdGggdGhlIHNwZWNpZmllZCBwYXlsb2FkLlxuICAgKiBUaGlzIHRyaWdnZXJzIGFsbCBjb21tYW5kIGxpc3RlbmVycyAoc2V0IGJ5IHtAbGluayBMZXhpY2FsRWRpdG9yLnJlZ2lzdGVyQ29tbWFuZH0pXG4gICAqIGZvciB0aGlzIHR5cGUsIHBhc3NpbmcgdGhlbSB0aGUgcHJvdmlkZWQgcGF5bG9hZC5cbiAgICogQHBhcmFtIHR5cGUgLSB0aGUgdHlwZSBvZiBjb21tYW5kIGxpc3RlbmVycyB0byB0cmlnZ2VyLlxuICAgKiBAcGFyYW0gcGF5bG9hZCAtIHRoZSBkYXRhIHRvIHBhc3MgYXMgYW4gYXJndW1lbnQgdG8gdGhlIGNvbW1hbmQgbGlzdGVuZXJzLlxuICAgKi9cblxuXG4gIGRpc3BhdGNoQ29tbWFuZCh0eXBlLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoQ29tbWFuZCh0aGlzLCB0eXBlLCBwYXlsb2FkKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBhIG1hcCBvZiBhbGwgZGVjb3JhdG9ycyBpbiB0aGUgZWRpdG9yLlxuICAgKiBAcmV0dXJucyBBIG1hcHBpbmcgb2YgY2FsbCBkZWNvcmF0b3Iga2V5cyB0byB0aGVpciBkZWNvcmF0ZWQgY29udGVudFxuICAgKi9cblxuXG4gIGdldERlY29yYXRvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlY29yYXRvcnM7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjdXJyZW50IHJvb3QgZWxlbWVudCBvZiB0aGUgZWRpdG9yLiBJZiB5b3Ugd2FudCB0byByZWdpc3RlclxuICAgKiBhbiBldmVudCBsaXN0ZW5lciwgZG8gaXQgdmlhIHtAbGluayBMZXhpY2FsRWRpdG9yLnJlZ2lzdGVyUm9vdExpc3RlbmVyfSwgc2luY2VcbiAgICogdGhpcyByZWZlcmVuY2UgbWF5IG5vdCBiZSBzdGFibGUuXG4gICAqL1xuXG5cbiAgZ2V0Um9vdEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3RFbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBrZXkgb2YgdGhlIGVkaXRvclxuICAgKiBAcmV0dXJucyBUaGUgZWRpdG9yIGtleVxuICAgKi9cblxuXG4gIGdldEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5O1xuICB9XG4gIC8qKlxuICAgKiBJbXBlcmF0aXZlbHkgc2V0IHRoZSByb290IGNvbnRlbnRlZGl0YWJsZSBlbGVtZW50IHRoYXQgTGV4aWNhbCBsaXN0ZW5zXG4gICAqIGZvciBldmVudHMgb24uXG4gICAqL1xuXG5cbiAgc2V0Um9vdEVsZW1lbnQobmV4dFJvb3RFbGVtZW50KSB7XG4gICAgY29uc3QgcHJldlJvb3RFbGVtZW50ID0gdGhpcy5fcm9vdEVsZW1lbnQ7XG5cbiAgICBpZiAobmV4dFJvb3RFbGVtZW50ICE9PSBwcmV2Um9vdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBnZXRDYWNoZWRDbGFzc05hbWVBcnJheSh0aGlzLl9jb25maWcudGhlbWUsICdyb290Jyk7XG4gICAgICBjb25zdCBwZW5kaW5nRWRpdG9yU3RhdGUgPSB0aGlzLl9wZW5kaW5nRWRpdG9yU3RhdGUgfHwgdGhpcy5fZWRpdG9yU3RhdGU7XG4gICAgICB0aGlzLl9yb290RWxlbWVudCA9IG5leHRSb290RWxlbWVudDtcbiAgICAgIHJlc2V0RWRpdG9yKHRoaXMsIHByZXZSb290RWxlbWVudCwgbmV4dFJvb3RFbGVtZW50LCBwZW5kaW5nRWRpdG9yU3RhdGUpO1xuXG4gICAgICBpZiAocHJldlJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSB0aGlzIGZsYWcgb25jZSB3ZSBubyBsb25nZXIgdXNlIFVFdjIgaW50ZXJuYWxseVxuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5kaXNhYmxlRXZlbnRzKSB7XG4gICAgICAgICAgcmVtb3ZlUm9vdEVsZW1lbnRFdmVudHMocHJldlJvb3RFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbGFzc05hbWVzICE9IG51bGwpIHtcbiAgICAgICAgICBwcmV2Um9vdEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc05hbWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV4dFJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdpbmRvd09iaiA9IGdldERlZmF1bHRWaWV3KG5leHRSb290RWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gbmV4dFJvb3RFbGVtZW50LnN0eWxlO1xuICAgICAgICBzdHlsZS51c2VyU2VsZWN0ID0gJ3RleHQnO1xuICAgICAgICBzdHlsZS53aGl0ZVNwYWNlID0gJ3ByZS13cmFwJztcbiAgICAgICAgc3R5bGUud29yZEJyZWFrID0gJ2JyZWFrLXdvcmQnO1xuICAgICAgICBuZXh0Um9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtZWRpdG9yJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5fd2luZG93ID0gd2luZG93T2JqO1xuICAgICAgICB0aGlzLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgICAgICAgaW5pdE11dGF0aW9uT2JzZXJ2ZXIodGhpcyk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlVGFncy5hZGQoJ2hpc3RvcnktbWVyZ2UnKTtcblxuICAgICAgICBjb21taXRQZW5kaW5nVXBkYXRlcyh0aGlzKTsgLy8gVE9ETzogcmVtb3ZlIHRoaXMgZmxhZyBvbmNlIHdlIG5vIGxvbmdlciB1c2UgVUV2MiBpbnRlcm5hbGx5XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcuZGlzYWJsZUV2ZW50cykge1xuICAgICAgICAgIGFkZFJvb3RFbGVtZW50RXZlbnRzKG5leHRSb290RWxlbWVudCwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xhc3NOYW1lcyAhPSBudWxsKSB7XG4gICAgICAgICAgbmV4dFJvb3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoLi4uY2xhc3NOYW1lcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGNvbnRlbnQgZWRpdGFibGUgaXMgdW5tb3VudGVkIHdlJ2xsIHJlc2V0IGVkaXRvciBzdGF0ZSBiYWNrIHRvIG9yaWdpbmFsXG4gICAgICAgIC8vIChvciBwZW5kaW5nKSBlZGl0b3Igc3RhdGUgc2luY2UgdGhlcmUgd2lsbCBiZSBubyByZWNvbmNpbGlhdGlvblxuICAgICAgICB0aGlzLl9lZGl0b3JTdGF0ZSA9IHBlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0VkaXRvclN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd2luZG93ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlckxpc3RlbmVycygncm9vdCcsIHRoaXMsIGZhbHNlLCBuZXh0Um9vdEVsZW1lbnQsIHByZXZSb290RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB1bmRlcmx5aW5nIEhUTUxFbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgTGV4aWNhbE5vZGUgZm9yIHRoZSBnaXZlbiBrZXkuXG4gICAqIEByZXR1cm5zIHRoZSBIVE1MRWxlbWVudCByZW5kZXJlZCBieSB0aGUgTGV4aWNhbE5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkuXG4gICAqIEBwYXJhbSBrZXkgLSB0aGUga2V5IG9mIHRoZSBMZXhpY2FsTm9kZS5cbiAgICovXG5cblxuICBnZXRFbGVtZW50QnlLZXkoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleVRvRE9NTWFwLmdldChrZXkpIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGFjdGl2ZSBlZGl0b3Igc3RhdGUuXG4gICAqIEByZXR1cm5zIFRoZSBlZGl0b3Igc3RhdGVcbiAgICovXG5cblxuICBnZXRFZGl0b3JTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWRpdG9yU3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEltcGVyYXRpdmVseSBzZXQgdGhlIEVkaXRvclN0YXRlLiBUcmlnZ2VycyByZWNvbmNpbGlhdGlvbiBsaWtlIGFuIHVwZGF0ZS5cbiAgICogQHBhcmFtIGVkaXRvclN0YXRlIC0gdGhlIHN0YXRlIHRvIHNldCB0aGUgZWRpdG9yXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgdGhlIHVwZGF0ZS5cbiAgICovXG5cblxuICBzZXRFZGl0b3JTdGF0ZShlZGl0b3JTdGF0ZSwgb3B0aW9ucykge1xuICAgIGlmIChlZGl0b3JTdGF0ZS5pc0VtcHR5KCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYHNldEVkaXRvclN0YXRlOiB0aGUgZWRpdG9yIHN0YXRlIGlzIGVtcHR5LiBFbnN1cmUgdGhlIGVkaXRvciBzdGF0ZSdzIHJvb3Qgbm9kZSBuZXZlciBiZWNvbWVzIGVtcHR5LmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoUm9vdE11dGF0aW9ucyh0aGlzKTtcbiAgICBjb25zdCBwZW5kaW5nRWRpdG9yU3RhdGUgPSB0aGlzLl9wZW5kaW5nRWRpdG9yU3RhdGU7XG4gICAgY29uc3QgdGFncyA9IHRoaXMuX3VwZGF0ZVRhZ3M7XG4gICAgY29uc3QgdGFnID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50YWcgOiBudWxsO1xuXG4gICAgaWYgKHBlbmRpbmdFZGl0b3JTdGF0ZSAhPT0gbnVsbCAmJiAhcGVuZGluZ0VkaXRvclN0YXRlLmlzRW1wdHkoKSkge1xuICAgICAgaWYgKHRhZyAhPSBudWxsKSB7XG4gICAgICAgIHRhZ3MuYWRkKHRhZyk7XG4gICAgICB9XG5cbiAgICAgIGNvbW1pdFBlbmRpbmdVcGRhdGVzKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IGVkaXRvclN0YXRlO1xuICAgIHRoaXMuX2RpcnR5VHlwZSA9IEZVTExfUkVDT05DSUxFO1xuXG4gICAgdGhpcy5fZGlydHlFbGVtZW50cy5zZXQoJ3Jvb3QnLCBmYWxzZSk7XG5cbiAgICB0aGlzLl9jb21wb3NpdGlvbktleSA9IG51bGw7XG5cbiAgICBpZiAodGFnICE9IG51bGwpIHtcbiAgICAgIHRhZ3MuYWRkKHRhZyk7XG4gICAgfVxuXG4gICAgY29tbWl0UGVuZGluZ1VwZGF0ZXModGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlcyBhIFNlcmlhbGl6ZWRFZGl0b3JTdGF0ZSAodXN1YWxseSBwcm9kdWNlZCBieSB7QGxpbmsgRWRpdG9yU3RhdGUudG9KU09OfSkgYW5kIHJldHVybnNcbiAgICogYW5kIEVkaXRvclN0YXRlIG9iamVjdCB0aGF0IGNhbiBiZSwgZm9yIGV4YW1wbGUsIHBhc3NlZCB0byB7QGxpbmsgTGV4aWNhbEVkaXRvci5zZXRFZGl0b3JTdGF0ZX0uIFR5cGljYWxseSxcbiAgICogZGVzZXJsaWF6YXRpb24gZnJvbSBKU09OIHN0b3JlZCBpbiBhIGRhdGFiYXNlIHVzZXMgdGhpcyBtZXRob2QuXG4gICAqIEBwYXJhbSBtYXliZVN0cmluZ2lmaWVkRWRpdG9yU3RhdGVcbiAgICogQHBhcmFtIHVwZGF0ZUZuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuXG5cbiAgcGFyc2VFZGl0b3JTdGF0ZShtYXliZVN0cmluZ2lmaWVkRWRpdG9yU3RhdGUsIHVwZGF0ZUZuKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZEVkaXRvclN0YXRlID0gdHlwZW9mIG1heWJlU3RyaW5naWZpZWRFZGl0b3JTdGF0ZSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKG1heWJlU3RyaW5naWZpZWRFZGl0b3JTdGF0ZSkgOiBtYXliZVN0cmluZ2lmaWVkRWRpdG9yU3RhdGU7XG4gICAgcmV0dXJuIHBhcnNlRWRpdG9yU3RhdGUoc2VyaWFsaXplZEVkaXRvclN0YXRlLCB0aGlzLCB1cGRhdGVGbik7XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGFuIHVwZGF0ZSB0byB0aGUgZWRpdG9yIHN0YXRlLiBUaGUgdXBkYXRlRm4gY2FsbGJhY2sgaXMgdGhlIE9OTFkgcGxhY2VcbiAgICogd2hlcmUgTGV4aWNhbCBlZGl0b3Igc3RhdGUgY2FuIGJlIHNhZmVseSBtdXRhdGVkLlxuICAgKiBAcGFyYW0gdXBkYXRlRm4gLSBBIGZ1bmN0aW9uIHRoYXQgaGFzIGFjY2VzcyB0byB3cml0YWJsZSBlZGl0b3Igc3RhdGUuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQSBiYWcgb2Ygb3B0aW9ucyB0byBjb250cm9sIHRoZSBiZWhhdmlvciBvZiB0aGUgdXBkYXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5vblVwZGF0ZSAtIEEgZnVuY3Rpb24gdG8gcnVuIG9uY2UgdGhlIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAgICogVXNlZnVsIGZvciBzeW5jaHJvbml6aW5nIHVwZGF0ZXMgaW4gc29tZSBjYXNlcy5cbiAgICogQHBhcmFtIG9wdGlvbnMuc2tpcFRyYW5zZm9ybXMgLSBTZXR0aW5nIHRoaXMgdG8gdHJ1ZSB3aWxsIHN1cHByZXNzIGFsbCBub2RlXG4gICAqIHRyYW5zZm9ybXMgZm9yIHRoaXMgdXBkYXRlIGN5Y2xlLlxuICAgKiBAcGFyYW0gb3B0aW9ucy50YWcgLSBBIHRhZyB0byBpZGVudGlmeSB0aGlzIHVwZGF0ZSwgaW4gYW4gdXBkYXRlIGxpc3RlbmVyLCBmb3IgaW5zdGFuY2UuXG4gICAqIFNvbWUgdGFncyBhcmUgcmVzZXJ2ZWQgYnkgdGhlIGNvcmUgYW5kIGNvbnRyb2wgdXBkYXRlIGJlaGF2aW9yIGluIGRpZmZlcmVudCB3YXlzLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5kaXNjcmV0ZSAtIElmIHRydWUsIHByZXZlbnRzIHRoaXMgdXBkYXRlIGZyb20gYmVpbmcgYmF0Y2hlZCwgZm9yY2luZyBpdCB0b1xuICAgKiBydW4gc3luY2hyb25vdXNseS5cbiAgICovXG5cblxuICB1cGRhdGUodXBkYXRlRm4sIG9wdGlvbnMpIHtcbiAgICB1cGRhdGVFZGl0b3IodGhpcywgdXBkYXRlRm4sIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1c2VzIHRoZSBlZGl0b3JcbiAgICogQHBhcmFtIGNhbGxiYWNrRm4gLSBBIGZ1bmN0aW9uIHRvIHJ1biBhZnRlciB0aGUgZWRpdG9yIGlzIGZvY3VzZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gQSBiYWcgb2Ygb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0U2VsZWN0aW9uIC0gV2hlcmUgdG8gbW92ZSBzZWxlY3Rpb24gd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAqIGZvY3VzZWQuIENhbiBiZSByb290U3RhcnQsIHJvb3RFbmQsIG9yIHVuZGVmaW5lZC4gRGVmYXVsdHMgdG8gcm9vdEVuZC5cbiAgICovXG5cblxuICBmb2N1cyhjYWxsYmFja0ZuLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50O1xuXG4gICAgaWYgKHJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCBpT1MgZG9lcyBub3QgdHJpZ2dlciBjYXBzIGxvY2sgdXBvbiBmb2N1c1xuICAgICAgcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhdXRvY2FwaXRhbGl6ZScsICdvZmYnKTtcbiAgICAgIHVwZGF0ZUVkaXRvcih0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIE1hcmtpbmcgdGhlIHNlbGVjdGlvbiBkaXJ0eSB3aWxsIGZvcmNlIHRoZSBzZWxlY3Rpb24gYmFjayB0byBpdFxuICAgICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdC5nZXRDaGlsZHJlblNpemUoKSAhPT0gMCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRTZWxlY3Rpb24gPT09ICdyb290U3RhcnQnKSB7XG4gICAgICAgICAgICByb290LnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvb3Quc2VsZWN0RW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIG9uVXBkYXRlOiAoKSA9PiB7XG4gICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhdXRvY2FwaXRhbGl6ZScpO1xuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIGNhbGxiYWNrRm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRhZzogJ2ZvY3VzJ1xuICAgICAgfSk7IC8vIEluIHRoZSBjYXNlIHdoZXJlIG9uVXBkYXRlIGRvZXNuJ3QgZmlyZSAoZHVlIHRvIHRoZSBmb2N1cyB1cGRhdGUgbm90XG4gICAgICAvLyBvY2N1cmluZykuXG5cbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nRWRpdG9yU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhdXRvY2FwaXRhbGl6ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBmb2N1cyBmcm9tIHRoZSBlZGl0b3IuXG4gICAqL1xuXG5cbiAgYmx1cigpIHtcbiAgICBjb25zdCByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50O1xuXG4gICAgaWYgKHJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICByb290RWxlbWVudC5ibHVyKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKHRoaXMuX3dpbmRvdyk7XG5cbiAgICBpZiAoZG9tU2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVkaXRvciBpcyBlZGl0YWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBlZGl0b3IgaXMgZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBpc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9lZGl0YWJsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZWRpdGFibGUgcHJvcGVydHkgb2YgdGhlIGVkaXRvci4gV2hlbiBmYWxzZSwgdGhlXG4gICAqIGVkaXRvciB3aWxsIG5vdCBsaXN0ZW4gZm9yIHVzZXIgZXZlbnRzIG9uIHRoZSB1bmRlcmxpbmcgY29udGVudGVkaXRhYmxlLlxuICAgKiBAcGFyYW0gZWRpdGFibGUgLSB0aGUgdmFsdWUgdG8gc2V0IHRoZSBlZGl0YWJsZSBtb2RlIHRvLlxuICAgKi9cblxuXG4gIHNldEVkaXRhYmxlKGVkaXRhYmxlKSB7XG4gICAgaWYgKHRoaXMuX2VkaXRhYmxlICE9PSBlZGl0YWJsZSkge1xuICAgICAgdGhpcy5fZWRpdGFibGUgPSBlZGl0YWJsZTtcbiAgICAgIHRyaWdnZXJMaXN0ZW5lcnMoJ2VkaXRhYmxlJywgdGhpcywgdHJ1ZSwgZWRpdGFibGUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIGphdmFzY3JpcHQgb2JqZWN0IE5PVCBhIEpTT04gc3RyaW5nLlxuICAgKiBZb3Ugc3RpbGwgbXVzdCBjYWxsIEpTT04uc3RyaW5naWZ5IChvciBzb21ldGhpbmcgZWxzZSkgdG8gdHVybiB0aGVcbiAgICogc3RhdGUgaW50byBhIHN0cmluZyB5b3UgY2FuIHRyYW5zZmVyIG92ZXIgdGhlIHdpcmUgYW5kIHN0b3JlIGluIGEgZGF0YWJhc2UuXG4gICAqXG4gICAqIFNlZSB7QGxpbmsgTGV4aWNhbE5vZGUuZXhwb3J0SlNPTn1cbiAgICpcbiAgICogQHJldHVybnMgQSBKU09OLXNlcmlhbGl6YWJsZSBqYXZhc2NyaXB0IG9iamVjdFxuICAgKi9cblxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWRpdG9yU3RhdGU6IHRoaXMuX2VkaXRvclN0YXRlLnRvSlNPTigpXG4gICAgfTtcbiAgfVxuXG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIERFUFJFQ0FURURfR3JpZENlbGxOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKGNvbFNwYW4sIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX2NvbFNwYW4gPSBjb2xTcGFuO1xuICAgIHRoaXMuX19yb3dTcGFuID0gMTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgY29sU3BhbjogdGhpcy5fX2NvbFNwYW4sXG4gICAgICByb3dTcGFuOiB0aGlzLl9fcm93U3BhblxuICAgIH07XG4gIH1cblxuICBnZXRDb2xTcGFuKCkge1xuICAgIHJldHVybiB0aGlzLl9fY29sU3BhbjtcbiAgfVxuXG4gIHNldENvbFNwYW4oY29sU3Bhbikge1xuICAgIHRoaXMuZ2V0V3JpdGFibGUoKS5fX2NvbFNwYW4gPSBjb2xTcGFuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0Um93U3BhbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX3Jvd1NwYW47XG4gIH1cblxuICBzZXRSb3dTcGFuKHJvd1NwYW4pIHtcbiAgICB0aGlzLmdldFdyaXRhYmxlKCkuX19yb3dTcGFuID0gcm93U3BhbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5mdW5jdGlvbiBERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgREVQUkVDQVRFRF9HcmlkQ2VsbE5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNsYXNzIERFUFJFQ0FURURfR3JpZE5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7fVxuZnVuY3Rpb24gREVQUkVDQVRFRF8kaXNHcmlkTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgREVQUkVDQVRFRF9HcmlkTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY2xhc3MgREVQUkVDQVRFRF9HcmlkUm93Tm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHt9XG5mdW5jdGlvbiBERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBERVBSRUNBVEVEX0dyaWRSb3dOb2RlO1xufVxuXG5leHBvcnRzLiRhZGRVcGRhdGVUYWcgPSAkYWRkVXBkYXRlVGFnO1xuZXhwb3J0cy4kYXBwbHlOb2RlUmVwbGFjZW1lbnQgPSAkYXBwbHlOb2RlUmVwbGFjZW1lbnQ7XG5leHBvcnRzLiRjb3B5Tm9kZSA9ICRjb3B5Tm9kZTtcbmV4cG9ydHMuJGNyZWF0ZUxpbmVCcmVha05vZGUgPSAkY3JlYXRlTGluZUJyZWFrTm9kZTtcbmV4cG9ydHMuJGNyZWF0ZU5vZGVTZWxlY3Rpb24gPSAkY3JlYXRlTm9kZVNlbGVjdGlvbjtcbmV4cG9ydHMuJGNyZWF0ZVBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZTtcbmV4cG9ydHMuJGNyZWF0ZVJhbmdlU2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uO1xuZXhwb3J0cy4kY3JlYXRlVGFiTm9kZSA9ICRjcmVhdGVUYWJOb2RlO1xuZXhwb3J0cy4kY3JlYXRlVGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGU7XG5leHBvcnRzLiRnZXRBZGphY2VudE5vZGUgPSAkZ2V0QWRqYWNlbnROb2RlO1xuZXhwb3J0cy4kZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlO1xuZXhwb3J0cy4kZ2V0TmVhcmVzdFJvb3RPclNoYWRvd1Jvb3QgPSAkZ2V0TmVhcmVzdFJvb3RPclNoYWRvd1Jvb3Q7XG5leHBvcnRzLiRnZXROb2RlQnlLZXkgPSAkZ2V0Tm9kZUJ5S2V5O1xuZXhwb3J0cy4kZ2V0UHJldmlvdXNTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb247XG5leHBvcnRzLiRnZXRSb290ID0gJGdldFJvb3Q7XG5leHBvcnRzLiRnZXRTZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uO1xuZXhwb3J0cy4kZ2V0VGV4dENvbnRlbnQgPSAkZ2V0VGV4dENvbnRlbnQ7XG5leHBvcnRzLiRoYXNBbmNlc3RvciA9ICRoYXNBbmNlc3RvcjtcbmV4cG9ydHMuJGhhc1VwZGF0ZVRhZyA9ICRoYXNVcGRhdGVUYWc7XG5leHBvcnRzLiRpbnNlcnROb2RlcyA9ICRpbnNlcnROb2RlcztcbmV4cG9ydHMuJGlzQmxvY2tFbGVtZW50Tm9kZSA9ICRpc0Jsb2NrRWxlbWVudE5vZGU7XG5leHBvcnRzLiRpc0RlY29yYXRvck5vZGUgPSAkaXNEZWNvcmF0b3JOb2RlO1xuZXhwb3J0cy4kaXNFbGVtZW50Tm9kZSA9ICRpc0VsZW1lbnROb2RlO1xuZXhwb3J0cy4kaXNJbmxpbmVFbGVtZW50T3JEZWNvcmF0b3JOb2RlID0gJGlzSW5saW5lRWxlbWVudE9yRGVjb3JhdG9yTm9kZTtcbmV4cG9ydHMuJGlzTGVhZk5vZGUgPSAkaXNMZWFmTm9kZTtcbmV4cG9ydHMuJGlzTGluZUJyZWFrTm9kZSA9ICRpc0xpbmVCcmVha05vZGU7XG5leHBvcnRzLiRpc05vZGVTZWxlY3Rpb24gPSAkaXNOb2RlU2VsZWN0aW9uO1xuZXhwb3J0cy4kaXNQYXJhZ3JhcGhOb2RlID0gJGlzUGFyYWdyYXBoTm9kZTtcbmV4cG9ydHMuJGlzUmFuZ2VTZWxlY3Rpb24gPSAkaXNSYW5nZVNlbGVjdGlvbjtcbmV4cG9ydHMuJGlzUm9vdE5vZGUgPSAkaXNSb290Tm9kZTtcbmV4cG9ydHMuJGlzUm9vdE9yU2hhZG93Um9vdCA9ICRpc1Jvb3RPclNoYWRvd1Jvb3Q7XG5leHBvcnRzLiRpc1RhYk5vZGUgPSAkaXNUYWJOb2RlO1xuZXhwb3J0cy4kaXNUZXh0Tm9kZSA9ICRpc1RleHROb2RlO1xuZXhwb3J0cy4kbm9kZXNPZlR5cGUgPSAkbm9kZXNPZlR5cGU7XG5leHBvcnRzLiRub3JtYWxpemVTZWxlY3Rpb25fX0VYUEVSSU1FTlRBTCA9ICRub3JtYWxpemVTZWxlY3Rpb247XG5leHBvcnRzLiRwYXJzZVNlcmlhbGl6ZWROb2RlID0gJHBhcnNlU2VyaWFsaXplZE5vZGU7XG5leHBvcnRzLiRzZXRDb21wb3NpdGlvbktleSA9ICRzZXRDb21wb3NpdGlvbktleTtcbmV4cG9ydHMuJHNldFNlbGVjdGlvbiA9ICRzZXRTZWxlY3Rpb247XG5leHBvcnRzLiRzcGxpdE5vZGUgPSAkc3BsaXROb2RlO1xuZXhwb3J0cy5CTFVSX0NPTU1BTkQgPSBCTFVSX0NPTU1BTkQ7XG5leHBvcnRzLkNBTl9SRURPX0NPTU1BTkQgPSBDQU5fUkVET19DT01NQU5EO1xuZXhwb3J0cy5DQU5fVU5ET19DT01NQU5EID0gQ0FOX1VORE9fQ09NTUFORDtcbmV4cG9ydHMuQ0xFQVJfRURJVE9SX0NPTU1BTkQgPSBDTEVBUl9FRElUT1JfQ09NTUFORDtcbmV4cG9ydHMuQ0xFQVJfSElTVE9SWV9DT01NQU5EID0gQ0xFQVJfSElTVE9SWV9DT01NQU5EO1xuZXhwb3J0cy5DTElDS19DT01NQU5EID0gQ0xJQ0tfQ09NTUFORDtcbmV4cG9ydHMuQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCA9IENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUw7XG5leHBvcnRzLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SID0gQ09NTUFORF9QUklPUklUWV9FRElUT1I7XG5leHBvcnRzLkNPTU1BTkRfUFJJT1JJVFlfSElHSCA9IENPTU1BTkRfUFJJT1JJVFlfSElHSDtcbmV4cG9ydHMuQ09NTUFORF9QUklPUklUWV9MT1cgPSBDT01NQU5EX1BSSU9SSVRZX0xPVztcbmV4cG9ydHMuQ09NTUFORF9QUklPUklUWV9OT1JNQUwgPSBDT01NQU5EX1BSSU9SSVRZX05PUk1BTDtcbmV4cG9ydHMuQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5EID0gQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5EO1xuZXhwb3J0cy5DT1BZX0NPTU1BTkQgPSBDT1BZX0NPTU1BTkQ7XG5leHBvcnRzLkNVVF9DT01NQU5EID0gQ1VUX0NPTU1BTkQ7XG5leHBvcnRzLkRFTEVURV9DSEFSQUNURVJfQ09NTUFORCA9IERFTEVURV9DSEFSQUNURVJfQ09NTUFORDtcbmV4cG9ydHMuREVMRVRFX0xJTkVfQ09NTUFORCA9IERFTEVURV9MSU5FX0NPTU1BTkQ7XG5leHBvcnRzLkRFTEVURV9XT1JEX0NPTU1BTkQgPSBERUxFVEVfV09SRF9DT01NQU5EO1xuZXhwb3J0cy5ERVBSRUNBVEVEXyRjb21wdXRlR3JpZE1hcCA9IERFUFJFQ0FURURfJGNvbXB1dGVHcmlkTWFwO1xuZXhwb3J0cy5ERVBSRUNBVEVEXyRjcmVhdGVHcmlkU2VsZWN0aW9uID0gREVQUkVDQVRFRF8kY3JlYXRlR3JpZFNlbGVjdGlvbjtcbmV4cG9ydHMuREVQUkVDQVRFRF8kZ2V0Tm9kZVRyaXBsZXQgPSBERVBSRUNBVEVEXyRnZXROb2RlVHJpcGxldDtcbmV4cG9ydHMuREVQUkVDQVRFRF8kaXNHcmlkQ2VsbE5vZGUgPSBERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZTtcbmV4cG9ydHMuREVQUkVDQVRFRF8kaXNHcmlkTm9kZSA9IERFUFJFQ0FURURfJGlzR3JpZE5vZGU7XG5leHBvcnRzLkRFUFJFQ0FURURfJGlzR3JpZFJvd05vZGUgPSBERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlO1xuZXhwb3J0cy5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24gPSBERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb247XG5leHBvcnRzLkRFUFJFQ0FURURfR3JpZENlbGxOb2RlID0gREVQUkVDQVRFRF9HcmlkQ2VsbE5vZGU7XG5leHBvcnRzLkRFUFJFQ0FURURfR3JpZE5vZGUgPSBERVBSRUNBVEVEX0dyaWROb2RlO1xuZXhwb3J0cy5ERVBSRUNBVEVEX0dyaWRSb3dOb2RlID0gREVQUkVDQVRFRF9HcmlkUm93Tm9kZTtcbmV4cG9ydHMuRFJBR0VORF9DT01NQU5EID0gRFJBR0VORF9DT01NQU5EO1xuZXhwb3J0cy5EUkFHT1ZFUl9DT01NQU5EID0gRFJBR09WRVJfQ09NTUFORDtcbmV4cG9ydHMuRFJBR1NUQVJUX0NPTU1BTkQgPSBEUkFHU1RBUlRfQ09NTUFORDtcbmV4cG9ydHMuRFJPUF9DT01NQU5EID0gRFJPUF9DT01NQU5EO1xuZXhwb3J0cy5EZWNvcmF0b3JOb2RlID0gRGVjb3JhdG9yTm9kZTtcbmV4cG9ydHMuRWxlbWVudE5vZGUgPSBFbGVtZW50Tm9kZTtcbmV4cG9ydHMuRk9DVVNfQ09NTUFORCA9IEZPQ1VTX0NPTU1BTkQ7XG5leHBvcnRzLkZPUk1BVF9FTEVNRU5UX0NPTU1BTkQgPSBGT1JNQVRfRUxFTUVOVF9DT01NQU5EO1xuZXhwb3J0cy5GT1JNQVRfVEVYVF9DT01NQU5EID0gRk9STUFUX1RFWFRfQ09NTUFORDtcbmV4cG9ydHMuSU5ERU5UX0NPTlRFTlRfQ09NTUFORCA9IElOREVOVF9DT05URU5UX0NPTU1BTkQ7XG5leHBvcnRzLklOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQgPSBJTlNFUlRfTElORV9CUkVBS19DT01NQU5EO1xuZXhwb3J0cy5JTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQgPSBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQ7XG5leHBvcnRzLklOU0VSVF9UQUJfQ09NTUFORCA9IElOU0VSVF9UQUJfQ09NTUFORDtcbmV4cG9ydHMuS0VZX0FSUk9XX0RPV05fQ09NTUFORCA9IEtFWV9BUlJPV19ET1dOX0NPTU1BTkQ7XG5leHBvcnRzLktFWV9BUlJPV19MRUZUX0NPTU1BTkQgPSBLRVlfQVJST1dfTEVGVF9DT01NQU5EO1xuZXhwb3J0cy5LRVlfQVJST1dfUklHSFRfQ09NTUFORCA9IEtFWV9BUlJPV19SSUdIVF9DT01NQU5EO1xuZXhwb3J0cy5LRVlfQVJST1dfVVBfQ09NTUFORCA9IEtFWV9BUlJPV19VUF9DT01NQU5EO1xuZXhwb3J0cy5LRVlfQkFDS1NQQUNFX0NPTU1BTkQgPSBLRVlfQkFDS1NQQUNFX0NPTU1BTkQ7XG5leHBvcnRzLktFWV9ERUxFVEVfQ09NTUFORCA9IEtFWV9ERUxFVEVfQ09NTUFORDtcbmV4cG9ydHMuS0VZX0RPV05fQ09NTUFORCA9IEtFWV9ET1dOX0NPTU1BTkQ7XG5leHBvcnRzLktFWV9FTlRFUl9DT01NQU5EID0gS0VZX0VOVEVSX0NPTU1BTkQ7XG5leHBvcnRzLktFWV9FU0NBUEVfQ09NTUFORCA9IEtFWV9FU0NBUEVfQ09NTUFORDtcbmV4cG9ydHMuS0VZX01PRElGSUVSX0NPTU1BTkQgPSBLRVlfTU9ESUZJRVJfQ09NTUFORDtcbmV4cG9ydHMuS0VZX1NQQUNFX0NPTU1BTkQgPSBLRVlfU1BBQ0VfQ09NTUFORDtcbmV4cG9ydHMuS0VZX1RBQl9DT01NQU5EID0gS0VZX1RBQl9DT01NQU5EO1xuZXhwb3J0cy5MaW5lQnJlYWtOb2RlID0gTGluZUJyZWFrTm9kZTtcbmV4cG9ydHMuTU9WRV9UT19FTkQgPSBNT1ZFX1RPX0VORDtcbmV4cG9ydHMuTU9WRV9UT19TVEFSVCA9IE1PVkVfVE9fU1RBUlQ7XG5leHBvcnRzLk9VVERFTlRfQ09OVEVOVF9DT01NQU5EID0gT1VUREVOVF9DT05URU5UX0NPTU1BTkQ7XG5leHBvcnRzLlBBU1RFX0NPTU1BTkQgPSBQQVNURV9DT01NQU5EO1xuZXhwb3J0cy5QYXJhZ3JhcGhOb2RlID0gUGFyYWdyYXBoTm9kZTtcbmV4cG9ydHMuUkVET19DT01NQU5EID0gUkVET19DT01NQU5EO1xuZXhwb3J0cy5SRU1PVkVfVEVYVF9DT01NQU5EID0gUkVNT1ZFX1RFWFRfQ09NTUFORDtcbmV4cG9ydHMuUm9vdE5vZGUgPSBSb290Tm9kZTtcbmV4cG9ydHMuU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5EID0gU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5EO1xuZXhwb3J0cy5UYWJOb2RlID0gVGFiTm9kZTtcbmV4cG9ydHMuVGV4dE5vZGUgPSBUZXh0Tm9kZTtcbmV4cG9ydHMuVU5ET19DT01NQU5EID0gVU5ET19DT01NQU5EO1xuZXhwb3J0cy5jcmVhdGVDb21tYW5kID0gY3JlYXRlQ29tbWFuZDtcbmV4cG9ydHMuY3JlYXRlRWRpdG9yID0gY3JlYXRlRWRpdG9yO1xuZXhwb3J0cy5nZXROZWFyZXN0RWRpdG9yRnJvbURPTU5vZGUgPSBnZXROZWFyZXN0RWRpdG9yRnJvbURPTU5vZGU7XG5leHBvcnRzLmlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcklucHV0ID0gaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9ySW5wdXQ7XG5leHBvcnRzLmlzU2VsZWN0aW9uV2l0aGluRWRpdG9yID0gaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lexical/Lexical.dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lexical/Lexical.js":
/*!*****************************************!*\
  !*** ./node_modules/lexical/Lexical.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst Lexical =  true ? __webpack_require__(/*! ./Lexical.dev.js */ \"(app-pages-browser)/./node_modules/lexical/Lexical.dev.js\") : 0\nmodule.exports = Lexical;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sZXhpY2FsL0xleGljYWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWixnQkFBZ0IsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLG1GQUFrQixJQUFJLENBQTRCO0FBQ25IIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sZXhpY2FsL0xleGljYWwuanM/ZGZiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lexical/Lexical.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-c.js":
/*!****************************************************!*\
  !*** ./node_modules/prismjs/components/prism-c.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Prism.languages.c = Prism.languages.extend('clike', {\n\t'comment': {\n\t\tpattern: /\\/\\/(?:[^\\r\\n\\\\]|\\\\(?:\\r\\n?|\\n|(?![\\r\\n])))*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\tgreedy: true\n\t},\n\t'string': {\n\t\t// https://en.cppreference.com/w/c/language/string_literal\n\t\tpattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:enum|struct)\\s+(?:__attribute__\\s*\\(\\([\\s\\S]*?\\)\\)\\s*)?)\\w+|\\b[a-z]\\w*_t\\b/,\n\t\tlookbehind: true\n\t},\n\t'keyword': /\\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b/,\n\t'function': /\\b[a-z_]\\w*(?=\\s*\\()/i,\n\t'number': /(?:\\b0x(?:[\\da-f]+(?:\\.[\\da-f]*)?|\\.[\\da-f]+)(?:p[+-]?\\d+)?|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ful]{0,4}/i,\n\t'operator': />>=?|<<=?|->|([-+&|:])\\1|[?:~]|[-+*/%&|^!=<>]=?/\n});\n\nPrism.languages.insertBefore('c', 'string', {\n\t'char': {\n\t\t// https://en.cppreference.com/w/c/language/character_constant\n\t\tpattern: /'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n]){0,32}'/,\n\t\tgreedy: true\n\t}\n});\n\nPrism.languages.insertBefore('c', 'string', {\n\t'macro': {\n\t\t// allow for multiline macro definitions\n\t\t// spaces after the # character compile fine with gcc\n\t\tpattern: /(^[\\t ]*)#\\s*[a-z](?:[^\\r\\n\\\\/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\\\\(?:\\r\\n|[\\s\\S]))*/im,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\talias: 'property',\n\t\tinside: {\n\t\t\t'string': [\n\t\t\t\t{\n\t\t\t\t\t// highlight the path of the include statement as a string\n\t\t\t\t\tpattern: /^(#\\s*include\\s*)<[^>]+>/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\tPrism.languages.c['string']\n\t\t\t],\n\t\t\t'char': Prism.languages.c['char'],\n\t\t\t'comment': Prism.languages.c['comment'],\n\t\t\t'macro-name': [\n\t\t\t\t{\n\t\t\t\t\tpattern: /(^#\\s*define\\s+)\\w+\\b(?!\\()/i,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tpattern: /(^#\\s*define\\s+)\\w+\\b(?=\\()/i,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'function'\n\t\t\t\t}\n\t\t\t],\n\t\t\t// highlight macro directives as keywords\n\t\t\t'directive': {\n\t\t\t\tpattern: /^(#\\s*)[a-z]+/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'keyword'\n\t\t\t},\n\t\t\t'directive-hash': /^#/,\n\t\t\t'punctuation': /##|\\\\(?=[\\r\\n])/,\n\t\t\t'expression': {\n\t\t\t\tpattern: /\\S[\\s\\S]*/,\n\t\t\t\tinside: Prism.languages.c\n\t\t\t}\n\t\t}\n\t}\n});\n\nPrism.languages.insertBefore('c', 'function', {\n\t// highlight predefined macros as constants\n\t'constant': /\\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\\b/\n});\n\ndelete Prism.languages.c['boolean'];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tYy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLHdIQUF3SCxJQUFJO0FBQzVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tYy5qcz84OTEyIl0sInNvdXJjZXNDb250ZW50IjpbIlByaXNtLmxhbmd1YWdlcy5jID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG5cdCdjb21tZW50Jzoge1xuXHRcdHBhdHRlcm46IC9cXC9cXC8oPzpbXlxcclxcblxcXFxdfFxcXFwoPzpcXHJcXG4/fFxcbnwoPyFbXFxyXFxuXSkpKSp8XFwvXFwqW1xcc1xcU10qPyg/OlxcKlxcL3wkKS8sXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH0sXG5cdCdzdHJpbmcnOiB7XG5cdFx0Ly8gaHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvYy9sYW5ndWFnZS9zdHJpbmdfbGl0ZXJhbFxuXHRcdHBhdHRlcm46IC9cIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXCJcXFxcXFxyXFxuXSkqXCIvLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQnY2xhc3MtbmFtZSc6IHtcblx0XHRwYXR0ZXJuOiAvKFxcYig/OmVudW18c3RydWN0KVxccysoPzpfX2F0dHJpYnV0ZV9fXFxzKlxcKFxcKFtcXHNcXFNdKj9cXClcXClcXHMqKT8pXFx3K3xcXGJbYS16XVxcdypfdFxcYi8sXG5cdFx0bG9va2JlaGluZDogdHJ1ZVxuXHR9LFxuXHQna2V5d29yZCc6IC9cXGIoPzpfQWxpZ25hc3xfQWxpZ25vZnxfQXRvbWljfF9Cb29sfF9Db21wbGV4fF9HZW5lcmljfF9JbWFnaW5hcnl8X05vcmV0dXJufF9TdGF0aWNfYXNzZXJ0fF9UaHJlYWRfbG9jYWx8X19hdHRyaWJ1dGVfX3xhc218YXV0b3xicmVha3xjYXNlfGNoYXJ8Y29uc3R8Y29udGludWV8ZGVmYXVsdHxkb3xkb3VibGV8ZWxzZXxlbnVtfGV4dGVybnxmbG9hdHxmb3J8Z290b3xpZnxpbmxpbmV8aW50fGxvbmd8cmVnaXN0ZXJ8cmV0dXJufHNob3J0fHNpZ25lZHxzaXplb2Z8c3RhdGljfHN0cnVjdHxzd2l0Y2h8dHlwZWRlZnx0eXBlb2Z8dW5pb258dW5zaWduZWR8dm9pZHx2b2xhdGlsZXx3aGlsZSlcXGIvLFxuXHQnZnVuY3Rpb24nOiAvXFxiW2Etel9dXFx3Kig/PVxccypcXCgpL2ksXG5cdCdudW1iZXInOiAvKD86XFxiMHgoPzpbXFxkYS1mXSsoPzpcXC5bXFxkYS1mXSopP3xcXC5bXFxkYS1mXSspKD86cFsrLV0/XFxkKyk/fCg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzplWystXT9cXGQrKT8pW2Z1bF17MCw0fS9pLFxuXHQnb3BlcmF0b3InOiAvPj49P3w8PD0/fC0+fChbLSsmfDpdKVxcMXxbPzp+XXxbLSsqLyUmfF4hPTw+XT0/L1xufSk7XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2MnLCAnc3RyaW5nJywge1xuXHQnY2hhcic6IHtcblx0XHQvLyBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jL2xhbmd1YWdlL2NoYXJhY3Rlcl9jb25zdGFudFxuXHRcdHBhdHRlcm46IC8nKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W14nXFxcXFxcclxcbl0pezAsMzJ9Jy8sXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH1cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjJywgJ3N0cmluZycsIHtcblx0J21hY3JvJzoge1xuXHRcdC8vIGFsbG93IGZvciBtdWx0aWxpbmUgbWFjcm8gZGVmaW5pdGlvbnNcblx0XHQvLyBzcGFjZXMgYWZ0ZXIgdGhlICMgY2hhcmFjdGVyIGNvbXBpbGUgZmluZSB3aXRoIGdjY1xuXHRcdHBhdHRlcm46IC8oXltcXHQgXSopI1xccypbYS16XSg/OlteXFxyXFxuXFxcXC9dfFxcLyg/IVxcKil8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC98XFxcXCg/OlxcclxcbnxbXFxzXFxTXSkpKi9pbSxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRhbGlhczogJ3Byb3BlcnR5Jyxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCdzdHJpbmcnOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBoaWdobGlnaHQgdGhlIHBhdGggb2YgdGhlIGluY2x1ZGUgc3RhdGVtZW50IGFzIGEgc3RyaW5nXG5cdFx0XHRcdFx0cGF0dGVybjogL14oI1xccyppbmNsdWRlXFxzKik8W14+XSs+Lyxcblx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdFByaXNtLmxhbmd1YWdlcy5jWydzdHJpbmcnXVxuXHRcdFx0XSxcblx0XHRcdCdjaGFyJzogUHJpc20ubGFuZ3VhZ2VzLmNbJ2NoYXInXSxcblx0XHRcdCdjb21tZW50JzogUHJpc20ubGFuZ3VhZ2VzLmNbJ2NvbW1lbnQnXSxcblx0XHRcdCdtYWNyby1uYW1lJzogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cGF0dGVybjogLyheI1xccypkZWZpbmVcXHMrKVxcdytcXGIoPyFcXCgpL2ksXG5cdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cGF0dGVybjogLyheI1xccypkZWZpbmVcXHMrKVxcdytcXGIoPz1cXCgpL2ksXG5cdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0XHRhbGlhczogJ2Z1bmN0aW9uJ1xuXHRcdFx0XHR9XG5cdFx0XHRdLFxuXHRcdFx0Ly8gaGlnaGxpZ2h0IG1hY3JvIGRpcmVjdGl2ZXMgYXMga2V5d29yZHNcblx0XHRcdCdkaXJlY3RpdmUnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9eKCNcXHMqKVthLXpdKy8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGFsaWFzOiAna2V5d29yZCdcblx0XHRcdH0sXG5cdFx0XHQnZGlyZWN0aXZlLWhhc2gnOiAvXiMvLFxuXHRcdFx0J3B1bmN0dWF0aW9uJzogLyMjfFxcXFwoPz1bXFxyXFxuXSkvLFxuXHRcdFx0J2V4cHJlc3Npb24nOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9cXFNbXFxzXFxTXSovLFxuXHRcdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KTtcblxuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnYycsICdmdW5jdGlvbicsIHtcblx0Ly8gaGlnaGxpZ2h0IHByZWRlZmluZWQgbWFjcm9zIGFzIGNvbnN0YW50c1xuXHQnY29uc3RhbnQnOiAvXFxiKD86RU9GfE5VTEx8U0VFS19DVVJ8U0VFS19FTkR8U0VFS19TRVR8X19EQVRFX198X19GSUxFX198X19MSU5FX198X19USU1FU1RBTVBfX3xfX1RJTUVfX3xfX2Z1bmNfX3xzdGRlcnJ8c3RkaW58c3Rkb3V0KVxcYi9cbn0pO1xuXG5kZWxldGUgUHJpc20ubGFuZ3VhZ2VzLmNbJ2Jvb2xlYW4nXTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-c.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-clike.js":
/*!********************************************************!*\
  !*** ./node_modules/prismjs/components/prism-clike.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Prism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /[.\\\\]/\n\t\t}\n\t},\n\t'keyword': /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'function': /\\b\\w+(?=\\()/,\n\t'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n\t'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY2xpa2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY2xpa2UuanM/Y2M1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJQcmlzbS5sYW5ndWFnZXMuY2xpa2UgPSB7XG5cdCdjb21tZW50JzogW1xuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXlxcXFxdKVxcL1xcKltcXHNcXFNdKj8oPzpcXCpcXC98JCkvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhefFteXFxcXDpdKVxcL1xcLy4qLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRncmVlZHk6IHRydWVcblx0XHR9XG5cdF0sXG5cdCdzdHJpbmcnOiB7XG5cdFx0cGF0dGVybjogLyhbXCInXSkoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLyxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J2NsYXNzLW5hbWUnOiB7XG5cdFx0cGF0dGVybjogLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3fHRyYWl0KVxccyt8XFxiY2F0Y2hcXHMrXFwoKVtcXHcuXFxcXF0rL2ksXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCdwdW5jdHVhdGlvbic6IC9bLlxcXFxdL1xuXHRcdH1cblx0fSxcblx0J2tleXdvcmQnOiAvXFxiKD86YnJlYWt8Y2F0Y2h8Y29udGludWV8ZG98ZWxzZXxmaW5hbGx5fGZvcnxmdW5jdGlvbnxpZnxpbnxpbnN0YW5jZW9mfG5ld3xudWxsfHJldHVybnx0aHJvd3x0cnl8d2hpbGUpXFxiLyxcblx0J2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuXHQnZnVuY3Rpb24nOiAvXFxiXFx3Kyg/PVxcKCkvLFxuXHQnbnVtYmVyJzogL1xcYjB4W1xcZGEtZl0rXFxifCg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzplWystXT9cXGQrKT8vaSxcblx0J29wZXJhdG9yJzogL1s8Pl09P3xbIT1dPT89P3wtLT98XFwrXFwrP3wmJj98XFx8XFx8P3xbPyovfl4lXS8sXG5cdCdwdW5jdHVhdGlvbic6IC9be31bXFxdOygpLC46XS9cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-clike.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-cpp.js":
/*!******************************************************!*\
  !*** ./node_modules/prismjs/components/prism-cpp.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (Prism) {\n\n\tvar keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n\tvar modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () { return keyword.source; });\n\n\tPrism.languages.cpp = Prism.languages.extend('c', {\n\t\t'class-name': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source\n\t\t\t\t\t.replace(/<keyword>/g, function () { return keyword.source; })),\n\t\t\t\tlookbehind: true\n\t\t\t},\n\t\t\t// This is intended to capture the class name of method implementations like:\n\t\t\t//   void foo::bar() const {}\n\t\t\t// However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n\t\t\t// it starts with an uppercase letter. This approximation should give decent results.\n\t\t\t/\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/,\n\t\t\t// This will capture the class name before destructors like:\n\t\t\t//   Foo::~Foo() {}\n\t\t\t/\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i,\n\t\t\t// This also intends to capture the class name of method implementations but here the class has template\n\t\t\t// parameters, so it can't be a namespace (until C++ adds generic namespaces).\n\t\t\t/\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/\n\t\t],\n\t\t'keyword': keyword,\n\t\t'number': {\n\t\t\tpattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n\t\t\tgreedy: true\n\t\t},\n\t\t'operator': />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n\t\t'boolean': /\\b(?:false|true)\\b/\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'string', {\n\t\t'module': {\n\t\t\t// https://en.cppreference.com/w/cpp/language/modules\n\t\t\tpattern: RegExp(\n\t\t\t\t/(\\b(?:import|module)\\s+)/.source +\n\t\t\t\t'(?:' +\n\t\t\t\t// header-name\n\t\t\t\t/\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source +\n\t\t\t\t'|' +\n\t\t\t\t// module name or partition or both\n\t\t\t\t/<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () { return modName; }) +\n\t\t\t\t')'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'string': /^[<\"][\\s\\S]+/,\n\t\t\t\t'operator': /:/,\n\t\t\t\t'punctuation': /\\./\n\t\t\t}\n\t\t},\n\t\t'raw-string': {\n\t\t\tpattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n\t\t\talias: 'string',\n\t\t\tgreedy: true\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'keyword', {\n\t\t'generic-function': {\n\t\t\tpattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\n\t\t\tinside: {\n\t\t\t\t'function': /^\\w+/,\n\t\t\t\t'generic': {\n\t\t\t\t\tpattern: /<[\\s\\S]+/,\n\t\t\t\t\talias: 'class-name',\n\t\t\t\t\tinside: Prism.languages.cpp\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'operator', {\n\t\t'double-colon': {\n\t\t\tpattern: /::/,\n\t\t\talias: 'punctuation'\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('cpp', 'class-name', {\n\t\t// the base clause is an optional list of parent classes\n\t\t// https://en.cppreference.com/w/cpp/language/class\n\t\t'base-clause': {\n\t\t\tpattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: Prism.languages.extend('cpp', {})\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('inside', 'double-colon', {\n\t\t// All untokenized words that are not namespaces should be class names\n\t\t'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n\t}, Prism.languages.cpp['base-clause']);\n\n}(Prism));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY3BwLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0EsaUdBQWlHLHdCQUF3Qjs7QUFFekg7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0JBQXdCO0FBQ2xFO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSkFBc0osSUFBSTtBQUMxSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyxpQkFBaUI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUJBQXlCLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGlCQUFpQixpQkFBaUI7QUFDckY7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY3BwLmpzP2I0MjgiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChQcmlzbSkge1xuXG5cdHZhciBrZXl3b3JkID0gL1xcYig/OmFsaWduYXN8YWxpZ25vZnxhc218YXV0b3xib29sfGJyZWFrfGNhc2V8Y2F0Y2h8Y2hhcnxjaGFyMTZfdHxjaGFyMzJfdHxjaGFyOF90fGNsYXNzfGNvX2F3YWl0fGNvX3JldHVybnxjb195aWVsZHxjb21wbHxjb25jZXB0fGNvbnN0fGNvbnN0X2Nhc3R8Y29uc3RldmFsfGNvbnN0ZXhwcnxjb25zdGluaXR8Y29udGludWV8ZGVjbHR5cGV8ZGVmYXVsdHxkZWxldGV8ZG98ZG91YmxlfGR5bmFtaWNfY2FzdHxlbHNlfGVudW18ZXhwbGljaXR8ZXhwb3J0fGV4dGVybnxmaW5hbHxmbG9hdHxmb3J8ZnJpZW5kfGdvdG98aWZ8aW1wb3J0fGlubGluZXxpbnR8aW50MTZfdHxpbnQzMl90fGludDY0X3R8aW50OF90fGxvbmd8bW9kdWxlfG11dGFibGV8bmFtZXNwYWNlfG5ld3xub2V4Y2VwdHxudWxscHRyfG9wZXJhdG9yfG92ZXJyaWRlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZWdpc3RlcnxyZWludGVycHJldF9jYXN0fHJlcXVpcmVzfHJldHVybnxzaG9ydHxzaWduZWR8c2l6ZW9mfHN0YXRpY3xzdGF0aWNfYXNzZXJ0fHN0YXRpY19jYXN0fHN0cnVjdHxzd2l0Y2h8dGVtcGxhdGV8dGhpc3x0aHJlYWRfbG9jYWx8dGhyb3d8dHJ5fHR5cGVkZWZ8dHlwZWlkfHR5cGVuYW1lfHVpbnQxNl90fHVpbnQzMl90fHVpbnQ2NF90fHVpbnQ4X3R8dW5pb258dW5zaWduZWR8dXNpbmd8dmlydHVhbHx2b2lkfHZvbGF0aWxlfHdjaGFyX3R8d2hpbGUpXFxiLztcblx0dmFyIG1vZE5hbWUgPSAvXFxiKD8hPGtleXdvcmQ+KVxcdysoPzpcXHMqXFwuXFxzKlxcdyspKlxcYi8uc291cmNlLnJlcGxhY2UoLzxrZXl3b3JkPi9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBrZXl3b3JkLnNvdXJjZTsgfSk7XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmNwcCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2MnLCB7XG5cdFx0J2NsYXNzLW5hbWUnOiBbXG5cdFx0XHR7XG5cdFx0XHRcdHBhdHRlcm46IFJlZ0V4cCgvKFxcYig/OmNsYXNzfGNvbmNlcHR8ZW51bXxzdHJ1Y3R8dHlwZW5hbWUpXFxzKykoPyE8a2V5d29yZD4pXFx3Ky8uc291cmNlXG5cdFx0XHRcdFx0LnJlcGxhY2UoLzxrZXl3b3JkPi9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiBrZXl3b3JkLnNvdXJjZTsgfSkpLFxuXHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0Ly8gVGhpcyBpcyBpbnRlbmRlZCB0byBjYXB0dXJlIHRoZSBjbGFzcyBuYW1lIG9mIG1ldGhvZCBpbXBsZW1lbnRhdGlvbnMgbGlrZTpcblx0XHRcdC8vICAgdm9pZCBmb286OmJhcigpIGNvbnN0IHt9XG5cdFx0XHQvLyBIb3dldmVyISBUaGUgYGZvb2AgaW4gdGhlIGFib3ZlIGV4YW1wbGUgY291bGQgYWxzbyBiZSBhIG5hbWVzcGFjZSwgc28gd2Ugb25seSBjYXB0dXJlIHRoZSBjbGFzcyBuYW1lIGlmXG5cdFx0XHQvLyBpdCBzdGFydHMgd2l0aCBhbiB1cHBlcmNhc2UgbGV0dGVyLiBUaGlzIGFwcHJveGltYXRpb24gc2hvdWxkIGdpdmUgZGVjZW50IHJlc3VsdHMuXG5cdFx0XHQvXFxiW0EtWl1cXHcqKD89XFxzKjo6XFxzKlxcdytcXHMqXFwoKS8sXG5cdFx0XHQvLyBUaGlzIHdpbGwgY2FwdHVyZSB0aGUgY2xhc3MgbmFtZSBiZWZvcmUgZGVzdHJ1Y3RvcnMgbGlrZTpcblx0XHRcdC8vICAgRm9vOjp+Rm9vKCkge31cblx0XHRcdC9cXGJbQS1aX11cXHcqKD89XFxzKjo6XFxzKn5cXHcrXFxzKlxcKCkvaSxcblx0XHRcdC8vIFRoaXMgYWxzbyBpbnRlbmRzIHRvIGNhcHR1cmUgdGhlIGNsYXNzIG5hbWUgb2YgbWV0aG9kIGltcGxlbWVudGF0aW9ucyBidXQgaGVyZSB0aGUgY2xhc3MgaGFzIHRlbXBsYXRlXG5cdFx0XHQvLyBwYXJhbWV0ZXJzLCBzbyBpdCBjYW4ndCBiZSBhIG5hbWVzcGFjZSAodW50aWwgQysrIGFkZHMgZ2VuZXJpYyBuYW1lc3BhY2VzKS5cblx0XHRcdC9cXGJcXHcrKD89XFxzKjwoPzpbXjw+XXw8KD86W148Pl18PFtePD5dKj4pKj4pKj5cXHMqOjpcXHMqXFx3K1xccypcXCgpL1xuXHRcdF0sXG5cdFx0J2tleXdvcmQnOiBrZXl3b3JkLFxuXHRcdCdudW1iZXInOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKD86XFxiMGJbMDEnXSt8XFxiMHgoPzpbXFxkYS1mJ10rKD86XFwuW1xcZGEtZiddKik/fFxcLltcXGRhLWYnXSspKD86cFsrLV0/W1xcZCddKyk/fCg/OlxcYltcXGQnXSsoPzpcXC5bXFxkJ10qKT98XFxCXFwuW1xcZCddKykoPzplWystXT9bXFxkJ10rKT8pW2Z1bF17MCw0fS9pLFxuXHRcdFx0Z3JlZWR5OiB0cnVlXG5cdFx0fSxcblx0XHQnb3BlcmF0b3InOiAvPj49P3w8PD0/fC0+fC0tfFxcK1xcK3wmJnxcXHxcXHx8Wz86fl18PD0+fFstKyovJSZ8XiE9PD5dPT98XFxiKD86YW5kfGFuZF9lcXxiaXRhbmR8Yml0b3J8bm90fG5vdF9lcXxvcnxvcl9lcXx4b3J8eG9yX2VxKVxcYi8sXG5cdFx0J2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvXG5cdH0pO1xuXG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NwcCcsICdzdHJpbmcnLCB7XG5cdFx0J21vZHVsZSc6IHtcblx0XHRcdC8vIGh0dHBzOi8vZW4uY3BwcmVmZXJlbmNlLmNvbS93L2NwcC9sYW5ndWFnZS9tb2R1bGVzXG5cdFx0XHRwYXR0ZXJuOiBSZWdFeHAoXG5cdFx0XHRcdC8oXFxiKD86aW1wb3J0fG1vZHVsZSlcXHMrKS8uc291cmNlICtcblx0XHRcdFx0Jyg/OicgK1xuXHRcdFx0XHQvLyBoZWFkZXItbmFtZVxuXHRcdFx0XHQvXCIoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlwiXFxcXFxcclxcbl0pKlwifDxbXjw+XFxyXFxuXSo+Ly5zb3VyY2UgK1xuXHRcdFx0XHQnfCcgK1xuXHRcdFx0XHQvLyBtb2R1bGUgbmFtZSBvciBwYXJ0aXRpb24gb3IgYm90aFxuXHRcdFx0XHQvPG1vZC1uYW1lPig/Olxccyo6XFxzKjxtb2QtbmFtZT4pP3w6XFxzKjxtb2QtbmFtZT4vLnNvdXJjZS5yZXBsYWNlKC88bW9kLW5hbWU+L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vZE5hbWU7IH0pICtcblx0XHRcdFx0JyknXG5cdFx0XHQpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQnc3RyaW5nJzogL15bPFwiXVtcXHNcXFNdKy8sXG5cdFx0XHRcdCdvcGVyYXRvcic6IC86Lyxcblx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL1xcLi9cblx0XHRcdH1cblx0XHR9LFxuXHRcdCdyYXctc3RyaW5nJzoge1xuXHRcdFx0cGF0dGVybjogL1JcIihbXigpXFxcXCBdezAsMTZ9KVxcKFtcXHNcXFNdKj9cXClcXDFcIi8sXG5cdFx0XHRhbGlhczogJ3N0cmluZycsXG5cdFx0XHRncmVlZHk6IHRydWVcblx0XHR9XG5cdH0pO1xuXG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NwcCcsICdrZXl3b3JkJywge1xuXHRcdCdnZW5lcmljLWZ1bmN0aW9uJzoge1xuXHRcdFx0cGF0dGVybjogL1xcYig/IW9wZXJhdG9yXFxiKVthLXpfXVxcdypcXHMqPCg/OltePD5dfDxbXjw+XSo+KSo+KD89XFxzKlxcKCkvaSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQnZnVuY3Rpb24nOiAvXlxcdysvLFxuXHRcdFx0XHQnZ2VuZXJpYyc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvPFtcXHNcXFNdKy8sXG5cdFx0XHRcdFx0YWxpYXM6ICdjbGFzcy1uYW1lJyxcblx0XHRcdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5jcHBcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3BwJywgJ29wZXJhdG9yJywge1xuXHRcdCdkb3VibGUtY29sb24nOiB7XG5cdFx0XHRwYXR0ZXJuOiAvOjovLFxuXHRcdFx0YWxpYXM6ICdwdW5jdHVhdGlvbidcblx0XHR9XG5cdH0pO1xuXG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NwcCcsICdjbGFzcy1uYW1lJywge1xuXHRcdC8vIHRoZSBiYXNlIGNsYXVzZSBpcyBhbiBvcHRpb25hbCBsaXN0IG9mIHBhcmVudCBjbGFzc2VzXG5cdFx0Ly8gaHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL2NsYXNzXG5cdFx0J2Jhc2UtY2xhdXNlJzoge1xuXHRcdFx0cGF0dGVybjogLyhcXGIoPzpjbGFzc3xzdHJ1Y3QpXFxzK1xcdytcXHMqOlxccyopW147e31cIidcXHNdKyg/OlxccytbXjt7fVwiJ1xcc10rKSooPz1cXHMqWzt7XSkvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY3BwJywge30pXG5cdFx0fVxuXHR9KTtcblxuXHRQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdpbnNpZGUnLCAnZG91YmxlLWNvbG9uJywge1xuXHRcdC8vIEFsbCB1bnRva2VuaXplZCB3b3JkcyB0aGF0IGFyZSBub3QgbmFtZXNwYWNlcyBzaG91bGQgYmUgY2xhc3MgbmFtZXNcblx0XHQnY2xhc3MtbmFtZSc6IC9cXGJbYS16X11cXHcqXFxiKD8hXFxzKjo6KS9pXG5cdH0sIFByaXNtLmxhbmd1YWdlcy5jcHBbJ2Jhc2UtY2xhdXNlJ10pO1xuXG59KFByaXNtKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-cpp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-css.js":
/*!******************************************************!*\
  !*** ./node_modules/prismjs/components/prism-css.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (Prism) {\n\n\tvar string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n\n\tPrism.languages.css = {\n\t\t'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n\t\t'atrule': {\n\t\t\tpattern: RegExp('@[\\\\w-](?:' + /[^;{\\s\"']|\\s+(?!\\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\\s*\\{))/.source),\n\t\t\tinside: {\n\t\t\t\t'rule': /^@[\\w-]+/,\n\t\t\t\t'selector-function-argument': {\n\t\t\t\t\tpattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'keyword': {\n\t\t\t\t\tpattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t\t// See rest below\n\t\t\t}\n\t\t},\n\t\t'url': {\n\t\t\t// https://drafts.csswg.org/css-values-3/#urls\n\t\t\tpattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^url/i,\n\t\t\t\t'punctuation': /^\\(|\\)$/,\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: RegExp('^' + string.source + '$'),\n\t\t\t\t\talias: 'url'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'selector': {\n\t\t\tpattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string': {\n\t\t\tpattern: string,\n\t\t\tgreedy: true\n\t\t},\n\t\t'property': {\n\t\t\tpattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'important': /!important\\b/i,\n\t\t'function': {\n\t\t\tpattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'punctuation': /[(){};:,]/\n\t};\n\n\tPrism.languages.css['atrule'].inside.rest = Prism.languages.css;\n\n\tvar markup = Prism.languages.markup;\n\tif (markup) {\n\t\tmarkup.tag.addInlined('style', 'css');\n\t\tmarkup.tag.addAttribute('style', 'css');\n\t}\n\n}(Prism));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2REFBNkQsU0FBUztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDBCQUEwQixTQUFTLFlBQVksb0JBQW9CLG9DQUFvQztBQUN2RztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdCQUF3QjtBQUN4Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jc3MuanM/ZjViOCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKFByaXNtKSB7XG5cblx0dmFyIHN0cmluZyA9IC8oPzpcIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXCJcXFxcXFxyXFxuXSkqXCJ8Jyg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteJ1xcXFxcXHJcXG5dKSonKS87XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmNzcyA9IHtcblx0XHQnY29tbWVudCc6IC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvLyxcblx0XHQnYXRydWxlJzoge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKCdAW1xcXFx3LV0oPzonICsgL1teO3tcXHNcIiddfFxccysoPyFcXHMpLy5zb3VyY2UgKyAnfCcgKyBzdHJpbmcuc291cmNlICsgJykqPycgKyAvKD86O3woPz1cXHMqXFx7KSkvLnNvdXJjZSksXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J3J1bGUnOiAvXkBbXFx3LV0rLyxcblx0XHRcdFx0J3NlbGVjdG9yLWZ1bmN0aW9uLWFyZ3VtZW50Jzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC8oXFxic2VsZWN0b3JcXHMqXFwoXFxzKig/IVtcXHMpXSkpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCkpKyg/PVxccypcXCkpLyxcblx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRcdGFsaWFzOiAnc2VsZWN0b3InXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdrZXl3b3JkJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC8oXnxbXlxcdy1dKSg/OmFuZHxub3R8b25seXxvcikoPyFbXFx3LV0pLyxcblx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gU2VlIHJlc3QgYmVsb3dcblx0XHRcdH1cblx0XHR9LFxuXHRcdCd1cmwnOiB7XG5cdFx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG5cdFx0XHRwYXR0ZXJuOiBSZWdFeHAoJ1xcXFxidXJsXFxcXCgoPzonICsgc3RyaW5nLnNvdXJjZSArICd8JyArIC8oPzpbXlxcXFxcXHJcXG4oKVwiJ118XFxcXFtcXHNcXFNdKSovLnNvdXJjZSArICcpXFxcXCknLCAnaScpLFxuXHRcdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdmdW5jdGlvbic6IC9edXJsL2ksXG5cdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9eXFwofFxcKSQvLFxuXHRcdFx0XHQnc3RyaW5nJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnXicgKyBzdHJpbmcuc291cmNlICsgJyQnKSxcblx0XHRcdFx0XHRhbGlhczogJ3VybCdcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0J3NlbGVjdG9yJzoge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKCcoXnxbe31cXFxcc10pW157fVxcXFxzXSg/Oltee307XCJcXCdcXFxcc118XFxcXHMrKD8hW1xcXFxze10pfCcgKyBzdHJpbmcuc291cmNlICsgJykqKD89XFxcXHMqXFxcXHspJyksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQnc3RyaW5nJzoge1xuXHRcdFx0cGF0dGVybjogc3RyaW5nLFxuXHRcdFx0Z3JlZWR5OiB0cnVlXG5cdFx0fSxcblx0XHQncHJvcGVydHknOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W14tXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVstX2EtelxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVstXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo6KS9pLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0J2ltcG9ydGFudCc6IC8haW1wb3J0YW50XFxiL2ksXG5cdFx0J2Z1bmN0aW9uJzoge1xuXHRcdFx0cGF0dGVybjogLyhefFteLWEtejAtOV0pWy1hLXowLTldKyg/PVxcKCkvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdCdwdW5jdHVhdGlvbic6IC9bKCl7fTs6LF0vXG5cdH07XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmNzc1snYXRydWxlJ10uaW5zaWRlLnJlc3QgPSBQcmlzbS5sYW5ndWFnZXMuY3NzO1xuXG5cdHZhciBtYXJrdXAgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuXHRpZiAobWFya3VwKSB7XG5cdFx0bWFya3VwLnRhZy5hZGRJbmxpbmVkKCdzdHlsZScsICdjc3MnKTtcblx0XHRtYXJrdXAudGFnLmFkZEF0dHJpYnV0ZSgnc3R5bGUnLCAnY3NzJyk7XG5cdH1cblxufShQcmlzbSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-css.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-java.js":
/*!*******************************************************!*\
  !*** ./node_modules/prismjs/components/prism-java.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (Prism) {\n\n\tvar keywords = /\\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\\s*[(){}[\\]<>=%~.:,;?+\\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\\b/;\n\n\t// full package (optional) + parent classes (optional)\n\tvar classNamePrefix = /(?:[a-z]\\w*\\s*\\.\\s*)*(?:[A-Z]\\w*\\s*\\.\\s*)*/.source;\n\n\t// based on the java naming conventions\n\tvar className = {\n\t\tpattern: RegExp(/(^|[^\\w.])/.source + classNamePrefix + /[A-Z](?:[\\d_A-Z]*[a-z]\\w*)?\\b/.source),\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'namespace': {\n\t\t\t\tpattern: /^[a-z]\\w*(?:\\s*\\.\\s*[a-z]\\w*)*(?:\\s*\\.)?/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /\\./\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\./\n\t\t}\n\t};\n\n\tPrism.languages.java = Prism.languages.extend('clike', {\n\t\t'string': {\n\t\t\tpattern: /(^|[^\\\\])\"(?:\\\\.|[^\"\\\\\\r\\n])*\"/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t'class-name': [\n\t\t\tclassName,\n\t\t\t{\n\t\t\t\t// variables, parameters, and constructor references\n\t\t\t\t// this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)\n\t\t\t\tpattern: RegExp(/(^|[^\\w.])/.source + classNamePrefix + /[A-Z]\\w*(?=\\s+\\w+\\s*[;,=()]|\\s*(?:\\[[\\s,]*\\]\\s*)?::\\s*new\\b)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: className.inside\n\t\t\t},\n\t\t\t{\n\t\t\t\t// class names based on keyword\n\t\t\t\t// this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)\n\t\t\t\tpattern: RegExp(/(\\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\\s+)/.source + classNamePrefix + /[A-Z]\\w*\\b/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: className.inside\n\t\t\t}\n\t\t],\n\t\t'keyword': keywords,\n\t\t'function': [\n\t\t\tPrism.languages.clike.function,\n\t\t\t{\n\t\t\t\tpattern: /(::\\s*)[a-z_]\\w*/,\n\t\t\t\tlookbehind: true\n\t\t\t}\n\t\t],\n\t\t'number': /\\b0b[01][01_]*L?\\b|\\b0x(?:\\.[\\da-f_p+-]+|[\\da-f_]+(?:\\.[\\da-f_p+-]+)?)\\b|(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?\\d[\\d_]*)?[dfl]?/i,\n\t\t'operator': {\n\t\t\tpattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\\+\\+|&&|\\|\\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'constant': /\\b[A-Z][A-Z_\\d]+\\b/\n\t});\n\n\tPrism.languages.insertBefore('java', 'string', {\n\t\t'triple-quoted-string': {\n\t\t\t// http://openjdk.java.net/jeps/355#Description\n\t\t\tpattern: /\"\"\"[ \\t]*[\\r\\n](?:(?:\"|\"\")?(?:\\\\.|[^\"\\\\]))*\"\"\"/,\n\t\t\tgreedy: true,\n\t\t\talias: 'string'\n\t\t},\n\t\t'char': {\n\t\t\tpattern: /'(?:\\\\.|[^'\\\\\\r\\n]){1,6}'/,\n\t\t\tgreedy: true\n\t\t}\n\t});\n\n\tPrism.languages.insertBefore('java', 'class-name', {\n\t\t'annotation': {\n\t\t\tpattern: /(^|[^.])@\\w+(?:\\s*\\.\\s*\\w+)*/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'generics': {\n\t\t\tpattern: /<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&)|<(?:[\\w\\s,.?]|&(?!&))*>)*>)*>)*>/,\n\t\t\tinside: {\n\t\t\t\t'class-name': className,\n\t\t\t\t'keyword': keywords,\n\t\t\t\t'punctuation': /[<>(),.:]/,\n\t\t\t\t'operator': /[?&|]/\n\t\t\t}\n\t\t},\n\t\t'import': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(\\bimport\\s+)/.source + classNamePrefix + /(?:[A-Z]\\w*|\\*)(?=\\s*;)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': className.inside.namespace,\n\t\t\t\t\t'punctuation': /\\./,\n\t\t\t\t\t'operator': /\\*/,\n\t\t\t\t\t'class-name': /\\w+/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(\\bimport\\s+static\\s+)/.source + classNamePrefix + /(?:\\w+|\\*)(?=\\s*;)/.source),\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'static',\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': className.inside.namespace,\n\t\t\t\t\t'static': /\\b\\w+$/,\n\t\t\t\t\t'punctuation': /\\./,\n\t\t\t\t\t'operator': /\\*/,\n\t\t\t\t\t'class-name': /\\w+/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'namespace': {\n\t\t\tpattern: RegExp(\n\t\t\t\t/(\\b(?:exports|import(?:\\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\\s+)(?!<keyword>)[a-z]\\w*(?:\\.[a-z]\\w*)*\\.?/\n\t\t\t\t\t.source.replace(/<keyword>/g, function () { return keywords.source; })),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /\\./,\n\t\t\t}\n\t\t}\n\t});\n}(Prism));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tamF2YS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSwwVUFBMFUsWUFBWTs7QUFFdFY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx5QkFBeUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tamF2YS5qcz9hZGVkIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoUHJpc20pIHtcblxuXHR2YXIga2V5d29yZHMgPSAvXFxiKD86YWJzdHJhY3R8YXNzZXJ0fGJvb2xlYW58YnJlYWt8Ynl0ZXxjYXNlfGNhdGNofGNoYXJ8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVmYXVsdHxkb3xkb3VibGV8ZWxzZXxlbnVtfGV4cG9ydHN8ZXh0ZW5kc3xmaW5hbHxmaW5hbGx5fGZsb2F0fGZvcnxnb3RvfGlmfGltcGxlbWVudHN8aW1wb3J0fGluc3RhbmNlb2Z8aW50fGludGVyZmFjZXxsb25nfG1vZHVsZXxuYXRpdmV8bmV3fG5vbi1zZWFsZWR8bnVsbHxvcGVufG9wZW5zfHBhY2thZ2V8cGVybWl0c3xwcml2YXRlfHByb3RlY3RlZHxwcm92aWRlc3xwdWJsaWN8cmVjb3JkKD8hXFxzKlsoKXt9W1xcXTw+PSV+LjosOz8rXFwtKi8mfF5dKXxyZXF1aXJlc3xyZXR1cm58c2VhbGVkfHNob3J0fHN0YXRpY3xzdHJpY3RmcHxzdXBlcnxzd2l0Y2h8c3luY2hyb25pemVkfHRoaXN8dGhyb3d8dGhyb3dzfHRvfHRyYW5zaWVudHx0cmFuc2l0aXZlfHRyeXx1c2VzfHZhcnx2b2lkfHZvbGF0aWxlfHdoaWxlfHdpdGh8eWllbGQpXFxiLztcblxuXHQvLyBmdWxsIHBhY2thZ2UgKG9wdGlvbmFsKSArIHBhcmVudCBjbGFzc2VzIChvcHRpb25hbClcblx0dmFyIGNsYXNzTmFtZVByZWZpeCA9IC8oPzpbYS16XVxcdypcXHMqXFwuXFxzKikqKD86W0EtWl1cXHcqXFxzKlxcLlxccyopKi8uc291cmNlO1xuXG5cdC8vIGJhc2VkIG9uIHRoZSBqYXZhIG5hbWluZyBjb252ZW50aW9uc1xuXHR2YXIgY2xhc3NOYW1lID0ge1xuXHRcdHBhdHRlcm46IFJlZ0V4cCgvKF58W15cXHcuXSkvLnNvdXJjZSArIGNsYXNzTmFtZVByZWZpeCArIC9bQS1aXSg/OltcXGRfQS1aXSpbYS16XVxcdyopP1xcYi8uc291cmNlKSxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J25hbWVzcGFjZSc6IHtcblx0XHRcdFx0cGF0dGVybjogL15bYS16XVxcdyooPzpcXHMqXFwuXFxzKlthLXpdXFx3KikqKD86XFxzKlxcLik/Lyxcblx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL1xcLi9cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdwdW5jdHVhdGlvbic6IC9cXC4vXG5cdFx0fVxuXHR9O1xuXG5cdFByaXNtLmxhbmd1YWdlcy5qYXZhID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG5cdFx0J3N0cmluZyc6IHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXlxcXFxdKVwiKD86XFxcXC58W15cIlxcXFxcXHJcXG5dKSpcIi8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0Z3JlZWR5OiB0cnVlXG5cdFx0fSxcblx0XHQnY2xhc3MtbmFtZSc6IFtcblx0XHRcdGNsYXNzTmFtZSxcblx0XHRcdHtcblx0XHRcdFx0Ly8gdmFyaWFibGVzLCBwYXJhbWV0ZXJzLCBhbmQgY29uc3RydWN0b3IgcmVmZXJlbmNlc1xuXHRcdFx0XHQvLyB0aGlzIHRvIHN1cHBvcnQgY2xhc3MgbmFtZXMgKG9yIGdlbmVyaWMgcGFyYW1ldGVycykgd2hpY2ggZG8gbm90IGNvbnRhaW4gYSBsb3dlciBjYXNlIGxldHRlciAoYWxzbyB3b3JrcyBmb3IgbWV0aG9kcylcblx0XHRcdFx0cGF0dGVybjogUmVnRXhwKC8oXnxbXlxcdy5dKS8uc291cmNlICsgY2xhc3NOYW1lUHJlZml4ICsgL1tBLVpdXFx3Kig/PVxccytcXHcrXFxzKls7LD0oKV18XFxzKig/OlxcW1tcXHMsXSpcXF1cXHMqKT86OlxccypuZXdcXGIpLy5zb3VyY2UpLFxuXHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRpbnNpZGU6IGNsYXNzTmFtZS5pbnNpZGVcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdC8vIGNsYXNzIG5hbWVzIGJhc2VkIG9uIGtleXdvcmRcblx0XHRcdFx0Ly8gdGhpcyB0byBzdXBwb3J0IGNsYXNzIG5hbWVzIChvciBnZW5lcmljIHBhcmFtZXRlcnMpIHdoaWNoIGRvIG5vdCBjb250YWluIGEgbG93ZXIgY2FzZSBsZXR0ZXIgKGFsc28gd29ya3MgZm9yIG1ldGhvZHMpXG5cdFx0XHRcdHBhdHRlcm46IFJlZ0V4cCgvKFxcYig/OmNsYXNzfGVudW18ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8aW50ZXJmYWNlfG5ld3xyZWNvcmR8dGhyb3dzKVxccyspLy5zb3VyY2UgKyBjbGFzc05hbWVQcmVmaXggKyAvW0EtWl1cXHcqXFxiLy5zb3VyY2UpLFxuXHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRpbnNpZGU6IGNsYXNzTmFtZS5pbnNpZGVcblx0XHRcdH1cblx0XHRdLFxuXHRcdCdrZXl3b3JkJzoga2V5d29yZHMsXG5cdFx0J2Z1bmN0aW9uJzogW1xuXHRcdFx0UHJpc20ubGFuZ3VhZ2VzLmNsaWtlLmZ1bmN0aW9uLFxuXHRcdFx0e1xuXHRcdFx0XHRwYXR0ZXJuOiAvKDo6XFxzKilbYS16X11cXHcqLyxcblx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0J251bWJlcic6IC9cXGIwYlswMV1bMDFfXSpMP1xcYnxcXGIweCg/OlxcLltcXGRhLWZfcCstXSt8W1xcZGEtZl9dKyg/OlxcLltcXGRhLWZfcCstXSspPylcXGJ8KD86XFxiXFxkW1xcZF9dKig/OlxcLltcXGRfXSopP3xcXEJcXC5cXGRbXFxkX10qKSg/OmVbKy1dP1xcZFtcXGRfXSopP1tkZmxdPy9pLFxuXHRcdCdvcGVyYXRvcic6IHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXi5dKSg/Ojw8PT98Pj4+Pz0/fC0+fC0tfFxcK1xcK3wmJnxcXHxcXHx8Ojp8Wz86fl18Wy0rKi8lJnxeIT08Pl09PykvbSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdCdjb25zdGFudCc6IC9cXGJbQS1aXVtBLVpfXFxkXStcXGIvXG5cdH0pO1xuXG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmEnLCAnc3RyaW5nJywge1xuXHRcdCd0cmlwbGUtcXVvdGVkLXN0cmluZyc6IHtcblx0XHRcdC8vIGh0dHA6Ly9vcGVuamRrLmphdmEubmV0L2plcHMvMzU1I0Rlc2NyaXB0aW9uXG5cdFx0XHRwYXR0ZXJuOiAvXCJcIlwiWyBcXHRdKltcXHJcXG5dKD86KD86XCJ8XCJcIik/KD86XFxcXC58W15cIlxcXFxdKSkqXCJcIlwiLyxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGFsaWFzOiAnc3RyaW5nJ1xuXHRcdH0sXG5cdFx0J2NoYXInOiB7XG5cdFx0XHRwYXR0ZXJuOiAvJyg/OlxcXFwufFteJ1xcXFxcXHJcXG5dKXsxLDZ9Jy8sXG5cdFx0XHRncmVlZHk6IHRydWVcblx0XHR9XG5cdH0pO1xuXG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmEnLCAnY2xhc3MtbmFtZScsIHtcblx0XHQnYW5ub3RhdGlvbic6IHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXi5dKUBcXHcrKD86XFxzKlxcLlxccypcXHcrKSovLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGFsaWFzOiAncHVuY3R1YXRpb24nXG5cdFx0fSxcblx0XHQnZ2VuZXJpY3MnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvPCg/OltcXHdcXHMsLj9dfCYoPyEmKXw8KD86W1xcd1xccywuP118Jig/ISYpfDwoPzpbXFx3XFxzLC4/XXwmKD8hJil8PCg/OltcXHdcXHMsLj9dfCYoPyEmKSkqPikqPikqPikqPi8sXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J2NsYXNzLW5hbWUnOiBjbGFzc05hbWUsXG5cdFx0XHRcdCdrZXl3b3JkJzoga2V5d29yZHMsXG5cdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9bPD4oKSwuOl0vLFxuXHRcdFx0XHQnb3BlcmF0b3InOiAvWz8mfF0vXG5cdFx0XHR9XG5cdFx0fSxcblx0XHQnaW1wb3J0JzogW1xuXHRcdFx0e1xuXHRcdFx0XHRwYXR0ZXJuOiBSZWdFeHAoLyhcXGJpbXBvcnRcXHMrKS8uc291cmNlICsgY2xhc3NOYW1lUHJlZml4ICsgLyg/OltBLVpdXFx3KnxcXCopKD89XFxzKjspLy5zb3VyY2UpLFxuXHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQnbmFtZXNwYWNlJzogY2xhc3NOYW1lLmluc2lkZS5uYW1lc3BhY2UsXG5cdFx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL1xcLi8sXG5cdFx0XHRcdFx0J29wZXJhdG9yJzogL1xcKi8sXG5cdFx0XHRcdFx0J2NsYXNzLW5hbWUnOiAvXFx3Ky9cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0cGF0dGVybjogUmVnRXhwKC8oXFxiaW1wb3J0XFxzK3N0YXRpY1xccyspLy5zb3VyY2UgKyBjbGFzc05hbWVQcmVmaXggKyAvKD86XFx3K3xcXCopKD89XFxzKjspLy5zb3VyY2UpLFxuXHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRhbGlhczogJ3N0YXRpYycsXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCduYW1lc3BhY2UnOiBjbGFzc05hbWUuaW5zaWRlLm5hbWVzcGFjZSxcblx0XHRcdFx0XHQnc3RhdGljJzogL1xcYlxcdyskLyxcblx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXFwuLyxcblx0XHRcdFx0XHQnb3BlcmF0b3InOiAvXFwqLyxcblx0XHRcdFx0XHQnY2xhc3MtbmFtZSc6IC9cXHcrL1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XSxcblx0XHQnbmFtZXNwYWNlJzoge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKFxuXHRcdFx0XHQvKFxcYig/OmV4cG9ydHN8aW1wb3J0KD86XFxzK3N0YXRpYyk/fG1vZHVsZXxvcGVufG9wZW5zfHBhY2thZ2V8cHJvdmlkZXN8cmVxdWlyZXN8dG98dHJhbnNpdGl2ZXx1c2VzfHdpdGgpXFxzKykoPyE8a2V5d29yZD4pW2Etel1cXHcqKD86XFwuW2Etel1cXHcqKSpcXC4/L1xuXHRcdFx0XHRcdC5zb3VyY2UucmVwbGFjZSgvPGtleXdvcmQ+L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtleXdvcmRzLnNvdXJjZTsgfSkpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXFwuLyxcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufShQcmlzbSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-java.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-javascript.js":
/*!*************************************************************!*\
  !*** ./node_modules/prismjs/components/prism-javascript.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Prism.languages.javascript = Prism.languages.extend('clike', {\n\t'class-name': [\n\t\tPrism.languages.clike['class-name'],\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'keyword': [\n\t\t{\n\t\t\tpattern: /((?:^|\\})\\s*)catch\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t],\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n\t'number': {\n\t\tpattern: RegExp(\n\t\t\t/(^|[^\\w$])/.source +\n\t\t\t'(?:' +\n\t\t\t(\n\t\t\t\t// constant\n\t\t\t\t/NaN|Infinity/.source +\n\t\t\t\t'|' +\n\t\t\t\t// binary integer\n\t\t\t\t/0[bB][01]+(?:_[01]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// octal integer\n\t\t\t\t/0[oO][0-7]+(?:_[0-7]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// hexadecimal integer\n\t\t\t\t/0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal bigint\n\t\t\t\t/\\d+(?:_\\d+)*n/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal number (integer or float) but no bigint\n\t\t\t\t/(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source\n\t\t\t) +\n\t\t\t')' +\n\t\t\t/(?![\\w$])/.source\n\t\t),\n\t\tlookbehind: true\n\t},\n\t'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\n\nPrism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: RegExp(\n\t\t\t// lookbehind\n\t\t\t// eslint-disable-next-line regexp/no-dupe-characters-character-class\n\t\t\t/((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source +\n\t\t\t// Regex pattern:\n\t\t\t// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n\t\t\t// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n\t\t\t// with the only syntax, so we have to define 2 different regex patterns.\n\t\t\t/\\//.source +\n\t\t\t'(?:' +\n\t\t\t/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source +\n\t\t\t'|' +\n\t\t\t// `v` flag syntax. This supports 3 levels of nested character classes.\n\t\t\t/(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +\n\t\t\t')' +\n\t\t\t// lookahead\n\t\t\t/(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source\n\t\t),\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'regex-source': {\n\t\t\t\tpattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'language-regex',\n\t\t\t\tinside: Prism.languages.regex\n\t\t\t},\n\t\t\t'regex-delimiter': /^\\/|\\/$/,\n\t\t\t'regex-flags': /^[a-z]+$/,\n\t\t}\n\t},\n\t// This must be declared before keyword because we use \"function\" inside the look-forward\n\t'function-variable': {\n\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n\t\talias: 'function'\n\t},\n\t'parameter': [\n\t\t{\n\t\t\tpattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t}\n\t],\n\t'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n\t'hashbang': {\n\t\tpattern: /^#!.*/,\n\t\tgreedy: true,\n\t\talias: 'comment'\n\t},\n\t'template-string': {\n\t\tpattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'template-punctuation': {\n\t\t\t\tpattern: /^`|`$/,\n\t\t\t\talias: 'string'\n\t\t\t},\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\t'string-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\talias: 'property'\n\t}\n});\n\nPrism.languages.insertBefore('javascript', 'operator', {\n\t'literal-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\talias: 'property'\n\t},\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.markup.tag.addInlined('script', 'javascript');\n\n\t// add attribute support for all DOM events.\n\t// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n\tPrism.languages.markup.tag.addAttribute(\n\t\t/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,\n\t\t'javascript'\n\t);\n}\n\nPrism.languages.js = Prism.languages.javascript;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tamF2YXNjcmlwdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLEdBQUc7QUFDSDtBQUNBLHFEQUFxRCwrSkFBK0o7QUFDcE47QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLG1GQUFtRixFQUFFO0FBQ3JGLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELElBQUk7QUFDbEU7QUFDQTtBQUNBLG1IQUFtSCxJQUFJLFdBQVcsSUFBSTtBQUN0STtBQUNBO0FBQ0Esc0RBQXNELEVBQUU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsdWZBQXVmO0FBQ3ZmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSw2QkFBNkIsT0FBTyxJQUFJLE9BQU8sSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdDQUFnQyxFQUFFLE9BQU8sT0FBTyxJQUFJLE9BQU8sSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixHQUFHO0FBQ3hCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWphdmFzY3JpcHQuanM/MzYwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuXHQnY2xhc3MtbmFtZSc6IFtcblx0XHRQcmlzbS5sYW5ndWFnZXMuY2xpa2VbJ2NsYXNzLW5hbWUnXSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVtfJEEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxcLig/OmNvbnN0cnVjdG9yfHByb3RvdHlwZSkpLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9XG5cdF0sXG5cdCdrZXl3b3JkJzogW1xuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oKD86XnxcXH0pXFxzKiljYXRjaFxcYi8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W14uXXxcXC5cXC5cXC5cXHMqKVxcYig/OmFzfGFzc2VydCg/PVxccypcXHspfGFzeW5jKD89XFxzKig/OmZ1bmN0aW9uXFxifFxcKHxbJFxcd1xceEEwLVxcdUZGRkZdfCQpKXxhd2FpdHxicmVha3xjYXNlfGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5KD89XFxzKig/Olxce3wkKSl8Zm9yfGZyb20oPz1cXHMqKD86WydcIl18JCkpfGZ1bmN0aW9ufCg/OmdldHxzZXQpKD89XFxzKig/OlsjXFxbJFxcd1xceEEwLVxcdUZGRkZdfCQpKXxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHVuZGVmaW5lZHx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKVxcYi8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XSxcblx0Ly8gQWxsb3cgZm9yIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycyAoU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwMDg0NDQpXG5cdCdmdW5jdGlvbic6IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqKD86XFwuXFxzKig/OmFwcGx5fGJpbmR8Y2FsbClcXHMqKT9cXCgpLyxcblx0J251bWJlcic6IHtcblx0XHRwYXR0ZXJuOiBSZWdFeHAoXG5cdFx0XHQvKF58W15cXHckXSkvLnNvdXJjZSArXG5cdFx0XHQnKD86JyArXG5cdFx0XHQoXG5cdFx0XHRcdC8vIGNvbnN0YW50XG5cdFx0XHRcdC9OYU58SW5maW5pdHkvLnNvdXJjZSArXG5cdFx0XHRcdCd8JyArXG5cdFx0XHRcdC8vIGJpbmFyeSBpbnRlZ2VyXG5cdFx0XHRcdC8wW2JCXVswMV0rKD86X1swMV0rKSpuPy8uc291cmNlICtcblx0XHRcdFx0J3wnICtcblx0XHRcdFx0Ly8gb2N0YWwgaW50ZWdlclxuXHRcdFx0XHQvMFtvT11bMC03XSsoPzpfWzAtN10rKSpuPy8uc291cmNlICtcblx0XHRcdFx0J3wnICtcblx0XHRcdFx0Ly8gaGV4YWRlY2ltYWwgaW50ZWdlclxuXHRcdFx0XHQvMFt4WF1bXFxkQS1GYS1mXSsoPzpfW1xcZEEtRmEtZl0rKSpuPy8uc291cmNlICtcblx0XHRcdFx0J3wnICtcblx0XHRcdFx0Ly8gZGVjaW1hbCBiaWdpbnRcblx0XHRcdFx0L1xcZCsoPzpfXFxkKykqbi8uc291cmNlICtcblx0XHRcdFx0J3wnICtcblx0XHRcdFx0Ly8gZGVjaW1hbCBudW1iZXIgKGludGVnZXIgb3IgZmxvYXQpIGJ1dCBubyBiaWdpbnRcblx0XHRcdFx0Lyg/OlxcZCsoPzpfXFxkKykqKD86XFwuKD86XFxkKyg/Ol9cXGQrKSopPyk/fFxcLlxcZCsoPzpfXFxkKykqKSg/OltFZV1bKy1dP1xcZCsoPzpfXFxkKykqKT8vLnNvdXJjZVxuXHRcdFx0KSArXG5cdFx0XHQnKScgK1xuXHRcdFx0Lyg/IVtcXHckXSkvLnNvdXJjZVxuXHRcdCksXG5cdFx0bG9va2JlaGluZDogdHJ1ZVxuXHR9LFxuXHQnb3BlcmF0b3InOiAvLS18XFwrXFwrfFxcKlxcKj0/fD0+fCYmPT98XFx8XFx8PT98WyE9XT09fDw8PT98Pj4+Pz0/fFstKyovJSZ8XiE9PD5dPT98XFwuezN9fFxcP1xcPz0/fFxcP1xcLj98W346XS9cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFsnY2xhc3MtbmFtZSddWzBdLnBhdHRlcm4gPSAvKFxcYig/OmNsYXNzfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfGludGVyZmFjZXxuZXcpXFxzKylbXFx3LlxcXFxdKy87XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAna2V5d29yZCcsIHtcblx0J3JlZ2V4Jzoge1xuXHRcdHBhdHRlcm46IFJlZ0V4cChcblx0XHRcdC8vIGxvb2tiZWhpbmRcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZHVwZS1jaGFyYWN0ZXJzLWNoYXJhY3Rlci1jbGFzc1xuXHRcdFx0LygoPzpefFteJFxcd1xceEEwLVxcdUZGRkYuXCInXFxdKVxcc118XFxiKD86cmV0dXJufHlpZWxkKSlcXHMqKS8uc291cmNlICtcblx0XHRcdC8vIFJlZ2V4IHBhdHRlcm46XG5cdFx0XHQvLyBUaGVyZSBhcmUgMiByZWdleCBwYXR0ZXJucyBoZXJlLiBUaGUgUmVnRXhwIHNldCBub3RhdGlvbiBwcm9wb3NhbCBhZGRlZCBzdXBwb3J0IGZvciBuZXN0ZWQgY2hhcmFjdGVyXG5cdFx0XHQvLyBjbGFzc2VzIGlmIHRoZSBgdmAgZmxhZyBpcyBwcmVzZW50LiBVbmZvcnR1bmF0ZWx5LCBuZXN0ZWQgQ0NzIGFyZSBib3RoIGNvbnRleHQtZnJlZSBhbmQgaW5jb21wYXRpYmxlXG5cdFx0XHQvLyB3aXRoIHRoZSBvbmx5IHN5bnRheCwgc28gd2UgaGF2ZSB0byBkZWZpbmUgMiBkaWZmZXJlbnQgcmVnZXggcGF0dGVybnMuXG5cdFx0XHQvXFwvLy5zb3VyY2UgK1xuXHRcdFx0Jyg/OicgK1xuXHRcdFx0Lyg/OlxcWyg/OlteXFxdXFxcXFxcclxcbl18XFxcXC4pKlxcXXxcXFxcLnxbXi9cXFxcXFxbXFxyXFxuXSkrXFwvW2RnaW15dXNdezAsN30vLnNvdXJjZSArXG5cdFx0XHQnfCcgK1xuXHRcdFx0Ly8gYHZgIGZsYWcgc3ludGF4LiBUaGlzIHN1cHBvcnRzIDMgbGV2ZWxzIG9mIG5lc3RlZCBjaGFyYWN0ZXIgY2xhc3Nlcy5cblx0XHRcdC8oPzpcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLnxcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLnxcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLikqXFxdKSpcXF0pKlxcXXxcXFxcLnxbXi9cXFxcXFxbXFxyXFxuXSkrXFwvW2RnaW15dXNdezAsN312W2RnaW15dXNdezAsN30vLnNvdXJjZSArXG5cdFx0XHQnKScgK1xuXHRcdFx0Ly8gbG9va2FoZWFkXG5cdFx0XHQvKD89KD86XFxzfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSkqXFwqXFwvKSooPzokfFtcXHJcXG4sLjs6fSlcXF1dfFxcL1xcLykpLy5zb3VyY2Vcblx0XHQpLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J3JlZ2V4LXNvdXJjZSc6IHtcblx0XHRcdFx0cGF0dGVybjogL14oXFwvKVtcXHNcXFNdKyg/PVxcL1thLXpdKiQpLyxcblx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0YWxpYXM6ICdsYW5ndWFnZS1yZWdleCcsXG5cdFx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLnJlZ2V4XG5cdFx0XHR9LFxuXHRcdFx0J3JlZ2V4LWRlbGltaXRlcic6IC9eXFwvfFxcLyQvLFxuXHRcdFx0J3JlZ2V4LWZsYWdzJzogL15bYS16XSskLyxcblx0XHR9XG5cdH0sXG5cdC8vIFRoaXMgbXVzdCBiZSBkZWNsYXJlZCBiZWZvcmUga2V5d29yZCBiZWNhdXNlIHdlIHVzZSBcImZ1bmN0aW9uXCIgaW5zaWRlIHRoZSBsb29rLWZvcndhcmRcblx0J2Z1bmN0aW9uLXZhcmlhYmxlJzoge1xuXHRcdHBhdHRlcm46IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqWz06XVxccyooPzphc3luY1xccyopPyg/OlxcYmZ1bmN0aW9uXFxifCg/OlxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpfCg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSopXFxzKj0+KSkvLFxuXHRcdGFsaWFzOiAnZnVuY3Rpb24nXG5cdH0sXG5cdCdwYXJhbWV0ZXInOiBbXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhmdW5jdGlvbig/OlxccysoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKT9cXHMqXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpKS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhefFteJFxcd1xceEEwLVxcdUZGRkZdKSg/IVxccylbXyRhLXpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqPT4pL2ksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXClcXHMqPT4pLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG5cdFx0fSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKCg/OlxcYnxcXHN8XikoPyEoPzphc3xhc3luY3xhd2FpdHxicmVha3xjYXNlfGNhdGNofGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5fGZvcnxmcm9tfGZ1bmN0aW9ufGdldHxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHNldHxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZCkoPyFbJFxcd1xceEEwLVxcdUZGRkZdKSkoPzooPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqXFxzKilcXChcXHMqfFxcXVxccypcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXClcXHMqXFx7KS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuXHRcdH1cblx0XSxcblx0J2NvbnN0YW50JzogL1xcYltBLVpdKD86W0EtWl9dfFxcZHg/KSpcXGIvXG59KTtcblxuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdzdHJpbmcnLCB7XG5cdCdoYXNoYmFuZyc6IHtcblx0XHRwYXR0ZXJuOiAvXiMhLiovLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRhbGlhczogJ2NvbW1lbnQnXG5cdH0sXG5cdCd0ZW1wbGF0ZS1zdHJpbmcnOiB7XG5cdFx0cGF0dGVybjogL2AoPzpcXFxcW1xcc1xcU118XFwkXFx7KD86W157fV18XFx7KD86W157fV18XFx7W159XSpcXH0pKlxcfSkrXFx9fCg/IVxcJFxceylbXlxcXFxgXSkqYC8sXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J3RlbXBsYXRlLXB1bmN0dWF0aW9uJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvXmB8YCQvLFxuXHRcdFx0XHRhbGlhczogJ3N0cmluZydcblx0XHRcdH0sXG5cdFx0XHQnaW50ZXJwb2xhdGlvbic6IHtcblx0XHRcdFx0cGF0dGVybjogLygoPzpefFteXFxcXF0pKD86XFxcXHsyfSkqKVxcJFxceyg/Oltee31dfFxceyg/Oltee31dfFxce1tefV0qXFx9KSpcXH0pK1xcfS8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uJzoge1xuXHRcdFx0XHRcdFx0cGF0dGVybjogL15cXCRcXHt8XFx9JC8sXG5cdFx0XHRcdFx0XHRhbGlhczogJ3B1bmN0dWF0aW9uJ1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVzdDogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdzdHJpbmcnOiAvW1xcc1xcU10rL1xuXHRcdH1cblx0fSxcblx0J3N0cmluZy1wcm9wZXJ0eSc6IHtcblx0XHRwYXR0ZXJuOiAvKCg/Ol58Wyx7XSlbIFxcdF0qKShbXCInXSkoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDIpW15cXFxcXFxyXFxuXSkqXFwyKD89XFxzKjopL20sXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRncmVlZHk6IHRydWUsXG5cdFx0YWxpYXM6ICdwcm9wZXJ0eSdcblx0fVxufSk7XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnb3BlcmF0b3InLCB7XG5cdCdsaXRlcmFsLXByb3BlcnR5Jzoge1xuXHRcdHBhdHRlcm46IC8oKD86XnxbLHtdKVsgXFx0XSopKD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo6KS9tLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0YWxpYXM6ICdwcm9wZXJ0eSdcblx0fSxcbn0pO1xuXG5pZiAoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCkge1xuXHRQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5hZGRJbmxpbmVkKCdzY3JpcHQnLCAnamF2YXNjcmlwdCcpO1xuXG5cdC8vIGFkZCBhdHRyaWJ1dGUgc3VwcG9ydCBmb3IgYWxsIERPTSBldmVudHMuXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cyNTdGFuZGFyZF9ldmVudHNcblx0UHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuYWRkQXR0cmlidXRlKFxuXHRcdC9vbig/OmFib3J0fGJsdXJ8Y2hhbmdlfGNsaWNrfGNvbXBvc2l0aW9uKD86ZW5kfHN0YXJ0fHVwZGF0ZSl8ZGJsY2xpY2t8ZXJyb3J8Zm9jdXMoPzppbnxvdXQpP3xrZXkoPzpkb3dufHVwKXxsb2FkfG1vdXNlKD86ZG93bnxlbnRlcnxsZWF2ZXxtb3ZlfG91dHxvdmVyfHVwKXxyZXNldHxyZXNpemV8c2Nyb2xsfHNlbGVjdHxzbG90Y2hhbmdlfHN1Ym1pdHx1bmxvYWR8d2hlZWwpLy5zb3VyY2UsXG5cdFx0J2phdmFzY3JpcHQnXG5cdCk7XG59XG5cblByaXNtLmxhbmd1YWdlcy5qcyA9IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-javascript.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-markdown.js":
/*!***********************************************************!*\
  !*** ./node_modules/prismjs/components/prism-markdown.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (Prism) {\n\n\t// Allow only one line break\n\tvar inner = /(?:\\\\.|[^\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))/.source;\n\n\t/**\n\t * This function is intended for the creation of the bold or italic pattern.\n\t *\n\t * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.\n\t *\n\t * _Note:_ Keep in mind that this adds a capturing group.\n\t *\n\t * @param {string} pattern\n\t * @returns {RegExp}\n\t */\n\tfunction createInline(pattern) {\n\t\tpattern = pattern.replace(/<inner>/g, function () { return inner; });\n\t\treturn RegExp(/((?:^|[^\\\\])(?:\\\\{2})*)/.source + '(?:' + pattern + ')');\n\t}\n\n\n\tvar tableCell = /(?:\\\\.|``(?:[^`\\r\\n]|`(?!`))+``|`[^`\\r\\n]+`|[^\\\\|\\r\\n`])+/.source;\n\tvar tableRow = /\\|?__(?:\\|__)+\\|?(?:(?:\\n|\\r\\n?)|(?![\\s\\S]))/.source.replace(/__/g, function () { return tableCell; });\n\tvar tableLine = /\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\|?(?:\\n|\\r\\n?)/.source;\n\n\n\tPrism.languages.markdown = Prism.languages.extend('markup', {});\n\tPrism.languages.insertBefore('markdown', 'prolog', {\n\t\t'front-matter-block': {\n\t\t\tpattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /^---|---$/,\n\t\t\t\t'front-matter': {\n\t\t\t\t\tpattern: /\\S+(?:\\s+\\S+)*/,\n\t\t\t\t\talias: ['yaml', 'language-yaml'],\n\t\t\t\t\tinside: Prism.languages.yaml\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'blockquote': {\n\t\t\t// > ...\n\t\t\tpattern: /^>(?:[\\t ]*>)*/m,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'table': {\n\t\t\tpattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),\n\t\t\tinside: {\n\t\t\t\t'table-data-rows': {\n\t\t\t\t\tpattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'table-data': {\n\t\t\t\t\t\t\tpattern: RegExp(tableCell),\n\t\t\t\t\t\t\tinside: Prism.languages.markdown\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': /\\|/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'table-line': {\n\t\t\t\t\tpattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'punctuation': /\\||:?-{3,}:?/\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t'table-header-row': {\n\t\t\t\t\tpattern: RegExp('^' + tableRow + '$'),\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'table-header': {\n\t\t\t\t\t\t\tpattern: RegExp(tableCell),\n\t\t\t\t\t\t\talias: 'important',\n\t\t\t\t\t\t\tinside: Prism.languages.markdown\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': /\\|/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'code': [\n\t\t\t{\n\t\t\t\t// Prefixed by 4 spaces or 1 tab and preceded by an empty line\n\t\t\t\tpattern: /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'keyword'\n\t\t\t},\n\t\t\t{\n\t\t\t\t// ```optional language\n\t\t\t\t// code block\n\t\t\t\t// ```\n\t\t\t\tpattern: /^```[\\s\\S]*?^```$/m,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'code-block': {\n\t\t\t\t\t\tpattern: /^(```.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^```$)/m,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t'code-language': {\n\t\t\t\t\t\tpattern: /^(```).+/,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t'punctuation': /```/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'title': [\n\t\t\t{\n\t\t\t\t// title 1\n\t\t\t\t// =======\n\n\t\t\t\t// title 2\n\t\t\t\t// -------\n\t\t\t\tpattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,\n\t\t\t\talias: 'important',\n\t\t\t\tinside: {\n\t\t\t\t\tpunctuation: /==+$|--+$/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\t// # title 1\n\t\t\t\t// ###### title 6\n\t\t\t\tpattern: /(^\\s*)#.+/m,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'important',\n\t\t\t\tinside: {\n\t\t\t\t\tpunctuation: /^#+|#+$/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'hr': {\n\t\t\t// ***\n\t\t\t// ---\n\t\t\t// * * *\n\t\t\t// -----------\n\t\t\tpattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'list': {\n\t\t\t// * item\n\t\t\t// + item\n\t\t\t// - item\n\t\t\t// 1. item\n\t\t\tpattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'url-reference': {\n\t\t\t// [id]: http://example.com \"Optional title\"\n\t\t\t// [id]: http://example.com 'Optional title'\n\t\t\t// [id]: http://example.com (Optional title)\n\t\t\t// [id]: <http://example.com> \"Optional title\"\n\t\t\tpattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n\t\t\tinside: {\n\t\t\t\t'variable': {\n\t\t\t\t\tpattern: /^(!?\\[)[^\\]]+/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'string': /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n\t\t\t\t'punctuation': /^[\\[\\]!:]|[<>]/\n\t\t\t},\n\t\t\talias: 'url'\n\t\t},\n\t\t'bold': {\n\t\t\t// **strong**\n\t\t\t// __strong__\n\n\t\t\t// allow one nested instance of italic text using the same delimiter\n\t\t\tpattern: createInline(/\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^..)[\\s\\S]+(?=..$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'punctuation': /\\*\\*|__/\n\t\t\t}\n\t\t},\n\t\t'italic': {\n\t\t\t// *em*\n\t\t\t// _em_\n\n\t\t\t// allow one nested instance of bold text using the same delimiter\n\t\t\tpattern: createInline(/\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^.)[\\s\\S]+(?=.$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'punctuation': /[*_]/\n\t\t\t}\n\t\t},\n\t\t'strike': {\n\t\t\t// ~~strike through~~\n\t\t\t// ~strike~\n\t\t\t// eslint-disable-next-line regexp/strict\n\t\t\tpattern: createInline(/(~~?)(?:(?!~)<inner>)+\\2/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^~~?)[\\s\\S]+(?=\\1$)/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'punctuation': /~~?/\n\t\t\t}\n\t\t},\n\t\t'code-snippet': {\n\t\t\t// `code`\n\t\t\t// ``code``\n\t\t\tpattern: /(^|[^\\\\`])(?:``[^`\\r\\n]+(?:`[^`\\r\\n]+)*``(?!`)|`[^`\\r\\n]+`(?!`))/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\talias: ['code', 'keyword']\n\t\t},\n\t\t'url': {\n\t\t\t// [example](http://example.com \"Optional title\")\n\t\t\t// [example][id]\n\t\t\t// [example] [id]\n\t\t\tpattern: createInline(/!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)|[ \\t]?\\[(?:(?!\\])<inner>)+\\])/.source),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'operator': /^!/,\n\t\t\t\t'content': {\n\t\t\t\t\tpattern: /(^\\[)[^\\]]+(?=\\])/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: {} // see below\n\t\t\t\t},\n\t\t\t\t'variable': {\n\t\t\t\t\tpattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'url': {\n\t\t\t\t\tpattern: /(^\\]\\()[^\\s)]+/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t},\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: /(^[ \\t]+)\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t['url', 'bold', 'italic', 'strike'].forEach(function (token) {\n\t\t['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {\n\t\t\tif (token !== inside) {\n\t\t\t\tPrism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];\n\t\t\t}\n\t\t});\n\t});\n\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\tif (env.language !== 'markdown' && env.language !== 'md') {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction walkTokens(tokens) {\n\t\t\tif (!tokens || typeof tokens === 'string') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {\n\t\t\t\tvar token = tokens[i];\n\n\t\t\t\tif (token.type !== 'code') {\n\t\t\t\t\twalkTokens(token.content);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token\n\t\t\t\t * is optional. But the grammar is defined so that there is only one case we have to handle:\n\t\t\t\t *\n\t\t\t\t * token.content = [\n\t\t\t\t *     <span class=\"punctuation\">```</span>,\n\t\t\t\t *     <span class=\"code-language\">xxxx</span>,\n\t\t\t\t *     '\\n', // exactly one new lines (\\r or \\n or \\r\\n)\n\t\t\t\t *     <span class=\"code-block\">...</span>,\n\t\t\t\t *     '\\n', // exactly one new lines again\n\t\t\t\t *     <span class=\"punctuation\">```</span>\n\t\t\t\t * ];\n\t\t\t\t */\n\n\t\t\t\tvar codeLang = token.content[1];\n\t\t\t\tvar codeBlock = token.content[3];\n\n\t\t\t\tif (codeLang && codeBlock &&\n\t\t\t\t\tcodeLang.type === 'code-language' && codeBlock.type === 'code-block' &&\n\t\t\t\t\ttypeof codeLang.content === 'string') {\n\n\t\t\t\t\t// this might be a language that Prism does not support\n\n\t\t\t\t\t// do some replacements to support C++, C#, and F#\n\t\t\t\t\tvar lang = codeLang.content.replace(/\\b#/g, 'sharp').replace(/\\b\\+\\+/g, 'pp');\n\t\t\t\t\t// only use the first word\n\t\t\t\t\tlang = (/[a-z][\\w-]*/i.exec(lang) || [''])[0].toLowerCase();\n\t\t\t\t\tvar alias = 'language-' + lang;\n\n\t\t\t\t\t// add alias\n\t\t\t\t\tif (!codeBlock.alias) {\n\t\t\t\t\t\tcodeBlock.alias = [alias];\n\t\t\t\t\t} else if (typeof codeBlock.alias === 'string') {\n\t\t\t\t\t\tcodeBlock.alias = [codeBlock.alias, alias];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcodeBlock.alias.push(alias);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twalkTokens(env.tokens);\n\t});\n\n\tPrism.hooks.add('wrap', function (env) {\n\t\tif (env.type !== 'code-block') {\n\t\t\treturn;\n\t\t}\n\n\t\tvar codeLang = '';\n\t\tfor (var i = 0, l = env.classes.length; i < l; i++) {\n\t\t\tvar cls = env.classes[i];\n\t\t\tvar match = /language-(.+)/.exec(cls);\n\t\t\tif (match) {\n\t\t\t\tcodeLang = match[1];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tvar grammar = Prism.languages[codeLang];\n\n\t\tif (!grammar) {\n\t\t\tif (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {\n\t\t\t\tvar id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);\n\t\t\t\tenv.attributes['id'] = id;\n\n\t\t\t\tPrism.plugins.autoloader.loadLanguages(codeLang, function () {\n\t\t\t\t\tvar ele = document.getElementById(id);\n\t\t\t\t\tif (ele) {\n\t\t\t\t\t\tele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tenv.content = Prism.highlight(textContent(env.content), grammar, codeLang);\n\t\t}\n\t});\n\n\tvar tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');\n\n\t/**\n\t * A list of known entity names.\n\t *\n\t * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.\n\t *\n\t * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}\n\t */\n\tvar KNOWN_ENTITY_NAMES = {\n\t\t'amp': '&',\n\t\t'lt': '<',\n\t\t'gt': '>',\n\t\t'quot': '\"',\n\t};\n\n\t// IE 11 doesn't support `String.fromCodePoint`\n\tvar fromCodePoint = String.fromCodePoint || String.fromCharCode;\n\n\t/**\n\t * Returns the text content of a given HTML source code string.\n\t *\n\t * @param {string} html\n\t * @returns {string}\n\t */\n\tfunction textContent(html) {\n\t\t// remove all tags\n\t\tvar text = html.replace(tagPattern, '');\n\n\t\t// decode known entities\n\t\ttext = text.replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function (m, code) {\n\t\t\tcode = code.toLowerCase();\n\n\t\t\tif (code[0] === '#') {\n\t\t\t\tvar value;\n\t\t\t\tif (code[1] === 'x') {\n\t\t\t\t\tvalue = parseInt(code.slice(2), 16);\n\t\t\t\t} else {\n\t\t\t\t\tvalue = Number(code.slice(1));\n\t\t\t\t}\n\n\t\t\t\treturn fromCodePoint(value);\n\t\t\t} else {\n\t\t\t\tvar known = KNOWN_ENTITY_NAMES[code];\n\t\t\t\tif (known) {\n\t\t\t\t\treturn known;\n\t\t\t\t}\n\n\t\t\t\t// unable to decode\n\t\t\t\treturn m;\n\t\t\t}\n\t\t});\n\n\t\treturn text;\n\t}\n\n\tPrism.languages.md = Prism.languages.markdown;\n\n}(Prism));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tbWFya2Rvd24uanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLHNEQUFzRCxlQUFlO0FBQ3JFLG1DQUFtQyxFQUFFO0FBQ3JDOzs7QUFHQTtBQUNBLG1HQUFtRyxtQkFBbUI7QUFDdEgsK0JBQStCLEdBQUcsdUJBQXVCLEdBQUc7OztBQUc1RCwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixHQUFHO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxFQUFFLDBCQUEwQixFQUFFO0FBQzFGO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsR0FBRztBQUN6QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsSUFBSSxZQUFZLElBQUksRUFBRTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tbWFya2Rvd24uanM/NTE3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKFByaXNtKSB7XG5cblx0Ly8gQWxsb3cgb25seSBvbmUgbGluZSBicmVha1xuXHR2YXIgaW5uZXIgPSAvKD86XFxcXC58W15cXFxcXFxuXFxyXXwoPzpcXG58XFxyXFxuPykoPyFbXFxyXFxuXSkpLy5zb3VyY2U7XG5cblx0LyoqXG5cdCAqIFRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiB0aGUgYm9sZCBvciBpdGFsaWMgcGF0dGVybi5cblx0ICpcblx0ICogVGhpcyBhbHNvIGFkZHMgYSBsb29rYmVoaW5kIGdyb3VwIHRvIHRoZSBnaXZlbiBwYXR0ZXJuIHRvIGVuc3VyZSB0aGF0IHRoZSBwYXR0ZXJuIGlzIG5vdCBiYWNrc2xhc2gtZXNjYXBlZC5cblx0ICpcblx0ICogX05vdGU6XyBLZWVwIGluIG1pbmQgdGhhdCB0aGlzIGFkZHMgYSBjYXB0dXJpbmcgZ3JvdXAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG5cdCAqIEByZXR1cm5zIHtSZWdFeHB9XG5cdCAqL1xuXHRmdW5jdGlvbiBjcmVhdGVJbmxpbmUocGF0dGVybikge1xuXHRcdHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoLzxpbm5lcj4vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5uZXI7IH0pO1xuXHRcdHJldHVybiBSZWdFeHAoLygoPzpefFteXFxcXF0pKD86XFxcXHsyfSkqKS8uc291cmNlICsgJyg/OicgKyBwYXR0ZXJuICsgJyknKTtcblx0fVxuXG5cblx0dmFyIHRhYmxlQ2VsbCA9IC8oPzpcXFxcLnxgYCg/OlteYFxcclxcbl18YCg/IWApKStgYHxgW15gXFxyXFxuXStgfFteXFxcXHxcXHJcXG5gXSkrLy5zb3VyY2U7XG5cdHZhciB0YWJsZVJvdyA9IC9cXHw/X18oPzpcXHxfXykrXFx8Pyg/Oig/OlxcbnxcXHJcXG4/KXwoPyFbXFxzXFxTXSkpLy5zb3VyY2UucmVwbGFjZSgvX18vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGFibGVDZWxsOyB9KTtcblx0dmFyIHRhYmxlTGluZSA9IC9cXHw/WyBcXHRdKjo/LXszLH06P1sgXFx0XSooPzpcXHxbIFxcdF0qOj8tezMsfTo/WyBcXHRdKikrXFx8Pyg/OlxcbnxcXHJcXG4/KS8uc291cmNlO1xuXG5cblx0UHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnbWFya3VwJywge30pO1xuXHRQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrZG93bicsICdwcm9sb2cnLCB7XG5cdFx0J2Zyb250LW1hdHRlci1ibG9jayc6IHtcblx0XHRcdHBhdHRlcm46IC8oXig/OlxccypbXFxyXFxuXSk/KS0tLSg/IS4pW1xcc1xcU10qP1tcXHJcXG5dLS0tKD8hLikvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXi0tLXwtLS0kLyxcblx0XHRcdFx0J2Zyb250LW1hdHRlcic6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvXFxTKyg/OlxccytcXFMrKSovLFxuXHRcdFx0XHRcdGFsaWFzOiBbJ3lhbWwnLCAnbGFuZ3VhZ2UteWFtbCddLFxuXHRcdFx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLnlhbWxcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0J2Jsb2NrcXVvdGUnOiB7XG5cdFx0XHQvLyA+IC4uLlxuXHRcdFx0cGF0dGVybjogL14+KD86W1xcdCBdKj4pKi9tLFxuXHRcdFx0YWxpYXM6ICdwdW5jdHVhdGlvbidcblx0XHR9LFxuXHRcdCd0YWJsZSc6IHtcblx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnXicgKyB0YWJsZVJvdyArIHRhYmxlTGluZSArICcoPzonICsgdGFibGVSb3cgKyAnKSonLCAnbScpLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCd0YWJsZS1kYXRhLXJvd3MnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogUmVnRXhwKCdeKCcgKyB0YWJsZVJvdyArIHRhYmxlTGluZSArICcpKD86JyArIHRhYmxlUm93ICsgJykqJCcpLFxuXHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0XHQndGFibGUtZGF0YSc6IHtcblx0XHRcdFx0XHRcdFx0cGF0dGVybjogUmVnRXhwKHRhYmxlQ2VsbCksXG5cdFx0XHRcdFx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL1xcfC9cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdCd0YWJsZS1saW5lJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnXignICsgdGFibGVSb3cgKyAnKScgKyB0YWJsZUxpbmUgKyAnJCcpLFxuXHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXFx8fDo/LXszLH06Py9cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdCd0YWJsZS1oZWFkZXItcm93Jzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnXicgKyB0YWJsZVJvdyArICckJyksXG5cdFx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0XHQndGFibGUtaGVhZGVyJzoge1xuXHRcdFx0XHRcdFx0XHRwYXR0ZXJuOiBSZWdFeHAodGFibGVDZWxsKSxcblx0XHRcdFx0XHRcdFx0YWxpYXM6ICdpbXBvcnRhbnQnLFxuXHRcdFx0XHRcdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5tYXJrZG93blxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9cXHwvXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQnY29kZSc6IFtcblx0XHRcdHtcblx0XHRcdFx0Ly8gUHJlZml4ZWQgYnkgNCBzcGFjZXMgb3IgMSB0YWIgYW5kIHByZWNlZGVkIGJ5IGFuIGVtcHR5IGxpbmVcblx0XHRcdFx0cGF0dGVybjogLygoPzpefFxcbilbIFxcdF0qXFxufCg/Ol58XFxyXFxuPylbIFxcdF0qXFxyXFxuPykoPzogezR9fFxcdCkuKyg/Oig/OlxcbnxcXHJcXG4/KSg/OiB7NH18XFx0KS4rKSovLFxuXHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRhbGlhczogJ2tleXdvcmQnXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHQvLyBgYGBvcHRpb25hbCBsYW5ndWFnZVxuXHRcdFx0XHQvLyBjb2RlIGJsb2NrXG5cdFx0XHRcdC8vIGBgYFxuXHRcdFx0XHRwYXR0ZXJuOiAvXmBgYFtcXHNcXFNdKj9eYGBgJC9tLFxuXHRcdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdjb2RlLWJsb2NrJzoge1xuXHRcdFx0XHRcdFx0cGF0dGVybjogL14oYGBgLiooPzpcXG58XFxyXFxuPykpW1xcc1xcU10rPyg/PSg/OlxcbnxcXHJcXG4/KV5gYGAkKS9tLFxuXHRcdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0J2NvZGUtbGFuZ3VhZ2UnOiB7XG5cdFx0XHRcdFx0XHRwYXR0ZXJuOiAvXihgYGApLisvLFxuXHRcdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL2BgYC9cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF0sXG5cdFx0J3RpdGxlJzogW1xuXHRcdFx0e1xuXHRcdFx0XHQvLyB0aXRsZSAxXG5cdFx0XHRcdC8vID09PT09PT1cblxuXHRcdFx0XHQvLyB0aXRsZSAyXG5cdFx0XHRcdC8vIC0tLS0tLS1cblx0XHRcdFx0cGF0dGVybjogL1xcUy4qKD86XFxufFxcclxcbj8pKD86PT0rfC0tKykoPz1bIFxcdF0qJCkvbSxcblx0XHRcdFx0YWxpYXM6ICdpbXBvcnRhbnQnLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHRwdW5jdHVhdGlvbjogLz09KyR8LS0rJC9cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0Ly8gIyB0aXRsZSAxXG5cdFx0XHRcdC8vICMjIyMjIyB0aXRsZSA2XG5cdFx0XHRcdHBhdHRlcm46IC8oXlxccyopIy4rL20sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGFsaWFzOiAnaW1wb3J0YW50Jyxcblx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0cHVuY3R1YXRpb246IC9eIyt8IyskL1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XSxcblx0XHQnaHInOiB7XG5cdFx0XHQvLyAqKipcblx0XHRcdC8vIC0tLVxuXHRcdFx0Ly8gKiAqICpcblx0XHRcdC8vIC0tLS0tLS0tLS0tXG5cdFx0XHRwYXR0ZXJuOiAvKF5cXHMqKShbKi1dKSg/OltcXHQgXSpcXDIpezIsfSg/PVxccyokKS9tLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGFsaWFzOiAncHVuY3R1YXRpb24nXG5cdFx0fSxcblx0XHQnbGlzdCc6IHtcblx0XHRcdC8vICogaXRlbVxuXHRcdFx0Ly8gKyBpdGVtXG5cdFx0XHQvLyAtIGl0ZW1cblx0XHRcdC8vIDEuIGl0ZW1cblx0XHRcdHBhdHRlcm46IC8oXlxccyopKD86WyorLV18XFxkK1xcLikoPz1bXFx0IF0uKS9tLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGFsaWFzOiAncHVuY3R1YXRpb24nXG5cdFx0fSxcblx0XHQndXJsLXJlZmVyZW5jZSc6IHtcblx0XHRcdC8vIFtpZF06IGh0dHA6Ly9leGFtcGxlLmNvbSBcIk9wdGlvbmFsIHRpdGxlXCJcblx0XHRcdC8vIFtpZF06IGh0dHA6Ly9leGFtcGxlLmNvbSAnT3B0aW9uYWwgdGl0bGUnXG5cdFx0XHQvLyBbaWRdOiBodHRwOi8vZXhhbXBsZS5jb20gKE9wdGlvbmFsIHRpdGxlKVxuXHRcdFx0Ly8gW2lkXTogPGh0dHA6Ly9leGFtcGxlLmNvbT4gXCJPcHRpb25hbCB0aXRsZVwiXG5cdFx0XHRwYXR0ZXJuOiAvIT9cXFtbXlxcXV0rXFxdOltcXHQgXSsoPzpcXFMrfDwoPzpcXFxcLnxbXj5cXFxcXSkrPikoPzpbXFx0IF0rKD86XCIoPzpcXFxcLnxbXlwiXFxcXF0pKlwifCcoPzpcXFxcLnxbXidcXFxcXSkqJ3xcXCgoPzpcXFxcLnxbXilcXFxcXSkqXFwpKSk/Lyxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQndmFyaWFibGUnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogL14oIT9cXFspW15cXF1dKy8sXG5cdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQnc3RyaW5nJzogLyg/OlwiKD86XFxcXC58W15cIlxcXFxdKSpcInwnKD86XFxcXC58W14nXFxcXF0pKid8XFwoKD86XFxcXC58W14pXFxcXF0pKlxcKSkkLyxcblx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL15bXFxbXFxdITpdfFs8Pl0vXG5cdFx0XHR9LFxuXHRcdFx0YWxpYXM6ICd1cmwnXG5cdFx0fSxcblx0XHQnYm9sZCc6IHtcblx0XHRcdC8vICoqc3Ryb25nKipcblx0XHRcdC8vIF9fc3Ryb25nX19cblxuXHRcdFx0Ly8gYWxsb3cgb25lIG5lc3RlZCBpbnN0YW5jZSBvZiBpdGFsaWMgdGV4dCB1c2luZyB0aGUgc2FtZSBkZWxpbWl0ZXJcblx0XHRcdHBhdHRlcm46IGNyZWF0ZUlubGluZSgvXFxiX18oPzooPyFfKTxpbm5lcj58Xyg/Oig/IV8pPGlubmVyPikrXykrX19cXGJ8XFwqXFwqKD86KD8hXFwqKTxpbm5lcj58XFwqKD86KD8hXFwqKTxpbm5lcj4pK1xcKikrXFwqXFwqLy5zb3VyY2UpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQnY29udGVudCc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvKF4uLilbXFxzXFxTXSsoPz0uLiQpLyxcblx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRcdGluc2lkZToge30gLy8gc2VlIGJlbG93XG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9cXCpcXCp8X18vXG5cdFx0XHR9XG5cdFx0fSxcblx0XHQnaXRhbGljJzoge1xuXHRcdFx0Ly8gKmVtKlxuXHRcdFx0Ly8gX2VtX1xuXG5cdFx0XHQvLyBhbGxvdyBvbmUgbmVzdGVkIGluc3RhbmNlIG9mIGJvbGQgdGV4dCB1c2luZyB0aGUgc2FtZSBkZWxpbWl0ZXJcblx0XHRcdHBhdHRlcm46IGNyZWF0ZUlubGluZSgvXFxiXyg/Oig/IV8pPGlubmVyPnxfXyg/Oig/IV8pPGlubmVyPikrX18pK19cXGJ8XFwqKD86KD8hXFwqKTxpbm5lcj58XFwqXFwqKD86KD8hXFwqKTxpbm5lcj4pK1xcKlxcKikrXFwqLy5zb3VyY2UpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQnY29udGVudCc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvKF4uKVtcXHNcXFNdKyg/PS4kKS8sXG5cdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0XHRpbnNpZGU6IHt9IC8vIHNlZSBiZWxvd1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQncHVuY3R1YXRpb24nOiAvWypfXS9cblx0XHRcdH1cblx0XHR9LFxuXHRcdCdzdHJpa2UnOiB7XG5cdFx0XHQvLyB+fnN0cmlrZSB0aHJvdWdofn5cblx0XHRcdC8vIH5zdHJpa2V+XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL3N0cmljdFxuXHRcdFx0cGF0dGVybjogY3JlYXRlSW5saW5lKC8ofn4/KSg/Oig/IX4pPGlubmVyPikrXFwyLy5zb3VyY2UpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQnY29udGVudCc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvKF5+fj8pW1xcc1xcU10rKD89XFwxJCkvLFxuXHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdFx0aW5zaWRlOiB7fSAvLyBzZWUgYmVsb3dcblx0XHRcdFx0fSxcblx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL35+Py9cblx0XHRcdH1cblx0XHR9LFxuXHRcdCdjb2RlLXNuaXBwZXQnOiB7XG5cdFx0XHQvLyBgY29kZWBcblx0XHRcdC8vIGBgY29kZWBgXG5cdFx0XHRwYXR0ZXJuOiAvKF58W15cXFxcYF0pKD86YGBbXmBcXHJcXG5dKyg/OmBbXmBcXHJcXG5dKykqYGAoPyFgKXxgW15gXFxyXFxuXStgKD8hYCkpLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRhbGlhczogWydjb2RlJywgJ2tleXdvcmQnXVxuXHRcdH0sXG5cdFx0J3VybCc6IHtcblx0XHRcdC8vIFtleGFtcGxlXShodHRwOi8vZXhhbXBsZS5jb20gXCJPcHRpb25hbCB0aXRsZVwiKVxuXHRcdFx0Ly8gW2V4YW1wbGVdW2lkXVxuXHRcdFx0Ly8gW2V4YW1wbGVdIFtpZF1cblx0XHRcdHBhdHRlcm46IGNyZWF0ZUlubGluZSgvIT9cXFsoPzooPyFcXF0pPGlubmVyPikrXFxdKD86XFwoW15cXHMpXSsoPzpbXFx0IF0rXCIoPzpcXFxcLnxbXlwiXFxcXF0pKlwiKT9cXCl8WyBcXHRdP1xcWyg/Oig/IVxcXSk8aW5uZXI+KStcXF0pLy5zb3VyY2UpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQnb3BlcmF0b3InOiAvXiEvLFxuXHRcdFx0XHQnY29udGVudCc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvKF5cXFspW15cXF1dKyg/PVxcXSkvLFxuXHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdFx0aW5zaWRlOiB7fSAvLyBzZWUgYmVsb3dcblx0XHRcdFx0fSxcblx0XHRcdFx0J3ZhcmlhYmxlJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC8oXlxcXVsgXFx0XT9cXFspW15cXF1dKyg/PVxcXSQpLyxcblx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCd1cmwnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogLyheXFxdXFwoKVteXFxzKV0rLyxcblx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdzdHJpbmcnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogLyheWyBcXHRdKylcIig/OlxcXFwufFteXCJcXFxcXSkqXCIoPz1cXCkkKS8sXG5cdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRbJ3VybCcsICdib2xkJywgJ2l0YWxpYycsICdzdHJpa2UnXS5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuXHRcdFsndXJsJywgJ2JvbGQnLCAnaXRhbGljJywgJ3N0cmlrZScsICdjb2RlLXNuaXBwZXQnXS5mb3JFYWNoKGZ1bmN0aW9uIChpbnNpZGUpIHtcblx0XHRcdGlmICh0b2tlbiAhPT0gaW5zaWRlKSB7XG5cdFx0XHRcdFByaXNtLmxhbmd1YWdlcy5tYXJrZG93blt0b2tlbl0uaW5zaWRlLmNvbnRlbnQuaW5zaWRlW2luc2lkZV0gPSBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd25baW5zaWRlXTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cblx0UHJpc20uaG9va3MuYWRkKCdhZnRlci10b2tlbml6ZScsIGZ1bmN0aW9uIChlbnYpIHtcblx0XHRpZiAoZW52Lmxhbmd1YWdlICE9PSAnbWFya2Rvd24nICYmIGVudi5sYW5ndWFnZSAhPT0gJ21kJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdhbGtUb2tlbnModG9rZW5zKSB7XG5cdFx0XHRpZiAoIXRva2VucyB8fCB0eXBlb2YgdG9rZW5zID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdFx0aWYgKHRva2VuLnR5cGUgIT09ICdjb2RlJykge1xuXHRcdFx0XHRcdHdhbGtUb2tlbnModG9rZW4uY29udGVudCk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKlxuXHRcdFx0XHQgKiBBZGQgdGhlIGNvcnJlY3QgYGxhbmd1YWdlLXh4eHhgIGNsYXNzIHRvIHRoaXMgY29kZSBibG9jay4gS2VlcCBpbiBtaW5kIHRoYXQgdGhlIGBjb2RlLWxhbmd1YWdlYCB0b2tlblxuXHRcdFx0XHQgKiBpcyBvcHRpb25hbC4gQnV0IHRoZSBncmFtbWFyIGlzIGRlZmluZWQgc28gdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBjYXNlIHdlIGhhdmUgdG8gaGFuZGxlOlxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiB0b2tlbi5jb250ZW50ID0gW1xuXHRcdFx0XHQgKiAgICAgPHNwYW4gY2xhc3M9XCJwdW5jdHVhdGlvblwiPmBgYDwvc3Bhbj4sXG5cdFx0XHRcdCAqICAgICA8c3BhbiBjbGFzcz1cImNvZGUtbGFuZ3VhZ2VcIj54eHh4PC9zcGFuPixcblx0XHRcdFx0ICogICAgICdcXG4nLCAvLyBleGFjdGx5IG9uZSBuZXcgbGluZXMgKFxcciBvciBcXG4gb3IgXFxyXFxuKVxuXHRcdFx0XHQgKiAgICAgPHNwYW4gY2xhc3M9XCJjb2RlLWJsb2NrXCI+Li4uPC9zcGFuPixcblx0XHRcdFx0ICogICAgICdcXG4nLCAvLyBleGFjdGx5IG9uZSBuZXcgbGluZXMgYWdhaW5cblx0XHRcdFx0ICogICAgIDxzcGFuIGNsYXNzPVwicHVuY3R1YXRpb25cIj5gYGA8L3NwYW4+XG5cdFx0XHRcdCAqIF07XG5cdFx0XHRcdCAqL1xuXG5cdFx0XHRcdHZhciBjb2RlTGFuZyA9IHRva2VuLmNvbnRlbnRbMV07XG5cdFx0XHRcdHZhciBjb2RlQmxvY2sgPSB0b2tlbi5jb250ZW50WzNdO1xuXG5cdFx0XHRcdGlmIChjb2RlTGFuZyAmJiBjb2RlQmxvY2sgJiZcblx0XHRcdFx0XHRjb2RlTGFuZy50eXBlID09PSAnY29kZS1sYW5ndWFnZScgJiYgY29kZUJsb2NrLnR5cGUgPT09ICdjb2RlLWJsb2NrJyAmJlxuXHRcdFx0XHRcdHR5cGVvZiBjb2RlTGFuZy5jb250ZW50ID09PSAnc3RyaW5nJykge1xuXG5cdFx0XHRcdFx0Ly8gdGhpcyBtaWdodCBiZSBhIGxhbmd1YWdlIHRoYXQgUHJpc20gZG9lcyBub3Qgc3VwcG9ydFxuXG5cdFx0XHRcdFx0Ly8gZG8gc29tZSByZXBsYWNlbWVudHMgdG8gc3VwcG9ydCBDKyssIEMjLCBhbmQgRiNcblx0XHRcdFx0XHR2YXIgbGFuZyA9IGNvZGVMYW5nLmNvbnRlbnQucmVwbGFjZSgvXFxiIy9nLCAnc2hhcnAnKS5yZXBsYWNlKC9cXGJcXCtcXCsvZywgJ3BwJyk7XG5cdFx0XHRcdFx0Ly8gb25seSB1c2UgdGhlIGZpcnN0IHdvcmRcblx0XHRcdFx0XHRsYW5nID0gKC9bYS16XVtcXHctXSovaS5leGVjKGxhbmcpIHx8IFsnJ10pWzBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0dmFyIGFsaWFzID0gJ2xhbmd1YWdlLScgKyBsYW5nO1xuXG5cdFx0XHRcdFx0Ly8gYWRkIGFsaWFzXG5cdFx0XHRcdFx0aWYgKCFjb2RlQmxvY2suYWxpYXMpIHtcblx0XHRcdFx0XHRcdGNvZGVCbG9jay5hbGlhcyA9IFthbGlhc107XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY29kZUJsb2NrLmFsaWFzID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0Y29kZUJsb2NrLmFsaWFzID0gW2NvZGVCbG9jay5hbGlhcywgYWxpYXNdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb2RlQmxvY2suYWxpYXMucHVzaChhbGlhcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0d2Fsa1Rva2VucyhlbnYudG9rZW5zKTtcblx0fSk7XG5cblx0UHJpc20uaG9va3MuYWRkKCd3cmFwJywgZnVuY3Rpb24gKGVudikge1xuXHRcdGlmIChlbnYudHlwZSAhPT0gJ2NvZGUtYmxvY2snKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGNvZGVMYW5nID0gJyc7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBlbnYuY2xhc3Nlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjbHMgPSBlbnYuY2xhc3Nlc1tpXTtcblx0XHRcdHZhciBtYXRjaCA9IC9sYW5ndWFnZS0oLispLy5leGVjKGNscyk7XG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0Y29kZUxhbmcgPSBtYXRjaFsxXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGdyYW1tYXIgPSBQcmlzbS5sYW5ndWFnZXNbY29kZUxhbmddO1xuXG5cdFx0aWYgKCFncmFtbWFyKSB7XG5cdFx0XHRpZiAoY29kZUxhbmcgJiYgY29kZUxhbmcgIT09ICdub25lJyAmJiBQcmlzbS5wbHVnaW5zLmF1dG9sb2FkZXIpIHtcblx0XHRcdFx0dmFyIGlkID0gJ21kLScgKyBuZXcgRGF0ZSgpLnZhbHVlT2YoKSArICctJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlMTYpO1xuXHRcdFx0XHRlbnYuYXR0cmlidXRlc1snaWQnXSA9IGlkO1xuXG5cdFx0XHRcdFByaXNtLnBsdWdpbnMuYXV0b2xvYWRlci5sb2FkTGFuZ3VhZ2VzKGNvZGVMYW5nLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dmFyIGVsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcblx0XHRcdFx0XHRpZiAoZWxlKSB7XG5cdFx0XHRcdFx0XHRlbGUuaW5uZXJIVE1MID0gUHJpc20uaGlnaGxpZ2h0KGVsZS50ZXh0Q29udGVudCwgUHJpc20ubGFuZ3VhZ2VzW2NvZGVMYW5nXSwgY29kZUxhbmcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVudi5jb250ZW50ID0gUHJpc20uaGlnaGxpZ2h0KHRleHRDb250ZW50KGVudi5jb250ZW50KSwgZ3JhbW1hciwgY29kZUxhbmcpO1xuXHRcdH1cblx0fSk7XG5cblx0dmFyIHRhZ1BhdHRlcm4gPSBSZWdFeHAoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcucGF0dGVybi5zb3VyY2UsICdnaScpO1xuXG5cdC8qKlxuXHQgKiBBIGxpc3Qgb2Yga25vd24gZW50aXR5IG5hbWVzLlxuXHQgKlxuXHQgKiBUaGlzIHdpbGwgYWx3YXlzIGJlIGluY29tcGxldGUgdG8gc2F2ZSBzcGFjZS4gVGhlIGN1cnJlbnQgbGlzdCBpcyB0aGUgb25lIHVzZWQgYnkgbG93ZGFzaCdzIHVuZXNjYXBlIGZ1bmN0aW9uLlxuXHQgKlxuXHQgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzJkYTAyNGMzYjRmOTk0N2E0ODUxNzYzOWRlNzU2MDQ1N2NkNGVjNmMvdW5lc2NhcGUuanMjTDJ9XG5cdCAqL1xuXHR2YXIgS05PV05fRU5USVRZX05BTUVTID0ge1xuXHRcdCdhbXAnOiAnJicsXG5cdFx0J2x0JzogJzwnLFxuXHRcdCdndCc6ICc+Jyxcblx0XHQncXVvdCc6ICdcIicsXG5cdH07XG5cblx0Ly8gSUUgMTEgZG9lc24ndCBzdXBwb3J0IGBTdHJpbmcuZnJvbUNvZGVQb2ludGBcblx0dmFyIGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYSBnaXZlbiBIVE1MIHNvdXJjZSBjb2RlIHN0cmluZy5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGZ1bmN0aW9uIHRleHRDb250ZW50KGh0bWwpIHtcblx0XHQvLyByZW1vdmUgYWxsIHRhZ3Ncblx0XHR2YXIgdGV4dCA9IGh0bWwucmVwbGFjZSh0YWdQYXR0ZXJuLCAnJyk7XG5cblx0XHQvLyBkZWNvZGUga25vd24gZW50aXRpZXNcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC8mKFxcd3sxLDh9fCN4P1tcXGRhLWZdezEsOH0pOy9naSwgZnVuY3Rpb24gKG0sIGNvZGUpIHtcblx0XHRcdGNvZGUgPSBjb2RlLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmIChjb2RlWzBdID09PSAnIycpIHtcblx0XHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0XHRpZiAoY29kZVsxXSA9PT0gJ3gnKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBwYXJzZUludChjb2RlLnNsaWNlKDIpLCAxNik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBOdW1iZXIoY29kZS5zbGljZSgxKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZnJvbUNvZGVQb2ludCh2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIga25vd24gPSBLTk9XTl9FTlRJVFlfTkFNRVNbY29kZV07XG5cdFx0XHRcdGlmIChrbm93bikge1xuXHRcdFx0XHRcdHJldHVybiBrbm93bjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHVuYWJsZSB0byBkZWNvZGVcblx0XHRcdFx0cmV0dXJuIG07XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGV4dDtcblx0fVxuXG5cdFByaXNtLmxhbmd1YWdlcy5tZCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrZG93bjtcblxufShQcmlzbSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-markdown.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-markup.js":
/*!*********************************************************!*\
  !*** ./node_modules/prismjs/components/prism-markup.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Prism.languages.markup = {\n\t'comment': {\n\t\tpattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n\t\tgreedy: true\n\t},\n\t'prolog': {\n\t\tpattern: /<\\?[\\s\\S]+?\\?>/,\n\t\tgreedy: true\n\t},\n\t'doctype': {\n\t\t// https://www.w3.org/TR/xml/#NT-doctypedecl\n\t\tpattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'internal-subset': {\n\t\t\t\tpattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /\"[^\"]*\"|'[^']*'/,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t'punctuation': /^<!|>$|[[\\]]/,\n\t\t\t'doctype-tag': /^DOCTYPE/i,\n\t\t\t'name': /[^\\s<>'\"]+/\n\t\t}\n\t},\n\t'cdata': {\n\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\tgreedy: true\n\t},\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'special-attr': [],\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^(\\s*)[\"']|[\"']$/,\n\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': [\n\t\t{\n\t\t\tpattern: /&[\\da-z]{1,8};/i,\n\t\t\talias: 'named-entity'\n\t\t},\n\t\t/&#x?[\\da-f]{1,8};/i\n\t]\n};\n\nPrism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n\tPrism.languages.markup['entity'];\nPrism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nObject.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n\t/**\n\t * Adds an inlined language to markup.\n\t *\n\t * An example of an inlined language is CSS with `<style>` tags.\n\t *\n\t * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addInlined('style', 'css');\n\t */\n\tvalue: function addInlined(tagName, lang) {\n\t\tvar includedCdataInside = {};\n\t\tincludedCdataInside['language-' + lang] = {\n\t\t\tpattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\t\tincludedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n\n\t\tvar inside = {\n\t\t\t'included-cdata': {\n\t\t\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\t\t\tinside: includedCdataInside\n\t\t\t}\n\t\t};\n\t\tinside['language-' + lang] = {\n\t\t\tpattern: /[\\s\\S]+/,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\n\t\tvar def = {};\n\t\tdef[tagName] = {\n\t\t\tpattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: inside\n\t\t};\n\n\t\tPrism.languages.insertBefore('markup', 'cdata', def);\n\t}\n});\nObject.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n\t/**\n\t * Adds an pattern to highlight languages embedded in HTML attributes.\n\t *\n\t * An example of an inlined language is CSS with `style` attributes.\n\t *\n\t * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addAttribute('style', 'css');\n\t */\n\tvalue: function (attrName, lang) {\n\t\tPrism.languages.markup.tag.inside['special-attr'].push({\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[\"'\\s])/.source + '(?:' + attrName + ')' + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n\t\t\t\t'i'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'attr-name': /^[^\\s=]+/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /=[\\s\\S]+/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'value': {\n\t\t\t\t\t\t\tpattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: [lang, 'language-' + lang],\n\t\t\t\t\t\t\tinside: Prism.languages[lang]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/\"|'/\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\nPrism.languages.xml = Prism.languages.extend('markup', {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tbWFya3VwLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBLEdBQUc7QUFDSCxlQUFlLEtBQUs7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtJQUErSSxpQkFBaUI7QUFDaEs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW1hcmt1cC5qcz9mZGY4Il0sInNvdXJjZXNDb250ZW50IjpbIlByaXNtLmxhbmd1YWdlcy5tYXJrdXAgPSB7XG5cdCdjb21tZW50Jzoge1xuXHRcdHBhdHRlcm46IC88IS0tKD86KD8hPCEtLSlbXFxzXFxTXSkqPy0tPi8sXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH0sXG5cdCdwcm9sb2cnOiB7XG5cdFx0cGF0dGVybjogLzxcXD9bXFxzXFxTXSs/XFw/Pi8sXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH0sXG5cdCdkb2N0eXBlJzoge1xuXHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi94bWwvI05ULWRvY3R5cGVkZWNsXG5cdFx0cGF0dGVybjogLzwhRE9DVFlQRSg/OltePlwiJ1tcXF1dfFwiW15cIl0qXCJ8J1teJ10qJykrKD86XFxbKD86W148XCInXFxdXXxcIlteXCJdKlwifCdbXiddKid8PCg/ISEtLSl8PCEtLSg/OlteLV18LSg/IS0+KSkqLS0+KSpcXF1cXHMqKT8+L2ksXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J2ludGVybmFsLXN1YnNldCc6IHtcblx0XHRcdFx0cGF0dGVybjogLyheW15cXFtdKlxcWylbXFxzXFxTXSsoPz1cXF0+JCkvLFxuXHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRcdGluc2lkZTogbnVsbCAvLyBzZWUgYmVsb3dcblx0XHRcdH0sXG5cdFx0XHQnc3RyaW5nJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvXCJbXlwiXSpcInwnW14nXSonLyxcblx0XHRcdFx0Z3JlZWR5OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0J3B1bmN0dWF0aW9uJzogL148IXw+JHxbW1xcXV0vLFxuXHRcdFx0J2RvY3R5cGUtdGFnJzogL15ET0NUWVBFL2ksXG5cdFx0XHQnbmFtZSc6IC9bXlxcczw+J1wiXSsvXG5cdFx0fVxuXHR9LFxuXHQnY2RhdGEnOiB7XG5cdFx0cGF0dGVybjogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdPi9pLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQndGFnJzoge1xuXHRcdHBhdHRlcm46IC88XFwvPyg/IVxcZClbXlxccz5cXC89JDwlXSsoPzpcXHMoPzpcXHMqW15cXHM+XFwvPV0rKD86XFxzKj1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKyg/PVtcXHM+XSkpfCg/PVtcXHMvPl0pKSkrKT9cXHMqXFwvPz4vLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCd0YWcnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9ePFxcLz9bXlxccz5cXC9dKy8sXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9ePFxcLz8vLFxuXHRcdFx0XHRcdCduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQnc3BlY2lhbC1hdHRyJzogW10sXG5cdFx0XHQnYXR0ci12YWx1ZSc6IHtcblx0XHRcdFx0cGF0dGVybjogLz1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKykvLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiBbXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHBhdHRlcm46IC9ePS8sXG5cdFx0XHRcdFx0XHRcdGFsaWFzOiAnYXR0ci1lcXVhbHMnXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRwYXR0ZXJuOiAvXihcXHMqKVtcIiddfFtcIiddJC8sXG5cdFx0XHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRdXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQncHVuY3R1YXRpb24nOiAvXFwvPz4vLFxuXHRcdFx0J2F0dHItbmFtZSc6IHtcblx0XHRcdFx0cGF0dGVybjogL1teXFxzPlxcL10rLyxcblx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0J25hbWVzcGFjZSc6IC9eW15cXHM+XFwvOl0rOi9cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXHR9LFxuXHQnZW50aXR5JzogW1xuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8mW1xcZGEtel17MSw4fTsvaSxcblx0XHRcdGFsaWFzOiAnbmFtZWQtZW50aXR5J1xuXHRcdH0sXG5cdFx0LyYjeD9bXFxkYS1mXXsxLDh9Oy9pXG5cdF1cbn07XG5cblByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ3RhZyddLmluc2lkZVsnYXR0ci12YWx1ZSddLmluc2lkZVsnZW50aXR5J10gPVxuXHRQcmlzbS5sYW5ndWFnZXMubWFya3VwWydlbnRpdHknXTtcblByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ2RvY3R5cGUnXS5pbnNpZGVbJ2ludGVybmFsLXN1YnNldCddLmluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5cbi8vIFBsdWdpbiB0byBtYWtlIGVudGl0eSB0aXRsZSBzaG93IHRoZSByZWFsIGVudGl0eSwgaWRlYSBieSBSb21hbiBLb21hcm92XG5QcmlzbS5ob29rcy5hZGQoJ3dyYXAnLCBmdW5jdGlvbiAoZW52KSB7XG5cblx0aWYgKGVudi50eXBlID09PSAnZW50aXR5Jykge1xuXHRcdGVudi5hdHRyaWJ1dGVzWyd0aXRsZSddID0gZW52LmNvbnRlbnQucmVwbGFjZSgvJmFtcDsvLCAnJicpO1xuXHR9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLCAnYWRkSW5saW5lZCcsIHtcblx0LyoqXG5cdCAqIEFkZHMgYW4gaW5saW5lZCBsYW5ndWFnZSB0byBtYXJrdXAuXG5cdCAqXG5cdCAqIEFuIGV4YW1wbGUgb2YgYW4gaW5saW5lZCBsYW5ndWFnZSBpcyBDU1Mgd2l0aCBgPHN0eWxlPmAgdGFncy5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZyB0aGF0IGNvbnRhaW5zIHRoZSBpbmxpbmVkIGxhbmd1YWdlLiBUaGlzIG5hbWUgd2lsbCBiZSB0cmVhdGVkIGFzXG5cdCAqIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nIFRoZSBsYW5ndWFnZSBrZXkuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGFkZElubGluZWQoJ3N0eWxlJywgJ2NzcycpO1xuXHQgKi9cblx0dmFsdWU6IGZ1bmN0aW9uIGFkZElubGluZWQodGFnTmFtZSwgbGFuZykge1xuXHRcdHZhciBpbmNsdWRlZENkYXRhSW5zaWRlID0ge307XG5cdFx0aW5jbHVkZWRDZGF0YUluc2lkZVsnbGFuZ3VhZ2UtJyArIGxhbmddID0ge1xuXHRcdFx0cGF0dGVybjogLyhePCFcXFtDREFUQVxcWylbXFxzXFxTXSs/KD89XFxdXFxdPiQpL2ksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXNbbGFuZ11cblx0XHR9O1xuXHRcdGluY2x1ZGVkQ2RhdGFJbnNpZGVbJ2NkYXRhJ10gPSAvXjwhXFxbQ0RBVEFcXFt8XFxdXFxdPiQvaTtcblxuXHRcdHZhciBpbnNpZGUgPSB7XG5cdFx0XHQnaW5jbHVkZWQtY2RhdGEnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC88IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXT4vaSxcblx0XHRcdFx0aW5zaWRlOiBpbmNsdWRlZENkYXRhSW5zaWRlXG5cdFx0XHR9XG5cdFx0fTtcblx0XHRpbnNpZGVbJ2xhbmd1YWdlLScgKyBsYW5nXSA9IHtcblx0XHRcdHBhdHRlcm46IC9bXFxzXFxTXSsvLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXNbbGFuZ11cblx0XHR9O1xuXG5cdFx0dmFyIGRlZiA9IHt9O1xuXHRcdGRlZlt0YWdOYW1lXSA9IHtcblx0XHRcdHBhdHRlcm46IFJlZ0V4cCgvKDxfX1tePl0qPikoPzo8IVxcW0NEQVRBXFxbKD86W15cXF1dfFxcXSg/IVxcXT4pKSpcXF1cXF0+fCg/ITwhXFxbQ0RBVEFcXFspW1xcc1xcU10pKj8oPz08XFwvX18+KS8uc291cmNlLnJlcGxhY2UoL19fL2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRhZ05hbWU7IH0pLCAnaScpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZTogaW5zaWRlXG5cdFx0fTtcblxuXHRcdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjZGF0YScsIGRlZik7XG5cdH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLCAnYWRkQXR0cmlidXRlJywge1xuXHQvKipcblx0ICogQWRkcyBhbiBwYXR0ZXJuIHRvIGhpZ2hsaWdodCBsYW5ndWFnZXMgZW1iZWRkZWQgaW4gSFRNTCBhdHRyaWJ1dGVzLlxuXHQgKlxuXHQgKiBBbiBleGFtcGxlIG9mIGFuIGlubGluZWQgbGFuZ3VhZ2UgaXMgQ1NTIHdpdGggYHN0eWxlYCBhdHRyaWJ1dGVzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZyB0aGF0IGNvbnRhaW5zIHRoZSBpbmxpbmVkIGxhbmd1YWdlLiBUaGlzIG5hbWUgd2lsbCBiZSB0cmVhdGVkIGFzXG5cdCAqIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nIFRoZSBsYW5ndWFnZSBrZXkuXG5cdCAqIEBleGFtcGxlXG5cdCAqIGFkZEF0dHJpYnV0ZSgnc3R5bGUnLCAnY3NzJyk7XG5cdCAqL1xuXHR2YWx1ZTogZnVuY3Rpb24gKGF0dHJOYW1lLCBsYW5nKSB7XG5cdFx0UHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlWydzcGVjaWFsLWF0dHInXS5wdXNoKHtcblx0XHRcdHBhdHRlcm46IFJlZ0V4cChcblx0XHRcdFx0LyhefFtcIidcXHNdKS8uc291cmNlICsgJyg/OicgKyBhdHRyTmFtZSArICcpJyArIC9cXHMqPVxccyooPzpcIlteXCJdKlwifCdbXiddKid8W15cXHMnXCI+PV0rKD89W1xccz5dKSkvLnNvdXJjZSxcblx0XHRcdFx0J2knXG5cdFx0XHQpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQnYXR0ci1uYW1lJzogL15bXlxccz1dKy8sXG5cdFx0XHRcdCdhdHRyLXZhbHVlJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC89W1xcc1xcU10rLyxcblx0XHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHRcdCd2YWx1ZSc6IHtcblx0XHRcdFx0XHRcdFx0cGF0dGVybjogLyhePVxccyooW1wiJ118KD8hW1wiJ10pKSlcXFNbXFxzXFxTXSooPz1cXDIkKS8sXG5cdFx0XHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGFsaWFzOiBbbGFuZywgJ2xhbmd1YWdlLScgKyBsYW5nXSxcblx0XHRcdFx0XHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXNbbGFuZ11cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiBbXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuOiAvXj0vLFxuXHRcdFx0XHRcdFx0XHRcdGFsaWFzOiAnYXR0ci1lcXVhbHMnXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdC9cInwnL1xuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59KTtcblxuUHJpc20ubGFuZ3VhZ2VzLmh0bWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLm1hdGhtbCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMuc3ZnID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblxuUHJpc20ubGFuZ3VhZ2VzLnhtbCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ21hcmt1cCcsIHt9KTtcblByaXNtLmxhbmd1YWdlcy5zc21sID0gUHJpc20ubGFuZ3VhZ2VzLnhtbDtcblByaXNtLmxhbmd1YWdlcy5hdG9tID0gUHJpc20ubGFuZ3VhZ2VzLnhtbDtcblByaXNtLmxhbmd1YWdlcy5yc3MgPSBQcmlzbS5sYW5ndWFnZXMueG1sO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-markup.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-objectivec.js":
/*!*************************************************************!*\
  !*** ./node_modules/prismjs/components/prism-objectivec.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Prism.languages.objectivec = Prism.languages.extend('c', {\n\t'string': {\n\t\tpattern: /@?\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n\t\tgreedy: true\n\t},\n\t'keyword': /\\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\\b/,\n\t'operator': /-[->]?|\\+\\+?|!=?|<<?=?|>>?=?|==?|&&?|\\|\\|?|[~^%?*\\/@]/\n});\n\ndelete Prism.languages.objectivec['class-name'];\n\nPrism.languages.objc = Prism.languages.objectivec;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tb2JqZWN0aXZlYy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW9iamVjdGl2ZWMuanM/ZDkyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJQcmlzbS5sYW5ndWFnZXMub2JqZWN0aXZlYyA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2MnLCB7XG5cdCdzdHJpbmcnOiB7XG5cdFx0cGF0dGVybjogL0A/XCIoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlwiXFxcXFxcclxcbl0pKlwiLyxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J2tleXdvcmQnOiAvXFxiKD86YXNtfGF1dG98YnJlYWt8Y2FzZXxjaGFyfGNvbnN0fGNvbnRpbnVlfGRlZmF1bHR8ZG98ZG91YmxlfGVsc2V8ZW51bXxleHRlcm58ZmxvYXR8Zm9yfGdvdG98aWZ8aW58aW5saW5lfGludHxsb25nfHJlZ2lzdGVyfHJldHVybnxzZWxmfHNob3J0fHNpZ25lZHxzaXplb2Z8c3RhdGljfHN0cnVjdHxzdXBlcnxzd2l0Y2h8dHlwZWRlZnx0eXBlb2Z8dW5pb258dW5zaWduZWR8dm9pZHx2b2xhdGlsZXx3aGlsZSlcXGJ8KD86QGludGVyZmFjZXxAZW5kfEBpbXBsZW1lbnRhdGlvbnxAcHJvdG9jb2x8QGNsYXNzfEBwdWJsaWN8QHByb3RlY3RlZHxAcHJpdmF0ZXxAcHJvcGVydHl8QHRyeXxAY2F0Y2h8QGZpbmFsbHl8QHRocm93fEBzeW50aGVzaXplfEBkeW5hbWljfEBzZWxlY3RvcilcXGIvLFxuXHQnb3BlcmF0b3InOiAvLVstPl0/fFxcK1xcKz98IT0/fDw8Pz0/fD4+Pz0/fD09P3wmJj98XFx8XFx8P3xbfl4lPypcXC9AXS9cbn0pO1xuXG5kZWxldGUgUHJpc20ubGFuZ3VhZ2VzLm9iamVjdGl2ZWNbJ2NsYXNzLW5hbWUnXTtcblxuUHJpc20ubGFuZ3VhZ2VzLm9iamMgPSBQcmlzbS5sYW5ndWFnZXMub2JqZWN0aXZlYztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-objectivec.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-python.js":
/*!*********************************************************!*\
  !*** ./node_modules/prismjs/components/prism-python.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Prism.languages.python = {\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])#.*/,\n\t\tlookbehind: true,\n\t\tgreedy: true\n\t},\n\t'string-interpolation': {\n\t\tpattern: /(?:f|fr|rf)(?:(\"\"\"|''')[\\s\\S]*?\\1|(\"|')(?:\\\\.|(?!\\2)[^\\\\\\r\\n])*\\2)/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'interpolation': {\n\t\t\t\t// \"{\" <expression> <optional \"!s\", \"!r\", or \"!a\"> <optional \":\" format specifier> \"}\"\n\t\t\t\tpattern: /((?:^|[^{])(?:\\{\\{)*)\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}])+\\})+\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'format-spec': {\n\t\t\t\t\t\tpattern: /(:)[^:(){}]+(?=\\}$)/,\n\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t},\n\t\t\t\t\t'conversion-option': {\n\t\t\t\t\t\tpattern: /![sra](?=[:}]$)/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: null\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\t'triple-quoted-string': {\n\t\tpattern: /(?:[rub]|br|rb)?(\"\"\"|''')[\\s\\S]*?\\1/i,\n\t\tgreedy: true,\n\t\talias: 'string'\n\t},\n\t'string': {\n\t\tpattern: /(?:[rub]|br|rb)?(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/i,\n\t\tgreedy: true\n\t},\n\t'function': {\n\t\tpattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_]\\w*(?=\\s*\\()/g,\n\t\tlookbehind: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\bclass\\s+)\\w+/i,\n\t\tlookbehind: true\n\t},\n\t'decorator': {\n\t\tpattern: /(^[\\t ]*)@\\w+(?:\\.\\w+)*/m,\n\t\tlookbehind: true,\n\t\talias: ['annotation', 'punctuation'],\n\t\tinside: {\n\t\t\t'punctuation': /\\./\n\t\t}\n\t},\n\t'keyword': /\\b(?:_(?=\\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\\b/,\n\t'builtin': /\\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\\b/,\n\t'boolean': /\\b(?:False|None|True)\\b/,\n\t'number': /\\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\\b|(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:e[+-]?\\d+(?:_\\d+)*)?j?(?!\\w)/i,\n\t'operator': /[-+%=]=?|!=|:=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\nPrism.languages.python['string-interpolation'].inside['interpolation'].inside.rest = Prism.languages.python;\n\nPrism.languages.py = Prism.languages.python;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tcHl0aG9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0ZBQWdGO0FBQ3pGLHVCQUF1QixPQUFPLEVBQUUsS0FBSyxLQUFLLFFBQVEsSUFBSSxLQUFLLFFBQVEsSUFBSSxLQUFLLFFBQVEsS0FBSyxJQUFJLElBQUk7QUFDakc7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQSxNQUFNO0FBQ047QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBSTtBQUN4Qjs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXB5dGhvbi5qcz8yZjFhIl0sInNvdXJjZXNDb250ZW50IjpbIlByaXNtLmxhbmd1YWdlcy5weXRob24gPSB7XG5cdCdjb21tZW50Jzoge1xuXHRcdHBhdHRlcm46IC8oXnxbXlxcXFxdKSMuKi8sXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J3N0cmluZy1pbnRlcnBvbGF0aW9uJzoge1xuXHRcdHBhdHRlcm46IC8oPzpmfGZyfHJmKSg/OihcIlwiXCJ8JycnKVtcXHNcXFNdKj9cXDF8KFwifCcpKD86XFxcXC58KD8hXFwyKVteXFxcXFxcclxcbl0pKlxcMikvaSxcblx0XHRncmVlZHk6IHRydWUsXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQnaW50ZXJwb2xhdGlvbic6IHtcblx0XHRcdFx0Ly8gXCJ7XCIgPGV4cHJlc3Npb24+IDxvcHRpb25hbCBcIiFzXCIsIFwiIXJcIiwgb3IgXCIhYVwiPiA8b3B0aW9uYWwgXCI6XCIgZm9ybWF0IHNwZWNpZmllcj4gXCJ9XCJcblx0XHRcdFx0cGF0dGVybjogLygoPzpefFtee10pKD86XFx7XFx7KSopXFx7KD8hXFx7KSg/Oltee31dfFxceyg/IVxceykoPzpbXnt9XXxcXHsoPyFcXHspKD86W157fV0pK1xcfSkrXFx9KStcXH0vLFxuXHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQnZm9ybWF0LXNwZWMnOiB7XG5cdFx0XHRcdFx0XHRwYXR0ZXJuOiAvKDopW146KCl7fV0rKD89XFx9JCkvLFxuXHRcdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0J2NvbnZlcnNpb24tb3B0aW9uJzoge1xuXHRcdFx0XHRcdFx0cGF0dGVybjogLyFbc3JhXSg/PVs6fV0kKS8sXG5cdFx0XHRcdFx0XHRhbGlhczogJ3B1bmN0dWF0aW9uJ1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVzdDogbnVsbFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0J3N0cmluZyc6IC9bXFxzXFxTXSsvXG5cdFx0fVxuXHR9LFxuXHQndHJpcGxlLXF1b3RlZC1zdHJpbmcnOiB7XG5cdFx0cGF0dGVybjogLyg/OltydWJdfGJyfHJiKT8oXCJcIlwifCcnJylbXFxzXFxTXSo/XFwxL2ksXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGFsaWFzOiAnc3RyaW5nJ1xuXHR9LFxuXHQnc3RyaW5nJzoge1xuXHRcdHBhdHRlcm46IC8oPzpbcnViXXxicnxyYik/KFwifCcpKD86XFxcXC58KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS9pLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQnZnVuY3Rpb24nOiB7XG5cdFx0cGF0dGVybjogLygoPzpefFxccylkZWZbIFxcdF0rKVthLXpBLVpfXVxcdyooPz1cXHMqXFwoKS9nLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0fSxcblx0J2NsYXNzLW5hbWUnOiB7XG5cdFx0cGF0dGVybjogLyhcXGJjbGFzc1xccyspXFx3Ky9pLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0fSxcblx0J2RlY29yYXRvcic6IHtcblx0XHRwYXR0ZXJuOiAvKF5bXFx0IF0qKUBcXHcrKD86XFwuXFx3KykqL20sXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRhbGlhczogWydhbm5vdGF0aW9uJywgJ3B1bmN0dWF0aW9uJ10sXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQncHVuY3R1YXRpb24nOiAvXFwuL1xuXHRcdH1cblx0fSxcblx0J2tleXdvcmQnOiAvXFxiKD86Xyg/PVxccyo6KXxhbmR8YXN8YXNzZXJ0fGFzeW5jfGF3YWl0fGJyZWFrfGNhc2V8Y2xhc3N8Y29udGludWV8ZGVmfGRlbHxlbGlmfGVsc2V8ZXhjZXB0fGV4ZWN8ZmluYWxseXxmb3J8ZnJvbXxnbG9iYWx8aWZ8aW1wb3J0fGlufGlzfGxhbWJkYXxtYXRjaHxub25sb2NhbHxub3R8b3J8cGFzc3xwcmludHxyYWlzZXxyZXR1cm58dHJ5fHdoaWxlfHdpdGh8eWllbGQpXFxiLyxcblx0J2J1aWx0aW4nOiAvXFxiKD86X19pbXBvcnRfX3xhYnN8YWxsfGFueXxhcHBseXxhc2NpaXxiYXNlc3RyaW5nfGJpbnxib29sfGJ1ZmZlcnxieXRlYXJyYXl8Ynl0ZXN8Y2FsbGFibGV8Y2hyfGNsYXNzbWV0aG9kfGNtcHxjb2VyY2V8Y29tcGlsZXxjb21wbGV4fGRlbGF0dHJ8ZGljdHxkaXJ8ZGl2bW9kfGVudW1lcmF0ZXxldmFsfGV4ZWNmaWxlfGZpbGV8ZmlsdGVyfGZsb2F0fGZvcm1hdHxmcm96ZW5zZXR8Z2V0YXR0cnxnbG9iYWxzfGhhc2F0dHJ8aGFzaHxoZWxwfGhleHxpZHxpbnB1dHxpbnR8aW50ZXJufGlzaW5zdGFuY2V8aXNzdWJjbGFzc3xpdGVyfGxlbnxsaXN0fGxvY2Fsc3xsb25nfG1hcHxtYXh8bWVtb3J5dmlld3xtaW58bmV4dHxvYmplY3R8b2N0fG9wZW58b3JkfHBvd3xwcm9wZXJ0eXxyYW5nZXxyYXdfaW5wdXR8cmVkdWNlfHJlbG9hZHxyZXByfHJldmVyc2VkfHJvdW5kfHNldHxzZXRhdHRyfHNsaWNlfHNvcnRlZHxzdGF0aWNtZXRob2R8c3RyfHN1bXxzdXBlcnx0dXBsZXx0eXBlfHVuaWNocnx1bmljb2RlfHZhcnN8eHJhbmdlfHppcClcXGIvLFxuXHQnYm9vbGVhbic6IC9cXGIoPzpGYWxzZXxOb25lfFRydWUpXFxiLyxcblx0J251bWJlcic6IC9cXGIwKD86Yig/Ol8/WzAxXSkrfG8oPzpfP1swLTddKSt8eCg/Ol8/W2EtZjAtOV0pKylcXGJ8KD86XFxiXFxkKyg/Ol9cXGQrKSooPzpcXC4oPzpcXGQrKD86X1xcZCspKik/KT98XFxCXFwuXFxkKyg/Ol9cXGQrKSopKD86ZVsrLV0/XFxkKyg/Ol9cXGQrKSopP2o/KD8hXFx3KS9pLFxuXHQnb3BlcmF0b3InOiAvWy0rJT1dPT98IT18Oj18XFwqXFwqPz0/fFxcL1xcLz89P3w8Wzw9Pl0/fD5bPT5dP3xbJnxefl0vLFxuXHQncHVuY3R1YXRpb24nOiAvW3t9W1xcXTsoKSwuOl0vXG59O1xuXG5QcmlzbS5sYW5ndWFnZXMucHl0aG9uWydzdHJpbmctaW50ZXJwb2xhdGlvbiddLmluc2lkZVsnaW50ZXJwb2xhdGlvbiddLmluc2lkZS5yZXN0ID0gUHJpc20ubGFuZ3VhZ2VzLnB5dGhvbjtcblxuUHJpc20ubGFuZ3VhZ2VzLnB5ID0gUHJpc20ubGFuZ3VhZ2VzLnB5dGhvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-python.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-rust.js":
/*!*******************************************************!*\
  !*** ./node_modules/prismjs/components/prism-rust.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (Prism) {\n\n\tvar multilineComment = /\\/\\*(?:[^*/]|\\*(?!\\/)|\\/(?!\\*)|<self>)*\\*\\//.source;\n\tfor (var i = 0; i < 2; i++) {\n\t\t// support 4 levels of nested comments\n\t\tmultilineComment = multilineComment.replace(/<self>/g, function () { return multilineComment; });\n\t}\n\tmultilineComment = multilineComment.replace(/<self>/g, function () { return /[^\\s\\S]/.source; });\n\n\n\tPrism.languages.rust = {\n\t\t'comment': [\n\t\t\t{\n\t\t\t\tpattern: RegExp(/(^|[^\\\\])/.source + multilineComment),\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t}\n\t\t],\n\t\t'string': {\n\t\t\tpattern: /b?\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|b?r(#*)\"(?:[^\"]|\"(?!\\1))*\"\\1/,\n\t\t\tgreedy: true\n\t\t},\n\t\t'char': {\n\t\t\tpattern: /b?'(?:\\\\(?:x[0-7][\\da-fA-F]|u\\{(?:[\\da-fA-F]_*){1,6}\\}|.)|[^\\\\\\r\\n\\t'])'/,\n\t\t\tgreedy: true\n\t\t},\n\t\t'attribute': {\n\t\t\tpattern: /#!?\\[(?:[^\\[\\]\"]|\"(?:\\\\[\\s\\S]|[^\\\\\"])*\")*\\]/,\n\t\t\tgreedy: true,\n\t\t\talias: 'attr-name',\n\t\t\tinside: {\n\t\t\t\t'string': null // see below\n\t\t\t}\n\t\t},\n\n\t\t// Closure params should not be confused with bitwise OR |\n\t\t'closure-params': {\n\t\t\tpattern: /([=(,:]\\s*|\\bmove\\s*)\\|[^|]*\\||\\|[^|]*\\|(?=\\s*(?:\\{|->))/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'closure-punctuation': {\n\t\t\t\t\tpattern: /^\\||\\|$/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\trest: null // see below\n\t\t\t}\n\t\t},\n\n\t\t'lifetime-annotation': {\n\t\t\tpattern: /'\\w+/,\n\t\t\talias: 'symbol'\n\t\t},\n\n\t\t'fragment-specifier': {\n\t\t\tpattern: /(\\$\\w+:)[a-z]+/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'punctuation'\n\t\t},\n\t\t'variable': /\\$\\w+/,\n\n\t\t'function-definition': {\n\t\t\tpattern: /(\\bfn\\s+)\\w+/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'function'\n\t\t},\n\t\t'type-definition': {\n\t\t\tpattern: /(\\b(?:enum|struct|trait|type|union)\\s+)\\w+/,\n\t\t\tlookbehind: true,\n\t\t\talias: 'class-name'\n\t\t},\n\t\t'module-declaration': [\n\t\t\t{\n\t\t\t\tpattern: /(\\b(?:crate|mod)\\s+)[a-z][a-z_\\d]*/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'namespace'\n\t\t\t},\n\t\t\t{\n\t\t\t\tpattern: /(\\b(?:crate|self|super)\\s*)::\\s*[a-z][a-z_\\d]*\\b(?:\\s*::(?:\\s*[a-z][a-z_\\d]*\\s*::)*)?/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'namespace',\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /::/\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'keyword': [\n\t\t\t// https://github.com/rust-lang/reference/blob/master/src/keywords.md\n\t\t\t/\\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\b/,\n\t\t\t// primitives and str\n\t\t\t// https://doc.rust-lang.org/stable/rust-by-example/primitives.html\n\t\t\t/\\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\\b/\n\t\t],\n\n\t\t// functions can technically start with an upper-case letter, but this will introduce a lot of false positives\n\t\t// and Rust's naming conventions recommend snake_case anyway.\n\t\t// https://doc.rust-lang.org/1.0.0/style/style/naming/README.html\n\t\t'function': /\\b[a-z_]\\w*(?=\\s*(?:::\\s*<|\\())/,\n\t\t'macro': {\n\t\t\tpattern: /\\b\\w+!/,\n\t\t\talias: 'property'\n\t\t},\n\t\t'constant': /\\b[A-Z_][A-Z_\\d]+\\b/,\n\t\t'class-name': /\\b[A-Z]\\w*\\b/,\n\n\t\t'namespace': {\n\t\t\tpattern: /(?:\\b[a-z][a-z_\\d]*\\s*::\\s*)*\\b[a-z][a-z_\\d]*\\s*::(?!\\s*<)/,\n\t\t\tinside: {\n\t\t\t\t'punctuation': /::/\n\t\t\t}\n\t\t},\n\n\t\t// Hex, oct, bin, dec numbers with visual separators and type suffix\n\t\t'number': /\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\\d(?:_?\\d)*)?\\.)?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\\b/,\n\t\t'boolean': /\\b(?:false|true)\\b/,\n\t\t'punctuation': /->|\\.\\.=|\\.{1,3}|::|[{}[\\];(),:]/,\n\t\t'operator': /[-+*\\/%!^]=?|=[=>]?|&[&=]?|\\|[|=]?|<<?=?|>>?=?|[@?]/\n\t};\n\n\tPrism.languages.rust['closure-params'].inside.rest = Prism.languages.rust;\n\tPrism.languages.rust['attribute'].inside['string'] = Prism.languages.rust['string'];\n\n}(Prism));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tcnVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0EsdUVBQXVFLDBCQUEwQjtBQUNqRztBQUNBLHNFQUFzRSwwQkFBMEI7OztBQUdoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNENBQTRDLGlCQUFpQixJQUFJLEVBQUU7QUFDbkU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFJLE9BQU8sSUFBSTtBQUM3QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXJ1c3QuanM/NGQ3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKFByaXNtKSB7XG5cblx0dmFyIG11bHRpbGluZUNvbW1lbnQgPSAvXFwvXFwqKD86W14qL118XFwqKD8hXFwvKXxcXC8oPyFcXCopfDxzZWxmPikqXFwqXFwvLy5zb3VyY2U7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG5cdFx0Ly8gc3VwcG9ydCA0IGxldmVscyBvZiBuZXN0ZWQgY29tbWVudHNcblx0XHRtdWx0aWxpbmVDb21tZW50ID0gbXVsdGlsaW5lQ29tbWVudC5yZXBsYWNlKC88c2VsZj4vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbXVsdGlsaW5lQ29tbWVudDsgfSk7XG5cdH1cblx0bXVsdGlsaW5lQ29tbWVudCA9IG11bHRpbGluZUNvbW1lbnQucmVwbGFjZSgvPHNlbGY+L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIC9bXlxcc1xcU10vLnNvdXJjZTsgfSk7XG5cblxuXHRQcmlzbS5sYW5ndWFnZXMucnVzdCA9IHtcblx0XHQnY29tbWVudCc6IFtcblx0XHRcdHtcblx0XHRcdFx0cGF0dGVybjogUmVnRXhwKC8oXnxbXlxcXFxdKS8uc291cmNlICsgbXVsdGlsaW5lQ29tbWVudCksXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGdyZWVkeTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0cGF0dGVybjogLyhefFteXFxcXDpdKVxcL1xcLy4qLyxcblx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0Z3JlZWR5OiB0cnVlXG5cdFx0XHR9XG5cdFx0XSxcblx0XHQnc3RyaW5nJzoge1xuXHRcdFx0cGF0dGVybjogL2I/XCIoPzpcXFxcW1xcc1xcU118W15cXFxcXCJdKSpcInxiP3IoIyopXCIoPzpbXlwiXXxcIig/IVxcMSkpKlwiXFwxLyxcblx0XHRcdGdyZWVkeTogdHJ1ZVxuXHRcdH0sXG5cdFx0J2NoYXInOiB7XG5cdFx0XHRwYXR0ZXJuOiAvYj8nKD86XFxcXCg/OnhbMC03XVtcXGRhLWZBLUZdfHVcXHsoPzpbXFxkYS1mQS1GXV8qKXsxLDZ9XFx9fC4pfFteXFxcXFxcclxcblxcdCddKScvLFxuXHRcdFx0Z3JlZWR5OiB0cnVlXG5cdFx0fSxcblx0XHQnYXR0cmlidXRlJzoge1xuXHRcdFx0cGF0dGVybjogLyMhP1xcWyg/OlteXFxbXFxdXCJdfFwiKD86XFxcXFtcXHNcXFNdfFteXFxcXFwiXSkqXCIpKlxcXS8sXG5cdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRhbGlhczogJ2F0dHItbmFtZScsXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J3N0cmluZyc6IG51bGwgLy8gc2VlIGJlbG93XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIENsb3N1cmUgcGFyYW1zIHNob3VsZCBub3QgYmUgY29uZnVzZWQgd2l0aCBiaXR3aXNlIE9SIHxcblx0XHQnY2xvc3VyZS1wYXJhbXMnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKFs9KCw6XVxccyp8XFxibW92ZVxccyopXFx8W158XSpcXHx8XFx8W158XSpcXHwoPz1cXHMqKD86XFx7fC0+KSkvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQnY2xvc3VyZS1wdW5jdHVhdGlvbic6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvXlxcfHxcXHwkLyxcblx0XHRcdFx0XHRhbGlhczogJ3B1bmN0dWF0aW9uJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXN0OiBudWxsIC8vIHNlZSBiZWxvd1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQnbGlmZXRpbWUtYW5ub3RhdGlvbic6IHtcblx0XHRcdHBhdHRlcm46IC8nXFx3Ky8sXG5cdFx0XHRhbGlhczogJ3N5bWJvbCdcblx0XHR9LFxuXG5cdFx0J2ZyYWdtZW50LXNwZWNpZmllcic6IHtcblx0XHRcdHBhdHRlcm46IC8oXFwkXFx3KzopW2Etel0rLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRhbGlhczogJ3B1bmN0dWF0aW9uJ1xuXHRcdH0sXG5cdFx0J3ZhcmlhYmxlJzogL1xcJFxcdysvLFxuXG5cdFx0J2Z1bmN0aW9uLWRlZmluaXRpb24nOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKFxcYmZuXFxzKylcXHcrLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRhbGlhczogJ2Z1bmN0aW9uJ1xuXHRcdH0sXG5cdFx0J3R5cGUtZGVmaW5pdGlvbic6IHtcblx0XHRcdHBhdHRlcm46IC8oXFxiKD86ZW51bXxzdHJ1Y3R8dHJhaXR8dHlwZXx1bmlvbilcXHMrKVxcdysvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGFsaWFzOiAnY2xhc3MtbmFtZSdcblx0XHR9LFxuXHRcdCdtb2R1bGUtZGVjbGFyYXRpb24nOiBbXG5cdFx0XHR7XG5cdFx0XHRcdHBhdHRlcm46IC8oXFxiKD86Y3JhdGV8bW9kKVxccyspW2Etel1bYS16X1xcZF0qLyxcblx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0YWxpYXM6ICduYW1lc3BhY2UnXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRwYXR0ZXJuOiAvKFxcYig/OmNyYXRlfHNlbGZ8c3VwZXIpXFxzKik6OlxccypbYS16XVthLXpfXFxkXSpcXGIoPzpcXHMqOjooPzpcXHMqW2Etel1bYS16X1xcZF0qXFxzKjo6KSopPy8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGFsaWFzOiAnbmFtZXNwYWNlJyxcblx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0J3B1bmN0dWF0aW9uJzogLzo6L1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XSxcblx0XHQna2V5d29yZCc6IFtcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ydXN0LWxhbmcvcmVmZXJlbmNlL2Jsb2IvbWFzdGVyL3NyYy9rZXl3b3Jkcy5tZFxuXHRcdFx0L1xcYig/OlNlbGZ8YWJzdHJhY3R8YXN8YXN5bmN8YXdhaXR8YmVjb21lfGJveHxicmVha3xjb25zdHxjb250aW51ZXxjcmF0ZXxkb3xkeW58ZWxzZXxlbnVtfGV4dGVybnxmaW5hbHxmbnxmb3J8aWZ8aW1wbHxpbnxsZXR8bG9vcHxtYWNyb3xtYXRjaHxtb2R8bW92ZXxtdXR8b3ZlcnJpZGV8cHJpdnxwdWJ8cmVmfHJldHVybnxzZWxmfHN0YXRpY3xzdHJ1Y3R8c3VwZXJ8dHJhaXR8dHJ5fHR5cGV8dHlwZW9mfHVuaW9ufHVuc2FmZXx1bnNpemVkfHVzZXx2aXJ0dWFsfHdoZXJlfHdoaWxlfHlpZWxkKVxcYi8sXG5cdFx0XHQvLyBwcmltaXRpdmVzIGFuZCBzdHJcblx0XHRcdC8vIGh0dHBzOi8vZG9jLnJ1c3QtbGFuZy5vcmcvc3RhYmxlL3J1c3QtYnktZXhhbXBsZS9wcmltaXRpdmVzLmh0bWxcblx0XHRcdC9cXGIoPzpib29sfGNoYXJ8Zig/OjMyfDY0KXxbdWldKD86OHwxNnwzMnw2NHwxMjh8c2l6ZSl8c3RyKVxcYi9cblx0XHRdLFxuXG5cdFx0Ly8gZnVuY3Rpb25zIGNhbiB0ZWNobmljYWxseSBzdGFydCB3aXRoIGFuIHVwcGVyLWNhc2UgbGV0dGVyLCBidXQgdGhpcyB3aWxsIGludHJvZHVjZSBhIGxvdCBvZiBmYWxzZSBwb3NpdGl2ZXNcblx0XHQvLyBhbmQgUnVzdCdzIG5hbWluZyBjb252ZW50aW9ucyByZWNvbW1lbmQgc25ha2VfY2FzZSBhbnl3YXkuXG5cdFx0Ly8gaHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy8xLjAuMC9zdHlsZS9zdHlsZS9uYW1pbmcvUkVBRE1FLmh0bWxcblx0XHQnZnVuY3Rpb24nOiAvXFxiW2Etel9dXFx3Kig/PVxccyooPzo6Olxccyo8fFxcKCkpLyxcblx0XHQnbWFjcm8nOiB7XG5cdFx0XHRwYXR0ZXJuOiAvXFxiXFx3KyEvLFxuXHRcdFx0YWxpYXM6ICdwcm9wZXJ0eSdcblx0XHR9LFxuXHRcdCdjb25zdGFudCc6IC9cXGJbQS1aX11bQS1aX1xcZF0rXFxiLyxcblx0XHQnY2xhc3MtbmFtZSc6IC9cXGJbQS1aXVxcdypcXGIvLFxuXG5cdFx0J25hbWVzcGFjZSc6IHtcblx0XHRcdHBhdHRlcm46IC8oPzpcXGJbYS16XVthLXpfXFxkXSpcXHMqOjpcXHMqKSpcXGJbYS16XVthLXpfXFxkXSpcXHMqOjooPyFcXHMqPCkvLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdwdW5jdHVhdGlvbic6IC86Oi9cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gSGV4LCBvY3QsIGJpbiwgZGVjIG51bWJlcnMgd2l0aCB2aXN1YWwgc2VwYXJhdG9ycyBhbmQgdHlwZSBzdWZmaXhcblx0XHQnbnVtYmVyJzogL1xcYig/OjB4W1xcZEEtRmEtZl0oPzpfP1tcXGRBLUZhLWZdKSp8MG9bMC03XSg/Ol8/WzAtN10pKnwwYlswMV0oPzpfP1swMV0pKnwoPzooPzpcXGQoPzpfP1xcZCkqKT9cXC4pP1xcZCg/Ol8/XFxkKSooPzpbRWVdWystXT9cXGQrKT8pKD86Xz8oPzpmMzJ8ZjY0fFtpdV0oPzo4fDE2fDMyfDY0fHNpemUpPykpP1xcYi8sXG5cdFx0J2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuXHRcdCdwdW5jdHVhdGlvbic6IC8tPnxcXC5cXC49fFxcLnsxLDN9fDo6fFt7fVtcXF07KCksOl0vLFxuXHRcdCdvcGVyYXRvcic6IC9bLSsqXFwvJSFeXT0/fD1bPT5dP3wmWyY9XT98XFx8W3w9XT98PDw/PT98Pj4/PT98W0A/XS9cblx0fTtcblxuXHRQcmlzbS5sYW5ndWFnZXMucnVzdFsnY2xvc3VyZS1wYXJhbXMnXS5pbnNpZGUucmVzdCA9IFByaXNtLmxhbmd1YWdlcy5ydXN0O1xuXHRQcmlzbS5sYW5ndWFnZXMucnVzdFsnYXR0cmlidXRlJ10uaW5zaWRlWydzdHJpbmcnXSA9IFByaXNtLmxhbmd1YWdlcy5ydXN0WydzdHJpbmcnXTtcblxufShQcmlzbSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-rust.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-sql.js":
/*!******************************************************!*\
  !*** ./node_modules/prismjs/components/prism-sql.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Prism.languages.sql = {\n\t'comment': {\n\t\tpattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|(?:--|\\/\\/|#).*)/,\n\t\tlookbehind: true\n\t},\n\t'variable': [\n\t\t{\n\t\t\tpattern: /@([\"'`])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1/,\n\t\t\tgreedy: true\n\t\t},\n\t\t/@[\\w.$]+/\n\t],\n\t'string': {\n\t\tpattern: /(^|[^@\\\\])(\"|')(?:\\\\[\\s\\S]|(?!\\2)[^\\\\]|\\2\\2)*\\2/,\n\t\tgreedy: true,\n\t\tlookbehind: true\n\t},\n\t'identifier': {\n\t\tpattern: /(^|[^@\\\\])`(?:\\\\[\\s\\S]|[^`\\\\]|``)*`/,\n\t\tgreedy: true,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /^`|`$/\n\t\t}\n\t},\n\t'function': /\\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\\s*\\()/i, // Should we highlight user defined functions too?\n\t'keyword': /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\\b/i,\n\t'boolean': /\\b(?:FALSE|NULL|TRUE)\\b/i,\n\t'number': /\\b0x[\\da-f]+\\b|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+\\b/i,\n\t'operator': /[-+*\\/=%^~]|&&?|\\|\\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,\n\t'punctuation': /[;[\\]()`,.]/\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tc3FsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tc3FsLmpzPzI4M2IiXSwic291cmNlc0NvbnRlbnQiOlsiUHJpc20ubGFuZ3VhZ2VzLnNxbCA9IHtcblx0J2NvbW1lbnQnOiB7XG5cdFx0cGF0dGVybjogLyhefFteXFxcXF0pKD86XFwvXFwqW1xcc1xcU10qP1xcKlxcL3woPzotLXxcXC9cXC98IykuKikvLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0fSxcblx0J3ZhcmlhYmxlJzogW1xuXHRcdHtcblx0XHRcdHBhdHRlcm46IC9AKFtcIidgXSkoPzpcXFxcW1xcc1xcU118KD8hXFwxKVteXFxcXF0pK1xcMS8sXG5cdFx0XHRncmVlZHk6IHRydWVcblx0XHR9LFxuXHRcdC9AW1xcdy4kXSsvXG5cdF0sXG5cdCdzdHJpbmcnOiB7XG5cdFx0cGF0dGVybjogLyhefFteQFxcXFxdKShcInwnKSg/OlxcXFxbXFxzXFxTXXwoPyFcXDIpW15cXFxcXXxcXDJcXDIpKlxcMi8sXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0fSxcblx0J2lkZW50aWZpZXInOiB7XG5cdFx0cGF0dGVybjogLyhefFteQFxcXFxdKWAoPzpcXFxcW1xcc1xcU118W15gXFxcXF18YGApKmAvLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J3B1bmN0dWF0aW9uJzogL15gfGAkL1xuXHRcdH1cblx0fSxcblx0J2Z1bmN0aW9uJzogL1xcYig/OkFWR3xDT1VOVHxGSVJTVHxGT1JNQVR8TEFTVHxMQ0FTRXxMRU58TUFYfE1JRHxNSU58TU9EfE5PV3xST1VORHxTVU18VUNBU0UpKD89XFxzKlxcKCkvaSwgLy8gU2hvdWxkIHdlIGhpZ2hsaWdodCB1c2VyIGRlZmluZWQgZnVuY3Rpb25zIHRvbz9cblx0J2tleXdvcmQnOiAvXFxiKD86QUNUSU9OfEFERHxBRlRFUnxBTEdPUklUSE18QUxMfEFMVEVSfEFOQUxZWkV8QU5ZfEFQUExZfEFTfEFTQ3xBVVRIT1JJWkFUSU9OfEFVVE9fSU5DUkVNRU5UfEJBQ0tVUHxCREJ8QkVHSU58QkVSS0VMRVlEQnxCSUdJTlR8QklOQVJZfEJJVHxCTE9CfEJPT0x8Qk9PTEVBTnxCUkVBS3xCUk9XU0V8QlRSRUV8QlVMS3xCWXxDQUxMfENBU0NBREVEP3xDQVNFfENIQUlOfENIQVIoPzpBQ1RFUnxTRVQpP3xDSEVDSyg/OlBPSU5UKT98Q0xPU0V8Q0xVU1RFUkVEfENPQUxFU0NFfENPTExBVEV8Q09MVU1OUz98Q09NTUVOVHxDT01NSVQoPzpURUQpP3xDT01QVVRFfENPTk5FQ1R8Q09OU0lTVEVOVHxDT05TVFJBSU5UfENPTlRBSU5TKD86VEFCTEUpP3xDT05USU5VRXxDT05WRVJUfENSRUFURXxDUk9TU3xDVVJSRU5UKD86X0RBVEV8X1RJTUV8X1RJTUVTVEFNUHxfVVNFUik/fENVUlNPUnxDWUNMRXxEQVRBKD86QkFTRVM/KT98REFURSg/OlRJTUUpP3xEQVl8REJDQ3xERUFMTE9DQVRFfERFQ3xERUNJTUFMfERFQ0xBUkV8REVGQVVMVHxERUZJTkVSfERFTEFZRUR8REVMRVRFfERFTElNSVRFUlM/fERFTll8REVTQ3xERVNDUklCRXxERVRFUk1JTklTVElDfERJU0FCTEV8RElTQ0FSRHxESVNLfERJU1RJTkNUfERJU1RJTkNUUk9XfERJU1RSSUJVVEVEfERPfERPVUJMRXxEUk9QfERVTU1ZfERVTVAoPzpGSUxFKT98RFVQTElDQVRFfEVMU0UoPzpJRik/fEVOQUJMRXxFTkNMT1NFRHxFTkR8RU5HSU5FfEVOVU18RVJSTFZMfEVSUk9SU3xFU0NBUEVEP3xFWENFUFR8RVhFQyg/OlVURSk/fEVYSVNUU3xFWElUfEVYUExBSU58RVhURU5ERUR8RkVUQ0h8RklFTERTfEZJTEV8RklMTEZBQ1RPUnxGSVJTVHxGSVhFRHxGTE9BVHxGT0xMT1dJTkd8Rk9SKD86IEVBQ0ggUk9XKT98Rk9SQ0V8Rk9SRUlHTnxGUkVFVEVYVCg/OlRBQkxFKT98RlJPTXxGVUxMfEZVTkNUSU9OfEdFT01FVFJZKD86Q09MTEVDVElPTik/fEdMT0JBTHxHT1RPfEdSQU5UfEdST1VQfEhBTkRMRVJ8SEFTSHxIQVZJTkd8SE9MRExPQ0t8SE9VUnxJREVOVElUWSg/OkNPTHxfSU5TRVJUKT98SUZ8SUdOT1JFfElNUE9SVHxJTkRFWHxJTkZJTEV8SU5ORVJ8SU5OT0RCfElOT1VUfElOU0VSVHxJTlR8SU5URUdFUnxJTlRFUlNFQ1R8SU5URVJWQUx8SU5UT3xJTlZPS0VSfElTT0xBVElPTnxJVEVSQVRFfEpPSU58S0VZUz98S0lMTHxMQU5HVUFHRXxMQVNUfExFQVZFfExFRlR8TEVWRUx8TElNSVR8TElORU5PfExJTkVTfExJTkVTVFJJTkd8TE9BRHxMT0NBTHxMT0NLfExPTkcoPzpCTE9CfFRFWFQpfExPT1B8TUFUQ0goPzpFRCk/fE1FRElVTSg/OkJMT0J8SU5UfFRFWFQpfE1FUkdFfE1JRERMRUlOVHxNSU5VVEV8TU9ERXxNT0RJRklFU3xNT0RJRll8TU9OVEh8TVVMVEkoPzpMSU5FU1RSSU5HfFBPSU5UfFBPTFlHT04pfE5BVElPTkFMfE5BVFVSQUx8TkNIQVJ8TkVYVHxOT3xOT05DTFVTVEVSRUR8TlVMTElGfE5VTUVSSUN8T0ZGP3xPRkZTRVRTP3xPTnxPUEVOKD86REFUQVNPVVJDRXxRVUVSWXxST1dTRVQpP3xPUFRJTUlaRXxPUFRJT04oPzpBTExZKT98T1JERVJ8T1VUKD86RVJ8RklMRSk/fE9WRVJ8UEFSVElBTHxQQVJUSVRJT058UEVSQ0VOVHxQSVZPVHxQTEFOfFBPSU5UfFBPTFlHT058UFJFQ0VESU5HfFBSRUNJU0lPTnxQUkVQQVJFfFBSRVZ8UFJJTUFSWXxQUklOVHxQUklWSUxFR0VTfFBST0MoPzpFRFVSRSk/fFBVQkxJQ3xQVVJHRXxRVUlDS3xSQUlTRVJST1J8UkVBRFM/fFJFQUx8UkVDT05GSUdVUkV8UkVGRVJFTkNFU3xSRUxFQVNFfFJFTkFNRXxSRVBFQVQoPzpBQkxFKT98UkVQTEFDRXxSRVBMSUNBVElPTnxSRVFVSVJFfFJFU0lHTkFMfFJFU1RPUkV8UkVTVFJJQ1R8UkVUVVJOKD86SU5HfFMpP3xSRVZPS0V8UklHSFR8Uk9MTEJBQ0t8Uk9VVElORXxST1coPzpDT1VOVHxHVUlEQ09MfFMpP3xSVFJFRXxSVUxFfFNBVkUoPzpQT0lOVCk/fFNDSEVNQXxTRUNPTkR8U0VMRUNUfFNFUklBTCg/OklaQUJMRSk/fFNFU1NJT04oPzpfVVNFUik/fFNFVCg/OlVTRVIpP3xTSEFSRXxTSE9XfFNIVVRET1dOfFNJTVBMRXxTTUFMTElOVHxTTkFQU0hPVHxTT01FfFNPTkFNRXxTUUx8U1RBUlQoPzpJTkcpP3xTVEFUSVNUSUNTfFNUQVRVU3xTVFJJUEVEfFNZU1RFTV9VU0VSfFRBQkxFUz98VEFCTEVTUEFDRXxURU1QKD86T1JBUll8VEFCTEUpP3xURVJNSU5BVEVEfFRFWFQoPzpTSVpFKT98VEhFTnxUSU1FKD86U1RBTVApP3xUSU5ZKD86QkxPQnxJTlR8VEVYVCl8VE9QP3xUUkFOKD86U0FDVElPTlM/KT98VFJJR0dFUnxUUlVOQ0FURXxUU0VRVUFMfFRZUEVTP3xVTkJPVU5ERUR8VU5DT01NSVRURUR8VU5ERUZJTkVEfFVOSU9OfFVOSVFVRXxVTkxPQ0t8VU5QSVZPVHxVTlNJR05FRHxVUERBVEUoPzpURVhUKT98VVNBR0V8VVNFfFVTRVJ8VVNJTkd8VkFMVUVTP3xWQVIoPzpCSU5BUll8Q0hBUnxDSEFSQUNURVJ8WUlORyl8VklFV3xXQUlURk9SfFdBUk5JTkdTfFdIRU58V0hFUkV8V0hJTEV8V0lUSCg/OiBST0xMVVB8SU4pP3xXT1JLfFdSSVRFKD86VEVYVCk/fFlFQVIpXFxiL2ksXG5cdCdib29sZWFuJzogL1xcYig/OkZBTFNFfE5VTEx8VFJVRSlcXGIvaSxcblx0J251bWJlcic6IC9cXGIweFtcXGRhLWZdK1xcYnxcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCtcXGIvaSxcblx0J29wZXJhdG9yJzogL1stKypcXC89JV5+XXwmJj98XFx8XFx8P3whPT98PCg/Oj0+P3w8fD4pP3w+Wz49XT98XFxiKD86QU5EfEJFVFdFRU58RElWfElMSUtFfElOfElTfExJS0V8Tk9UfE9SfFJFR0VYUHxSTElLRXxTT1VORFMgTElLRXxYT1IpXFxiL2ksXG5cdCdwdW5jdHVhdGlvbic6IC9bO1tcXF0oKWAsLl0vXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-sql.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-swift.js":
/*!********************************************************!*\
  !*** ./node_modules/prismjs/components/prism-swift.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Prism.languages.swift = {\n\t'comment': {\n\t\t// Nested comments are supported up to 2 levels\n\t\tpattern: /(^|[^\\\\:])(?:\\/\\/.*|\\/\\*(?:[^/*]|\\/(?!\\*)|\\*(?!\\/)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*\\*\\/)/,\n\t\tlookbehind: true,\n\t\tgreedy: true\n\t},\n\t'string-literal': [\n\t\t// https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html\n\t\t{\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[^\"#])/.source\n\t\t\t\t+ '(?:'\n\t\t\t\t// single-line string\n\t\t\t\t+ /\"(?:\\\\(?:\\((?:[^()]|\\([^()]*\\))*\\)|\\r\\n|[^(])|[^\\\\\\r\\n\"])*\"/.source\n\t\t\t\t+ '|'\n\t\t\t\t// multi-line string\n\t\t\t\t+ /\"\"\"(?:\\\\(?:\\((?:[^()]|\\([^()]*\\))*\\)|[^(])|[^\\\\\"]|\"(?!\"\"))*\"\"\"/.source\n\t\t\t\t+ ')'\n\t\t\t\t+ /(?![\"#])/.source\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'interpolation': {\n\t\t\t\t\tpattern: /(\\\\\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: null // see below\n\t\t\t\t},\n\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\tpattern: /^\\)|\\\\\\($/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\t'punctuation': /\\\\(?=[\\r\\n])/,\n\t\t\t\t'string': /[\\s\\S]+/\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[^\"#])(#+)/.source\n\t\t\t\t+ '(?:'\n\t\t\t\t// single-line string\n\t\t\t\t+ /\"(?:\\\\(?:#+\\((?:[^()]|\\([^()]*\\))*\\)|\\r\\n|[^#])|[^\\\\\\r\\n])*?\"/.source\n\t\t\t\t+ '|'\n\t\t\t\t// multi-line string\n\t\t\t\t+ /\"\"\"(?:\\\\(?:#+\\((?:[^()]|\\([^()]*\\))*\\)|[^#])|[^\\\\])*?\"\"\"/.source\n\t\t\t\t+ ')'\n\t\t\t\t+ '\\\\2'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'interpolation': {\n\t\t\t\t\tpattern: /(\\\\#+\\()(?:[^()]|\\([^()]*\\))*(?=\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\tinside: null // see below\n\t\t\t\t},\n\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\tpattern: /^\\)|\\\\#+\\($/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\t'string': /[\\s\\S]+/\n\t\t\t}\n\t\t},\n\t],\n\n\t'directive': {\n\t\t// directives with conditions\n\t\tpattern: RegExp(\n\t\t\t/#/.source\n\t\t\t+ '(?:'\n\t\t\t+ (\n\t\t\t\t/(?:elseif|if)\\b/.source\n\t\t\t\t+ '(?:[ \\t]*'\n\t\t\t\t// This regex is a little complex. It's equivalent to this:\n\t\t\t\t//   (?:![ \\t]*)?(?:\\b\\w+\\b(?:[ \\t]*<round>)?|<round>)(?:[ \\t]*(?:&&|\\|\\|))?\n\t\t\t\t// where <round> is a general parentheses expression.\n\t\t\t\t+ /(?:![ \\t]*)?(?:\\b\\w+\\b(?:[ \\t]*\\((?:[^()]|\\([^()]*\\))*\\))?|\\((?:[^()]|\\([^()]*\\))*\\))(?:[ \\t]*(?:&&|\\|\\|))?/.source\n\t\t\t\t+ ')+'\n\t\t\t)\n\t\t\t+ '|'\n\t\t\t+ /(?:else|endif)\\b/.source\n\t\t\t+ ')'\n\t\t),\n\t\talias: 'property',\n\t\tinside: {\n\t\t\t'directive-name': /^#\\w+/,\n\t\t\t'boolean': /\\b(?:false|true)\\b/,\n\t\t\t'number': /\\b\\d+(?:\\.\\d+)*\\b/,\n\t\t\t'operator': /!|&&|\\|\\||[<>]=?/,\n\t\t\t'punctuation': /[(),]/\n\t\t}\n\t},\n\t'literal': {\n\t\tpattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\\b/,\n\t\talias: 'constant'\n\t},\n\t'other-directive': {\n\t\tpattern: /#\\w+\\b/,\n\t\talias: 'property'\n\t},\n\n\t'attribute': {\n\t\tpattern: /@\\w+/,\n\t\talias: 'atrule'\n\t},\n\n\t'function-definition': {\n\t\tpattern: /(\\bfunc\\s+)\\w+/,\n\t\tlookbehind: true,\n\t\talias: 'function'\n\t},\n\t'label': {\n\t\t// https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141\n\t\tpattern: /\\b(break|continue)\\s+\\w+|\\b[a-zA-Z_]\\w*(?=\\s*:\\s*(?:for|repeat|while)\\b)/,\n\t\tlookbehind: true,\n\t\talias: 'important'\n\t},\n\n\t'keyword': /\\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\\b/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'nil': {\n\t\tpattern: /\\bnil\\b/,\n\t\talias: 'constant'\n\t},\n\n\t'short-argument': /\\$\\d+\\b/,\n\t'omit': {\n\t\tpattern: /\\b_\\b/,\n\t\talias: 'keyword'\n\t},\n\t'number': /\\b(?:[\\d_]+(?:\\.[\\de_]+)?|0x[a-f0-9_]+(?:\\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\\b/i,\n\n\t// A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.\n\t'class-name': /\\b[A-Z](?:[A-Z_\\d]*[a-z]\\w*)?\\b/,\n\t'function': /\\b[a-z_]\\w*(?=\\s*\\()/i,\n\t'constant': /\\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\\b/,\n\n\t// Operators are generic in Swift. Developers can even create new operators (e.g. +++).\n\t// https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481\n\t// This regex only supports ASCII operators.\n\t'operator': /[-+*/%=!<>&|^~?]+|\\.[.\\-+*/%=!<>&|^~?]+/,\n\t'punctuation': /[{}[\\]();,.:\\\\]/\n};\n\nPrism.languages.swift['string-literal'].forEach(function (rule) {\n\trule.inside['interpolation'].inside = Prism.languages.swift;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tc3dpZnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsR0FBRzs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXN3aWZ0LmpzPzA1OTEiXSwic291cmNlc0NvbnRlbnQiOlsiUHJpc20ubGFuZ3VhZ2VzLnN3aWZ0ID0ge1xuXHQnY29tbWVudCc6IHtcblx0XHQvLyBOZXN0ZWQgY29tbWVudHMgYXJlIHN1cHBvcnRlZCB1cCB0byAyIGxldmVsc1xuXHRcdHBhdHRlcm46IC8oXnxbXlxcXFw6XSkoPzpcXC9cXC8uKnxcXC9cXCooPzpbXi8qXXxcXC8oPyFcXCopfFxcKig/IVxcLyl8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC8pKlxcKlxcLykvLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH0sXG5cdCdzdHJpbmctbGl0ZXJhbCc6IFtcblx0XHQvLyBodHRwczovL2RvY3Muc3dpZnQub3JnL3N3aWZ0LWJvb2svTGFuZ3VhZ2VHdWlkZS9TdHJpbmdzQW5kQ2hhcmFjdGVycy5odG1sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKFxuXHRcdFx0XHQvKF58W15cIiNdKS8uc291cmNlXG5cdFx0XHRcdCsgJyg/Oidcblx0XHRcdFx0Ly8gc2luZ2xlLWxpbmUgc3RyaW5nXG5cdFx0XHRcdCsgL1wiKD86XFxcXCg/OlxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpfFxcclxcbnxbXihdKXxbXlxcXFxcXHJcXG5cIl0pKlwiLy5zb3VyY2Vcblx0XHRcdFx0KyAnfCdcblx0XHRcdFx0Ly8gbXVsdGktbGluZSBzdHJpbmdcblx0XHRcdFx0KyAvXCJcIlwiKD86XFxcXCg/OlxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpfFteKF0pfFteXFxcXFwiXXxcIig/IVwiXCIpKSpcIlwiXCIvLnNvdXJjZVxuXHRcdFx0XHQrICcpJ1xuXHRcdFx0XHQrIC8oPyFbXCIjXSkvLnNvdXJjZVxuXHRcdFx0KSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J2ludGVycG9sYXRpb24nOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogLyhcXFxcXFwoKSg/OlteKCldfFxcKFteKCldKlxcKSkqKD89XFwpKS8sXG5cdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0XHRpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC9eXFwpfFxcXFxcXCgkLyxcblx0XHRcdFx0XHRhbGlhczogJ3B1bmN0dWF0aW9uJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXFxcXCg/PVtcXHJcXG5dKS8sXG5cdFx0XHRcdCdzdHJpbmcnOiAvW1xcc1xcU10rL1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKFxuXHRcdFx0XHQvKF58W15cIiNdKSgjKykvLnNvdXJjZVxuXHRcdFx0XHQrICcoPzonXG5cdFx0XHRcdC8vIHNpbmdsZS1saW5lIHN0cmluZ1xuXHRcdFx0XHQrIC9cIig/OlxcXFwoPzojK1xcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpfFxcclxcbnxbXiNdKXxbXlxcXFxcXHJcXG5dKSo/XCIvLnNvdXJjZVxuXHRcdFx0XHQrICd8J1xuXHRcdFx0XHQvLyBtdWx0aS1saW5lIHN0cmluZ1xuXHRcdFx0XHQrIC9cIlwiXCIoPzpcXFxcKD86IytcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKXxbXiNdKXxbXlxcXFxdKSo/XCJcIlwiLy5zb3VyY2Vcblx0XHRcdFx0KyAnKSdcblx0XHRcdFx0KyAnXFxcXDInXG5cdFx0XHQpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQnaW50ZXJwb2xhdGlvbic6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvKFxcXFwjK1xcKCkoPzpbXigpXXxcXChbXigpXSpcXCkpKig/PVxcKSkvLFxuXHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdFx0aW5zaWRlOiBudWxsIC8vIHNlZSBiZWxvd1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbic6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvXlxcKXxcXFxcIytcXCgkLyxcblx0XHRcdFx0XHRhbGlhczogJ3B1bmN0dWF0aW9uJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQnc3RyaW5nJzogL1tcXHNcXFNdKy9cblx0XHRcdH1cblx0XHR9LFxuXHRdLFxuXG5cdCdkaXJlY3RpdmUnOiB7XG5cdFx0Ly8gZGlyZWN0aXZlcyB3aXRoIGNvbmRpdGlvbnNcblx0XHRwYXR0ZXJuOiBSZWdFeHAoXG5cdFx0XHQvIy8uc291cmNlXG5cdFx0XHQrICcoPzonXG5cdFx0XHQrIChcblx0XHRcdFx0Lyg/OmVsc2VpZnxpZilcXGIvLnNvdXJjZVxuXHRcdFx0XHQrICcoPzpbIFxcdF0qJ1xuXHRcdFx0XHQvLyBUaGlzIHJlZ2V4IGlzIGEgbGl0dGxlIGNvbXBsZXguIEl0J3MgZXF1aXZhbGVudCB0byB0aGlzOlxuXHRcdFx0XHQvLyAgICg/OiFbIFxcdF0qKT8oPzpcXGJcXHcrXFxiKD86WyBcXHRdKjxyb3VuZD4pP3w8cm91bmQ+KSg/OlsgXFx0XSooPzomJnxcXHxcXHwpKT9cblx0XHRcdFx0Ly8gd2hlcmUgPHJvdW5kPiBpcyBhIGdlbmVyYWwgcGFyZW50aGVzZXMgZXhwcmVzc2lvbi5cblx0XHRcdFx0KyAvKD86IVsgXFx0XSopPyg/OlxcYlxcdytcXGIoPzpbIFxcdF0qXFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCkpP3xcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKSkoPzpbIFxcdF0qKD86JiZ8XFx8XFx8KSk/Ly5zb3VyY2Vcblx0XHRcdFx0KyAnKSsnXG5cdFx0XHQpXG5cdFx0XHQrICd8J1xuXHRcdFx0KyAvKD86ZWxzZXxlbmRpZilcXGIvLnNvdXJjZVxuXHRcdFx0KyAnKSdcblx0XHQpLFxuXHRcdGFsaWFzOiAncHJvcGVydHknLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J2RpcmVjdGl2ZS1uYW1lJzogL14jXFx3Ky8sXG5cdFx0XHQnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG5cdFx0XHQnbnVtYmVyJzogL1xcYlxcZCsoPzpcXC5cXGQrKSpcXGIvLFxuXHRcdFx0J29wZXJhdG9yJzogLyF8JiZ8XFx8XFx8fFs8Pl09Py8sXG5cdFx0XHQncHVuY3R1YXRpb24nOiAvWygpLF0vXG5cdFx0fVxuXHR9LFxuXHQnbGl0ZXJhbCc6IHtcblx0XHRwYXR0ZXJuOiAvIyg/OmNvbG9yTGl0ZXJhbHxjb2x1bW58ZHNvaGFuZGxlfGZpbGUoPzpJRHxMaXRlcmFsfFBhdGgpP3xmdW5jdGlvbnxpbWFnZUxpdGVyYWx8bGluZSlcXGIvLFxuXHRcdGFsaWFzOiAnY29uc3RhbnQnXG5cdH0sXG5cdCdvdGhlci1kaXJlY3RpdmUnOiB7XG5cdFx0cGF0dGVybjogLyNcXHcrXFxiLyxcblx0XHRhbGlhczogJ3Byb3BlcnR5J1xuXHR9LFxuXG5cdCdhdHRyaWJ1dGUnOiB7XG5cdFx0cGF0dGVybjogL0BcXHcrLyxcblx0XHRhbGlhczogJ2F0cnVsZSdcblx0fSxcblxuXHQnZnVuY3Rpb24tZGVmaW5pdGlvbic6IHtcblx0XHRwYXR0ZXJuOiAvKFxcYmZ1bmNcXHMrKVxcdysvLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0YWxpYXM6ICdmdW5jdGlvbidcblx0fSxcblx0J2xhYmVsJzoge1xuXHRcdC8vIGh0dHBzOi8vZG9jcy5zd2lmdC5vcmcvc3dpZnQtYm9vay9MYW5ndWFnZUd1aWRlL0NvbnRyb2xGbG93Lmh0bWwjSUQxNDFcblx0XHRwYXR0ZXJuOiAvXFxiKGJyZWFrfGNvbnRpbnVlKVxccytcXHcrfFxcYlthLXpBLVpfXVxcdyooPz1cXHMqOlxccyooPzpmb3J8cmVwZWF0fHdoaWxlKVxcYikvLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0YWxpYXM6ICdpbXBvcnRhbnQnXG5cdH0sXG5cblx0J2tleXdvcmQnOiAvXFxiKD86QW55fFByb3RvY29sfFNlbGZ8VHlwZXxhY3Rvcnxhc3xhc3NpZ25tZW50fGFzc29jaWF0ZWR0eXBlfGFzc29jaWF0aXZpdHl8YXN5bmN8YXdhaXR8YnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb250aW51ZXxjb252ZW5pZW5jZXxkZWZhdWx0fGRlZmVyfGRlaW5pdHxkaWRTZXR8ZG98ZHluYW1pY3xlbHNlfGVudW18ZXh0ZW5zaW9ufGZhbGx0aHJvdWdofGZpbGVwcml2YXRlfGZpbmFsfGZvcnxmdW5jfGdldHxndWFyZHxoaWdoZXJUaGFufGlmfGltcG9ydHxpbnxpbmRpcmVjdHxpbmZpeHxpbml0fGlub3V0fGludGVybmFsfGlzfGlzb2xhdGVkfGxhenl8bGVmdHxsZXR8bG93ZXJUaGFufG11dGF0aW5nfG5vbmV8bm9uaXNvbGF0ZWR8bm9ubXV0YXRpbmd8b3BlbnxvcGVyYXRvcnxvcHRpb25hbHxvdmVycmlkZXxwb3N0Zml4fHByZWNlZGVuY2Vncm91cHxwcmVmaXh8cHJpdmF0ZXxwcm90b2NvbHxwdWJsaWN8cmVwZWF0fHJlcXVpcmVkfHJldGhyb3dzfHJldHVybnxyaWdodHxzYWZlfHNlbGZ8c2V0fHNvbWV8c3RhdGljfHN0cnVjdHxzdWJzY3JpcHR8c3VwZXJ8c3dpdGNofHRocm93fHRocm93c3x0cnl8dHlwZWFsaWFzfHVub3duZWR8dW5zYWZlfHZhcnx3ZWFrfHdoZXJlfHdoaWxlfHdpbGxTZXQpXFxiLyxcblx0J2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuXHQnbmlsJzoge1xuXHRcdHBhdHRlcm46IC9cXGJuaWxcXGIvLFxuXHRcdGFsaWFzOiAnY29uc3RhbnQnXG5cdH0sXG5cblx0J3Nob3J0LWFyZ3VtZW50JzogL1xcJFxcZCtcXGIvLFxuXHQnb21pdCc6IHtcblx0XHRwYXR0ZXJuOiAvXFxiX1xcYi8sXG5cdFx0YWxpYXM6ICdrZXl3b3JkJ1xuXHR9LFxuXHQnbnVtYmVyJzogL1xcYig/OltcXGRfXSsoPzpcXC5bXFxkZV9dKyk/fDB4W2EtZjAtOV9dKyg/OlxcLlthLWYwLTlwX10rKT98MGJbMDFfXSt8MG9bMC03X10rKVxcYi9pLFxuXG5cdC8vIEEgY2xhc3MgbmFtZSBtdXN0IHN0YXJ0IHdpdGggYW4gdXBwZXItY2FzZSBsZXR0ZXIgYW5kIGJlIGVpdGhlciAxIGxldHRlciBsb25nIG9yIGNvbnRhaW4gYSBsb3dlci1jYXNlIGxldHRlci5cblx0J2NsYXNzLW5hbWUnOiAvXFxiW0EtWl0oPzpbQS1aX1xcZF0qW2Etel1cXHcqKT9cXGIvLFxuXHQnZnVuY3Rpb24nOiAvXFxiW2Etel9dXFx3Kig/PVxccypcXCgpL2ksXG5cdCdjb25zdGFudCc6IC9cXGIoPzpbQS1aX117Mix9fGtbQS1aXVtBLVphLXpfXSspXFxiLyxcblxuXHQvLyBPcGVyYXRvcnMgYXJlIGdlbmVyaWMgaW4gU3dpZnQuIERldmVsb3BlcnMgY2FuIGV2ZW4gY3JlYXRlIG5ldyBvcGVyYXRvcnMgKGUuZy4gKysrKS5cblx0Ly8gaHR0cHM6Ly9kb2NzLnN3aWZ0Lm9yZy9zd2lmdC1ib29rL1JlZmVyZW5jZU1hbnVhbC96elN1bW1hcnlPZlRoZUdyYW1tYXIuaHRtbCNJRDQ4MVxuXHQvLyBUaGlzIHJlZ2V4IG9ubHkgc3VwcG9ydHMgQVNDSUkgb3BlcmF0b3JzLlxuXHQnb3BlcmF0b3InOiAvWy0rKi8lPSE8PiZ8Xn4/XSt8XFwuWy5cXC0rKi8lPSE8PiZ8Xn4/XSsvLFxuXHQncHVuY3R1YXRpb24nOiAvW3t9W1xcXSgpOywuOlxcXFxdL1xufTtcblxuUHJpc20ubGFuZ3VhZ2VzLnN3aWZ0WydzdHJpbmctbGl0ZXJhbCddLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcblx0cnVsZS5pbnNpZGVbJ2ludGVycG9sYXRpb24nXS5pbnNpZGUgPSBQcmlzbS5sYW5ndWFnZXMuc3dpZnQ7XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-swift.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/components/prism-typescript.js":
/*!*************************************************************!*\
  !*** ./node_modules/prismjs/components/prism-typescript.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (Prism) {\n\n\tPrism.languages.typescript = Prism.languages.extend('javascript', {\n\t\t'class-name': {\n\t\t\tpattern: /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: null // see below\n\t\t},\n\t\t'builtin': /\\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\\b/,\n\t});\n\n\t// The keywords TypeScript adds to JavaScript\n\tPrism.languages.typescript.keyword.push(\n\t\t/\\b(?:abstract|declare|is|keyof|readonly|require)\\b/,\n\t\t// keywords that have to be followed by an identifier\n\t\t/\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/,\n\t\t// This is for `import type *, {}`\n\t\t/\\btype\\b(?=\\s*(?:[\\{*]|$))/\n\t);\n\n\t// doesn't work with TS because TS is too complex\n\tdelete Prism.languages.typescript['parameter'];\n\tdelete Prism.languages.typescript['literal-property'];\n\n\t// a version of typescript specifically for highlighting types\n\tvar typeInside = Prism.languages.extend('typescript', {});\n\tdelete typeInside['class-name'];\n\n\tPrism.languages.typescript['class-name'].inside = typeInside;\n\n\tPrism.languages.insertBefore('typescript', 'function', {\n\t\t'decorator': {\n\t\t\tpattern: /@[$\\w\\xA0-\\uFFFF]+/,\n\t\t\tinside: {\n\t\t\t\t'at': {\n\t\t\t\t\tpattern: /^@/,\n\t\t\t\t\talias: 'operator'\n\t\t\t\t},\n\t\t\t\t'function': /^[\\s\\S]+/\n\t\t\t}\n\t\t},\n\t\t'generic-function': {\n\t\t\t// e.g. foo<T extends \"bar\" | \"baz\">( ...\n\t\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n\t\t\t\t'generic': {\n\t\t\t\t\tpattern: /<[\\s\\S]+/, // everything after the first <\n\t\t\t\t\talias: 'class-name',\n\t\t\t\t\tinside: typeInside\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tPrism.languages.ts = Prism.languages.typescript;\n\n}(Prism));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tdHlwZXNjcmlwdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLG1DQUFtQztBQUNuQyx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS10eXBlc2NyaXB0LmpzPzJlYzkiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChQcmlzbSkge1xuXG5cdFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnamF2YXNjcmlwdCcsIHtcblx0XHQnY2xhc3MtbmFtZSc6IHtcblx0XHRcdHBhdHRlcm46IC8oXFxiKD86Y2xhc3N8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8aW50ZXJmYWNlfG5ld3x0eXBlKVxccyspKD8ha2V5b2ZcXGIpKD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/Olxccyo8KD86W148Pl18PCg/OltePD5dfDxbXjw+XSo+KSo+KSo+KT8vLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZTogbnVsbCAvLyBzZWUgYmVsb3dcblx0XHR9LFxuXHRcdCdidWlsdGluJzogL1xcYig/OkFycmF5fEZ1bmN0aW9ufFByb21pc2V8YW55fGJvb2xlYW58Y29uc29sZXxuZXZlcnxudW1iZXJ8c3RyaW5nfHN5bWJvbHx1bmtub3duKVxcYi8sXG5cdH0pO1xuXG5cdC8vIFRoZSBrZXl3b3JkcyBUeXBlU2NyaXB0IGFkZHMgdG8gSmF2YVNjcmlwdFxuXHRQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdC5rZXl3b3JkLnB1c2goXG5cdFx0L1xcYig/OmFic3RyYWN0fGRlY2xhcmV8aXN8a2V5b2Z8cmVhZG9ubHl8cmVxdWlyZSlcXGIvLFxuXHRcdC8vIGtleXdvcmRzIHRoYXQgaGF2ZSB0byBiZSBmb2xsb3dlZCBieSBhbiBpZGVudGlmaWVyXG5cdFx0L1xcYig/OmFzc2VydHN8aW5mZXJ8aW50ZXJmYWNlfG1vZHVsZXxuYW1lc3BhY2V8dHlwZSlcXGIoPz1cXHMqKD86W3tfJGEtekEtWlxceEEwLVxcdUZGRkZdfCQpKS8sXG5cdFx0Ly8gVGhpcyBpcyBmb3IgYGltcG9ydCB0eXBlICosIHt9YFxuXHRcdC9cXGJ0eXBlXFxiKD89XFxzKig/OltcXHsqXXwkKSkvXG5cdCk7XG5cblx0Ly8gZG9lc24ndCB3b3JrIHdpdGggVFMgYmVjYXVzZSBUUyBpcyB0b28gY29tcGxleFxuXHRkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ3BhcmFtZXRlciddO1xuXHRkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ2xpdGVyYWwtcHJvcGVydHknXTtcblxuXHQvLyBhIHZlcnNpb24gb2YgdHlwZXNjcmlwdCBzcGVjaWZpY2FsbHkgZm9yIGhpZ2hsaWdodGluZyB0eXBlc1xuXHR2YXIgdHlwZUluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ3R5cGVzY3JpcHQnLCB7fSk7XG5cdGRlbGV0ZSB0eXBlSW5zaWRlWydjbGFzcy1uYW1lJ107XG5cblx0UHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ2NsYXNzLW5hbWUnXS5pbnNpZGUgPSB0eXBlSW5zaWRlO1xuXG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3R5cGVzY3JpcHQnLCAnZnVuY3Rpb24nLCB7XG5cdFx0J2RlY29yYXRvcic6IHtcblx0XHRcdHBhdHRlcm46IC9AWyRcXHdcXHhBMC1cXHVGRkZGXSsvLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdhdCc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvXkAvLFxuXHRcdFx0XHRcdGFsaWFzOiAnb3BlcmF0b3InXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdmdW5jdGlvbic6IC9eW1xcc1xcU10rL1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0J2dlbmVyaWMtZnVuY3Rpb24nOiB7XG5cdFx0XHQvLyBlLmcuIGZvbzxUIGV4dGVuZHMgXCJiYXJcIiB8IFwiYmF6XCI+KCAuLi5cblx0XHRcdHBhdHRlcm46IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSpcXHMqPCg/OltePD5dfDwoPzpbXjw+XXw8W148Pl0qPikqPikqPig/PVxccypcXCgpLyxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQnZnVuY3Rpb24nOiAvXiM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKi8sXG5cdFx0XHRcdCdnZW5lcmljJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC88W1xcc1xcU10rLywgLy8gZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgPFxuXHRcdFx0XHRcdGFsaWFzOiAnY2xhc3MtbmFtZScsXG5cdFx0XHRcdFx0aW5zaWRlOiB0eXBlSW5zaWRlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdFByaXNtLmxhbmd1YWdlcy50cyA9IFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0O1xuXG59KFByaXNtKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/components/prism-typescript.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prismjs/prism.js":
/*!***************************************!*\
  !*** ./node_modules/prismjs/prism.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n/* **********************************************\n     Begin prism-core.js\n********************************************** */\n\n/// <reference lib=\"WebWorker\"/>\n\nvar _self = (typeof window !== 'undefined')\n\t? window   // if in browser\n\t: (\n\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t\t? self // if in worker\n\t\t\t: {}   // if in node js\n\t);\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */\nvar Prism = (function (_self) {\n\n\t// Private helper vars\n\tvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n\tvar uniqueId = 0;\n\n\t// The grammar object for plaintext\n\tvar plainTextGrammar = {};\n\n\n\tvar _ = {\n\t\t/**\n\t\t * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the\n\t\t * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load\n\t\t * additional languages or plugins yourself.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.\n\t\t *\n\t\t * You obviously have to change this value before the automatic highlighting started. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.manual = true;\n\t\t * // add a new <script> to load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tmanual: _self.Prism && _self.Prism.manual,\n\t\t/**\n\t\t * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses\n\t\t * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your\n\t\t * own worker, you don't want it to do this.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not add its own listeners to the worker.\n\t\t *\n\t\t * You obviously have to change this value before Prism executes. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.disableWorkerMessageHandler = true;\n\t\t * // Load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tdisableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n\n\t\t/**\n\t\t * A namespace for utility methods.\n\t\t *\n\t\t * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n\t\t * change or disappear at any time.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t */\n\t\tutil: {\n\t\t\tencode: function encode(tokens) {\n\t\t\t\tif (tokens instanceof Token) {\n\t\t\t\t\treturn new Token(tokens.type, encode(tokens.content), tokens.alias);\n\t\t\t\t} else if (Array.isArray(tokens)) {\n\t\t\t\t\treturn tokens.map(encode);\n\t\t\t\t} else {\n\t\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the name of the type of the given value.\n\t\t\t *\n\t\t\t * @param {any} o\n\t\t\t * @returns {string}\n\t\t\t * @example\n\t\t\t * type(null)      === 'Null'\n\t\t\t * type(undefined) === 'Undefined'\n\t\t\t * type(123)       === 'Number'\n\t\t\t * type('foo')     === 'String'\n\t\t\t * type(true)      === 'Boolean'\n\t\t\t * type([1, 2])    === 'Array'\n\t\t\t * type({})        === 'Object'\n\t\t\t * type(String)    === 'Function'\n\t\t\t * type(/abc+/)    === 'RegExp'\n\t\t\t */\n\t\t\ttype: function (o) {\n\t\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a unique number for the given object. Later calls will still return the same number.\n\t\t\t *\n\t\t\t * @param {Object} obj\n\t\t\t * @returns {number}\n\t\t\t */\n\t\t\tobjId: function (obj) {\n\t\t\t\tif (!obj['__id']) {\n\t\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t\t}\n\t\t\t\treturn obj['__id'];\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Creates a deep clone of the given object.\n\t\t\t *\n\t\t\t * The main intended use of this function is to clone language definitions.\n\t\t\t *\n\t\t\t * @param {T} o\n\t\t\t * @param {Record<number, any>} [visited]\n\t\t\t * @returns {T}\n\t\t\t * @template T\n\t\t\t */\n\t\t\tclone: function deepClone(o, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar clone; var id;\n\t\t\t\tswitch (_.util.type(o)) {\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = /** @type {Record<string, any>} */ ({});\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tclone[key] = deepClone(o[key], visited);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tcase 'Array':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\t(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {\n\t\t\t\t\t\t\tclone[i] = deepClone(v, visited);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn o;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n\t\t\t *\n\t\t\t * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @returns {string}\n\t\t\t */\n\t\t\tgetLanguage: function (element) {\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar m = lang.exec(element.className);\n\t\t\t\t\tif (m) {\n\t\t\t\t\t\treturn m[1].toLowerCase();\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn 'none';\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Sets the Prism `language-xxxx` class of the given element.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} language\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\tsetLanguage: function (element, language) {\n\t\t\t\t// remove all `language-xxxx` classes\n\t\t\t\t// (this might leave behind a leading space)\n\t\t\t\telement.className = element.className.replace(RegExp(lang, 'gi'), '');\n\n\t\t\t\t// add the new `language-xxxx` class\n\t\t\t\t// (using `classList` will automatically clean up spaces for us)\n\t\t\t\telement.classList.add('language-' + language);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the script element that is currently executing.\n\t\t\t *\n\t\t\t * This does __not__ work for line script element.\n\t\t\t *\n\t\t\t * @returns {HTMLScriptElement | null}\n\t\t\t */\n\t\t\tcurrentScript: function () {\n\t\t\t\tif (typeof document === 'undefined') {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {\n\t\t\t\t\treturn /** @type {any} */ (document.currentScript);\n\t\t\t\t}\n\n\t\t\t\t// IE11 workaround\n\t\t\t\t// we'll get the src of the current script by parsing IE11's error stack trace\n\t\t\t\t// this will not work for inline scripts\n\n\t\t\t\ttry {\n\t\t\t\t\tthrow new Error();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// Get file src url from stack. Specifically works with the format of stack traces in IE.\n\t\t\t\t\t// A stack will look like this:\n\t\t\t\t\t//\n\t\t\t\t\t// Error\n\t\t\t\t\t//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)\n\t\t\t\t\t//    at Global code (http://localhost/components/prism-core.js:606:1)\n\n\t\t\t\t\tvar src = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(err.stack) || [])[1];\n\t\t\t\t\tif (src) {\n\t\t\t\t\t\tvar scripts = document.getElementsByTagName('script');\n\t\t\t\t\t\tfor (var i in scripts) {\n\t\t\t\t\t\t\tif (scripts[i].src == src) {\n\t\t\t\t\t\t\t\treturn scripts[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns whether a given class is active for `element`.\n\t\t\t *\n\t\t\t * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n\t\t\t * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n\t\t\t * given class is just the given class with a `no-` prefix.\n\t\t\t *\n\t\t\t * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n\t\t\t * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n\t\t\t * ancestors have the given class or the negated version of it, then the default activation will be returned.\n\t\t\t *\n\t\t\t * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n\t\t\t * version of it, the class is considered active.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} className\n\t\t\t * @param {boolean} [defaultActivation=false]\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tisActive: function (element, className, defaultActivation) {\n\t\t\t\tvar no = 'no-' + className;\n\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar classList = element.classList;\n\t\t\t\t\tif (classList.contains(className)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (classList.contains(no)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn !!defaultActivation;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tlanguages: {\n\t\t\t/**\n\t\t\t * The grammar for plain, unformatted text.\n\t\t\t */\n\t\t\tplain: plainTextGrammar,\n\t\t\tplaintext: plainTextGrammar,\n\t\t\ttext: plainTextGrammar,\n\t\t\ttxt: plainTextGrammar,\n\n\t\t\t/**\n\t\t\t * Creates a deep copy of the language with the given id and appends the given tokens.\n\t\t\t *\n\t\t\t * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n\t\t\t * will be overwritten at its original position.\n\t\t\t *\n\t\t\t * ## Best practices\n\t\t\t *\n\t\t\t * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n\t\t\t * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n\t\t\t * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n\t\t\t *\n\t\t\t * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n\t\t\t * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n\t\t\t *\n\t\t\t * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n\t\t\t * @param {Grammar} redef The new tokens to append.\n\t\t\t * @returns {Grammar} The new language created.\n\t\t\t * @public\n\t\t\t * @example\n\t\t\t * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n\t\t\t *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n\t\t\t *     // at its original position\n\t\t\t *     'comment': { ... },\n\t\t\t *     // CSS doesn't have a 'color' token, so this token will be appended\n\t\t\t *     'color': /\\b(?:red|green|blue)\\b/\n\t\t\t * });\n\t\t\t */\n\t\t\textend: function (id, redef) {\n\t\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\t\tfor (var key in redef) {\n\t\t\t\t\tlang[key] = redef[key];\n\t\t\t\t}\n\n\t\t\t\treturn lang;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Inserts tokens _before_ another token in a language definition or any other grammar.\n\t\t\t *\n\t\t\t * ## Usage\n\t\t\t *\n\t\t\t * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n\t\t\t * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n\t\t\t * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n\t\t\t * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n\t\t\t * this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.markup.style = {\n\t\t\t *     // token\n\t\t\t * };\n\t\t\t * ```\n\t\t\t *\n\t\t\t * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n\t\t\t * before existing tokens. For the CSS example above, you would use it like this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'cdata', {\n\t\t\t *     'style': {\n\t\t\t *         // token\n\t\t\t *     }\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Special cases\n\t\t\t *\n\t\t\t * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n\t\t\t * will be ignored.\n\t\t\t *\n\t\t\t * This behavior can be used to insert tokens after `before`:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'comment', {\n\t\t\t *     'comment': Prism.languages.markup.comment,\n\t\t\t *     // tokens after 'comment'\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Limitations\n\t\t\t *\n\t\t\t * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n\t\t\t * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n\t\t\t * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n\t\t\t * deleting properties which is necessary to insert at arbitrary positions.\n\t\t\t *\n\t\t\t * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n\t\t\t * Instead, it will create a new object and replace all references to the target object with the new one. This\n\t\t\t * can be done without temporarily deleting properties, so the iteration order is well-defined.\n\t\t\t *\n\t\t\t * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n\t\t\t * you hold the target object in a variable, then the value of the variable will not change.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var oldMarkup = Prism.languages.markup;\n\t\t\t * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n\t\t\t *\n\t\t\t * assert(oldMarkup !== Prism.languages.markup);\n\t\t\t * assert(newMarkup === Prism.languages.markup);\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n\t\t\t * object to be modified.\n\t\t\t * @param {string} before The key to insert before.\n\t\t\t * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n\t\t\t * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n\t\t\t * object to be modified.\n\t\t\t *\n\t\t\t * Defaults to `Prism.languages`.\n\t\t\t * @returns {Grammar} The new grammar object.\n\t\t\t * @public\n\t\t\t */\n\t\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\t\troot = root || /** @type {any} */ (_.languages);\n\t\t\t\tvar grammar = root[inside];\n\t\t\t\t/** @type {Grammar} */\n\t\t\t\tvar ret = {};\n\n\t\t\t\tfor (var token in grammar) {\n\t\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\t\tif (token == before) {\n\t\t\t\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Do not insert token which also occur in insert. See #1525\n\t\t\t\t\t\tif (!insert.hasOwnProperty(token)) {\n\t\t\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar old = root[inside];\n\t\t\t\troot[inside] = ret;\n\n\t\t\t\t// Update references in other language definitions\n\t\t\t\t_.languages.DFS(_.languages, function (key, value) {\n\t\t\t\t\tif (value === old && key != inside) {\n\t\t\t\t\t\tthis[key] = ret;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn ret;\n\t\t\t},\n\n\t\t\t// Traverse a language definition with Depth First Search\n\t\t\tDFS: function DFS(o, callback, type, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar objId = _.util.objId;\n\n\t\t\t\tfor (var i in o) {\n\t\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\t\tvar property = o[i];\n\t\t\t\t\t\tvar propertyType = _.util.type(property);\n\n\t\t\t\t\t\tif (propertyType === 'Object' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, null, visited);\n\t\t\t\t\t\t} else if (propertyType === 'Array' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, i, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tplugins: {},\n\n\t\t/**\n\t\t * This is the most high-level function in Prism’s API.\n\t\t * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on\n\t\t * each one of them.\n\t\t *\n\t\t * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.\n\t\t *\n\t\t * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAll: function (async, callback) {\n\t\t\t_.highlightAllUnder(document, async, callback);\n\t\t},\n\n\t\t/**\n\t\t * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls\n\t\t * {@link Prism.highlightElement} on each one of them.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-highlightall`\n\t\t * 2. `before-all-elements-highlight`\n\t\t * 3. All hooks of {@link Prism.highlightElement} for each element.\n\t\t *\n\t\t * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n\t\t * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAllUnder: function (container, async, callback) {\n\t\t\tvar env = {\n\t\t\t\tcallback: callback,\n\t\t\t\tcontainer: container,\n\t\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n\t\t\t};\n\n\t\t\t_.hooks.run('before-highlightall', env);\n\n\t\t\tenv.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));\n\n\t\t\t_.hooks.run('before-all-elements-highlight', env);\n\n\t\t\tfor (var i = 0, element; (element = env.elements[i++]);) {\n\t\t\t\t_.highlightElement(element, async === true, env.callback);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Highlights the code inside a single element.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-sanity-check`\n\t\t * 2. `before-highlight`\n\t\t * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n\t\t * 4. `before-insert`\n\t\t * 5. `after-highlight`\n\t\t * 6. `complete`\n\t\t *\n\t\t * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n\t\t * the element's language.\n\t\t *\n\t\t * @param {Element} element The element containing the code.\n\t\t * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n\t\t * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers\n\t\t * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is\n\t\t * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).\n\t\t *\n\t\t * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for\n\t\t * asynchronous highlighting to work. You can build your own bundle on the\n\t\t * [Download page](https://prismjs.com/download.html).\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.\n\t\t * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightElement: function (element, async, callback) {\n\t\t\t// Find language\n\t\t\tvar language = _.util.getLanguage(element);\n\t\t\tvar grammar = _.languages[language];\n\n\t\t\t// Set language on the element, if not present\n\t\t\t_.util.setLanguage(element, language);\n\n\t\t\t// Set language on the parent, for styling\n\t\t\tvar parent = element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre') {\n\t\t\t\t_.util.setLanguage(parent, language);\n\t\t\t}\n\n\t\t\tvar code = element.textContent;\n\n\t\t\tvar env = {\n\t\t\t\telement: element,\n\t\t\t\tlanguage: language,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tcode: code\n\t\t\t};\n\n\t\t\tfunction insertHighlightedCode(highlightedCode) {\n\t\t\t\tenv.highlightedCode = highlightedCode;\n\n\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t}\n\n\t\t\t_.hooks.run('before-sanity-check', env);\n\n\t\t\t// plugins may change/add the parent/element\n\t\t\tparent = env.element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {\n\t\t\t\tparent.setAttribute('tabindex', '0');\n\t\t\t}\n\n\t\t\tif (!env.code) {\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_.hooks.run('before-highlight', env);\n\n\t\t\tif (!env.grammar) {\n\t\t\t\tinsertHighlightedCode(_.util.encode(env.code));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (async && _self.Worker) {\n\t\t\t\tvar worker = new Worker(_.filename);\n\n\t\t\t\tworker.onmessage = function (evt) {\n\t\t\t\t\tinsertHighlightedCode(evt.data);\n\t\t\t\t};\n\n\t\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\t\tlanguage: env.language,\n\t\t\t\t\tcode: env.code,\n\t\t\t\t\timmediateClose: true\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tinsertHighlightedCode(_.highlight(env.code, env.grammar, env.language));\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Low-level function, only use if you know what you’re doing. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns a string with the HTML produced.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-tokenize`\n\t\t * 2. `after-tokenize`\n\t\t * 3. `wrap`: On each {@link Token}.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @param {string} language The name of the language definition passed to `grammar`.\n\t\t * @returns {string} The highlighted HTML.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n\t\t */\n\t\thighlight: function (text, grammar, language) {\n\t\t\tvar env = {\n\t\t\t\tcode: text,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tlanguage: language\n\t\t\t};\n\t\t\t_.hooks.run('before-tokenize', env);\n\t\t\tif (!env.grammar) {\n\t\t\t\tthrow new Error('The language \"' + env.language + '\" has no grammar.');\n\t\t\t}\n\t\t\tenv.tokens = _.tokenize(env.code, env.grammar);\n\t\t\t_.hooks.run('after-tokenize', env);\n\t\t\treturn Token.stringify(_.util.encode(env.tokens), env.language);\n\t\t},\n\n\t\t/**\n\t\t * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns an array with the tokenized code.\n\t\t *\n\t\t * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n\t\t *\n\t\t * This method could be useful in other contexts as well, as a very crude parser.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @returns {TokenStream} An array of strings and tokens, a token stream.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * let code = `var foo = 0;`;\n\t\t * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n\t\t * tokens.forEach(token => {\n\t\t *     if (token instanceof Prism.Token && token.type === 'number') {\n\t\t *         console.log(`Found numeric literal: ${token.content}`);\n\t\t *     }\n\t\t * });\n\t\t */\n\t\ttokenize: function (text, grammar) {\n\t\t\tvar rest = grammar.rest;\n\t\t\tif (rest) {\n\t\t\t\tfor (var token in rest) {\n\t\t\t\t\tgrammar[token] = rest[token];\n\t\t\t\t}\n\n\t\t\t\tdelete grammar.rest;\n\t\t\t}\n\n\t\t\tvar tokenList = new LinkedList();\n\t\t\taddAfter(tokenList, tokenList.head, text);\n\n\t\t\tmatchGrammar(text, tokenList, grammar, tokenList.head, 0);\n\n\t\t\treturn toArray(tokenList);\n\t\t},\n\n\t\t/**\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thooks: {\n\t\t\tall: {},\n\n\t\t\t/**\n\t\t\t * Adds the given callback to the list of callbacks for the given hook.\n\t\t\t *\n\t\t\t * The callback will be invoked when the hook it is registered for is run.\n\t\t\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n\t\t\t *\n\t\t\t * One callback function can be registered to multiple hooks and the same hook multiple times.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {HookCallback} callback The callback function which is given environment variables.\n\t\t\t * @public\n\t\t\t */\n\t\t\tadd: function (name, callback) {\n\t\t\t\tvar hooks = _.hooks.all;\n\n\t\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\t\thooks[name].push(callback);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t\t\t *\n\t\t\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n\t\t\t * @public\n\t\t\t */\n\t\t\trun: function (name, env) {\n\t\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, callback; (callback = callbacks[i++]);) {\n\t\t\t\t\tcallback(env);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tToken: Token\n\t};\n\t_self.Prism = _;\n\n\n\t// Typescript note:\n\t// The following can be used to import the Token type in JSDoc:\n\t//\n\t//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n\t/**\n\t * Creates a new token.\n\t *\n\t * @param {string} type See {@link Token#type type}\n\t * @param {string | TokenStream} content See {@link Token#content content}\n\t * @param {string|string[]} [alias] The alias(es) of the token.\n\t * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n\t * @class\n\t * @global\n\t * @public\n\t */\n\tfunction Token(type, content, alias, matchedStr) {\n\t\t/**\n\t\t * The type of the token.\n\t\t *\n\t\t * This is usually the key of a pattern in a {@link Grammar}.\n\t\t *\n\t\t * @type {string}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.type = type;\n\t\t/**\n\t\t * The strings or tokens contained by this token.\n\t\t *\n\t\t * This will be a token stream if the pattern matched also defined an `inside` grammar.\n\t\t *\n\t\t * @type {string | TokenStream}\n\t\t * @public\n\t\t */\n\t\tthis.content = content;\n\t\t/**\n\t\t * The alias(es) of the token.\n\t\t *\n\t\t * @type {string|string[]}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.alias = alias;\n\t\t// Copy of the full string this token was created from\n\t\tthis.length = (matchedStr || '').length | 0;\n\t}\n\n\t/**\n\t * A token stream is an array of strings and {@link Token Token} objects.\n\t *\n\t * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n\t * them.\n\t *\n\t * 1. No adjacent strings.\n\t * 2. No empty strings.\n\t *\n\t *    The only exception here is the token stream that only contains the empty string and nothing else.\n\t *\n\t * @typedef {Array<string | Token>} TokenStream\n\t * @global\n\t * @public\n\t */\n\n\t/**\n\t * Converts the given token or token stream to an HTML representation.\n\t *\n\t * The following hooks will be run:\n\t * 1. `wrap`: On each {@link Token}.\n\t *\n\t * @param {string | Token | TokenStream} o The token or token stream to be converted.\n\t * @param {string} language The name of current language.\n\t * @returns {string} The HTML representation of the token or token stream.\n\t * @memberof Token\n\t * @static\n\t */\n\tToken.stringify = function stringify(o, language) {\n\t\tif (typeof o == 'string') {\n\t\t\treturn o;\n\t\t}\n\t\tif (Array.isArray(o)) {\n\t\t\tvar s = '';\n\t\t\to.forEach(function (e) {\n\t\t\t\ts += stringify(e, language);\n\t\t\t});\n\t\t\treturn s;\n\t\t}\n\n\t\tvar env = {\n\t\t\ttype: o.type,\n\t\t\tcontent: stringify(o.content, language),\n\t\t\ttag: 'span',\n\t\t\tclasses: ['token', o.type],\n\t\t\tattributes: {},\n\t\t\tlanguage: language\n\t\t};\n\n\t\tvar aliases = o.alias;\n\t\tif (aliases) {\n\t\t\tif (Array.isArray(aliases)) {\n\t\t\t\tArray.prototype.push.apply(env.classes, aliases);\n\t\t\t} else {\n\t\t\t\tenv.classes.push(aliases);\n\t\t\t}\n\t\t}\n\n\t\t_.hooks.run('wrap', env);\n\n\t\tvar attributes = '';\n\t\tfor (var name in env.attributes) {\n\t\t\tattributes += ' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n\t\t}\n\n\t\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + attributes + '>' + env.content + '</' + env.tag + '>';\n\t};\n\n\t/**\n\t * @param {RegExp} pattern\n\t * @param {number} pos\n\t * @param {string} text\n\t * @param {boolean} lookbehind\n\t * @returns {RegExpExecArray | null}\n\t */\n\tfunction matchPattern(pattern, pos, text, lookbehind) {\n\t\tpattern.lastIndex = pos;\n\t\tvar match = pattern.exec(text);\n\t\tif (match && lookbehind && match[1]) {\n\t\t\t// change the match to remove the text matched by the Prism lookbehind group\n\t\t\tvar lookbehindLength = match[1].length;\n\t\t\tmatch.index += lookbehindLength;\n\t\t\tmatch[0] = match[0].slice(lookbehindLength);\n\t\t}\n\t\treturn match;\n\t}\n\n\t/**\n\t * @param {string} text\n\t * @param {LinkedList<string | Token>} tokenList\n\t * @param {any} grammar\n\t * @param {LinkedListNode<string | Token>} startNode\n\t * @param {number} startPos\n\t * @param {RematchOptions} [rematch]\n\t * @returns {void}\n\t * @private\n\t *\n\t * @typedef RematchOptions\n\t * @property {string} cause\n\t * @property {number} reach\n\t */\n\tfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n\t\tfor (var token in grammar) {\n\t\t\tif (!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar patterns = grammar[token];\n\t\t\tpatterns = Array.isArray(patterns) ? patterns : [patterns];\n\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\tif (rematch && rematch.cause == token + ',' + j) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar patternObj = patterns[j];\n\t\t\t\tvar inside = patternObj.inside;\n\t\t\t\tvar lookbehind = !!patternObj.lookbehind;\n\t\t\t\tvar greedy = !!patternObj.greedy;\n\t\t\t\tvar alias = patternObj.alias;\n\n\t\t\t\tif (greedy && !patternObj.pattern.global) {\n\t\t\t\t\t// Without the global flag, lastIndex won't work\n\t\t\t\t\tvar flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n\t\t\t\t\tpatternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n\t\t\t\t}\n\n\t\t\t\t/** @type {RegExp} */\n\t\t\t\tvar pattern = patternObj.pattern || patternObj;\n\n\t\t\t\tfor ( // iterate the token list and keep track of the current token/string position\n\t\t\t\t\tvar currentNode = startNode.next, pos = startPos;\n\t\t\t\t\tcurrentNode !== tokenList.tail;\n\t\t\t\t\tpos += currentNode.value.length, currentNode = currentNode.next\n\t\t\t\t) {\n\n\t\t\t\t\tif (rematch && pos >= rematch.reach) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar str = currentNode.value;\n\n\t\t\t\t\tif (tokenList.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeCount = 1; // this is the to parameter of removeBetween\n\t\t\t\t\tvar match;\n\n\t\t\t\t\tif (greedy) {\n\t\t\t\t\t\tmatch = matchPattern(pattern, pos, text, lookbehind);\n\t\t\t\t\t\tif (!match || match.index >= text.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar from = match.index;\n\t\t\t\t\t\tvar to = match.index + match[0].length;\n\t\t\t\t\t\tvar p = pos;\n\n\t\t\t\t\t\t// find the node that contains the match\n\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\twhile (from >= p) {\n\t\t\t\t\t\t\tcurrentNode = currentNode.next;\n\t\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// adjust pos (and p)\n\t\t\t\t\t\tp -= currentNode.value.length;\n\t\t\t\t\t\tpos = p;\n\n\t\t\t\t\t\t// the current node is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\t\tif (currentNode.value instanceof Token) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the last node which is affected by this match\n\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\tvar k = currentNode;\n\t\t\t\t\t\t\tk !== tokenList.tail && (p < to || typeof k.value === 'string');\n\t\t\t\t\t\t\tk = k.next\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tremoveCount++;\n\t\t\t\t\t\t\tp += k.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoveCount--;\n\n\t\t\t\t\t\t// replace with the new match\n\t\t\t\t\t\tstr = text.slice(pos, p);\n\t\t\t\t\t\tmatch.index -= pos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = matchPattern(pattern, 0, str, lookbehind);\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// eslint-disable-next-line no-redeclare\n\t\t\t\t\tvar from = match.index;\n\t\t\t\t\tvar matchStr = match[0];\n\t\t\t\t\tvar before = str.slice(0, from);\n\t\t\t\t\tvar after = str.slice(from + matchStr.length);\n\n\t\t\t\t\tvar reach = pos + str.length;\n\t\t\t\t\tif (rematch && reach > rematch.reach) {\n\t\t\t\t\t\trematch.reach = reach;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeFrom = currentNode.prev;\n\n\t\t\t\t\tif (before) {\n\t\t\t\t\t\tremoveFrom = addAfter(tokenList, removeFrom, before);\n\t\t\t\t\t\tpos += before.length;\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveRange(tokenList, removeFrom, removeCount);\n\n\t\t\t\t\tvar wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n\t\t\t\t\tcurrentNode = addAfter(tokenList, removeFrom, wrapped);\n\n\t\t\t\t\tif (after) {\n\t\t\t\t\t\taddAfter(tokenList, currentNode, after);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (removeCount > 1) {\n\t\t\t\t\t\t// at least one Token object was removed, so we have to do some rematching\n\t\t\t\t\t\t// this can only happen if the current pattern is greedy\n\n\t\t\t\t\t\t/** @type {RematchOptions} */\n\t\t\t\t\t\tvar nestedRematch = {\n\t\t\t\t\t\t\tcause: token + ',' + j,\n\t\t\t\t\t\t\treach: reach\n\t\t\t\t\t\t};\n\t\t\t\t\t\tmatchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n\n\t\t\t\t\t\t// the reach might have been extended because of the rematching\n\t\t\t\t\t\tif (rematch && nestedRematch.reach > rematch.reach) {\n\t\t\t\t\t\t\trematch.reach = nestedRematch.reach;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @typedef LinkedListNode\n\t * @property {T} value\n\t * @property {LinkedListNode<T> | null} prev The previous node.\n\t * @property {LinkedListNode<T> | null} next The next node.\n\t * @template T\n\t * @private\n\t */\n\n\t/**\n\t * @template T\n\t * @private\n\t */\n\tfunction LinkedList() {\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar head = { value: null, prev: null, next: null };\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar tail = { value: null, prev: head, next: null };\n\t\thead.next = tail;\n\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.head = head;\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.tail = tail;\n\t\tthis.length = 0;\n\t}\n\n\t/**\n\t * Adds a new node with the given value to the list.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {T} value\n\t * @returns {LinkedListNode<T>} The added node.\n\t * @template T\n\t */\n\tfunction addAfter(list, node, value) {\n\t\t// assumes that node != list.tail && values.length >= 0\n\t\tvar next = node.next;\n\n\t\tvar newNode = { value: value, prev: node, next: next };\n\t\tnode.next = newNode;\n\t\tnext.prev = newNode;\n\t\tlist.length++;\n\n\t\treturn newNode;\n\t}\n\t/**\n\t * Removes `count` nodes after the given node. The given node will not be removed.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {number} count\n\t * @template T\n\t */\n\tfunction removeRange(list, node, count) {\n\t\tvar next = node.next;\n\t\tfor (var i = 0; i < count && next !== list.tail; i++) {\n\t\t\tnext = next.next;\n\t\t}\n\t\tnode.next = next;\n\t\tnext.prev = node;\n\t\tlist.length -= i;\n\t}\n\t/**\n\t * @param {LinkedList<T>} list\n\t * @returns {T[]}\n\t * @template T\n\t */\n\tfunction toArray(list) {\n\t\tvar array = [];\n\t\tvar node = list.head.next;\n\t\twhile (node !== list.tail) {\n\t\t\tarray.push(node.value);\n\t\t\tnode = node.next;\n\t\t}\n\t\treturn array;\n\t}\n\n\n\tif (!_self.document) {\n\t\tif (!_self.addEventListener) {\n\t\t\t// in Node.js\n\t\t\treturn _;\n\t\t}\n\n\t\tif (!_.disableWorkerMessageHandler) {\n\t\t\t// In worker\n\t\t\t_self.addEventListener('message', function (evt) {\n\t\t\t\tvar message = JSON.parse(evt.data);\n\t\t\t\tvar lang = message.language;\n\t\t\t\tvar code = message.code;\n\t\t\t\tvar immediateClose = message.immediateClose;\n\n\t\t\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\n\t\t\t\tif (immediateClose) {\n\t\t\t\t\t_self.close();\n\t\t\t\t}\n\t\t\t}, false);\n\t\t}\n\n\t\treturn _;\n\t}\n\n\t// Get current script and highlight\n\tvar script = _.util.currentScript();\n\n\tif (script) {\n\t\t_.filename = script.src;\n\n\t\tif (script.hasAttribute('data-manual')) {\n\t\t\t_.manual = true;\n\t\t}\n\t}\n\n\tfunction highlightAutomaticallyCallback() {\n\t\tif (!_.manual) {\n\t\t\t_.highlightAll();\n\t\t}\n\t}\n\n\tif (!_.manual) {\n\t\t// If the document state is \"loading\", then we'll use DOMContentLoaded.\n\t\t// If the document state is \"interactive\" and the prism.js script is deferred, then we'll also use the\n\t\t// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they\n\t\t// might take longer one animation frame to execute which can create a race condition where only some plugins have\n\t\t// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.\n\t\t// See https://github.com/PrismJS/prism/issues/2102\n\t\tvar readyState = document.readyState;\n\t\tif (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {\n\t\t\tdocument.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);\n\t\t} else {\n\t\t\tif (window.requestAnimationFrame) {\n\t\t\t\twindow.requestAnimationFrame(highlightAutomaticallyCallback);\n\t\t\t} else {\n\t\t\t\twindow.setTimeout(highlightAutomaticallyCallback, 16);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn _;\n\n}(_self));\n\nif ( true && module.exports) {\n\tmodule.exports = Prism;\n}\n\n// hack for components to work correctly in node.js\nif (typeof __webpack_require__.g !== 'undefined') {\n\t__webpack_require__.g.Prism = Prism;\n}\n\n// some additional documentation/types\n\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */\n\n/**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */\n\n/**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */\n\n/**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */\n\n\n/* **********************************************\n     Begin prism-markup.js\n********************************************** */\n\nPrism.languages.markup = {\n\t'comment': {\n\t\tpattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n\t\tgreedy: true\n\t},\n\t'prolog': {\n\t\tpattern: /<\\?[\\s\\S]+?\\?>/,\n\t\tgreedy: true\n\t},\n\t'doctype': {\n\t\t// https://www.w3.org/TR/xml/#NT-doctypedecl\n\t\tpattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'internal-subset': {\n\t\t\t\tpattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /\"[^\"]*\"|'[^']*'/,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t'punctuation': /^<!|>$|[[\\]]/,\n\t\t\t'doctype-tag': /^DOCTYPE/i,\n\t\t\t'name': /[^\\s<>'\"]+/\n\t\t}\n\t},\n\t'cdata': {\n\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\tgreedy: true\n\t},\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'special-attr': [],\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^(\\s*)[\"']|[\"']$/,\n\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': [\n\t\t{\n\t\t\tpattern: /&[\\da-z]{1,8};/i,\n\t\t\talias: 'named-entity'\n\t\t},\n\t\t/&#x?[\\da-f]{1,8};/i\n\t]\n};\n\nPrism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n\tPrism.languages.markup['entity'];\nPrism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nObject.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n\t/**\n\t * Adds an inlined language to markup.\n\t *\n\t * An example of an inlined language is CSS with `<style>` tags.\n\t *\n\t * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addInlined('style', 'css');\n\t */\n\tvalue: function addInlined(tagName, lang) {\n\t\tvar includedCdataInside = {};\n\t\tincludedCdataInside['language-' + lang] = {\n\t\t\tpattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\t\tincludedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n\n\t\tvar inside = {\n\t\t\t'included-cdata': {\n\t\t\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\t\t\tinside: includedCdataInside\n\t\t\t}\n\t\t};\n\t\tinside['language-' + lang] = {\n\t\t\tpattern: /[\\s\\S]+/,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\n\t\tvar def = {};\n\t\tdef[tagName] = {\n\t\t\tpattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: inside\n\t\t};\n\n\t\tPrism.languages.insertBefore('markup', 'cdata', def);\n\t}\n});\nObject.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n\t/**\n\t * Adds an pattern to highlight languages embedded in HTML attributes.\n\t *\n\t * An example of an inlined language is CSS with `style` attributes.\n\t *\n\t * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addAttribute('style', 'css');\n\t */\n\tvalue: function (attrName, lang) {\n\t\tPrism.languages.markup.tag.inside['special-attr'].push({\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[\"'\\s])/.source + '(?:' + attrName + ')' + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n\t\t\t\t'i'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'attr-name': /^[^\\s=]+/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /=[\\s\\S]+/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'value': {\n\t\t\t\t\t\t\tpattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: [lang, 'language-' + lang],\n\t\t\t\t\t\t\tinside: Prism.languages[lang]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/\"|'/\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\nPrism.languages.xml = Prism.languages.extend('markup', {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n\n\n/* **********************************************\n     Begin prism-css.js\n********************************************** */\n\n(function (Prism) {\n\n\tvar string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n\n\tPrism.languages.css = {\n\t\t'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n\t\t'atrule': {\n\t\t\tpattern: RegExp('@[\\\\w-](?:' + /[^;{\\s\"']|\\s+(?!\\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\\s*\\{))/.source),\n\t\t\tinside: {\n\t\t\t\t'rule': /^@[\\w-]+/,\n\t\t\t\t'selector-function-argument': {\n\t\t\t\t\tpattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'keyword': {\n\t\t\t\t\tpattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t\t// See rest below\n\t\t\t}\n\t\t},\n\t\t'url': {\n\t\t\t// https://drafts.csswg.org/css-values-3/#urls\n\t\t\tpattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^url/i,\n\t\t\t\t'punctuation': /^\\(|\\)$/,\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: RegExp('^' + string.source + '$'),\n\t\t\t\t\talias: 'url'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'selector': {\n\t\t\tpattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string': {\n\t\t\tpattern: string,\n\t\t\tgreedy: true\n\t\t},\n\t\t'property': {\n\t\t\tpattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'important': /!important\\b/i,\n\t\t'function': {\n\t\t\tpattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'punctuation': /[(){};:,]/\n\t};\n\n\tPrism.languages.css['atrule'].inside.rest = Prism.languages.css;\n\n\tvar markup = Prism.languages.markup;\n\tif (markup) {\n\t\tmarkup.tag.addInlined('style', 'css');\n\t\tmarkup.tag.addAttribute('style', 'css');\n\t}\n\n}(Prism));\n\n\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */\n\nPrism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /[.\\\\]/\n\t\t}\n\t},\n\t'keyword': /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'function': /\\b\\w+(?=\\()/,\n\t'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n\t'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\n\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n\t'class-name': [\n\t\tPrism.languages.clike['class-name'],\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'keyword': [\n\t\t{\n\t\t\tpattern: /((?:^|\\})\\s*)catch\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t],\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n\t'number': {\n\t\tpattern: RegExp(\n\t\t\t/(^|[^\\w$])/.source +\n\t\t\t'(?:' +\n\t\t\t(\n\t\t\t\t// constant\n\t\t\t\t/NaN|Infinity/.source +\n\t\t\t\t'|' +\n\t\t\t\t// binary integer\n\t\t\t\t/0[bB][01]+(?:_[01]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// octal integer\n\t\t\t\t/0[oO][0-7]+(?:_[0-7]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// hexadecimal integer\n\t\t\t\t/0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal bigint\n\t\t\t\t/\\d+(?:_\\d+)*n/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal number (integer or float) but no bigint\n\t\t\t\t/(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source\n\t\t\t) +\n\t\t\t')' +\n\t\t\t/(?![\\w$])/.source\n\t\t),\n\t\tlookbehind: true\n\t},\n\t'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\n\nPrism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: RegExp(\n\t\t\t// lookbehind\n\t\t\t// eslint-disable-next-line regexp/no-dupe-characters-character-class\n\t\t\t/((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source +\n\t\t\t// Regex pattern:\n\t\t\t// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n\t\t\t// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n\t\t\t// with the only syntax, so we have to define 2 different regex patterns.\n\t\t\t/\\//.source +\n\t\t\t'(?:' +\n\t\t\t/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source +\n\t\t\t'|' +\n\t\t\t// `v` flag syntax. This supports 3 levels of nested character classes.\n\t\t\t/(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +\n\t\t\t')' +\n\t\t\t// lookahead\n\t\t\t/(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source\n\t\t),\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'regex-source': {\n\t\t\t\tpattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'language-regex',\n\t\t\t\tinside: Prism.languages.regex\n\t\t\t},\n\t\t\t'regex-delimiter': /^\\/|\\/$/,\n\t\t\t'regex-flags': /^[a-z]+$/,\n\t\t}\n\t},\n\t// This must be declared before keyword because we use \"function\" inside the look-forward\n\t'function-variable': {\n\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n\t\talias: 'function'\n\t},\n\t'parameter': [\n\t\t{\n\t\t\tpattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t}\n\t],\n\t'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n\t'hashbang': {\n\t\tpattern: /^#!.*/,\n\t\tgreedy: true,\n\t\talias: 'comment'\n\t},\n\t'template-string': {\n\t\tpattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'template-punctuation': {\n\t\t\t\tpattern: /^`|`$/,\n\t\t\t\talias: 'string'\n\t\t\t},\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\t'string-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\talias: 'property'\n\t}\n});\n\nPrism.languages.insertBefore('javascript', 'operator', {\n\t'literal-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\talias: 'property'\n\t},\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.markup.tag.addInlined('script', 'javascript');\n\n\t// add attribute support for all DOM events.\n\t// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n\tPrism.languages.markup.tag.addAttribute(\n\t\t/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,\n\t\t'javascript'\n\t);\n}\n\nPrism.languages.js = Prism.languages.javascript;\n\n\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */\n\n(function () {\n\n\tif (typeof Prism === 'undefined' || typeof document === 'undefined') {\n\t\treturn;\n\t}\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\n\tif (!Element.prototype.matches) {\n\t\tElement.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\t}\n\n\tvar LOADING_MESSAGE = 'Loading…';\n\tvar FAILURE_MESSAGE = function (status, message) {\n\t\treturn '✖ Error ' + status + ' while fetching file: ' + message;\n\t};\n\tvar FAILURE_EMPTY_MESSAGE = '✖ Error: File does not exist or is empty';\n\n\tvar EXTENSIONS = {\n\t\t'js': 'javascript',\n\t\t'py': 'python',\n\t\t'rb': 'ruby',\n\t\t'ps1': 'powershell',\n\t\t'psm1': 'powershell',\n\t\t'sh': 'bash',\n\t\t'bat': 'batch',\n\t\t'h': 'c',\n\t\t'tex': 'latex'\n\t};\n\n\tvar STATUS_ATTR = 'data-src-status';\n\tvar STATUS_LOADING = 'loading';\n\tvar STATUS_LOADED = 'loaded';\n\tvar STATUS_FAILED = 'failed';\n\n\tvar SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '=\"' + STATUS_LOADED + '\"])'\n\t\t+ ':not([' + STATUS_ATTR + '=\"' + STATUS_LOADING + '\"])';\n\n\t/**\n\t * Loads the given file.\n\t *\n\t * @param {string} src The URL or path of the source file to load.\n\t * @param {(result: string) => void} success\n\t * @param {(reason: string) => void} error\n\t */\n\tfunction loadFile(src, success, error) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.open('GET', src, true);\n\t\txhr.onreadystatechange = function () {\n\t\t\tif (xhr.readyState == 4) {\n\t\t\t\tif (xhr.status < 400 && xhr.responseText) {\n\t\t\t\t\tsuccess(xhr.responseText);\n\t\t\t\t} else {\n\t\t\t\t\tif (xhr.status >= 400) {\n\t\t\t\t\t\terror(FAILURE_MESSAGE(xhr.status, xhr.statusText));\n\t\t\t\t\t} else {\n\t\t\t\t\t\terror(FAILURE_EMPTY_MESSAGE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\txhr.send(null);\n\t}\n\n\t/**\n\t * Parses the given range.\n\t *\n\t * This returns a range with inclusive ends.\n\t *\n\t * @param {string | null | undefined} range\n\t * @returns {[number, number | undefined] | undefined}\n\t */\n\tfunction parseRange(range) {\n\t\tvar m = /^\\s*(\\d+)\\s*(?:(,)\\s*(?:(\\d+)\\s*)?)?$/.exec(range || '');\n\t\tif (m) {\n\t\t\tvar start = Number(m[1]);\n\t\t\tvar comma = m[2];\n\t\t\tvar end = m[3];\n\n\t\t\tif (!comma) {\n\t\t\t\treturn [start, start];\n\t\t\t}\n\t\t\tif (!end) {\n\t\t\t\treturn [start, undefined];\n\t\t\t}\n\t\t\treturn [start, Number(end)];\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tPrism.hooks.add('before-highlightall', function (env) {\n\t\tenv.selector += ', ' + SELECTOR;\n\t});\n\n\tPrism.hooks.add('before-sanity-check', function (env) {\n\t\tvar pre = /** @type {HTMLPreElement} */ (env.element);\n\t\tif (pre.matches(SELECTOR)) {\n\t\t\tenv.code = ''; // fast-path the whole thing and go to complete\n\n\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading\n\n\t\t\t// add code element with loading message\n\t\t\tvar code = pre.appendChild(document.createElement('CODE'));\n\t\t\tcode.textContent = LOADING_MESSAGE;\n\n\t\t\tvar src = pre.getAttribute('data-src');\n\n\t\t\tvar language = env.language;\n\t\t\tif (language === 'none') {\n\t\t\t\t// the language might be 'none' because there is no language set;\n\t\t\t\t// in this case, we want to use the extension as the language\n\t\t\t\tvar extension = (/\\.(\\w+)$/.exec(src) || [, 'none'])[1];\n\t\t\t\tlanguage = EXTENSIONS[extension] || extension;\n\t\t\t}\n\n\t\t\t// set language classes\n\t\t\tPrism.util.setLanguage(code, language);\n\t\t\tPrism.util.setLanguage(pre, language);\n\n\t\t\t// preload the language\n\t\t\tvar autoloader = Prism.plugins.autoloader;\n\t\t\tif (autoloader) {\n\t\t\t\tautoloader.loadLanguages(language);\n\t\t\t}\n\n\t\t\t// load file\n\t\t\tloadFile(\n\t\t\t\tsrc,\n\t\t\t\tfunction (text) {\n\t\t\t\t\t// mark as loaded\n\t\t\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_LOADED);\n\n\t\t\t\t\t// handle data-range\n\t\t\t\t\tvar range = parseRange(pre.getAttribute('data-range'));\n\t\t\t\t\tif (range) {\n\t\t\t\t\t\tvar lines = text.split(/\\r\\n?|\\n/g);\n\n\t\t\t\t\t\t// the range is one-based and inclusive on both ends\n\t\t\t\t\t\tvar start = range[0];\n\t\t\t\t\t\tvar end = range[1] == null ? lines.length : range[1];\n\n\t\t\t\t\t\tif (start < 0) { start += lines.length; }\n\t\t\t\t\t\tstart = Math.max(0, Math.min(start - 1, lines.length));\n\t\t\t\t\t\tif (end < 0) { end += lines.length; }\n\t\t\t\t\t\tend = Math.max(0, Math.min(end, lines.length));\n\n\t\t\t\t\t\ttext = lines.slice(start, end).join('\\n');\n\n\t\t\t\t\t\t// add data-start for line numbers\n\t\t\t\t\t\tif (!pre.hasAttribute('data-start')) {\n\t\t\t\t\t\t\tpre.setAttribute('data-start', String(start + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// highlight code\n\t\t\t\t\tcode.textContent = text;\n\t\t\t\t\tPrism.highlightElement(code);\n\t\t\t\t},\n\t\t\t\tfunction (error) {\n\t\t\t\t\t// mark as failed\n\t\t\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_FAILED);\n\n\t\t\t\t\tcode.textContent = error;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t});\n\n\tPrism.plugins.fileHighlight = {\n\t\t/**\n\t\t * Executes the File Highlight plugin for all matching `pre` elements under the given container.\n\t\t *\n\t\t * Note: Elements which are already loaded or currently loading will not be touched by this method.\n\t\t *\n\t\t * @param {ParentNode} [container=document]\n\t\t */\n\t\thighlight: function highlight(container) {\n\t\t\tvar elements = (container || document).querySelectorAll(SELECTOR);\n\n\t\t\tfor (var i = 0, element; (element = elements[i++]);) {\n\t\t\t\tPrism.highlightElement(element);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar logged = false;\n\t/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */\n\tPrism.fileHighlight = function () {\n\t\tif (!logged) {\n\t\t\tconsole.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');\n\t\t\tlogged = true;\n\t\t}\n\t\tPrism.plugins.fileHighlight.highlight.apply(this, arguments);\n\t};\n\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcmlzbWpzL3ByaXNtLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxnRkFBZ0YseUJBQXlCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ04sdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQixjQUFjLHFCQUFxQjtBQUNuQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUIsTUFBTTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixLQUFLOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTyxjQUFjLEtBQUs7QUFDNUM7QUFDQSxPQUFPOztBQUVQLHdCQUF3QixLQUFLOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSztBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsS0FBSztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBLGVBQWUsU0FBUztBQUN4Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsYUFBYTs7QUFFYjtBQUNBO0FBQ0Esb0ZBQW9GLDhCQUE4QjtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUywwQkFBMEIsOEJBQThCO0FBQzlFLGFBQWEsbUJBQW1CLHVCQUF1Qiw4QkFBOEI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLE1BQU0sOEJBQThCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qiw0QkFBNEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBK0M7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUSxVQUFVO0FBQzlCLFlBQVksc0JBQXNCLGFBQWE7QUFDL0MsWUFBWSxpQkFBaUI7QUFDN0IsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLG1CQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBLFlBQVksOEJBQThCO0FBQzFDLFlBQVksUUFBUTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVGQUF1RjtBQUN2Rjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSw0QkFBNEI7QUFDeEMsWUFBWSxLQUFLO0FBQ2pCLFlBQVksZ0NBQWdDO0FBQzVDLFlBQVksUUFBUTtBQUNwQixZQUFZLGdCQUFnQjtBQUM1QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGVBQWU7QUFDZixhQUFhLG1CQUFtQjtBQUNoQyxlQUFlO0FBQ2Y7O0FBRUEsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksbUJBQW1CO0FBQy9CLFlBQVksR0FBRztBQUNmLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksbUJBQW1CO0FBQy9CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7O0FBRUQsSUFBSSxLQUE2QjtBQUNqQztBQUNBOztBQUVBO0FBQ0EsV0FBVyxxQkFBTTtBQUNqQixDQUFDLHFCQUFNO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsaUJBQWlCO0FBQy9CLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBLEdBQUc7QUFDSCxlQUFlLEtBQUs7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtJQUErSSxpQkFBaUI7QUFDaEs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2REFBNkQsU0FBUztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDBCQUEwQixTQUFTLFlBQVksb0JBQW9CLG9DQUFvQztBQUN2RztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdCQUF3QjtBQUN4Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEI7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLEdBQUc7QUFDSDtBQUNBLHFEQUFxRCwrSkFBK0o7QUFDcE47QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLG1GQUFtRixFQUFFO0FBQ3JGLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELElBQUk7QUFDbEU7QUFDQTtBQUNBLG1IQUFtSCxJQUFJLFdBQVcsSUFBSTtBQUN0STtBQUNBO0FBQ0Esc0RBQXNELEVBQUU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsdWZBQXVmO0FBQ3ZmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSw2QkFBNkIsT0FBTyxJQUFJLE9BQU8sSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdDQUFnQyxFQUFFLE9BQU8sT0FBTyxJQUFJLE9BQU8sSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixHQUFHO0FBQ3hCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSwwQkFBMEI7QUFDdEMsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0Esa0JBQWtCOztBQUVsQixrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJpc21qcy9wcmlzbS5qcz8zN2IzIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jb3JlLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbi8vLyA8cmVmZXJlbmNlIGxpYj1cIldlYldvcmtlclwiLz5cblxudmFyIF9zZWxmID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKVxuXHQ/IHdpbmRvdyAgIC8vIGlmIGluIGJyb3dzZXJcblx0OiAoXG5cdFx0KHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKVxuXHRcdFx0PyBzZWxmIC8vIGlmIGluIHdvcmtlclxuXHRcdFx0OiB7fSAgIC8vIGlmIGluIG5vZGUganNcblx0KTtcblxuLyoqXG4gKiBQcmlzbTogTGlnaHR3ZWlnaHQsIHJvYnVzdCwgZWxlZ2FudCBzeW50YXggaGlnaGxpZ2h0aW5nXG4gKlxuICogQGxpY2Vuc2UgTUlUIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD5cbiAqIEBhdXRob3IgTGVhIFZlcm91IDxodHRwczovL2xlYS52ZXJvdS5tZT5cbiAqIEBuYW1lc3BhY2VcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFByaXNtID0gKGZ1bmN0aW9uIChfc2VsZikge1xuXG5cdC8vIFByaXZhdGUgaGVscGVyIHZhcnNcblx0dmFyIGxhbmcgPSAvKD86XnxcXHMpbGFuZyg/OnVhZ2UpPy0oW1xcdy1dKykoPz1cXHN8JCkvaTtcblx0dmFyIHVuaXF1ZUlkID0gMDtcblxuXHQvLyBUaGUgZ3JhbW1hciBvYmplY3QgZm9yIHBsYWludGV4dFxuXHR2YXIgcGxhaW5UZXh0R3JhbW1hciA9IHt9O1xuXG5cblx0dmFyIF8gPSB7XG5cdFx0LyoqXG5cdFx0ICogQnkgZGVmYXVsdCwgUHJpc20gd2lsbCBhdHRlbXB0IHRvIGhpZ2hsaWdodCBhbGwgY29kZSBlbGVtZW50cyAoYnkgY2FsbGluZyB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0QWxsfSkgb24gdGhlXG5cdFx0ICogY3VycmVudCBwYWdlIGFmdGVyIHRoZSBwYWdlIGZpbmlzaGVkIGxvYWRpbmcuIFRoaXMgbWlnaHQgYmUgYSBwcm9ibGVtIGlmIGUuZy4geW91IHdhbnRlZCB0byBhc3luY2hyb25vdXNseSBsb2FkXG5cdFx0ICogYWRkaXRpb25hbCBsYW5ndWFnZXMgb3IgcGx1Z2lucyB5b3Vyc2VsZi5cblx0XHQgKlxuXHRcdCAqIEJ5IHNldHRpbmcgdGhpcyB2YWx1ZSB0byBgdHJ1ZWAsIFByaXNtIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgaGlnaGxpZ2h0IGFsbCBjb2RlIGVsZW1lbnRzIG9uIHRoZSBwYWdlLlxuXHRcdCAqXG5cdFx0ICogWW91IG9idmlvdXNseSBoYXZlIHRvIGNoYW5nZSB0aGlzIHZhbHVlIGJlZm9yZSB0aGUgYXV0b21hdGljIGhpZ2hsaWdodGluZyBzdGFydGVkLiBUbyBkbyB0aGlzLCB5b3UgY2FuIGFkZCBhblxuXHRcdCAqIGVtcHR5IFByaXNtIG9iamVjdCBpbnRvIHRoZSBnbG9iYWwgc2NvcGUgYmVmb3JlIGxvYWRpbmcgdGhlIFByaXNtIHNjcmlwdCBsaWtlIHRoaXM6XG5cdFx0ICpcblx0XHQgKiBgYGBqc1xuXHRcdCAqIHdpbmRvdy5QcmlzbSA9IHdpbmRvdy5QcmlzbSB8fCB7fTtcblx0XHQgKiBQcmlzbS5tYW51YWwgPSB0cnVlO1xuXHRcdCAqIC8vIGFkZCBhIG5ldyA8c2NyaXB0PiB0byBsb2FkIFByaXNtJ3Mgc2NyaXB0XG5cdFx0ICogYGBgXG5cdFx0ICpcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRtYW51YWw6IF9zZWxmLlByaXNtICYmIF9zZWxmLlByaXNtLm1hbnVhbCxcblx0XHQvKipcblx0XHQgKiBCeSBkZWZhdWx0LCBpZiBQcmlzbSBpcyBpbiBhIHdlYiB3b3JrZXIsIGl0IGFzc3VtZXMgdGhhdCBpdCBpcyBpbiBhIHdvcmtlciBpdCBjcmVhdGVkIGl0c2VsZiwgc28gaXQgdXNlc1xuXHRcdCAqIGBhZGRFdmVudExpc3RlbmVyYCB0byBjb21tdW5pY2F0ZSB3aXRoIGl0cyBwYXJlbnQgaW5zdGFuY2UuIEhvd2V2ZXIsIGlmIHlvdSdyZSB1c2luZyBQcmlzbSBtYW51YWxseSBpbiB5b3VyXG5cdFx0ICogb3duIHdvcmtlciwgeW91IGRvbid0IHdhbnQgaXQgdG8gZG8gdGhpcy5cblx0XHQgKlxuXHRcdCAqIEJ5IHNldHRpbmcgdGhpcyB2YWx1ZSB0byBgdHJ1ZWAsIFByaXNtIHdpbGwgbm90IGFkZCBpdHMgb3duIGxpc3RlbmVycyB0byB0aGUgd29ya2VyLlxuXHRcdCAqXG5cdFx0ICogWW91IG9idmlvdXNseSBoYXZlIHRvIGNoYW5nZSB0aGlzIHZhbHVlIGJlZm9yZSBQcmlzbSBleGVjdXRlcy4gVG8gZG8gdGhpcywgeW91IGNhbiBhZGQgYW5cblx0XHQgKiBlbXB0eSBQcmlzbSBvYmplY3QgaW50byB0aGUgZ2xvYmFsIHNjb3BlIGJlZm9yZSBsb2FkaW5nIHRoZSBQcmlzbSBzY3JpcHQgbGlrZSB0aGlzOlxuXHRcdCAqXG5cdFx0ICogYGBganNcblx0XHQgKiB3aW5kb3cuUHJpc20gPSB3aW5kb3cuUHJpc20gfHwge307XG5cdFx0ICogUHJpc20uZGlzYWJsZVdvcmtlck1lc3NhZ2VIYW5kbGVyID0gdHJ1ZTtcblx0XHQgKiAvLyBMb2FkIFByaXNtJ3Mgc2NyaXB0XG5cdFx0ICogYGBgXG5cdFx0ICpcblx0XHQgKiBAZGVmYXVsdCBmYWxzZVxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRkaXNhYmxlV29ya2VyTWVzc2FnZUhhbmRsZXI6IF9zZWxmLlByaXNtICYmIF9zZWxmLlByaXNtLmRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlcixcblxuXHRcdC8qKlxuXHRcdCAqIEEgbmFtZXNwYWNlIGZvciB1dGlsaXR5IG1ldGhvZHMuXG5cdFx0ICpcblx0XHQgKiBBbGwgZnVuY3Rpb24gaW4gdGhpcyBuYW1lc3BhY2UgdGhhdCBhcmUgbm90IGV4cGxpY2l0bHkgbWFya2VkIGFzIF9wdWJsaWNfIGFyZSBmb3IgX19pbnRlcm5hbCB1c2Ugb25seV9fIGFuZCBtYXlcblx0XHQgKiBjaGFuZ2Ugb3IgZGlzYXBwZWFyIGF0IGFueSB0aW1lLlxuXHRcdCAqXG5cdFx0ICogQG5hbWVzcGFjZVxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqL1xuXHRcdHV0aWw6IHtcblx0XHRcdGVuY29kZTogZnVuY3Rpb24gZW5jb2RlKHRva2Vucykge1xuXHRcdFx0XHRpZiAodG9rZW5zIGluc3RhbmNlb2YgVG9rZW4pIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFRva2VuKHRva2Vucy50eXBlLCBlbmNvZGUodG9rZW5zLmNvbnRlbnQpLCB0b2tlbnMuYWxpYXMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodG9rZW5zKSkge1xuXHRcdFx0XHRcdHJldHVybiB0b2tlbnMubWFwKGVuY29kZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRva2Vucy5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC9cXHUwMGEwL2csICcgJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgdHlwZSBvZiB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHthbnl9IG9cblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogdHlwZShudWxsKSAgICAgID09PSAnTnVsbCdcblx0XHRcdCAqIHR5cGUodW5kZWZpbmVkKSA9PT0gJ1VuZGVmaW5lZCdcblx0XHRcdCAqIHR5cGUoMTIzKSAgICAgICA9PT0gJ051bWJlcidcblx0XHRcdCAqIHR5cGUoJ2ZvbycpICAgICA9PT0gJ1N0cmluZydcblx0XHRcdCAqIHR5cGUodHJ1ZSkgICAgICA9PT0gJ0Jvb2xlYW4nXG5cdFx0XHQgKiB0eXBlKFsxLCAyXSkgICAgPT09ICdBcnJheSdcblx0XHRcdCAqIHR5cGUoe30pICAgICAgICA9PT0gJ09iamVjdCdcblx0XHRcdCAqIHR5cGUoU3RyaW5nKSAgICA9PT0gJ0Z1bmN0aW9uJ1xuXHRcdFx0ICogdHlwZSgvYWJjKy8pICAgID09PSAnUmVnRXhwJ1xuXHRcdFx0ICovXG5cdFx0XHR0eXBlOiBmdW5jdGlvbiAobykge1xuXHRcdFx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyBhIHVuaXF1ZSBudW1iZXIgZm9yIHRoZSBnaXZlbiBvYmplY3QuIExhdGVyIGNhbGxzIHdpbGwgc3RpbGwgcmV0dXJuIHRoZSBzYW1lIG51bWJlci5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdFx0XHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHRcdFx0ICovXG5cdFx0XHRvYmpJZDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRpZiAoIW9ialsnX19pZCddKSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ19faWQnLCB7IHZhbHVlOiArK3VuaXF1ZUlkIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmpbJ19faWQnXTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgdGhlIGdpdmVuIG9iamVjdC5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgbWFpbiBpbnRlbmRlZCB1c2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBjbG9uZSBsYW5ndWFnZSBkZWZpbml0aW9ucy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge1R9IG9cblx0XHRcdCAqIEBwYXJhbSB7UmVjb3JkPG51bWJlciwgYW55Pn0gW3Zpc2l0ZWRdXG5cdFx0XHQgKiBAcmV0dXJucyB7VH1cblx0XHRcdCAqIEB0ZW1wbGF0ZSBUXG5cdFx0XHQgKi9cblx0XHRcdGNsb25lOiBmdW5jdGlvbiBkZWVwQ2xvbmUobywgdmlzaXRlZCkge1xuXHRcdFx0XHR2aXNpdGVkID0gdmlzaXRlZCB8fCB7fTtcblxuXHRcdFx0XHR2YXIgY2xvbmU7IHZhciBpZDtcblx0XHRcdFx0c3dpdGNoIChfLnV0aWwudHlwZShvKSkge1xuXHRcdFx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRcdFx0XHRpZCA9IF8udXRpbC5vYmpJZChvKTtcblx0XHRcdFx0XHRcdGlmICh2aXNpdGVkW2lkXSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmlzaXRlZFtpZF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjbG9uZSA9IC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi8gKHt9KTtcblx0XHRcdFx0XHRcdHZpc2l0ZWRbaWRdID0gY2xvbmU7XG5cblx0XHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBvKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRcdFx0XHRjbG9uZVtrZXldID0gZGVlcENsb25lKG9ba2V5XSwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAoY2xvbmUpO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRcdFx0aWQgPSBfLnV0aWwub2JqSWQobyk7XG5cdFx0XHRcdFx0XHRpZiAodmlzaXRlZFtpZF0pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZpc2l0ZWRbaWRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHRcdHZpc2l0ZWRbaWRdID0gY2xvbmU7XG5cblx0XHRcdFx0XHRcdCgvKiogQHR5cGUge0FycmF5fSAqLygvKiogQHR5cGUge2FueX0gKi8obykpKS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XG5cdFx0XHRcdFx0XHRcdGNsb25lW2ldID0gZGVlcENsb25lKHYsIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKGNsb25lKTtcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRyZXR1cm4gbztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIHRoZSBQcmlzbSBsYW5ndWFnZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBzZXQgYnkgYSBgbGFuZ3VhZ2UteHh4eGAgb3IgYGxhbmcteHh4eGAgY2xhc3MuXG5cdFx0XHQgKlxuXHRcdFx0ICogSWYgbm8gbGFuZ3VhZ2UgaXMgc2V0IGZvciB0aGUgZWxlbWVudCBvciB0aGUgZWxlbWVudCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIGBub25lYCB3aWxsIGJlIHJldHVybmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ31cblx0XHRcdCAqL1xuXHRcdFx0Z2V0TGFuZ3VhZ2U6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0XHRcdHdoaWxlIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0dmFyIG0gPSBsYW5nLmV4ZWMoZWxlbWVudC5jbGFzc05hbWUpO1xuXHRcdFx0XHRcdGlmIChtKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbVsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAnbm9uZSc7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldHMgdGhlIFByaXNtIGBsYW5ndWFnZS14eHh4YCBjbGFzcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZVxuXHRcdFx0ICogQHJldHVybnMge3ZvaWR9XG5cdFx0XHQgKi9cblx0XHRcdHNldExhbmd1YWdlOiBmdW5jdGlvbiAoZWxlbWVudCwgbGFuZ3VhZ2UpIHtcblx0XHRcdFx0Ly8gcmVtb3ZlIGFsbCBgbGFuZ3VhZ2UteHh4eGAgY2xhc3Nlc1xuXHRcdFx0XHQvLyAodGhpcyBtaWdodCBsZWF2ZSBiZWhpbmQgYSBsZWFkaW5nIHNwYWNlKVxuXHRcdFx0XHRlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoUmVnRXhwKGxhbmcsICdnaScpLCAnJyk7XG5cblx0XHRcdFx0Ly8gYWRkIHRoZSBuZXcgYGxhbmd1YWdlLXh4eHhgIGNsYXNzXG5cdFx0XHRcdC8vICh1c2luZyBgY2xhc3NMaXN0YCB3aWxsIGF1dG9tYXRpY2FsbHkgY2xlYW4gdXAgc3BhY2VzIGZvciB1cylcblx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdsYW5ndWFnZS0nICsgbGFuZ3VhZ2UpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIHRoZSBzY3JpcHQgZWxlbWVudCB0aGF0IGlzIGN1cnJlbnRseSBleGVjdXRpbmcuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhpcyBkb2VzIF9fbm90X18gd29yayBmb3IgbGluZSBzY3JpcHQgZWxlbWVudC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcmV0dXJucyB7SFRNTFNjcmlwdEVsZW1lbnQgfCBudWxsfVxuXHRcdFx0ICovXG5cdFx0XHRjdXJyZW50U2NyaXB0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCdjdXJyZW50U2NyaXB0JyBpbiBkb2N1bWVudCAmJiAxIDwgMiAvKiBoYWNrIHRvIHRyaXAgVFMnIGZsb3cgYW5hbHlzaXMgKi8pIHtcblx0XHRcdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElFMTEgd29ya2Fyb3VuZFxuXHRcdFx0XHQvLyB3ZSdsbCBnZXQgdGhlIHNyYyBvZiB0aGUgY3VycmVudCBzY3JpcHQgYnkgcGFyc2luZyBJRTExJ3MgZXJyb3Igc3RhY2sgdHJhY2Vcblx0XHRcdFx0Ly8gdGhpcyB3aWxsIG5vdCB3b3JrIGZvciBpbmxpbmUgc2NyaXB0c1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdC8vIEdldCBmaWxlIHNyYyB1cmwgZnJvbSBzdGFjay4gU3BlY2lmaWNhbGx5IHdvcmtzIHdpdGggdGhlIGZvcm1hdCBvZiBzdGFjayB0cmFjZXMgaW4gSUUuXG5cdFx0XHRcdFx0Ly8gQSBzdGFjayB3aWxsIGxvb2sgbGlrZSB0aGlzOlxuXHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0Ly8gRXJyb3Jcblx0XHRcdFx0XHQvLyAgICBhdCBfLnV0aWwuY3VycmVudFNjcmlwdCAoaHR0cDovL2xvY2FsaG9zdC9jb21wb25lbnRzL3ByaXNtLWNvcmUuanM6MTE5OjUpXG5cdFx0XHRcdFx0Ly8gICAgYXQgR2xvYmFsIGNvZGUgKGh0dHA6Ly9sb2NhbGhvc3QvY29tcG9uZW50cy9wcmlzbS1jb3JlLmpzOjYwNjoxKVxuXG5cdFx0XHRcdFx0dmFyIHNyYyA9ICgvYXQgW14oXFxyXFxuXSpcXCgoLiopOlteOl0rOlteOl0rXFwpJC9pLmV4ZWMoZXJyLnN0YWNrKSB8fCBbXSlbMV07XG5cdFx0XHRcdFx0aWYgKHNyYykge1xuXHRcdFx0XHRcdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpIGluIHNjcmlwdHMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHNjcmlwdHNbaV0uc3JjID09IHNyYykge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBzY3JpcHRzW2ldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgd2hldGhlciBhIGdpdmVuIGNsYXNzIGlzIGFjdGl2ZSBmb3IgYGVsZW1lbnRgLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBjbGFzcyBjYW4gYmUgYWN0aXZhdGVkIGlmIGBlbGVtZW50YCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgdGhlIGdpdmVuIGNsYXNzIGFuZCBpdCBjYW4gYmUgZGVhY3RpdmF0ZWRcblx0XHRcdCAqIGlmIGBlbGVtZW50YCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gY2xhc3MuIFRoZSBfbmVnYXRlZCB2ZXJzaW9uXyBvZiB0aGVcblx0XHRcdCAqIGdpdmVuIGNsYXNzIGlzIGp1c3QgdGhlIGdpdmVuIGNsYXNzIHdpdGggYSBgbm8tYCBwcmVmaXguXG5cdFx0XHQgKlxuXHRcdFx0ICogV2hldGhlciB0aGUgY2xhc3MgaXMgYWN0aXZlIGlzIGRldGVybWluZWQgYnkgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgYGVsZW1lbnRgICh3aGVyZSBgZWxlbWVudGAgaXRzZWxmIGlzXG5cdFx0XHQgKiBjbG9zZXN0IGFuY2VzdG9yKSB0aGF0IGhhcyB0aGUgZ2l2ZW4gY2xhc3Mgb3IgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiBpdC4gSWYgbmVpdGhlciBgZWxlbWVudGAgbm9yIGFueSBvZiBpdHNcblx0XHRcdCAqIGFuY2VzdG9ycyBoYXZlIHRoZSBnaXZlbiBjbGFzcyBvciB0aGUgbmVnYXRlZCB2ZXJzaW9uIG9mIGl0LCB0aGVuIHRoZSBkZWZhdWx0IGFjdGl2YXRpb24gd2lsbCBiZSByZXR1cm5lZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBJbiB0aGUgcGFyYWRveGljYWwgc2l0dWF0aW9uIHdoZXJlIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGNvbnRhaW5zIF9fYm90aF9fIHRoZSBnaXZlbiBjbGFzcyBhbmQgdGhlIG5lZ2F0ZWRcblx0XHRcdCAqIHZlcnNpb24gb2YgaXQsIHRoZSBjbGFzcyBpcyBjb25zaWRlcmVkIGFjdGl2ZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcblx0XHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZmF1bHRBY3RpdmF0aW9uPWZhbHNlXVxuXHRcdFx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdFx0XHQgKi9cblx0XHRcdGlzQWN0aXZlOiBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lLCBkZWZhdWx0QWN0aXZhdGlvbikge1xuXHRcdFx0XHR2YXIgbm8gPSAnbm8tJyArIGNsYXNzTmFtZTtcblxuXHRcdFx0XHR3aGlsZSAoZWxlbWVudCkge1xuXHRcdFx0XHRcdHZhciBjbGFzc0xpc3QgPSBlbGVtZW50LmNsYXNzTGlzdDtcblx0XHRcdFx0XHRpZiAoY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoY2xhc3NMaXN0LmNvbnRhaW5zKG5vKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAhIWRlZmF1bHRBY3RpdmF0aW9uO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIG5hbWVzcGFjZSBjb250YWlucyBhbGwgY3VycmVudGx5IGxvYWRlZCBsYW5ndWFnZXMgYW5kIHRoZSBzb21lIGhlbHBlciBmdW5jdGlvbnMgdG8gY3JlYXRlIGFuZCBtb2RpZnkgbGFuZ3VhZ2VzLlxuXHRcdCAqXG5cdFx0ICogQG5hbWVzcGFjZVxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRsYW5ndWFnZXM6IHtcblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIGdyYW1tYXIgZm9yIHBsYWluLCB1bmZvcm1hdHRlZCB0ZXh0LlxuXHRcdFx0ICovXG5cdFx0XHRwbGFpbjogcGxhaW5UZXh0R3JhbW1hcixcblx0XHRcdHBsYWludGV4dDogcGxhaW5UZXh0R3JhbW1hcixcblx0XHRcdHRleHQ6IHBsYWluVGV4dEdyYW1tYXIsXG5cdFx0XHR0eHQ6IHBsYWluVGV4dEdyYW1tYXIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ3JlYXRlcyBhIGRlZXAgY29weSBvZiB0aGUgbGFuZ3VhZ2Ugd2l0aCB0aGUgZ2l2ZW4gaWQgYW5kIGFwcGVuZHMgdGhlIGdpdmVuIHRva2Vucy5cblx0XHRcdCAqXG5cdFx0XHQgKiBJZiBhIHRva2VuIGluIGByZWRlZmAgYWxzbyBhcHBlYXJzIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2UsIHRoZW4gdGhlIGV4aXN0aW5nIHRva2VuIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2Vcblx0XHRcdCAqIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYXQgaXRzIG9yaWdpbmFsIHBvc2l0aW9uLlxuXHRcdFx0ICpcblx0XHRcdCAqICMjIEJlc3QgcHJhY3RpY2VzXG5cdFx0XHQgKlxuXHRcdFx0ICogU2luY2UgdGhlIHBvc2l0aW9uIG9mIG92ZXJ3cml0aW5nIHRva2VucyAodG9rZW4gaW4gYHJlZGVmYCB0aGF0IG92ZXJ3cml0ZSB0b2tlbnMgaW4gdGhlIGNvcGllZCBsYW5ndWFnZSlcblx0XHRcdCAqIGRvZXNuJ3QgbWF0dGVyLCB0aGV5IGNhbiB0ZWNobmljYWxseSBiZSBpbiBhbnkgb3JkZXIuIEhvd2V2ZXIsIHRoaXMgY2FuIGJlIGNvbmZ1c2luZyB0byBvdGhlcnMgdGhhdCB0cnlpbmcgdG9cblx0XHRcdCAqIHVuZGVyc3RhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb24gYmVjYXVzZSwgbm9ybWFsbHksIHRoZSBvcmRlciBvZiB0b2tlbnMgbWF0dGVycyBpbiBQcmlzbSBncmFtbWFycy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGVyZWZvcmUsIGl0IGlzIGVuY291cmFnZWQgdG8gb3JkZXIgb3ZlcndyaXRpbmcgdG9rZW5zIGFjY29yZGluZyB0byB0aGUgcG9zaXRpb25zIG9mIHRoZSBvdmVyd3JpdHRlbiB0b2tlbnMuXG5cdFx0XHQgKiBGdXJ0aGVybW9yZSwgYWxsIG5vbi1vdmVyd3JpdGluZyB0b2tlbnMgc2hvdWxkIGJlIHBsYWNlZCBhZnRlciB0aGUgb3ZlcndyaXRpbmcgb25lcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBsYW5ndWFnZSB0byBleHRlbmQuIFRoaXMgaGFzIHRvIGJlIGEga2V5IGluIGBQcmlzbS5sYW5ndWFnZXNgLlxuXHRcdFx0ICogQHBhcmFtIHtHcmFtbWFyfSByZWRlZiBUaGUgbmV3IHRva2VucyB0byBhcHBlbmQuXG5cdFx0XHQgKiBAcmV0dXJucyB7R3JhbW1hcn0gVGhlIG5ldyBsYW5ndWFnZSBjcmVhdGVkLlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIFByaXNtLmxhbmd1YWdlc1snY3NzLXdpdGgtY29sb3JzJ10gPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG5cdFx0XHQgKiAgICAgLy8gUHJpc20ubGFuZ3VhZ2VzLmNzcyBhbHJlYWR5IGhhcyBhICdjb21tZW50JyB0b2tlbiwgc28gdGhpcyB0b2tlbiB3aWxsIG92ZXJ3cml0ZSBDU1MnICdjb21tZW50JyB0b2tlblxuXHRcdFx0ICogICAgIC8vIGF0IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuXHRcdFx0ICogICAgICdjb21tZW50JzogeyAuLi4gfSxcblx0XHRcdCAqICAgICAvLyBDU1MgZG9lc24ndCBoYXZlIGEgJ2NvbG9yJyB0b2tlbiwgc28gdGhpcyB0b2tlbiB3aWxsIGJlIGFwcGVuZGVkXG5cdFx0XHQgKiAgICAgJ2NvbG9yJzogL1xcYig/OnJlZHxncmVlbnxibHVlKVxcYi9cblx0XHRcdCAqIH0pO1xuXHRcdFx0ICovXG5cdFx0XHRleHRlbmQ6IGZ1bmN0aW9uIChpZCwgcmVkZWYpIHtcblx0XHRcdFx0dmFyIGxhbmcgPSBfLnV0aWwuY2xvbmUoXy5sYW5ndWFnZXNbaWRdKTtcblxuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gcmVkZWYpIHtcblx0XHRcdFx0XHRsYW5nW2tleV0gPSByZWRlZltrZXldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGxhbmc7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEluc2VydHMgdG9rZW5zIF9iZWZvcmVfIGFub3RoZXIgdG9rZW4gaW4gYSBsYW5ndWFnZSBkZWZpbml0aW9uIG9yIGFueSBvdGhlciBncmFtbWFyLlxuXHRcdFx0ICpcblx0XHRcdCAqICMjIFVzYWdlXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhpcyBoZWxwZXIgbWV0aG9kIG1ha2VzIGl0IGVhc3kgdG8gbW9kaWZ5IGV4aXN0aW5nIGxhbmd1YWdlcy4gRm9yIGV4YW1wbGUsIHRoZSBDU1MgbGFuZ3VhZ2UgZGVmaW5pdGlvblxuXHRcdFx0ICogbm90IG9ubHkgZGVmaW5lcyBDU1MgaGlnaGxpZ2h0aW5nIGZvciBDU1MgZG9jdW1lbnRzLCBidXQgYWxzbyBuZWVkcyB0byBkZWZpbmUgaGlnaGxpZ2h0aW5nIGZvciBDU1MgZW1iZWRkZWRcblx0XHRcdCAqIGluIEhUTUwgdGhyb3VnaCBgPHN0eWxlPmAgZWxlbWVudHMuIFRvIGRvIHRoaXMsIGl0IG5lZWRzIHRvIG1vZGlmeSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAgYW5kIGFkZCB0aGVcblx0XHRcdCAqIGFwcHJvcHJpYXRlIHRva2Vucy4gSG93ZXZlciwgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgIGlzIGEgcmVndWxhciBKYXZhU2NyaXB0IG9iamVjdCBsaXRlcmFsLCBzbyBpZiB5b3UgZG9cblx0XHRcdCAqIHRoaXM6XG5cdFx0XHQgKlxuXHRcdFx0ICogYGBganNcblx0XHRcdCAqIFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuc3R5bGUgPSB7XG5cdFx0XHQgKiAgICAgLy8gdG9rZW5cblx0XHRcdCAqIH07XG5cdFx0XHQgKiBgYGBcblx0XHRcdCAqXG5cdFx0XHQgKiB0aGVuIHRoZSBgc3R5bGVgIHRva2VuIHdpbGwgYmUgYWRkZWQgKGFuZCBwcm9jZXNzZWQpIGF0IHRoZSBlbmQuIGBpbnNlcnRCZWZvcmVgIGFsbG93cyB5b3UgdG8gaW5zZXJ0IHRva2Vuc1xuXHRcdFx0ICogYmVmb3JlIGV4aXN0aW5nIHRva2Vucy4gRm9yIHRoZSBDU1MgZXhhbXBsZSBhYm92ZSwgeW91IHdvdWxkIHVzZSBpdCBsaWtlIHRoaXM6XG5cdFx0XHQgKlxuXHRcdFx0ICogYGBganNcblx0XHRcdCAqIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjZGF0YScsIHtcblx0XHRcdCAqICAgICAnc3R5bGUnOiB7XG5cdFx0XHQgKiAgICAgICAgIC8vIHRva2VuXG5cdFx0XHQgKiAgICAgfVxuXHRcdFx0ICogfSk7XG5cdFx0XHQgKiBgYGBcblx0XHRcdCAqXG5cdFx0XHQgKiAjIyBTcGVjaWFsIGNhc2VzXG5cdFx0XHQgKlxuXHRcdFx0ICogSWYgdGhlIGdyYW1tYXJzIG9mIGBpbnNpZGVgIGFuZCBgaW5zZXJ0YCBoYXZlIHRva2VucyB3aXRoIHRoZSBzYW1lIG5hbWUsIHRoZSB0b2tlbnMgaW4gYGluc2lkZWAncyBncmFtbWFyXG5cdFx0XHQgKiB3aWxsIGJlIGlnbm9yZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhpcyBiZWhhdmlvciBjYW4gYmUgdXNlZCB0byBpbnNlcnQgdG9rZW5zIGFmdGVyIGBiZWZvcmVgOlxuXHRcdFx0ICpcblx0XHRcdCAqIGBgYGpzXG5cdFx0XHQgKiBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAnY29tbWVudCcsIHtcblx0XHRcdCAqICAgICAnY29tbWVudCc6IFByaXNtLmxhbmd1YWdlcy5tYXJrdXAuY29tbWVudCxcblx0XHRcdCAqICAgICAvLyB0b2tlbnMgYWZ0ZXIgJ2NvbW1lbnQnXG5cdFx0XHQgKiB9KTtcblx0XHRcdCAqIGBgYFxuXHRcdFx0ICpcblx0XHRcdCAqICMjIExpbWl0YXRpb25zXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIG1haW4gcHJvYmxlbSBgaW5zZXJ0QmVmb3JlYCBoYXMgdG8gc29sdmUgaXMgaXRlcmF0aW9uIG9yZGVyLiBTaW5jZSBFUzIwMTUsIHRoZSBpdGVyYXRpb24gb3JkZXIgZm9yIG9iamVjdFxuXHRcdFx0ICogcHJvcGVydGllcyBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSBpbnNlcnRpb24gb3JkZXIgKGV4Y2VwdCBmb3IgaW50ZWdlciBrZXlzKSBidXQgc29tZSBicm93c2VycyBiZWhhdmVcblx0XHRcdCAqIGRpZmZlcmVudGx5IHdoZW4ga2V5cyBhcmUgZGVsZXRlZCBhbmQgcmUtaW5zZXJ0ZWQuIFNvIGBpbnNlcnRCZWZvcmVgIGNhbid0IGJlIGltcGxlbWVudGVkIGJ5IHRlbXBvcmFyaWx5XG5cdFx0XHQgKiBkZWxldGluZyBwcm9wZXJ0aWVzIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBpbnNlcnQgYXQgYXJiaXRyYXJ5IHBvc2l0aW9ucy5cblx0XHRcdCAqXG5cdFx0XHQgKiBUbyBzb2x2ZSB0aGlzIHByb2JsZW0sIGBpbnNlcnRCZWZvcmVgIGRvZXNuJ3QgYWN0dWFsbHkgaW5zZXJ0IHRoZSBnaXZlbiB0b2tlbnMgaW50byB0aGUgdGFyZ2V0IG9iamVjdC5cblx0XHRcdCAqIEluc3RlYWQsIGl0IHdpbGwgY3JlYXRlIGEgbmV3IG9iamVjdCBhbmQgcmVwbGFjZSBhbGwgcmVmZXJlbmNlcyB0byB0aGUgdGFyZ2V0IG9iamVjdCB3aXRoIHRoZSBuZXcgb25lLiBUaGlzXG5cdFx0XHQgKiBjYW4gYmUgZG9uZSB3aXRob3V0IHRlbXBvcmFyaWx5IGRlbGV0aW5nIHByb3BlcnRpZXMsIHNvIHRoZSBpdGVyYXRpb24gb3JkZXIgaXMgd2VsbC1kZWZpbmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEhvd2V2ZXIsIG9ubHkgcmVmZXJlbmNlcyB0aGF0IGNhbiBiZSByZWFjaGVkIGZyb20gYFByaXNtLmxhbmd1YWdlc2Agb3IgYGluc2VydGAgd2lsbCBiZSByZXBsYWNlZC4gSS5lLiBpZlxuXHRcdFx0ICogeW91IGhvbGQgdGhlIHRhcmdldCBvYmplY3QgaW4gYSB2YXJpYWJsZSwgdGhlbiB0aGUgdmFsdWUgb2YgdGhlIHZhcmlhYmxlIHdpbGwgbm90IGNoYW5nZS5cblx0XHRcdCAqXG5cdFx0XHQgKiBgYGBqc1xuXHRcdFx0ICogdmFyIG9sZE1hcmt1cCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5cdFx0XHQgKiB2YXIgbmV3TWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NvbW1lbnQnLCB7IC4uLiB9KTtcblx0XHRcdCAqXG5cdFx0XHQgKiBhc3NlcnQob2xkTWFya3VwICE9PSBQcmlzbS5sYW5ndWFnZXMubWFya3VwKTtcblx0XHRcdCAqIGFzc2VydChuZXdNYXJrdXAgPT09IFByaXNtLmxhbmd1YWdlcy5tYXJrdXApO1xuXHRcdFx0ICogYGBgXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGluc2lkZSBUaGUgcHJvcGVydHkgb2YgYHJvb3RgIChlLmcuIGEgbGFuZ3VhZ2UgaWQgaW4gYFByaXNtLmxhbmd1YWdlc2ApIHRoYXQgY29udGFpbnMgdGhlXG5cdFx0XHQgKiBvYmplY3QgdG8gYmUgbW9kaWZpZWQuXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gYmVmb3JlIFRoZSBrZXkgdG8gaW5zZXJ0IGJlZm9yZS5cblx0XHRcdCAqIEBwYXJhbSB7R3JhbW1hcn0gaW5zZXJ0IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBrZXktdmFsdWUgcGFpcnMgdG8gYmUgaW5zZXJ0ZWQuXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtyb290XSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgYGluc2lkZWAsIGkuZS4gdGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuXHRcdFx0ICogb2JqZWN0IHRvIGJlIG1vZGlmaWVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIERlZmF1bHRzIHRvIGBQcmlzbS5sYW5ndWFnZXNgLlxuXHRcdFx0ICogQHJldHVybnMge0dyYW1tYXJ9IFRoZSBuZXcgZ3JhbW1hciBvYmplY3QuXG5cdFx0XHQgKiBAcHVibGljXG5cdFx0XHQgKi9cblx0XHRcdGluc2VydEJlZm9yZTogZnVuY3Rpb24gKGluc2lkZSwgYmVmb3JlLCBpbnNlcnQsIHJvb3QpIHtcblx0XHRcdFx0cm9vdCA9IHJvb3QgfHwgLyoqIEB0eXBlIHthbnl9ICovIChfLmxhbmd1YWdlcyk7XG5cdFx0XHRcdHZhciBncmFtbWFyID0gcm9vdFtpbnNpZGVdO1xuXHRcdFx0XHQvKiogQHR5cGUge0dyYW1tYXJ9ICovXG5cdFx0XHRcdHZhciByZXQgPSB7fTtcblxuXHRcdFx0XHRmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG5cdFx0XHRcdFx0aWYgKGdyYW1tYXIuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG5cblx0XHRcdFx0XHRcdGlmICh0b2tlbiA9PSBiZWZvcmUpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgbmV3VG9rZW4gaW4gaW5zZXJ0KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGluc2VydC5oYXNPd25Qcm9wZXJ0eShuZXdUb2tlbikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldFtuZXdUb2tlbl0gPSBpbnNlcnRbbmV3VG9rZW5dO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBEbyBub3QgaW5zZXJ0IHRva2VuIHdoaWNoIGFsc28gb2NjdXIgaW4gaW5zZXJ0LiBTZWUgIzE1MjVcblx0XHRcdFx0XHRcdGlmICghaW5zZXJ0Lmhhc093blByb3BlcnR5KHRva2VuKSkge1xuXHRcdFx0XHRcdFx0XHRyZXRbdG9rZW5dID0gZ3JhbW1hclt0b2tlbl07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG9sZCA9IHJvb3RbaW5zaWRlXTtcblx0XHRcdFx0cm9vdFtpbnNpZGVdID0gcmV0O1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSByZWZlcmVuY2VzIGluIG90aGVyIGxhbmd1YWdlIGRlZmluaXRpb25zXG5cdFx0XHRcdF8ubGFuZ3VhZ2VzLkRGUyhfLmxhbmd1YWdlcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IG9sZCAmJiBrZXkgIT0gaW5zaWRlKSB7XG5cdFx0XHRcdFx0XHR0aGlzW2tleV0gPSByZXQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVHJhdmVyc2UgYSBsYW5ndWFnZSBkZWZpbml0aW9uIHdpdGggRGVwdGggRmlyc3QgU2VhcmNoXG5cdFx0XHRERlM6IGZ1bmN0aW9uIERGUyhvLCBjYWxsYmFjaywgdHlwZSwgdmlzaXRlZCkge1xuXHRcdFx0XHR2aXNpdGVkID0gdmlzaXRlZCB8fCB7fTtcblxuXHRcdFx0XHR2YXIgb2JqSWQgPSBfLnV0aWwub2JqSWQ7XG5cblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvKSB7XG5cdFx0XHRcdFx0aWYgKG8uaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwobywgaSwgb1tpXSwgdHlwZSB8fCBpKTtcblxuXHRcdFx0XHRcdFx0dmFyIHByb3BlcnR5ID0gb1tpXTtcblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eVR5cGUgPSBfLnV0aWwudHlwZShwcm9wZXJ0eSk7XG5cblx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0eVR5cGUgPT09ICdPYmplY3QnICYmICF2aXNpdGVkW29iaklkKHByb3BlcnR5KV0pIHtcblx0XHRcdFx0XHRcdFx0dmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0REZTKHByb3BlcnR5LCBjYWxsYmFjaywgbnVsbCwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHByb3BlcnR5VHlwZSA9PT0gJ0FycmF5JyAmJiAhdmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldKSB7XG5cdFx0XHRcdFx0XHRcdHZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdERGUyhwcm9wZXJ0eSwgY2FsbGJhY2ssIGksIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRwbHVnaW5zOiB7fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaXMgdGhlIG1vc3QgaGlnaC1sZXZlbCBmdW5jdGlvbiBpbiBQcmlzbeKAmXMgQVBJLlxuXHRcdCAqIEl0IGZldGNoZXMgYWxsIHRoZSBlbGVtZW50cyB0aGF0IGhhdmUgYSBgLmxhbmd1YWdlLXh4eHhgIGNsYXNzIGFuZCB0aGVuIGNhbGxzIHtAbGluayBQcmlzbS5oaWdobGlnaHRFbGVtZW50fSBvblxuXHRcdCAqIGVhY2ggb25lIG9mIHRoZW0uXG5cdFx0ICpcblx0XHQgKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gYFByaXNtLmhpZ2hsaWdodEFsbFVuZGVyKGRvY3VtZW50LCBhc3luYywgY2FsbGJhY2spYC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzeW5jPWZhbHNlXSBTYW1lIGFzIGluIHtAbGluayBQcmlzbS5oaWdobGlnaHRBbGxVbmRlcn0uXG5cdFx0ICogQHBhcmFtIHtIaWdobGlnaHRDYWxsYmFja30gW2NhbGxiYWNrXSBTYW1lIGFzIGluIHtAbGluayBQcmlzbS5oaWdobGlnaHRBbGxVbmRlcn0uXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdGhpZ2hsaWdodEFsbDogZnVuY3Rpb24gKGFzeW5jLCBjYWxsYmFjaykge1xuXHRcdFx0Xy5oaWdobGlnaHRBbGxVbmRlcihkb2N1bWVudCwgYXN5bmMsIGNhbGxiYWNrKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRmV0Y2hlcyBhbGwgdGhlIGRlc2NlbmRhbnRzIG9mIGBjb250YWluZXJgIHRoYXQgaGF2ZSBhIGAubGFuZ3VhZ2UteHh4eGAgY2xhc3MgYW5kIHRoZW4gY2FsbHNcblx0XHQgKiB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0RWxlbWVudH0gb24gZWFjaCBvbmUgb2YgdGhlbS5cblx0XHQgKlxuXHRcdCAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG5cdFx0ICogMS4gYGJlZm9yZS1oaWdobGlnaHRhbGxgXG5cdFx0ICogMi4gYGJlZm9yZS1hbGwtZWxlbWVudHMtaGlnaGxpZ2h0YFxuXHRcdCAqIDMuIEFsbCBob29rcyBvZiB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0RWxlbWVudH0gZm9yIGVhY2ggZWxlbWVudC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7UGFyZW50Tm9kZX0gY29udGFpbmVyIFRoZSByb290IGVsZW1lbnQsIHdob3NlIGRlc2NlbmRhbnRzIHRoYXQgaGF2ZSBhIGAubGFuZ3VhZ2UteHh4eGAgY2xhc3Mgd2lsbCBiZSBoaWdobGlnaHRlZC5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFthc3luYz1mYWxzZV0gV2hldGhlciBlYWNoIGVsZW1lbnQgaXMgdG8gYmUgaGlnaGxpZ2h0ZWQgYXN5bmNocm9ub3VzbHkgdXNpbmcgV2ViIFdvcmtlcnMuXG5cdFx0ICogQHBhcmFtIHtIaWdobGlnaHRDYWxsYmFja30gW2NhbGxiYWNrXSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGVhY2ggZWxlbWVudCBhZnRlciBpdHMgaGlnaGxpZ2h0aW5nIGlzIGRvbmUuXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdGhpZ2hsaWdodEFsbFVuZGVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBhc3luYywgY2FsbGJhY2spIHtcblx0XHRcdHZhciBlbnYgPSB7XG5cdFx0XHRcdGNhbGxiYWNrOiBjYWxsYmFjayxcblx0XHRcdFx0Y29udGFpbmVyOiBjb250YWluZXIsXG5cdFx0XHRcdHNlbGVjdG9yOiAnY29kZVtjbGFzcyo9XCJsYW5ndWFnZS1cIl0sIFtjbGFzcyo9XCJsYW5ndWFnZS1cIl0gY29kZSwgY29kZVtjbGFzcyo9XCJsYW5nLVwiXSwgW2NsYXNzKj1cImxhbmctXCJdIGNvZGUnXG5cdFx0XHR9O1xuXG5cdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWhpZ2hsaWdodGFsbCcsIGVudik7XG5cblx0XHRcdGVudi5lbGVtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShlbnYuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoZW52LnNlbGVjdG9yKSk7XG5cblx0XHRcdF8uaG9va3MucnVuKCdiZWZvcmUtYWxsLWVsZW1lbnRzLWhpZ2hsaWdodCcsIGVudik7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBlbGVtZW50OyAoZWxlbWVudCA9IGVudi5lbGVtZW50c1tpKytdKTspIHtcblx0XHRcdFx0Xy5oaWdobGlnaHRFbGVtZW50KGVsZW1lbnQsIGFzeW5jID09PSB0cnVlLCBlbnYuY2FsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIaWdobGlnaHRzIHRoZSBjb2RlIGluc2lkZSBhIHNpbmdsZSBlbGVtZW50LlxuXHRcdCAqXG5cdFx0ICogVGhlIGZvbGxvd2luZyBob29rcyB3aWxsIGJlIHJ1bjpcblx0XHQgKiAxLiBgYmVmb3JlLXNhbml0eS1jaGVja2Bcblx0XHQgKiAyLiBgYmVmb3JlLWhpZ2hsaWdodGBcblx0XHQgKiAzLiBBbGwgaG9va3Mgb2Yge0BsaW5rIFByaXNtLmhpZ2hsaWdodH0uIFRoZXNlIGhvb2tzIHdpbGwgYmUgcnVuIGJ5IGFuIGFzeW5jaHJvbm91cyB3b3JrZXIgaWYgYGFzeW5jYCBpcyBgdHJ1ZWAuXG5cdFx0ICogNC4gYGJlZm9yZS1pbnNlcnRgXG5cdFx0ICogNS4gYGFmdGVyLWhpZ2hsaWdodGBcblx0XHQgKiA2LiBgY29tcGxldGVgXG5cdFx0ICpcblx0XHQgKiBTb21lIHRoZSBhYm92ZSBob29rcyB3aWxsIGJlIHNraXBwZWQgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBjb250YWluIGFueSB0ZXh0IG9yIHRoZXJlIGlzIG5vIGdyYW1tYXIgbG9hZGVkIGZvclxuXHRcdCAqIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgY29kZS5cblx0XHQgKiBJdCBtdXN0IGhhdmUgYSBjbGFzcyBvZiBgbGFuZ3VhZ2UteHh4eGAgdG8gYmUgcHJvY2Vzc2VkLCB3aGVyZSBgeHh4eGAgaXMgYSB2YWxpZCBsYW5ndWFnZSBpZGVudGlmaWVyLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzeW5jPWZhbHNlXSBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIHRvIGJlIGhpZ2hsaWdodGVkIGFzeW5jaHJvbm91c2x5IHVzaW5nIFdlYiBXb3JrZXJzXG5cdFx0ICogdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSBhbmQgYXZvaWQgYmxvY2tpbmcgdGhlIFVJIHdoZW4gaGlnaGxpZ2h0aW5nIHZlcnkgbGFyZ2UgY2h1bmtzIG9mIGNvZGUuIFRoaXMgb3B0aW9uIGlzXG5cdFx0ICogW2Rpc2FibGVkIGJ5IGRlZmF1bHRdKGh0dHBzOi8vcHJpc21qcy5jb20vZmFxLmh0bWwjd2h5LWlzLWFzeW5jaHJvbm91cy1oaWdobGlnaHRpbmctZGlzYWJsZWQtYnktZGVmYXVsdCkuXG5cdFx0ICpcblx0XHQgKiBOb3RlOiBBbGwgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgcmVxdWlyZWQgdG8gaGlnaGxpZ2h0IHRoZSBjb2RlIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIG1haW4gYHByaXNtLmpzYCBmaWxlIGZvclxuXHRcdCAqIGFzeW5jaHJvbm91cyBoaWdobGlnaHRpbmcgdG8gd29yay4gWW91IGNhbiBidWlsZCB5b3VyIG93biBidW5kbGUgb24gdGhlXG5cdFx0ICogW0Rvd25sb2FkIHBhZ2VdKGh0dHBzOi8vcHJpc21qcy5jb20vZG93bmxvYWQuaHRtbCkuXG5cdFx0ICogQHBhcmFtIHtIaWdobGlnaHRDYWxsYmFja30gW2NhbGxiYWNrXSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBoaWdobGlnaHRpbmcgaXMgZG9uZS5cblx0XHQgKiBNb3N0bHkgdXNlZnVsIHdoZW4gYGFzeW5jYCBpcyBgdHJ1ZWAsIHNpbmNlIGluIHRoYXQgY2FzZSwgdGhlIGhpZ2hsaWdodGluZyBpcyBkb25lIGFzeW5jaHJvbm91c2x5LlxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRoaWdobGlnaHRFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgYXN5bmMsIGNhbGxiYWNrKSB7XG5cdFx0XHQvLyBGaW5kIGxhbmd1YWdlXG5cdFx0XHR2YXIgbGFuZ3VhZ2UgPSBfLnV0aWwuZ2V0TGFuZ3VhZ2UoZWxlbWVudCk7XG5cdFx0XHR2YXIgZ3JhbW1hciA9IF8ubGFuZ3VhZ2VzW2xhbmd1YWdlXTtcblxuXHRcdFx0Ly8gU2V0IGxhbmd1YWdlIG9uIHRoZSBlbGVtZW50LCBpZiBub3QgcHJlc2VudFxuXHRcdFx0Xy51dGlsLnNldExhbmd1YWdlKGVsZW1lbnQsIGxhbmd1YWdlKTtcblxuXHRcdFx0Ly8gU2V0IGxhbmd1YWdlIG9uIHRoZSBwYXJlbnQsIGZvciBzdHlsaW5nXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0aWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3ByZScpIHtcblx0XHRcdFx0Xy51dGlsLnNldExhbmd1YWdlKHBhcmVudCwgbGFuZ3VhZ2UpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29kZSA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG5cblx0XHRcdHZhciBlbnYgPSB7XG5cdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnQsXG5cdFx0XHRcdGxhbmd1YWdlOiBsYW5ndWFnZSxcblx0XHRcdFx0Z3JhbW1hcjogZ3JhbW1hcixcblx0XHRcdFx0Y29kZTogY29kZVxuXHRcdFx0fTtcblxuXHRcdFx0ZnVuY3Rpb24gaW5zZXJ0SGlnaGxpZ2h0ZWRDb2RlKGhpZ2hsaWdodGVkQ29kZSkge1xuXHRcdFx0XHRlbnYuaGlnaGxpZ2h0ZWRDb2RlID0gaGlnaGxpZ2h0ZWRDb2RlO1xuXG5cdFx0XHRcdF8uaG9va3MucnVuKCdiZWZvcmUtaW5zZXJ0JywgZW52KTtcblxuXHRcdFx0XHRlbnYuZWxlbWVudC5pbm5lckhUTUwgPSBlbnYuaGlnaGxpZ2h0ZWRDb2RlO1xuXG5cdFx0XHRcdF8uaG9va3MucnVuKCdhZnRlci1oaWdobGlnaHQnLCBlbnYpO1xuXHRcdFx0XHRfLmhvb2tzLnJ1bignY29tcGxldGUnLCBlbnYpO1xuXHRcdFx0XHRjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVudi5lbGVtZW50KTtcblx0XHRcdH1cblxuXHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1zYW5pdHktY2hlY2snLCBlbnYpO1xuXG5cdFx0XHQvLyBwbHVnaW5zIG1heSBjaGFuZ2UvYWRkIHRoZSBwYXJlbnQvZWxlbWVudFxuXHRcdFx0cGFyZW50ID0gZW52LmVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHRcdGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwcmUnICYmICFwYXJlbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG5cdFx0XHRcdHBhcmVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFlbnYuY29kZSkge1xuXHRcdFx0XHRfLmhvb2tzLnJ1bignY29tcGxldGUnLCBlbnYpO1xuXHRcdFx0XHRjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGVudi5lbGVtZW50KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWhpZ2hsaWdodCcsIGVudik7XG5cblx0XHRcdGlmICghZW52LmdyYW1tYXIpIHtcblx0XHRcdFx0aW5zZXJ0SGlnaGxpZ2h0ZWRDb2RlKF8udXRpbC5lbmNvZGUoZW52LmNvZGUpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYXN5bmMgJiYgX3NlbGYuV29ya2VyKSB7XG5cdFx0XHRcdHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKF8uZmlsZW5hbWUpO1xuXG5cdFx0XHRcdHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG5cdFx0XHRcdFx0aW5zZXJ0SGlnaGxpZ2h0ZWRDb2RlKGV2dC5kYXRhKTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHR3b3JrZXIucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuXHRcdFx0XHRcdGxhbmd1YWdlOiBlbnYubGFuZ3VhZ2UsXG5cdFx0XHRcdFx0Y29kZTogZW52LmNvZGUsXG5cdFx0XHRcdFx0aW1tZWRpYXRlQ2xvc2U6IHRydWVcblx0XHRcdFx0fSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5zZXJ0SGlnaGxpZ2h0ZWRDb2RlKF8uaGlnaGxpZ2h0KGVudi5jb2RlLCBlbnYuZ3JhbW1hciwgZW52Lmxhbmd1YWdlKSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIExvdy1sZXZlbCBmdW5jdGlvbiwgb25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3XigJlyZSBkb2luZy4gSXQgYWNjZXB0cyBhIHN0cmluZyBvZiB0ZXh0IGFzIGlucHV0XG5cdFx0ICogYW5kIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9ucyB0byB1c2UsIGFuZCByZXR1cm5zIGEgc3RyaW5nIHdpdGggdGhlIEhUTUwgcHJvZHVjZWQuXG5cdFx0ICpcblx0XHQgKiBUaGUgZm9sbG93aW5nIGhvb2tzIHdpbGwgYmUgcnVuOlxuXHRcdCAqIDEuIGBiZWZvcmUtdG9rZW5pemVgXG5cdFx0ICogMi4gYGFmdGVyLXRva2VuaXplYFxuXHRcdCAqIDMuIGB3cmFwYDogT24gZWFjaCB7QGxpbmsgVG9rZW59LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHQgQSBzdHJpbmcgd2l0aCB0aGUgY29kZSB0byBiZSBoaWdobGlnaHRlZC5cblx0XHQgKiBAcGFyYW0ge0dyYW1tYXJ9IGdyYW1tYXIgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRva2VucyB0byB1c2UuXG5cdFx0ICpcblx0XHQgKiBVc3VhbGx5IGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBsaWtlIGBQcmlzbS5sYW5ndWFnZXMubWFya3VwYC5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgVGhlIG5hbWUgb2YgdGhlIGxhbmd1YWdlIGRlZmluaXRpb24gcGFzc2VkIHRvIGBncmFtbWFyYC5cblx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaGlnaGxpZ2h0ZWQgSFRNTC5cblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBQcmlzbS5oaWdobGlnaHQoJ3ZhciBmb28gPSB0cnVlOycsIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0LCAnamF2YXNjcmlwdCcpO1xuXHRcdCAqL1xuXHRcdGhpZ2hsaWdodDogZnVuY3Rpb24gKHRleHQsIGdyYW1tYXIsIGxhbmd1YWdlKSB7XG5cdFx0XHR2YXIgZW52ID0ge1xuXHRcdFx0XHRjb2RlOiB0ZXh0LFxuXHRcdFx0XHRncmFtbWFyOiBncmFtbWFyLFxuXHRcdFx0XHRsYW5ndWFnZTogbGFuZ3VhZ2Vcblx0XHRcdH07XG5cdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLXRva2VuaXplJywgZW52KTtcblx0XHRcdGlmICghZW52LmdyYW1tYXIpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUaGUgbGFuZ3VhZ2UgXCInICsgZW52Lmxhbmd1YWdlICsgJ1wiIGhhcyBubyBncmFtbWFyLicpO1xuXHRcdFx0fVxuXHRcdFx0ZW52LnRva2VucyA9IF8udG9rZW5pemUoZW52LmNvZGUsIGVudi5ncmFtbWFyKTtcblx0XHRcdF8uaG9va3MucnVuKCdhZnRlci10b2tlbml6ZScsIGVudik7XG5cdFx0XHRyZXR1cm4gVG9rZW4uc3RyaW5naWZ5KF8udXRpbC5lbmNvZGUoZW52LnRva2VucyksIGVudi5sYW5ndWFnZSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgaXMgdGhlIGhlYXJ0IG9mIFByaXNtLCBhbmQgdGhlIG1vc3QgbG93LWxldmVsIGZ1bmN0aW9uIHlvdSBjYW4gdXNlLiBJdCBhY2NlcHRzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXRcblx0XHQgKiBhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIHRvIHVzZSwgYW5kIHJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgdG9rZW5pemVkIGNvZGUuXG5cdFx0ICpcblx0XHQgKiBXaGVuIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9uIGluY2x1ZGVzIG5lc3RlZCB0b2tlbnMsIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgcmVjdXJzaXZlbHkgb24gZWFjaCBvZiB0aGVzZSB0b2tlbnMuXG5cdFx0ICpcblx0XHQgKiBUaGlzIG1ldGhvZCBjb3VsZCBiZSB1c2VmdWwgaW4gb3RoZXIgY29udGV4dHMgYXMgd2VsbCwgYXMgYSB2ZXJ5IGNydWRlIHBhcnNlci5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IEEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG8gYmUgaGlnaGxpZ2h0ZWQuXG5cdFx0ICogQHBhcmFtIHtHcmFtbWFyfSBncmFtbWFyIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0b2tlbnMgdG8gdXNlLlxuXHRcdCAqXG5cdFx0ICogVXN1YWxseSBhIGxhbmd1YWdlIGRlZmluaXRpb24gbGlrZSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAuXG5cdFx0ICogQHJldHVybnMge1Rva2VuU3RyZWFtfSBBbiBhcnJheSBvZiBzdHJpbmdzIGFuZCB0b2tlbnMsIGEgdG9rZW4gc3RyZWFtLlxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqIGxldCBjb2RlID0gYHZhciBmb28gPSAwO2A7XG5cdFx0ICogbGV0IHRva2VucyA9IFByaXNtLnRva2VuaXplKGNvZGUsIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0KTtcblx0XHQgKiB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XG5cdFx0ICogICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIFByaXNtLlRva2VuICYmIHRva2VuLnR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0ICogICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgbnVtZXJpYyBsaXRlcmFsOiAke3Rva2VuLmNvbnRlbnR9YCk7XG5cdFx0ICogICAgIH1cblx0XHQgKiB9KTtcblx0XHQgKi9cblx0XHR0b2tlbml6ZTogZnVuY3Rpb24gKHRleHQsIGdyYW1tYXIpIHtcblx0XHRcdHZhciByZXN0ID0gZ3JhbW1hci5yZXN0O1xuXHRcdFx0aWYgKHJlc3QpIHtcblx0XHRcdFx0Zm9yICh2YXIgdG9rZW4gaW4gcmVzdCkge1xuXHRcdFx0XHRcdGdyYW1tYXJbdG9rZW5dID0gcmVzdFt0b2tlbl07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZ3JhbW1hci5yZXN0O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdG9rZW5MaXN0ID0gbmV3IExpbmtlZExpc3QoKTtcblx0XHRcdGFkZEFmdGVyKHRva2VuTGlzdCwgdG9rZW5MaXN0LmhlYWQsIHRleHQpO1xuXG5cdFx0XHRtYXRjaEdyYW1tYXIodGV4dCwgdG9rZW5MaXN0LCBncmFtbWFyLCB0b2tlbkxpc3QuaGVhZCwgMCk7XG5cblx0XHRcdHJldHVybiB0b0FycmF5KHRva2VuTGlzdCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBuYW1lc3BhY2Vcblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0aG9va3M6IHtcblx0XHRcdGFsbDoge30sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQWRkcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgdG8gdGhlIGxpc3Qgb2YgY2FsbGJhY2tzIGZvciB0aGUgZ2l2ZW4gaG9vay5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGhvb2sgaXQgaXMgcmVnaXN0ZXJlZCBmb3IgaXMgcnVuLlxuXHRcdFx0ICogSG9va3MgYXJlIHVzdWFsbHkgZGlyZWN0bHkgcnVuIGJ5IGEgaGlnaGxpZ2h0IGZ1bmN0aW9uIGJ1dCB5b3UgY2FuIGFsc28gcnVuIGhvb2tzIHlvdXJzZWxmLlxuXHRcdFx0ICpcblx0XHRcdCAqIE9uZSBjYWxsYmFjayBmdW5jdGlvbiBjYW4gYmUgcmVnaXN0ZXJlZCB0byBtdWx0aXBsZSBob29rcyBhbmQgdGhlIHNhbWUgaG9vayBtdWx0aXBsZSB0aW1lcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9vay5cblx0XHRcdCAqIEBwYXJhbSB7SG9va0NhbGxiYWNrfSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaXMgZ2l2ZW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICovXG5cdFx0XHRhZGQ6IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgaG9va3MgPSBfLmhvb2tzLmFsbDtcblxuXHRcdFx0XHRob29rc1tuYW1lXSA9IGhvb2tzW25hbWVdIHx8IFtdO1xuXG5cdFx0XHRcdGhvb2tzW25hbWVdLnB1c2goY2FsbGJhY2spO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSdW5zIGEgaG9vayBpbnZva2luZyBhbGwgcmVnaXN0ZXJlZCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuXHRcdFx0ICpcblx0XHRcdCAqIENhbGxiYWNrcyB3aWxsIGJlIGludm9rZWQgc3luY2hyb25vdXNseSBhbmQgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgd2VyZSByZWdpc3RlcmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rLlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBlbnYgVGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyBvZiB0aGUgaG9vayBwYXNzZWQgdG8gYWxsIGNhbGxiYWNrcyByZWdpc3RlcmVkLlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICovXG5cdFx0XHRydW46IGZ1bmN0aW9uIChuYW1lLCBlbnYpIHtcblx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IF8uaG9va3MuYWxsW25hbWVdO1xuXG5cdFx0XHRcdGlmICghY2FsbGJhY2tzIHx8ICFjYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGNhbGxiYWNrOyAoY2FsbGJhY2sgPSBjYWxsYmFja3NbaSsrXSk7KSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZW52KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRUb2tlbjogVG9rZW5cblx0fTtcblx0X3NlbGYuUHJpc20gPSBfO1xuXG5cblx0Ly8gVHlwZXNjcmlwdCBub3RlOlxuXHQvLyBUaGUgZm9sbG93aW5nIGNhbiBiZSB1c2VkIHRvIGltcG9ydCB0aGUgVG9rZW4gdHlwZSBpbiBKU0RvYzpcblx0Ly9cblx0Ly8gICBAdHlwZWRlZiB7SW5zdGFuY2VUeXBlPGltcG9ydChcIi4vcHJpc20tY29yZVwiKVtcIlRva2VuXCJdPn0gVG9rZW5cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB0b2tlbi5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgU2VlIHtAbGluayBUb2tlbiN0eXBlIHR5cGV9XG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgVG9rZW5TdHJlYW19IGNvbnRlbnQgU2VlIHtAbGluayBUb2tlbiNjb250ZW50IGNvbnRlbnR9XG5cdCAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbYWxpYXNdIFRoZSBhbGlhcyhlcykgb2YgdGhlIHRva2VuLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW21hdGNoZWRTdHI9XCJcIl0gQSBjb3B5IG9mIHRoZSBmdWxsIHN0cmluZyB0aGlzIHRva2VuIHdhcyBjcmVhdGVkIGZyb20uXG5cdCAqIEBjbGFzc1xuXHQgKiBAZ2xvYmFsXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIFRva2VuKHR5cGUsIGNvbnRlbnQsIGFsaWFzLCBtYXRjaGVkU3RyKSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIHRva2VuLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBpcyB1c3VhbGx5IHRoZSBrZXkgb2YgYSBwYXR0ZXJuIGluIGEge0BsaW5rIEdyYW1tYXJ9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAc2VlIEdyYW1tYXJUb2tlblxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBzdHJpbmdzIG9yIHRva2VucyBjb250YWluZWQgYnkgdGhpcyB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIFRoaXMgd2lsbCBiZSBhIHRva2VuIHN0cmVhbSBpZiB0aGUgcGF0dGVybiBtYXRjaGVkIGFsc28gZGVmaW5lZCBhbiBgaW5zaWRlYCBncmFtbWFyLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZyB8IFRva2VuU3RyZWFtfVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBhbGlhcyhlcykgb2YgdGhlIHRva2VuLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ3xzdHJpbmdbXX1cblx0XHQgKiBAc2VlIEdyYW1tYXJUb2tlblxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHR0aGlzLmFsaWFzID0gYWxpYXM7XG5cdFx0Ly8gQ29weSBvZiB0aGUgZnVsbCBzdHJpbmcgdGhpcyB0b2tlbiB3YXMgY3JlYXRlZCBmcm9tXG5cdFx0dGhpcy5sZW5ndGggPSAobWF0Y2hlZFN0ciB8fCAnJykubGVuZ3RoIHwgMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHRva2VuIHN0cmVhbSBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCB7QGxpbmsgVG9rZW4gVG9rZW59IG9iamVjdHMuXG5cdCAqXG5cdCAqIFRva2VuIHN0cmVhbXMgaGF2ZSB0byBmdWxmaWxsIGEgZmV3IHByb3BlcnRpZXMgdGhhdCBhcmUgYXNzdW1lZCBieSBtb3N0IGZ1bmN0aW9ucyAobW9zdGx5IGludGVybmFsIG9uZXMpIHRoYXQgcHJvY2Vzc1xuXHQgKiB0aGVtLlxuXHQgKlxuXHQgKiAxLiBObyBhZGphY2VudCBzdHJpbmdzLlxuXHQgKiAyLiBObyBlbXB0eSBzdHJpbmdzLlxuXHQgKlxuXHQgKiAgICBUaGUgb25seSBleGNlcHRpb24gaGVyZSBpcyB0aGUgdG9rZW4gc3RyZWFtIHRoYXQgb25seSBjb250YWlucyB0aGUgZW1wdHkgc3RyaW5nIGFuZCBub3RoaW5nIGVsc2UuXG5cdCAqXG5cdCAqIEB0eXBlZGVmIHtBcnJheTxzdHJpbmcgfCBUb2tlbj59IFRva2VuU3RyZWFtXG5cdCAqIEBnbG9iYWxcblx0ICogQHB1YmxpY1xuXHQgKi9cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIHRva2VuIG9yIHRva2VuIHN0cmVhbSB0byBhbiBIVE1MIHJlcHJlc2VudGF0aW9uLlxuXHQgKlxuXHQgKiBUaGUgZm9sbG93aW5nIGhvb2tzIHdpbGwgYmUgcnVuOlxuXHQgKiAxLiBgd3JhcGA6IE9uIGVhY2gge0BsaW5rIFRva2VufS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBUb2tlbiB8IFRva2VuU3RyZWFtfSBvIFRoZSB0b2tlbiBvciB0b2tlbiBzdHJlYW0gdG8gYmUgY29udmVydGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgVGhlIG5hbWUgb2YgY3VycmVudCBsYW5ndWFnZS5cblx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIEhUTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRva2VuIG9yIHRva2VuIHN0cmVhbS5cblx0ICogQG1lbWJlcm9mIFRva2VuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFRva2VuLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShvLCBsYW5ndWFnZSkge1xuXHRcdGlmICh0eXBlb2YgbyA9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIG87XG5cdFx0fVxuXHRcdGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG5cdFx0XHR2YXIgcyA9ICcnO1xuXHRcdFx0by5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHMgKz0gc3RyaW5naWZ5KGUsIGxhbmd1YWdlKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHM7XG5cdFx0fVxuXG5cdFx0dmFyIGVudiA9IHtcblx0XHRcdHR5cGU6IG8udHlwZSxcblx0XHRcdGNvbnRlbnQ6IHN0cmluZ2lmeShvLmNvbnRlbnQsIGxhbmd1YWdlKSxcblx0XHRcdHRhZzogJ3NwYW4nLFxuXHRcdFx0Y2xhc3NlczogWyd0b2tlbicsIG8udHlwZV0sXG5cdFx0XHRhdHRyaWJ1dGVzOiB7fSxcblx0XHRcdGxhbmd1YWdlOiBsYW5ndWFnZVxuXHRcdH07XG5cblx0XHR2YXIgYWxpYXNlcyA9IG8uYWxpYXM7XG5cdFx0aWYgKGFsaWFzZXMpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFsaWFzZXMpKSB7XG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVudi5jbGFzc2VzLCBhbGlhc2VzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVudi5jbGFzc2VzLnB1c2goYWxpYXNlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Xy5ob29rcy5ydW4oJ3dyYXAnLCBlbnYpO1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSAnJztcblx0XHRmb3IgKHZhciBuYW1lIGluIGVudi5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRhdHRyaWJ1dGVzICs9ICcgJyArIG5hbWUgKyAnPVwiJyArIChlbnYuYXR0cmlidXRlc1tuYW1lXSB8fCAnJykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpICsgJ1wiJztcblx0XHR9XG5cblx0XHRyZXR1cm4gJzwnICsgZW52LnRhZyArICcgY2xhc3M9XCInICsgZW52LmNsYXNzZXMuam9pbignICcpICsgJ1wiJyArIGF0dHJpYnV0ZXMgKyAnPicgKyBlbnYuY29udGVudCArICc8LycgKyBlbnYudGFnICsgJz4nO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1JlZ0V4cH0gcGF0dGVyblxuXHQgKiBAcGFyYW0ge251bWJlcn0gcG9zXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9va2JlaGluZFxuXHQgKiBAcmV0dXJucyB7UmVnRXhwRXhlY0FycmF5IHwgbnVsbH1cblx0ICovXG5cdGZ1bmN0aW9uIG1hdGNoUGF0dGVybihwYXR0ZXJuLCBwb3MsIHRleHQsIGxvb2tiZWhpbmQpIHtcblx0XHRwYXR0ZXJuLmxhc3RJbmRleCA9IHBvcztcblx0XHR2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGV4dCk7XG5cdFx0aWYgKG1hdGNoICYmIGxvb2tiZWhpbmQgJiYgbWF0Y2hbMV0pIHtcblx0XHRcdC8vIGNoYW5nZSB0aGUgbWF0Y2ggdG8gcmVtb3ZlIHRoZSB0ZXh0IG1hdGNoZWQgYnkgdGhlIFByaXNtIGxvb2tiZWhpbmQgZ3JvdXBcblx0XHRcdHZhciBsb29rYmVoaW5kTGVuZ3RoID0gbWF0Y2hbMV0ubGVuZ3RoO1xuXHRcdFx0bWF0Y2guaW5kZXggKz0gbG9va2JlaGluZExlbmd0aDtcblx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UobG9va2JlaGluZExlbmd0aCk7XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3Q8c3RyaW5nIHwgVG9rZW4+fSB0b2tlbkxpc3Rcblx0ICogQHBhcmFtIHthbnl9IGdyYW1tYXJcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0Tm9kZTxzdHJpbmcgfCBUb2tlbj59IHN0YXJ0Tm9kZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRQb3Ncblx0ICogQHBhcmFtIHtSZW1hdGNoT3B0aW9uc30gW3JlbWF0Y2hdXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKlxuXHQgKiBAdHlwZWRlZiBSZW1hdGNoT3B0aW9uc1xuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gY2F1c2Vcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IHJlYWNoXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXRjaEdyYW1tYXIodGV4dCwgdG9rZW5MaXN0LCBncmFtbWFyLCBzdGFydE5vZGUsIHN0YXJ0UG9zLCByZW1hdGNoKSB7XG5cdFx0Zm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuXHRcdFx0aWYgKCFncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSB8fCAhZ3JhbW1hclt0b2tlbl0pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwYXR0ZXJucyA9IGdyYW1tYXJbdG9rZW5dO1xuXHRcdFx0cGF0dGVybnMgPSBBcnJheS5pc0FycmF5KHBhdHRlcm5zKSA/IHBhdHRlcm5zIDogW3BhdHRlcm5zXTtcblxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBwYXR0ZXJucy5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRpZiAocmVtYXRjaCAmJiByZW1hdGNoLmNhdXNlID09IHRva2VuICsgJywnICsgaikge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwYXR0ZXJuT2JqID0gcGF0dGVybnNbal07XG5cdFx0XHRcdHZhciBpbnNpZGUgPSBwYXR0ZXJuT2JqLmluc2lkZTtcblx0XHRcdFx0dmFyIGxvb2tiZWhpbmQgPSAhIXBhdHRlcm5PYmoubG9va2JlaGluZDtcblx0XHRcdFx0dmFyIGdyZWVkeSA9ICEhcGF0dGVybk9iai5ncmVlZHk7XG5cdFx0XHRcdHZhciBhbGlhcyA9IHBhdHRlcm5PYmouYWxpYXM7XG5cblx0XHRcdFx0aWYgKGdyZWVkeSAmJiAhcGF0dGVybk9iai5wYXR0ZXJuLmdsb2JhbCkge1xuXHRcdFx0XHRcdC8vIFdpdGhvdXQgdGhlIGdsb2JhbCBmbGFnLCBsYXN0SW5kZXggd29uJ3Qgd29ya1xuXHRcdFx0XHRcdHZhciBmbGFncyA9IHBhdHRlcm5PYmoucGF0dGVybi50b1N0cmluZygpLm1hdGNoKC9baW1zdXldKiQvKVswXTtcblx0XHRcdFx0XHRwYXR0ZXJuT2JqLnBhdHRlcm4gPSBSZWdFeHAocGF0dGVybk9iai5wYXR0ZXJuLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyoqIEB0eXBlIHtSZWdFeHB9ICovXG5cdFx0XHRcdHZhciBwYXR0ZXJuID0gcGF0dGVybk9iai5wYXR0ZXJuIHx8IHBhdHRlcm5PYmo7XG5cblx0XHRcdFx0Zm9yICggLy8gaXRlcmF0ZSB0aGUgdG9rZW4gbGlzdCBhbmQga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCB0b2tlbi9zdHJpbmcgcG9zaXRpb25cblx0XHRcdFx0XHR2YXIgY3VycmVudE5vZGUgPSBzdGFydE5vZGUubmV4dCwgcG9zID0gc3RhcnRQb3M7XG5cdFx0XHRcdFx0Y3VycmVudE5vZGUgIT09IHRva2VuTGlzdC50YWlsO1xuXHRcdFx0XHRcdHBvcyArPSBjdXJyZW50Tm9kZS52YWx1ZS5sZW5ndGgsIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dFxuXHRcdFx0XHQpIHtcblxuXHRcdFx0XHRcdGlmIChyZW1hdGNoICYmIHBvcyA+PSByZW1hdGNoLnJlYWNoKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgc3RyID0gY3VycmVudE5vZGUudmFsdWU7XG5cblx0XHRcdFx0XHRpZiAodG9rZW5MaXN0Lmxlbmd0aCA+IHRleHQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvLyBTb21ldGhpbmcgd2VudCB0ZXJyaWJseSB3cm9uZywgQUJPUlQsIEFCT1JUIVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChzdHIgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHJlbW92ZUNvdW50ID0gMTsgLy8gdGhpcyBpcyB0aGUgdG8gcGFyYW1ldGVyIG9mIHJlbW92ZUJldHdlZW5cblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cblx0XHRcdFx0XHRpZiAoZ3JlZWR5KSB7XG5cdFx0XHRcdFx0XHRtYXRjaCA9IG1hdGNoUGF0dGVybihwYXR0ZXJuLCBwb3MsIHRleHQsIGxvb2tiZWhpbmQpO1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCA+PSB0ZXh0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIGZyb20gPSBtYXRjaC5pbmRleDtcblx0XHRcdFx0XHRcdHZhciB0byA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0dmFyIHAgPSBwb3M7XG5cblx0XHRcdFx0XHRcdC8vIGZpbmQgdGhlIG5vZGUgdGhhdCBjb250YWlucyB0aGUgbWF0Y2hcblx0XHRcdFx0XHRcdHAgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGZyb20gPj0gcCkge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG5cdFx0XHRcdFx0XHRcdHAgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gYWRqdXN0IHBvcyAoYW5kIHApXG5cdFx0XHRcdFx0XHRwIC09IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRcdHBvcyA9IHA7XG5cblx0XHRcdFx0XHRcdC8vIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBUb2tlbiwgdGhlbiB0aGUgbWF0Y2ggc3RhcnRzIGluc2lkZSBhbm90aGVyIFRva2VuLCB3aGljaCBpcyBpbnZhbGlkXG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudE5vZGUudmFsdWUgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gZmluZCB0aGUgbGFzdCBub2RlIHdoaWNoIGlzIGFmZmVjdGVkIGJ5IHRoaXMgbWF0Y2hcblx0XHRcdFx0XHRcdGZvciAoXG5cdFx0XHRcdFx0XHRcdHZhciBrID0gY3VycmVudE5vZGU7XG5cdFx0XHRcdFx0XHRcdGsgIT09IHRva2VuTGlzdC50YWlsICYmIChwIDwgdG8gfHwgdHlwZW9mIGsudmFsdWUgPT09ICdzdHJpbmcnKTtcblx0XHRcdFx0XHRcdFx0ayA9IGsubmV4dFxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZUNvdW50Kys7XG5cdFx0XHRcdFx0XHRcdHAgKz0gay52YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZW1vdmVDb3VudC0tO1xuXG5cdFx0XHRcdFx0XHQvLyByZXBsYWNlIHdpdGggdGhlIG5ldyBtYXRjaFxuXHRcdFx0XHRcdFx0c3RyID0gdGV4dC5zbGljZShwb3MsIHApO1xuXHRcdFx0XHRcdFx0bWF0Y2guaW5kZXggLT0gcG9zO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtYXRjaCA9IG1hdGNoUGF0dGVybihwYXR0ZXJuLCAwLCBzdHIsIGxvb2tiZWhpbmQpO1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cdFx0XHRcdFx0dmFyIGZyb20gPSBtYXRjaC5pbmRleDtcblx0XHRcdFx0XHR2YXIgbWF0Y2hTdHIgPSBtYXRjaFswXTtcblx0XHRcdFx0XHR2YXIgYmVmb3JlID0gc3RyLnNsaWNlKDAsIGZyb20pO1xuXHRcdFx0XHRcdHZhciBhZnRlciA9IHN0ci5zbGljZShmcm9tICsgbWF0Y2hTdHIubGVuZ3RoKTtcblxuXHRcdFx0XHRcdHZhciByZWFjaCA9IHBvcyArIHN0ci5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKHJlbWF0Y2ggJiYgcmVhY2ggPiByZW1hdGNoLnJlYWNoKSB7XG5cdFx0XHRcdFx0XHRyZW1hdGNoLnJlYWNoID0gcmVhY2g7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHJlbW92ZUZyb20gPSBjdXJyZW50Tm9kZS5wcmV2O1xuXG5cdFx0XHRcdFx0aWYgKGJlZm9yZSkge1xuXHRcdFx0XHRcdFx0cmVtb3ZlRnJvbSA9IGFkZEFmdGVyKHRva2VuTGlzdCwgcmVtb3ZlRnJvbSwgYmVmb3JlKTtcblx0XHRcdFx0XHRcdHBvcyArPSBiZWZvcmUubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlbW92ZVJhbmdlKHRva2VuTGlzdCwgcmVtb3ZlRnJvbSwgcmVtb3ZlQ291bnQpO1xuXG5cdFx0XHRcdFx0dmFyIHdyYXBwZWQgPSBuZXcgVG9rZW4odG9rZW4sIGluc2lkZSA/IF8udG9rZW5pemUobWF0Y2hTdHIsIGluc2lkZSkgOiBtYXRjaFN0ciwgYWxpYXMsIG1hdGNoU3RyKTtcblx0XHRcdFx0XHRjdXJyZW50Tm9kZSA9IGFkZEFmdGVyKHRva2VuTGlzdCwgcmVtb3ZlRnJvbSwgd3JhcHBlZCk7XG5cblx0XHRcdFx0XHRpZiAoYWZ0ZXIpIHtcblx0XHRcdFx0XHRcdGFkZEFmdGVyKHRva2VuTGlzdCwgY3VycmVudE5vZGUsIGFmdGVyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAocmVtb3ZlQ291bnQgPiAxKSB7XG5cdFx0XHRcdFx0XHQvLyBhdCBsZWFzdCBvbmUgVG9rZW4gb2JqZWN0IHdhcyByZW1vdmVkLCBzbyB3ZSBoYXZlIHRvIGRvIHNvbWUgcmVtYXRjaGluZ1xuXHRcdFx0XHRcdFx0Ly8gdGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIGN1cnJlbnQgcGF0dGVybiBpcyBncmVlZHlcblxuXHRcdFx0XHRcdFx0LyoqIEB0eXBlIHtSZW1hdGNoT3B0aW9uc30gKi9cblx0XHRcdFx0XHRcdHZhciBuZXN0ZWRSZW1hdGNoID0ge1xuXHRcdFx0XHRcdFx0XHRjYXVzZTogdG9rZW4gKyAnLCcgKyBqLFxuXHRcdFx0XHRcdFx0XHRyZWFjaDogcmVhY2hcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRtYXRjaEdyYW1tYXIodGV4dCwgdG9rZW5MaXN0LCBncmFtbWFyLCBjdXJyZW50Tm9kZS5wcmV2LCBwb3MsIG5lc3RlZFJlbWF0Y2gpO1xuXG5cdFx0XHRcdFx0XHQvLyB0aGUgcmVhY2ggbWlnaHQgaGF2ZSBiZWVuIGV4dGVuZGVkIGJlY2F1c2Ugb2YgdGhlIHJlbWF0Y2hpbmdcblx0XHRcdFx0XHRcdGlmIChyZW1hdGNoICYmIG5lc3RlZFJlbWF0Y2gucmVhY2ggPiByZW1hdGNoLnJlYWNoKSB7XG5cdFx0XHRcdFx0XHRcdHJlbWF0Y2gucmVhY2ggPSBuZXN0ZWRSZW1hdGNoLnJlYWNoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZWRlZiBMaW5rZWRMaXN0Tm9kZVxuXHQgKiBAcHJvcGVydHkge1R9IHZhbHVlXG5cdCAqIEBwcm9wZXJ0eSB7TGlua2VkTGlzdE5vZGU8VD4gfCBudWxsfSBwcmV2IFRoZSBwcmV2aW91cyBub2RlLlxuXHQgKiBAcHJvcGVydHkge0xpbmtlZExpc3ROb2RlPFQ+IHwgbnVsbH0gbmV4dCBUaGUgbmV4dCBub2RlLlxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblxuXHQvKipcblx0ICogQHRlbXBsYXRlIFRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIExpbmtlZExpc3QoKSB7XG5cdFx0LyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cblx0XHR2YXIgaGVhZCA9IHsgdmFsdWU6IG51bGwsIHByZXY6IG51bGwsIG5leHQ6IG51bGwgfTtcblx0XHQvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuXHRcdHZhciB0YWlsID0geyB2YWx1ZTogbnVsbCwgcHJldjogaGVhZCwgbmV4dDogbnVsbCB9O1xuXHRcdGhlYWQubmV4dCA9IHRhaWw7XG5cblx0XHQvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuXHRcdHRoaXMuaGVhZCA9IGhlYWQ7XG5cdFx0LyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cblx0XHR0aGlzLnRhaWwgPSB0YWlsO1xuXHRcdHRoaXMubGVuZ3RoID0gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbmV3IG5vZGUgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIGxpc3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdDxUPn0gbGlzdFxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3ROb2RlPFQ+fSBub2RlXG5cdCAqIEBwYXJhbSB7VH0gdmFsdWVcblx0ICogQHJldHVybnMge0xpbmtlZExpc3ROb2RlPFQ+fSBUaGUgYWRkZWQgbm9kZS5cblx0ICogQHRlbXBsYXRlIFRcblx0ICovXG5cdGZ1bmN0aW9uIGFkZEFmdGVyKGxpc3QsIG5vZGUsIHZhbHVlKSB7XG5cdFx0Ly8gYXNzdW1lcyB0aGF0IG5vZGUgIT0gbGlzdC50YWlsICYmIHZhbHVlcy5sZW5ndGggPj0gMFxuXHRcdHZhciBuZXh0ID0gbm9kZS5uZXh0O1xuXG5cdFx0dmFyIG5ld05vZGUgPSB7IHZhbHVlOiB2YWx1ZSwgcHJldjogbm9kZSwgbmV4dDogbmV4dCB9O1xuXHRcdG5vZGUubmV4dCA9IG5ld05vZGU7XG5cdFx0bmV4dC5wcmV2ID0gbmV3Tm9kZTtcblx0XHRsaXN0Lmxlbmd0aCsrO1xuXG5cdFx0cmV0dXJuIG5ld05vZGU7XG5cdH1cblx0LyoqXG5cdCAqIFJlbW92ZXMgYGNvdW50YCBub2RlcyBhZnRlciB0aGUgZ2l2ZW4gbm9kZS4gVGhlIGdpdmVuIG5vZGUgd2lsbCBub3QgYmUgcmVtb3ZlZC5cblx0ICpcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8VD59IG5vZGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqL1xuXHRmdW5jdGlvbiByZW1vdmVSYW5nZShsaXN0LCBub2RlLCBjb3VudCkge1xuXHRcdHZhciBuZXh0ID0gbm9kZS5uZXh0O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgJiYgbmV4dCAhPT0gbGlzdC50YWlsOyBpKyspIHtcblx0XHRcdG5leHQgPSBuZXh0Lm5leHQ7XG5cdFx0fVxuXHRcdG5vZGUubmV4dCA9IG5leHQ7XG5cdFx0bmV4dC5wcmV2ID0gbm9kZTtcblx0XHRsaXN0Lmxlbmd0aCAtPSBpO1xuXHR9XG5cdC8qKlxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3Q8VD59IGxpc3Rcblx0ICogQHJldHVybnMge1RbXX1cblx0ICogQHRlbXBsYXRlIFRcblx0ICovXG5cdGZ1bmN0aW9uIHRvQXJyYXkobGlzdCkge1xuXHRcdHZhciBhcnJheSA9IFtdO1xuXHRcdHZhciBub2RlID0gbGlzdC5oZWFkLm5leHQ7XG5cdFx0d2hpbGUgKG5vZGUgIT09IGxpc3QudGFpbCkge1xuXHRcdFx0YXJyYXkucHVzaChub2RlLnZhbHVlKTtcblx0XHRcdG5vZGUgPSBub2RlLm5leHQ7XG5cdFx0fVxuXHRcdHJldHVybiBhcnJheTtcblx0fVxuXG5cblx0aWYgKCFfc2VsZi5kb2N1bWVudCkge1xuXHRcdGlmICghX3NlbGYuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0Ly8gaW4gTm9kZS5qc1xuXHRcdFx0cmV0dXJuIF87XG5cdFx0fVxuXG5cdFx0aWYgKCFfLmRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlcikge1xuXHRcdFx0Ly8gSW4gd29ya2VyXG5cdFx0XHRfc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2dCkge1xuXHRcdFx0XHR2YXIgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZ0LmRhdGEpO1xuXHRcdFx0XHR2YXIgbGFuZyA9IG1lc3NhZ2UubGFuZ3VhZ2U7XG5cdFx0XHRcdHZhciBjb2RlID0gbWVzc2FnZS5jb2RlO1xuXHRcdFx0XHR2YXIgaW1tZWRpYXRlQ2xvc2UgPSBtZXNzYWdlLmltbWVkaWF0ZUNsb3NlO1xuXG5cdFx0XHRcdF9zZWxmLnBvc3RNZXNzYWdlKF8uaGlnaGxpZ2h0KGNvZGUsIF8ubGFuZ3VhZ2VzW2xhbmddLCBsYW5nKSk7XG5cdFx0XHRcdGlmIChpbW1lZGlhdGVDbG9zZSkge1xuXHRcdFx0XHRcdF9zZWxmLmNsb3NlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIGZhbHNlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gXztcblx0fVxuXG5cdC8vIEdldCBjdXJyZW50IHNjcmlwdCBhbmQgaGlnaGxpZ2h0XG5cdHZhciBzY3JpcHQgPSBfLnV0aWwuY3VycmVudFNjcmlwdCgpO1xuXG5cdGlmIChzY3JpcHQpIHtcblx0XHRfLmZpbGVuYW1lID0gc2NyaXB0LnNyYztcblxuXHRcdGlmIChzY3JpcHQuaGFzQXR0cmlidXRlKCdkYXRhLW1hbnVhbCcpKSB7XG5cdFx0XHRfLm1hbnVhbCA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaGlnaGxpZ2h0QXV0b21hdGljYWxseUNhbGxiYWNrKCkge1xuXHRcdGlmICghXy5tYW51YWwpIHtcblx0XHRcdF8uaGlnaGxpZ2h0QWxsKCk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFfLm1hbnVhbCkge1xuXHRcdC8vIElmIHRoZSBkb2N1bWVudCBzdGF0ZSBpcyBcImxvYWRpbmdcIiwgdGhlbiB3ZSdsbCB1c2UgRE9NQ29udGVudExvYWRlZC5cblx0XHQvLyBJZiB0aGUgZG9jdW1lbnQgc3RhdGUgaXMgXCJpbnRlcmFjdGl2ZVwiIGFuZCB0aGUgcHJpc20uanMgc2NyaXB0IGlzIGRlZmVycmVkLCB0aGVuIHdlJ2xsIGFsc28gdXNlIHRoZVxuXHRcdC8vIERPTUNvbnRlbnRMb2FkZWQgZXZlbnQgYmVjYXVzZSB0aGVyZSBtaWdodCBiZSBzb21lIHBsdWdpbnMgb3IgbGFuZ3VhZ2VzIHdoaWNoIGhhdmUgYWxzbyBiZWVuIGRlZmVycmVkIGFuZCB0aGV5XG5cdFx0Ly8gbWlnaHQgdGFrZSBsb25nZXIgb25lIGFuaW1hdGlvbiBmcmFtZSB0byBleGVjdXRlIHdoaWNoIGNhbiBjcmVhdGUgYSByYWNlIGNvbmRpdGlvbiB3aGVyZSBvbmx5IHNvbWUgcGx1Z2lucyBoYXZlXG5cdFx0Ly8gYmVlbiBsb2FkZWQgd2hlbiBQcmlzbS5oaWdobGlnaHRBbGwoKSBpcyBleGVjdXRlZCwgZGVwZW5kaW5nIG9uIGhvdyBmYXN0IHJlc291cmNlcyBhcmUgbG9hZGVkLlxuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUHJpc21KUy9wcmlzbS9pc3N1ZXMvMjEwMlxuXHRcdHZhciByZWFkeVN0YXRlID0gZG9jdW1lbnQucmVhZHlTdGF0ZTtcblx0XHRpZiAocmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnIHx8IHJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgJiYgc2NyaXB0ICYmIHNjcmlwdC5kZWZlcikge1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGhpZ2hsaWdodEF1dG9tYXRpY2FsbHlDYWxsYmFjayk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaGlnaGxpZ2h0QXV0b21hdGljYWxseUNhbGxiYWNrKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KGhpZ2hsaWdodEF1dG9tYXRpY2FsbHlDYWxsYmFjaywgMTYpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBfO1xuXG59KF9zZWxmKSk7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IFByaXNtO1xufVxuXG4vLyBoYWNrIGZvciBjb21wb25lbnRzIHRvIHdvcmsgY29ycmVjdGx5IGluIG5vZGUuanNcbmlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuXHRnbG9iYWwuUHJpc20gPSBQcmlzbTtcbn1cblxuLy8gc29tZSBhZGRpdGlvbmFsIGRvY3VtZW50YXRpb24vdHlwZXNcblxuLyoqXG4gKiBUaGUgZXhwYW5zaW9uIG9mIGEgc2ltcGxlIGBSZWdFeHBgIGxpdGVyYWwgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIHByb3BlcnRpZXMuXG4gKlxuICogQHR5cGVkZWYgR3JhbW1hclRva2VuXG4gKiBAcHJvcGVydHkge1JlZ0V4cH0gcGF0dGVybiBUaGUgcmVndWxhciBleHByZXNzaW9uIG9mIHRoZSB0b2tlbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xvb2tiZWhpbmQ9ZmFsc2VdIElmIGB0cnVlYCwgdGhlbiB0aGUgZmlyc3QgY2FwdHVyaW5nIGdyb3VwIG9mIGBwYXR0ZXJuYCB3aWxsIChlZmZlY3RpdmVseSlcbiAqIGJlaGF2ZSBhcyBhIGxvb2tiZWhpbmQgZ3JvdXAgbWVhbmluZyB0aGF0IHRoZSBjYXB0dXJlZCB0ZXh0IHdpbGwgbm90IGJlIHBhcnQgb2YgdGhlIG1hdGNoZWQgdGV4dCBvZiB0aGUgbmV3IHRva2VuLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZ3JlZWR5PWZhbHNlXSBXaGV0aGVyIHRoZSB0b2tlbiBpcyBncmVlZHkuXG4gKiBAcHJvcGVydHkge3N0cmluZ3xzdHJpbmdbXX0gW2FsaWFzXSBBbiBvcHRpb25hbCBhbGlhcyBvciBsaXN0IG9mIGFsaWFzZXMuXG4gKiBAcHJvcGVydHkge0dyYW1tYXJ9IFtpbnNpZGVdIFRoZSBuZXN0ZWQgZ3JhbW1hciBvZiB0aGlzIHRva2VuLlxuICpcbiAqIFRoZSBgaW5zaWRlYCBncmFtbWFyIHdpbGwgYmUgdXNlZCB0byB0b2tlbml6ZSB0aGUgdGV4dCB2YWx1ZSBvZiBlYWNoIHRva2VuIG9mIHRoaXMga2luZC5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIG1ha2UgbmVzdGVkIGFuZCBldmVuIHJlY3Vyc2l2ZSBsYW5ndWFnZSBkZWZpbml0aW9ucy5cbiAqXG4gKiBOb3RlOiBUaGlzIGNhbiBjYXVzZSBpbmZpbml0ZSByZWN1cnNpb24uIEJlIGNhcmVmdWwgd2hlbiB5b3UgZW1iZWQgZGlmZmVyZW50IGxhbmd1YWdlcyBvciBldmVuIHRoZSBzYW1lIGxhbmd1YWdlIGludG9cbiAqIGVhY2ggYW5vdGhlci5cbiAqIEBnbG9iYWxcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIEdyYW1tYXJcbiAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBSZWdFeHAgfCBHcmFtbWFyVG9rZW4gfCBBcnJheTxSZWdFeHAgfCBHcmFtbWFyVG9rZW4+Pn1cbiAqIEBwcm9wZXJ0eSB7R3JhbW1hcn0gW3Jlc3RdIEFuIG9wdGlvbmFsIGdyYW1tYXIgb2JqZWN0IHRoYXQgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGlzIGdyYW1tYXIuXG4gKiBAZ2xvYmFsXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHdoaWNoIHdpbGwgaW52b2tlZCBhZnRlciBhbiBlbGVtZW50IHdhcyBzdWNjZXNzZnVsbHkgaGlnaGxpZ2h0ZWQuXG4gKlxuICogQGNhbGxiYWNrIEhpZ2hsaWdodENhbGxiYWNrXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgc3VjY2Vzc2Z1bGx5IGhpZ2hsaWdodGVkLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZ2xvYmFsXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgSG9va0NhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IGVudiBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIG9mIHRoZSBob29rLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZ2xvYmFsXG4gKiBAcHVibGljXG4gKi9cblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLW1hcmt1cC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMubWFya3VwID0ge1xuXHQnY29tbWVudCc6IHtcblx0XHRwYXR0ZXJuOiAvPCEtLSg/Oig/ITwhLS0pW1xcc1xcU10pKj8tLT4vLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQncHJvbG9nJzoge1xuXHRcdHBhdHRlcm46IC88XFw/W1xcc1xcU10rP1xcPz4vLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQnZG9jdHlwZSc6IHtcblx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIveG1sLyNOVC1kb2N0eXBlZGVjbFxuXHRcdHBhdHRlcm46IC88IURPQ1RZUEUoPzpbXj5cIidbXFxdXXxcIlteXCJdKlwifCdbXiddKicpKyg/OlxcWyg/OltePFwiJ1xcXV18XCJbXlwiXSpcInwnW14nXSonfDwoPyEhLS0pfDwhLS0oPzpbXi1dfC0oPyEtPikpKi0tPikqXFxdXFxzKik/Pi9pLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCdpbnRlcm5hbC1zdWJzZXQnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC8oXlteXFxbXSpcXFspW1xcc1xcU10rKD89XFxdPiQpLyxcblx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdFx0XHRpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG5cdFx0XHR9LFxuXHRcdFx0J3N0cmluZyc6IHtcblx0XHRcdFx0cGF0dGVybjogL1wiW15cIl0qXCJ8J1teJ10qJy8sXG5cdFx0XHRcdGdyZWVkeTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdCdwdW5jdHVhdGlvbic6IC9ePCF8PiR8W1tcXF1dLyxcblx0XHRcdCdkb2N0eXBlLXRhZyc6IC9eRE9DVFlQRS9pLFxuXHRcdFx0J25hbWUnOiAvW15cXHM8PidcIl0rL1xuXHRcdH1cblx0fSxcblx0J2NkYXRhJzoge1xuXHRcdHBhdHRlcm46IC88IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXT4vaSxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J3RhZyc6IHtcblx0XHRwYXR0ZXJuOiAvPFxcLz8oPyFcXGQpW15cXHM+XFwvPSQ8JV0rKD86XFxzKD86XFxzKlteXFxzPlxcLz1dKyg/Olxccyo9XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSsoPz1bXFxzPl0pKXwoPz1bXFxzLz5dKSkpKyk/XFxzKlxcLz8+Lyxcblx0XHRncmVlZHk6IHRydWUsXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQndGFnJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvXjxcXC8/W15cXHM+XFwvXSsvLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXjxcXC8/Lyxcblx0XHRcdFx0XHQnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0J3NwZWNpYWwtYXR0cic6IFtdLFxuXHRcdFx0J2F0dHItdmFsdWUnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC89XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSspLyxcblx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0J3B1bmN0dWF0aW9uJzogW1xuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRwYXR0ZXJuOiAvXj0vLFxuXHRcdFx0XHRcdFx0XHRhbGlhczogJ2F0dHItZXF1YWxzJ1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cGF0dGVybjogL14oXFxzKilbXCInXXxbXCInXSQvLFxuXHRcdFx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0J3B1bmN0dWF0aW9uJzogL1xcLz8+Lyxcblx0XHRcdCdhdHRyLW5hbWUnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9bXlxccz5cXC9dKy8sXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCduYW1lc3BhY2UnOiAvXlteXFxzPlxcLzpdKzovXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH1cblx0fSxcblx0J2VudGl0eSc6IFtcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvJltcXGRhLXpdezEsOH07L2ksXG5cdFx0XHRhbGlhczogJ25hbWVkLWVudGl0eSdcblx0XHR9LFxuXHRcdC8mI3g/W1xcZGEtZl17MSw4fTsvaVxuXHRdXG59O1xuXG5QcmlzbS5sYW5ndWFnZXMubWFya3VwWyd0YWcnXS5pbnNpZGVbJ2F0dHItdmFsdWUnXS5pbnNpZGVbJ2VudGl0eSddID1cblx0UHJpc20ubGFuZ3VhZ2VzLm1hcmt1cFsnZW50aXR5J107XG5QcmlzbS5sYW5ndWFnZXMubWFya3VwWydkb2N0eXBlJ10uaW5zaWRlWydpbnRlcm5hbC1zdWJzZXQnXS5pbnNpZGUgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuXG4vLyBQbHVnaW4gdG8gbWFrZSBlbnRpdHkgdGl0bGUgc2hvdyB0aGUgcmVhbCBlbnRpdHksIGlkZWEgYnkgUm9tYW4gS29tYXJvdlxuUHJpc20uaG9va3MuYWRkKCd3cmFwJywgZnVuY3Rpb24gKGVudikge1xuXG5cdGlmIChlbnYudHlwZSA9PT0gJ2VudGl0eScpIHtcblx0XHRlbnYuYXR0cmlidXRlc1sndGl0bGUnXSA9IGVudi5jb250ZW50LnJlcGxhY2UoLyZhbXA7LywgJyYnKTtcblx0fVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZywgJ2FkZElubGluZWQnLCB7XG5cdC8qKlxuXHQgKiBBZGRzIGFuIGlubGluZWQgbGFuZ3VhZ2UgdG8gbWFya3VwLlxuXHQgKlxuXHQgKiBBbiBleGFtcGxlIG9mIGFuIGlubGluZWQgbGFuZ3VhZ2UgaXMgQ1NTIHdpdGggYDxzdHlsZT5gIHRhZ3MuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIFRoZSBuYW1lIG9mIHRoZSB0YWcgdGhhdCBjb250YWlucyB0aGUgaW5saW5lZCBsYW5ndWFnZS4gVGhpcyBuYW1lIHdpbGwgYmUgdHJlYXRlZCBhc1xuXHQgKiBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZyBUaGUgbGFuZ3VhZ2Uga2V5LlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBhZGRJbmxpbmVkKCdzdHlsZScsICdjc3MnKTtcblx0ICovXG5cdHZhbHVlOiBmdW5jdGlvbiBhZGRJbmxpbmVkKHRhZ05hbWUsIGxhbmcpIHtcblx0XHR2YXIgaW5jbHVkZWRDZGF0YUluc2lkZSA9IHt9O1xuXHRcdGluY2x1ZGVkQ2RhdGFJbnNpZGVbJ2xhbmd1YWdlLScgKyBsYW5nXSA9IHtcblx0XHRcdHBhdHRlcm46IC8oXjwhXFxbQ0RBVEFcXFspW1xcc1xcU10rPyg/PVxcXVxcXT4kKS9pLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzW2xhbmddXG5cdFx0fTtcblx0XHRpbmNsdWRlZENkYXRhSW5zaWRlWydjZGF0YSddID0gL148IVxcW0NEQVRBXFxbfFxcXVxcXT4kL2k7XG5cblx0XHR2YXIgaW5zaWRlID0ge1xuXHRcdFx0J2luY2x1ZGVkLWNkYXRhJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvPCFcXFtDREFUQVxcW1tcXHNcXFNdKj9cXF1cXF0+L2ksXG5cdFx0XHRcdGluc2lkZTogaW5jbHVkZWRDZGF0YUluc2lkZVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0aW5zaWRlWydsYW5ndWFnZS0nICsgbGFuZ10gPSB7XG5cdFx0XHRwYXR0ZXJuOiAvW1xcc1xcU10rLyxcblx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzW2xhbmddXG5cdFx0fTtcblxuXHRcdHZhciBkZWYgPSB7fTtcblx0XHRkZWZbdGFnTmFtZV0gPSB7XG5cdFx0XHRwYXR0ZXJuOiBSZWdFeHAoLyg8X19bXj5dKj4pKD86PCFcXFtDREFUQVxcWyg/OlteXFxdXXxcXF0oPyFcXF0+KSkqXFxdXFxdPnwoPyE8IVxcW0NEQVRBXFxbKVtcXHNcXFNdKSo/KD89PFxcL19fPikvLnNvdXJjZS5yZXBsYWNlKC9fXy9nLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0YWdOYW1lOyB9KSwgJ2knKSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRpbnNpZGU6IGluc2lkZVxuXHRcdH07XG5cblx0XHRQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAnY2RhdGEnLCBkZWYpO1xuXHR9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZywgJ2FkZEF0dHJpYnV0ZScsIHtcblx0LyoqXG5cdCAqIEFkZHMgYW4gcGF0dGVybiB0byBoaWdobGlnaHQgbGFuZ3VhZ2VzIGVtYmVkZGVkIGluIEhUTUwgYXR0cmlidXRlcy5cblx0ICpcblx0ICogQW4gZXhhbXBsZSBvZiBhbiBpbmxpbmVkIGxhbmd1YWdlIGlzIENTUyB3aXRoIGBzdHlsZWAgYXR0cmlidXRlcy5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGF0dHJOYW1lIFRoZSBuYW1lIG9mIHRoZSB0YWcgdGhhdCBjb250YWlucyB0aGUgaW5saW5lZCBsYW5ndWFnZS4gVGhpcyBuYW1lIHdpbGwgYmUgdHJlYXRlZCBhc1xuXHQgKiBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZyBUaGUgbGFuZ3VhZ2Uga2V5LlxuXHQgKiBAZXhhbXBsZVxuXHQgKiBhZGRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2NzcycpO1xuXHQgKi9cblx0dmFsdWU6IGZ1bmN0aW9uIChhdHRyTmFtZSwgbGFuZykge1xuXHRcdFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmluc2lkZVsnc3BlY2lhbC1hdHRyJ10ucHVzaCh7XG5cdFx0XHRwYXR0ZXJuOiBSZWdFeHAoXG5cdFx0XHRcdC8oXnxbXCInXFxzXSkvLnNvdXJjZSArICcoPzonICsgYXR0ck5hbWUgKyAnKScgKyAvXFxzKj1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKyg/PVtcXHM+XSkpLy5zb3VyY2UsXG5cdFx0XHRcdCdpJ1xuXHRcdFx0KSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J2F0dHItbmFtZSc6IC9eW15cXHM9XSsvLFxuXHRcdFx0XHQnYXR0ci12YWx1ZSc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvPVtcXHNcXFNdKy8sXG5cdFx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0XHQndmFsdWUnOiB7XG5cdFx0XHRcdFx0XHRcdHBhdHRlcm46IC8oXj1cXHMqKFtcIiddfCg/IVtcIiddKSkpXFxTW1xcc1xcU10qKD89XFwyJCkvLFxuXHRcdFx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRhbGlhczogW2xhbmcsICdsYW5ndWFnZS0nICsgbGFuZ10sXG5cdFx0XHRcdFx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzW2xhbmddXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0J3B1bmN0dWF0aW9uJzogW1xuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0cGF0dGVybjogL149Lyxcblx0XHRcdFx0XHRcdFx0XHRhbGlhczogJ2F0dHItZXF1YWxzJ1xuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHQvXCJ8Jy9cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fVxufSk7XG5cblByaXNtLmxhbmd1YWdlcy5odG1sID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblByaXNtLmxhbmd1YWdlcy5tYXRobWwgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuUHJpc20ubGFuZ3VhZ2VzLnN2ZyA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5cblByaXNtLmxhbmd1YWdlcy54bWwgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdtYXJrdXAnLCB7fSk7XG5QcmlzbS5sYW5ndWFnZXMuc3NtbCA9IFByaXNtLmxhbmd1YWdlcy54bWw7XG5QcmlzbS5sYW5ndWFnZXMuYXRvbSA9IFByaXNtLmxhbmd1YWdlcy54bWw7XG5QcmlzbS5sYW5ndWFnZXMucnNzID0gUHJpc20ubGFuZ3VhZ2VzLnhtbDtcblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNzcy5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG5cblx0dmFyIHN0cmluZyA9IC8oPzpcIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXCJcXFxcXFxyXFxuXSkqXCJ8Jyg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteJ1xcXFxcXHJcXG5dKSonKS87XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmNzcyA9IHtcblx0XHQnY29tbWVudCc6IC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvLyxcblx0XHQnYXRydWxlJzoge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKCdAW1xcXFx3LV0oPzonICsgL1teO3tcXHNcIiddfFxccysoPyFcXHMpLy5zb3VyY2UgKyAnfCcgKyBzdHJpbmcuc291cmNlICsgJykqPycgKyAvKD86O3woPz1cXHMqXFx7KSkvLnNvdXJjZSksXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J3J1bGUnOiAvXkBbXFx3LV0rLyxcblx0XHRcdFx0J3NlbGVjdG9yLWZ1bmN0aW9uLWFyZ3VtZW50Jzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC8oXFxic2VsZWN0b3JcXHMqXFwoXFxzKig/IVtcXHMpXSkpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCkpKyg/PVxccypcXCkpLyxcblx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRcdGFsaWFzOiAnc2VsZWN0b3InXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdrZXl3b3JkJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC8oXnxbXlxcdy1dKSg/OmFuZHxub3R8b25seXxvcikoPyFbXFx3LV0pLyxcblx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gU2VlIHJlc3QgYmVsb3dcblx0XHRcdH1cblx0XHR9LFxuXHRcdCd1cmwnOiB7XG5cdFx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG5cdFx0XHRwYXR0ZXJuOiBSZWdFeHAoJ1xcXFxidXJsXFxcXCgoPzonICsgc3RyaW5nLnNvdXJjZSArICd8JyArIC8oPzpbXlxcXFxcXHJcXG4oKVwiJ118XFxcXFtcXHNcXFNdKSovLnNvdXJjZSArICcpXFxcXCknLCAnaScpLFxuXHRcdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdmdW5jdGlvbic6IC9edXJsL2ksXG5cdFx0XHRcdCdwdW5jdHVhdGlvbic6IC9eXFwofFxcKSQvLFxuXHRcdFx0XHQnc3RyaW5nJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnXicgKyBzdHJpbmcuc291cmNlICsgJyQnKSxcblx0XHRcdFx0XHRhbGlhczogJ3VybCdcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0J3NlbGVjdG9yJzoge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKCcoXnxbe31cXFxcc10pW157fVxcXFxzXSg/Oltee307XCJcXCdcXFxcc118XFxcXHMrKD8hW1xcXFxze10pfCcgKyBzdHJpbmcuc291cmNlICsgJykqKD89XFxcXHMqXFxcXHspJyksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQnc3RyaW5nJzoge1xuXHRcdFx0cGF0dGVybjogc3RyaW5nLFxuXHRcdFx0Z3JlZWR5OiB0cnVlXG5cdFx0fSxcblx0XHQncHJvcGVydHknOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W14tXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVstX2EtelxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVstXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo6KS9pLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0J2ltcG9ydGFudCc6IC8haW1wb3J0YW50XFxiL2ksXG5cdFx0J2Z1bmN0aW9uJzoge1xuXHRcdFx0cGF0dGVybjogLyhefFteLWEtejAtOV0pWy1hLXowLTldKyg/PVxcKCkvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdCdwdW5jdHVhdGlvbic6IC9bKCl7fTs6LF0vXG5cdH07XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmNzc1snYXRydWxlJ10uaW5zaWRlLnJlc3QgPSBQcmlzbS5sYW5ndWFnZXMuY3NzO1xuXG5cdHZhciBtYXJrdXAgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuXHRpZiAobWFya3VwKSB7XG5cdFx0bWFya3VwLnRhZy5hZGRJbmxpbmVkKCdzdHlsZScsICdjc3MnKTtcblx0XHRtYXJrdXAudGFnLmFkZEF0dHJpYnV0ZSgnc3R5bGUnLCAnY3NzJyk7XG5cdH1cblxufShQcmlzbSkpO1xuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tY2xpa2UuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLmNsaWtlID0ge1xuXHQnY29tbWVudCc6IFtcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXCpbXFxzXFxTXSo/KD86XFwqXFwvfCQpLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRncmVlZHk6IHRydWVcblx0XHR9LFxuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXlxcXFw6XSlcXC9cXC8uKi8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0Z3JlZWR5OiB0cnVlXG5cdFx0fVxuXHRdLFxuXHQnc3RyaW5nJzoge1xuXHRcdHBhdHRlcm46IC8oW1wiJ10pKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS8sXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH0sXG5cdCdjbGFzcy1uYW1lJzoge1xuXHRcdHBhdHRlcm46IC8oXFxiKD86Y2xhc3N8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8aW50ZXJmYWNlfG5ld3x0cmFpdClcXHMrfFxcYmNhdGNoXFxzK1xcKClbXFx3LlxcXFxdKy9pLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQncHVuY3R1YXRpb24nOiAvWy5cXFxcXS9cblx0XHR9XG5cdH0sXG5cdCdrZXl3b3JkJzogL1xcYig/OmJyZWFrfGNhdGNofGNvbnRpbnVlfGRvfGVsc2V8ZmluYWxseXxmb3J8ZnVuY3Rpb258aWZ8aW58aW5zdGFuY2VvZnxuZXd8bnVsbHxyZXR1cm58dGhyb3d8dHJ5fHdoaWxlKVxcYi8sXG5cdCdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcblx0J2Z1bmN0aW9uJzogL1xcYlxcdysoPz1cXCgpLyxcblx0J251bWJlcic6IC9cXGIweFtcXGRhLWZdK1xcYnwoPzpcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCspKD86ZVsrLV0/XFxkKyk/L2ksXG5cdCdvcGVyYXRvcic6IC9bPD5dPT98WyE9XT0/PT98LS0/fFxcK1xcKz98JiY/fFxcfFxcfD98Wz8qL35eJV0vLFxuXHQncHVuY3R1YXRpb24nOiAvW3t9W1xcXTsoKSwuOl0vXG59O1xuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tamF2YXNjcmlwdC5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuXHQnY2xhc3MtbmFtZSc6IFtcblx0XHRQcmlzbS5sYW5ndWFnZXMuY2xpa2VbJ2NsYXNzLW5hbWUnXSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVtfJEEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxcLig/OmNvbnN0cnVjdG9yfHByb3RvdHlwZSkpLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9XG5cdF0sXG5cdCdrZXl3b3JkJzogW1xuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oKD86XnxcXH0pXFxzKiljYXRjaFxcYi8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W14uXXxcXC5cXC5cXC5cXHMqKVxcYig/OmFzfGFzc2VydCg/PVxccypcXHspfGFzeW5jKD89XFxzKig/OmZ1bmN0aW9uXFxifFxcKHxbJFxcd1xceEEwLVxcdUZGRkZdfCQpKXxhd2FpdHxicmVha3xjYXNlfGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5KD89XFxzKig/Olxce3wkKSl8Zm9yfGZyb20oPz1cXHMqKD86WydcIl18JCkpfGZ1bmN0aW9ufCg/OmdldHxzZXQpKD89XFxzKig/OlsjXFxbJFxcd1xceEEwLVxcdUZGRkZdfCQpKXxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHVuZGVmaW5lZHx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKVxcYi8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XSxcblx0Ly8gQWxsb3cgZm9yIGFsbCBub24tQVNDSUkgY2hhcmFjdGVycyAoU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIwMDg0NDQpXG5cdCdmdW5jdGlvbic6IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqKD86XFwuXFxzKig/OmFwcGx5fGJpbmR8Y2FsbClcXHMqKT9cXCgpLyxcblx0J251bWJlcic6IHtcblx0XHRwYXR0ZXJuOiBSZWdFeHAoXG5cdFx0XHQvKF58W15cXHckXSkvLnNvdXJjZSArXG5cdFx0XHQnKD86JyArXG5cdFx0XHQoXG5cdFx0XHRcdC8vIGNvbnN0YW50XG5cdFx0XHRcdC9OYU58SW5maW5pdHkvLnNvdXJjZSArXG5cdFx0XHRcdCd8JyArXG5cdFx0XHRcdC8vIGJpbmFyeSBpbnRlZ2VyXG5cdFx0XHRcdC8wW2JCXVswMV0rKD86X1swMV0rKSpuPy8uc291cmNlICtcblx0XHRcdFx0J3wnICtcblx0XHRcdFx0Ly8gb2N0YWwgaW50ZWdlclxuXHRcdFx0XHQvMFtvT11bMC03XSsoPzpfWzAtN10rKSpuPy8uc291cmNlICtcblx0XHRcdFx0J3wnICtcblx0XHRcdFx0Ly8gaGV4YWRlY2ltYWwgaW50ZWdlclxuXHRcdFx0XHQvMFt4WF1bXFxkQS1GYS1mXSsoPzpfW1xcZEEtRmEtZl0rKSpuPy8uc291cmNlICtcblx0XHRcdFx0J3wnICtcblx0XHRcdFx0Ly8gZGVjaW1hbCBiaWdpbnRcblx0XHRcdFx0L1xcZCsoPzpfXFxkKykqbi8uc291cmNlICtcblx0XHRcdFx0J3wnICtcblx0XHRcdFx0Ly8gZGVjaW1hbCBudW1iZXIgKGludGVnZXIgb3IgZmxvYXQpIGJ1dCBubyBiaWdpbnRcblx0XHRcdFx0Lyg/OlxcZCsoPzpfXFxkKykqKD86XFwuKD86XFxkKyg/Ol9cXGQrKSopPyk/fFxcLlxcZCsoPzpfXFxkKykqKSg/OltFZV1bKy1dP1xcZCsoPzpfXFxkKykqKT8vLnNvdXJjZVxuXHRcdFx0KSArXG5cdFx0XHQnKScgK1xuXHRcdFx0Lyg/IVtcXHckXSkvLnNvdXJjZVxuXHRcdCksXG5cdFx0bG9va2JlaGluZDogdHJ1ZVxuXHR9LFxuXHQnb3BlcmF0b3InOiAvLS18XFwrXFwrfFxcKlxcKj0/fD0+fCYmPT98XFx8XFx8PT98WyE9XT09fDw8PT98Pj4+Pz0/fFstKyovJSZ8XiE9PD5dPT98XFwuezN9fFxcP1xcPz0/fFxcP1xcLj98W346XS9cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFsnY2xhc3MtbmFtZSddWzBdLnBhdHRlcm4gPSAvKFxcYig/OmNsYXNzfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfGludGVyZmFjZXxuZXcpXFxzKylbXFx3LlxcXFxdKy87XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAna2V5d29yZCcsIHtcblx0J3JlZ2V4Jzoge1xuXHRcdHBhdHRlcm46IFJlZ0V4cChcblx0XHRcdC8vIGxvb2tiZWhpbmRcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZHVwZS1jaGFyYWN0ZXJzLWNoYXJhY3Rlci1jbGFzc1xuXHRcdFx0LygoPzpefFteJFxcd1xceEEwLVxcdUZGRkYuXCInXFxdKVxcc118XFxiKD86cmV0dXJufHlpZWxkKSlcXHMqKS8uc291cmNlICtcblx0XHRcdC8vIFJlZ2V4IHBhdHRlcm46XG5cdFx0XHQvLyBUaGVyZSBhcmUgMiByZWdleCBwYXR0ZXJucyBoZXJlLiBUaGUgUmVnRXhwIHNldCBub3RhdGlvbiBwcm9wb3NhbCBhZGRlZCBzdXBwb3J0IGZvciBuZXN0ZWQgY2hhcmFjdGVyXG5cdFx0XHQvLyBjbGFzc2VzIGlmIHRoZSBgdmAgZmxhZyBpcyBwcmVzZW50LiBVbmZvcnR1bmF0ZWx5LCBuZXN0ZWQgQ0NzIGFyZSBib3RoIGNvbnRleHQtZnJlZSBhbmQgaW5jb21wYXRpYmxlXG5cdFx0XHQvLyB3aXRoIHRoZSBvbmx5IHN5bnRheCwgc28gd2UgaGF2ZSB0byBkZWZpbmUgMiBkaWZmZXJlbnQgcmVnZXggcGF0dGVybnMuXG5cdFx0XHQvXFwvLy5zb3VyY2UgK1xuXHRcdFx0Jyg/OicgK1xuXHRcdFx0Lyg/OlxcWyg/OlteXFxdXFxcXFxcclxcbl18XFxcXC4pKlxcXXxcXFxcLnxbXi9cXFxcXFxbXFxyXFxuXSkrXFwvW2RnaW15dXNdezAsN30vLnNvdXJjZSArXG5cdFx0XHQnfCcgK1xuXHRcdFx0Ly8gYHZgIGZsYWcgc3ludGF4LiBUaGlzIHN1cHBvcnRzIDMgbGV2ZWxzIG9mIG5lc3RlZCBjaGFyYWN0ZXIgY2xhc3Nlcy5cblx0XHRcdC8oPzpcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLnxcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLnxcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLikqXFxdKSpcXF0pKlxcXXxcXFxcLnxbXi9cXFxcXFxbXFxyXFxuXSkrXFwvW2RnaW15dXNdezAsN312W2RnaW15dXNdezAsN30vLnNvdXJjZSArXG5cdFx0XHQnKScgK1xuXHRcdFx0Ly8gbG9va2FoZWFkXG5cdFx0XHQvKD89KD86XFxzfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSkqXFwqXFwvKSooPzokfFtcXHJcXG4sLjs6fSlcXF1dfFxcL1xcLykpLy5zb3VyY2Vcblx0XHQpLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J3JlZ2V4LXNvdXJjZSc6IHtcblx0XHRcdFx0cGF0dGVybjogL14oXFwvKVtcXHNcXFNdKyg/PVxcL1thLXpdKiQpLyxcblx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0YWxpYXM6ICdsYW5ndWFnZS1yZWdleCcsXG5cdFx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLnJlZ2V4XG5cdFx0XHR9LFxuXHRcdFx0J3JlZ2V4LWRlbGltaXRlcic6IC9eXFwvfFxcLyQvLFxuXHRcdFx0J3JlZ2V4LWZsYWdzJzogL15bYS16XSskLyxcblx0XHR9XG5cdH0sXG5cdC8vIFRoaXMgbXVzdCBiZSBkZWNsYXJlZCBiZWZvcmUga2V5d29yZCBiZWNhdXNlIHdlIHVzZSBcImZ1bmN0aW9uXCIgaW5zaWRlIHRoZSBsb29rLWZvcndhcmRcblx0J2Z1bmN0aW9uLXZhcmlhYmxlJzoge1xuXHRcdHBhdHRlcm46IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqWz06XVxccyooPzphc3luY1xccyopPyg/OlxcYmZ1bmN0aW9uXFxifCg/OlxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpfCg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSopXFxzKj0+KSkvLFxuXHRcdGFsaWFzOiAnZnVuY3Rpb24nXG5cdH0sXG5cdCdwYXJhbWV0ZXInOiBbXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhmdW5jdGlvbig/OlxccysoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKT9cXHMqXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpKS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhefFteJFxcd1xceEEwLVxcdUZGRkZdKSg/IVxccylbXyRhLXpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqPT4pL2ksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXClcXHMqPT4pLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG5cdFx0fSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKCg/OlxcYnxcXHN8XikoPyEoPzphc3xhc3luY3xhd2FpdHxicmVha3xjYXNlfGNhdGNofGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5fGZvcnxmcm9tfGZ1bmN0aW9ufGdldHxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHNldHxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZCkoPyFbJFxcd1xceEEwLVxcdUZGRkZdKSkoPzooPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqXFxzKilcXChcXHMqfFxcXVxccypcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXClcXHMqXFx7KS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuXHRcdH1cblx0XSxcblx0J2NvbnN0YW50JzogL1xcYltBLVpdKD86W0EtWl9dfFxcZHg/KSpcXGIvXG59KTtcblxuUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdzdHJpbmcnLCB7XG5cdCdoYXNoYmFuZyc6IHtcblx0XHRwYXR0ZXJuOiAvXiMhLiovLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRhbGlhczogJ2NvbW1lbnQnXG5cdH0sXG5cdCd0ZW1wbGF0ZS1zdHJpbmcnOiB7XG5cdFx0cGF0dGVybjogL2AoPzpcXFxcW1xcc1xcU118XFwkXFx7KD86W157fV18XFx7KD86W157fV18XFx7W159XSpcXH0pKlxcfSkrXFx9fCg/IVxcJFxceylbXlxcXFxgXSkqYC8sXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J3RlbXBsYXRlLXB1bmN0dWF0aW9uJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvXmB8YCQvLFxuXHRcdFx0XHRhbGlhczogJ3N0cmluZydcblx0XHRcdH0sXG5cdFx0XHQnaW50ZXJwb2xhdGlvbic6IHtcblx0XHRcdFx0cGF0dGVybjogLygoPzpefFteXFxcXF0pKD86XFxcXHsyfSkqKVxcJFxceyg/Oltee31dfFxceyg/Oltee31dfFxce1tefV0qXFx9KSpcXH0pK1xcfS8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uJzoge1xuXHRcdFx0XHRcdFx0cGF0dGVybjogL15cXCRcXHt8XFx9JC8sXG5cdFx0XHRcdFx0XHRhbGlhczogJ3B1bmN0dWF0aW9uJ1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVzdDogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdzdHJpbmcnOiAvW1xcc1xcU10rL1xuXHRcdH1cblx0fSxcblx0J3N0cmluZy1wcm9wZXJ0eSc6IHtcblx0XHRwYXR0ZXJuOiAvKCg/Ol58Wyx7XSlbIFxcdF0qKShbXCInXSkoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDIpW15cXFxcXFxyXFxuXSkqXFwyKD89XFxzKjopL20sXG5cdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRncmVlZHk6IHRydWUsXG5cdFx0YWxpYXM6ICdwcm9wZXJ0eSdcblx0fVxufSk7XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnb3BlcmF0b3InLCB7XG5cdCdsaXRlcmFsLXByb3BlcnR5Jzoge1xuXHRcdHBhdHRlcm46IC8oKD86XnxbLHtdKVsgXFx0XSopKD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo6KS9tLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0YWxpYXM6ICdwcm9wZXJ0eSdcblx0fSxcbn0pO1xuXG5pZiAoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCkge1xuXHRQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5hZGRJbmxpbmVkKCdzY3JpcHQnLCAnamF2YXNjcmlwdCcpO1xuXG5cdC8vIGFkZCBhdHRyaWJ1dGUgc3VwcG9ydCBmb3IgYWxsIERPTSBldmVudHMuXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cyNTdGFuZGFyZF9ldmVudHNcblx0UHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuYWRkQXR0cmlidXRlKFxuXHRcdC9vbig/OmFib3J0fGJsdXJ8Y2hhbmdlfGNsaWNrfGNvbXBvc2l0aW9uKD86ZW5kfHN0YXJ0fHVwZGF0ZSl8ZGJsY2xpY2t8ZXJyb3J8Zm9jdXMoPzppbnxvdXQpP3xrZXkoPzpkb3dufHVwKXxsb2FkfG1vdXNlKD86ZG93bnxlbnRlcnxsZWF2ZXxtb3ZlfG91dHxvdmVyfHVwKXxyZXNldHxyZXNpemV8c2Nyb2xsfHNlbGVjdHxzbG90Y2hhbmdlfHN1Ym1pdHx1bmxvYWR8d2hlZWwpLy5zb3VyY2UsXG5cdFx0J2phdmFzY3JpcHQnXG5cdCk7XG59XG5cblByaXNtLmxhbmd1YWdlcy5qcyA9IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0O1xuXG5cbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tZmlsZS1oaWdobGlnaHQuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuKGZ1bmN0aW9uICgpIHtcblxuXHRpZiAodHlwZW9mIFByaXNtID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvbWF0Y2hlcyNQb2x5ZmlsbFxuXHRpZiAoIUVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMpIHtcblx0XHRFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzID0gRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXHR9XG5cblx0dmFyIExPQURJTkdfTUVTU0FHRSA9ICdMb2FkaW5n4oCmJztcblx0dmFyIEZBSUxVUkVfTUVTU0FHRSA9IGZ1bmN0aW9uIChzdGF0dXMsIG1lc3NhZ2UpIHtcblx0XHRyZXR1cm4gJ+KcliBFcnJvciAnICsgc3RhdHVzICsgJyB3aGlsZSBmZXRjaGluZyBmaWxlOiAnICsgbWVzc2FnZTtcblx0fTtcblx0dmFyIEZBSUxVUkVfRU1QVFlfTUVTU0FHRSA9ICfinJYgRXJyb3I6IEZpbGUgZG9lcyBub3QgZXhpc3Qgb3IgaXMgZW1wdHknO1xuXG5cdHZhciBFWFRFTlNJT05TID0ge1xuXHRcdCdqcyc6ICdqYXZhc2NyaXB0Jyxcblx0XHQncHknOiAncHl0aG9uJyxcblx0XHQncmInOiAncnVieScsXG5cdFx0J3BzMSc6ICdwb3dlcnNoZWxsJyxcblx0XHQncHNtMSc6ICdwb3dlcnNoZWxsJyxcblx0XHQnc2gnOiAnYmFzaCcsXG5cdFx0J2JhdCc6ICdiYXRjaCcsXG5cdFx0J2gnOiAnYycsXG5cdFx0J3RleCc6ICdsYXRleCdcblx0fTtcblxuXHR2YXIgU1RBVFVTX0FUVFIgPSAnZGF0YS1zcmMtc3RhdHVzJztcblx0dmFyIFNUQVRVU19MT0FESU5HID0gJ2xvYWRpbmcnO1xuXHR2YXIgU1RBVFVTX0xPQURFRCA9ICdsb2FkZWQnO1xuXHR2YXIgU1RBVFVTX0ZBSUxFRCA9ICdmYWlsZWQnO1xuXG5cdHZhciBTRUxFQ1RPUiA9ICdwcmVbZGF0YS1zcmNdOm5vdChbJyArIFNUQVRVU19BVFRSICsgJz1cIicgKyBTVEFUVVNfTE9BREVEICsgJ1wiXSknXG5cdFx0KyAnOm5vdChbJyArIFNUQVRVU19BVFRSICsgJz1cIicgKyBTVEFUVVNfTE9BRElORyArICdcIl0pJztcblxuXHQvKipcblx0ICogTG9hZHMgdGhlIGdpdmVuIGZpbGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVGhlIFVSTCBvciBwYXRoIG9mIHRoZSBzb3VyY2UgZmlsZSB0byBsb2FkLlxuXHQgKiBAcGFyYW0geyhyZXN1bHQ6IHN0cmluZykgPT4gdm9pZH0gc3VjY2Vzc1xuXHQgKiBAcGFyYW0geyhyZWFzb246IHN0cmluZykgPT4gdm9pZH0gZXJyb3Jcblx0ICovXG5cdGZ1bmN0aW9uIGxvYWRGaWxlKHNyYywgc3VjY2VzcywgZXJyb3IpIHtcblx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0eGhyLm9wZW4oJ0dFVCcsIHNyYywgdHJ1ZSk7XG5cdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KSB7XG5cdFx0XHRcdGlmICh4aHIuc3RhdHVzIDwgNDAwICYmIHhoci5yZXNwb25zZVRleHQpIHtcblx0XHRcdFx0XHRzdWNjZXNzKHhoci5yZXNwb25zZVRleHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh4aHIuc3RhdHVzID49IDQwMCkge1xuXHRcdFx0XHRcdFx0ZXJyb3IoRkFJTFVSRV9NRVNTQUdFKHhoci5zdGF0dXMsIHhoci5zdGF0dXNUZXh0KSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVycm9yKEZBSUxVUkVfRU1QVFlfTUVTU0FHRSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR4aHIuc2VuZChudWxsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXJzZXMgdGhlIGdpdmVuIHJhbmdlLlxuXHQgKlxuXHQgKiBUaGlzIHJldHVybnMgYSByYW5nZSB3aXRoIGluY2x1c2l2ZSBlbmRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IHJhbmdlXG5cdCAqIEByZXR1cm5zIHtbbnVtYmVyLCBudW1iZXIgfCB1bmRlZmluZWRdIHwgdW5kZWZpbmVkfVxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VSYW5nZShyYW5nZSkge1xuXHRcdHZhciBtID0gL15cXHMqKFxcZCspXFxzKig/OigsKVxccyooPzooXFxkKylcXHMqKT8pPyQvLmV4ZWMocmFuZ2UgfHwgJycpO1xuXHRcdGlmIChtKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSBOdW1iZXIobVsxXSk7XG5cdFx0XHR2YXIgY29tbWEgPSBtWzJdO1xuXHRcdFx0dmFyIGVuZCA9IG1bM107XG5cblx0XHRcdGlmICghY29tbWEpIHtcblx0XHRcdFx0cmV0dXJuIFtzdGFydCwgc3RhcnRdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFlbmQpIHtcblx0XHRcdFx0cmV0dXJuIFtzdGFydCwgdW5kZWZpbmVkXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBbc3RhcnQsIE51bWJlcihlbmQpXTtcblx0XHR9XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdFByaXNtLmhvb2tzLmFkZCgnYmVmb3JlLWhpZ2hsaWdodGFsbCcsIGZ1bmN0aW9uIChlbnYpIHtcblx0XHRlbnYuc2VsZWN0b3IgKz0gJywgJyArIFNFTEVDVE9SO1xuXHR9KTtcblxuXHRQcmlzbS5ob29rcy5hZGQoJ2JlZm9yZS1zYW5pdHktY2hlY2snLCBmdW5jdGlvbiAoZW52KSB7XG5cdFx0dmFyIHByZSA9IC8qKiBAdHlwZSB7SFRNTFByZUVsZW1lbnR9ICovIChlbnYuZWxlbWVudCk7XG5cdFx0aWYgKHByZS5tYXRjaGVzKFNFTEVDVE9SKSkge1xuXHRcdFx0ZW52LmNvZGUgPSAnJzsgLy8gZmFzdC1wYXRoIHRoZSB3aG9sZSB0aGluZyBhbmQgZ28gdG8gY29tcGxldGVcblxuXHRcdFx0cHJlLnNldEF0dHJpYnV0ZShTVEFUVVNfQVRUUiwgU1RBVFVTX0xPQURJTkcpOyAvLyBtYXJrIGFzIGxvYWRpbmdcblxuXHRcdFx0Ly8gYWRkIGNvZGUgZWxlbWVudCB3aXRoIGxvYWRpbmcgbWVzc2FnZVxuXHRcdFx0dmFyIGNvZGUgPSBwcmUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQ09ERScpKTtcblx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSBMT0FESU5HX01FU1NBR0U7XG5cblx0XHRcdHZhciBzcmMgPSBwcmUuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpO1xuXG5cdFx0XHR2YXIgbGFuZ3VhZ2UgPSBlbnYubGFuZ3VhZ2U7XG5cdFx0XHRpZiAobGFuZ3VhZ2UgPT09ICdub25lJykge1xuXHRcdFx0XHQvLyB0aGUgbGFuZ3VhZ2UgbWlnaHQgYmUgJ25vbmUnIGJlY2F1c2UgdGhlcmUgaXMgbm8gbGFuZ3VhZ2Ugc2V0O1xuXHRcdFx0XHQvLyBpbiB0aGlzIGNhc2UsIHdlIHdhbnQgdG8gdXNlIHRoZSBleHRlbnNpb24gYXMgdGhlIGxhbmd1YWdlXG5cdFx0XHRcdHZhciBleHRlbnNpb24gPSAoL1xcLihcXHcrKSQvLmV4ZWMoc3JjKSB8fCBbLCAnbm9uZSddKVsxXTtcblx0XHRcdFx0bGFuZ3VhZ2UgPSBFWFRFTlNJT05TW2V4dGVuc2lvbl0gfHwgZXh0ZW5zaW9uO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzZXQgbGFuZ3VhZ2UgY2xhc3Nlc1xuXHRcdFx0UHJpc20udXRpbC5zZXRMYW5ndWFnZShjb2RlLCBsYW5ndWFnZSk7XG5cdFx0XHRQcmlzbS51dGlsLnNldExhbmd1YWdlKHByZSwgbGFuZ3VhZ2UpO1xuXG5cdFx0XHQvLyBwcmVsb2FkIHRoZSBsYW5ndWFnZVxuXHRcdFx0dmFyIGF1dG9sb2FkZXIgPSBQcmlzbS5wbHVnaW5zLmF1dG9sb2FkZXI7XG5cdFx0XHRpZiAoYXV0b2xvYWRlcikge1xuXHRcdFx0XHRhdXRvbG9hZGVyLmxvYWRMYW5ndWFnZXMobGFuZ3VhZ2UpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBsb2FkIGZpbGVcblx0XHRcdGxvYWRGaWxlKFxuXHRcdFx0XHRzcmMsXG5cdFx0XHRcdGZ1bmN0aW9uICh0ZXh0KSB7XG5cdFx0XHRcdFx0Ly8gbWFyayBhcyBsb2FkZWRcblx0XHRcdFx0XHRwcmUuc2V0QXR0cmlidXRlKFNUQVRVU19BVFRSLCBTVEFUVVNfTE9BREVEKTtcblxuXHRcdFx0XHRcdC8vIGhhbmRsZSBkYXRhLXJhbmdlXG5cdFx0XHRcdFx0dmFyIHJhbmdlID0gcGFyc2VSYW5nZShwcmUuZ2V0QXR0cmlidXRlKCdkYXRhLXJhbmdlJykpO1xuXHRcdFx0XHRcdGlmIChyYW5nZSkge1xuXHRcdFx0XHRcdFx0dmFyIGxpbmVzID0gdGV4dC5zcGxpdCgvXFxyXFxuP3xcXG4vZyk7XG5cblx0XHRcdFx0XHRcdC8vIHRoZSByYW5nZSBpcyBvbmUtYmFzZWQgYW5kIGluY2x1c2l2ZSBvbiBib3RoIGVuZHNcblx0XHRcdFx0XHRcdHZhciBzdGFydCA9IHJhbmdlWzBdO1xuXHRcdFx0XHRcdFx0dmFyIGVuZCA9IHJhbmdlWzFdID09IG51bGwgPyBsaW5lcy5sZW5ndGggOiByYW5nZVsxXTtcblxuXHRcdFx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBsaW5lcy5sZW5ndGg7IH1cblx0XHRcdFx0XHRcdHN0YXJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc3RhcnQgLSAxLCBsaW5lcy5sZW5ndGgpKTtcblx0XHRcdFx0XHRcdGlmIChlbmQgPCAwKSB7IGVuZCArPSBsaW5lcy5sZW5ndGg7IH1cblx0XHRcdFx0XHRcdGVuZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGVuZCwgbGluZXMubGVuZ3RoKSk7XG5cblx0XHRcdFx0XHRcdHRleHQgPSBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5qb2luKCdcXG4nKTtcblxuXHRcdFx0XHRcdFx0Ly8gYWRkIGRhdGEtc3RhcnQgZm9yIGxpbmUgbnVtYmVyc1xuXHRcdFx0XHRcdFx0aWYgKCFwcmUuaGFzQXR0cmlidXRlKCdkYXRhLXN0YXJ0JykpIHtcblx0XHRcdFx0XHRcdFx0cHJlLnNldEF0dHJpYnV0ZSgnZGF0YS1zdGFydCcsIFN0cmluZyhzdGFydCArIDEpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBoaWdobGlnaHQgY29kZVxuXHRcdFx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuXHRcdFx0XHRcdFByaXNtLmhpZ2hsaWdodEVsZW1lbnQoY29kZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdC8vIG1hcmsgYXMgZmFpbGVkXG5cdFx0XHRcdFx0cHJlLnNldEF0dHJpYnV0ZShTVEFUVVNfQVRUUiwgU1RBVFVTX0ZBSUxFRCk7XG5cblx0XHRcdFx0XHRjb2RlLnRleHRDb250ZW50ID0gZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9KTtcblxuXHRQcmlzbS5wbHVnaW5zLmZpbGVIaWdobGlnaHQgPSB7XG5cdFx0LyoqXG5cdFx0ICogRXhlY3V0ZXMgdGhlIEZpbGUgSGlnaGxpZ2h0IHBsdWdpbiBmb3IgYWxsIG1hdGNoaW5nIGBwcmVgIGVsZW1lbnRzIHVuZGVyIHRoZSBnaXZlbiBjb250YWluZXIuXG5cdFx0ICpcblx0XHQgKiBOb3RlOiBFbGVtZW50cyB3aGljaCBhcmUgYWxyZWFkeSBsb2FkZWQgb3IgY3VycmVudGx5IGxvYWRpbmcgd2lsbCBub3QgYmUgdG91Y2hlZCBieSB0aGlzIG1ldGhvZC5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7UGFyZW50Tm9kZX0gW2NvbnRhaW5lcj1kb2N1bWVudF1cblx0XHQgKi9cblx0XHRoaWdobGlnaHQ6IGZ1bmN0aW9uIGhpZ2hsaWdodChjb250YWluZXIpIHtcblx0XHRcdHZhciBlbGVtZW50cyA9IChjb250YWluZXIgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1IpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgZWxlbWVudDsgKGVsZW1lbnQgPSBlbGVtZW50c1tpKytdKTspIHtcblx0XHRcdFx0UHJpc20uaGlnaGxpZ2h0RWxlbWVudChlbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0dmFyIGxvZ2dlZCA9IGZhbHNlO1xuXHQvKiogQGRlcHJlY2F0ZWQgVXNlIGBQcmlzbS5wbHVnaW5zLmZpbGVIaWdobGlnaHQuaGlnaGxpZ2h0YCBpbnN0ZWFkLiAqL1xuXHRQcmlzbS5maWxlSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmICghbG9nZ2VkKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1ByaXNtLmZpbGVIaWdobGlnaHQgaXMgZGVwcmVjYXRlZC4gVXNlIGBQcmlzbS5wbHVnaW5zLmZpbGVIaWdobGlnaHQuaGlnaGxpZ2h0YCBpbnN0ZWFkLicpO1xuXHRcdFx0bG9nZ2VkID0gdHJ1ZTtcblx0XHR9XG5cdFx0UHJpc20ucGx1Z2lucy5maWxlSGlnaGxpZ2h0LmhpZ2hsaWdodC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9O1xuXG59KCkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prismjs/prism.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/editor.css":
/*!*******************************************!*\
  !*** ./src/components/Lexical/editor.css ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"8fa4380ca2bd\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvZWRpdG9yLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTGV4aWNhbC9lZGl0b3IuY3NzPzc1MDkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI4ZmE0MzgwY2EyYmRcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/editor.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/plugins/floting.css":
/*!****************************************************!*\
  !*** ./src/components/Lexical/plugins/floting.css ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"cffc76d0603d\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvcGx1Z2lucy9mbG90aW5nLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTGV4aWNhbC9wbHVnaW5zL2Zsb3RpbmcuY3NzPzUwNDAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJjZmZjNzZkMDYwM2RcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/plugins/floting.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/Button.css":
/*!**************************************!*\
  !*** ./src/components/ui/Button.css ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"5ea5f38271e0\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL0J1dHRvbi5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3VpL0J1dHRvbi5jc3M/NTlmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjVlYTVmMzgyNzFlMFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/Button.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/Checkbox.css":
/*!****************************************!*\
  !*** ./src/components/ui/Checkbox.css ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"5fd2b59a485b\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL0NoZWNrYm94LmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvQ2hlY2tib3guY3NzP2Q1MTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI1ZmQyYjU5YTQ4NWJcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/Checkbox.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/Dialog.css":
/*!**************************************!*\
  !*** ./src/components/ui/Dialog.css ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"493725a39704\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL0RpYWxvZy5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3VpL0RpYWxvZy5jc3M/NjE3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjQ5MzcyNWEzOTcwNFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/Dialog.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/Input.css":
/*!*************************************!*\
  !*** ./src/components/ui/Input.css ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"80c46b1376cc\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL0lucHV0LmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvSW5wdXQuY3NzPzEzNmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI4MGM0NmIxMzc2Y2NcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/Input.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/Select.css":
/*!**************************************!*\
  !*** ./src/components/ui/Select.css ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"74512507f30a\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL1NlbGVjdC5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3VpL1NlbGVjdC5jc3M/OTI2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjc0NTEyNTA3ZjMwYVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/Select.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/creation/page.jsx":
/*!***********************************!*\
  !*** ./src/app/creation/page.jsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Lexical_MyEditor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/components/Lexical/MyEditor */ \"(app-pages-browser)/./src/components/Lexical/MyEditor.js\");\n/* harmony import */ var _lexical_react_LexicalComposer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/react/LexicalComposer */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposer.js\");\n/* harmony import */ var _lexical_react_LexicalComposer__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalComposer__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _components_Lexical_Theme__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/Lexical/Theme */ \"(app-pages-browser)/./src/components/Lexical/Theme.js\");\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/rich-text */ \"(app-pages-browser)/./node_modules/@lexical/rich-text/LexicalRichText.js\");\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lexical_rich_text__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _lexical_table__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lexical/table */ \"(app-pages-browser)/./node_modules/@lexical/table/LexicalTable.js\");\n/* harmony import */ var _lexical_table__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lexical_table__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _lexical_list__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lexical/list */ \"(app-pages-browser)/./node_modules/@lexical/list/LexicalList.js\");\n/* harmony import */ var _lexical_list__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_lexical_list__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _lexical_code__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lexical/code */ \"(app-pages-browser)/./node_modules/@lexical/code/LexicalCode.js\");\n/* harmony import */ var _lexical_code__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_lexical_code__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lexical/link */ \"(app-pages-browser)/./node_modules/@lexical/link/LexicalLink.js\");\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_lexical_link__WEBPACK_IMPORTED_MODULE_9__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\n\n\n\n\n\n\nconst editorConfig = {\n    // NOTE: This is critical for collaboration plugin to set editor state to null. It\n    // would indicate that the editor should not try to set any default state\n    // (not even empty one), and let collaboration plugin do it instead\n    editorState: null,\n    namespace: \"React.js Collab Demo\",\n    nodes: [\n        _lexical_rich_text__WEBPACK_IMPORTED_MODULE_5__.HeadingNode,\n        _lexical_list__WEBPACK_IMPORTED_MODULE_7__.ListNode,\n        _lexical_list__WEBPACK_IMPORTED_MODULE_7__.ListItemNode,\n        _lexical_rich_text__WEBPACK_IMPORTED_MODULE_5__.QuoteNode,\n        _lexical_code__WEBPACK_IMPORTED_MODULE_8__.CodeNode,\n        _lexical_code__WEBPACK_IMPORTED_MODULE_8__.CodeHighlightNode,\n        _lexical_table__WEBPACK_IMPORTED_MODULE_6__.TableNode,\n        _lexical_table__WEBPACK_IMPORTED_MODULE_6__.TableCellNode,\n        _lexical_table__WEBPACK_IMPORTED_MODULE_6__.TableRowNode,\n        _lexical_link__WEBPACK_IMPORTED_MODULE_9__.AutoLinkNode,\n        _lexical_link__WEBPACK_IMPORTED_MODULE_9__.LinkNode\n    ],\n    // Handling of errors during update\n    onError (error) {\n        throw error;\n    },\n    // The editor theme\n    theme: _components_Lexical_Theme__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n    editable: true\n};\nconst page = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            height: \"100%\",\n            width: \"100%\"\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalComposer__WEBPACK_IMPORTED_MODULE_3__.LexicalComposer, {\n            initialConfig: editorConfig,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Lexical_MyEditor__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/app/creation/page.jsx\",\n                lineNumber: 42,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/app/creation/page.jsx\",\n            lineNumber: 41,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/app/creation/page.jsx\",\n        lineNumber: 40,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (page);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY3JlYXRpb24vcGFnZS5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUN5QjtBQUMyQjtBQUNhO0FBQ1g7QUFDTTtBQUNZO0FBQ2pCO0FBQ0s7QUFDTDtBQUN2RCxNQUFNZSxlQUFlO0lBQ25CLGtGQUFrRjtJQUNsRix5RUFBeUU7SUFDekUsbUVBQW1FO0lBQ25FQyxhQUFhO0lBQ2JDLFdBQVc7SUFDWEMsT0FBTztRQUNMZCwyREFBV0E7UUFDWE0sbURBQVFBO1FBQ1JELHVEQUFZQTtRQUNaSix5REFBU0E7UUFDVE8sbURBQVFBO1FBQ1JELDREQUFpQkE7UUFDakJKLHFEQUFTQTtRQUNURCx5REFBYUE7UUFDYkUsd0RBQVlBO1FBQ1pLLHVEQUFZQTtRQUNaQyxtREFBUUE7S0FDVDtJQUNELG1DQUFtQztJQUNuQ0ssU0FBUUMsS0FBSztRQUNYLE1BQU1BO0lBQ1I7SUFDQSxtQkFBbUI7SUFDbkJDLE9BQU9sQixpRUFBWUE7SUFDbkJtQixVQUFVO0FBQ1o7QUFDQSxNQUFNQyxPQUFPO0lBQ1gscUJBQ0UsOERBQUNDO1FBQUlDLE9BQU87WUFBRUMsUUFBUTtZQUFRQyxPQUFPO1FBQU87a0JBQzFDLDRFQUFDekIsMkVBQWVBO1lBQUMwQixlQUFlYjtzQkFDOUIsNEVBQUNkLG9FQUFRQTs7Ozs7Ozs7Ozs7Ozs7O0FBSWpCO0FBRUEsK0RBQWVzQixJQUFJQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvY3JlYXRpb24vcGFnZS5qc3g/YzU3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IE15RWRpdG9yIGZyb20gJ0AvY29tcG9uZW50cy9MZXhpY2FsL015RWRpdG9yJ1xuaW1wb3J0IHsgTGV4aWNhbENvbXBvc2VyIH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyJztcbmltcG9ydCBFeGFtcGxlVGhlbWUgZnJvbSAnQC9jb21wb25lbnRzL0xleGljYWwvVGhlbWUnO1xuaW1wb3J0IHsgSGVhZGluZ05vZGUsIFF1b3RlTm9kZSB9IGZyb20gXCJAbGV4aWNhbC9yaWNoLXRleHRcIjtcbmltcG9ydCB7IFRhYmxlQ2VsbE5vZGUsIFRhYmxlTm9kZSwgVGFibGVSb3dOb2RlIH0gZnJvbSBcIkBsZXhpY2FsL3RhYmxlXCI7XG5pbXBvcnQgeyBMaXN0SXRlbU5vZGUsIExpc3ROb2RlIH0gZnJvbSBcIkBsZXhpY2FsL2xpc3RcIjtcbmltcG9ydCB7IENvZGVIaWdobGlnaHROb2RlLCBDb2RlTm9kZSB9IGZyb20gXCJAbGV4aWNhbC9jb2RlXCI7XG5pbXBvcnQgeyBBdXRvTGlua05vZGUsIExpbmtOb2RlIH0gZnJvbSBcIkBsZXhpY2FsL2xpbmtcIjtcbmNvbnN0IGVkaXRvckNvbmZpZyA9IHtcbiAgLy8gTk9URTogVGhpcyBpcyBjcml0aWNhbCBmb3IgY29sbGFib3JhdGlvbiBwbHVnaW4gdG8gc2V0IGVkaXRvciBzdGF0ZSB0byBudWxsLiBJdFxuICAvLyB3b3VsZCBpbmRpY2F0ZSB0aGF0IHRoZSBlZGl0b3Igc2hvdWxkIG5vdCB0cnkgdG8gc2V0IGFueSBkZWZhdWx0IHN0YXRlXG4gIC8vIChub3QgZXZlbiBlbXB0eSBvbmUpLCBhbmQgbGV0IGNvbGxhYm9yYXRpb24gcGx1Z2luIGRvIGl0IGluc3RlYWRcbiAgZWRpdG9yU3RhdGU6IG51bGwsXG4gIG5hbWVzcGFjZTogJ1JlYWN0LmpzIENvbGxhYiBEZW1vJyxcbiAgbm9kZXM6IFtcbiAgICBIZWFkaW5nTm9kZSxcbiAgICBMaXN0Tm9kZSxcbiAgICBMaXN0SXRlbU5vZGUsXG4gICAgUXVvdGVOb2RlLFxuICAgIENvZGVOb2RlLFxuICAgIENvZGVIaWdobGlnaHROb2RlLFxuICAgIFRhYmxlTm9kZSxcbiAgICBUYWJsZUNlbGxOb2RlLFxuICAgIFRhYmxlUm93Tm9kZSxcbiAgICBBdXRvTGlua05vZGUsXG4gICAgTGlua05vZGUsXG4gIF0sXG4gIC8vIEhhbmRsaW5nIG9mIGVycm9ycyBkdXJpbmcgdXBkYXRlXG4gIG9uRXJyb3IoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSxcbiAgLy8gVGhlIGVkaXRvciB0aGVtZVxuICB0aGVtZTogRXhhbXBsZVRoZW1lLFxuICBlZGl0YWJsZTogdHJ1ZSxcbn07XG5jb25zdCBwYWdlID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxkaXYgc3R5bGU9e3sgaGVpZ2h0OiBcIjEwMCVcIiwgd2lkdGg6IFwiMTAwJVwiIH19PlxuICAgICAgPExleGljYWxDb21wb3NlciBpbml0aWFsQ29uZmlnPXtlZGl0b3JDb25maWd9PlxuICAgICAgICA8TXlFZGl0b3IvPlxuICAgICAgPC9MZXhpY2FsQ29tcG9zZXI+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFnZSJdLCJuYW1lcyI6WyJSZWFjdCIsIk15RWRpdG9yIiwiTGV4aWNhbENvbXBvc2VyIiwiRXhhbXBsZVRoZW1lIiwiSGVhZGluZ05vZGUiLCJRdW90ZU5vZGUiLCJUYWJsZUNlbGxOb2RlIiwiVGFibGVOb2RlIiwiVGFibGVSb3dOb2RlIiwiTGlzdEl0ZW1Ob2RlIiwiTGlzdE5vZGUiLCJDb2RlSGlnaGxpZ2h0Tm9kZSIsIkNvZGVOb2RlIiwiQXV0b0xpbmtOb2RlIiwiTGlua05vZGUiLCJlZGl0b3JDb25maWciLCJlZGl0b3JTdGF0ZSIsIm5hbWVzcGFjZSIsIm5vZGVzIiwib25FcnJvciIsImVycm9yIiwidGhlbWUiLCJlZGl0YWJsZSIsInBhZ2UiLCJkaXYiLCJzdHlsZSIsImhlaWdodCIsIndpZHRoIiwiaW5pdGlhbENvbmZpZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/creation/page.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/MyEditor.js":
/*!********************************************!*\
  !*** ./src/components/Lexical/MyEditor.js ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Editor; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _hooks_useMediaQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hooks/useMediaQuery */ \"(app-pages-browser)/./src/components/Lexical/hooks/useMediaQuery.js\");\n/* harmony import */ var _lexical_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/html */ \"(app-pages-browser)/./node_modules/@lexical/html/LexicalHtml.js\");\n/* harmony import */ var _lexical_html__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lexical_html__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lexical_react_LexicalRichTextPlugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/react/LexicalRichTextPlugin */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalRichTextPlugin.js\");\n/* harmony import */ var _lexical_react_LexicalRichTextPlugin__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalRichTextPlugin__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _lexical_react_LexicalContentEditable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/react/LexicalContentEditable */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalContentEditable.js\");\n/* harmony import */ var _lexical_react_LexicalContentEditable__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalContentEditable__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _lexical_react_LexicalHistoryPlugin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lexical/react/LexicalHistoryPlugin */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalHistoryPlugin.js\");\n/* harmony import */ var _lexical_react_LexicalHistoryPlugin__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalHistoryPlugin__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _lexical_react_LexicalAutoFocusPlugin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lexical/react/LexicalAutoFocusPlugin */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.js\");\n/* harmony import */ var _lexical_react_LexicalAutoFocusPlugin__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalAutoFocusPlugin__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _lexical_react_LexicalErrorBoundary__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lexical/react/LexicalErrorBoundary */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalErrorBoundary.js\");\n/* harmony import */ var _lexical_react_LexicalErrorBoundary__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalErrorBoundary__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _lexical_react_LexicalLinkPlugin__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lexical/react/LexicalLinkPlugin */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalLinkPlugin.js\");\n/* harmony import */ var _lexical_react_LexicalLinkPlugin__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalLinkPlugin__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _lexical_react_LexicalListPlugin__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lexical/react/LexicalListPlugin */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalListPlugin.js\");\n/* harmony import */ var _lexical_react_LexicalListPlugin__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalListPlugin__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _lexical_react_LexicalMarkdownShortcutPlugin__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @lexical/react/LexicalMarkdownShortcutPlugin */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js\");\n/* harmony import */ var _lexical_react_LexicalMarkdownShortcutPlugin__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalMarkdownShortcutPlugin__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _lexical_markdown__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @lexical/markdown */ \"(app-pages-browser)/./node_modules/@lexical/markdown/LexicalMarkdown.js\");\n/* harmony import */ var _lexical_markdown__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_lexical_markdown__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var _lexical_react_LexicalOnChangePlugin__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @lexical/react/LexicalOnChangePlugin */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalOnChangePlugin.js\");\n/* harmony import */ var _lexical_react_LexicalOnChangePlugin__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalOnChangePlugin__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var _editor_css__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./editor.css */ \"(app-pages-browser)/./src/components/Lexical/editor.css\");\n/* harmony import */ var _plugins_DragDropPastPlugin__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./plugins/DragDropPastPlugin */ \"(app-pages-browser)/./src/components/Lexical/plugins/DragDropPastPlugin.js\");\n/* harmony import */ var _plugins_ToolbarPlugin__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./plugins/ToolbarPlugin */ \"(app-pages-browser)/./src/components/Lexical/plugins/ToolbarPlugin.js\");\n/* harmony import */ var _plugins_TreeViewPlugin__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./plugins/TreeViewPlugin */ \"(app-pages-browser)/./src/components/Lexical/plugins/TreeViewPlugin.js\");\n/* harmony import */ var _plugins_FloatingLinkEditorPlugin__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./plugins/FloatingLinkEditorPlugin */ \"(app-pages-browser)/./src/components/Lexical/plugins/FloatingLinkEditorPlugin.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Placeholder() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"editor-placeholder\",\n        children: \"Enter some rich text...\"\n    }, void 0, false, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n        lineNumber: 22,\n        columnNumber: 10\n    }, this);\n}\n_c = Placeholder;\nfunction Editor() {\n    _s();\n    const isSmallWidthViewPort = (0,_hooks_useMediaQuery__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"(max-width: 1025px)\");\n    const [previewMode, setPreviewMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [textValue, setTextValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const handlePreviewMode = ()=>setPreviewMode(!previewMode);\n    const [floatingAnchorElem, setFloatingAnchorElem] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const onChange = (editorState, editor)=>{\n        editorState.read(()=>{\n            const markdown = (0,_lexical_markdown__WEBPACK_IMPORTED_MODULE_12__.$convertToMarkdownString)(_lexical_markdown__WEBPACK_IMPORTED_MODULE_12__.TRANSFORMERS);\n            const htmlString = (0,_lexical_html__WEBPACK_IMPORTED_MODULE_3__.$generateHtmlFromNodes)(editor, null);\n            console.log(htmlString);\n            setTextValue(markdown);\n        });\n    };\n    const onRef = (_floatingAnchorElem)=>{\n        if (_floatingAnchorElem !== null) {\n            setFloatingAnchorElem(_floatingAnchorElem);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"editor-container\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_plugins_ToolbarPlugin__WEBPACK_IMPORTED_MODULE_16__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n                lineNumber: 50,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"editor-inner\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalRichTextPlugin__WEBPACK_IMPORTED_MODULE_4__.RichTextPlugin, {\n                        contentEditable: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"editor\",\n                            ref: onRef,\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalContentEditable__WEBPACK_IMPORTED_MODULE_5__.ContentEditable, {\n                                className: \"editor-input\"\n                            }, void 0, false, {\n                                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n                                lineNumber: 53,\n                                columnNumber: 64\n                            }, void 0)\n                        }, void 0, false, {\n                            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n                            lineNumber: 53,\n                            columnNumber: 28\n                        }, void 0),\n                        placeholder: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Placeholder, {}, void 0, false, {\n                            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n                            lineNumber: 54,\n                            columnNumber: 24\n                        }, void 0),\n                        ErrorBoundary: (_lexical_react_LexicalErrorBoundary__WEBPACK_IMPORTED_MODULE_8___default())\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n                        lineNumber: 52,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalAutoFocusPlugin__WEBPACK_IMPORTED_MODULE_7__.AutoFocusPlugin, {}, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n                        lineNumber: 57,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalOnChangePlugin__WEBPACK_IMPORTED_MODULE_13__.OnChangePlugin, {\n                        onChange: onChange\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n                        lineNumber: 58,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalHistoryPlugin__WEBPACK_IMPORTED_MODULE_6__.HistoryPlugin, {}, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n                        lineNumber: 59,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalListPlugin__WEBPACK_IMPORTED_MODULE_10__.ListPlugin, {}, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n                        lineNumber: 61,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalLinkPlugin__WEBPACK_IMPORTED_MODULE_9__.LinkPlugin, {}, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n                        lineNumber: 62,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_plugins_DragDropPastPlugin__WEBPACK_IMPORTED_MODULE_15__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n                        lineNumber: 63,\n                        columnNumber: 9\n                    }, this),\n                    floatingAnchorElem && !isSmallWidthViewPort && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_plugins_FloatingLinkEditorPlugin__WEBPACK_IMPORTED_MODULE_18__[\"default\"], {\n                        anchorElem: floatingAnchorElem\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n                        lineNumber: 65,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalMarkdownShortcutPlugin__WEBPACK_IMPORTED_MODULE_11__.MarkdownShortcutPlugin, {\n                        transformers: _lexical_markdown__WEBPACK_IMPORTED_MODULE_12__.TRANSFORMERS\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n                        lineNumber: 67,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n                lineNumber: 51,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/MyEditor.js\",\n        lineNumber: 49,\n        columnNumber: 5\n    }, this);\n}\n_s(Editor, \"IzTDRKzsKSfdrmwCZnmSGRCvp8M=\", false, function() {\n    return [\n        _hooks_useMediaQuery__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n    ];\n});\n_c1 = Editor;\nvar _c, _c1;\n$RefreshReg$(_c, \"Placeholder\");\n$RefreshReg$(_c1, \"Editor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvTXlFZGl0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQUNTO0FBQ007QUFDZTtBQUNFO0FBQ0o7QUFDSTtBQUNEO0FBQ1Q7QUFDQTtBQUN3QjtBQUNYO0FBQ0w7QUFFaEQ7QUFDbUM7QUFDTDtBQUNFO0FBQ29CO0FBRTFFLFNBQVNtQjtJQUNQLHFCQUFPLDhEQUFDQztRQUFJQyxXQUFVO2tCQUFxQjs7Ozs7O0FBQzdDO0tBRlNGO0FBSU0sU0FBU0c7O0lBRXRCLE1BQU1DLHVCQUF1QnJCLGdFQUFhQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ3NCLGFBQWFDLGVBQWUsR0FBR3hCLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ3lCLFdBQVdDLGFBQWEsR0FBRzFCLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0yQixvQkFBb0IsSUFBTUgsZUFBZSxDQUFDRDtJQUNoRCxNQUFNLENBQUNLLG9CQUFvQkMsc0JBQXNCLEdBQy9DN0IsK0NBQVFBLENBQUM7SUFDWCxNQUFNOEIsV0FBVyxDQUFDQyxhQUFhQztRQUM3QkQsWUFBWUUsSUFBSSxDQUFDO1lBQ2YsTUFBTUMsV0FBV3RCLDRFQUF3QkEsQ0FBQ0QsNERBQVlBO1lBQ3RELE1BQU13QixhQUFhakMscUVBQXNCQSxDQUFDOEIsUUFBUTtZQUNsREksUUFBUUMsR0FBRyxDQUFDRjtZQUNaVCxhQUFhUTtRQUNmO0lBQ0Y7SUFDQSxNQUFNSSxRQUFRLENBQUNDO1FBQ2IsSUFBSUEsd0JBQXdCLE1BQU07WUFDaENWLHNCQUFzQlU7UUFDeEI7SUFDRjtJQUdBLHFCQUNFLDhEQUFDcEI7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNMLCtEQUFhQTs7Ozs7MEJBQ2QsOERBQUNJO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ2pCLGdGQUFjQTt3QkFDYnFDLCtCQUFpQiw4REFBQ3JCOzRCQUFJQyxXQUFVOzRCQUFTcUIsS0FBS0g7c0NBQU8sNEVBQUNsQyxrRkFBZUE7Z0NBQUNnQixXQUFVOzs7Ozs7Ozs7Ozt3QkFDaEZzQiwyQkFBYSw4REFBQ3hCOzs7Ozt3QkFDZHlCLGVBQWVwQyw0RUFBb0JBOzs7Ozs7a0NBRXJDLDhEQUFDRCxrRkFBZUE7Ozs7O2tDQUNoQiw4REFBQ08saUZBQWNBO3dCQUFDaUIsVUFBVUE7Ozs7OztrQ0FDMUIsOERBQUN6Qiw4RUFBYUE7Ozs7O2tDQUVkLDhEQUFDSSx5RUFBVUE7Ozs7O2tDQUNYLDhEQUFDRCx3RUFBVUE7Ozs7O2tDQUNYLDhEQUFDTSxvRUFBYUE7Ozs7O29CQUNiYyxzQkFBc0IsQ0FBQ04sc0NBQ3RCLDhEQUFDTCwwRUFBd0JBO3dCQUFDMkIsWUFBWWhCOzs7Ozs7a0NBRXhDLDhEQUFDbEIsaUdBQXNCQTt3QkFBQ21DLGNBQWNsQyw0REFBWUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUsxRDtHQS9Dd0JVOztRQUVPcEIsNERBQWFBOzs7TUFGcEJvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9MZXhpY2FsL015RWRpdG9yLmpzPzBlZTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdXNlTWVkaWFRdWVyeSBmcm9tICcuL2hvb2tzL3VzZU1lZGlhUXVlcnknXG5pbXBvcnQgeyAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzIH0gZnJvbSAnQGxleGljYWwvaHRtbCc7XG5pbXBvcnQgeyBSaWNoVGV4dFBsdWdpbiB9IGZyb20gXCJAbGV4aWNhbC9yZWFjdC9MZXhpY2FsUmljaFRleHRQbHVnaW5cIjtcbmltcG9ydCB7IENvbnRlbnRFZGl0YWJsZSB9IGZyb20gXCJAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29udGVudEVkaXRhYmxlXCI7XG5pbXBvcnQgeyBIaXN0b3J5UGx1Z2luIH0gZnJvbSBcIkBsZXhpY2FsL3JlYWN0L0xleGljYWxIaXN0b3J5UGx1Z2luXCI7XG5pbXBvcnQgeyBBdXRvRm9jdXNQbHVnaW4gfSBmcm9tIFwiQGxleGljYWwvcmVhY3QvTGV4aWNhbEF1dG9Gb2N1c1BsdWdpblwiO1xuaW1wb3J0IExleGljYWxFcnJvckJvdW5kYXJ5IGZyb20gXCJAbGV4aWNhbC9yZWFjdC9MZXhpY2FsRXJyb3JCb3VuZGFyeVwiO1xuaW1wb3J0IHsgTGlua1BsdWdpbiB9IGZyb20gXCJAbGV4aWNhbC9yZWFjdC9MZXhpY2FsTGlua1BsdWdpblwiO1xuaW1wb3J0IHsgTGlzdFBsdWdpbiB9IGZyb20gXCJAbGV4aWNhbC9yZWFjdC9MZXhpY2FsTGlzdFBsdWdpblwiO1xuaW1wb3J0IHsgTWFya2Rvd25TaG9ydGN1dFBsdWdpbiB9IGZyb20gXCJAbGV4aWNhbC9yZWFjdC9MZXhpY2FsTWFya2Rvd25TaG9ydGN1dFBsdWdpblwiO1xuaW1wb3J0IHsgVFJBTlNGT1JNRVJTLCAkY29udmVydFRvTWFya2Rvd25TdHJpbmcgfSBmcm9tIFwiQGxleGljYWwvbWFya2Rvd25cIjtcbmltcG9ydCB7IE9uQ2hhbmdlUGx1Z2luIH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbE9uQ2hhbmdlUGx1Z2luJztcblxuaW1wb3J0IFwiLi9lZGl0b3IuY3NzXCI7XG5pbXBvcnQgRHJhZ0Ryb3BQYXN0ZSBmcm9tIFwiLi9wbHVnaW5zL0RyYWdEcm9wUGFzdFBsdWdpblwiO1xuaW1wb3J0IFRvb2xiYXJQbHVnaW4gZnJvbSAnLi9wbHVnaW5zL1Rvb2xiYXJQbHVnaW4nO1xuaW1wb3J0IFRyZWVWaWV3UGx1Z2luIGZyb20gJy4vcGx1Z2lucy9UcmVlVmlld1BsdWdpbic7XG5pbXBvcnQgRmxvYXRpbmdMaW5rRWRpdG9yUGx1Z2luIGZyb20gXCIuL3BsdWdpbnMvRmxvYXRpbmdMaW5rRWRpdG9yUGx1Z2luXCI7XG5cbmZ1bmN0aW9uIFBsYWNlaG9sZGVyKCkge1xuICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJlZGl0b3ItcGxhY2Vob2xkZXJcIj5FbnRlciBzb21lIHJpY2ggdGV4dC4uLjwvZGl2Pjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRWRpdG9yKCkge1xuXG4gIGNvbnN0IGlzU21hbGxXaWR0aFZpZXdQb3J0ID0gdXNlTWVkaWFRdWVyeSgnKG1heC13aWR0aDogMTAyNXB4KScpXG4gIGNvbnN0IFtwcmV2aWV3TW9kZSwgc2V0UHJldmlld01vZGVdID0gdXNlU3RhdGUoZmFsc2UpXG4gIGNvbnN0IFt0ZXh0VmFsdWUsIHNldFRleHRWYWx1ZV0gPSB1c2VTdGF0ZShcIlwiKVxuICBjb25zdCBoYW5kbGVQcmV2aWV3TW9kZSA9ICgpID0+IHNldFByZXZpZXdNb2RlKCFwcmV2aWV3TW9kZSk7XG4gIGNvbnN0IFtmbG9hdGluZ0FuY2hvckVsZW0sIHNldEZsb2F0aW5nQW5jaG9yRWxlbV0gPVxuICAgIHVzZVN0YXRlKG51bGwpXG4gIGNvbnN0IG9uQ2hhbmdlID0gKGVkaXRvclN0YXRlLCBlZGl0b3IpID0+IHtcbiAgICBlZGl0b3JTdGF0ZS5yZWFkKCgpID0+IHtcbiAgICAgIGNvbnN0IG1hcmtkb3duID0gJGNvbnZlcnRUb01hcmtkb3duU3RyaW5nKFRSQU5TRk9STUVSUyk7XG4gICAgICBjb25zdCBodG1sU3RyaW5nID0gJGdlbmVyYXRlSHRtbEZyb21Ob2RlcyhlZGl0b3IsIG51bGwpO1xuICAgICAgY29uc29sZS5sb2coaHRtbFN0cmluZyk7XG4gICAgICBzZXRUZXh0VmFsdWUobWFya2Rvd24pXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgb25SZWYgPSAoX2Zsb2F0aW5nQW5jaG9yRWxlbSkgPT4ge1xuICAgIGlmIChfZmxvYXRpbmdBbmNob3JFbGVtICE9PSBudWxsKSB7XG4gICAgICBzZXRGbG9hdGluZ0FuY2hvckVsZW0oX2Zsb2F0aW5nQW5jaG9yRWxlbSlcbiAgICB9XG4gIH1cblxuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJlZGl0b3ItY29udGFpbmVyXCI+XG4gICAgICA8VG9vbGJhclBsdWdpbiAvPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJlZGl0b3ItaW5uZXJcIj5cbiAgICAgICAgPFJpY2hUZXh0UGx1Z2luXG4gICAgICAgICAgY29udGVudEVkaXRhYmxlPXs8ZGl2IGNsYXNzTmFtZT1cImVkaXRvclwiIHJlZj17b25SZWZ9PjxDb250ZW50RWRpdGFibGUgY2xhc3NOYW1lPVwiZWRpdG9yLWlucHV0XCIvPjwvZGl2Pn1cbiAgICAgICAgICBwbGFjZWhvbGRlcj17PFBsYWNlaG9sZGVyIC8+fVxuICAgICAgICAgIEVycm9yQm91bmRhcnk9e0xleGljYWxFcnJvckJvdW5kYXJ5fVxuICAgICAgICAvPlxuICAgICAgICA8QXV0b0ZvY3VzUGx1Z2luIC8+XG4gICAgICAgIDxPbkNoYW5nZVBsdWdpbiBvbkNoYW5nZT17b25DaGFuZ2V9IC8+XG4gICAgICAgIDxIaXN0b3J5UGx1Z2luIC8+XG4gICAgICAgIHsvKiA8Q29kZUhpZ2hsaWdodFBsdWdpbiAvPiAqL31cbiAgICAgICAgPExpc3RQbHVnaW4gLz5cbiAgICAgICAgPExpbmtQbHVnaW4gLz5cbiAgICAgICAgPERyYWdEcm9wUGFzdGUgLz5cbiAgICAgICAge2Zsb2F0aW5nQW5jaG9yRWxlbSAmJiAhaXNTbWFsbFdpZHRoVmlld1BvcnQgJiYgKFxuICAgICAgICAgIDxGbG9hdGluZ0xpbmtFZGl0b3JQbHVnaW4gYW5jaG9yRWxlbT17ZmxvYXRpbmdBbmNob3JFbGVtfSAvPlxuICAgICAgICApfVxuICAgICAgICA8TWFya2Rvd25TaG9ydGN1dFBsdWdpbiB0cmFuc2Zvcm1lcnM9e1RSQU5TRk9STUVSU30gLz5cbiAgICAgICAgey8qIDxUcmVlVmlld1BsdWdpbiAvPiAqL31cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VNZWRpYVF1ZXJ5IiwiJGdlbmVyYXRlSHRtbEZyb21Ob2RlcyIsIlJpY2hUZXh0UGx1Z2luIiwiQ29udGVudEVkaXRhYmxlIiwiSGlzdG9yeVBsdWdpbiIsIkF1dG9Gb2N1c1BsdWdpbiIsIkxleGljYWxFcnJvckJvdW5kYXJ5IiwiTGlua1BsdWdpbiIsIkxpc3RQbHVnaW4iLCJNYXJrZG93blNob3J0Y3V0UGx1Z2luIiwiVFJBTlNGT1JNRVJTIiwiJGNvbnZlcnRUb01hcmtkb3duU3RyaW5nIiwiT25DaGFuZ2VQbHVnaW4iLCJEcmFnRHJvcFBhc3RlIiwiVG9vbGJhclBsdWdpbiIsIlRyZWVWaWV3UGx1Z2luIiwiRmxvYXRpbmdMaW5rRWRpdG9yUGx1Z2luIiwiUGxhY2Vob2xkZXIiLCJkaXYiLCJjbGFzc05hbWUiLCJFZGl0b3IiLCJpc1NtYWxsV2lkdGhWaWV3UG9ydCIsInByZXZpZXdNb2RlIiwic2V0UHJldmlld01vZGUiLCJ0ZXh0VmFsdWUiLCJzZXRUZXh0VmFsdWUiLCJoYW5kbGVQcmV2aWV3TW9kZSIsImZsb2F0aW5nQW5jaG9yRWxlbSIsInNldEZsb2F0aW5nQW5jaG9yRWxlbSIsIm9uQ2hhbmdlIiwiZWRpdG9yU3RhdGUiLCJlZGl0b3IiLCJyZWFkIiwibWFya2Rvd24iLCJodG1sU3RyaW5nIiwiY29uc29sZSIsImxvZyIsIm9uUmVmIiwiX2Zsb2F0aW5nQW5jaG9yRWxlbSIsImNvbnRlbnRFZGl0YWJsZSIsInJlZiIsInBsYWNlaG9sZGVyIiwiRXJyb3JCb3VuZGFyeSIsImFuY2hvckVsZW0iLCJ0cmFuc2Zvcm1lcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/MyEditor.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/Theme.js":
/*!*****************************************!*\
  !*** ./src/components/Lexical/Theme.js ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nconst theme = {\n    ltr: \"ltr\",\n    rtl: \"rtl\",\n    placeholder: \"editor-placeholder\",\n    paragraph: \"editor-paragraph\",\n    quote: \"editor-quote\",\n    heading: {\n        h1: \"editor-heading-h1\",\n        h2: \"editor-heading-h2\",\n        h3: \"editor-heading-h3\",\n        h4: \"editor-heading-h4\",\n        h5: \"editor-heading-h5\"\n    },\n    list: {\n        nested: {\n            listitem: \"editor-nested-listitem\"\n        },\n        ol: \"editor-list-ol\",\n        ul: \"editor-list-ul\",\n        listitem: \"editor-listitem\"\n    },\n    image: \"editor-image\",\n    link: \"editor-link\",\n    text: {\n        bold: \"editor-text-bold\",\n        italic: \"editor-text-italic\",\n        overflowed: \"editor-text-overflowed\",\n        hashtag: \"editor-text-hashtag\",\n        underline: \"editor-text-underline\",\n        strikethrough: \"editor-text-strikethrough\",\n        underlineStrikethrough: \"editor-text-underlineStrikethrough\",\n        code: \"editor-text-code\"\n    },\n    code: \"editor-code\",\n    codeHighlight: {\n        atrule: \"editor-tokenAttr\",\n        attr: \"editor-tokenAttr\",\n        boolean: \"editor-tokenProperty\",\n        builtin: \"editor-tokenSelector\",\n        cdata: \"editor-tokenComment\",\n        char: \"editor-tokenSelector\",\n        class: \"editor-tokenFunction\",\n        \"class-name\": \"editor-tokenFunction\",\n        comment: \"editor-tokenComment\",\n        constant: \"editor-tokenProperty\",\n        deleted: \"editor-tokenProperty\",\n        doctype: \"editor-tokenComment\",\n        entity: \"editor-tokenOperator\",\n        function: \"editor-tokenFunction\",\n        important: \"editor-tokenVariable\",\n        inserted: \"editor-tokenSelector\",\n        keyword: \"editor-tokenAttr\",\n        namespace: \"editor-tokenVariable\",\n        number: \"editor-tokenProperty\",\n        operator: \"editor-tokenOperator\",\n        prolog: \"editor-tokenComment\",\n        property: \"editor-tokenProperty\",\n        punctuation: \"editor-tokenPunctuation\",\n        regex: \"editor-tokenVariable\",\n        selector: \"editor-tokenSelector\",\n        string: \"editor-tokenSelector\",\n        symbol: \"editor-tokenProperty\",\n        tag: \"editor-tokenProperty\",\n        url: \"editor-tokenOperator\",\n        variable: \"editor-tokenVariable\"\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (theme);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvVGhlbWUuanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLFFBQVE7SUFDWkMsS0FBSztJQUNMQyxLQUFLO0lBQ0xDLGFBQWE7SUFDYkMsV0FBVztJQUNYQyxPQUFPO0lBQ1BDLFNBQVM7UUFDUEMsSUFBSTtRQUNKQyxJQUFJO1FBQ0pDLElBQUk7UUFDSkMsSUFBSTtRQUNKQyxJQUFJO0lBQ047SUFDQUMsTUFBTTtRQUNKQyxRQUFRO1lBQ05DLFVBQVU7UUFDWjtRQUNBQyxJQUFJO1FBQ0pDLElBQUk7UUFDSkYsVUFBVTtJQUNaO0lBQ0FHLE9BQU87SUFDUEMsTUFBTTtJQUNOQyxNQUFNO1FBQ0pDLE1BQU07UUFDTkMsUUFBUTtRQUNSQyxZQUFZO1FBQ1pDLFNBQVM7UUFDVEMsV0FBVztRQUNYQyxlQUFlO1FBQ2ZDLHdCQUF3QjtRQUN4QkMsTUFBTTtJQUNSO0lBQ0FBLE1BQU07SUFDTkMsZUFBZTtRQUNiQyxRQUFRO1FBQ1JDLE1BQU07UUFDTkMsU0FBUztRQUNUQyxTQUFTO1FBQ1RDLE9BQU87UUFDUEMsTUFBTTtRQUNOQyxPQUFPO1FBQ1AsY0FBYztRQUNkQyxTQUFTO1FBQ1RDLFVBQVU7UUFDVkMsU0FBUztRQUNUQyxTQUFTO1FBQ1RDLFFBQVE7UUFDUkMsVUFBVTtRQUNWQyxXQUFXO1FBQ1hDLFVBQVU7UUFDVkMsU0FBUztRQUNUQyxXQUFXO1FBQ1hDLFFBQVE7UUFDUkMsVUFBVTtRQUNWQyxRQUFRO1FBQ1JDLFVBQVU7UUFDVkMsYUFBYTtRQUNiQyxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsUUFBUTtRQUNSQyxRQUFRO1FBQ1JDLEtBQUs7UUFDTEMsS0FBSztRQUNMQyxVQUFVO0lBQ1o7QUFDRjtBQUVBLCtEQUFlekQsS0FBS0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9MZXhpY2FsL1RoZW1lLmpzP2RjZjciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdGhlbWUgPSB7XG4gIGx0cjogXCJsdHJcIixcbiAgcnRsOiBcInJ0bFwiLFxuICBwbGFjZWhvbGRlcjogXCJlZGl0b3ItcGxhY2Vob2xkZXJcIixcbiAgcGFyYWdyYXBoOiBcImVkaXRvci1wYXJhZ3JhcGhcIixcbiAgcXVvdGU6IFwiZWRpdG9yLXF1b3RlXCIsXG4gIGhlYWRpbmc6IHtcbiAgICBoMTogXCJlZGl0b3ItaGVhZGluZy1oMVwiLFxuICAgIGgyOiBcImVkaXRvci1oZWFkaW5nLWgyXCIsXG4gICAgaDM6IFwiZWRpdG9yLWhlYWRpbmctaDNcIixcbiAgICBoNDogXCJlZGl0b3ItaGVhZGluZy1oNFwiLFxuICAgIGg1OiBcImVkaXRvci1oZWFkaW5nLWg1XCJcbiAgfSxcbiAgbGlzdDoge1xuICAgIG5lc3RlZDoge1xuICAgICAgbGlzdGl0ZW06IFwiZWRpdG9yLW5lc3RlZC1saXN0aXRlbVwiXG4gICAgfSxcbiAgICBvbDogXCJlZGl0b3ItbGlzdC1vbFwiLFxuICAgIHVsOiBcImVkaXRvci1saXN0LXVsXCIsXG4gICAgbGlzdGl0ZW06IFwiZWRpdG9yLWxpc3RpdGVtXCJcbiAgfSxcbiAgaW1hZ2U6IFwiZWRpdG9yLWltYWdlXCIsXG4gIGxpbms6IFwiZWRpdG9yLWxpbmtcIixcbiAgdGV4dDoge1xuICAgIGJvbGQ6IFwiZWRpdG9yLXRleHQtYm9sZFwiLFxuICAgIGl0YWxpYzogXCJlZGl0b3ItdGV4dC1pdGFsaWNcIixcbiAgICBvdmVyZmxvd2VkOiBcImVkaXRvci10ZXh0LW92ZXJmbG93ZWRcIixcbiAgICBoYXNodGFnOiBcImVkaXRvci10ZXh0LWhhc2h0YWdcIixcbiAgICB1bmRlcmxpbmU6IFwiZWRpdG9yLXRleHQtdW5kZXJsaW5lXCIsXG4gICAgc3RyaWtldGhyb3VnaDogXCJlZGl0b3ItdGV4dC1zdHJpa2V0aHJvdWdoXCIsXG4gICAgdW5kZXJsaW5lU3RyaWtldGhyb3VnaDogXCJlZGl0b3ItdGV4dC11bmRlcmxpbmVTdHJpa2V0aHJvdWdoXCIsXG4gICAgY29kZTogXCJlZGl0b3ItdGV4dC1jb2RlXCJcbiAgfSxcbiAgY29kZTogXCJlZGl0b3ItY29kZVwiLFxuICBjb2RlSGlnaGxpZ2h0OiB7XG4gICAgYXRydWxlOiBcImVkaXRvci10b2tlbkF0dHJcIixcbiAgICBhdHRyOiBcImVkaXRvci10b2tlbkF0dHJcIixcbiAgICBib29sZWFuOiBcImVkaXRvci10b2tlblByb3BlcnR5XCIsXG4gICAgYnVpbHRpbjogXCJlZGl0b3ItdG9rZW5TZWxlY3RvclwiLFxuICAgIGNkYXRhOiBcImVkaXRvci10b2tlbkNvbW1lbnRcIixcbiAgICBjaGFyOiBcImVkaXRvci10b2tlblNlbGVjdG9yXCIsXG4gICAgY2xhc3M6IFwiZWRpdG9yLXRva2VuRnVuY3Rpb25cIixcbiAgICBcImNsYXNzLW5hbWVcIjogXCJlZGl0b3ItdG9rZW5GdW5jdGlvblwiLFxuICAgIGNvbW1lbnQ6IFwiZWRpdG9yLXRva2VuQ29tbWVudFwiLFxuICAgIGNvbnN0YW50OiBcImVkaXRvci10b2tlblByb3BlcnR5XCIsXG4gICAgZGVsZXRlZDogXCJlZGl0b3ItdG9rZW5Qcm9wZXJ0eVwiLFxuICAgIGRvY3R5cGU6IFwiZWRpdG9yLXRva2VuQ29tbWVudFwiLFxuICAgIGVudGl0eTogXCJlZGl0b3ItdG9rZW5PcGVyYXRvclwiLFxuICAgIGZ1bmN0aW9uOiBcImVkaXRvci10b2tlbkZ1bmN0aW9uXCIsXG4gICAgaW1wb3J0YW50OiBcImVkaXRvci10b2tlblZhcmlhYmxlXCIsXG4gICAgaW5zZXJ0ZWQ6IFwiZWRpdG9yLXRva2VuU2VsZWN0b3JcIixcbiAgICBrZXl3b3JkOiBcImVkaXRvci10b2tlbkF0dHJcIixcbiAgICBuYW1lc3BhY2U6IFwiZWRpdG9yLXRva2VuVmFyaWFibGVcIixcbiAgICBudW1iZXI6IFwiZWRpdG9yLXRva2VuUHJvcGVydHlcIixcbiAgICBvcGVyYXRvcjogXCJlZGl0b3ItdG9rZW5PcGVyYXRvclwiLFxuICAgIHByb2xvZzogXCJlZGl0b3ItdG9rZW5Db21tZW50XCIsXG4gICAgcHJvcGVydHk6IFwiZWRpdG9yLXRva2VuUHJvcGVydHlcIixcbiAgICBwdW5jdHVhdGlvbjogXCJlZGl0b3ItdG9rZW5QdW5jdHVhdGlvblwiLFxuICAgIHJlZ2V4OiBcImVkaXRvci10b2tlblZhcmlhYmxlXCIsXG4gICAgc2VsZWN0b3I6IFwiZWRpdG9yLXRva2VuU2VsZWN0b3JcIixcbiAgICBzdHJpbmc6IFwiZWRpdG9yLXRva2VuU2VsZWN0b3JcIixcbiAgICBzeW1ib2w6IFwiZWRpdG9yLXRva2VuUHJvcGVydHlcIixcbiAgICB0YWc6IFwiZWRpdG9yLXRva2VuUHJvcGVydHlcIixcbiAgICB1cmw6IFwiZWRpdG9yLXRva2VuT3BlcmF0b3JcIixcbiAgICB2YXJpYWJsZTogXCJlZGl0b3ItdG9rZW5WYXJpYWJsZVwiXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHRoZW1lO1xuIl0sIm5hbWVzIjpbInRoZW1lIiwibHRyIiwicnRsIiwicGxhY2Vob2xkZXIiLCJwYXJhZ3JhcGgiLCJxdW90ZSIsImhlYWRpbmciLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwibGlzdCIsIm5lc3RlZCIsImxpc3RpdGVtIiwib2wiLCJ1bCIsImltYWdlIiwibGluayIsInRleHQiLCJib2xkIiwiaXRhbGljIiwib3ZlcmZsb3dlZCIsImhhc2h0YWciLCJ1bmRlcmxpbmUiLCJzdHJpa2V0aHJvdWdoIiwidW5kZXJsaW5lU3RyaWtldGhyb3VnaCIsImNvZGUiLCJjb2RlSGlnaGxpZ2h0IiwiYXRydWxlIiwiYXR0ciIsImJvb2xlYW4iLCJidWlsdGluIiwiY2RhdGEiLCJjaGFyIiwiY2xhc3MiLCJjb21tZW50IiwiY29uc3RhbnQiLCJkZWxldGVkIiwiZG9jdHlwZSIsImVudGl0eSIsImZ1bmN0aW9uIiwiaW1wb3J0YW50IiwiaW5zZXJ0ZWQiLCJrZXl3b3JkIiwibmFtZXNwYWNlIiwibnVtYmVyIiwib3BlcmF0b3IiLCJwcm9sb2ciLCJwcm9wZXJ0eSIsInB1bmN0dWF0aW9uIiwicmVnZXgiLCJzZWxlY3RvciIsInN0cmluZyIsInN5bWJvbCIsInRhZyIsInVybCIsInZhcmlhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/Theme.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/hooks/useMediaQuery.js":
/*!*******************************************************!*\
  !*** ./src/components/Lexical/hooks/useMediaQuery.js ***!
  \*******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar _s = $RefreshSig$();\n\nconst useMediaQuery = (query)=>{\n    _s();\n    const [matches, setMatches] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const mediaMatch = window.matchMedia(query);\n        if (matches === null) {\n            setMatches(mediaMatch.matches);\n        }\n        const handler = (e)=>setMatches(e.matches);\n        mediaMatch.addEventListener(\"change\", handler);\n        return ()=>mediaMatch.removeEventListener(\"change\", handler);\n    }, [\n        setMatches,\n        matches,\n        query\n    ]);\n    return matches;\n};\n_s(useMediaQuery, \"XLhjjl1cEJzh8gqdx7jwSpJmF/k=\");\n/* harmony default export */ __webpack_exports__[\"default\"] = (useMediaQuery);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvaG9va3MvdXNlTWVkaWFRdWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQTJDO0FBRTNDLE1BQU1FLGdCQUFnQixDQUFDQzs7SUFDckIsTUFBTSxDQUFDQyxTQUFTQyxXQUFXLEdBQUdKLCtDQUFRQSxDQUFDO0lBQ3ZDRCxnREFBU0EsQ0FBQztRQUNSLE1BQU1NLGFBQWFDLE9BQU9DLFVBQVUsQ0FBQ0w7UUFDckMsSUFBSUMsWUFBWSxNQUFNO1lBQ3BCQyxXQUFXQyxXQUFXRixPQUFPO1FBQy9CO1FBQ0EsTUFBTUssVUFBVSxDQUFDQyxJQUFNTCxXQUFXSyxFQUFFTixPQUFPO1FBQzNDRSxXQUFXSyxnQkFBZ0IsQ0FBQyxVQUFVRjtRQUN0QyxPQUFPLElBQU1ILFdBQVdNLG1CQUFtQixDQUFDLFVBQVVIO0lBQ3hELEdBQUc7UUFBQ0o7UUFBWUQ7UUFBU0Q7S0FBTTtJQUUvQixPQUFPQztBQUNUO0dBYk1GO0FBZU4sK0RBQWVBLGFBQWFBLEVBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTGV4aWNhbC9ob29rcy91c2VNZWRpYVF1ZXJ5LmpzP2FkNGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuXG5jb25zdCB1c2VNZWRpYVF1ZXJ5ID0gKHF1ZXJ5KSA9PiB7XG4gIGNvbnN0IFttYXRjaGVzLCBzZXRNYXRjaGVzXSA9IHVzZVN0YXRlKG51bGwpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbWVkaWFNYXRjaCA9IHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5KVxuICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICBzZXRNYXRjaGVzKG1lZGlhTWF0Y2gubWF0Y2hlcylcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlciA9IChlKSA9PiBzZXRNYXRjaGVzKGUubWF0Y2hlcylcbiAgICBtZWRpYU1hdGNoLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZXIpXG4gICAgcmV0dXJuICgpID0+IG1lZGlhTWF0Y2gucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlcilcbiAgfSwgW3NldE1hdGNoZXMsIG1hdGNoZXMsIHF1ZXJ5XSlcblxuICByZXR1cm4gbWF0Y2hlc1xufVxuXG5leHBvcnQgZGVmYXVsdCB1c2VNZWRpYVF1ZXJ5Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlTWVkaWFRdWVyeSIsInF1ZXJ5IiwibWF0Y2hlcyIsInNldE1hdGNoZXMiLCJtZWRpYU1hdGNoIiwid2luZG93IiwibWF0Y2hNZWRpYSIsImhhbmRsZXIiLCJlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/hooks/useMediaQuery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/nodes/InlineImageNode.jsx":
/*!**********************************************************!*\
  !*** ./src/components/Lexical/nodes/InlineImageNode.jsx ***!
  \**********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createInlineImageNode: function() { return /* binding */ $createInlineImageNode; },\n/* harmony export */   $isInlineImageNode: function() { return /* binding */ $isInlineImageNode; },\n/* harmony export */   InlineImageNode: function() { return /* binding */ InlineImageNode; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lexical__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* eslint-disable @typescript-eslint/ban-ts-comment */ /**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ \n\n\n\nconst InlineImageComponent = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.lazy(// @ts-ignore\n()=>__webpack_require__.e(/*! import() */ \"_app-pages-browser_src_components_Lexical_nodes_InlineImageComponent_jsx\").then(__webpack_require__.bind(__webpack_require__, /*! ./InlineImageComponent */ \"(app-pages-browser)/./src/components/Lexical/nodes/InlineImageComponent.jsx\")));\n_c = InlineImageComponent;\nfunction convertInlineImageElement(domNode) {\n    if (domNode instanceof HTMLImageElement) {\n        const { alt: altText, src, width, height } = domNode;\n        const node = $createInlineImageNode({\n            altText,\n            height,\n            src,\n            width\n        });\n        return {\n            node\n        };\n    }\n    return null;\n}\nclass InlineImageNode extends lexical__WEBPACK_IMPORTED_MODULE_1__.DecoratorNode {\n    static getType() {\n        return \"inline-image\";\n    }\n    static clone(node) {\n        return new InlineImageNode(node.__src, node.__altText, node.__position, node.__width, node.__height, node.__showCaption, node.__caption, node.__key);\n    }\n    static importJSON(serializedNode) {\n        const { altText, height, width, caption, src, showCaption, position } = serializedNode;\n        const node = $createInlineImageNode({\n            altText,\n            height,\n            showCaption,\n            src,\n            width,\n            position\n        });\n        const nestedEditor = node.__caption;\n        const editorState = nestedEditor.parseEditorState(caption.editorState);\n        if (!editorState.isEmpty()) {\n            nestedEditor.setEditorState(editorState);\n        }\n        return node;\n    }\n    static importDOM() {\n        return {\n            img: (node)=>({\n                    conversion: convertInlineImageElement,\n                    priority: 0\n                })\n        };\n    }\n    exportDOM() {\n        const element = document.createElement(\"img\");\n        element.setAttribute(\"src\", this.__src);\n        element.setAttribute(\"alt\", this.__altText);\n        element.setAttribute(\"width\", this.__width.toString());\n        element.setAttribute(\"height\", this.__height.toString());\n        return {\n            element\n        };\n    }\n    exportJSON() {\n        return {\n            altText: this.getAltText(),\n            caption: this.__caption.toJSON(),\n            height: this.__height === \"inherit\" ? 0 : this.__height,\n            showCaption: this.__showCaption,\n            src: this.getSrc(),\n            type: \"inline-image\",\n            version: 1,\n            width: this.__width === \"inherit\" ? 0 : this.__width,\n            position: this.__position\n        };\n    }\n    getSrc() {\n        return this.__src;\n    }\n    getAltText() {\n        return this.__altText;\n    }\n    setAltText(altText) {\n        const writable = this.getWritable();\n        writable.__altText = altText;\n    }\n    setWidthAndHeight(width, height) {\n        const writable = this.getWritable();\n        writable.__width = width;\n        writable.__height = height;\n    }\n    getShowCaption() {\n        return this.__showCaption;\n    }\n    setShowCaption(showCaption) {\n        const writable = this.getWritable();\n        writable.__showCaption = showCaption;\n    }\n    getPosition() {\n        return this.__position;\n    }\n    setPosition(position) {\n        const writable = this.getWritable();\n        writable.__position = position;\n    }\n    update(payload) {\n        const writable = this.getWritable();\n        const { altText, showCaption, position } = payload;\n        if (altText !== undefined) {\n            writable.__altText = altText;\n        }\n        if (showCaption !== undefined) {\n            writable.__showCaption = showCaption;\n        }\n        if (position !== undefined) {\n            writable.__position = position;\n        }\n    }\n    // View\n    createDOM(config) {\n        const span = document.createElement(\"span\");\n        const theme = config.theme;\n        const className = \"\".concat(theme.image, \" position-\").concat(this.__position);\n        if (className !== undefined) {\n            span.className = className;\n        }\n        return span;\n    }\n    updateDOM(prevNode, dom, config) {\n        const position = this.__position;\n        if (position !== prevNode.__position) {\n            const className = \"\".concat(config.theme.image, \" position-\").concat(position);\n            if (className !== undefined) {\n                dom.className = className;\n            }\n        }\n        return false;\n    }\n    decorate() {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react__WEBPACK_IMPORTED_MODULE_2__.Suspense, {\n            fallback: null,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(InlineImageComponent, {\n                src: this.__src,\n                altText: this.__altText,\n                width: this.__width,\n                height: this.__height,\n                nodeKey: this.getKey(),\n                showCaption: this.__showCaption,\n                caption: this.__caption,\n                position: this.__position\n            }, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/nodes/InlineImageNode.jsx\",\n                lineNumber: 194,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/nodes/InlineImageNode.jsx\",\n            lineNumber: 193,\n            columnNumber: 7\n        }, this);\n    }\n    constructor(src, altText, position, width = \"inherit\", height = \"inherit\", showCaption = false, caption = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.createEditor)(), key){\n        super(key);\n        this.__src = src;\n        this.__altText = altText;\n        this.__width = width;\n        this.__height = height;\n        this.__showCaption = showCaption;\n        this.__caption = caption;\n        this.__position = position;\n    }\n}\nfunction $createInlineImageNode(param) {\n    let { altText, position, height, src, width, showCaption, caption, key } = param;\n    return (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$applyNodeReplacement)(new InlineImageNode(src, altText, position, width, height, showCaption, caption, key));\n}\nfunction $isInlineImageNode(node) {\n    return node instanceof InlineImageNode;\n}\nvar _c;\n$RefreshReg$(_c, \"InlineImageComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvbm9kZXMvSW5saW5lSW1hZ2VOb2RlLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLG9EQUFvRCxHQUVwRDs7Ozs7O0NBTUM7QUFFNEU7QUFDOUM7QUFDRTtBQUVqQyxNQUFNSyxxQ0FBdUJGLHVDQUFVLENBQ3JDLGFBQWE7QUFDYixJQUFNLGtSQUFPO0tBRlRFO0FBS04sU0FBU0UsMEJBQTBCQyxPQUFPO0lBQ3hDLElBQUlBLG1CQUFtQkMsa0JBQWtCO1FBQ3ZDLE1BQU0sRUFBRUMsS0FBS0MsT0FBTyxFQUFFQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdOO1FBQzdDLE1BQU1PLE9BQU9DLHVCQUF1QjtZQUFFTDtZQUFTRztZQUFRRjtZQUFLQztRQUFNO1FBQ2xFLE9BQU87WUFBRUU7UUFBSztJQUNoQjtJQUNBLE9BQU87QUFDVDtBQUVPLE1BQU1FLHdCQUF3QmYsa0RBQWFBO0lBcUJoRCxPQUFPZ0IsVUFBVTtRQUNmLE9BQU87SUFDVDtJQUVBLE9BQU9DLE1BQU1KLElBQUksRUFBRTtRQUNqQixPQUFPLElBQUlFLGdCQUNURixLQUFLSyxLQUFLLEVBQ1ZMLEtBQUtNLFNBQVMsRUFDZE4sS0FBS08sVUFBVSxFQUNmUCxLQUFLUSxPQUFPLEVBQ1pSLEtBQUtTLFFBQVEsRUFDYlQsS0FBS1UsYUFBYSxFQUNsQlYsS0FBS1csU0FBUyxFQUNkWCxLQUFLWSxLQUFLO0lBRWQ7SUFFQSxPQUFPQyxXQUFXQyxjQUFjLEVBQUU7UUFDaEMsTUFBTSxFQUFFbEIsT0FBTyxFQUFFRyxNQUFNLEVBQUVELEtBQUssRUFBRWlCLE9BQU8sRUFBRWxCLEdBQUcsRUFBRW1CLFdBQVcsRUFBRUMsUUFBUSxFQUFFLEdBQ25FSDtRQUNGLE1BQU1kLE9BQU9DLHVCQUF1QjtZQUNsQ0w7WUFDQUc7WUFDQWlCO1lBQ0FuQjtZQUNBQztZQUNBbUI7UUFDRjtRQUNBLE1BQU1DLGVBQWVsQixLQUFLVyxTQUFTO1FBQ25DLE1BQU1RLGNBQWNELGFBQWFFLGdCQUFnQixDQUFDTCxRQUFRSSxXQUFXO1FBQ3JFLElBQUksQ0FBQ0EsWUFBWUUsT0FBTyxJQUFJO1lBQzFCSCxhQUFhSSxjQUFjLENBQUNIO1FBQzlCO1FBQ0EsT0FBT25CO0lBQ1Q7SUFFQSxPQUFPdUIsWUFBWTtRQUNqQixPQUFPO1lBQ0xDLEtBQUssQ0FBQ3hCLE9BQVU7b0JBQ2R5QixZQUFZakM7b0JBQ1prQyxVQUFVO2dCQUNaO1FBQ0Y7SUFDRjtJQUVBQyxZQUFZO1FBQ1YsTUFBTUMsVUFBVUMsU0FBU0MsYUFBYSxDQUFDO1FBQ3ZDRixRQUFRRyxZQUFZLENBQUMsT0FBTyxJQUFJLENBQUMxQixLQUFLO1FBQ3RDdUIsUUFBUUcsWUFBWSxDQUFDLE9BQU8sSUFBSSxDQUFDekIsU0FBUztRQUMxQ3NCLFFBQVFHLFlBQVksQ0FBQyxTQUFTLElBQUksQ0FBQ3ZCLE9BQU8sQ0FBQ3dCLFFBQVE7UUFDbkRKLFFBQVFHLFlBQVksQ0FBQyxVQUFVLElBQUksQ0FBQ3RCLFFBQVEsQ0FBQ3VCLFFBQVE7UUFDckQsT0FBTztZQUFFSjtRQUFRO0lBQ25CO0lBRUFLLGFBQWE7UUFDWCxPQUFPO1lBQ0xyQyxTQUFTLElBQUksQ0FBQ3NDLFVBQVU7WUFDeEJuQixTQUFTLElBQUksQ0FBQ0osU0FBUyxDQUFDd0IsTUFBTTtZQUM5QnBDLFFBQVEsSUFBSSxDQUFDVSxRQUFRLEtBQUssWUFBWSxJQUFJLElBQUksQ0FBQ0EsUUFBUTtZQUN2RE8sYUFBYSxJQUFJLENBQUNOLGFBQWE7WUFDL0JiLEtBQUssSUFBSSxDQUFDdUMsTUFBTTtZQUNoQkMsTUFBTTtZQUNOQyxTQUFTO1lBQ1R4QyxPQUFPLElBQUksQ0FBQ1UsT0FBTyxLQUFLLFlBQVksSUFBSSxJQUFJLENBQUNBLE9BQU87WUFDcERTLFVBQVUsSUFBSSxDQUFDVixVQUFVO1FBQzNCO0lBQ0Y7SUFFQTZCLFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQy9CLEtBQUs7SUFDbkI7SUFFQTZCLGFBQWE7UUFDWCxPQUFPLElBQUksQ0FBQzVCLFNBQVM7SUFDdkI7SUFFQWlDLFdBQVczQyxPQUFPLEVBQUU7UUFDbEIsTUFBTTRDLFdBQVcsSUFBSSxDQUFDQyxXQUFXO1FBQ2pDRCxTQUFTbEMsU0FBUyxHQUFHVjtJQUN2QjtJQUVBOEMsa0JBQWtCNUMsS0FBSyxFQUFFQyxNQUFNLEVBQUU7UUFDL0IsTUFBTXlDLFdBQVcsSUFBSSxDQUFDQyxXQUFXO1FBQ2pDRCxTQUFTaEMsT0FBTyxHQUFHVjtRQUNuQjBDLFNBQVMvQixRQUFRLEdBQUdWO0lBQ3RCO0lBRUE0QyxpQkFBaUI7UUFDZixPQUFPLElBQUksQ0FBQ2pDLGFBQWE7SUFDM0I7SUFFQWtDLGVBQWU1QixXQUFXLEVBQUU7UUFDMUIsTUFBTXdCLFdBQVcsSUFBSSxDQUFDQyxXQUFXO1FBQ2pDRCxTQUFTOUIsYUFBYSxHQUFHTTtJQUMzQjtJQUVBNkIsY0FBYztRQUNaLE9BQU8sSUFBSSxDQUFDdEMsVUFBVTtJQUN4QjtJQUVBdUMsWUFBWTdCLFFBQVEsRUFBRTtRQUNwQixNQUFNdUIsV0FBVyxJQUFJLENBQUNDLFdBQVc7UUFDakNELFNBQVNqQyxVQUFVLEdBQUdVO0lBQ3hCO0lBRUE4QixPQUFPQyxPQUFPLEVBQUU7UUFDZCxNQUFNUixXQUFXLElBQUksQ0FBQ0MsV0FBVztRQUNqQyxNQUFNLEVBQUU3QyxPQUFPLEVBQUVvQixXQUFXLEVBQUVDLFFBQVEsRUFBRSxHQUFHK0I7UUFDM0MsSUFBSXBELFlBQVlxRCxXQUFXO1lBQ3pCVCxTQUFTbEMsU0FBUyxHQUFHVjtRQUN2QjtRQUNBLElBQUlvQixnQkFBZ0JpQyxXQUFXO1lBQzdCVCxTQUFTOUIsYUFBYSxHQUFHTTtRQUMzQjtRQUNBLElBQUlDLGFBQWFnQyxXQUFXO1lBQzFCVCxTQUFTakMsVUFBVSxHQUFHVTtRQUN4QjtJQUNGO0lBRUEsT0FBTztJQUNQaUMsVUFBVUMsTUFBTSxFQUFFO1FBQ2hCLE1BQU1DLE9BQU92QixTQUFTQyxhQUFhLENBQUM7UUFDcEMsTUFBTXVCLFFBQVFGLE9BQU9FLEtBQUs7UUFDMUIsTUFBTUMsWUFBWSxHQUEyQixPQUF4QkQsTUFBTUUsS0FBSyxFQUFDLGNBQTRCLE9BQWhCLElBQUksQ0FBQ2hELFVBQVU7UUFDNUQsSUFBSStDLGNBQWNMLFdBQVc7WUFDM0JHLEtBQUtFLFNBQVMsR0FBR0E7UUFDbkI7UUFDQSxPQUFPRjtJQUNUO0lBRUFJLFVBQVVDLFFBQVEsRUFBRUMsR0FBRyxFQUFFUCxNQUFNLEVBQUU7UUFDL0IsTUFBTWxDLFdBQVcsSUFBSSxDQUFDVixVQUFVO1FBQ2hDLElBQUlVLGFBQWF3QyxTQUFTbEQsVUFBVSxFQUFFO1lBQ3BDLE1BQU0rQyxZQUFZLEdBQWtDckMsT0FBL0JrQyxPQUFPRSxLQUFLLENBQUNFLEtBQUssRUFBQyxjQUFxQixPQUFUdEM7WUFDcEQsSUFBSXFDLGNBQWNMLFdBQVc7Z0JBQzNCUyxJQUFJSixTQUFTLEdBQUdBO1lBQ2xCO1FBQ0Y7UUFDQSxPQUFPO0lBQ1Q7SUFFQUssV0FBVztRQUNULHFCQUNFLDhEQUFDdEUsMkNBQVFBO1lBQUN1RSxVQUFVO3NCQUNsQiw0RUFBQ3RFO2dCQUNDTyxLQUFLLElBQUksQ0FBQ1EsS0FBSztnQkFDZlQsU0FBUyxJQUFJLENBQUNVLFNBQVM7Z0JBQ3ZCUixPQUFPLElBQUksQ0FBQ1UsT0FBTztnQkFDbkJULFFBQVEsSUFBSSxDQUFDVSxRQUFRO2dCQUNyQm9ELFNBQVMsSUFBSSxDQUFDQyxNQUFNO2dCQUNwQjlDLGFBQWEsSUFBSSxDQUFDTixhQUFhO2dCQUMvQkssU0FBUyxJQUFJLENBQUNKLFNBQVM7Z0JBQ3ZCTSxVQUFVLElBQUksQ0FBQ1YsVUFBVTs7Ozs7Ozs7Ozs7SUFJakM7SUFoTEF3RCxZQUNFbEUsR0FBRyxFQUNIRCxPQUFPLEVBQ1BxQixRQUFRLEVBQ1JuQixRQUFRLFNBQVMsRUFDakJDLFNBQVMsU0FBUyxFQUNsQmlCLGNBQWMsS0FBSyxFQUNuQkQsVUFBVTdCLHFEQUFZQSxFQUFFLEVBQ3hCOEUsR0FBRyxDQUNIO1FBQ0EsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQzNELEtBQUssR0FBR1I7UUFDYixJQUFJLENBQUNTLFNBQVMsR0FBR1Y7UUFDakIsSUFBSSxDQUFDWSxPQUFPLEdBQUdWO1FBQ2YsSUFBSSxDQUFDVyxRQUFRLEdBQUdWO1FBQ2hCLElBQUksQ0FBQ1csYUFBYSxHQUFHTTtRQUNyQixJQUFJLENBQUNMLFNBQVMsR0FBR0k7UUFDakIsSUFBSSxDQUFDUixVQUFVLEdBQUdVO0lBQ3BCO0FBK0pGO0FBRU8sU0FBU2hCLHVCQUF1QixLQVN0QztRQVRzQyxFQUNyQ0wsT0FBTyxFQUNQcUIsUUFBUSxFQUNSbEIsTUFBTSxFQUNORixHQUFHLEVBQ0hDLEtBQUssRUFDTGtCLFdBQVcsRUFDWEQsT0FBTyxFQUNQaUQsR0FBRyxFQUNKLEdBVHNDO0lBVXJDLE9BQU8vRSw4REFBcUJBLENBQzFCLElBQUlpQixnQkFDRkwsS0FDQUQsU0FDQXFCLFVBQ0FuQixPQUNBQyxRQUNBaUIsYUFDQUQsU0FDQWlEO0FBR047QUFFTyxTQUFTQyxtQkFBbUJqRSxJQUFJO0lBQ3JDLE9BQU9BLGdCQUFnQkU7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTGV4aWNhbC9ub2Rlcy9JbmxpbmVJbWFnZU5vZGUuanN4PzUxOWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50ICovXG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCBjcmVhdGVFZGl0b3IsIERlY29yYXRvck5vZGUgfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFN1c3BlbnNlIH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCBJbmxpbmVJbWFnZUNvbXBvbmVudCA9IFJlYWN0LmxhenkoXG4gIC8vIEB0cy1pZ25vcmVcbiAgKCkgPT4gaW1wb3J0KCcuL0lubGluZUltYWdlQ29tcG9uZW50JyksXG4pO1xuXG5mdW5jdGlvbiBjb252ZXJ0SW5saW5lSW1hZ2VFbGVtZW50KGRvbU5vZGUpIHtcbiAgaWYgKGRvbU5vZGUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG4gICAgY29uc3QgeyBhbHQ6IGFsdFRleHQsIHNyYywgd2lkdGgsIGhlaWdodCB9ID0gZG9tTm9kZTtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZUlubGluZUltYWdlTm9kZSh7IGFsdFRleHQsIGhlaWdodCwgc3JjLCB3aWR0aCB9KTtcbiAgICByZXR1cm4geyBub2RlIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBjbGFzcyBJbmxpbmVJbWFnZU5vZGUgZXh0ZW5kcyBEZWNvcmF0b3JOb2RlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgc3JjLFxuICAgIGFsdFRleHQsXG4gICAgcG9zaXRpb24sXG4gICAgd2lkdGggPSAnaW5oZXJpdCcsXG4gICAgaGVpZ2h0ID0gJ2luaGVyaXQnLFxuICAgIHNob3dDYXB0aW9uID0gZmFsc2UsXG4gICAgY2FwdGlvbiA9IGNyZWF0ZUVkaXRvcigpLFxuICAgIGtleSxcbiAgKSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fc3JjID0gc3JjO1xuICAgIHRoaXMuX19hbHRUZXh0ID0gYWx0VGV4dDtcbiAgICB0aGlzLl9fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX19zaG93Q2FwdGlvbiA9IHNob3dDYXB0aW9uO1xuICAgIHRoaXMuX19jYXB0aW9uID0gY2FwdGlvbjtcbiAgICB0aGlzLl9fcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgfVxuXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnaW5saW5lLWltYWdlJztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBJbmxpbmVJbWFnZU5vZGUoXG4gICAgICBub2RlLl9fc3JjLFxuICAgICAgbm9kZS5fX2FsdFRleHQsXG4gICAgICBub2RlLl9fcG9zaXRpb24sXG4gICAgICBub2RlLl9fd2lkdGgsXG4gICAgICBub2RlLl9faGVpZ2h0LFxuICAgICAgbm9kZS5fX3Nob3dDYXB0aW9uLFxuICAgICAgbm9kZS5fX2NhcHRpb24sXG4gICAgICBub2RlLl9fa2V5LFxuICAgICk7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IHsgYWx0VGV4dCwgaGVpZ2h0LCB3aWR0aCwgY2FwdGlvbiwgc3JjLCBzaG93Q2FwdGlvbiwgcG9zaXRpb24gfSA9XG4gICAgICBzZXJpYWxpemVkTm9kZTtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZUlubGluZUltYWdlTm9kZSh7XG4gICAgICBhbHRUZXh0LFxuICAgICAgaGVpZ2h0LFxuICAgICAgc2hvd0NhcHRpb24sXG4gICAgICBzcmMsXG4gICAgICB3aWR0aCxcbiAgICAgIHBvc2l0aW9uLFxuICAgIH0pO1xuICAgIGNvbnN0IG5lc3RlZEVkaXRvciA9IG5vZGUuX19jYXB0aW9uO1xuICAgIGNvbnN0IGVkaXRvclN0YXRlID0gbmVzdGVkRWRpdG9yLnBhcnNlRWRpdG9yU3RhdGUoY2FwdGlvbi5lZGl0b3JTdGF0ZSk7XG4gICAgaWYgKCFlZGl0b3JTdGF0ZS5pc0VtcHR5KCkpIHtcbiAgICAgIG5lc3RlZEVkaXRvci5zZXRFZGl0b3JTdGF0ZShlZGl0b3JTdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW1nOiAobm9kZSkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydElubGluZUltYWdlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICB9KSxcbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0RE9NKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3JjJywgdGhpcy5fX3NyYyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FsdCcsIHRoaXMuX19hbHRUZXh0KTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLl9fd2lkdGgudG9TdHJpbmcoKSk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuX19oZWlnaHQudG9TdHJpbmcoKSk7XG4gICAgcmV0dXJuIHsgZWxlbWVudCB9O1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWx0VGV4dDogdGhpcy5nZXRBbHRUZXh0KCksXG4gICAgICBjYXB0aW9uOiB0aGlzLl9fY2FwdGlvbi50b0pTT04oKSxcbiAgICAgIGhlaWdodDogdGhpcy5fX2hlaWdodCA9PT0gJ2luaGVyaXQnID8gMCA6IHRoaXMuX19oZWlnaHQsXG4gICAgICBzaG93Q2FwdGlvbjogdGhpcy5fX3Nob3dDYXB0aW9uLFxuICAgICAgc3JjOiB0aGlzLmdldFNyYygpLFxuICAgICAgdHlwZTogJ2lubGluZS1pbWFnZScsXG4gICAgICB2ZXJzaW9uOiAxLFxuICAgICAgd2lkdGg6IHRoaXMuX193aWR0aCA9PT0gJ2luaGVyaXQnID8gMCA6IHRoaXMuX193aWR0aCxcbiAgICAgIHBvc2l0aW9uOiB0aGlzLl9fcG9zaXRpb24sXG4gICAgfTtcbiAgfVxuXG4gIGdldFNyYygpIHtcbiAgICByZXR1cm4gdGhpcy5fX3NyYztcbiAgfVxuXG4gIGdldEFsdFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19hbHRUZXh0O1xuICB9XG5cbiAgc2V0QWx0VGV4dChhbHRUZXh0KSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX19hbHRUZXh0ID0gYWx0VGV4dDtcbiAgfVxuXG4gIHNldFdpZHRoQW5kSGVpZ2h0KHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB3cml0YWJsZSA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICB3cml0YWJsZS5fX3dpZHRoID0gd2lkdGg7XG4gICAgd3JpdGFibGUuX19oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICBnZXRTaG93Q2FwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX3Nob3dDYXB0aW9uO1xuICB9XG5cbiAgc2V0U2hvd0NhcHRpb24oc2hvd0NhcHRpb24pIHtcbiAgICBjb25zdCB3cml0YWJsZSA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICB3cml0YWJsZS5fX3Nob3dDYXB0aW9uID0gc2hvd0NhcHRpb247XG4gIH1cblxuICBnZXRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uO1xuICB9XG5cbiAgc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICBjb25zdCB3cml0YWJsZSA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICB3cml0YWJsZS5fX3Bvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cblxuICB1cGRhdGUocGF5bG9hZCkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHsgYWx0VGV4dCwgc2hvd0NhcHRpb24sIHBvc2l0aW9uIH0gPSBwYXlsb2FkO1xuICAgIGlmIChhbHRUZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdyaXRhYmxlLl9fYWx0VGV4dCA9IGFsdFRleHQ7XG4gICAgfVxuICAgIGlmIChzaG93Q2FwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3cml0YWJsZS5fX3Nob3dDYXB0aW9uID0gc2hvd0NhcHRpb247XG4gICAgfVxuICAgIGlmIChwb3NpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3cml0YWJsZS5fX3Bvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgLy8gVmlld1xuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBjb25zdCB0aGVtZSA9IGNvbmZpZy50aGVtZTtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBgJHt0aGVtZS5pbWFnZX0gcG9zaXRpb24tJHt0aGlzLl9fcG9zaXRpb259YDtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNwYW4uY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gc3BhbjtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX19wb3NpdGlvbjtcbiAgICBpZiAocG9zaXRpb24gIT09IHByZXZOb2RlLl9fcG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGAke2NvbmZpZy50aGVtZS5pbWFnZX0gcG9zaXRpb24tJHtwb3NpdGlvbn1gO1xuICAgICAgaWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRvbS5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGRlY29yYXRlKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e251bGx9PlxuICAgICAgICA8SW5saW5lSW1hZ2VDb21wb25lbnRcbiAgICAgICAgICBzcmM9e3RoaXMuX19zcmN9XG4gICAgICAgICAgYWx0VGV4dD17dGhpcy5fX2FsdFRleHR9XG4gICAgICAgICAgd2lkdGg9e3RoaXMuX193aWR0aH1cbiAgICAgICAgICBoZWlnaHQ9e3RoaXMuX19oZWlnaHR9XG4gICAgICAgICAgbm9kZUtleT17dGhpcy5nZXRLZXkoKX1cbiAgICAgICAgICBzaG93Q2FwdGlvbj17dGhpcy5fX3Nob3dDYXB0aW9ufVxuICAgICAgICAgIGNhcHRpb249e3RoaXMuX19jYXB0aW9ufVxuICAgICAgICAgIHBvc2l0aW9uPXt0aGlzLl9fcG9zaXRpb259XG4gICAgICAgIC8+XG4gICAgICA8L1N1c3BlbnNlPlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uICRjcmVhdGVJbmxpbmVJbWFnZU5vZGUoe1xuICBhbHRUZXh0LFxuICBwb3NpdGlvbixcbiAgaGVpZ2h0LFxuICBzcmMsXG4gIHdpZHRoLFxuICBzaG93Q2FwdGlvbixcbiAgY2FwdGlvbixcbiAga2V5LFxufSkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KFxuICAgIG5ldyBJbmxpbmVJbWFnZU5vZGUoXG4gICAgICBzcmMsXG4gICAgICBhbHRUZXh0LFxuICAgICAgcG9zaXRpb24sXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHNob3dDYXB0aW9uLFxuICAgICAgY2FwdGlvbixcbiAgICAgIGtleSxcbiAgICApLFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gJGlzSW5saW5lSW1hZ2VOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBJbmxpbmVJbWFnZU5vZGU7XG59XG4iXSwibmFtZXMiOlsiJGFwcGx5Tm9kZVJlcGxhY2VtZW50IiwiY3JlYXRlRWRpdG9yIiwiRGVjb3JhdG9yTm9kZSIsIlJlYWN0IiwiU3VzcGVuc2UiLCJJbmxpbmVJbWFnZUNvbXBvbmVudCIsImxhenkiLCJjb252ZXJ0SW5saW5lSW1hZ2VFbGVtZW50IiwiZG9tTm9kZSIsIkhUTUxJbWFnZUVsZW1lbnQiLCJhbHQiLCJhbHRUZXh0Iiwic3JjIiwid2lkdGgiLCJoZWlnaHQiLCJub2RlIiwiJGNyZWF0ZUlubGluZUltYWdlTm9kZSIsIklubGluZUltYWdlTm9kZSIsImdldFR5cGUiLCJjbG9uZSIsIl9fc3JjIiwiX19hbHRUZXh0IiwiX19wb3NpdGlvbiIsIl9fd2lkdGgiLCJfX2hlaWdodCIsIl9fc2hvd0NhcHRpb24iLCJfX2NhcHRpb24iLCJfX2tleSIsImltcG9ydEpTT04iLCJzZXJpYWxpemVkTm9kZSIsImNhcHRpb24iLCJzaG93Q2FwdGlvbiIsInBvc2l0aW9uIiwibmVzdGVkRWRpdG9yIiwiZWRpdG9yU3RhdGUiLCJwYXJzZUVkaXRvclN0YXRlIiwiaXNFbXB0eSIsInNldEVkaXRvclN0YXRlIiwiaW1wb3J0RE9NIiwiaW1nIiwiY29udmVyc2lvbiIsInByaW9yaXR5IiwiZXhwb3J0RE9NIiwiZWxlbWVudCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsInRvU3RyaW5nIiwiZXhwb3J0SlNPTiIsImdldEFsdFRleHQiLCJ0b0pTT04iLCJnZXRTcmMiLCJ0eXBlIiwidmVyc2lvbiIsInNldEFsdFRleHQiLCJ3cml0YWJsZSIsImdldFdyaXRhYmxlIiwic2V0V2lkdGhBbmRIZWlnaHQiLCJnZXRTaG93Q2FwdGlvbiIsInNldFNob3dDYXB0aW9uIiwiZ2V0UG9zaXRpb24iLCJzZXRQb3NpdGlvbiIsInVwZGF0ZSIsInBheWxvYWQiLCJ1bmRlZmluZWQiLCJjcmVhdGVET00iLCJjb25maWciLCJzcGFuIiwidGhlbWUiLCJjbGFzc05hbWUiLCJpbWFnZSIsInVwZGF0ZURPTSIsInByZXZOb2RlIiwiZG9tIiwiZGVjb3JhdGUiLCJmYWxsYmFjayIsIm5vZGVLZXkiLCJnZXRLZXkiLCJjb25zdHJ1Y3RvciIsImtleSIsIiRpc0lubGluZUltYWdlTm9kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/nodes/InlineImageNode.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/plugins/DragDropPastPlugin.js":
/*!**************************************************************!*\
  !*** ./src/components/Lexical/plugins/DragDropPastPlugin.js ***!
  \**************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ DragDropPaste; }\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/rich-text */ \"(app-pages-browser)/./node_modules/@lexical/rich-text/LexicalRichText.js\");\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lexical_rich_text__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lexical_utils__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lexical__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _InlineImagePlugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./InlineImagePlugin */ \"(app-pages-browser)/./src/components/Lexical/plugins/InlineImagePlugin.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ var _s = $RefreshSig$();\n\n\n\n\n\n\nconst ACCEPTABLE_IMAGE_TYPES = [\n    \"image/\",\n    \"image/heic\",\n    \"image/heif\",\n    \"image/gif\",\n    \"image/webp\"\n];\nfunction DragDropPaste() {\n    _s();\n    const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_0__.useLexicalComposerContext)();\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        return editor.registerCommand(_lexical_rich_text__WEBPACK_IMPORTED_MODULE_1__.DRAG_DROP_PASTE, (files)=>{\n            (async ()=>{\n                const filesResult = await (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_2__.mediaFileReader)(files, [\n                    ACCEPTABLE_IMAGE_TYPES\n                ].flatMap((x)=>x));\n                for (const { file, result } of filesResult){\n                    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_2__.isMimeType)(file, ACCEPTABLE_IMAGE_TYPES)) {\n                        editor.dispatchCommand(_InlineImagePlugin__WEBPACK_IMPORTED_MODULE_5__.INSERT_INLINE_IMAGE_COMMAND, {\n                            altText: file.name,\n                            src: result\n                        });\n                    }\n                }\n            })();\n            return true;\n        }, lexical__WEBPACK_IMPORTED_MODULE_3__.COMMAND_PRIORITY_LOW);\n    }, [\n        editor\n    ]);\n    return null;\n}\n_s(DragDropPaste, \"mCqe7sh4aC9mLBXPHfG3d/PNTaQ=\", false, function() {\n    return [\n        _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_0__.useLexicalComposerContext\n    ];\n});\n_c = DragDropPaste;\nvar _c;\n$RefreshReg$(_c, \"DragDropPaste\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvcGx1Z2lucy9EcmFnRHJvcFBhc3RQbHVnaW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7OztDQU1DO0FBRWdGO0FBQzdCO0FBQ1E7QUFDZDtBQUNiO0FBRWdDO0FBRWpFLE1BQU1PLHlCQUF5QjtJQUM3QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFYyxTQUFTQzs7SUFDdEIsTUFBTSxDQUFDQyxPQUFPLEdBQUdULGdHQUF5QkE7SUFDMUNLLGdEQUFTQSxDQUFDO1FBQ1IsT0FBT0ksT0FBT0MsZUFBZSxDQUMzQlQsK0RBQWVBLEVBQ2YsQ0FBQ1U7WUFDRTtnQkFDQyxNQUFNQyxjQUFjLE1BQU1ULCtEQUFlQSxDQUN2Q1EsT0FDQTtvQkFBQ0o7aUJBQXVCLENBQUNNLE9BQU8sQ0FBQyxDQUFDQyxJQUFNQTtnQkFFMUMsS0FBSyxNQUFNLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFLElBQUlKLFlBQWE7b0JBQzFDLElBQUlWLDBEQUFVQSxDQUFDYSxNQUFNUix5QkFBeUI7d0JBQzVDRSxPQUFPUSxlQUFlLENBQUNYLDJFQUEyQkEsRUFBRTs0QkFDbERZLFNBQVNILEtBQUtJLElBQUk7NEJBQ2xCQyxLQUFLSjt3QkFDUDtvQkFDRjtnQkFDRjtZQUNGO1lBQ0EsT0FBTztRQUNULEdBQ0FaLHlEQUFvQkE7SUFFeEIsR0FBRztRQUFDSztLQUFPO0lBQ1gsT0FBTztBQUNUO0dBMUJ3QkQ7O1FBQ0xSLDRGQUF5QkE7OztLQURwQlEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTGV4aWNhbC9wbHVnaW5zL0RyYWdEcm9wUGFzdFBsdWdpbi5qcz9jNmFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnXG5pbXBvcnQgeyBEUkFHX0RST1BfUEFTVEUgfSBmcm9tICdAbGV4aWNhbC9yaWNoLXRleHQnXG5pbXBvcnQgeyBpc01pbWVUeXBlLCBtZWRpYUZpbGVSZWFkZXIgfSBmcm9tICdAbGV4aWNhbC91dGlscydcbmltcG9ydCB7IENPTU1BTkRfUFJJT1JJVFlfTE9XIH0gZnJvbSAnbGV4aWNhbCdcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyBJTlNFUlRfSU5MSU5FX0lNQUdFX0NPTU1BTkQgfSBmcm9tICcuL0lubGluZUltYWdlUGx1Z2luJ1xuXG5jb25zdCBBQ0NFUFRBQkxFX0lNQUdFX1RZUEVTID0gW1xuICAnaW1hZ2UvJyxcbiAgJ2ltYWdlL2hlaWMnLFxuICAnaW1hZ2UvaGVpZicsXG4gICdpbWFnZS9naWYnLFxuICAnaW1hZ2Uvd2VicCcsXG5dXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERyYWdEcm9wUGFzdGUoKSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoXG4gICAgICBEUkFHX0RST1BfUEFTVEUsXG4gICAgICAoZmlsZXMpID0+IHtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlc1Jlc3VsdCA9IGF3YWl0IG1lZGlhRmlsZVJlYWRlcihcbiAgICAgICAgICAgIGZpbGVzLFxuICAgICAgICAgICAgW0FDQ0VQVEFCTEVfSU1BR0VfVFlQRVNdLmZsYXRNYXAoKHgpID0+IHgpLFxuICAgICAgICAgIClcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgZmlsZSwgcmVzdWx0IH0gb2YgZmlsZXNSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChpc01pbWVUeXBlKGZpbGUsIEFDQ0VQVEFCTEVfSU1BR0VfVFlQRVMpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoSU5TRVJUX0lOTElORV9JTUFHRV9DT01NQU5ELCB7XG4gICAgICAgICAgICAgICAgYWx0VGV4dDogZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgIHNyYzogcmVzdWx0LFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSxcbiAgICAgIENPTU1BTkRfUFJJT1JJVFlfTE9XLFxuICAgIClcbiAgfSwgW2VkaXRvcl0pXG4gIHJldHVybiBudWxsXG59Il0sIm5hbWVzIjpbInVzZUxleGljYWxDb21wb3NlckNvbnRleHQiLCJEUkFHX0RST1BfUEFTVEUiLCJpc01pbWVUeXBlIiwibWVkaWFGaWxlUmVhZGVyIiwiQ09NTUFORF9QUklPUklUWV9MT1ciLCJ1c2VFZmZlY3QiLCJJTlNFUlRfSU5MSU5FX0lNQUdFX0NPTU1BTkQiLCJBQ0NFUFRBQkxFX0lNQUdFX1RZUEVTIiwiRHJhZ0Ryb3BQYXN0ZSIsImVkaXRvciIsInJlZ2lzdGVyQ29tbWFuZCIsImZpbGVzIiwiZmlsZXNSZXN1bHQiLCJmbGF0TWFwIiwieCIsImZpbGUiLCJyZXN1bHQiLCJkaXNwYXRjaENvbW1hbmQiLCJhbHRUZXh0IiwibmFtZSIsInNyYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/plugins/DragDropPastPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/plugins/FloatingLinkEditorPlugin.js":
/*!********************************************************************!*\
  !*** ./src/components/Lexical/plugins/FloatingLinkEditorPlugin.js ***!
  \********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ FloatingLinkEditorPlugin; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _floting_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./floting.css */ \"(app-pages-browser)/./src/components/Lexical/plugins/floting.css\");\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/link */ \"(app-pages-browser)/./node_modules/@lexical/link/LexicalLink.js\");\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lexical_link__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lexical_utils__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lexical__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _utils_getSelectedNode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/getSelectedNode */ \"(app-pages-browser)/./src/components/Lexical/utils/getSelectedNode.js\");\n/* harmony import */ var _utils_setFloatingElemPositionForLinkEditor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/setFloatingElemPositionForLinkEditor */ \"(app-pages-browser)/./src/components/Lexical/utils/setFloatingElemPositionForLinkEditor.js\");\n/* harmony import */ var _utils_url__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/url */ \"(app-pages-browser)/./src/components/Lexical/utils/url.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\nfunction FloatingLinkEditor(param) {\n    let { editor, isLink, setIsLink, anchorElem } = param;\n    _s();\n    const editorRef = (0,react__WEBPACK_IMPORTED_MODULE_6__.useRef)(null);\n    const inputRef = (0,react__WEBPACK_IMPORTED_MODULE_6__.useRef)(null);\n    const [linkUrl, setLinkUrl] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(\"\");\n    const [editedLinkUrl, setEditedLinkUrl] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(\"\");\n    const [isEditMode, setEditMode] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(false);\n    const [lastSelection, setLastSelection] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(null);\n    const updateLinkEditor = (0,react__WEBPACK_IMPORTED_MODULE_6__.useCallback)(()=>{\n        const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_5__.$getSelection)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_5__.$isRangeSelection)(selection)) {\n            const node = (0,_utils_getSelectedNode__WEBPACK_IMPORTED_MODULE_8__.getSelectedNode)(selection);\n            const parent = node.getParent();\n            if ((0,_lexical_link__WEBPACK_IMPORTED_MODULE_2__.$isLinkNode)(parent)) {\n                setLinkUrl(parent.getURL());\n            } else if ((0,_lexical_link__WEBPACK_IMPORTED_MODULE_2__.$isLinkNode)(node)) {\n                setLinkUrl(node.getURL());\n            } else {\n                setLinkUrl(\"\");\n            }\n        }\n        const editorElem = editorRef.current;\n        const nativeSelection = window.getSelection();\n        const activeElement = document.activeElement;\n        if (editorElem === null) {\n            return;\n        }\n        const rootElement = editor.getRootElement();\n        if (selection !== null && nativeSelection !== null && rootElement !== null && rootElement.contains(nativeSelection.anchorNode) && editor.isEditable()) {\n            var _nativeSelection_focusNode_parentElement, _nativeSelection_focusNode;\n            const domRect = (_nativeSelection_focusNode = nativeSelection.focusNode) === null || _nativeSelection_focusNode === void 0 ? void 0 : (_nativeSelection_focusNode_parentElement = _nativeSelection_focusNode.parentElement) === null || _nativeSelection_focusNode_parentElement === void 0 ? void 0 : _nativeSelection_focusNode_parentElement.getBoundingClientRect();\n            if (domRect) {\n                domRect.y += 40;\n                (0,_utils_setFloatingElemPositionForLinkEditor__WEBPACK_IMPORTED_MODULE_9__.setFloatingElemPositionForLinkEditor)(domRect, editorElem, anchorElem);\n            }\n            setLastSelection(selection);\n        } else if (!activeElement || activeElement.className !== \"link-input\") {\n            if (rootElement !== null) {\n                (0,_utils_setFloatingElemPositionForLinkEditor__WEBPACK_IMPORTED_MODULE_9__.setFloatingElemPositionForLinkEditor)(null, editorElem, anchorElem);\n            }\n            setLastSelection(null);\n            setEditMode(false);\n            setLinkUrl(\"\");\n        }\n        return true;\n    }, [\n        anchorElem,\n        editor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_6__.useEffect)(()=>{\n        const scrollerElem = anchorElem.parentElement;\n        const update = ()=>{\n            editor.getEditorState().read(()=>{\n                updateLinkEditor();\n            });\n        };\n        window.addEventListener(\"resize\", update);\n        if (scrollerElem) {\n            scrollerElem.addEventListener(\"scroll\", update);\n        }\n        return ()=>{\n            window.removeEventListener(\"resize\", update);\n            if (scrollerElem) {\n                scrollerElem.removeEventListener(\"scroll\", update);\n            }\n        };\n    }, [\n        anchorElem.parentElement,\n        editor,\n        updateLinkEditor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_6__.useEffect)(()=>{\n        return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.mergeRegister)(editor.registerUpdateListener((param)=>{\n            let { editorState } = param;\n            editorState.read(()=>{\n                updateLinkEditor();\n            });\n        }), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_5__.SELECTION_CHANGE_COMMAND, ()=>{\n            updateLinkEditor();\n            return true;\n        }, lexical__WEBPACK_IMPORTED_MODULE_5__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_5__.KEY_ESCAPE_COMMAND, ()=>{\n            if (isLink) {\n                setIsLink(false);\n                return true;\n            }\n            return false;\n        }, lexical__WEBPACK_IMPORTED_MODULE_5__.COMMAND_PRIORITY_HIGH));\n    }, [\n        editor,\n        updateLinkEditor,\n        setIsLink,\n        isLink\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_6__.useEffect)(()=>{\n        editor.getEditorState().read(()=>{\n            updateLinkEditor();\n        });\n    }, [\n        editor,\n        updateLinkEditor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_6__.useEffect)(()=>{\n        if (isEditMode && inputRef.current) {\n            inputRef.current.focus();\n        }\n    }, [\n        isEditMode\n    ]);\n    const monitorInputInteraction = (event)=>{\n        if (event.key === \"Enter\") {\n            event.preventDefault();\n            handleLinkSubmission();\n        } else if (event.key === \"Escape\") {\n            event.preventDefault();\n            setEditMode(false);\n        }\n    };\n    const handleLinkSubmission = ()=>{\n        if (lastSelection !== null) {\n            if (linkUrl !== \"\") {\n                editor.dispatchCommand(_lexical_link__WEBPACK_IMPORTED_MODULE_2__.TOGGLE_LINK_COMMAND, (0,_utils_url__WEBPACK_IMPORTED_MODULE_10__.sanitizeUrl)(editedLinkUrl));\n            }\n            setEditMode(false);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: editorRef,\n        className: \"link-editor\",\n        children: !isLink ? null : isEditMode ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                    ref: inputRef,\n                    className: \"link-input\",\n                    value: editedLinkUrl,\n                    onChange: (event)=>{\n                        setEditedLinkUrl(event.target.value);\n                    },\n                    onKeyDown: (event)=>{\n                        monitorInputInteraction(event);\n                    }\n                }, void 0, false, {\n                    fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/FloatingLinkEditorPlugin.js\",\n                    lineNumber: 187,\n                    columnNumber: 11\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"link-cancel\",\n                            role: \"button\",\n                            tabIndex: 0,\n                            onMouseDown: (event)=>event.preventDefault(),\n                            onClick: ()=>{\n                                setEditMode(false);\n                            }\n                        }, void 0, false, {\n                            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/FloatingLinkEditorPlugin.js\",\n                            lineNumber: 199,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"link-confirm\",\n                            role: \"button\",\n                            tabIndex: 0,\n                            onMouseDown: (event)=>event.preventDefault(),\n                            onClick: handleLinkSubmission\n                        }, void 0, false, {\n                            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/FloatingLinkEditorPlugin.js\",\n                            lineNumber: 209,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/FloatingLinkEditorPlugin.js\",\n                    lineNumber: 198,\n                    columnNumber: 11\n                }, this)\n            ]\n        }, void 0, true) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"link-view\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                    href: linkUrl,\n                    target: \"_blank\",\n                    rel: \"noopener noreferrer\",\n                    children: linkUrl\n                }, void 0, false, {\n                    fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/FloatingLinkEditorPlugin.js\",\n                    lineNumber: 220,\n                    columnNumber: 11\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"link-edit\",\n                    role: \"button\",\n                    tabIndex: 0,\n                    onMouseDown: (event)=>event.preventDefault(),\n                    onClick: ()=>{\n                        setEditedLinkUrl(linkUrl);\n                        setEditMode(true);\n                    }\n                }, void 0, false, {\n                    fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/FloatingLinkEditorPlugin.js\",\n                    lineNumber: 223,\n                    columnNumber: 11\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"link-trash\",\n                    role: \"button\",\n                    tabIndex: 0,\n                    onMouseDown: (event)=>event.preventDefault(),\n                    onClick: ()=>{\n                        editor.dispatchCommand(_lexical_link__WEBPACK_IMPORTED_MODULE_2__.TOGGLE_LINK_COMMAND, null);\n                    }\n                }, void 0, false, {\n                    fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/FloatingLinkEditorPlugin.js\",\n                    lineNumber: 233,\n                    columnNumber: 11\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/FloatingLinkEditorPlugin.js\",\n            lineNumber: 219,\n            columnNumber: 9\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/FloatingLinkEditorPlugin.js\",\n        lineNumber: 184,\n        columnNumber: 5\n    }, this);\n}\n_s(FloatingLinkEditor, \"/DjXDIlC4jRVzH4yEspy8iLiR2A=\");\n_c = FloatingLinkEditor;\nfunction useFloatingLinkEditorToolbar(editor, anchorElem) {\n    _s1();\n    const [activeEditor, setActiveEditor] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(editor);\n    const [isLink, setIsLink] = (0,react__WEBPACK_IMPORTED_MODULE_6__.useState)(false);\n    const updateToolbar = (0,react__WEBPACK_IMPORTED_MODULE_6__.useCallback)(()=>{\n        const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_5__.$getSelection)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_5__.$isRangeSelection)(selection)) {\n            const node = (0,_utils_getSelectedNode__WEBPACK_IMPORTED_MODULE_8__.getSelectedNode)(selection);\n            const linkParent = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.$findMatchingParent)(node, _lexical_link__WEBPACK_IMPORTED_MODULE_2__.$isLinkNode);\n            const autoLinkParent = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.$findMatchingParent)(node, _lexical_link__WEBPACK_IMPORTED_MODULE_2__.$isAutoLinkNode);\n            // We don't want this menu to open for auto links.\n            if (linkParent != null && autoLinkParent == null) {\n                setIsLink(true);\n            } else {\n                setIsLink(false);\n            }\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_6__.useEffect)(()=>{\n        return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.mergeRegister)(editor.registerUpdateListener((param)=>{\n            let { editorState } = param;\n            editorState.read(()=>{\n                updateToolbar();\n            });\n        }), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_5__.SELECTION_CHANGE_COMMAND, (_payload, newEditor)=>{\n            updateToolbar();\n            setActiveEditor(newEditor);\n            return false;\n        }, lexical__WEBPACK_IMPORTED_MODULE_5__.COMMAND_PRIORITY_CRITICAL));\n    }, [\n        editor,\n        updateToolbar\n    ]);\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_7__.createPortal)(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(FloatingLinkEditor, {\n        editor: activeEditor,\n        isLink: isLink,\n        anchorElem: anchorElem,\n        setIsLink: setIsLink\n    }, void 0, false, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/FloatingLinkEditorPlugin.js\",\n        lineNumber: 291,\n        columnNumber: 5\n    }, this), anchorElem);\n}\n_s1(useFloatingLinkEditorToolbar, \"xkFTNAP9Q6qi1b/gBLG40TLrMpA=\");\nfunction FloatingLinkEditorPlugin(param) {\n    let { anchorElem = document.body } = param;\n    _s2();\n    const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__.useLexicalComposerContext)();\n    return useFloatingLinkEditorToolbar(editor, anchorElem);\n}\n_s2(FloatingLinkEditorPlugin, \"FeDpefYNFWUx3pirmJfwhSv6krM=\", false, function() {\n    return [\n        _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__.useLexicalComposerContext,\n        useFloatingLinkEditorToolbar\n    ];\n});\n_c1 = FloatingLinkEditorPlugin;\nvar _c, _c1;\n$RefreshReg$(_c, \"FloatingLinkEditor\");\n$RefreshReg$(_c1, \"FloatingLinkEditorPlugin\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvcGx1Z2lucy9GbG9hdGluZ0xpbmtFZGl0b3JQbHVnaW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUM7O0FBQ3FCO0FBRTJEO0FBQ0E7QUFDZDtBQWFuRDtBQUMwRDtBQUM1QztBQUNVO0FBRWtCO0FBQzBDO0FBQzFEO0FBRTFDLFNBQVMyQixtQkFBbUIsS0FLM0I7UUFMMkIsRUFDMUJDLE1BQU0sRUFDTkMsTUFBTSxFQUNOQyxTQUFTLEVBQ1RDLFVBQVUsRUFDWCxHQUwyQjs7SUFNMUIsTUFBTUMsWUFBWVosNkNBQU1BLENBQUM7SUFDekIsTUFBTWEsV0FBV2IsNkNBQU1BLENBQUM7SUFDeEIsTUFBTSxDQUFDYyxTQUFTQyxXQUFXLEdBQUdkLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQ2UsZUFBZUMsaUJBQWlCLEdBQUdoQiwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNpQixZQUFZQyxZQUFZLEdBQUdsQiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNtQixlQUFlQyxpQkFBaUIsR0FBR3BCLCtDQUFRQSxDQUFDO0lBRW5ELE1BQU1xQixtQkFBbUJ4QixrREFBV0EsQ0FBQztRQUNuQyxNQUFNeUIsWUFBWXJDLHNEQUFhQTtRQUMvQixJQUFJQywwREFBaUJBLENBQUNvQyxZQUFZO1lBQ2hDLE1BQU1DLE9BQU9wQix1RUFBZUEsQ0FBQ21CO1lBQzdCLE1BQU1FLFNBQVNELEtBQUtFLFNBQVM7WUFDN0IsSUFBSTdDLDBEQUFXQSxDQUFDNEMsU0FBUztnQkFDdkJWLFdBQVdVLE9BQU9FLE1BQU07WUFDMUIsT0FBTyxJQUFJOUMsMERBQVdBLENBQUMyQyxPQUFPO2dCQUM1QlQsV0FBV1MsS0FBS0csTUFBTTtZQUN4QixPQUFPO2dCQUNMWixXQUFXO1lBQ2I7UUFDRjtRQUNBLE1BQU1hLGFBQWFoQixVQUFVaUIsT0FBTztRQUNwQyxNQUFNQyxrQkFBa0JDLE9BQU9DLFlBQVk7UUFDM0MsTUFBTUMsZ0JBQWdCQyxTQUFTRCxhQUFhO1FBRTVDLElBQUlMLGVBQWUsTUFBTTtZQUN2QjtRQUNGO1FBRUEsTUFBTU8sY0FBYzNCLE9BQU80QixjQUFjO1FBRXpDLElBQ0ViLGNBQWMsUUFDZE8sb0JBQW9CLFFBQ3BCSyxnQkFBZ0IsUUFDaEJBLFlBQVlFLFFBQVEsQ0FBQ1AsZ0JBQWdCUSxVQUFVLEtBQy9DOUIsT0FBTytCLFVBQVUsSUFDakI7Z0JBRUVULDBDQUFBQTtZQURGLE1BQU1VLFdBQ0pWLDZCQUFBQSxnQkFBZ0JXLFNBQVMsY0FBekJYLGtEQUFBQSwyQ0FBQUEsMkJBQTJCWSxhQUFhLGNBQXhDWiwrREFBQUEseUNBQTBDYSxxQkFBcUI7WUFDakUsSUFBSUgsU0FBUztnQkFDWEEsUUFBUUksQ0FBQyxJQUFJO2dCQUNidkMsaUhBQW9DQSxDQUFDbUMsU0FBU1osWUFBWWpCO1lBQzVEO1lBQ0FVLGlCQUFpQkU7UUFDbkIsT0FBTyxJQUFJLENBQUNVLGlCQUFpQkEsY0FBY1ksU0FBUyxLQUFLLGNBQWM7WUFDckUsSUFBSVYsZ0JBQWdCLE1BQU07Z0JBQ3hCOUIsaUhBQW9DQSxDQUFDLE1BQU11QixZQUFZakI7WUFDekQ7WUFDQVUsaUJBQWlCO1lBQ2pCRixZQUFZO1lBQ1pKLFdBQVc7UUFDYjtRQUVBLE9BQU87SUFDVCxHQUFHO1FBQUNKO1FBQVlIO0tBQU87SUFFdkJULGdEQUFTQSxDQUFDO1FBQ1IsTUFBTStDLGVBQWVuQyxXQUFXK0IsYUFBYTtRQUU3QyxNQUFNSyxTQUFTO1lBQ2J2QyxPQUFPd0MsY0FBYyxHQUFHQyxJQUFJLENBQUM7Z0JBQzNCM0I7WUFDRjtRQUNGO1FBRUFTLE9BQU9tQixnQkFBZ0IsQ0FBQyxVQUFVSDtRQUVsQyxJQUFJRCxjQUFjO1lBQ2hCQSxhQUFhSSxnQkFBZ0IsQ0FBQyxVQUFVSDtRQUMxQztRQUVBLE9BQU87WUFDTGhCLE9BQU9vQixtQkFBbUIsQ0FBQyxVQUFVSjtZQUVyQyxJQUFJRCxjQUFjO2dCQUNoQkEsYUFBYUssbUJBQW1CLENBQUMsVUFBVUo7WUFDN0M7UUFDRjtJQUNGLEdBQUc7UUFBQ3BDLFdBQVcrQixhQUFhO1FBQUVsQztRQUFRYztLQUFpQjtJQUV2RHZCLGdEQUFTQSxDQUFDO1FBQ1IsT0FBT2QsNkRBQWFBLENBQ2xCdUIsT0FBTzRDLHNCQUFzQixDQUFDO2dCQUFDLEVBQUVDLFdBQVcsRUFBRTtZQUM1Q0EsWUFBWUosSUFBSSxDQUFDO2dCQUNmM0I7WUFDRjtRQUNGLElBRUFkLE9BQU84QyxlQUFlLENBQ3BCMUQsNkRBQXdCQSxFQUN4QjtZQUNFMEI7WUFDQSxPQUFPO1FBQ1QsR0FDQWhDLHlEQUFvQkEsR0FFdEJrQixPQUFPOEMsZUFBZSxDQUNwQjlELHVEQUFrQkEsRUFDbEI7WUFDRSxJQUFJaUIsUUFBUTtnQkFDVkMsVUFBVTtnQkFDVixPQUFPO1lBQ1Q7WUFDQSxPQUFPO1FBQ1QsR0FDQXJCLDBEQUFxQkE7SUFHM0IsR0FBRztRQUFDbUI7UUFBUWM7UUFBa0JaO1FBQVdEO0tBQU87SUFFaERWLGdEQUFTQSxDQUFDO1FBQ1JTLE9BQU93QyxjQUFjLEdBQUdDLElBQUksQ0FBQztZQUMzQjNCO1FBQ0Y7SUFDRixHQUFHO1FBQUNkO1FBQVFjO0tBQWlCO0lBRTdCdkIsZ0RBQVNBLENBQUM7UUFDUixJQUFJbUIsY0FBY0wsU0FBU2dCLE9BQU8sRUFBRTtZQUNsQ2hCLFNBQVNnQixPQUFPLENBQUMwQixLQUFLO1FBQ3hCO0lBQ0YsR0FBRztRQUFDckM7S0FBVztJQUVmLE1BQU1zQywwQkFBMEIsQ0FDOUJDO1FBRUEsSUFBSUEsTUFBTUMsR0FBRyxLQUFLLFNBQVM7WUFDekJELE1BQU1FLGNBQWM7WUFDcEJDO1FBQ0YsT0FBTyxJQUFJSCxNQUFNQyxHQUFHLEtBQUssVUFBVTtZQUNqQ0QsTUFBTUUsY0FBYztZQUNwQnhDLFlBQVk7UUFDZDtJQUNGO0lBRUEsTUFBTXlDLHVCQUF1QjtRQUMzQixJQUFJeEMsa0JBQWtCLE1BQU07WUFDMUIsSUFBSU4sWUFBWSxJQUFJO2dCQUNsQk4sT0FBT3FELGVBQWUsQ0FBQy9FLDhEQUFtQkEsRUFBRXdCLHdEQUFXQSxDQUFDVTtZQUMxRDtZQUNBRyxZQUFZO1FBQ2Q7SUFDRjtJQUVBLHFCQUNFLDhEQUFDMkM7UUFBSUMsS0FBS25EO1FBQVdpQyxXQUFVO2tCQUM1QixDQUFDcEMsU0FBUyxPQUFPUywyQkFDaEI7OzhCQUNFLDhEQUFDOEM7b0JBQ0NELEtBQUtsRDtvQkFDTGdDLFdBQVU7b0JBQ1ZvQixPQUFPakQ7b0JBQ1BrRCxVQUFVLENBQUNUO3dCQUNUeEMsaUJBQWlCd0MsTUFBTVUsTUFBTSxDQUFDRixLQUFLO29CQUNyQztvQkFDQUcsV0FBVyxDQUFDWDt3QkFDVkQsd0JBQXdCQztvQkFDMUI7Ozs7Ozs4QkFFRiw4REFBQ0s7O3NDQUNDLDhEQUFDQTs0QkFDQ2pCLFdBQVU7NEJBQ1Z3QixNQUFLOzRCQUNMQyxVQUFVOzRCQUNWQyxhQUFhLENBQUNkLFFBQVVBLE1BQU1FLGNBQWM7NEJBQzVDYSxTQUFTO2dDQUNQckQsWUFBWTs0QkFDZDs7Ozs7O3NDQUdGLDhEQUFDMkM7NEJBQ0NqQixXQUFVOzRCQUNWd0IsTUFBSzs0QkFDTEMsVUFBVTs0QkFDVkMsYUFBYSxDQUFDZCxRQUFVQSxNQUFNRSxjQUFjOzRCQUM1Q2EsU0FBU1o7Ozs7Ozs7Ozs7Ozs7eUNBS2YsOERBQUNFO1lBQUlqQixXQUFVOzs4QkFDYiw4REFBQzRCO29CQUFFQyxNQUFNNUQ7b0JBQVNxRCxRQUFPO29CQUFTUSxLQUFJOzhCQUNuQzdEOzs7Ozs7OEJBRUgsOERBQUNnRDtvQkFDQ2pCLFdBQVU7b0JBQ1Z3QixNQUFLO29CQUNMQyxVQUFVO29CQUNWQyxhQUFhLENBQUNkLFFBQVVBLE1BQU1FLGNBQWM7b0JBQzVDYSxTQUFTO3dCQUNQdkQsaUJBQWlCSDt3QkFDakJLLFlBQVk7b0JBQ2Q7Ozs7Ozs4QkFFRiw4REFBQzJDO29CQUNDakIsV0FBVTtvQkFDVndCLE1BQUs7b0JBQ0xDLFVBQVU7b0JBQ1ZDLGFBQWEsQ0FBQ2QsUUFBVUEsTUFBTUUsY0FBYztvQkFDNUNhLFNBQVM7d0JBQ1BoRSxPQUFPcUQsZUFBZSxDQUFDL0UsOERBQW1CQSxFQUFFO29CQUM5Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNWjtHQXBOU3lCO0tBQUFBO0FBc05ULFNBQVNxRSw2QkFDUHBFLE1BQU0sRUFDTkcsVUFBVTs7SUFFVixNQUFNLENBQUNrRSxjQUFjQyxnQkFBZ0IsR0FBRzdFLCtDQUFRQSxDQUFDTztJQUNqRCxNQUFNLENBQUNDLFFBQVFDLFVBQVUsR0FBR1QsK0NBQVFBLENBQUM7SUFFckMsTUFBTThFLGdCQUFnQmpGLGtEQUFXQSxDQUFDO1FBQ2hDLE1BQU15QixZQUFZckMsc0RBQWFBO1FBQy9CLElBQUlDLDBEQUFpQkEsQ0FBQ29DLFlBQVk7WUFDaEMsTUFBTUMsT0FBT3BCLHVFQUFlQSxDQUFDbUI7WUFDN0IsTUFBTXlELGFBQWFoRyxtRUFBbUJBLENBQUN3QyxNQUFNM0Msc0RBQVdBO1lBQ3hELE1BQU1vRyxpQkFBaUJqRyxtRUFBbUJBLENBQUN3QyxNQUFNNUMsMERBQWVBO1lBRWhFLGtEQUFrRDtZQUNsRCxJQUFJb0csY0FBYyxRQUFRQyxrQkFBa0IsTUFBTTtnQkFDaER2RSxVQUFVO1lBQ1osT0FBTztnQkFDTEEsVUFBVTtZQUNaO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFFTFgsZ0RBQVNBLENBQUM7UUFDUixPQUFPZCw2REFBYUEsQ0FDbEJ1QixPQUFPNEMsc0JBQXNCLENBQUM7Z0JBQUMsRUFBRUMsV0FBVyxFQUFFO1lBQzVDQSxZQUFZSixJQUFJLENBQUM7Z0JBQ2Y4QjtZQUNGO1FBQ0YsSUFDQXZFLE9BQU84QyxlQUFlLENBQ3BCMUQsNkRBQXdCQSxFQUN4QixDQUFDc0YsVUFBVUM7WUFDVEo7WUFDQUQsZ0JBQWdCSztZQUNoQixPQUFPO1FBQ1QsR0FDQS9GLDhEQUF5QkE7SUFHL0IsR0FBRztRQUFDb0I7UUFBUXVFO0tBQWM7SUFFMUIscUJBQU81RSx1REFBWUEsZUFDakIsOERBQUNJO1FBQ0NDLFFBQVFxRTtRQUNScEUsUUFBUUE7UUFDUkUsWUFBWUE7UUFDWkQsV0FBV0E7Ozs7O2NBRWJDO0FBRUo7SUFuRFNpRTtBQXFETSxTQUFTUSx5QkFBeUIsS0FFaEQ7UUFGZ0QsRUFDL0N6RSxhQUFhdUIsU0FBU21ELElBQUksRUFDM0IsR0FGZ0Q7O0lBRy9DLE1BQU0sQ0FBQzdFLE9BQU8sR0FBR3pCLGdHQUF5QkE7SUFDMUMsT0FBTzZGLDZCQUE2QnBFLFFBQVFHO0FBQzlDO0lBTHdCeUU7O1FBR0xyRyw0RkFBeUJBO1FBQ25DNkY7OztNQUplUSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9MZXhpY2FsL3BsdWdpbnMvRmxvYXRpbmdMaW5rRWRpdG9yUGx1Z2luLmpzPzMxZjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuaW1wb3J0ICcuL2Zsb3RpbmcuY3NzJ1xuXG5pbXBvcnQgeyAkaXNBdXRvTGlua05vZGUsICRpc0xpbmtOb2RlLCBUT0dHTEVfTElOS19DT01NQU5EIH0gZnJvbSAnQGxleGljYWwvbGluaydcbmltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0J1xuaW1wb3J0IHsgJGZpbmRNYXRjaGluZ1BhcmVudCwgbWVyZ2VSZWdpc3RlciB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJ1xuaW1wb3J0IHtcbiAgJGdldFNlbGVjdGlvbixcbiAgJGlzUmFuZ2VTZWxlY3Rpb24sXG4gIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwsXG4gIENPTU1BTkRfUFJJT1JJVFlfSElHSCxcbiAgQ09NTUFORF9QUklPUklUWV9MT1csXG4gIEdyaWRTZWxlY3Rpb24sXG4gIEtFWV9FU0NBUEVfQ09NTUFORCxcbiAgTGV4aWNhbEVkaXRvcixcbiAgTm9kZVNlbGVjdGlvbixcbiAgUmFuZ2VTZWxlY3Rpb24sXG4gIFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCxcbn0gZnJvbSAnbGV4aWNhbCdcbmltcG9ydCB7IERpc3BhdGNoLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSdcblxuaW1wb3J0IHsgZ2V0U2VsZWN0ZWROb2RlIH0gZnJvbSAnLi4vdXRpbHMvZ2V0U2VsZWN0ZWROb2RlJ1xuaW1wb3J0IHsgc2V0RmxvYXRpbmdFbGVtUG9zaXRpb25Gb3JMaW5rRWRpdG9yIH0gZnJvbSAnLi4vdXRpbHMvc2V0RmxvYXRpbmdFbGVtUG9zaXRpb25Gb3JMaW5rRWRpdG9yJ1xuaW1wb3J0IHsgc2FuaXRpemVVcmwgfSBmcm9tICcuLi91dGlscy91cmwnXG5cbmZ1bmN0aW9uIEZsb2F0aW5nTGlua0VkaXRvcih7XG4gIGVkaXRvcixcbiAgaXNMaW5rLFxuICBzZXRJc0xpbmssXG4gIGFuY2hvckVsZW0sXG59KXtcbiAgY29uc3QgZWRpdG9yUmVmID0gdXNlUmVmKG51bGwpXG4gIGNvbnN0IGlucHV0UmVmID0gdXNlUmVmKG51bGwpXG4gIGNvbnN0IFtsaW5rVXJsLCBzZXRMaW5rVXJsXSA9IHVzZVN0YXRlKCcnKVxuICBjb25zdCBbZWRpdGVkTGlua1VybCwgc2V0RWRpdGVkTGlua1VybF0gPSB1c2VTdGF0ZSgnJylcbiAgY29uc3QgW2lzRWRpdE1vZGUsIHNldEVkaXRNb2RlXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbbGFzdFNlbGVjdGlvbiwgc2V0TGFzdFNlbGVjdGlvbl0gPSB1c2VTdGF0ZShudWxsKVxuXG4gIGNvbnN0IHVwZGF0ZUxpbmtFZGl0b3IgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpXG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBnZXRTZWxlY3RlZE5vZGUoc2VsZWN0aW9uKVxuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKVxuICAgICAgaWYgKCRpc0xpbmtOb2RlKHBhcmVudCkpIHtcbiAgICAgICAgc2V0TGlua1VybChwYXJlbnQuZ2V0VVJMKCkpXG4gICAgICB9IGVsc2UgaWYgKCRpc0xpbmtOb2RlKG5vZGUpKSB7XG4gICAgICAgIHNldExpbmtVcmwobm9kZS5nZXRVUkwoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldExpbmtVcmwoJycpXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvckVsZW0gPSBlZGl0b3JSZWYuY3VycmVudFxuICAgIGNvbnN0IG5hdGl2ZVNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKVxuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG5cbiAgICBpZiAoZWRpdG9yRWxlbSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKVxuXG4gICAgaWYgKFxuICAgICAgc2VsZWN0aW9uICE9PSBudWxsICYmXG4gICAgICBuYXRpdmVTZWxlY3Rpb24gIT09IG51bGwgJiZcbiAgICAgIHJvb3RFbGVtZW50ICE9PSBudWxsICYmXG4gICAgICByb290RWxlbWVudC5jb250YWlucyhuYXRpdmVTZWxlY3Rpb24uYW5jaG9yTm9kZSkgJiZcbiAgICAgIGVkaXRvci5pc0VkaXRhYmxlKClcbiAgICApIHtcbiAgICAgIGNvbnN0IGRvbVJlY3Q9XG4gICAgICAgIG5hdGl2ZVNlbGVjdGlvbi5mb2N1c05vZGU/LnBhcmVudEVsZW1lbnQ/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICBpZiAoZG9tUmVjdCkge1xuICAgICAgICBkb21SZWN0LnkgKz0gNDBcbiAgICAgICAgc2V0RmxvYXRpbmdFbGVtUG9zaXRpb25Gb3JMaW5rRWRpdG9yKGRvbVJlY3QsIGVkaXRvckVsZW0sIGFuY2hvckVsZW0pXG4gICAgICB9XG4gICAgICBzZXRMYXN0U2VsZWN0aW9uKHNlbGVjdGlvbilcbiAgICB9IGVsc2UgaWYgKCFhY3RpdmVFbGVtZW50IHx8IGFjdGl2ZUVsZW1lbnQuY2xhc3NOYW1lICE9PSAnbGluay1pbnB1dCcpIHtcbiAgICAgIGlmIChyb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICBzZXRGbG9hdGluZ0VsZW1Qb3NpdGlvbkZvckxpbmtFZGl0b3IobnVsbCwgZWRpdG9yRWxlbSwgYW5jaG9yRWxlbSlcbiAgICAgIH1cbiAgICAgIHNldExhc3RTZWxlY3Rpb24obnVsbClcbiAgICAgIHNldEVkaXRNb2RlKGZhbHNlKVxuICAgICAgc2V0TGlua1VybCgnJylcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9LCBbYW5jaG9yRWxlbSwgZWRpdG9yXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHNjcm9sbGVyRWxlbSA9IGFuY2hvckVsZW0ucGFyZW50RWxlbWVudFxuXG4gICAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgICAgZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgICAgIHVwZGF0ZUxpbmtFZGl0b3IoKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlKVxuXG4gICAgaWYgKHNjcm9sbGVyRWxlbSkge1xuICAgICAgc2Nyb2xsZXJFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSlcblxuICAgICAgaWYgKHNjcm9sbGVyRWxlbSkge1xuICAgICAgICBzY3JvbGxlckVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdXBkYXRlKVxuICAgICAgfVxuICAgIH1cbiAgfSwgW2FuY2hvckVsZW0ucGFyZW50RWxlbWVudCwgZWRpdG9yLCB1cGRhdGVMaW5rRWRpdG9yXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKFxuICAgICAgZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHsgZWRpdG9yU3RhdGUgfSkgPT4ge1xuICAgICAgICBlZGl0b3JTdGF0ZS5yZWFkKCgpID0+IHtcbiAgICAgICAgICB1cGRhdGVMaW5rRWRpdG9yKClcbiAgICAgICAgfSlcbiAgICAgIH0pLFxuXG4gICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFxuICAgICAgICBTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICB1cGRhdGVMaW5rRWRpdG9yKClcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBDT01NQU5EX1BSSU9SSVRZX0xPVyxcbiAgICAgICksXG4gICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFxuICAgICAgICBLRVlfRVNDQVBFX0NPTU1BTkQsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBpZiAoaXNMaW5rKSB7XG4gICAgICAgICAgICBzZXRJc0xpbmsoZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgQ09NTUFORF9QUklPUklUWV9ISUdILFxuICAgICAgKSxcbiAgICApXG4gIH0sIFtlZGl0b3IsIHVwZGF0ZUxpbmtFZGl0b3IsIHNldElzTGluaywgaXNMaW5rXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoKCkgPT4ge1xuICAgICAgdXBkYXRlTGlua0VkaXRvcigpXG4gICAgfSlcbiAgfSwgW2VkaXRvciwgdXBkYXRlTGlua0VkaXRvcl0pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNFZGl0TW9kZSAmJiBpbnB1dFJlZi5jdXJyZW50KSB7XG4gICAgICBpbnB1dFJlZi5jdXJyZW50LmZvY3VzKClcbiAgICB9XG4gIH0sIFtpc0VkaXRNb2RlXSlcblxuICBjb25zdCBtb25pdG9ySW5wdXRJbnRlcmFjdGlvbiA9IChcbiAgICBldmVudCxcbiAgKSA9PiB7XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgaGFuZGxlTGlua1N1Ym1pc3Npb24oKVxuICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgc2V0RWRpdE1vZGUoZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgaGFuZGxlTGlua1N1Ym1pc3Npb24gPSAoKSA9PiB7XG4gICAgaWYgKGxhc3RTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgIGlmIChsaW5rVXJsICE9PSAnJykge1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFRPR0dMRV9MSU5LX0NPTU1BTkQsIHNhbml0aXplVXJsKGVkaXRlZExpbmtVcmwpKVxuICAgICAgfVxuICAgICAgc2V0RWRpdE1vZGUoZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IHJlZj17ZWRpdG9yUmVmfSBjbGFzc05hbWU9XCJsaW5rLWVkaXRvclwiPlxuICAgICAgeyFpc0xpbmsgPyBudWxsIDogaXNFZGl0TW9kZSA/IChcbiAgICAgICAgPD5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHJlZj17aW5wdXRSZWZ9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJsaW5rLWlucHV0XCJcbiAgICAgICAgICAgIHZhbHVlPXtlZGl0ZWRMaW5rVXJsfVxuICAgICAgICAgICAgb25DaGFuZ2U9eyhldmVudCkgPT4ge1xuICAgICAgICAgICAgICBzZXRFZGl0ZWRMaW5rVXJsKGV2ZW50LnRhcmdldC52YWx1ZSlcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBvbktleURvd249eyhldmVudCkgPT4ge1xuICAgICAgICAgICAgICBtb25pdG9ySW5wdXRJbnRlcmFjdGlvbihldmVudClcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJsaW5rLWNhbmNlbFwiXG4gICAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICB0YWJJbmRleD17MH1cbiAgICAgICAgICAgICAgb25Nb3VzZURvd249eyhldmVudCkgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKX1cbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldEVkaXRNb2RlKGZhbHNlKVxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cblxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJsaW5rLWNvbmZpcm1cIlxuICAgICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgdGFiSW5kZXg9ezB9XG4gICAgICAgICAgICAgIG9uTW91c2VEb3duPXsoZXZlbnQpID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCl9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZUxpbmtTdWJtaXNzaW9ufVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgICApIDogKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxpbmstdmlld1wiPlxuICAgICAgICAgIDxhIGhyZWY9e2xpbmtVcmx9IHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIj5cbiAgICAgICAgICAgIHtsaW5rVXJsfVxuICAgICAgICAgIDwvYT5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJsaW5rLWVkaXRcIlxuICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICB0YWJJbmRleD17MH1cbiAgICAgICAgICAgIG9uTW91c2VEb3duPXsoZXZlbnQpID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCl9XG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgIHNldEVkaXRlZExpbmtVcmwobGlua1VybClcbiAgICAgICAgICAgICAgc2V0RWRpdE1vZGUodHJ1ZSlcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJsaW5rLXRyYXNoXCJcbiAgICAgICAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgICAgICAgICAgdGFiSW5kZXg9ezB9XG4gICAgICAgICAgICBvbk1vdXNlRG93bj17KGV2ZW50KSA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpfVxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFRPR0dMRV9MSU5LX0NPTU1BTkQsIG51bGwpXG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5mdW5jdGlvbiB1c2VGbG9hdGluZ0xpbmtFZGl0b3JUb29sYmFyKFxuICBlZGl0b3IsXG4gIGFuY2hvckVsZW0sXG4pIHtcbiAgY29uc3QgW2FjdGl2ZUVkaXRvciwgc2V0QWN0aXZlRWRpdG9yXSA9IHVzZVN0YXRlKGVkaXRvcilcbiAgY29uc3QgW2lzTGluaywgc2V0SXNMaW5rXSA9IHVzZVN0YXRlKGZhbHNlKVxuXG4gIGNvbnN0IHVwZGF0ZVRvb2xiYXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpXG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBnZXRTZWxlY3RlZE5vZGUoc2VsZWN0aW9uKVxuICAgICAgY29uc3QgbGlua1BhcmVudCA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgJGlzTGlua05vZGUpXG4gICAgICBjb25zdCBhdXRvTGlua1BhcmVudCA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgJGlzQXV0b0xpbmtOb2RlKVxuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRoaXMgbWVudSB0byBvcGVuIGZvciBhdXRvIGxpbmtzLlxuICAgICAgaWYgKGxpbmtQYXJlbnQgIT0gbnVsbCAmJiBhdXRvTGlua1BhcmVudCA9PSBudWxsKSB7XG4gICAgICAgIHNldElzTGluayh0cnVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0SXNMaW5rKGZhbHNlKVxuICAgICAgfVxuICAgIH1cbiAgfSwgW10pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gbWVyZ2VSZWdpc3RlcihcbiAgICAgIGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKCh7IGVkaXRvclN0YXRlIH0pID0+IHtcbiAgICAgICAgZWRpdG9yU3RhdGUucmVhZCgoKSA9PiB7XG4gICAgICAgICAgdXBkYXRlVG9vbGJhcigpXG4gICAgICAgIH0pXG4gICAgICB9KSxcbiAgICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoXG4gICAgICAgIFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCxcbiAgICAgICAgKF9wYXlsb2FkLCBuZXdFZGl0b3IpID0+IHtcbiAgICAgICAgICB1cGRhdGVUb29sYmFyKClcbiAgICAgICAgICBzZXRBY3RpdmVFZGl0b3IobmV3RWRpdG9yKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMLFxuICAgICAgKSxcbiAgICApXG4gIH0sIFtlZGl0b3IsIHVwZGF0ZVRvb2xiYXJdKVxuXG4gIHJldHVybiBjcmVhdGVQb3J0YWwoXG4gICAgPEZsb2F0aW5nTGlua0VkaXRvclxuICAgICAgZWRpdG9yPXthY3RpdmVFZGl0b3J9XG4gICAgICBpc0xpbms9e2lzTGlua31cbiAgICAgIGFuY2hvckVsZW09e2FuY2hvckVsZW19XG4gICAgICBzZXRJc0xpbms9e3NldElzTGlua31cbiAgICAvPixcbiAgICBhbmNob3JFbGVtLFxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb2F0aW5nTGlua0VkaXRvclBsdWdpbih7XG4gIGFuY2hvckVsZW0gPSBkb2N1bWVudC5ib2R5LFxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKVxuICByZXR1cm4gdXNlRmxvYXRpbmdMaW5rRWRpdG9yVG9vbGJhcihlZGl0b3IsIGFuY2hvckVsZW0pXG59Il0sIm5hbWVzIjpbIiRpc0F1dG9MaW5rTm9kZSIsIiRpc0xpbmtOb2RlIiwiVE9HR0xFX0xJTktfQ09NTUFORCIsInVzZUxleGljYWxDb21wb3NlckNvbnRleHQiLCIkZmluZE1hdGNoaW5nUGFyZW50IiwibWVyZ2VSZWdpc3RlciIsIiRnZXRTZWxlY3Rpb24iLCIkaXNSYW5nZVNlbGVjdGlvbiIsIkNPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwiLCJDT01NQU5EX1BSSU9SSVRZX0hJR0giLCJDT01NQU5EX1BSSU9SSVRZX0xPVyIsIkdyaWRTZWxlY3Rpb24iLCJLRVlfRVNDQVBFX0NPTU1BTkQiLCJMZXhpY2FsRWRpdG9yIiwiTm9kZVNlbGVjdGlvbiIsIlJhbmdlU2VsZWN0aW9uIiwiU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5EIiwiRGlzcGF0Y2giLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiUmVhY3QiLCJjcmVhdGVQb3J0YWwiLCJnZXRTZWxlY3RlZE5vZGUiLCJzZXRGbG9hdGluZ0VsZW1Qb3NpdGlvbkZvckxpbmtFZGl0b3IiLCJzYW5pdGl6ZVVybCIsIkZsb2F0aW5nTGlua0VkaXRvciIsImVkaXRvciIsImlzTGluayIsInNldElzTGluayIsImFuY2hvckVsZW0iLCJlZGl0b3JSZWYiLCJpbnB1dFJlZiIsImxpbmtVcmwiLCJzZXRMaW5rVXJsIiwiZWRpdGVkTGlua1VybCIsInNldEVkaXRlZExpbmtVcmwiLCJpc0VkaXRNb2RlIiwic2V0RWRpdE1vZGUiLCJsYXN0U2VsZWN0aW9uIiwic2V0TGFzdFNlbGVjdGlvbiIsInVwZGF0ZUxpbmtFZGl0b3IiLCJzZWxlY3Rpb24iLCJub2RlIiwicGFyZW50IiwiZ2V0UGFyZW50IiwiZ2V0VVJMIiwiZWRpdG9yRWxlbSIsImN1cnJlbnQiLCJuYXRpdmVTZWxlY3Rpb24iLCJ3aW5kb3ciLCJnZXRTZWxlY3Rpb24iLCJhY3RpdmVFbGVtZW50IiwiZG9jdW1lbnQiLCJyb290RWxlbWVudCIsImdldFJvb3RFbGVtZW50IiwiY29udGFpbnMiLCJhbmNob3JOb2RlIiwiaXNFZGl0YWJsZSIsImRvbVJlY3QiLCJmb2N1c05vZGUiLCJwYXJlbnRFbGVtZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieSIsImNsYXNzTmFtZSIsInNjcm9sbGVyRWxlbSIsInVwZGF0ZSIsImdldEVkaXRvclN0YXRlIiwicmVhZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVnaXN0ZXJVcGRhdGVMaXN0ZW5lciIsImVkaXRvclN0YXRlIiwicmVnaXN0ZXJDb21tYW5kIiwiZm9jdXMiLCJtb25pdG9ySW5wdXRJbnRlcmFjdGlvbiIsImV2ZW50Iiwia2V5IiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVMaW5rU3VibWlzc2lvbiIsImRpc3BhdGNoQ29tbWFuZCIsImRpdiIsInJlZiIsImlucHV0IiwidmFsdWUiLCJvbkNoYW5nZSIsInRhcmdldCIsIm9uS2V5RG93biIsInJvbGUiLCJ0YWJJbmRleCIsIm9uTW91c2VEb3duIiwib25DbGljayIsImEiLCJocmVmIiwicmVsIiwidXNlRmxvYXRpbmdMaW5rRWRpdG9yVG9vbGJhciIsImFjdGl2ZUVkaXRvciIsInNldEFjdGl2ZUVkaXRvciIsInVwZGF0ZVRvb2xiYXIiLCJsaW5rUGFyZW50IiwiYXV0b0xpbmtQYXJlbnQiLCJfcGF5bG9hZCIsIm5ld0VkaXRvciIsIkZsb2F0aW5nTGlua0VkaXRvclBsdWdpbiIsImJvZHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/plugins/FloatingLinkEditorPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/plugins/InlineImagePlugin.js":
/*!*************************************************************!*\
  !*** ./src/components/Lexical/plugins/InlineImagePlugin.js ***!
  \*************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INSERT_INLINE_IMAGE_COMMAND: function() { return /* binding */ INSERT_INLINE_IMAGE_COMMAND; },\n/* harmony export */   InsertInlineImageDialog: function() { return /* binding */ InsertInlineImageDialog; },\n/* harmony export */   \"default\": function() { return /* binding */ InlineImagePlugin; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lexical_utils__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lexical__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _utils_canUseDom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/canUseDom */ \"(app-pages-browser)/./src/components/Lexical/utils/canUseDom.js\");\n/* harmony import */ var _nodes_InlineImageNode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../nodes/InlineImageNode */ \"(app-pages-browser)/./src/components/Lexical/nodes/InlineImageNode.jsx\");\n/* harmony import */ var _ui_Button__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../ui/Button */ \"(app-pages-browser)/./src/components/ui/Button.jsx\");\n/* harmony import */ var _ui_Dialog__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../ui/Dialog */ \"(app-pages-browser)/./src/components/ui/Dialog.jsx\");\n/* harmony import */ var _ui_FileInput__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../ui/FileInput */ \"(app-pages-browser)/./src/components/ui/FileInput.jsx\");\n/* harmony import */ var _ui_TextInput__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../ui/TextInput */ \"(app-pages-browser)/./src/components/ui/TextInput.jsx\");\n/* harmony import */ var _ui_Select__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../ui/Select */ \"(app-pages-browser)/./src/components/ui/Select.jsx\");\n/* harmony import */ var _ui_Checkbox_css__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../ui/Checkbox.css */ \"(app-pages-browser)/./src/components/ui/Checkbox.css\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\n\nconst getDOMSelection = (targetWindow)=>_utils_canUseDom__WEBPACK_IMPORTED_MODULE_5__.CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\nconst INSERT_INLINE_IMAGE_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.createCommand)(\"INSERT_INLINE_IMAGE_COMMAND\");\nfunction InsertInlineImageDialog(param) {\n    let { activeEditor, onClose } = param;\n    _s();\n    const hasModifier = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(false);\n    const [src, setSrc] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(\"\");\n    const [altText, setAltText] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(\"\");\n    const [showCaption, setShowCaption] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(false);\n    const [position, setPosition] = (0,react__WEBPACK_IMPORTED_MODULE_4__.useState)(\"left\");\n    const isDisabled = src === \"\";\n    const handleShowCaptionChange = (e)=>{\n        setShowCaption(e.target.checked);\n    };\n    const handlePositionChange = (e)=>{\n        setPosition(e.target.value);\n    };\n    const loadImage = (files)=>{\n        const reader = new FileReader();\n        reader.onload = function() {\n            if (typeof reader.result === \"string\") {\n                setSrc(reader.result);\n            }\n        };\n        if (files !== null) {\n            reader.readAsDataURL(files[0]);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        hasModifier.current = false;\n        const handler = (e)=>{\n            hasModifier.current = e.altKey;\n        };\n        document.addEventListener(\"keydown\", handler);\n        return ()=>{\n            document.removeEventListener(\"keydown\", handler);\n        };\n    }, [\n        activeEditor\n    ]);\n    const handleOnClick = ()=>{\n        const payload = {\n            altText,\n            src,\n            showCaption,\n            position\n        };\n        activeEditor.dispatchCommand(INSERT_INLINE_IMAGE_COMMAND, payload);\n        onClose();\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginBottom: \"1em\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_FileInput__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                    label: \"Image Upload\",\n                    onChange: loadImage,\n                    accept: \"image/*\",\n                    \"data-test-id\": \"image-modal-file-upload\"\n                }, void 0, false, {\n                    fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/InlineImagePlugin.js\",\n                    lineNumber: 86,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/InlineImagePlugin.js\",\n                lineNumber: 85,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    marginBottom: \"1em\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_TextInput__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                    label: \"Alt Text\",\n                    placeholder: \"Descriptive alternative text\",\n                    onChange: setAltText,\n                    value: altText,\n                    \"data-test-id\": \"image-modal-alt-text-input\"\n                }, void 0, false, {\n                    fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/InlineImagePlugin.js\",\n                    lineNumber: 94,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/InlineImagePlugin.js\",\n                lineNumber: 93,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_Select__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n                style: {\n                    marginBottom: \"1em\",\n                    width: \"290px\"\n                },\n                label: \"Position\",\n                name: \"position\",\n                id: \"position-select\",\n                onChange: handlePositionChange,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                        value: \"left\",\n                        children: \"Left\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/InlineImagePlugin.js\",\n                        lineNumber: 110,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                        value: \"right\",\n                        children: \"Right\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/InlineImagePlugin.js\",\n                        lineNumber: 111,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                        value: \"full\",\n                        children: \"Full Width\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/InlineImagePlugin.js\",\n                        lineNumber: 112,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/InlineImagePlugin.js\",\n                lineNumber: 103,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"Input__wrapper\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        id: \"caption\",\n                        type: \"checkbox\",\n                        checked: showCaption,\n                        onChange: handleShowCaptionChange\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/InlineImagePlugin.js\",\n                        lineNumber: 116,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        htmlFor: \"caption\",\n                        children: \"Show Caption\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/InlineImagePlugin.js\",\n                        lineNumber: 117,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/InlineImagePlugin.js\",\n                lineNumber: 115,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_Dialog__WEBPACK_IMPORTED_MODULE_8__.DialogActions, {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ui_Button__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                    \"data-test-id\": \"image-modal-file-upload-btn\",\n                    disabled: isDisabled,\n                    onClick: handleOnClick,\n                    children: \"Confirm\"\n                }, void 0, false, {\n                    fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/InlineImagePlugin.js\",\n                    lineNumber: 121,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/InlineImagePlugin.js\",\n                lineNumber: 120,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(InsertInlineImageDialog, \"yl3UL4zw4VIu5rJI/YM2lf7vt5s=\");\n_c = InsertInlineImageDialog;\nfunction InlineImagePlugin(param) {\n    let { captionsEnabled } = param;\n    _s1();\n    const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext)();\n    (0,react__WEBPACK_IMPORTED_MODULE_4__.useEffect)(()=>{\n        if (!editor.hasNodes([\n            InlineImageNode\n        ])) {\n            throw new Error(\"ImagesPlugin: ImageNode not registered on editor\");\n        }\n        return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_2__.mergeRegister)(editor.registerCommand(INSERT_INLINE_IMAGE_COMMAND, (payload)=>{\n            const imageNode = (0,_nodes_InlineImageNode__WEBPACK_IMPORTED_MODULE_6__.$createInlineImageNode)(payload);\n            (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$insertNodes)([\n                imageNode\n            ]);\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isRootOrShadowRoot)(imageNode.getParentOrThrow())) {\n                (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_2__.$wrapNodeInElement)(imageNode, lexical__WEBPACK_IMPORTED_MODULE_3__.$createParagraphNode).selectEnd();\n            }\n            return true;\n        }, lexical__WEBPACK_IMPORTED_MODULE_3__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.DRAGSTART_COMMAND, (event)=>{\n            return onDragStart(event);\n        }, lexical__WEBPACK_IMPORTED_MODULE_3__.COMMAND_PRIORITY_HIGH), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.DRAGOVER_COMMAND, (event)=>{\n            return onDragover(event);\n        }, lexical__WEBPACK_IMPORTED_MODULE_3__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.DROP_COMMAND, (event)=>{\n            return onDrop(event, editor);\n        }, lexical__WEBPACK_IMPORTED_MODULE_3__.COMMAND_PRIORITY_HIGH));\n    }, [\n        captionsEnabled,\n        editor\n    ]);\n    return null;\n}\n_s1(InlineImagePlugin, \"mCqe7sh4aC9mLBXPHfG3d/PNTaQ=\", false, function() {\n    return [\n        _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext\n    ];\n});\n_c1 = InlineImagePlugin;\nfunction onDragStart(event) {\n    const node = getImageNodeInSelection();\n    if (!node) {\n        return false;\n    }\n    const dataTransfer = event.dataTransfer;\n    if (!dataTransfer) {\n        return false;\n    }\n    dataTransfer.setData(\"text/plain\", \"_\");\n    dataTransfer.setDragImage(img, 0, 0);\n    dataTransfer.setData(\"application/x-lexical-drag\", JSON.stringify({\n        data: {\n            altText: node.__altText,\n            caption: node.__caption,\n            height: node.__height,\n            key: node.getKey(),\n            showCaption: node.__showCaption,\n            src: node.__src,\n            width: node.__width\n        },\n        type: \"image\"\n    }));\n    return true;\n}\nfunction onDragover(event) {\n    const node = getImageNodeInSelection();\n    if (!node) {\n        return false;\n    }\n    if (!canDropImage(event)) {\n        event.preventDefault();\n    }\n    return true;\n}\nfunction onDrop(event, editor) {\n    const node = getImageNodeInSelection();\n    if (!node) {\n        return false;\n    }\n    const data = getDragImageData(event);\n    if (!data) {\n        return false;\n    }\n    event.preventDefault();\n    if (canDropImage(event)) {\n        const range = getDragSelection(event);\n        node.remove();\n        const rangeSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$createRangeSelection)();\n        if (range !== null && range !== undefined) {\n            rangeSelection.applyDOMRange(range);\n        }\n        (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$setSelection)(rangeSelection);\n        editor.dispatchCommand(INSERT_INLINE_IMAGE_COMMAND, data);\n    }\n    return true;\n}\nfunction getImageNodeInSelection() {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isNodeSelection)(selection)) {\n        return null;\n    }\n    const nodes = selection.getNodes();\n    const node = nodes[0];\n    return (0,_nodes_InlineImageNode__WEBPACK_IMPORTED_MODULE_6__.$isInlineImageNode)(node) ? node : null;\n}\nfunction getDragImageData(event) {\n    var _event_dataTransfer;\n    const dragData = (_event_dataTransfer = event.dataTransfer) === null || _event_dataTransfer === void 0 ? void 0 : _event_dataTransfer.getData(\"application/x-lexical-drag\");\n    if (!dragData) {\n        return null;\n    }\n    const { type, data } = JSON.parse(dragData);\n    if (type !== \"image\") {\n        return null;\n    }\n    return data;\n}\nfunction canDropImage(event) {\n    const target = event.target;\n    return !!(target && target instanceof HTMLElement && !target.closest(\"code, span.editor-image\") && target.parentElement && target.parentElement.closest(\"div.ContentEditable__root\"));\n}\nfunction getDragSelection(event) {\n    let range;\n    const target = event.target;\n    const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\n    const domSelection = getDOMSelection(targetWindow);\n    if (document.caretRangeFromPoint) {\n        range = document.caretRangeFromPoint(event.clientX, event.clientY);\n    } else if (event.rangeParent && domSelection !== null) {\n        domSelection.collapse(event.rangeParent, event.rangeOffset || 0);\n        range = domSelection.getRangeAt(0);\n    } else {\n        throw Error(\"Cannot get the selection when dragging\");\n    }\n    return range;\n}\nvar _c, _c1;\n$RefreshReg$(_c, \"InsertInlineImageDialog\");\n$RefreshReg$(_c1, \"InlineImagePlugin\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvcGx1Z2lucy9JbmxpbmVJbWFnZVBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtGO0FBQ2Y7QUFnQmxEO0FBQ21DO0FBQ0g7QUFJZjtBQUNHO0FBQ1c7QUFDTDtBQUNBO0FBQ047QUFDTjtBQUUvQixNQUFNNEIsa0JBQWtCLENBQUNDLGVBQ3ZCVCx5REFBV0EsR0FBRyxDQUFDUyxnQkFBZ0JDLE1BQUssRUFBR0MsWUFBWSxLQUFLO0FBRW5ELE1BQU1DLDhCQUE4Qm5CLHNEQUFhQSxDQUFDLCtCQUErQjtBQUVqRixTQUFTb0Isd0JBQXdCLEtBQXlCO1FBQXpCLEVBQUVDLFlBQVksRUFBRUMsT0FBTyxFQUFFLEdBQXpCOztJQUN0QyxNQUFNQyxjQUFjbEIsNkNBQU1BLENBQUM7SUFDM0IsTUFBTSxDQUFDbUIsS0FBS0MsT0FBTyxHQUFHbkIsK0NBQVFBLENBQUM7SUFDL0IsTUFBTSxDQUFDb0IsU0FBU0MsV0FBVyxHQUFHckIsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDc0IsYUFBYUMsZUFBZSxHQUFHdkIsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDd0IsVUFBVUMsWUFBWSxHQUFHekIsK0NBQVFBLENBQUM7SUFFekMsTUFBTTBCLGFBQWFSLFFBQVE7SUFFM0IsTUFBTVMsMEJBQTBCLENBQUNDO1FBQy9CTCxlQUFlSyxFQUFFQyxNQUFNLENBQUNDLE9BQU87SUFDakM7SUFFQSxNQUFNQyx1QkFBdUIsQ0FBQ0g7UUFDNUJILFlBQVlHLEVBQUVDLE1BQU0sQ0FBQ0csS0FBSztJQUM1QjtJQUVBLE1BQU1DLFlBQVksQ0FBQ0M7UUFDakIsTUFBTUMsU0FBUyxJQUFJQztRQUNuQkQsT0FBT0UsTUFBTSxHQUFHO1lBQ2QsSUFBSSxPQUFPRixPQUFPRyxNQUFNLEtBQUssVUFBVTtnQkFDckNuQixPQUFPZ0IsT0FBT0csTUFBTTtZQUN0QjtRQUNGO1FBQ0EsSUFBSUosVUFBVSxNQUFNO1lBQ2xCQyxPQUFPSSxhQUFhLENBQUNMLEtBQUssQ0FBQyxFQUFFO1FBQy9CO0lBQ0Y7SUFFQXBDLGdEQUFTQSxDQUFDO1FBQ1JtQixZQUFZdUIsT0FBTyxHQUFHO1FBQ3RCLE1BQU1DLFVBQVUsQ0FBQ2I7WUFDZlgsWUFBWXVCLE9BQU8sR0FBR1osRUFBRWMsTUFBTTtRQUNoQztRQUNBQyxTQUFTQyxnQkFBZ0IsQ0FBQyxXQUFXSDtRQUNyQyxPQUFPO1lBQ0xFLFNBQVNFLG1CQUFtQixDQUFDLFdBQVdKO1FBQzFDO0lBQ0YsR0FBRztRQUFDMUI7S0FBYTtJQUVqQixNQUFNK0IsZ0JBQWdCO1FBQ3BCLE1BQU1DLFVBQVU7WUFBRTNCO1lBQVNGO1lBQUtJO1lBQWFFO1FBQVM7UUFDdERULGFBQWFpQyxlQUFlLENBQUNuQyw2QkFBNkJrQztRQUMxRC9CO0lBQ0Y7SUFFQSxxQkFDRTs7MEJBQ0UsOERBQUNpQztnQkFBSUMsT0FBTztvQkFBRUMsY0FBYztnQkFBTTswQkFDaEMsNEVBQUM3QyxxREFBU0E7b0JBQ1I4QyxPQUFNO29CQUNOQyxVQUFVcEI7b0JBQ1ZxQixRQUFPO29CQUNQQyxnQkFBYTs7Ozs7Ozs7Ozs7MEJBR2pCLDhEQUFDTjtnQkFBSUMsT0FBTztvQkFBRUMsY0FBYztnQkFBTTswQkFDaEMsNEVBQUM1QyxzREFBU0E7b0JBQ1I2QyxPQUFNO29CQUNOSSxhQUFZO29CQUNaSCxVQUFVaEM7b0JBQ1ZXLE9BQU9aO29CQUNQbUMsZ0JBQWE7Ozs7Ozs7Ozs7OzBCQUlqQiw4REFBQy9DLG1EQUFNQTtnQkFDTDBDLE9BQU87b0JBQUVDLGNBQWM7b0JBQU9NLE9BQU87Z0JBQVE7Z0JBQzdDTCxPQUFNO2dCQUNOTSxNQUFLO2dCQUNMQyxJQUFHO2dCQUNITixVQUFVdEI7O2tDQUVWLDhEQUFDNkI7d0JBQU81QixPQUFNO2tDQUFPOzs7Ozs7a0NBQ3JCLDhEQUFDNEI7d0JBQU81QixPQUFNO2tDQUFROzs7Ozs7a0NBQ3RCLDhEQUFDNEI7d0JBQU81QixPQUFNO2tDQUFPOzs7Ozs7Ozs7Ozs7MEJBR3ZCLDhEQUFDaUI7Z0JBQUlZLFdBQVU7O2tDQUNiLDhEQUFDQzt3QkFBTUgsSUFBRzt3QkFBVUksTUFBSzt3QkFBV2pDLFNBQVNSO3dCQUFhK0IsVUFBVTFCOzs7Ozs7a0NBQ3BFLDhEQUFDeUI7d0JBQU1ZLFNBQVE7a0NBQVU7Ozs7Ozs7Ozs7OzswQkFHM0IsOERBQUMzRCxxREFBYUE7MEJBQ1osNEVBQUNELGtEQUFNQTtvQkFDTG1ELGdCQUFhO29CQUNiVSxVQUFVdkM7b0JBQ1Z3QyxTQUFTcEI7OEJBQWU7Ozs7Ozs7Ozs7Ozs7QUFNbEM7R0E3RmdCaEM7S0FBQUE7QUErRkQsU0FBU3FELGtCQUFrQixLQUFtQjtRQUFuQixFQUFFQyxlQUFlLEVBQUUsR0FBbkI7O0lBQ3hDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHeEYsZ0dBQXlCQTtJQUUxQ2lCLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDdUUsT0FBT0MsUUFBUSxDQUFDO1lBQUNDO1NBQWdCLEdBQUc7WUFDdkMsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsT0FBT3pGLDZEQUFhQSxDQUNsQnNGLE9BQU9JLGVBQWUsQ0FDcEI1RCw2QkFDQSxDQUFDa0M7WUFDQyxNQUFNMkIsWUFBWXhFLDhFQUFzQkEsQ0FBQzZDO1lBQ3pDNUQscURBQVlBLENBQUM7Z0JBQUN1RjthQUFVO1lBQ3hCLElBQUlyRiw0REFBbUJBLENBQUNxRixVQUFVQyxnQkFBZ0IsS0FBSztnQkFDckQ3RixrRUFBa0JBLENBQUM0RixXQUFXMUYseURBQW9CQSxFQUFFNEYsU0FBUztZQUMvRDtZQUVBLE9BQU87UUFDVCxHQUNBckYsNERBQXVCQSxHQUV6QjhFLE9BQU9JLGVBQWUsQ0FDcEI3RSxzREFBaUJBLEVBQ2pCLENBQUNpRjtZQUNDLE9BQU9DLFlBQVlEO1FBQ3JCLEdBQ0FyRiwwREFBcUJBLEdBRXZCNkUsT0FBT0ksZUFBZSxDQUNwQjlFLHFEQUFnQkEsRUFDaEIsQ0FBQ2tGO1lBQ0MsT0FBT0UsV0FBV0Y7UUFDcEIsR0FDQXBGLHlEQUFvQkEsR0FFdEI0RSxPQUFPSSxlQUFlLENBQ3BCNUUsaURBQVlBLEVBQ1osQ0FBQ2dGO1lBQ0MsT0FBT0csT0FBT0gsT0FBT1I7UUFDdkIsR0FDQTdFLDBEQUFxQkE7SUFHM0IsR0FBRztRQUFDNEU7UUFBaUJDO0tBQU87SUFFNUIsT0FBTztBQUNUO0lBL0N3QkY7O1FBQ0x0Riw0RkFBeUJBOzs7TUFEcEJzRjtBQWlEeEIsU0FBU1csWUFBWUQsS0FBSztJQUN4QixNQUFNSSxPQUFPQztJQUNiLElBQUksQ0FBQ0QsTUFBTTtRQUNULE9BQU87SUFDVDtJQUNBLE1BQU1FLGVBQWVOLE1BQU1NLFlBQVk7SUFDdkMsSUFBSSxDQUFDQSxjQUFjO1FBQ2pCLE9BQU87SUFDVDtJQUNBQSxhQUFhQyxPQUFPLENBQUMsY0FBYztJQUNuQ0QsYUFBYUUsWUFBWSxDQUFDQyxLQUFLLEdBQUc7SUFDbENILGFBQWFDLE9BQU8sQ0FDbEIsOEJBQ0FHLEtBQUtDLFNBQVMsQ0FBQztRQUNiQyxNQUFNO1lBQ0pyRSxTQUFTNkQsS0FBS1MsU0FBUztZQUN2QkMsU0FBU1YsS0FBS1csU0FBUztZQUN2QkMsUUFBUVosS0FBS2EsUUFBUTtZQUNyQkMsS0FBS2QsS0FBS2UsTUFBTTtZQUNoQjFFLGFBQWEyRCxLQUFLZ0IsYUFBYTtZQUMvQi9FLEtBQUsrRCxLQUFLaUIsS0FBSztZQUNmekMsT0FBT3dCLEtBQUtrQixPQUFPO1FBQ3JCO1FBQ0FwQyxNQUFNO0lBQ1I7SUFHRixPQUFPO0FBQ1Q7QUFFQSxTQUFTZ0IsV0FBV0YsS0FBSztJQUN2QixNQUFNSSxPQUFPQztJQUNiLElBQUksQ0FBQ0QsTUFBTTtRQUNULE9BQU87SUFDVDtJQUNBLElBQUksQ0FBQ21CLGFBQWF2QixRQUFRO1FBQ3hCQSxNQUFNd0IsY0FBYztJQUN0QjtJQUNBLE9BQU87QUFDVDtBQUVBLFNBQVNyQixPQUFPSCxLQUFLLEVBQUVSLE1BQU07SUFDM0IsTUFBTVksT0FBT0M7SUFDYixJQUFJLENBQUNELE1BQU07UUFDVCxPQUFPO0lBQ1Q7SUFDQSxNQUFNUSxPQUFPYSxpQkFBaUJ6QjtJQUM5QixJQUFJLENBQUNZLE1BQU07UUFDVCxPQUFPO0lBQ1Q7SUFDQVosTUFBTXdCLGNBQWM7SUFDcEIsSUFBSUQsYUFBYXZCLFFBQVE7UUFDdkIsTUFBTTBCLFFBQVFDLGlCQUFpQjNCO1FBQy9CSSxLQUFLd0IsTUFBTTtRQUNYLE1BQU1DLGlCQUFpQnpILDhEQUFxQkE7UUFDNUMsSUFBSXNILFVBQVUsUUFBUUEsVUFBVUksV0FBVztZQUN6Q0QsZUFBZUUsYUFBYSxDQUFDTDtRQUMvQjtRQUNBakgsc0RBQWFBLENBQUNvSDtRQUNkckMsT0FBT3JCLGVBQWUsQ0FBQ25DLDZCQUE2QjRFO0lBQ3REO0lBQ0EsT0FBTztBQUNUO0FBRUEsU0FBU1A7SUFDUCxNQUFNMkIsWUFBWTNILHNEQUFhQTtJQUMvQixJQUFJLENBQUNFLHlEQUFnQkEsQ0FBQ3lILFlBQVk7UUFDaEMsT0FBTztJQUNUO0lBQ0EsTUFBTUMsUUFBUUQsVUFBVUUsUUFBUTtJQUNoQyxNQUFNOUIsT0FBTzZCLEtBQUssQ0FBQyxFQUFFO0lBQ3JCLE9BQU8zRywwRUFBa0JBLENBQUM4RSxRQUFRQSxPQUFPO0FBQzNDO0FBRUEsU0FBU3FCLGlCQUFpQnpCLEtBQUs7UUFDWkE7SUFBakIsTUFBTW1DLFlBQVduQyxzQkFBQUEsTUFBTU0sWUFBWSxjQUFsQk4sMENBQUFBLG9CQUFvQm9DLE9BQU8sQ0FBQztJQUM3QyxJQUFJLENBQUNELFVBQVU7UUFDYixPQUFPO0lBQ1Q7SUFDQSxNQUFNLEVBQUVqRCxJQUFJLEVBQUUwQixJQUFJLEVBQUUsR0FBR0YsS0FBSzJCLEtBQUssQ0FBQ0Y7SUFDbEMsSUFBSWpELFNBQVMsU0FBUztRQUNwQixPQUFPO0lBQ1Q7SUFFQSxPQUFPMEI7QUFDVDtBQUVBLFNBQVNXLGFBQWF2QixLQUFLO0lBQ3pCLE1BQU1oRCxTQUFTZ0QsTUFBTWhELE1BQU07SUFDM0IsT0FBTyxDQUFDLENBQ05BLENBQUFBLFVBQ0FBLGtCQUFrQnNGLGVBQ2xCLENBQUN0RixPQUFPdUYsT0FBTyxDQUFDLDhCQUNoQnZGLE9BQU93RixhQUFhLElBQ3BCeEYsT0FBT3dGLGFBQWEsQ0FBQ0QsT0FBTyxDQUFDLDRCQUEyQjtBQUU1RDtBQUVBLFNBQVNaLGlCQUFpQjNCLEtBQUs7SUFDN0IsSUFBSTBCO0lBQ0osTUFBTTFFLFNBQVNnRCxNQUFNaEQsTUFBTTtJQUMzQixNQUFNbkIsZUFBZW1CLFVBQVUsT0FDM0IsT0FDQUEsT0FBT3lGLFFBQVEsS0FBSyxJQUNsQnpGLE9BQU8wRixXQUFXLEdBQ2xCMUYsT0FBTzJGLGFBQWEsQ0FBQ0QsV0FBVztJQUN0QyxNQUFNRSxlQUFlaEgsZ0JBQWdCQztJQUNyQyxJQUFJaUMsU0FBUytFLG1CQUFtQixFQUFFO1FBQ2hDbkIsUUFBUTVELFNBQVMrRSxtQkFBbUIsQ0FBQzdDLE1BQU04QyxPQUFPLEVBQUU5QyxNQUFNK0MsT0FBTztJQUNuRSxPQUFPLElBQUkvQyxNQUFNZ0QsV0FBVyxJQUFJSixpQkFBaUIsTUFBTTtRQUNyREEsYUFBYUssUUFBUSxDQUFDakQsTUFBTWdELFdBQVcsRUFBRWhELE1BQU1rRCxXQUFXLElBQUk7UUFDOUR4QixRQUFRa0IsYUFBYU8sVUFBVSxDQUFDO0lBQ2xDLE9BQU87UUFDTCxNQUFNeEQsTUFBTTtJQUNkO0lBRUEsT0FBTytCO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTGV4aWNhbC9wbHVnaW5zL0lubGluZUltYWdlUGx1Z2luLmpzPzZkODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnO1xuaW1wb3J0IHsgJHdyYXBOb2RlSW5FbGVtZW50LCBtZXJnZVJlZ2lzdGVyIH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHtcbiAgJGNyZWF0ZVBhcmFncmFwaE5vZGUsXG4gICRjcmVhdGVSYW5nZVNlbGVjdGlvbixcbiAgJGdldFNlbGVjdGlvbixcbiAgJGluc2VydE5vZGVzLFxuICAkaXNOb2RlU2VsZWN0aW9uLFxuICAkaXNSb290T3JTaGFkb3dSb290LFxuICAkc2V0U2VsZWN0aW9uLFxuICBDT01NQU5EX1BSSU9SSVRZX0VESVRPUixcbiAgQ09NTUFORF9QUklPUklUWV9ISUdILFxuICBDT01NQU5EX1BSSU9SSVRZX0xPVyxcbiAgY3JlYXRlQ29tbWFuZCxcbiAgRFJBR09WRVJfQ09NTUFORCxcbiAgRFJBR1NUQVJUX0NPTU1BTkQsXG4gIERST1BfQ09NTUFORCxcbn0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDQU5fVVNFX0RPTSB9IGZyb20gJy4uL3V0aWxzL2NhblVzZURvbSc7XG5pbXBvcnQge1xuICAkY3JlYXRlSW5saW5lSW1hZ2VOb2RlLFxuICAkaXNJbmxpbmVJbWFnZU5vZGUsXG59IGZyb20gJy4uL25vZGVzL0lubGluZUltYWdlTm9kZSc7XG5pbXBvcnQgQnV0dG9uIGZyb20gJy4uLy4uL3VpL0J1dHRvbic7XG5pbXBvcnQgeyBEaWFsb2dBY3Rpb25zIH0gZnJvbSAnLi4vLi4vdWkvRGlhbG9nJztcbmltcG9ydCBGaWxlSW5wdXQgZnJvbSAnLi4vLi4vdWkvRmlsZUlucHV0JztcbmltcG9ydCBUZXh0SW5wdXQgZnJvbSAnLi4vLi4vdWkvVGV4dElucHV0JztcbmltcG9ydCBTZWxlY3QgZnJvbSAnLi4vLi4vdWkvU2VsZWN0JztcbmltcG9ydCAnLi4vLi4vdWkvQ2hlY2tib3guY3NzJztcblxuY29uc3QgZ2V0RE9NU2VsZWN0aW9uID0gKHRhcmdldFdpbmRvdykgPT5cbiAgQ0FOX1VTRV9ET00gPyAodGFyZ2V0V2luZG93IHx8IHdpbmRvdykuZ2V0U2VsZWN0aW9uKCkgOiBudWxsO1xuXG5leHBvcnQgY29uc3QgSU5TRVJUX0lOTElORV9JTUFHRV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX0lOTElORV9JTUFHRV9DT01NQU5EJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBJbnNlcnRJbmxpbmVJbWFnZURpYWxvZyh7IGFjdGl2ZUVkaXRvciwgb25DbG9zZSB9KSB7XG4gIGNvbnN0IGhhc01vZGlmaWVyID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgW3NyYywgc2V0U3JjXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW2FsdFRleHQsIHNldEFsdFRleHRdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbc2hvd0NhcHRpb24sIHNldFNob3dDYXB0aW9uXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Bvc2l0aW9uLCBzZXRQb3NpdGlvbl0gPSB1c2VTdGF0ZSgnbGVmdCcpO1xuXG4gIGNvbnN0IGlzRGlzYWJsZWQgPSBzcmMgPT09ICcnO1xuXG4gIGNvbnN0IGhhbmRsZVNob3dDYXB0aW9uQ2hhbmdlID0gKGUpID0+IHtcbiAgICBzZXRTaG93Q2FwdGlvbihlLnRhcmdldC5jaGVja2VkKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVQb3NpdGlvbkNoYW5nZSA9IChlKSA9PiB7XG4gICAgc2V0UG9zaXRpb24oZS50YXJnZXQudmFsdWUpO1xuICB9O1xuXG4gIGNvbnN0IGxvYWRJbWFnZSA9IChmaWxlcykgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVhZGVyLnJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc2V0U3JjKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGZpbGVzICE9PSBudWxsKSB7XG4gICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlc1swXSk7XG4gICAgfVxuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaGFzTW9kaWZpZXIuY3VycmVudCA9IGZhbHNlO1xuICAgIGNvbnN0IGhhbmRsZXIgPSAoZSkgPT4ge1xuICAgICAgaGFzTW9kaWZpZXIuY3VycmVudCA9IGUuYWx0S2V5O1xuICAgIH07XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcik7XG4gICAgfTtcbiAgfSwgW2FjdGl2ZUVkaXRvcl0pO1xuXG4gIGNvbnN0IGhhbmRsZU9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHsgYWx0VGV4dCwgc3JjLCBzaG93Q2FwdGlvbiwgcG9zaXRpb24gfTtcbiAgICBhY3RpdmVFZGl0b3IuZGlzcGF0Y2hDb21tYW5kKElOU0VSVF9JTkxJTkVfSU1BR0VfQ09NTUFORCwgcGF5bG9hZCk7XG4gICAgb25DbG9zZSgpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxkaXYgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiAnMWVtJyB9fT5cbiAgICAgICAgPEZpbGVJbnB1dFxuICAgICAgICAgIGxhYmVsPVwiSW1hZ2UgVXBsb2FkXCJcbiAgICAgICAgICBvbkNoYW5nZT17bG9hZEltYWdlfVxuICAgICAgICAgIGFjY2VwdD1cImltYWdlLypcIlxuICAgICAgICAgIGRhdGEtdGVzdC1pZD1cImltYWdlLW1vZGFsLWZpbGUtdXBsb2FkXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBzdHlsZT17eyBtYXJnaW5Cb3R0b206ICcxZW0nIH19PlxuICAgICAgICA8VGV4dElucHV0XG4gICAgICAgICAgbGFiZWw9XCJBbHQgVGV4dFwiXG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJEZXNjcmlwdGl2ZSBhbHRlcm5hdGl2ZSB0ZXh0XCJcbiAgICAgICAgICBvbkNoYW5nZT17c2V0QWx0VGV4dH1cbiAgICAgICAgICB2YWx1ZT17YWx0VGV4dH1cbiAgICAgICAgICBkYXRhLXRlc3QtaWQ9XCJpbWFnZS1tb2RhbC1hbHQtdGV4dC1pbnB1dFwiXG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPFNlbGVjdFxuICAgICAgICBzdHlsZT17eyBtYXJnaW5Cb3R0b206ICcxZW0nLCB3aWR0aDogJzI5MHB4JyB9fVxuICAgICAgICBsYWJlbD1cIlBvc2l0aW9uXCJcbiAgICAgICAgbmFtZT1cInBvc2l0aW9uXCJcbiAgICAgICAgaWQ9XCJwb3NpdGlvbi1zZWxlY3RcIlxuICAgICAgICBvbkNoYW5nZT17aGFuZGxlUG9zaXRpb25DaGFuZ2V9XG4gICAgICA+XG4gICAgICAgIDxvcHRpb24gdmFsdWU9XCJsZWZ0XCI+TGVmdDwvb3B0aW9uPlxuICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmlnaHRcIj5SaWdodDwvb3B0aW9uPlxuICAgICAgICA8b3B0aW9uIHZhbHVlPVwiZnVsbFwiPkZ1bGwgV2lkdGg8L29wdGlvbj5cbiAgICAgIDwvU2VsZWN0PlxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIklucHV0X193cmFwcGVyXCI+XG4gICAgICAgIDxpbnB1dCBpZD1cImNhcHRpb25cIiB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXtzaG93Q2FwdGlvbn0gb25DaGFuZ2U9e2hhbmRsZVNob3dDYXB0aW9uQ2hhbmdlfSAvPlxuICAgICAgICA8bGFiZWwgaHRtbEZvcj1cImNhcHRpb25cIj5TaG93IENhcHRpb248L2xhYmVsPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxEaWFsb2dBY3Rpb25zPlxuICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgZGF0YS10ZXN0LWlkPVwiaW1hZ2UtbW9kYWwtZmlsZS11cGxvYWQtYnRuXCJcbiAgICAgICAgICBkaXNhYmxlZD17aXNEaXNhYmxlZH1cbiAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVPbkNsaWNrfT5cbiAgICAgICAgICBDb25maXJtXG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgPC9EaWFsb2dBY3Rpb25zPlxuICAgIDwvPlxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBJbmxpbmVJbWFnZVBsdWdpbih7IGNhcHRpb25zRW5hYmxlZCB9KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlZGl0b3IuaGFzTm9kZXMoW0lubGluZUltYWdlTm9kZV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlc1BsdWdpbjogSW1hZ2VOb2RlIG5vdCByZWdpc3RlcmVkIG9uIGVkaXRvcicpO1xuICAgIH1cblxuICAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKFxuICAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChcbiAgICAgICAgSU5TRVJUX0lOTElORV9JTUFHRV9DT01NQU5ELFxuICAgICAgICAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGltYWdlTm9kZSA9ICRjcmVhdGVJbmxpbmVJbWFnZU5vZGUocGF5bG9hZCk7XG4gICAgICAgICAgJGluc2VydE5vZGVzKFtpbWFnZU5vZGVdKTtcbiAgICAgICAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChpbWFnZU5vZGUuZ2V0UGFyZW50T3JUaHJvdygpKSkge1xuICAgICAgICAgICAgJHdyYXBOb2RlSW5FbGVtZW50KGltYWdlTm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUpLnNlbGVjdEVuZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBDT01NQU5EX1BSSU9SSVRZX0VESVRPUixcbiAgICAgICksXG4gICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFxuICAgICAgICBEUkFHU1RBUlRfQ09NTUFORCxcbiAgICAgICAgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9uRHJhZ1N0YXJ0KGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgQ09NTUFORF9QUklPUklUWV9ISUdILFxuICAgICAgKSxcbiAgICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoXG4gICAgICAgIERSQUdPVkVSX0NPTU1BTkQsXG4gICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgIHJldHVybiBvbkRyYWdvdmVyKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgQ09NTUFORF9QUklPUklUWV9MT1csXG4gICAgICApLFxuICAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChcbiAgICAgICAgRFJPUF9DT01NQU5ELFxuICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICByZXR1cm4gb25Ecm9wKGV2ZW50LCBlZGl0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBDT01NQU5EX1BSSU9SSVRZX0hJR0gsXG4gICAgICApLFxuICAgICk7XG4gIH0sIFtjYXB0aW9uc0VuYWJsZWQsIGVkaXRvcl0pO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBvbkRyYWdTdGFydChldmVudCkge1xuICBjb25zdCBub2RlID0gZ2V0SW1hZ2VOb2RlSW5TZWxlY3Rpb24oKTtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGV2ZW50LmRhdGFUcmFuc2ZlcjtcbiAgaWYgKCFkYXRhVHJhbnNmZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGF0YVRyYW5zZmVyLnNldERhdGEoJ3RleHQvcGxhaW4nLCAnXycpO1xuICBkYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGltZywgMCwgMCk7XG4gIGRhdGFUcmFuc2Zlci5zZXREYXRhKFxuICAgICdhcHBsaWNhdGlvbi94LWxleGljYWwtZHJhZycsXG4gICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgZGF0YToge1xuICAgICAgICBhbHRUZXh0OiBub2RlLl9fYWx0VGV4dCxcbiAgICAgICAgY2FwdGlvbjogbm9kZS5fX2NhcHRpb24sXG4gICAgICAgIGhlaWdodDogbm9kZS5fX2hlaWdodCxcbiAgICAgICAga2V5OiBub2RlLmdldEtleSgpLFxuICAgICAgICBzaG93Q2FwdGlvbjogbm9kZS5fX3Nob3dDYXB0aW9uLFxuICAgICAgICBzcmM6IG5vZGUuX19zcmMsXG4gICAgICAgIHdpZHRoOiBub2RlLl9fd2lkdGgsXG4gICAgICB9LFxuICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICB9KSxcbiAgKTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25EcmFnb3ZlcihldmVudCkge1xuICBjb25zdCBub2RlID0gZ2V0SW1hZ2VOb2RlSW5TZWxlY3Rpb24oKTtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghY2FuRHJvcEltYWdlKGV2ZW50KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uRHJvcChldmVudCwgZWRpdG9yKSB7XG4gIGNvbnN0IG5vZGUgPSBnZXRJbWFnZU5vZGVJblNlbGVjdGlvbigpO1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZGF0YSA9IGdldERyYWdJbWFnZURhdGEoZXZlbnQpO1xuICBpZiAoIWRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgaWYgKGNhbkRyb3BJbWFnZShldmVudCkpIHtcbiAgICBjb25zdCByYW5nZSA9IGdldERyYWdTZWxlY3Rpb24oZXZlbnQpO1xuICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgY29uc3QgcmFuZ2VTZWxlY3Rpb24gPSAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKTtcbiAgICBpZiAocmFuZ2UgIT09IG51bGwgJiYgcmFuZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmFuZ2VTZWxlY3Rpb24uYXBwbHlET01SYW5nZShyYW5nZSk7XG4gICAgfVxuICAgICRzZXRTZWxlY3Rpb24ocmFuZ2VTZWxlY3Rpb24pO1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoSU5TRVJUX0lOTElORV9JTUFHRV9DT01NQU5ELCBkYXRhKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW1hZ2VOb2RlSW5TZWxlY3Rpb24oKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBub2RlID0gbm9kZXNbMF07XG4gIHJldHVybiAkaXNJbmxpbmVJbWFnZU5vZGUobm9kZSkgPyBub2RlIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RHJhZ0ltYWdlRGF0YShldmVudCkge1xuICBjb25zdCBkcmFnRGF0YSA9IGV2ZW50LmRhdGFUcmFuc2Zlcj8uZ2V0RGF0YSgnYXBwbGljYXRpb24veC1sZXhpY2FsLWRyYWcnKTtcbiAgaWYgKCFkcmFnRGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHsgdHlwZSwgZGF0YSB9ID0gSlNPTi5wYXJzZShkcmFnRGF0YSk7XG4gIGlmICh0eXBlICE9PSAnaW1hZ2UnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gY2FuRHJvcEltYWdlKGV2ZW50KSB7XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgcmV0dXJuICEhKFxuICAgIHRhcmdldCAmJlxuICAgIHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmXG4gICAgIXRhcmdldC5jbG9zZXN0KCdjb2RlLCBzcGFuLmVkaXRvci1pbWFnZScpICYmXG4gICAgdGFyZ2V0LnBhcmVudEVsZW1lbnQgJiZcbiAgICB0YXJnZXQucGFyZW50RWxlbWVudC5jbG9zZXN0KCdkaXYuQ29udGVudEVkaXRhYmxlX19yb290JylcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0RHJhZ1NlbGVjdGlvbihldmVudCkge1xuICBsZXQgcmFuZ2U7XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgY29uc3QgdGFyZ2V0V2luZG93ID0gdGFyZ2V0ID09IG51bGxcbiAgICA/IG51bGxcbiAgICA6IHRhcmdldC5ub2RlVHlwZSA9PT0gOVxuICAgICAgPyB0YXJnZXQuZGVmYXVsdFZpZXdcbiAgICAgIDogdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbih0YXJnZXRXaW5kb3cpO1xuICBpZiAoZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgIHJhbmdlID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgfSBlbHNlIGlmIChldmVudC5yYW5nZVBhcmVudCAmJiBkb21TZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBkb21TZWxlY3Rpb24uY29sbGFwc2UoZXZlbnQucmFuZ2VQYXJlbnQsIGV2ZW50LnJhbmdlT2Zmc2V0IHx8IDApO1xuICAgIHJhbmdlID0gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBnZXQgdGhlIHNlbGVjdGlvbiB3aGVuIGRyYWdnaW5nJyk7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59XG4iXSwibmFtZXMiOlsidXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCIsIiR3cmFwTm9kZUluRWxlbWVudCIsIm1lcmdlUmVnaXN0ZXIiLCIkY3JlYXRlUGFyYWdyYXBoTm9kZSIsIiRjcmVhdGVSYW5nZVNlbGVjdGlvbiIsIiRnZXRTZWxlY3Rpb24iLCIkaW5zZXJ0Tm9kZXMiLCIkaXNOb2RlU2VsZWN0aW9uIiwiJGlzUm9vdE9yU2hhZG93Um9vdCIsIiRzZXRTZWxlY3Rpb24iLCJDT01NQU5EX1BSSU9SSVRZX0VESVRPUiIsIkNPTU1BTkRfUFJJT1JJVFlfSElHSCIsIkNPTU1BTkRfUFJJT1JJVFlfTE9XIiwiY3JlYXRlQ29tbWFuZCIsIkRSQUdPVkVSX0NPTU1BTkQiLCJEUkFHU1RBUlRfQ09NTUFORCIsIkRST1BfQ09NTUFORCIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiQ0FOX1VTRV9ET00iLCIkY3JlYXRlSW5saW5lSW1hZ2VOb2RlIiwiJGlzSW5saW5lSW1hZ2VOb2RlIiwiQnV0dG9uIiwiRGlhbG9nQWN0aW9ucyIsIkZpbGVJbnB1dCIsIlRleHRJbnB1dCIsIlNlbGVjdCIsImdldERPTVNlbGVjdGlvbiIsInRhcmdldFdpbmRvdyIsIndpbmRvdyIsImdldFNlbGVjdGlvbiIsIklOU0VSVF9JTkxJTkVfSU1BR0VfQ09NTUFORCIsIkluc2VydElubGluZUltYWdlRGlhbG9nIiwiYWN0aXZlRWRpdG9yIiwib25DbG9zZSIsImhhc01vZGlmaWVyIiwic3JjIiwic2V0U3JjIiwiYWx0VGV4dCIsInNldEFsdFRleHQiLCJzaG93Q2FwdGlvbiIsInNldFNob3dDYXB0aW9uIiwicG9zaXRpb24iLCJzZXRQb3NpdGlvbiIsImlzRGlzYWJsZWQiLCJoYW5kbGVTaG93Q2FwdGlvbkNoYW5nZSIsImUiLCJ0YXJnZXQiLCJjaGVja2VkIiwiaGFuZGxlUG9zaXRpb25DaGFuZ2UiLCJ2YWx1ZSIsImxvYWRJbWFnZSIsImZpbGVzIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsInJlc3VsdCIsInJlYWRBc0RhdGFVUkwiLCJjdXJyZW50IiwiaGFuZGxlciIsImFsdEtleSIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVPbkNsaWNrIiwicGF5bG9hZCIsImRpc3BhdGNoQ29tbWFuZCIsImRpdiIsInN0eWxlIiwibWFyZ2luQm90dG9tIiwibGFiZWwiLCJvbkNoYW5nZSIsImFjY2VwdCIsImRhdGEtdGVzdC1pZCIsInBsYWNlaG9sZGVyIiwid2lkdGgiLCJuYW1lIiwiaWQiLCJvcHRpb24iLCJjbGFzc05hbWUiLCJpbnB1dCIsInR5cGUiLCJodG1sRm9yIiwiZGlzYWJsZWQiLCJvbkNsaWNrIiwiSW5saW5lSW1hZ2VQbHVnaW4iLCJjYXB0aW9uc0VuYWJsZWQiLCJlZGl0b3IiLCJoYXNOb2RlcyIsIklubGluZUltYWdlTm9kZSIsIkVycm9yIiwicmVnaXN0ZXJDb21tYW5kIiwiaW1hZ2VOb2RlIiwiZ2V0UGFyZW50T3JUaHJvdyIsInNlbGVjdEVuZCIsImV2ZW50Iiwib25EcmFnU3RhcnQiLCJvbkRyYWdvdmVyIiwib25Ecm9wIiwibm9kZSIsImdldEltYWdlTm9kZUluU2VsZWN0aW9uIiwiZGF0YVRyYW5zZmVyIiwic2V0RGF0YSIsInNldERyYWdJbWFnZSIsImltZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIiwiX19hbHRUZXh0IiwiY2FwdGlvbiIsIl9fY2FwdGlvbiIsImhlaWdodCIsIl9faGVpZ2h0Iiwia2V5IiwiZ2V0S2V5IiwiX19zaG93Q2FwdGlvbiIsIl9fc3JjIiwiX193aWR0aCIsImNhbkRyb3BJbWFnZSIsInByZXZlbnREZWZhdWx0IiwiZ2V0RHJhZ0ltYWdlRGF0YSIsInJhbmdlIiwiZ2V0RHJhZ1NlbGVjdGlvbiIsInJlbW92ZSIsInJhbmdlU2VsZWN0aW9uIiwidW5kZWZpbmVkIiwiYXBwbHlET01SYW5nZSIsInNlbGVjdGlvbiIsIm5vZGVzIiwiZ2V0Tm9kZXMiLCJkcmFnRGF0YSIsImdldERhdGEiLCJwYXJzZSIsIkhUTUxFbGVtZW50IiwiY2xvc2VzdCIsInBhcmVudEVsZW1lbnQiLCJub2RlVHlwZSIsImRlZmF1bHRWaWV3Iiwib3duZXJEb2N1bWVudCIsImRvbVNlbGVjdGlvbiIsImNhcmV0UmFuZ2VGcm9tUG9pbnQiLCJjbGllbnRYIiwiY2xpZW50WSIsInJhbmdlUGFyZW50IiwiY29sbGFwc2UiLCJyYW5nZU9mZnNldCIsImdldFJhbmdlQXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/plugins/InlineImagePlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/plugins/ToolbarPlugin.js":
/*!*********************************************************!*\
  !*** ./src/components/Lexical/plugins/ToolbarPlugin.js ***!
  \*********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ ToolbarPlugin; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lexical */ \"(app-pages-browser)/./node_modules/lexical/Lexical.js\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lexical__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/link */ \"(app-pages-browser)/./node_modules/@lexical/link/LexicalLink.js\");\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lexical_link__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/selection */ \"(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.js\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lexical_selection__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lexical/utils */ \"(app-pages-browser)/./node_modules/@lexical/utils/LexicalUtils.js\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_lexical_utils__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _lexical_list__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lexical/list */ \"(app-pages-browser)/./node_modules/@lexical/list/LexicalList.js\");\n/* harmony import */ var _lexical_list__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_lexical_list__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lexical/rich-text */ \"(app-pages-browser)/./node_modules/@lexical/rich-text/LexicalRichText.js\");\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_lexical_rich_text__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _lexical_code__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lexical/code */ \"(app-pages-browser)/./node_modules/@lexical/code/LexicalCode.js\");\n/* harmony import */ var _lexical_code__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_lexical_code__WEBPACK_IMPORTED_MODULE_10__);\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\nconst LowPriority = 1;\nconst supportedBlockTypes = new Set([\n    \"paragraph\",\n    \"quote\",\n    \"code\",\n    \"h1\",\n    \"h2\",\n    \"ul\",\n    \"ol\"\n]);\nconst blockTypeToBlockName = {\n    code: \"Code Block\",\n    h1: \"Large Heading\",\n    h2: \"Small Heading\",\n    h3: \"Heading\",\n    h4: \"Heading\",\n    h5: \"Heading\",\n    ol: \"Numbered List\",\n    paragraph: \"Normal\",\n    quote: \"Quote\",\n    ul: \"Bulleted List\"\n};\nfunction Divider() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"divider\"\n    }, void 0, false, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n        lineNumber: 69,\n        columnNumber: 10\n    }, this);\n}\n_c = Divider;\nfunction positionEditorElement(editor, rect) {\n    if (rect === null) {\n        editor.style.opacity = \"0\";\n        editor.style.top = \"-1000px\";\n        editor.style.left = \"-1000px\";\n    } else {\n        editor.style.opacity = \"1\";\n        editor.style.top = \"\".concat(rect.top + rect.height + window.pageYOffset + 10, \"px\");\n        editor.style.left = \"\".concat(rect.left + window.pageXOffset - editor.offsetWidth / 2 + rect.width / 2, \"px\");\n    }\n}\nfunction FloatingLinkEditor(param) {\n    let { editor } = param;\n    _s();\n    const editorRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const inputRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const mouseDownRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(false);\n    const [linkUrl, setLinkUrl] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [isEditMode, setEditMode] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [lastSelection, setLastSelection] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const updateLinkEditor = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(()=>{\n        const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getSelection)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isRangeSelection)(selection)) {\n            const node = getSelectedNode(selection);\n            const parent = node.getParent();\n            if ((0,_lexical_link__WEBPACK_IMPORTED_MODULE_4__.$isLinkNode)(parent)) {\n                setLinkUrl(parent.getURL());\n            } else if ((0,_lexical_link__WEBPACK_IMPORTED_MODULE_4__.$isLinkNode)(node)) {\n                setLinkUrl(node.getURL());\n            } else {\n                setLinkUrl(\"\");\n            }\n        }\n        const editorElem = editorRef.current;\n        const nativeSelection = window.getSelection();\n        const activeElement = document.activeElement;\n        if (editorElem === null) {\n            return;\n        }\n        const rootElement = editor.getRootElement();\n        if (selection !== null && !nativeSelection.isCollapsed && rootElement !== null && rootElement.contains(nativeSelection.anchorNode)) {\n            const domRange = nativeSelection.getRangeAt(0);\n            let rect;\n            if (nativeSelection.anchorNode === rootElement) {\n                let inner = rootElement;\n                while(inner.firstElementChild != null){\n                    inner = inner.firstElementChild;\n                }\n                rect = inner.getBoundingClientRect();\n            } else {\n                rect = domRange.getBoundingClientRect();\n            }\n            if (!mouseDownRef.current) {\n                positionEditorElement(editorElem, rect);\n            }\n            setLastSelection(selection);\n        } else if (!activeElement || activeElement.className !== \"link-input\") {\n            positionEditorElement(editorElem, null);\n            setLastSelection(null);\n            setEditMode(false);\n            setLinkUrl(\"\");\n        }\n        return true;\n    }, [\n        editor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_6__.mergeRegister)(editor.registerUpdateListener((param)=>{\n            let { editorState } = param;\n            editorState.read(()=>{\n                updateLinkEditor();\n            });\n        }), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.SELECTION_CHANGE_COMMAND, ()=>{\n            updateLinkEditor();\n            return true;\n        }, LowPriority));\n    }, [\n        editor,\n        updateLinkEditor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        editor.getEditorState().read(()=>{\n            updateLinkEditor();\n        });\n    }, [\n        editor,\n        updateLinkEditor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        if (isEditMode && inputRef.current) {\n            inputRef.current.focus();\n        }\n    }, [\n        isEditMode\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: editorRef,\n        className: \"link-editor\",\n        children: isEditMode ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n            ref: inputRef,\n            className: \"link-input\",\n            value: linkUrl,\n            onChange: (event)=>{\n                setLinkUrl(event.target.value);\n            },\n            onKeyDown: (event)=>{\n                if (event.key === \"Enter\") {\n                    event.preventDefault();\n                    if (lastSelection !== null) {\n                        if (linkUrl !== \"\") {\n                            editor.dispatchCommand(_lexical_link__WEBPACK_IMPORTED_MODULE_4__.TOGGLE_LINK_COMMAND, linkUrl);\n                        }\n                        setEditMode(false);\n                    }\n                } else if (event.key === \"Escape\") {\n                    event.preventDefault();\n                    setEditMode(false);\n                }\n            }\n        }, void 0, false, {\n            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n            lineNumber: 181,\n            columnNumber: 9\n        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"link-input\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                        href: linkUrl,\n                        target: \"_blank\",\n                        rel: \"noopener noreferrer\",\n                        children: linkUrl\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 206,\n                        columnNumber: 13\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"link-edit\",\n                        role: \"button\",\n                        tabIndex: 0,\n                        onMouseDown: (event)=>event.preventDefault(),\n                        onClick: ()=>{\n                            setEditMode(true);\n                        }\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 209,\n                        columnNumber: 13\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                lineNumber: 205,\n                columnNumber: 11\n            }, this)\n        }, void 0, false)\n    }, void 0, false, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n        lineNumber: 179,\n        columnNumber: 5\n    }, this);\n}\n_s(FloatingLinkEditor, \"IFsS9uaNOKgBG2GtvqhAcvYWs20=\");\n_c1 = FloatingLinkEditor;\nfunction Select(param) {\n    let { onChange, className, options, value } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n        className: className,\n        onChange: onChange,\n        value: value,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                hidden: true,\n                value: \"\"\n            }, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                lineNumber: 228,\n                columnNumber: 7\n            }, this),\n            options.map((option)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                    value: option,\n                    children: option\n                }, option, false, {\n                    fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                    lineNumber: 230,\n                    columnNumber: 9\n                }, this))\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n        lineNumber: 227,\n        columnNumber: 5\n    }, this);\n}\n_c2 = Select;\nfunction getSelectedNode(selection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (anchorNode === focusNode) {\n        return anchorNode;\n    }\n    const isBackward = selection.isBackward();\n    if (isBackward) {\n        return (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_5__.$isAtNodeEnd)(focus) ? anchorNode : focusNode;\n    } else {\n        return (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_5__.$isAtNodeEnd)(anchor) ? focusNode : anchorNode;\n    }\n}\nfunction BlockOptionsDropdownList(param) {\n    let { editor, blockType, toolbarRef, setShowBlockOptionsDropDown } = param;\n    _s1();\n    const dropDownRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        const toolbar = toolbarRef.current;\n        const dropDown = dropDownRef.current;\n        if (toolbar !== null && dropDown !== null) {\n            const { top, left } = toolbar.getBoundingClientRect();\n            dropDown.style.top = \"\".concat(top + 40, \"px\");\n            dropDown.style.left = \"\".concat(left, \"px\");\n        }\n    }, [\n        dropDownRef,\n        toolbarRef\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        const dropDown = dropDownRef.current;\n        const toolbar = toolbarRef.current;\n        if (dropDown !== null && toolbar !== null) {\n            const handle = (event)=>{\n                const target = event.target;\n                if (!dropDown.contains(target) && !toolbar.contains(target)) {\n                    setShowBlockOptionsDropDown(false);\n                }\n            };\n            document.addEventListener(\"click\", handle);\n            return ()=>{\n                document.removeEventListener(\"click\", handle);\n            };\n        }\n    }, [\n        dropDownRef,\n        setShowBlockOptionsDropDown,\n        toolbarRef\n    ]);\n    const formatParagraph = ()=>{\n        if (blockType !== \"paragraph\") {\n            editor.update(()=>{\n                const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getSelection)();\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isRangeSelection)(selection)) {\n                    (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_5__.$wrapNodes)(selection, ()=>(0,lexical__WEBPACK_IMPORTED_MODULE_3__.$createParagraphNode)());\n                }\n            });\n        }\n        setShowBlockOptionsDropDown(false);\n    };\n    const formatLargeHeading = ()=>{\n        if (blockType !== \"h1\") {\n            editor.update(()=>{\n                const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getSelection)();\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isRangeSelection)(selection)) {\n                    (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_5__.$wrapNodes)(selection, ()=>(0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_9__.$createHeadingNode)(\"h1\"));\n                }\n            });\n        }\n        setShowBlockOptionsDropDown(false);\n    };\n    const formatSmallHeading = ()=>{\n        if (blockType !== \"h2\") {\n            editor.update(()=>{\n                const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getSelection)();\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isRangeSelection)(selection)) {\n                    (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_5__.$wrapNodes)(selection, ()=>(0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_9__.$createHeadingNode)(\"h2\"));\n                }\n            });\n        }\n        setShowBlockOptionsDropDown(false);\n    };\n    const formatBulletList = ()=>{\n        if (blockType !== \"ul\") {\n            editor.dispatchCommand(_lexical_list__WEBPACK_IMPORTED_MODULE_7__.INSERT_UNORDERED_LIST_COMMAND);\n        } else {\n            editor.dispatchCommand(_lexical_list__WEBPACK_IMPORTED_MODULE_7__.REMOVE_LIST_COMMAND);\n        }\n        setShowBlockOptionsDropDown(false);\n    };\n    const formatNumberedList = ()=>{\n        if (blockType !== \"ol\") {\n            editor.dispatchCommand(_lexical_list__WEBPACK_IMPORTED_MODULE_7__.INSERT_ORDERED_LIST_COMMAND);\n        } else {\n            editor.dispatchCommand(_lexical_list__WEBPACK_IMPORTED_MODULE_7__.REMOVE_LIST_COMMAND);\n        }\n        setShowBlockOptionsDropDown(false);\n    };\n    const formatQuote = ()=>{\n        if (blockType !== \"quote\") {\n            editor.update(()=>{\n                const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getSelection)();\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isRangeSelection)(selection)) {\n                    (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_5__.$wrapNodes)(selection, ()=>(0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_9__.$createQuoteNode)());\n                }\n            });\n        }\n        setShowBlockOptionsDropDown(false);\n    };\n    const formatCode = ()=>{\n        if (blockType !== \"code\") {\n            editor.update(()=>{\n                const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getSelection)();\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isRangeSelection)(selection)) {\n                    (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_5__.$wrapNodes)(selection, ()=>(0,_lexical_code__WEBPACK_IMPORTED_MODULE_10__.$createCodeNode)());\n                }\n            });\n        }\n        setShowBlockOptionsDropDown(false);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"toolBardropdown\",\n        ref: dropDownRef,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                className: \"item\",\n                onClick: formatParagraph,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"icon paragraph\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 379,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text\",\n                        children: \"Normal\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 380,\n                        columnNumber: 9\n                    }, this),\n                    blockType === \"paragraph\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"active\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 381,\n                        columnNumber: 39\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                lineNumber: 378,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                className: \"item\",\n                onClick: formatLargeHeading,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"icon large-heading\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 384,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text\",\n                        children: \"Large Heading\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 385,\n                        columnNumber: 9\n                    }, this),\n                    blockType === \"h1\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"active\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 386,\n                        columnNumber: 32\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                lineNumber: 383,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                className: \"item\",\n                onClick: formatSmallHeading,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"icon small-heading\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 389,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text\",\n                        children: \"Small Heading\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 390,\n                        columnNumber: 9\n                    }, this),\n                    blockType === \"h2\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"active\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 391,\n                        columnNumber: 32\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                lineNumber: 388,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                className: \"item\",\n                onClick: formatBulletList,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"icon bullet-list\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 394,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text\",\n                        children: \"Bullet List\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 395,\n                        columnNumber: 9\n                    }, this),\n                    blockType === \"ul\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"active\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 396,\n                        columnNumber: 32\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                lineNumber: 393,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                className: \"item\",\n                onClick: formatNumberedList,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"icon numbered-list\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 399,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text\",\n                        children: \"Numbered List\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 400,\n                        columnNumber: 9\n                    }, this),\n                    blockType === \"ol\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"active\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 401,\n                        columnNumber: 32\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                lineNumber: 398,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                className: \"item\",\n                onClick: formatQuote,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"icon quote\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 404,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text\",\n                        children: \"Quote\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 405,\n                        columnNumber: 9\n                    }, this),\n                    blockType === \"quote\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"active\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 406,\n                        columnNumber: 35\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                lineNumber: 403,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                className: \"item\",\n                onClick: formatCode,\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"icon code\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 409,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text\",\n                        children: \"Code Block\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 410,\n                        columnNumber: 9\n                    }, this),\n                    blockType === \"code\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"active\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 411,\n                        columnNumber: 34\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                lineNumber: 408,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n        lineNumber: 377,\n        columnNumber: 5\n    }, this);\n}\n_s1(BlockOptionsDropdownList, \"WaViSY3KSqR6IXk3ZFTwt9SmYC4=\");\n_c3 = BlockOptionsDropdownList;\nfunction ToolbarPlugin() {\n    _s2();\n    const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext)();\n    const toolbarRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const [canUndo, setCanUndo] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [canRedo, setCanRedo] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [blockType, setBlockType] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"paragraph\");\n    const [selectedElementKey, setSelectedElementKey] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [showBlockOptionsDropDown, setShowBlockOptionsDropDown] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [codeLanguage, setCodeLanguage] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [isRTL, setIsRTL] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [isLink, setIsLink] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [isBold, setIsBold] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [isItalic, setIsItalic] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [isUnderline, setIsUnderline] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [isStrikethrough, setIsStrikethrough] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [isCode, setIsCode] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const updateToolbar = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(()=>{\n        const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getSelection)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isRangeSelection)(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            const element = anchorNode.getKey() === \"root\" ? anchorNode : anchorNode.getTopLevelElementOrThrow();\n            const elementKey = element.getKey();\n            const elementDOM = editor.getElementByKey(elementKey);\n            if (elementDOM !== null) {\n                setSelectedElementKey(elementKey);\n                if ((0,_lexical_list__WEBPACK_IMPORTED_MODULE_7__.$isListNode)(element)) {\n                    const parentList = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_6__.$getNearestNodeOfType)(anchorNode, _lexical_list__WEBPACK_IMPORTED_MODULE_7__.ListNode);\n                    const type = parentList ? parentList.getTag() : element.getTag();\n                    setBlockType(type);\n                } else {\n                    const type = (0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_9__.$isHeadingNode)(element) ? element.getTag() : element.getType();\n                    setBlockType(type);\n                    if ((0,_lexical_code__WEBPACK_IMPORTED_MODULE_10__.$isCodeNode)(element)) {\n                        setCodeLanguage(element.getLanguage() || (0,_lexical_code__WEBPACK_IMPORTED_MODULE_10__.getDefaultCodeLanguage)());\n                    }\n                }\n            }\n            // Update text format\n            setIsBold(selection.hasFormat(\"bold\"));\n            setIsItalic(selection.hasFormat(\"italic\"));\n            setIsUnderline(selection.hasFormat(\"underline\"));\n            setIsStrikethrough(selection.hasFormat(\"strikethrough\"));\n            setIsCode(selection.hasFormat(\"code\"));\n            setIsRTL((0,_lexical_selection__WEBPACK_IMPORTED_MODULE_5__.$isParentElementRTL)(selection));\n            // Update links\n            const node = getSelectedNode(selection);\n            const parent = node.getParent();\n            if ((0,_lexical_link__WEBPACK_IMPORTED_MODULE_4__.$isLinkNode)(parent) || (0,_lexical_link__WEBPACK_IMPORTED_MODULE_4__.$isLinkNode)(node)) {\n                setIsLink(true);\n            } else {\n                setIsLink(false);\n            }\n        }\n    }, [\n        editor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_6__.mergeRegister)(editor.registerUpdateListener((param)=>{\n            let { editorState } = param;\n            editorState.read(()=>{\n                updateToolbar();\n            });\n        }), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.SELECTION_CHANGE_COMMAND, (_payload, newEditor)=>{\n            updateToolbar();\n            return false;\n        }, LowPriority), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.CAN_UNDO_COMMAND, (payload)=>{\n            setCanUndo(payload);\n            return false;\n        }, LowPriority), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.CAN_REDO_COMMAND, (payload)=>{\n            setCanRedo(payload);\n            return false;\n        }, LowPriority));\n    }, [\n        editor,\n        updateToolbar\n    ]);\n    const codeLanguges = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)(()=>(0,_lexical_code__WEBPACK_IMPORTED_MODULE_10__.getCodeLanguages)(), []);\n    const onCodeLanguageSelect = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)((e)=>{\n        editor.update(()=>{\n            if (selectedElementKey !== null) {\n                const node = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getNodeByKey)(selectedElementKey);\n                if ((0,_lexical_code__WEBPACK_IMPORTED_MODULE_10__.$isCodeNode)(node)) {\n                    node.setLanguage(e.target.value);\n                }\n            }\n        });\n    }, [\n        editor,\n        selectedElementKey\n    ]);\n    const insertLink = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(()=>{\n        if (!isLink) {\n            editor.dispatchCommand(_lexical_link__WEBPACK_IMPORTED_MODULE_4__.TOGGLE_LINK_COMMAND, \"https://\");\n        } else {\n            editor.dispatchCommand(_lexical_link__WEBPACK_IMPORTED_MODULE_4__.TOGGLE_LINK_COMMAND, null);\n        }\n    }, [\n        editor,\n        isLink\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"toolbar\",\n        ref: toolbarRef,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                disabled: !canUndo,\n                onClick: ()=>{\n                    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.UNDO_COMMAND);\n                },\n                className: \"toolbar-item spaced\",\n                \"aria-label\": \"Undo\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                    className: \"format undo\"\n                }, void 0, false, {\n                    fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                    lineNumber: 548,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                lineNumber: 540,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                disabled: !canRedo,\n                onClick: ()=>{\n                    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.REDO_COMMAND);\n                },\n                className: \"toolbar-item\",\n                \"aria-label\": \"Redo\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                    className: \"format redo\"\n                }, void 0, false, {\n                    fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                    lineNumber: 558,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                lineNumber: 550,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Divider, {}, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                lineNumber: 560,\n                columnNumber: 7\n            }, this),\n            supportedBlockTypes.has(blockType) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"toolbar-item block-controls\",\n                        onClick: ()=>setShowBlockOptionsDropDown(!showBlockOptionsDropDown),\n                        \"aria-label\": \"Formatting Options\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"icon block-type \" + blockType\n                            }, void 0, false, {\n                                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                                lineNumber: 570,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"text\",\n                                children: blockTypeToBlockName[blockType]\n                            }, void 0, false, {\n                                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                                lineNumber: 571,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                                className: \"chevron-down\"\n                            }, void 0, false, {\n                                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                                lineNumber: 572,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 563,\n                        columnNumber: 11\n                    }, this),\n                    showBlockOptionsDropDown && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_8__.createPortal)(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(BlockOptionsDropdownList, {\n                        editor: editor,\n                        blockType: blockType,\n                        toolbarRef: toolbarRef,\n                        setShowBlockOptionsDropDown: setShowBlockOptionsDropDown\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 576,\n                        columnNumber: 15\n                    }, this), document.body),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Divider, {}, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 584,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true),\n            blockType === \"code\" ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Select, {\n                        className: \"toolbar-item code-language\",\n                        onChange: onCodeLanguageSelect,\n                        options: codeLanguges,\n                        value: codeLanguage\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 589,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                        className: \"chevron-down inside\"\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 595,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>{\n                            editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.FORMAT_TEXT_COMMAND, \"bold\");\n                        },\n                        className: \"toolbar-item spaced \" + (isBold ? \"active\" : \"\"),\n                        \"aria-label\": \"Format Bold\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                            className: \"format bold\"\n                        }, void 0, false, {\n                            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                            lineNumber: 606,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 599,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>{\n                            editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.FORMAT_TEXT_COMMAND, \"italic\");\n                        },\n                        className: \"toolbar-item spaced \" + (isItalic ? \"active\" : \"\"),\n                        \"aria-label\": \"Format Italics\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                            className: \"format italic\"\n                        }, void 0, false, {\n                            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                            lineNumber: 615,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 608,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>{\n                            editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.FORMAT_TEXT_COMMAND, \"underline\");\n                        },\n                        className: \"toolbar-item spaced \" + (isUnderline ? \"active\" : \"\"),\n                        \"aria-label\": \"Format Underline\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                            className: \"format underline\"\n                        }, void 0, false, {\n                            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                            lineNumber: 624,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 617,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>{\n                            editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.FORMAT_TEXT_COMMAND, \"strikethrough\");\n                        },\n                        className: \"toolbar-item spaced \" + (isStrikethrough ? \"active\" : \"\"),\n                        \"aria-label\": \"Format Strikethrough\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                            className: \"format strikethrough\"\n                        }, void 0, false, {\n                            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                            lineNumber: 635,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 626,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>{\n                            editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.FORMAT_TEXT_COMMAND, \"code\");\n                        },\n                        className: \"toolbar-item spaced \" + (isCode ? \"active\" : \"\"),\n                        \"aria-label\": \"Insert Code\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                            className: \"format code\"\n                        }, void 0, false, {\n                            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                            lineNumber: 644,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 637,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: insertLink,\n                        className: \"toolbar-item spaced \" + (isLink ? \"active\" : \"\"),\n                        \"aria-label\": \"Insert Link\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                            className: \"format link\"\n                        }, void 0, false, {\n                            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                            lineNumber: 651,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 646,\n                        columnNumber: 11\n                    }, this),\n                    isLink && /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_8__.createPortal)(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(FloatingLinkEditor, {\n                        editor: editor\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 654,\n                        columnNumber: 26\n                    }, this), document.body),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Divider, {}, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 655,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>{\n                            editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.FORMAT_ELEMENT_COMMAND, \"left\");\n                        },\n                        className: \"toolbar-item spaced\",\n                        \"aria-label\": \"Left Align\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                            className: \"format left-align\"\n                        }, void 0, false, {\n                            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                            lineNumber: 663,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 656,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>{\n                            editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.FORMAT_ELEMENT_COMMAND, \"center\");\n                        },\n                        className: \"toolbar-item spaced\",\n                        \"aria-label\": \"Center Align\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                            className: \"format center-align\"\n                        }, void 0, false, {\n                            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                            lineNumber: 672,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 665,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>{\n                            editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.FORMAT_ELEMENT_COMMAND, \"right\");\n                        },\n                        className: \"toolbar-item spaced\",\n                        \"aria-label\": \"Right Align\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                            className: \"format right-align\"\n                        }, void 0, false, {\n                            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                            lineNumber: 681,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 674,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>{\n                            editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_3__.FORMAT_ELEMENT_COMMAND, \"justify\");\n                        },\n                        className: \"toolbar-item\",\n                        \"aria-label\": \"Justify Align\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"i\", {\n                            className: \"format justify-align\"\n                        }, void 0, false, {\n                            fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                            lineNumber: 690,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n                        lineNumber: 683,\n                        columnNumber: 11\n                    }, this),\n                    \" \"\n                ]\n            }, void 0, true)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/ToolbarPlugin.js\",\n        lineNumber: 539,\n        columnNumber: 5\n    }, this);\n}\n_s2(ToolbarPlugin, \"dvTKY96RDqelk5BFKAU0bevc3Po=\", false, function() {\n    return [\n        _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext\n    ];\n});\n_c4 = ToolbarPlugin;\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"Divider\");\n$RefreshReg$(_c1, \"FloatingLinkEditor\");\n$RefreshReg$(_c2, \"Select\");\n$RefreshReg$(_c3, \"BlockOptionsDropdownList\");\n$RefreshReg$(_c4, \"ToolbarPlugin\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvcGx1Z2lucy9Ub29sYmFyUGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtGO0FBQ1I7QUFhekQ7QUFDZ0Q7QUFLckM7QUFDMEM7QUFPL0M7QUFDa0I7QUFLYjtBQU1MO0FBRXZCLE1BQU1xQyxjQUFjO0FBRXBCLE1BQU1DLHNCQUFzQixJQUFJQyxJQUFJO0lBQ2xDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCxNQUFNQyx1QkFBdUI7SUFDM0JDLE1BQU07SUFDTkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsSUFBSTtJQUNKQyxJQUFJO0lBQ0pDLElBQUk7SUFDSkMsV0FBVztJQUNYQyxPQUFPO0lBQ1BDLElBQUk7QUFDTjtBQUVBLFNBQVNDO0lBQ1AscUJBQU8sOERBQUNDO1FBQUlDLFdBQVU7Ozs7OztBQUN4QjtLQUZTRjtBQUlULFNBQVNHLHNCQUFzQkMsTUFBTSxFQUFFQyxJQUFJO0lBQ3pDLElBQUlBLFNBQVMsTUFBTTtRQUNqQkQsT0FBT0UsS0FBSyxDQUFDQyxPQUFPLEdBQUc7UUFDdkJILE9BQU9FLEtBQUssQ0FBQ0UsR0FBRyxHQUFHO1FBQ25CSixPQUFPRSxLQUFLLENBQUNHLElBQUksR0FBRztJQUN0QixPQUFPO1FBQ0xMLE9BQU9FLEtBQUssQ0FBQ0MsT0FBTyxHQUFHO1FBQ3ZCSCxPQUFPRSxLQUFLLENBQUNFLEdBQUcsR0FBRyxHQUFvRCxPQUFqREgsS0FBS0csR0FBRyxHQUFHSCxLQUFLSyxNQUFNLEdBQUdDLE9BQU9DLFdBQVcsR0FBRyxJQUFHO1FBQ3ZFUixPQUFPRSxLQUFLLENBQUNHLElBQUksR0FBRyxHQUNqQixPQURvQkosS0FBS0ksSUFBSSxHQUFHRSxPQUFPRSxXQUFXLEdBQUdULE9BQU9VLFdBQVcsR0FBRyxJQUFJVCxLQUFLVSxLQUFLLEdBQUcsR0FDM0Y7SUFDTDtBQUNGO0FBRUEsU0FBU0MsbUJBQW1CLEtBQVU7UUFBVixFQUFFWixNQUFNLEVBQUUsR0FBVjs7SUFDMUIsTUFBTWEsWUFBWWhFLDZDQUFNQSxDQUFDO0lBQ3pCLE1BQU1pRSxXQUFXakUsNkNBQU1BLENBQUM7SUFDeEIsTUFBTWtFLGVBQWVsRSw2Q0FBTUEsQ0FBQztJQUM1QixNQUFNLENBQUNtRSxTQUFTQyxXQUFXLEdBQUduRSwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNvRSxZQUFZQyxZQUFZLEdBQUdyRSwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNzRSxlQUFlQyxpQkFBaUIsR0FBR3ZFLCtDQUFRQSxDQUFDO0lBRW5ELE1BQU13RSxtQkFBbUI1RSxrREFBV0EsQ0FBQztRQUNuQyxNQUFNNkUsWUFBWWpFLHNEQUFhQTtRQUMvQixJQUFJQywwREFBaUJBLENBQUNnRSxZQUFZO1lBQ2hDLE1BQU1DLE9BQU9DLGdCQUFnQkY7WUFDN0IsTUFBTUcsU0FBU0YsS0FBS0csU0FBUztZQUM3QixJQUFJakUsMERBQVdBLENBQUNnRSxTQUFTO2dCQUN2QlQsV0FBV1MsT0FBT0UsTUFBTTtZQUMxQixPQUFPLElBQUlsRSwwREFBV0EsQ0FBQzhELE9BQU87Z0JBQzVCUCxXQUFXTyxLQUFLSSxNQUFNO1lBQ3hCLE9BQU87Z0JBQ0xYLFdBQVc7WUFDYjtRQUNGO1FBQ0EsTUFBTVksYUFBYWhCLFVBQVVpQixPQUFPO1FBQ3BDLE1BQU1DLGtCQUFrQnhCLE9BQU95QixZQUFZO1FBQzNDLE1BQU1DLGdCQUFnQkMsU0FBU0QsYUFBYTtRQUU1QyxJQUFJSixlQUFlLE1BQU07WUFDdkI7UUFDRjtRQUVBLE1BQU1NLGNBQWNuQyxPQUFPb0MsY0FBYztRQUN6QyxJQUNFYixjQUFjLFFBQ2QsQ0FBQ1EsZ0JBQWdCTSxXQUFXLElBQzVCRixnQkFBZ0IsUUFDaEJBLFlBQVlHLFFBQVEsQ0FBQ1AsZ0JBQWdCUSxVQUFVLEdBQy9DO1lBQ0EsTUFBTUMsV0FBV1QsZ0JBQWdCVSxVQUFVLENBQUM7WUFDNUMsSUFBSXhDO1lBQ0osSUFBSThCLGdCQUFnQlEsVUFBVSxLQUFLSixhQUFhO2dCQUM5QyxJQUFJTyxRQUFRUDtnQkFDWixNQUFPTyxNQUFNQyxpQkFBaUIsSUFBSSxLQUFNO29CQUN0Q0QsUUFBUUEsTUFBTUMsaUJBQWlCO2dCQUNqQztnQkFDQTFDLE9BQU95QyxNQUFNRSxxQkFBcUI7WUFDcEMsT0FBTztnQkFDTDNDLE9BQU91QyxTQUFTSSxxQkFBcUI7WUFDdkM7WUFFQSxJQUFJLENBQUM3QixhQUFhZSxPQUFPLEVBQUU7Z0JBQ3pCL0Isc0JBQXNCOEIsWUFBWTVCO1lBQ3BDO1lBQ0FvQixpQkFBaUJFO1FBQ25CLE9BQU8sSUFBSSxDQUFDVSxpQkFBaUJBLGNBQWNuQyxTQUFTLEtBQUssY0FBYztZQUNyRUMsc0JBQXNCOEIsWUFBWTtZQUNsQ1IsaUJBQWlCO1lBQ2pCRixZQUFZO1lBQ1pGLFdBQVc7UUFDYjtRQUVBLE9BQU87SUFDVCxHQUFHO1FBQUNqQjtLQUFPO0lBRVhyRCxnREFBU0EsQ0FBQztRQUNSLE9BQU9xQiw2REFBYUEsQ0FDbEJnQyxPQUFPNkMsc0JBQXNCLENBQUM7Z0JBQUMsRUFBRUMsV0FBVyxFQUFFO1lBQzVDQSxZQUFZQyxJQUFJLENBQUM7Z0JBQ2Z6QjtZQUNGO1FBQ0YsSUFFQXRCLE9BQU9nRCxlQUFlLENBQ3BCN0YsNkRBQXdCQSxFQUN4QjtZQUNFbUU7WUFDQSxPQUFPO1FBQ1QsR0FDQXhDO0lBR04sR0FBRztRQUFDa0I7UUFBUXNCO0tBQWlCO0lBRTdCM0UsZ0RBQVNBLENBQUM7UUFDUnFELE9BQU9pRCxjQUFjLEdBQUdGLElBQUksQ0FBQztZQUMzQnpCO1FBQ0Y7SUFDRixHQUFHO1FBQUN0QjtRQUFRc0I7S0FBaUI7SUFFN0IzRSxnREFBU0EsQ0FBQztRQUNSLElBQUl1RSxjQUFjSixTQUFTZ0IsT0FBTyxFQUFFO1lBQ2xDaEIsU0FBU2dCLE9BQU8sQ0FBQ29CLEtBQUs7UUFDeEI7SUFDRixHQUFHO1FBQUNoQztLQUFXO0lBRWYscUJBQ0UsOERBQUNyQjtRQUFJc0QsS0FBS3RDO1FBQVdmLFdBQVU7a0JBQzVCb0IsMkJBQ0MsOERBQUNrQztZQUNDRCxLQUFLckM7WUFDTGhCLFdBQVU7WUFDVnVELE9BQU9yQztZQUNQc0MsVUFBVSxDQUFDQztnQkFDVHRDLFdBQVdzQyxNQUFNQyxNQUFNLENBQUNILEtBQUs7WUFDL0I7WUFDQUksV0FBVyxDQUFDRjtnQkFDVixJQUFJQSxNQUFNRyxHQUFHLEtBQUssU0FBUztvQkFDekJILE1BQU1JLGNBQWM7b0JBQ3BCLElBQUl2QyxrQkFBa0IsTUFBTTt3QkFDMUIsSUFBSUosWUFBWSxJQUFJOzRCQUNsQmhCLE9BQU80RCxlQUFlLENBQUNqRyw4REFBbUJBLEVBQUVxRDt3QkFDOUM7d0JBQ0FHLFlBQVk7b0JBQ2Q7Z0JBQ0YsT0FBTyxJQUFJb0MsTUFBTUcsR0FBRyxLQUFLLFVBQVU7b0JBQ2pDSCxNQUFNSSxjQUFjO29CQUNwQnhDLFlBQVk7Z0JBQ2Q7WUFDRjs7Ozs7aUNBR0Y7c0JBQ0UsNEVBQUN0QjtnQkFBSUMsV0FBVTs7a0NBQ2IsOERBQUMrRDt3QkFBRUMsTUFBTTlDO3dCQUFTd0MsUUFBTzt3QkFBU08sS0FBSTtrQ0FDbkMvQzs7Ozs7O2tDQUVILDhEQUFDbkI7d0JBQ0NDLFdBQVU7d0JBQ1ZrRSxNQUFLO3dCQUNMQyxVQUFVO3dCQUNWQyxhQUFhLENBQUNYLFFBQVVBLE1BQU1JLGNBQWM7d0JBQzVDUSxTQUFTOzRCQUNQaEQsWUFBWTt3QkFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBT2Q7R0ExSVNQO01BQUFBO0FBNElULFNBQVN3RCxPQUFPLEtBQXVDO1FBQXZDLEVBQUVkLFFBQVEsRUFBRXhELFNBQVMsRUFBRXVFLE9BQU8sRUFBRWhCLEtBQUssRUFBRSxHQUF2QztJQUNkLHFCQUNFLDhEQUFDaUI7UUFBT3hFLFdBQVdBO1FBQVd3RCxVQUFVQTtRQUFVRCxPQUFPQTs7MEJBQ3ZELDhEQUFDa0I7Z0JBQU9DLFFBQVE7Z0JBQU1uQixPQUFNOzs7Ozs7WUFDM0JnQixRQUFRSSxHQUFHLENBQUMsQ0FBQ0YsdUJBQ1osOERBQUNBO29CQUFvQmxCLE9BQU9rQjs4QkFDekJBO21CQURVQTs7Ozs7Ozs7Ozs7QUFNckI7TUFYU0g7QUFhVCxTQUFTM0MsZ0JBQWdCRixTQUFTO0lBQ2hDLE1BQU1tRCxTQUFTbkQsVUFBVW1ELE1BQU07SUFDL0IsTUFBTXhCLFFBQVEzQixVQUFVMkIsS0FBSztJQUM3QixNQUFNWCxhQUFhaEIsVUFBVW1ELE1BQU0sQ0FBQ0MsT0FBTztJQUMzQyxNQUFNQyxZQUFZckQsVUFBVTJCLEtBQUssQ0FBQ3lCLE9BQU87SUFDekMsSUFBSXBDLGVBQWVxQyxXQUFXO1FBQzVCLE9BQU9yQztJQUNUO0lBQ0EsTUFBTXNDLGFBQWF0RCxVQUFVc0QsVUFBVTtJQUN2QyxJQUFJQSxZQUFZO1FBQ2QsT0FBTy9HLGdFQUFZQSxDQUFDb0YsU0FBU1gsYUFBYXFDO0lBQzVDLE9BQU87UUFDTCxPQUFPOUcsZ0VBQVlBLENBQUM0RyxVQUFVRSxZQUFZckM7SUFDNUM7QUFDRjtBQUVBLFNBQVN1Qyx5QkFBeUIsS0FLakM7UUFMaUMsRUFDaEM5RSxNQUFNLEVBQ04rRSxTQUFTLEVBQ1RDLFVBQVUsRUFDVkMsMkJBQTJCLEVBQzVCLEdBTGlDOztJQU1oQyxNQUFNQyxjQUFjckksNkNBQU1BLENBQUM7SUFFM0JGLGdEQUFTQSxDQUFDO1FBQ1IsTUFBTXdJLFVBQVVILFdBQVdsRCxPQUFPO1FBQ2xDLE1BQU1zRCxXQUFXRixZQUFZcEQsT0FBTztRQUVwQyxJQUFJcUQsWUFBWSxRQUFRQyxhQUFhLE1BQU07WUFDekMsTUFBTSxFQUFFaEYsR0FBRyxFQUFFQyxJQUFJLEVBQUUsR0FBRzhFLFFBQVF2QyxxQkFBcUI7WUFDbkR3QyxTQUFTbEYsS0FBSyxDQUFDRSxHQUFHLEdBQUcsR0FBWSxPQUFUQSxNQUFNLElBQUc7WUFDakNnRixTQUFTbEYsS0FBSyxDQUFDRyxJQUFJLEdBQUcsR0FBUSxPQUFMQSxNQUFLO1FBQ2hDO0lBQ0YsR0FBRztRQUFDNkU7UUFBYUY7S0FBVztJQUU1QnJJLGdEQUFTQSxDQUFDO1FBQ1IsTUFBTXlJLFdBQVdGLFlBQVlwRCxPQUFPO1FBQ3BDLE1BQU1xRCxVQUFVSCxXQUFXbEQsT0FBTztRQUVsQyxJQUFJc0QsYUFBYSxRQUFRRCxZQUFZLE1BQU07WUFDekMsTUFBTUUsU0FBUyxDQUFDOUI7Z0JBQ2QsTUFBTUMsU0FBU0QsTUFBTUMsTUFBTTtnQkFFM0IsSUFBSSxDQUFDNEIsU0FBUzlDLFFBQVEsQ0FBQ2tCLFdBQVcsQ0FBQzJCLFFBQVE3QyxRQUFRLENBQUNrQixTQUFTO29CQUMzRHlCLDRCQUE0QjtnQkFDOUI7WUFDRjtZQUNBL0MsU0FBU29ELGdCQUFnQixDQUFDLFNBQVNEO1lBRW5DLE9BQU87Z0JBQ0xuRCxTQUFTcUQsbUJBQW1CLENBQUMsU0FBU0Y7WUFDeEM7UUFDRjtJQUNGLEdBQUc7UUFBQ0g7UUFBYUQ7UUFBNkJEO0tBQVc7SUFFekQsTUFBTVEsa0JBQWtCO1FBQ3RCLElBQUlULGNBQWMsYUFBYTtZQUM3Qi9FLE9BQU95RixNQUFNLENBQUM7Z0JBQ1osTUFBTWxFLFlBQVlqRSxzREFBYUE7Z0JBRS9CLElBQUlDLDBEQUFpQkEsQ0FBQ2dFLFlBQVk7b0JBQ2hDMUQsOERBQVVBLENBQUMwRCxXQUFXLElBQU0vRCw2REFBb0JBO2dCQUNsRDtZQUNGO1FBQ0Y7UUFDQXlILDRCQUE0QjtJQUM5QjtJQUVBLE1BQU1TLHFCQUFxQjtRQUN6QixJQUFJWCxjQUFjLE1BQU07WUFDdEIvRSxPQUFPeUYsTUFBTSxDQUFDO2dCQUNaLE1BQU1sRSxZQUFZakUsc0RBQWFBO2dCQUUvQixJQUFJQywwREFBaUJBLENBQUNnRSxZQUFZO29CQUNoQzFELDhEQUFVQSxDQUFDMEQsV0FBVyxJQUFNaEQsc0VBQWtCQSxDQUFDO2dCQUNqRDtZQUNGO1FBQ0Y7UUFDQTBHLDRCQUE0QjtJQUM5QjtJQUVBLE1BQU1VLHFCQUFxQjtRQUN6QixJQUFJWixjQUFjLE1BQU07WUFDdEIvRSxPQUFPeUYsTUFBTSxDQUFDO2dCQUNaLE1BQU1sRSxZQUFZakUsc0RBQWFBO2dCQUUvQixJQUFJQywwREFBaUJBLENBQUNnRSxZQUFZO29CQUNoQzFELDhEQUFVQSxDQUFDMEQsV0FBVyxJQUFNaEQsc0VBQWtCQSxDQUFDO2dCQUNqRDtZQUNGO1FBQ0Y7UUFDQTBHLDRCQUE0QjtJQUM5QjtJQUVBLE1BQU1XLG1CQUFtQjtRQUN2QixJQUFJYixjQUFjLE1BQU07WUFDdEIvRSxPQUFPNEQsZUFBZSxDQUFDMUYsd0VBQTZCQTtRQUN0RCxPQUFPO1lBQ0w4QixPQUFPNEQsZUFBZSxDQUFDekYsOERBQW1CQTtRQUM1QztRQUNBOEcsNEJBQTRCO0lBQzlCO0lBRUEsTUFBTVkscUJBQXFCO1FBQ3pCLElBQUlkLGNBQWMsTUFBTTtZQUN0Qi9FLE9BQU80RCxlQUFlLENBQUMzRixzRUFBMkJBO1FBQ3BELE9BQU87WUFDTCtCLE9BQU80RCxlQUFlLENBQUN6Riw4REFBbUJBO1FBQzVDO1FBQ0E4Ryw0QkFBNEI7SUFDOUI7SUFFQSxNQUFNYSxjQUFjO1FBQ2xCLElBQUlmLGNBQWMsU0FBUztZQUN6Qi9FLE9BQU95RixNQUFNLENBQUM7Z0JBQ1osTUFBTWxFLFlBQVlqRSxzREFBYUE7Z0JBRS9CLElBQUlDLDBEQUFpQkEsQ0FBQ2dFLFlBQVk7b0JBQ2hDMUQsOERBQVVBLENBQUMwRCxXQUFXLElBQU0vQyxvRUFBZ0JBO2dCQUM5QztZQUNGO1FBQ0Y7UUFDQXlHLDRCQUE0QjtJQUM5QjtJQUVBLE1BQU1jLGFBQWE7UUFDakIsSUFBSWhCLGNBQWMsUUFBUTtZQUN4Qi9FLE9BQU95RixNQUFNLENBQUM7Z0JBQ1osTUFBTWxFLFlBQVlqRSxzREFBYUE7Z0JBRS9CLElBQUlDLDBEQUFpQkEsQ0FBQ2dFLFlBQVk7b0JBQ2hDMUQsOERBQVVBLENBQUMwRCxXQUFXLElBQU03QywrREFBZUE7Z0JBQzdDO1lBQ0Y7UUFDRjtRQUNBdUcsNEJBQTRCO0lBQzlCO0lBRUEscUJBQ0UsOERBQUNwRjtRQUFJQyxXQUFVO1FBQWtCcUQsS0FBSytCOzswQkFDcEMsOERBQUNjO2dCQUFPbEcsV0FBVTtnQkFBT3FFLFNBQVNxQjs7a0NBQ2hDLDhEQUFDUzt3QkFBS25HLFdBQVU7Ozs7OztrQ0FDaEIsOERBQUNtRzt3QkFBS25HLFdBQVU7a0NBQU87Ozs7OztvQkFDdEJpRixjQUFjLDZCQUFlLDhEQUFDa0I7d0JBQUtuRyxXQUFVOzs7Ozs7Ozs7Ozs7MEJBRWhELDhEQUFDa0c7Z0JBQU9sRyxXQUFVO2dCQUFPcUUsU0FBU3VCOztrQ0FDaEMsOERBQUNPO3dCQUFLbkcsV0FBVTs7Ozs7O2tDQUNoQiw4REFBQ21HO3dCQUFLbkcsV0FBVTtrQ0FBTzs7Ozs7O29CQUN0QmlGLGNBQWMsc0JBQVEsOERBQUNrQjt3QkFBS25HLFdBQVU7Ozs7Ozs7Ozs7OzswQkFFekMsOERBQUNrRztnQkFBT2xHLFdBQVU7Z0JBQU9xRSxTQUFTd0I7O2tDQUNoQyw4REFBQ007d0JBQUtuRyxXQUFVOzs7Ozs7a0NBQ2hCLDhEQUFDbUc7d0JBQUtuRyxXQUFVO2tDQUFPOzs7Ozs7b0JBQ3RCaUYsY0FBYyxzQkFBUSw4REFBQ2tCO3dCQUFLbkcsV0FBVTs7Ozs7Ozs7Ozs7OzBCQUV6Qyw4REFBQ2tHO2dCQUFPbEcsV0FBVTtnQkFBT3FFLFNBQVN5Qjs7a0NBQ2hDLDhEQUFDSzt3QkFBS25HLFdBQVU7Ozs7OztrQ0FDaEIsOERBQUNtRzt3QkFBS25HLFdBQVU7a0NBQU87Ozs7OztvQkFDdEJpRixjQUFjLHNCQUFRLDhEQUFDa0I7d0JBQUtuRyxXQUFVOzs7Ozs7Ozs7Ozs7MEJBRXpDLDhEQUFDa0c7Z0JBQU9sRyxXQUFVO2dCQUFPcUUsU0FBUzBCOztrQ0FDaEMsOERBQUNJO3dCQUFLbkcsV0FBVTs7Ozs7O2tDQUNoQiw4REFBQ21HO3dCQUFLbkcsV0FBVTtrQ0FBTzs7Ozs7O29CQUN0QmlGLGNBQWMsc0JBQVEsOERBQUNrQjt3QkFBS25HLFdBQVU7Ozs7Ozs7Ozs7OzswQkFFekMsOERBQUNrRztnQkFBT2xHLFdBQVU7Z0JBQU9xRSxTQUFTMkI7O2tDQUNoQyw4REFBQ0c7d0JBQUtuRyxXQUFVOzs7Ozs7a0NBQ2hCLDhEQUFDbUc7d0JBQUtuRyxXQUFVO2tDQUFPOzs7Ozs7b0JBQ3RCaUYsY0FBYyx5QkFBVyw4REFBQ2tCO3dCQUFLbkcsV0FBVTs7Ozs7Ozs7Ozs7OzBCQUU1Qyw4REFBQ2tHO2dCQUFPbEcsV0FBVTtnQkFBT3FFLFNBQVM0Qjs7a0NBQ2hDLDhEQUFDRTt3QkFBS25HLFdBQVU7Ozs7OztrQ0FDaEIsOERBQUNtRzt3QkFBS25HLFdBQVU7a0NBQU87Ozs7OztvQkFDdEJpRixjQUFjLHdCQUFVLDhEQUFDa0I7d0JBQUtuRyxXQUFVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJakQ7SUFqS1NnRjtNQUFBQTtBQW1LTSxTQUFTb0I7O0lBQ3RCLE1BQU0sQ0FBQ2xHLE9BQU8sR0FBR3ZELGdHQUF5QkE7SUFDMUMsTUFBTXVJLGFBQWFuSSw2Q0FBTUEsQ0FBQztJQUMxQixNQUFNLENBQUNzSixTQUFTQyxXQUFXLEdBQUd0SiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUN1SixTQUFTQyxXQUFXLEdBQUd4SiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNpSSxXQUFXd0IsYUFBYSxHQUFHekosK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDMEosb0JBQW9CQyxzQkFBc0IsR0FBRzNKLCtDQUFRQSxDQUFDO0lBQzdELE1BQU0sQ0FBQzRKLDBCQUEwQnpCLDRCQUE0QixHQUFHbkksK0NBQVFBLENBQ3RFO0lBRUYsTUFBTSxDQUFDNkosY0FBY0MsZ0JBQWdCLEdBQUc5SiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUMrSixPQUFPQyxTQUFTLEdBQUdoSywrQ0FBUUEsQ0FBQztJQUNuQyxNQUFNLENBQUNpSyxRQUFRQyxVQUFVLEdBQUdsSywrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNLENBQUNtSyxRQUFRQyxVQUFVLEdBQUdwSywrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNLENBQUNxSyxVQUFVQyxZQUFZLEdBQUd0SywrQ0FBUUEsQ0FBQztJQUN6QyxNQUFNLENBQUN1SyxhQUFhQyxlQUFlLEdBQUd4SywrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUN5SyxpQkFBaUJDLG1CQUFtQixHQUFHMUssK0NBQVFBLENBQUM7SUFDdkQsTUFBTSxDQUFDMkssUUFBUUMsVUFBVSxHQUFHNUssK0NBQVFBLENBQUM7SUFFckMsTUFBTTZLLGdCQUFnQmpMLGtEQUFXQSxDQUFDO1FBQ2hDLE1BQU02RSxZQUFZakUsc0RBQWFBO1FBQy9CLElBQUlDLDBEQUFpQkEsQ0FBQ2dFLFlBQVk7WUFDaEMsTUFBTWdCLGFBQWFoQixVQUFVbUQsTUFBTSxDQUFDQyxPQUFPO1lBQzNDLE1BQU1pRCxVQUNKckYsV0FBV3NGLE1BQU0sT0FBTyxTQUNwQnRGLGFBQ0FBLFdBQVd1Rix5QkFBeUI7WUFDMUMsTUFBTUMsYUFBYUgsUUFBUUMsTUFBTTtZQUNqQyxNQUFNRyxhQUFhaEksT0FBT2lJLGVBQWUsQ0FBQ0Y7WUFDMUMsSUFBSUMsZUFBZSxNQUFNO2dCQUN2QnZCLHNCQUFzQnNCO2dCQUN0QixJQUFJM0osMERBQVdBLENBQUN3SixVQUFVO29CQUN4QixNQUFNTSxhQUFhbksscUVBQXFCQSxDQUFDd0UsWUFBWWxFLG1EQUFRQTtvQkFDN0QsTUFBTThKLE9BQU9ELGFBQWFBLFdBQVdFLE1BQU0sS0FBS1IsUUFBUVEsTUFBTTtvQkFDOUQ3QixhQUFhNEI7Z0JBQ2YsT0FBTztvQkFDTCxNQUFNQSxPQUFPMUosa0VBQWNBLENBQUNtSixXQUN4QkEsUUFBUVEsTUFBTSxLQUNkUixRQUFRUyxPQUFPO29CQUNuQjlCLGFBQWE0QjtvQkFDYixJQUFJeEosMkRBQVdBLENBQUNpSixVQUFVO3dCQUN4QmhCLGdCQUFnQmdCLFFBQVFVLFdBQVcsTUFBTTFKLHNFQUFzQkE7b0JBQ2pFO2dCQUNGO1lBQ0Y7WUFDQSxxQkFBcUI7WUFDckJzSSxVQUFVM0YsVUFBVWdILFNBQVMsQ0FBQztZQUM5Qm5CLFlBQVk3RixVQUFVZ0gsU0FBUyxDQUFDO1lBQ2hDakIsZUFBZS9GLFVBQVVnSCxTQUFTLENBQUM7WUFDbkNmLG1CQUFtQmpHLFVBQVVnSCxTQUFTLENBQUM7WUFDdkNiLFVBQVVuRyxVQUFVZ0gsU0FBUyxDQUFDO1lBQzlCekIsU0FBU2xKLHVFQUFtQkEsQ0FBQzJEO1lBRTdCLGVBQWU7WUFDZixNQUFNQyxPQUFPQyxnQkFBZ0JGO1lBQzdCLE1BQU1HLFNBQVNGLEtBQUtHLFNBQVM7WUFDN0IsSUFBSWpFLDBEQUFXQSxDQUFDZ0UsV0FBV2hFLDBEQUFXQSxDQUFDOEQsT0FBTztnQkFDNUN3RixVQUFVO1lBQ1osT0FBTztnQkFDTEEsVUFBVTtZQUNaO1FBQ0Y7SUFDRixHQUFHO1FBQUNoSDtLQUFPO0lBRVhyRCxnREFBU0EsQ0FBQztRQUNSLE9BQU9xQiw2REFBYUEsQ0FDbEJnQyxPQUFPNkMsc0JBQXNCLENBQUM7Z0JBQUMsRUFBRUMsV0FBVyxFQUFFO1lBQzVDQSxZQUFZQyxJQUFJLENBQUM7Z0JBQ2Y0RTtZQUNGO1FBQ0YsSUFDQTNILE9BQU9nRCxlQUFlLENBQ3BCN0YsNkRBQXdCQSxFQUN4QixDQUFDcUwsVUFBVUM7WUFDVGQ7WUFDQSxPQUFPO1FBQ1QsR0FDQTdJLGNBRUZrQixPQUFPZ0QsZUFBZSxDQUNwQmhHLHFEQUFnQkEsRUFDaEIsQ0FBQzBMO1lBQ0N0QyxXQUFXc0M7WUFDWCxPQUFPO1FBQ1QsR0FDQTVKLGNBRUZrQixPQUFPZ0QsZUFBZSxDQUNwQmpHLHFEQUFnQkEsRUFDaEIsQ0FBQzJMO1lBQ0NwQyxXQUFXb0M7WUFDWCxPQUFPO1FBQ1QsR0FDQTVKO0lBR04sR0FBRztRQUFDa0I7UUFBUTJIO0tBQWM7SUFFMUIsTUFBTWdCLGVBQWUvTCw4Q0FBT0EsQ0FBQyxJQUFNaUMsZ0VBQWdCQSxJQUFJLEVBQUU7SUFDekQsTUFBTStKLHVCQUF1QmxNLGtEQUFXQSxDQUN0QyxDQUFDbU07UUFDQzdJLE9BQU95RixNQUFNLENBQUM7WUFDWixJQUFJZSx1QkFBdUIsTUFBTTtnQkFDL0IsTUFBTWhGLE9BQU8vRCxzREFBYUEsQ0FBQytJO2dCQUMzQixJQUFJN0gsMkRBQVdBLENBQUM2QyxPQUFPO29CQUNyQkEsS0FBS3NILFdBQVcsQ0FBQ0QsRUFBRXJGLE1BQU0sQ0FBQ0gsS0FBSztnQkFDakM7WUFDRjtRQUNGO0lBQ0YsR0FDQTtRQUFDckQ7UUFBUXdHO0tBQW1CO0lBRzlCLE1BQU11QyxhQUFhck0sa0RBQVdBLENBQUM7UUFDN0IsSUFBSSxDQUFDcUssUUFBUTtZQUNYL0csT0FBTzRELGVBQWUsQ0FBQ2pHLDhEQUFtQkEsRUFBRTtRQUM5QyxPQUFPO1lBQ0xxQyxPQUFPNEQsZUFBZSxDQUFDakcsOERBQW1CQSxFQUFFO1FBQzlDO0lBQ0YsR0FBRztRQUFDcUM7UUFBUStHO0tBQU87SUFFbkIscUJBQ0UsOERBQUNsSDtRQUFJQyxXQUFVO1FBQVVxRCxLQUFLNkI7OzBCQUM1Qiw4REFBQ2dCO2dCQUNDZ0QsVUFBVSxDQUFDN0M7Z0JBQ1hoQyxTQUFTO29CQUNQbkUsT0FBTzRELGVBQWUsQ0FBQzFHLGlEQUFZQTtnQkFDckM7Z0JBQ0E0QyxXQUFVO2dCQUNWbUosY0FBVzswQkFFWCw0RUFBQ0M7b0JBQUVwSixXQUFVOzs7Ozs7Ozs7OzswQkFFZiw4REFBQ2tHO2dCQUNDZ0QsVUFBVSxDQUFDM0M7Z0JBQ1hsQyxTQUFTO29CQUNQbkUsT0FBTzRELGVBQWUsQ0FBQzNHLGlEQUFZQTtnQkFDckM7Z0JBQ0E2QyxXQUFVO2dCQUNWbUosY0FBVzswQkFFWCw0RUFBQ0M7b0JBQUVwSixXQUFVOzs7Ozs7Ozs7OzswQkFFZiw4REFBQ0Y7Ozs7O1lBQ0FiLG9CQUFvQm9LLEdBQUcsQ0FBQ3BFLDRCQUN2Qjs7a0NBQ0UsOERBQUNpQjt3QkFDQ2xHLFdBQVU7d0JBQ1ZxRSxTQUFTLElBQ1BjLDRCQUE0QixDQUFDeUI7d0JBRS9CdUMsY0FBVzs7MENBRVgsOERBQUNoRDtnQ0FBS25HLFdBQVcscUJBQXFCaUY7Ozs7OzswQ0FDdEMsOERBQUNrQjtnQ0FBS25HLFdBQVU7MENBQVFiLG9CQUFvQixDQUFDOEYsVUFBVTs7Ozs7OzBDQUN2RCw4REFBQ21FO2dDQUFFcEosV0FBVTs7Ozs7Ozs7Ozs7O29CQUVkNEcsMENBQ0NwSSx1REFBWUEsZUFDViw4REFBQ3dHO3dCQUNDOUUsUUFBUUE7d0JBQ1IrRSxXQUFXQTt3QkFDWEMsWUFBWUE7d0JBQ1pDLDZCQUE2QkE7Ozs7OzhCQUUvQi9DLFNBQVNrSCxJQUFJO2tDQUVqQiw4REFBQ3hKOzs7Ozs7O1lBR0ptRixjQUFjLHVCQUNiOztrQ0FDRSw4REFBQ1g7d0JBQ0N0RSxXQUFVO3dCQUNWd0QsVUFBVXNGO3dCQUNWdkUsU0FBU3NFO3dCQUNUdEYsT0FBT3NEOzs7Ozs7a0NBRVQsOERBQUN1Qzt3QkFBRXBKLFdBQVU7Ozs7Ozs7NkNBR2Y7O2tDQUNFLDhEQUFDa0c7d0JBQ0M3QixTQUFTOzRCQUNQbkUsT0FBTzRELGVBQWUsQ0FBQ3hHLHdEQUFtQkEsRUFBRTt3QkFDOUM7d0JBQ0EwQyxXQUFXLHlCQUEwQm1ILENBQUFBLFNBQVMsV0FBVyxFQUFDO3dCQUMxRGdDLGNBQVc7a0NBRVgsNEVBQUNDOzRCQUFFcEosV0FBVTs7Ozs7Ozs7Ozs7a0NBRWYsOERBQUNrRzt3QkFDQzdCLFNBQVM7NEJBQ1BuRSxPQUFPNEQsZUFBZSxDQUFDeEcsd0RBQW1CQSxFQUFFO3dCQUM5Qzt3QkFDQTBDLFdBQVcseUJBQTBCcUgsQ0FBQUEsV0FBVyxXQUFXLEVBQUM7d0JBQzVEOEIsY0FBVztrQ0FFWCw0RUFBQ0M7NEJBQUVwSixXQUFVOzs7Ozs7Ozs7OztrQ0FFZiw4REFBQ2tHO3dCQUNDN0IsU0FBUzs0QkFDUG5FLE9BQU80RCxlQUFlLENBQUN4Ryx3REFBbUJBLEVBQUU7d0JBQzlDO3dCQUNBMEMsV0FBVyx5QkFBMEJ1SCxDQUFBQSxjQUFjLFdBQVcsRUFBQzt3QkFDL0Q0QixjQUFXO2tDQUVYLDRFQUFDQzs0QkFBRXBKLFdBQVU7Ozs7Ozs7Ozs7O2tDQUVmLDhEQUFDa0c7d0JBQ0M3QixTQUFTOzRCQUNQbkUsT0FBTzRELGVBQWUsQ0FBQ3hHLHdEQUFtQkEsRUFBRTt3QkFDOUM7d0JBQ0EwQyxXQUNFLHlCQUEwQnlILENBQUFBLGtCQUFrQixXQUFXLEVBQUM7d0JBRTFEMEIsY0FBVztrQ0FFWCw0RUFBQ0M7NEJBQUVwSixXQUFVOzs7Ozs7Ozs7OztrQ0FFZiw4REFBQ2tHO3dCQUNDN0IsU0FBUzs0QkFDUG5FLE9BQU80RCxlQUFlLENBQUN4Ryx3REFBbUJBLEVBQUU7d0JBQzlDO3dCQUNBMEMsV0FBVyx5QkFBMEIySCxDQUFBQSxTQUFTLFdBQVcsRUFBQzt3QkFDMUR3QixjQUFXO2tDQUVYLDRFQUFDQzs0QkFBRXBKLFdBQVU7Ozs7Ozs7Ozs7O2tDQUVmLDhEQUFDa0c7d0JBQ0M3QixTQUFTNEU7d0JBQ1RqSixXQUFXLHlCQUEwQmlILENBQUFBLFNBQVMsV0FBVyxFQUFDO3dCQUMxRGtDLGNBQVc7a0NBRVgsNEVBQUNDOzRCQUFFcEosV0FBVTs7Ozs7Ozs7Ozs7b0JBRWRpSCx3QkFDQ3pJLHVEQUFZQSxlQUFDLDhEQUFDc0M7d0JBQW1CWixRQUFRQTs7Ozs7OEJBQVlrQyxTQUFTa0gsSUFBSTtrQ0FDcEUsOERBQUN4Sjs7Ozs7a0NBQ0QsOERBQUNvRzt3QkFDQzdCLFNBQVM7NEJBQ1BuRSxPQUFPNEQsZUFBZSxDQUFDdkcsMkRBQXNCQSxFQUFFO3dCQUNqRDt3QkFDQXlDLFdBQVU7d0JBQ1ZtSixjQUFXO2tDQUVYLDRFQUFDQzs0QkFBRXBKLFdBQVU7Ozs7Ozs7Ozs7O2tDQUVmLDhEQUFDa0c7d0JBQ0M3QixTQUFTOzRCQUNQbkUsT0FBTzRELGVBQWUsQ0FBQ3ZHLDJEQUFzQkEsRUFBRTt3QkFDakQ7d0JBQ0F5QyxXQUFVO3dCQUNWbUosY0FBVztrQ0FFWCw0RUFBQ0M7NEJBQUVwSixXQUFVOzs7Ozs7Ozs7OztrQ0FFZiw4REFBQ2tHO3dCQUNDN0IsU0FBUzs0QkFDUG5FLE9BQU80RCxlQUFlLENBQUN2RywyREFBc0JBLEVBQUU7d0JBQ2pEO3dCQUNBeUMsV0FBVTt3QkFDVm1KLGNBQVc7a0NBRVgsNEVBQUNDOzRCQUFFcEosV0FBVTs7Ozs7Ozs7Ozs7a0NBRWYsOERBQUNrRzt3QkFDQzdCLFNBQVM7NEJBQ1BuRSxPQUFPNEQsZUFBZSxDQUFDdkcsMkRBQXNCQSxFQUFFO3dCQUNqRDt3QkFDQXlDLFdBQVU7d0JBQ1ZtSixjQUFXO2tDQUVYLDRFQUFDQzs0QkFBRXBKLFdBQVU7Ozs7Ozs7Ozs7O29CQUNMOzs7Ozs7Ozs7QUFLcEI7SUF2UndCb0c7O1FBQ0x6Siw0RkFBeUJBOzs7TUFEcEJ5SiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9MZXhpY2FsL3BsdWdpbnMvVG9vbGJhclBsdWdpbi5qcz8zZGRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tIFwiQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgQ0FOX1JFRE9fQ09NTUFORCxcbiAgQ0FOX1VORE9fQ09NTUFORCxcbiAgUkVET19DT01NQU5ELFxuICBVTkRPX0NPTU1BTkQsXG4gIFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCxcbiAgRk9STUFUX1RFWFRfQ09NTUFORCxcbiAgRk9STUFUX0VMRU1FTlRfQ09NTUFORCxcbiAgJGdldFNlbGVjdGlvbixcbiAgJGlzUmFuZ2VTZWxlY3Rpb24sXG4gICRjcmVhdGVQYXJhZ3JhcGhOb2RlLFxuICAkZ2V0Tm9kZUJ5S2V5XG59IGZyb20gXCJsZXhpY2FsXCI7XG5pbXBvcnQgeyAkaXNMaW5rTm9kZSwgVE9HR0xFX0xJTktfQ09NTUFORCB9IGZyb20gXCJAbGV4aWNhbC9saW5rXCI7XG5pbXBvcnQge1xuICAkaXNQYXJlbnRFbGVtZW50UlRMLFxuICAkd3JhcE5vZGVzLFxuICAkaXNBdE5vZGVFbmRcbn0gZnJvbSBcIkBsZXhpY2FsL3NlbGVjdGlvblwiO1xuaW1wb3J0IHsgJGdldE5lYXJlc3ROb2RlT2ZUeXBlLCBtZXJnZVJlZ2lzdGVyIH0gZnJvbSBcIkBsZXhpY2FsL3V0aWxzXCI7XG5pbXBvcnQge1xuICBJTlNFUlRfT1JERVJFRF9MSVNUX0NPTU1BTkQsXG4gIElOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5ELFxuICBSRU1PVkVfTElTVF9DT01NQU5ELFxuICAkaXNMaXN0Tm9kZSxcbiAgTGlzdE5vZGVcbn0gZnJvbSBcIkBsZXhpY2FsL2xpc3RcIjtcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCB7XG4gICRjcmVhdGVIZWFkaW5nTm9kZSxcbiAgJGNyZWF0ZVF1b3RlTm9kZSxcbiAgJGlzSGVhZGluZ05vZGVcbn0gZnJvbSBcIkBsZXhpY2FsL3JpY2gtdGV4dFwiO1xuaW1wb3J0IHtcbiAgJGNyZWF0ZUNvZGVOb2RlLFxuICAkaXNDb2RlTm9kZSxcbiAgZ2V0RGVmYXVsdENvZGVMYW5ndWFnZSxcbiAgZ2V0Q29kZUxhbmd1YWdlc1xufSBmcm9tIFwiQGxleGljYWwvY29kZVwiO1xuXG5jb25zdCBMb3dQcmlvcml0eSA9IDE7XG5cbmNvbnN0IHN1cHBvcnRlZEJsb2NrVHlwZXMgPSBuZXcgU2V0KFtcbiAgXCJwYXJhZ3JhcGhcIixcbiAgXCJxdW90ZVwiLFxuICBcImNvZGVcIixcbiAgXCJoMVwiLFxuICBcImgyXCIsXG4gIFwidWxcIixcbiAgXCJvbFwiXG5dKTtcblxuY29uc3QgYmxvY2tUeXBlVG9CbG9ja05hbWUgPSB7XG4gIGNvZGU6IFwiQ29kZSBCbG9ja1wiLFxuICBoMTogXCJMYXJnZSBIZWFkaW5nXCIsXG4gIGgyOiBcIlNtYWxsIEhlYWRpbmdcIixcbiAgaDM6IFwiSGVhZGluZ1wiLFxuICBoNDogXCJIZWFkaW5nXCIsXG4gIGg1OiBcIkhlYWRpbmdcIixcbiAgb2w6IFwiTnVtYmVyZWQgTGlzdFwiLFxuICBwYXJhZ3JhcGg6IFwiTm9ybWFsXCIsXG4gIHF1b3RlOiBcIlF1b3RlXCIsXG4gIHVsOiBcIkJ1bGxldGVkIExpc3RcIlxufTtcblxuZnVuY3Rpb24gRGl2aWRlcigpIHtcbiAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwiZGl2aWRlclwiIC8+O1xufVxuXG5mdW5jdGlvbiBwb3NpdGlvbkVkaXRvckVsZW1lbnQoZWRpdG9yLCByZWN0KSB7XG4gIGlmIChyZWN0ID09PSBudWxsKSB7XG4gICAgZWRpdG9yLnN0eWxlLm9wYWNpdHkgPSBcIjBcIjtcbiAgICBlZGl0b3Iuc3R5bGUudG9wID0gXCItMTAwMHB4XCI7XG4gICAgZWRpdG9yLnN0eWxlLmxlZnQgPSBcIi0xMDAwcHhcIjtcbiAgfSBlbHNlIHtcbiAgICBlZGl0b3Iuc3R5bGUub3BhY2l0eSA9IFwiMVwiO1xuICAgIGVkaXRvci5zdHlsZS50b3AgPSBgJHtyZWN0LnRvcCArIHJlY3QuaGVpZ2h0ICsgd2luZG93LnBhZ2VZT2Zmc2V0ICsgMTB9cHhgO1xuICAgIGVkaXRvci5zdHlsZS5sZWZ0ID0gYCR7cmVjdC5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0IC0gZWRpdG9yLm9mZnNldFdpZHRoIC8gMiArIHJlY3Qud2lkdGggLyAyXG4gICAgICB9cHhgO1xuICB9XG59XG5cbmZ1bmN0aW9uIEZsb2F0aW5nTGlua0VkaXRvcih7IGVkaXRvciB9KSB7XG4gIGNvbnN0IGVkaXRvclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgaW5wdXRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IG1vdXNlRG93blJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IFtsaW5rVXJsLCBzZXRMaW5rVXJsXSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbaXNFZGl0TW9kZSwgc2V0RWRpdE1vZGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbbGFzdFNlbGVjdGlvbiwgc2V0TGFzdFNlbGVjdGlvbl0gPSB1c2VTdGF0ZShudWxsKTtcblxuICBjb25zdCB1cGRhdGVMaW5rRWRpdG9yID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGdldFNlbGVjdGVkTm9kZShzZWxlY3Rpb24pO1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGlmICgkaXNMaW5rTm9kZShwYXJlbnQpKSB7XG4gICAgICAgIHNldExpbmtVcmwocGFyZW50LmdldFVSTCgpKTtcbiAgICAgIH0gZWxzZSBpZiAoJGlzTGlua05vZGUobm9kZSkpIHtcbiAgICAgICAgc2V0TGlua1VybChub2RlLmdldFVSTCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldExpbmtVcmwoXCJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvckVsZW0gPSBlZGl0b3JSZWYuY3VycmVudDtcbiAgICBjb25zdCBuYXRpdmVTZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBpZiAoZWRpdG9yRWxlbSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgaWYgKFxuICAgICAgc2VsZWN0aW9uICE9PSBudWxsICYmXG4gICAgICAhbmF0aXZlU2VsZWN0aW9uLmlzQ29sbGFwc2VkICYmXG4gICAgICByb290RWxlbWVudCAhPT0gbnVsbCAmJlxuICAgICAgcm9vdEVsZW1lbnQuY29udGFpbnMobmF0aXZlU2VsZWN0aW9uLmFuY2hvck5vZGUpXG4gICAgKSB7XG4gICAgICBjb25zdCBkb21SYW5nZSA9IG5hdGl2ZVNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgbGV0IHJlY3Q7XG4gICAgICBpZiAobmF0aXZlU2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IHJvb3RFbGVtZW50KSB7XG4gICAgICAgIGxldCBpbm5lciA9IHJvb3RFbGVtZW50O1xuICAgICAgICB3aGlsZSAoaW5uZXIuZmlyc3RFbGVtZW50Q2hpbGQgIT0gbnVsbCkge1xuICAgICAgICAgIGlubmVyID0gaW5uZXIuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVjdCA9IGlubmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjdCA9IGRvbVJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1vdXNlRG93blJlZi5jdXJyZW50KSB7XG4gICAgICAgIHBvc2l0aW9uRWRpdG9yRWxlbWVudChlZGl0b3JFbGVtLCByZWN0KTtcbiAgICAgIH1cbiAgICAgIHNldExhc3RTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKCFhY3RpdmVFbGVtZW50IHx8IGFjdGl2ZUVsZW1lbnQuY2xhc3NOYW1lICE9PSBcImxpbmstaW5wdXRcIikge1xuICAgICAgcG9zaXRpb25FZGl0b3JFbGVtZW50KGVkaXRvckVsZW0sIG51bGwpO1xuICAgICAgc2V0TGFzdFNlbGVjdGlvbihudWxsKTtcbiAgICAgIHNldEVkaXRNb2RlKGZhbHNlKTtcbiAgICAgIHNldExpbmtVcmwoXCJcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIFtlZGl0b3JdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKFxuICAgICAgZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHsgZWRpdG9yU3RhdGUgfSkgPT4ge1xuICAgICAgICBlZGl0b3JTdGF0ZS5yZWFkKCgpID0+IHtcbiAgICAgICAgICB1cGRhdGVMaW5rRWRpdG9yKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG5cbiAgICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoXG4gICAgICAgIFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIHVwZGF0ZUxpbmtFZGl0b3IoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgTG93UHJpb3JpdHlcbiAgICAgIClcbiAgICApO1xuICB9LCBbZWRpdG9yLCB1cGRhdGVMaW5rRWRpdG9yXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgIHVwZGF0ZUxpbmtFZGl0b3IoKTtcbiAgICB9KTtcbiAgfSwgW2VkaXRvciwgdXBkYXRlTGlua0VkaXRvcl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzRWRpdE1vZGUgJiYgaW5wdXRSZWYuY3VycmVudCkge1xuICAgICAgaW5wdXRSZWYuY3VycmVudC5mb2N1cygpO1xuICAgIH1cbiAgfSwgW2lzRWRpdE1vZGVdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgcmVmPXtlZGl0b3JSZWZ9IGNsYXNzTmFtZT1cImxpbmstZWRpdG9yXCI+XG4gICAgICB7aXNFZGl0TW9kZSA/IChcbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgcmVmPXtpbnB1dFJlZn1cbiAgICAgICAgICBjbGFzc05hbWU9XCJsaW5rLWlucHV0XCJcbiAgICAgICAgICB2YWx1ZT17bGlua1VybH1cbiAgICAgICAgICBvbkNoYW5nZT17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBzZXRMaW5rVXJsKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgfX1cbiAgICAgICAgICBvbktleURvd249eyhldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGlmIChsYXN0U2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmtVcmwgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoVE9HR0xFX0xJTktfQ09NTUFORCwgbGlua1VybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldEVkaXRNb2RlKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgc2V0RWRpdE1vZGUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgICApIDogKFxuICAgICAgICA8PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibGluay1pbnB1dFwiPlxuICAgICAgICAgICAgPGEgaHJlZj17bGlua1VybH0gdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiPlxuICAgICAgICAgICAgICB7bGlua1VybH1cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibGluay1lZGl0XCJcbiAgICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgIHRhYkluZGV4PXswfVxuICAgICAgICAgICAgICBvbk1vdXNlRG93bj17KGV2ZW50KSA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpfVxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0RWRpdE1vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmZ1bmN0aW9uIFNlbGVjdCh7IG9uQ2hhbmdlLCBjbGFzc05hbWUsIG9wdGlvbnMsIHZhbHVlIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8c2VsZWN0IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBvbkNoYW5nZT17b25DaGFuZ2V9IHZhbHVlPXt2YWx1ZX0+XG4gICAgICA8b3B0aW9uIGhpZGRlbj17dHJ1ZX0gdmFsdWU9XCJcIiAvPlxuICAgICAge29wdGlvbnMubWFwKChvcHRpb24pID0+IChcbiAgICAgICAgPG9wdGlvbiBrZXk9e29wdGlvbn0gdmFsdWU9e29wdGlvbn0+XG4gICAgICAgICAge29wdGlvbn1cbiAgICAgICAgPC9vcHRpb24+XG4gICAgICApKX1cbiAgICA8L3NlbGVjdD5cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0ZWROb2RlKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICBpZiAoYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlKSB7XG4gICAgcmV0dXJuIGFuY2hvck5vZGU7XG4gIH1cbiAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gIGlmIChpc0JhY2t3YXJkKSB7XG4gICAgcmV0dXJuICRpc0F0Tm9kZUVuZChmb2N1cykgPyBhbmNob3JOb2RlIDogZm9jdXNOb2RlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAkaXNBdE5vZGVFbmQoYW5jaG9yKSA/IGZvY3VzTm9kZSA6IGFuY2hvck5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gQmxvY2tPcHRpb25zRHJvcGRvd25MaXN0KHtcbiAgZWRpdG9yLFxuICBibG9ja1R5cGUsXG4gIHRvb2xiYXJSZWYsXG4gIHNldFNob3dCbG9ja09wdGlvbnNEcm9wRG93blxufSkge1xuICBjb25zdCBkcm9wRG93blJlZiA9IHVzZVJlZihudWxsKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHRvb2xiYXIgPSB0b29sYmFyUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgZHJvcERvd24gPSBkcm9wRG93blJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHRvb2xiYXIgIT09IG51bGwgJiYgZHJvcERvd24gIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHsgdG9wLCBsZWZ0IH0gPSB0b29sYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZHJvcERvd24uc3R5bGUudG9wID0gYCR7dG9wICsgNDB9cHhgO1xuICAgICAgZHJvcERvd24uc3R5bGUubGVmdCA9IGAke2xlZnR9cHhgO1xuICAgIH1cbiAgfSwgW2Ryb3BEb3duUmVmLCB0b29sYmFyUmVmXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBkcm9wRG93biA9IGRyb3BEb3duUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgdG9vbGJhciA9IHRvb2xiYXJSZWYuY3VycmVudDtcblxuICAgIGlmIChkcm9wRG93biAhPT0gbnVsbCAmJiB0b29sYmFyICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBoYW5kbGUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgICAgIGlmICghZHJvcERvd24uY29udGFpbnModGFyZ2V0KSAmJiAhdG9vbGJhci5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgc2V0U2hvd0Jsb2NrT3B0aW9uc0Ryb3BEb3duKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGUpO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZHJvcERvd25SZWYsIHNldFNob3dCbG9ja09wdGlvbnNEcm9wRG93biwgdG9vbGJhclJlZl0pO1xuXG4gIGNvbnN0IGZvcm1hdFBhcmFncmFwaCA9ICgpID0+IHtcbiAgICBpZiAoYmxvY2tUeXBlICE9PSBcInBhcmFncmFwaFwiKSB7XG4gICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgJHdyYXBOb2RlcyhzZWxlY3Rpb24sICgpID0+ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2V0U2hvd0Jsb2NrT3B0aW9uc0Ryb3BEb3duKGZhbHNlKTtcbiAgfTtcblxuICBjb25zdCBmb3JtYXRMYXJnZUhlYWRpbmcgPSAoKSA9PiB7XG4gICAgaWYgKGJsb2NrVHlwZSAhPT0gXCJoMVwiKSB7XG4gICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgJHdyYXBOb2RlcyhzZWxlY3Rpb24sICgpID0+ICRjcmVhdGVIZWFkaW5nTm9kZShcImgxXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHNldFNob3dCbG9ja09wdGlvbnNEcm9wRG93bihmYWxzZSk7XG4gIH07XG5cbiAgY29uc3QgZm9ybWF0U21hbGxIZWFkaW5nID0gKCkgPT4ge1xuICAgIGlmIChibG9ja1R5cGUgIT09IFwiaDJcIikge1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICAgICR3cmFwTm9kZXMoc2VsZWN0aW9uLCAoKSA9PiAkY3JlYXRlSGVhZGluZ05vZGUoXCJoMlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRTaG93QmxvY2tPcHRpb25zRHJvcERvd24oZmFsc2UpO1xuICB9O1xuXG4gIGNvbnN0IGZvcm1hdEJ1bGxldExpc3QgPSAoKSA9PiB7XG4gICAgaWYgKGJsb2NrVHlwZSAhPT0gXCJ1bFwiKSB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKElOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5EKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChSRU1PVkVfTElTVF9DT01NQU5EKTtcbiAgICB9XG4gICAgc2V0U2hvd0Jsb2NrT3B0aW9uc0Ryb3BEb3duKGZhbHNlKTtcbiAgfTtcblxuICBjb25zdCBmb3JtYXROdW1iZXJlZExpc3QgPSAoKSA9PiB7XG4gICAgaWYgKGJsb2NrVHlwZSAhPT0gXCJvbFwiKSB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKElOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoUkVNT1ZFX0xJU1RfQ09NTUFORCk7XG4gICAgfVxuICAgIHNldFNob3dCbG9ja09wdGlvbnNEcm9wRG93bihmYWxzZSk7XG4gIH07XG5cbiAgY29uc3QgZm9ybWF0UXVvdGUgPSAoKSA9PiB7XG4gICAgaWYgKGJsb2NrVHlwZSAhPT0gXCJxdW90ZVwiKSB7XG4gICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgJHdyYXBOb2RlcyhzZWxlY3Rpb24sICgpID0+ICRjcmVhdGVRdW90ZU5vZGUoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRTaG93QmxvY2tPcHRpb25zRHJvcERvd24oZmFsc2UpO1xuICB9O1xuXG4gIGNvbnN0IGZvcm1hdENvZGUgPSAoKSA9PiB7XG4gICAgaWYgKGJsb2NrVHlwZSAhPT0gXCJjb2RlXCIpIHtcbiAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAkd3JhcE5vZGVzKHNlbGVjdGlvbiwgKCkgPT4gJGNyZWF0ZUNvZGVOb2RlKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2V0U2hvd0Jsb2NrT3B0aW9uc0Ryb3BEb3duKGZhbHNlKTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidG9vbEJhcmRyb3Bkb3duXCIgcmVmPXtkcm9wRG93blJlZn0+XG4gICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cIml0ZW1cIiBvbkNsaWNrPXtmb3JtYXRQYXJhZ3JhcGh9PlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJpY29uIHBhcmFncmFwaFwiIC8+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHRcIj5Ob3JtYWw8L3NwYW4+XG4gICAgICAgIHtibG9ja1R5cGUgPT09IFwicGFyYWdyYXBoXCIgJiYgPHNwYW4gY2xhc3NOYW1lPVwiYWN0aXZlXCIgLz59XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiaXRlbVwiIG9uQ2xpY2s9e2Zvcm1hdExhcmdlSGVhZGluZ30+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImljb24gbGFyZ2UtaGVhZGluZ1wiIC8+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHRcIj5MYXJnZSBIZWFkaW5nPC9zcGFuPlxuICAgICAgICB7YmxvY2tUeXBlID09PSBcImgxXCIgJiYgPHNwYW4gY2xhc3NOYW1lPVwiYWN0aXZlXCIgLz59XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiaXRlbVwiIG9uQ2xpY2s9e2Zvcm1hdFNtYWxsSGVhZGluZ30+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImljb24gc21hbGwtaGVhZGluZ1wiIC8+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHRcIj5TbWFsbCBIZWFkaW5nPC9zcGFuPlxuICAgICAgICB7YmxvY2tUeXBlID09PSBcImgyXCIgJiYgPHNwYW4gY2xhc3NOYW1lPVwiYWN0aXZlXCIgLz59XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiaXRlbVwiIG9uQ2xpY2s9e2Zvcm1hdEJ1bGxldExpc3R9PlxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJpY29uIGJ1bGxldC1saXN0XCIgLz5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dFwiPkJ1bGxldCBMaXN0PC9zcGFuPlxuICAgICAgICB7YmxvY2tUeXBlID09PSBcInVsXCIgJiYgPHNwYW4gY2xhc3NOYW1lPVwiYWN0aXZlXCIgLz59XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiaXRlbVwiIG9uQ2xpY2s9e2Zvcm1hdE51bWJlcmVkTGlzdH0+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImljb24gbnVtYmVyZWQtbGlzdFwiIC8+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHRcIj5OdW1iZXJlZCBMaXN0PC9zcGFuPlxuICAgICAgICB7YmxvY2tUeXBlID09PSBcIm9sXCIgJiYgPHNwYW4gY2xhc3NOYW1lPVwiYWN0aXZlXCIgLz59XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiaXRlbVwiIG9uQ2xpY2s9e2Zvcm1hdFF1b3RlfT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaWNvbiBxdW90ZVwiIC8+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHRcIj5RdW90ZTwvc3Bhbj5cbiAgICAgICAge2Jsb2NrVHlwZSA9PT0gXCJxdW90ZVwiICYmIDxzcGFuIGNsYXNzTmFtZT1cImFjdGl2ZVwiIC8+fVxuICAgICAgPC9idXR0b24+XG4gICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cIml0ZW1cIiBvbkNsaWNrPXtmb3JtYXRDb2RlfT5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaWNvbiBjb2RlXCIgLz5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dFwiPkNvZGUgQmxvY2s8L3NwYW4+XG4gICAgICAgIHtibG9ja1R5cGUgPT09IFwiY29kZVwiICYmIDxzcGFuIGNsYXNzTmFtZT1cImFjdGl2ZVwiIC8+fVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRvb2xiYXJQbHVnaW4oKSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICBjb25zdCB0b29sYmFyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbY2FuVW5kbywgc2V0Q2FuVW5kb10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjYW5SZWRvLCBzZXRDYW5SZWRvXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Jsb2NrVHlwZSwgc2V0QmxvY2tUeXBlXSA9IHVzZVN0YXRlKFwicGFyYWdyYXBoXCIpO1xuICBjb25zdCBbc2VsZWN0ZWRFbGVtZW50S2V5LCBzZXRTZWxlY3RlZEVsZW1lbnRLZXldID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtzaG93QmxvY2tPcHRpb25zRHJvcERvd24sIHNldFNob3dCbG9ja09wdGlvbnNEcm9wRG93bl0gPSB1c2VTdGF0ZShcbiAgICBmYWxzZVxuICApO1xuICBjb25zdCBbY29kZUxhbmd1YWdlLCBzZXRDb2RlTGFuZ3VhZ2VdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtpc1JUTCwgc2V0SXNSVExdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNMaW5rLCBzZXRJc0xpbmtdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNCb2xkLCBzZXRJc0JvbGRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNJdGFsaWMsIHNldElzSXRhbGljXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzVW5kZXJsaW5lLCBzZXRJc1VuZGVybGluZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc1N0cmlrZXRocm91Z2gsIHNldElzU3RyaWtldGhyb3VnaF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0NvZGUsIHNldElzQ29kZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgY29uc3QgdXBkYXRlVG9vbGJhciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPVxuICAgICAgICBhbmNob3JOb2RlLmdldEtleSgpID09PSBcInJvb3RcIlxuICAgICAgICAgID8gYW5jaG9yTm9kZVxuICAgICAgICAgIDogYW5jaG9yTm9kZS5nZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCk7XG4gICAgICBjb25zdCBlbGVtZW50S2V5ID0gZWxlbWVudC5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGVsZW1lbnRLZXkpO1xuICAgICAgaWYgKGVsZW1lbnRET00gIT09IG51bGwpIHtcbiAgICAgICAgc2V0U2VsZWN0ZWRFbGVtZW50S2V5KGVsZW1lbnRLZXkpO1xuICAgICAgICBpZiAoJGlzTGlzdE5vZGUoZWxlbWVudCkpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnRMaXN0ID0gJGdldE5lYXJlc3ROb2RlT2ZUeXBlKGFuY2hvck5vZGUsIExpc3ROb2RlKTtcbiAgICAgICAgICBjb25zdCB0eXBlID0gcGFyZW50TGlzdCA/IHBhcmVudExpc3QuZ2V0VGFnKCkgOiBlbGVtZW50LmdldFRhZygpO1xuICAgICAgICAgIHNldEJsb2NrVHlwZSh0eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0eXBlID0gJGlzSGVhZGluZ05vZGUoZWxlbWVudClcbiAgICAgICAgICAgID8gZWxlbWVudC5nZXRUYWcoKVxuICAgICAgICAgICAgOiBlbGVtZW50LmdldFR5cGUoKTtcbiAgICAgICAgICBzZXRCbG9ja1R5cGUodHlwZSk7XG4gICAgICAgICAgaWYgKCRpc0NvZGVOb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBzZXRDb2RlTGFuZ3VhZ2UoZWxlbWVudC5nZXRMYW5ndWFnZSgpIHx8IGdldERlZmF1bHRDb2RlTGFuZ3VhZ2UoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBVcGRhdGUgdGV4dCBmb3JtYXRcbiAgICAgIHNldElzQm9sZChzZWxlY3Rpb24uaGFzRm9ybWF0KFwiYm9sZFwiKSk7XG4gICAgICBzZXRJc0l0YWxpYyhzZWxlY3Rpb24uaGFzRm9ybWF0KFwiaXRhbGljXCIpKTtcbiAgICAgIHNldElzVW5kZXJsaW5lKHNlbGVjdGlvbi5oYXNGb3JtYXQoXCJ1bmRlcmxpbmVcIikpO1xuICAgICAgc2V0SXNTdHJpa2V0aHJvdWdoKHNlbGVjdGlvbi5oYXNGb3JtYXQoXCJzdHJpa2V0aHJvdWdoXCIpKTtcbiAgICAgIHNldElzQ29kZShzZWxlY3Rpb24uaGFzRm9ybWF0KFwiY29kZVwiKSk7XG4gICAgICBzZXRJc1JUTCgkaXNQYXJlbnRFbGVtZW50UlRMKHNlbGVjdGlvbikpO1xuXG4gICAgICAvLyBVcGRhdGUgbGlua3NcbiAgICAgIGNvbnN0IG5vZGUgPSBnZXRTZWxlY3RlZE5vZGUoc2VsZWN0aW9uKTtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAoJGlzTGlua05vZGUocGFyZW50KSB8fCAkaXNMaW5rTm9kZShub2RlKSkge1xuICAgICAgICBzZXRJc0xpbmsodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRJc0xpbmsoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2VkaXRvcl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoXG4gICAgICBlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoeyBlZGl0b3JTdGF0ZSB9KSA9PiB7XG4gICAgICAgIGVkaXRvclN0YXRlLnJlYWQoKCkgPT4ge1xuICAgICAgICAgIHVwZGF0ZVRvb2xiYXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoXG4gICAgICAgIFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCxcbiAgICAgICAgKF9wYXlsb2FkLCBuZXdFZGl0b3IpID0+IHtcbiAgICAgICAgICB1cGRhdGVUb29sYmFyKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBMb3dQcmlvcml0eVxuICAgICAgKSxcbiAgICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoXG4gICAgICAgIENBTl9VTkRPX0NPTU1BTkQsXG4gICAgICAgIChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgc2V0Q2FuVW5kbyhwYXlsb2FkKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIExvd1ByaW9yaXR5XG4gICAgICApLFxuICAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChcbiAgICAgICAgQ0FOX1JFRE9fQ09NTUFORCxcbiAgICAgICAgKHBheWxvYWQpID0+IHtcbiAgICAgICAgICBzZXRDYW5SZWRvKHBheWxvYWQpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgTG93UHJpb3JpdHlcbiAgICAgIClcbiAgICApO1xuICB9LCBbZWRpdG9yLCB1cGRhdGVUb29sYmFyXSk7XG5cbiAgY29uc3QgY29kZUxhbmd1Z2VzID0gdXNlTWVtbygoKSA9PiBnZXRDb2RlTGFuZ3VhZ2VzKCksIFtdKTtcbiAgY29uc3Qgb25Db2RlTGFuZ3VhZ2VTZWxlY3QgPSB1c2VDYWxsYmFjayhcbiAgICAoZSkgPT4ge1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGlmIChzZWxlY3RlZEVsZW1lbnRLZXkgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShzZWxlY3RlZEVsZW1lbnRLZXkpO1xuICAgICAgICAgIGlmICgkaXNDb2RlTm9kZShub2RlKSkge1xuICAgICAgICAgICAgbm9kZS5zZXRMYW5ndWFnZShlLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIFtlZGl0b3IsIHNlbGVjdGVkRWxlbWVudEtleV1cbiAgKTtcblxuICBjb25zdCBpbnNlcnRMaW5rID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghaXNMaW5rKSB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFRPR0dMRV9MSU5LX0NPTU1BTkQsIFwiaHR0cHM6Ly9cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoVE9HR0xFX0xJTktfQ09NTUFORCwgbnVsbCk7XG4gICAgfVxuICB9LCBbZWRpdG9yLCBpc0xpbmtdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidG9vbGJhclwiIHJlZj17dG9vbGJhclJlZn0+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIGRpc2FibGVkPXshY2FuVW5kb31cbiAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoVU5ET19DT01NQU5EKTtcbiAgICAgICAgfX1cbiAgICAgICAgY2xhc3NOYW1lPVwidG9vbGJhci1pdGVtIHNwYWNlZFwiXG4gICAgICAgIGFyaWEtbGFiZWw9XCJVbmRvXCJcbiAgICAgID5cbiAgICAgICAgPGkgY2xhc3NOYW1lPVwiZm9ybWF0IHVuZG9cIiAvPlxuICAgICAgPC9idXR0b24+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIGRpc2FibGVkPXshY2FuUmVkb31cbiAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoUkVET19DT01NQU5EKTtcbiAgICAgICAgfX1cbiAgICAgICAgY2xhc3NOYW1lPVwidG9vbGJhci1pdGVtXCJcbiAgICAgICAgYXJpYS1sYWJlbD1cIlJlZG9cIlxuICAgICAgPlxuICAgICAgICA8aSBjbGFzc05hbWU9XCJmb3JtYXQgcmVkb1wiIC8+XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxEaXZpZGVyIC8+XG4gICAgICB7c3VwcG9ydGVkQmxvY2tUeXBlcy5oYXMoYmxvY2tUeXBlKSAmJiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidG9vbGJhci1pdGVtIGJsb2NrLWNvbnRyb2xzXCJcbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+XG4gICAgICAgICAgICAgIHNldFNob3dCbG9ja09wdGlvbnNEcm9wRG93bighc2hvd0Jsb2NrT3B0aW9uc0Ryb3BEb3duKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJpYS1sYWJlbD1cIkZvcm1hdHRpbmcgT3B0aW9uc1wiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtcImljb24gYmxvY2stdHlwZSBcIiArIGJsb2NrVHlwZX0gLz5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHRcIj57YmxvY2tUeXBlVG9CbG9ja05hbWVbYmxvY2tUeXBlXX08L3NwYW4+XG4gICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJjaGV2cm9uLWRvd25cIiAvPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIHtzaG93QmxvY2tPcHRpb25zRHJvcERvd24gJiZcbiAgICAgICAgICAgIGNyZWF0ZVBvcnRhbChcbiAgICAgICAgICAgICAgPEJsb2NrT3B0aW9uc0Ryb3Bkb3duTGlzdFxuICAgICAgICAgICAgICAgIGVkaXRvcj17ZWRpdG9yfVxuICAgICAgICAgICAgICAgIGJsb2NrVHlwZT17YmxvY2tUeXBlfVxuICAgICAgICAgICAgICAgIHRvb2xiYXJSZWY9e3Rvb2xiYXJSZWZ9XG4gICAgICAgICAgICAgICAgc2V0U2hvd0Jsb2NrT3B0aW9uc0Ryb3BEb3duPXtzZXRTaG93QmxvY2tPcHRpb25zRHJvcERvd259XG4gICAgICAgICAgICAgIC8+LFxuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDxEaXZpZGVyIC8+XG4gICAgICAgIDwvPlxuICAgICAgKX1cbiAgICAgIHtibG9ja1R5cGUgPT09IFwiY29kZVwiID8gKFxuICAgICAgICA8PlxuICAgICAgICAgIDxTZWxlY3RcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInRvb2xiYXItaXRlbSBjb2RlLWxhbmd1YWdlXCJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNvZGVMYW5ndWFnZVNlbGVjdH1cbiAgICAgICAgICAgIG9wdGlvbnM9e2NvZGVMYW5ndWdlc31cbiAgICAgICAgICAgIHZhbHVlPXtjb2RlTGFuZ3VhZ2V9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8aSBjbGFzc05hbWU9XCJjaGV2cm9uLWRvd24gaW5zaWRlXCIgLz5cbiAgICAgICAgPC8+XG4gICAgICApIDogKFxuICAgICAgICA8PlxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChGT1JNQVRfVEVYVF9DT01NQU5ELCBcImJvbGRcIik7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtcInRvb2xiYXItaXRlbSBzcGFjZWQgXCIgKyAoaXNCb2xkID8gXCJhY3RpdmVcIiA6IFwiXCIpfVxuICAgICAgICAgICAgYXJpYS1sYWJlbD1cIkZvcm1hdCBCb2xkXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJmb3JtYXQgYm9sZFwiIC8+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKEZPUk1BVF9URVhUX0NPTU1BTkQsIFwiaXRhbGljXCIpO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17XCJ0b29sYmFyLWl0ZW0gc3BhY2VkIFwiICsgKGlzSXRhbGljID8gXCJhY3RpdmVcIiA6IFwiXCIpfVxuICAgICAgICAgICAgYXJpYS1sYWJlbD1cIkZvcm1hdCBJdGFsaWNzXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJmb3JtYXQgaXRhbGljXCIgLz5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoRk9STUFUX1RFWFRfQ09NTUFORCwgXCJ1bmRlcmxpbmVcIik7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtcInRvb2xiYXItaXRlbSBzcGFjZWQgXCIgKyAoaXNVbmRlcmxpbmUgPyBcImFjdGl2ZVwiIDogXCJcIil9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPVwiRm9ybWF0IFVuZGVybGluZVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiZm9ybWF0IHVuZGVybGluZVwiIC8+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKEZPUk1BVF9URVhUX0NPTU1BTkQsIFwic3RyaWtldGhyb3VnaFwiKTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBjbGFzc05hbWU9e1xuICAgICAgICAgICAgICBcInRvb2xiYXItaXRlbSBzcGFjZWQgXCIgKyAoaXNTdHJpa2V0aHJvdWdoID8gXCJhY3RpdmVcIiA6IFwiXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPVwiRm9ybWF0IFN0cmlrZXRocm91Z2hcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImZvcm1hdCBzdHJpa2V0aHJvdWdoXCIgLz5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoRk9STUFUX1RFWFRfQ09NTUFORCwgXCJjb2RlXCIpO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17XCJ0b29sYmFyLWl0ZW0gc3BhY2VkIFwiICsgKGlzQ29kZSA/IFwiYWN0aXZlXCIgOiBcIlwiKX1cbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJJbnNlcnQgQ29kZVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiZm9ybWF0IGNvZGVcIiAvPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIG9uQ2xpY2s9e2luc2VydExpbmt9XG4gICAgICAgICAgICBjbGFzc05hbWU9e1widG9vbGJhci1pdGVtIHNwYWNlZCBcIiArIChpc0xpbmsgPyBcImFjdGl2ZVwiIDogXCJcIil9XG4gICAgICAgICAgICBhcmlhLWxhYmVsPVwiSW5zZXJ0IExpbmtcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImZvcm1hdCBsaW5rXCIgLz5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICB7aXNMaW5rICYmXG4gICAgICAgICAgICBjcmVhdGVQb3J0YWwoPEZsb2F0aW5nTGlua0VkaXRvciBlZGl0b3I9e2VkaXRvcn0gLz4sIGRvY3VtZW50LmJvZHkpfVxuICAgICAgICAgIDxEaXZpZGVyIC8+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKEZPUk1BVF9FTEVNRU5UX0NPTU1BTkQsIFwibGVmdFwiKTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ0b29sYmFyLWl0ZW0gc3BhY2VkXCJcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJMZWZ0IEFsaWduXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8aSBjbGFzc05hbWU9XCJmb3JtYXQgbGVmdC1hbGlnblwiIC8+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKEZPUk1BVF9FTEVNRU5UX0NPTU1BTkQsIFwiY2VudGVyXCIpO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInRvb2xiYXItaXRlbSBzcGFjZWRcIlxuICAgICAgICAgICAgYXJpYS1sYWJlbD1cIkNlbnRlciBBbGlnblwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGkgY2xhc3NOYW1lPVwiZm9ybWF0IGNlbnRlci1hbGlnblwiIC8+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKEZPUk1BVF9FTEVNRU5UX0NPTU1BTkQsIFwicmlnaHRcIik7XG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidG9vbGJhci1pdGVtIHNwYWNlZFwiXG4gICAgICAgICAgICBhcmlhLWxhYmVsPVwiUmlnaHQgQWxpZ25cIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImZvcm1hdCByaWdodC1hbGlnblwiIC8+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKEZPUk1BVF9FTEVNRU5UX0NPTU1BTkQsIFwianVzdGlmeVwiKTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ0b29sYmFyLWl0ZW1cIlxuICAgICAgICAgICAgYXJpYS1sYWJlbD1cIkp1c3RpZnkgQWxpZ25cIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxpIGNsYXNzTmFtZT1cImZvcm1hdCBqdXN0aWZ5LWFsaWduXCIgLz5cbiAgICAgICAgICA8L2J1dHRvbj57XCIgXCJ9XG4gICAgICAgIDwvPlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlU3RhdGUiLCJDQU5fUkVET19DT01NQU5EIiwiQ0FOX1VORE9fQ09NTUFORCIsIlJFRE9fQ09NTUFORCIsIlVORE9fQ09NTUFORCIsIlNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCIsIkZPUk1BVF9URVhUX0NPTU1BTkQiLCJGT1JNQVRfRUxFTUVOVF9DT01NQU5EIiwiJGdldFNlbGVjdGlvbiIsIiRpc1JhbmdlU2VsZWN0aW9uIiwiJGNyZWF0ZVBhcmFncmFwaE5vZGUiLCIkZ2V0Tm9kZUJ5S2V5IiwiJGlzTGlua05vZGUiLCJUT0dHTEVfTElOS19DT01NQU5EIiwiJGlzUGFyZW50RWxlbWVudFJUTCIsIiR3cmFwTm9kZXMiLCIkaXNBdE5vZGVFbmQiLCIkZ2V0TmVhcmVzdE5vZGVPZlR5cGUiLCJtZXJnZVJlZ2lzdGVyIiwiSU5TRVJUX09SREVSRURfTElTVF9DT01NQU5EIiwiSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQiLCJSRU1PVkVfTElTVF9DT01NQU5EIiwiJGlzTGlzdE5vZGUiLCJMaXN0Tm9kZSIsImNyZWF0ZVBvcnRhbCIsIiRjcmVhdGVIZWFkaW5nTm9kZSIsIiRjcmVhdGVRdW90ZU5vZGUiLCIkaXNIZWFkaW5nTm9kZSIsIiRjcmVhdGVDb2RlTm9kZSIsIiRpc0NvZGVOb2RlIiwiZ2V0RGVmYXVsdENvZGVMYW5ndWFnZSIsImdldENvZGVMYW5ndWFnZXMiLCJMb3dQcmlvcml0eSIsInN1cHBvcnRlZEJsb2NrVHlwZXMiLCJTZXQiLCJibG9ja1R5cGVUb0Jsb2NrTmFtZSIsImNvZGUiLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1Iiwib2wiLCJwYXJhZ3JhcGgiLCJxdW90ZSIsInVsIiwiRGl2aWRlciIsImRpdiIsImNsYXNzTmFtZSIsInBvc2l0aW9uRWRpdG9yRWxlbWVudCIsImVkaXRvciIsInJlY3QiLCJzdHlsZSIsIm9wYWNpdHkiLCJ0b3AiLCJsZWZ0IiwiaGVpZ2h0Iiwid2luZG93IiwicGFnZVlPZmZzZXQiLCJwYWdlWE9mZnNldCIsIm9mZnNldFdpZHRoIiwid2lkdGgiLCJGbG9hdGluZ0xpbmtFZGl0b3IiLCJlZGl0b3JSZWYiLCJpbnB1dFJlZiIsIm1vdXNlRG93blJlZiIsImxpbmtVcmwiLCJzZXRMaW5rVXJsIiwiaXNFZGl0TW9kZSIsInNldEVkaXRNb2RlIiwibGFzdFNlbGVjdGlvbiIsInNldExhc3RTZWxlY3Rpb24iLCJ1cGRhdGVMaW5rRWRpdG9yIiwic2VsZWN0aW9uIiwibm9kZSIsImdldFNlbGVjdGVkTm9kZSIsInBhcmVudCIsImdldFBhcmVudCIsImdldFVSTCIsImVkaXRvckVsZW0iLCJjdXJyZW50IiwibmF0aXZlU2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9uIiwiYWN0aXZlRWxlbWVudCIsImRvY3VtZW50Iiwicm9vdEVsZW1lbnQiLCJnZXRSb290RWxlbWVudCIsImlzQ29sbGFwc2VkIiwiY29udGFpbnMiLCJhbmNob3JOb2RlIiwiZG9tUmFuZ2UiLCJnZXRSYW5nZUF0IiwiaW5uZXIiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIiLCJlZGl0b3JTdGF0ZSIsInJlYWQiLCJyZWdpc3RlckNvbW1hbmQiLCJnZXRFZGl0b3JTdGF0ZSIsImZvY3VzIiwicmVmIiwiaW5wdXQiLCJ2YWx1ZSIsIm9uQ2hhbmdlIiwiZXZlbnQiLCJ0YXJnZXQiLCJvbktleURvd24iLCJrZXkiLCJwcmV2ZW50RGVmYXVsdCIsImRpc3BhdGNoQ29tbWFuZCIsImEiLCJocmVmIiwicmVsIiwicm9sZSIsInRhYkluZGV4Iiwib25Nb3VzZURvd24iLCJvbkNsaWNrIiwiU2VsZWN0Iiwib3B0aW9ucyIsInNlbGVjdCIsIm9wdGlvbiIsImhpZGRlbiIsIm1hcCIsImFuY2hvciIsImdldE5vZGUiLCJmb2N1c05vZGUiLCJpc0JhY2t3YXJkIiwiQmxvY2tPcHRpb25zRHJvcGRvd25MaXN0IiwiYmxvY2tUeXBlIiwidG9vbGJhclJlZiIsInNldFNob3dCbG9ja09wdGlvbnNEcm9wRG93biIsImRyb3BEb3duUmVmIiwidG9vbGJhciIsImRyb3BEb3duIiwiaGFuZGxlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmb3JtYXRQYXJhZ3JhcGgiLCJ1cGRhdGUiLCJmb3JtYXRMYXJnZUhlYWRpbmciLCJmb3JtYXRTbWFsbEhlYWRpbmciLCJmb3JtYXRCdWxsZXRMaXN0IiwiZm9ybWF0TnVtYmVyZWRMaXN0IiwiZm9ybWF0UXVvdGUiLCJmb3JtYXRDb2RlIiwiYnV0dG9uIiwic3BhbiIsIlRvb2xiYXJQbHVnaW4iLCJjYW5VbmRvIiwic2V0Q2FuVW5kbyIsImNhblJlZG8iLCJzZXRDYW5SZWRvIiwic2V0QmxvY2tUeXBlIiwic2VsZWN0ZWRFbGVtZW50S2V5Iiwic2V0U2VsZWN0ZWRFbGVtZW50S2V5Iiwic2hvd0Jsb2NrT3B0aW9uc0Ryb3BEb3duIiwiY29kZUxhbmd1YWdlIiwic2V0Q29kZUxhbmd1YWdlIiwiaXNSVEwiLCJzZXRJc1JUTCIsImlzTGluayIsInNldElzTGluayIsImlzQm9sZCIsInNldElzQm9sZCIsImlzSXRhbGljIiwic2V0SXNJdGFsaWMiLCJpc1VuZGVybGluZSIsInNldElzVW5kZXJsaW5lIiwiaXNTdHJpa2V0aHJvdWdoIiwic2V0SXNTdHJpa2V0aHJvdWdoIiwiaXNDb2RlIiwic2V0SXNDb2RlIiwidXBkYXRlVG9vbGJhciIsImVsZW1lbnQiLCJnZXRLZXkiLCJnZXRUb3BMZXZlbEVsZW1lbnRPclRocm93IiwiZWxlbWVudEtleSIsImVsZW1lbnRET00iLCJnZXRFbGVtZW50QnlLZXkiLCJwYXJlbnRMaXN0IiwidHlwZSIsImdldFRhZyIsImdldFR5cGUiLCJnZXRMYW5ndWFnZSIsImhhc0Zvcm1hdCIsIl9wYXlsb2FkIiwibmV3RWRpdG9yIiwicGF5bG9hZCIsImNvZGVMYW5ndWdlcyIsIm9uQ29kZUxhbmd1YWdlU2VsZWN0IiwiZSIsInNldExhbmd1YWdlIiwiaW5zZXJ0TGluayIsImRpc2FibGVkIiwiYXJpYS1sYWJlbCIsImkiLCJoYXMiLCJib2R5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/plugins/ToolbarPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/plugins/TreeViewPlugin.js":
/*!**********************************************************!*\
  !*** ./src/components/Lexical/plugins/TreeViewPlugin.js ***!
  \**********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ TreeViewPlugin; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalComposerContext.js\");\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lexical_react_LexicalTreeView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalTreeView */ \"(app-pages-browser)/./node_modules/@lexical/react/LexicalTreeView.js\");\n/* harmony import */ var _lexical_react_LexicalTreeView__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lexical_react_LexicalTreeView__WEBPACK_IMPORTED_MODULE_2__);\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ \nvar _s = $RefreshSig$();\n\n\nfunction TreeViewPlugin() {\n    _s();\n    const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext)();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalTreeView__WEBPACK_IMPORTED_MODULE_2__.TreeView, {\n        viewClassName: \"tree-view-output\",\n        treeTypeButtonClassName: \"debug-treetype-button\",\n        timeTravelPanelClassName: \"debug-timetravel-panel\",\n        timeTravelButtonClassName: \"debug-timetravel-button\",\n        timeTravelPanelSliderClassName: \"debug-timetravel-panel-slider\",\n        timeTravelPanelButtonClassName: \"debug-timetravel-panel-button\",\n        editor: editor\n    }, void 0, false, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/Lexical/plugins/TreeViewPlugin.js\",\n        lineNumber: 15,\n        columnNumber: 5\n    }, this);\n}\n_s(TreeViewPlugin, \"MUJTZ3t3NKyXWeKoJUbyWHO70Z4=\", false, function() {\n    return [\n        _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext\n    ];\n});\n_c = TreeViewPlugin;\nvar _c;\n$RefreshReg$(_c, \"TreeViewPlugin\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvcGx1Z2lucy9UcmVlVmlld1BsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUM7O0FBRWlGO0FBQ3hCO0FBRTNDLFNBQVNFOztJQUN0QixNQUFNLENBQUNDLE9BQU8sR0FBR0gsZ0dBQXlCQTtJQUMxQyxxQkFDRSw4REFBQ0Msb0VBQVFBO1FBQ1BHLGVBQWM7UUFDZEMseUJBQXdCO1FBQ3hCQywwQkFBeUI7UUFDekJDLDJCQUEwQjtRQUMxQkMsZ0NBQStCO1FBQy9CQyxnQ0FBK0I7UUFDL0JOLFFBQVFBOzs7Ozs7QUFHZDtHQWJ3QkQ7O1FBQ0xGLDRGQUF5QkE7OztLQURwQkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTGV4aWNhbC9wbHVnaW5zL1RyZWVWaWV3UGx1Z2luLmpzPzM4ZmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCc7XG5pbXBvcnQgeyBUcmVlVmlldyB9IGZyb20gJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxUcmVlVmlldyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRyZWVWaWV3UGx1Z2luKCkge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgcmV0dXJuIChcbiAgICA8VHJlZVZpZXdcbiAgICAgIHZpZXdDbGFzc05hbWU9XCJ0cmVlLXZpZXctb3V0cHV0XCJcbiAgICAgIHRyZWVUeXBlQnV0dG9uQ2xhc3NOYW1lPVwiZGVidWctdHJlZXR5cGUtYnV0dG9uXCJcbiAgICAgIHRpbWVUcmF2ZWxQYW5lbENsYXNzTmFtZT1cImRlYnVnLXRpbWV0cmF2ZWwtcGFuZWxcIlxuICAgICAgdGltZVRyYXZlbEJ1dHRvbkNsYXNzTmFtZT1cImRlYnVnLXRpbWV0cmF2ZWwtYnV0dG9uXCJcbiAgICAgIHRpbWVUcmF2ZWxQYW5lbFNsaWRlckNsYXNzTmFtZT1cImRlYnVnLXRpbWV0cmF2ZWwtcGFuZWwtc2xpZGVyXCJcbiAgICAgIHRpbWVUcmF2ZWxQYW5lbEJ1dHRvbkNsYXNzTmFtZT1cImRlYnVnLXRpbWV0cmF2ZWwtcGFuZWwtYnV0dG9uXCJcbiAgICAgIGVkaXRvcj17ZWRpdG9yfVxuICAgIC8+XG4gICk7XG59XG4iXSwibmFtZXMiOlsidXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCIsIlRyZWVWaWV3IiwiVHJlZVZpZXdQbHVnaW4iLCJlZGl0b3IiLCJ2aWV3Q2xhc3NOYW1lIiwidHJlZVR5cGVCdXR0b25DbGFzc05hbWUiLCJ0aW1lVHJhdmVsUGFuZWxDbGFzc05hbWUiLCJ0aW1lVHJhdmVsQnV0dG9uQ2xhc3NOYW1lIiwidGltZVRyYXZlbFBhbmVsU2xpZGVyQ2xhc3NOYW1lIiwidGltZVRyYXZlbFBhbmVsQnV0dG9uQ2xhc3NOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/plugins/TreeViewPlugin.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/utils/canUseDom.js":
/*!***************************************************!*\
  !*** ./src/components/Lexical/utils/canUseDom.js ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CAN_USE_DOM: function() { return /* binding */ CAN_USE_DOM; }\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ const CAN_USE_DOM =  true && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvdXRpbHMvY2FuVXNlRG9tLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FFTSxNQUFNQSxjQUNYLEtBQWtCLElBQ2xCLE9BQU9DLE9BQU9DLFFBQVEsS0FBSyxlQUMzQixPQUFPRCxPQUFPQyxRQUFRLENBQUNDLGFBQWEsS0FBSyxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvdXRpbHMvY2FuVXNlRG9tLmpzP2EyMzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5leHBvcnQgY29uc3QgQ0FOX1VTRV9ET00gPVxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnOyJdLCJuYW1lcyI6WyJDQU5fVVNFX0RPTSIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/utils/canUseDom.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/utils/getSelectedNode.js":
/*!*********************************************************!*\
  !*** ./src/components/Lexical/utils/getSelectedNode.js ***!
  \*********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getSelectedNode: function() { return /* binding */ getSelectedNode; }\n/* harmony export */ });\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/selection */ \"(app-pages-browser)/./node_modules/@lexical/selection/LexicalSelection.js\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lexical_selection__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ \nfunction getSelectedNode(selection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (anchorNode === focusNode) {\n        return anchorNode;\n    }\n    const isBackward = selection.isBackward();\n    if (isBackward) {\n        return (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_0__.$isAtNodeEnd)(focus) ? anchorNode : focusNode;\n    } else {\n        return (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_0__.$isAtNodeEnd)(anchor) ? anchorNode : focusNode;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvdXRpbHMvZ2V0U2VsZWN0ZWROb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNpRDtBQUUzQyxTQUFTQyxnQkFDZEMsU0FBUztJQUVULE1BQU1DLFNBQVNELFVBQVVDLE1BQU07SUFDL0IsTUFBTUMsUUFBUUYsVUFBVUUsS0FBSztJQUM3QixNQUFNQyxhQUFhSCxVQUFVQyxNQUFNLENBQUNHLE9BQU87SUFDM0MsTUFBTUMsWUFBWUwsVUFBVUUsS0FBSyxDQUFDRSxPQUFPO0lBQ3pDLElBQUlELGVBQWVFLFdBQVc7UUFDNUIsT0FBT0Y7SUFDVDtJQUNBLE1BQU1HLGFBQWFOLFVBQVVNLFVBQVU7SUFDdkMsSUFBSUEsWUFBWTtRQUNkLE9BQU9SLGdFQUFZQSxDQUFDSSxTQUFTQyxhQUFhRTtJQUM1QyxPQUFPO1FBQ0wsT0FBT1AsZ0VBQVlBLENBQUNHLFVBQVVFLGFBQWFFO0lBQzdDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTGV4aWNhbC91dGlscy9nZXRTZWxlY3RlZE5vZGUuanM/NDQ4MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5pbXBvcnQgeyAkaXNBdE5vZGVFbmQgfSBmcm9tICdAbGV4aWNhbC9zZWxlY3Rpb24nO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VsZWN0ZWROb2RlKFxuICBzZWxlY3Rpb24sXG4pIHtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgaWYgKGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSkge1xuICAgIHJldHVybiBhbmNob3JOb2RlO1xuICB9XG4gIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICBpZiAoaXNCYWNrd2FyZCkge1xuICAgIHJldHVybiAkaXNBdE5vZGVFbmQoZm9jdXMpID8gYW5jaG9yTm9kZSA6IGZvY3VzTm9kZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJGlzQXROb2RlRW5kKGFuY2hvcikgPyBhbmNob3JOb2RlIDogZm9jdXNOb2RlO1xuICB9XG59Il0sIm5hbWVzIjpbIiRpc0F0Tm9kZUVuZCIsImdldFNlbGVjdGVkTm9kZSIsInNlbGVjdGlvbiIsImFuY2hvciIsImZvY3VzIiwiYW5jaG9yTm9kZSIsImdldE5vZGUiLCJmb2N1c05vZGUiLCJpc0JhY2t3YXJkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/utils/getSelectedNode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/utils/joinClasses.js":
/*!*****************************************************!*\
  !*** ./src/components/Lexical/utils/joinClasses.js ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ joinClasses; }\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ function joinClasses() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return args.filter(Boolean).join(\" \");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvdXRpbHMvam9pbkNsYXNzZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7Q0FNQyxHQUVjLFNBQVNBO0lBQ3RCO1FBQUdDLEtBQUgsdUJBQU87O0lBRVAsT0FBT0EsS0FBS0MsTUFBTSxDQUFDQyxTQUFTQyxJQUFJLENBQUM7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTGV4aWNhbC91dGlscy9qb2luQ2xhc3Nlcy5qcz84Mjg5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gam9pbkNsYXNzZXMoXG4gIC4uLmFyZ3Ncbikge1xuICByZXR1cm4gYXJncy5maWx0ZXIoQm9vbGVhbikuam9pbignICcpO1xufSJdLCJuYW1lcyI6WyJqb2luQ2xhc3NlcyIsImFyZ3MiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/utils/joinClasses.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/utils/setFloatingElemPositionForLinkEditor.js":
/*!******************************************************************************!*\
  !*** ./src/components/Lexical/utils/setFloatingElemPositionForLinkEditor.js ***!
  \******************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setFloatingElemPositionForLinkEditor: function() { return /* binding */ setFloatingElemPositionForLinkEditor; }\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ const VERTICAL_GAP = 10;\nconst HORIZONTAL_OFFSET = 5;\nfunction setFloatingElemPositionForLinkEditor(targetRect, floatingElem, anchorElem) {\n    let verticalGap = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : VERTICAL_GAP, horizontalOffset = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : HORIZONTAL_OFFSET;\n    const scrollerElem = anchorElem.parentElement;\n    if (targetRect === null || !scrollerElem) {\n        floatingElem.style.opacity = \"0\";\n        floatingElem.style.transform = \"translate(-10000px, -10000px)\";\n        return;\n    }\n    const floatingElemRect = floatingElem.getBoundingClientRect();\n    const anchorElementRect = anchorElem.getBoundingClientRect();\n    const editorScrollerRect = scrollerElem.getBoundingClientRect();\n    let top = targetRect.top - verticalGap;\n    let left = targetRect.left - horizontalOffset;\n    if (top < editorScrollerRect.top) {\n        top += floatingElemRect.height + targetRect.height + verticalGap * 2;\n    }\n    if (left + floatingElemRect.width > editorScrollerRect.right) {\n        left = editorScrollerRect.right - floatingElemRect.width - horizontalOffset;\n    }\n    top -= anchorElementRect.top;\n    left -= anchorElementRect.left;\n    floatingElem.style.opacity = \"1\";\n    floatingElem.style.transform = \"translate(\".concat(left, \"px, \").concat(top, \"px)\");\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvdXRpbHMvc2V0RmxvYXRpbmdFbGVtUG9zaXRpb25Gb3JMaW5rRWRpdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FDRCxNQUFNQSxlQUFlO0FBQ3JCLE1BQU1DLG9CQUFvQjtBQUVuQixTQUFTQyxxQ0FDZEMsVUFBVSxFQUNWQyxZQUFZLEVBQ1pDLFVBQVU7UUFDVkMsY0FBQUEsaUVBQWNOLGNBQ2RPLG1CQUFBQSxpRUFBbUJOO0lBRW5CLE1BQU1PLGVBQWVILFdBQVdJLGFBQWE7SUFFN0MsSUFBSU4sZUFBZSxRQUFRLENBQUNLLGNBQWM7UUFDeENKLGFBQWFNLEtBQUssQ0FBQ0MsT0FBTyxHQUFHO1FBQzdCUCxhQUFhTSxLQUFLLENBQUNFLFNBQVMsR0FBRztRQUMvQjtJQUNGO0lBRUEsTUFBTUMsbUJBQW1CVCxhQUFhVSxxQkFBcUI7SUFDM0QsTUFBTUMsb0JBQW9CVixXQUFXUyxxQkFBcUI7SUFDMUQsTUFBTUUscUJBQXFCUixhQUFhTSxxQkFBcUI7SUFFN0QsSUFBSUcsTUFBTWQsV0FBV2MsR0FBRyxHQUFHWDtJQUMzQixJQUFJWSxPQUFPZixXQUFXZSxJQUFJLEdBQUdYO0lBRTdCLElBQUlVLE1BQU1ELG1CQUFtQkMsR0FBRyxFQUFFO1FBQ2hDQSxPQUFPSixpQkFBaUJNLE1BQU0sR0FBR2hCLFdBQVdnQixNQUFNLEdBQUdiLGNBQWM7SUFDckU7SUFFQSxJQUFJWSxPQUFPTCxpQkFBaUJPLEtBQUssR0FBR0osbUJBQW1CSyxLQUFLLEVBQUU7UUFDNURILE9BQU9GLG1CQUFtQkssS0FBSyxHQUFHUixpQkFBaUJPLEtBQUssR0FBR2I7SUFDN0Q7SUFFQVUsT0FBT0Ysa0JBQWtCRSxHQUFHO0lBQzVCQyxRQUFRSCxrQkFBa0JHLElBQUk7SUFFOUJkLGFBQWFNLEtBQUssQ0FBQ0MsT0FBTyxHQUFHO0lBQzdCUCxhQUFhTSxLQUFLLENBQUNFLFNBQVMsR0FBRyxhQUF3QkssT0FBWEMsTUFBSyxRQUFVLE9BQUpELEtBQUk7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTGV4aWNhbC91dGlscy9zZXRGbG9hdGluZ0VsZW1Qb3NpdGlvbkZvckxpbmtFZGl0b3IuanM/YjM4NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBWRVJUSUNBTF9HQVAgPSAxMDtcbmNvbnN0IEhPUklaT05UQUxfT0ZGU0VUID0gNTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldEZsb2F0aW5nRWxlbVBvc2l0aW9uRm9yTGlua0VkaXRvcihcbiAgdGFyZ2V0UmVjdCxcbiAgZmxvYXRpbmdFbGVtLFxuICBhbmNob3JFbGVtLFxuICB2ZXJ0aWNhbEdhcCA9IFZFUlRJQ0FMX0dBUCxcbiAgaG9yaXpvbnRhbE9mZnNldCA9IEhPUklaT05UQUxfT0ZGU0VULFxuKSB7XG4gIGNvbnN0IHNjcm9sbGVyRWxlbSA9IGFuY2hvckVsZW0ucGFyZW50RWxlbWVudDtcblxuICBpZiAodGFyZ2V0UmVjdCA9PT0gbnVsbCB8fCAhc2Nyb2xsZXJFbGVtKSB7XG4gICAgZmxvYXRpbmdFbGVtLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgZmxvYXRpbmdFbGVtLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTEwMDAwcHgsIC0xMDAwMHB4KSc7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZmxvYXRpbmdFbGVtUmVjdCA9IGZsb2F0aW5nRWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgYW5jaG9yRWxlbWVudFJlY3QgPSBhbmNob3JFbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBlZGl0b3JTY3JvbGxlclJlY3QgPSBzY3JvbGxlckVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgbGV0IHRvcCA9IHRhcmdldFJlY3QudG9wIC0gdmVydGljYWxHYXA7XG4gIGxldCBsZWZ0ID0gdGFyZ2V0UmVjdC5sZWZ0IC0gaG9yaXpvbnRhbE9mZnNldDtcblxuICBpZiAodG9wIDwgZWRpdG9yU2Nyb2xsZXJSZWN0LnRvcCkge1xuICAgIHRvcCArPSBmbG9hdGluZ0VsZW1SZWN0LmhlaWdodCArIHRhcmdldFJlY3QuaGVpZ2h0ICsgdmVydGljYWxHYXAgKiAyO1xuICB9XG5cbiAgaWYgKGxlZnQgKyBmbG9hdGluZ0VsZW1SZWN0LndpZHRoID4gZWRpdG9yU2Nyb2xsZXJSZWN0LnJpZ2h0KSB7XG4gICAgbGVmdCA9IGVkaXRvclNjcm9sbGVyUmVjdC5yaWdodCAtIGZsb2F0aW5nRWxlbVJlY3Qud2lkdGggLSBob3Jpem9udGFsT2Zmc2V0O1xuICB9XG5cbiAgdG9wIC09IGFuY2hvckVsZW1lbnRSZWN0LnRvcDtcbiAgbGVmdCAtPSBhbmNob3JFbGVtZW50UmVjdC5sZWZ0O1xuXG4gIGZsb2F0aW5nRWxlbS5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuICBmbG9hdGluZ0VsZW0uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2xlZnR9cHgsICR7dG9wfXB4KWA7XG59Il0sIm5hbWVzIjpbIlZFUlRJQ0FMX0dBUCIsIkhPUklaT05UQUxfT0ZGU0VUIiwic2V0RmxvYXRpbmdFbGVtUG9zaXRpb25Gb3JMaW5rRWRpdG9yIiwidGFyZ2V0UmVjdCIsImZsb2F0aW5nRWxlbSIsImFuY2hvckVsZW0iLCJ2ZXJ0aWNhbEdhcCIsImhvcml6b250YWxPZmZzZXQiLCJzY3JvbGxlckVsZW0iLCJwYXJlbnRFbGVtZW50Iiwic3R5bGUiLCJvcGFjaXR5IiwidHJhbnNmb3JtIiwiZmxvYXRpbmdFbGVtUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImFuY2hvckVsZW1lbnRSZWN0IiwiZWRpdG9yU2Nyb2xsZXJSZWN0IiwidG9wIiwibGVmdCIsImhlaWdodCIsIndpZHRoIiwicmlnaHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/utils/setFloatingElemPositionForLinkEditor.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/Lexical/utils/url.js":
/*!*********************************************!*\
  !*** ./src/components/Lexical/utils/url.js ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sanitizeUrl: function() { return /* binding */ sanitizeUrl; },\n/* harmony export */   validateUrl: function() { return /* binding */ validateUrl; }\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ function sanitizeUrl(url) {\n    /** A pattern that matches safe  URLs. */ const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi;\n    /** A pattern that matches safe data URLs. */ const DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;\n    url = String(url).trim();\n    if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN)) return url;\n    return \"https://\";\n}\n// Source: https://stackoverflow.com/a/8234912/2013580\nconst urlRegExp = new RegExp(/((([A-Za-z]{3,9}:(?:\\/\\/)?)(?:[-;:&=+$,\\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=+$,\\w]+@)[A-Za-z0-9.-]+)((?:\\/[+~%/.\\w-_]*)?\\??(?:[-+=&;%@.\\w_]*)#?(?:[\\w]*))?)/);\nfunction validateUrl(url) {\n    // TODO Fix UI for link insertion; it should never default to an invalid URL such as https://.\n    // Maybe show a dialog where they user can type the URL before inserting it.\n    return url === \"https://\" || urlRegExp.test(url);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvdXRpbHMvdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7OztDQU1DLEdBRU0sU0FBU0EsWUFBWUMsR0FBRztJQUM3Qix1Q0FBdUMsR0FDdkMsTUFBTUMsbUJBQ0o7SUFFRiwyQ0FBMkMsR0FDM0MsTUFBTUMsbUJBQ0o7SUFFRkYsTUFBTUcsT0FBT0gsS0FBS0ksSUFBSTtJQUV0QixJQUFJSixJQUFJSyxLQUFLLENBQUNKLHFCQUFxQkQsSUFBSUssS0FBSyxDQUFDSCxtQkFBbUIsT0FBT0Y7SUFFdkUsT0FBTztBQUNUO0FBRUEsc0RBQXNEO0FBQ3RELE1BQU1NLFlBQVksSUFBSUMsT0FDcEI7QUFFSyxTQUFTQyxZQUFZUixHQUFHO0lBQzdCLDhGQUE4RjtJQUM5Riw0RUFBNEU7SUFDNUUsT0FBT0EsUUFBUSxjQUFjTSxVQUFVRyxJQUFJLENBQUNUO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL0xleGljYWwvdXRpbHMvdXJsLmpzPzViMzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVVcmwodXJsKXtcbiAgLyoqIEEgcGF0dGVybiB0aGF0IG1hdGNoZXMgc2FmZSAgVVJMcy4gKi9cbiAgY29uc3QgU0FGRV9VUkxfUEFUVEVSTiA9XG4gICAgL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZXxzbXMpOnxbXiY6Lz8jXSooPzpbLz8jXXwkKSkvZ2k7XG5cbiAgLyoqIEEgcGF0dGVybiB0aGF0IG1hdGNoZXMgc2FmZSBkYXRhIFVSTHMuICovXG4gIGNvbnN0IERBVEFfVVJMX1BBVFRFUk4gPVxuICAgIC9eZGF0YTooPzppbWFnZVxcLyg/OmJtcHxnaWZ8anBlZ3xqcGd8cG5nfHRpZmZ8d2VicCl8dmlkZW9cXC8oPzptcGVnfG1wNHxvZ2d8d2VibSl8YXVkaW9cXC8oPzptcDN8b2dhfG9nZ3xvcHVzKSk7YmFzZTY0LFthLXowLTkrL10rPSokL2k7XG5cbiAgdXJsID0gU3RyaW5nKHVybCkudHJpbSgpO1xuXG4gIGlmICh1cmwubWF0Y2goU0FGRV9VUkxfUEFUVEVSTikgfHwgdXJsLm1hdGNoKERBVEFfVVJMX1BBVFRFUk4pKSByZXR1cm4gdXJsO1xuXG4gIHJldHVybiAnaHR0cHM6Ly8nO1xufVxuXG4vLyBTb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84MjM0OTEyLzIwMTM1ODBcbmNvbnN0IHVybFJlZ0V4cCA9IG5ldyBSZWdFeHAoXG4gIC8oKChbQS1aYS16XXszLDl9Oig/OlxcL1xcLyk/KSg/OlstOzomPSskLFxcd10rQCk/W0EtWmEtejAtOS4tXSt8KD86d3d3LnxbLTs6Jj0rJCxcXHddK0ApW0EtWmEtejAtOS4tXSspKCg/OlxcL1srfiUvLlxcdy1fXSopP1xcPz8oPzpbLSs9JjslQC5cXHdfXSopIz8oPzpbXFx3XSopKT8pLyxcbik7XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVVcmwodXJsKSB7XG4gIC8vIFRPRE8gRml4IFVJIGZvciBsaW5rIGluc2VydGlvbjsgaXQgc2hvdWxkIG5ldmVyIGRlZmF1bHQgdG8gYW4gaW52YWxpZCBVUkwgc3VjaCBhcyBodHRwczovLy5cbiAgLy8gTWF5YmUgc2hvdyBhIGRpYWxvZyB3aGVyZSB0aGV5IHVzZXIgY2FuIHR5cGUgdGhlIFVSTCBiZWZvcmUgaW5zZXJ0aW5nIGl0LlxuICByZXR1cm4gdXJsID09PSAnaHR0cHM6Ly8nIHx8IHVybFJlZ0V4cC50ZXN0KHVybCk7XG59Il0sIm5hbWVzIjpbInNhbml0aXplVXJsIiwidXJsIiwiU0FGRV9VUkxfUEFUVEVSTiIsIkRBVEFfVVJMX1BBVFRFUk4iLCJTdHJpbmciLCJ0cmltIiwibWF0Y2giLCJ1cmxSZWdFeHAiLCJSZWdFeHAiLCJ2YWxpZGF0ZVVybCIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/Lexical/utils/url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/Button.jsx":
/*!**************************************!*\
  !*** ./src/components/ui/Button.jsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Button; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _Button_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Button.css */ \"(app-pages-browser)/./src/components/ui/Button.css\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Lexical_utils_joinClasses__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! .././Lexical/utils/joinClasses */ \"(app-pages-browser)/./src/components/Lexical/utils/joinClasses.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ \n\n\n\nfunction Button(param) {\n    let { \"data-test-id\": dataTestId, children, className, onClick, disabled, small, title } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        disabled: disabled,\n        className: (0,_Lexical_utils_joinClasses__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\"Button__root\", disabled && \"Button__disabled\", small && \"Button__small\", className),\n        onClick: onClick,\n        title: title,\n        \"aria-label\": title,\n        ...dataTestId && {\n            \"data-test-id\": dataTestId\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/ui/Button.jsx\",\n        lineNumber: 25,\n        columnNumber: 5\n    }, this);\n}\n_c = Button;\nvar _c;\n$RefreshReg$(_c, \"Button\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL0J1dHRvbi5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7OztDQU1DO0FBRXFCO0FBRVM7QUFFMEI7QUFFMUMsU0FBU0UsT0FBTyxLQVE5QjtRQVI4QixFQUM3QixnQkFBZ0JDLFVBQVUsRUFDMUJDLFFBQVEsRUFDUkMsU0FBUyxFQUNUQyxPQUFPLEVBQ1BDLFFBQVEsRUFDUkMsS0FBSyxFQUNMQyxLQUFLLEVBQ04sR0FSOEI7SUFTN0IscUJBQ0UsOERBQUNDO1FBQ0NILFVBQVVBO1FBQ1ZGLFdBQVdKLHNFQUFXQSxDQUNwQixnQkFDQU0sWUFBWSxvQkFDWkMsU0FBUyxpQkFDVEg7UUFFRkMsU0FBU0E7UUFDVEcsT0FBT0E7UUFDUEUsY0FBWUY7UUFDWCxHQUFJTixjQUFjO1lBQUUsZ0JBQWdCQTtRQUFXLENBQUM7a0JBQ2hEQzs7Ozs7O0FBR1A7S0F6QndCRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy91aS9CdXR0b24uanN4PzFhODgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgJy4vQnV0dG9uLmNzcyc7XG5cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IGpvaW5DbGFzc2VzIGZyb20gJy4uLy4vTGV4aWNhbC91dGlscy9qb2luQ2xhc3Nlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJ1dHRvbih7XG4gICdkYXRhLXRlc3QtaWQnOiBkYXRhVGVzdElkLFxuICBjaGlsZHJlbixcbiAgY2xhc3NOYW1lLFxuICBvbkNsaWNrLFxuICBkaXNhYmxlZCxcbiAgc21hbGwsXG4gIHRpdGxlLFxufSkge1xuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgIGNsYXNzTmFtZT17am9pbkNsYXNzZXMoXG4gICAgICAgICdCdXR0b25fX3Jvb3QnLFxuICAgICAgICBkaXNhYmxlZCAmJiAnQnV0dG9uX19kaXNhYmxlZCcsXG4gICAgICAgIHNtYWxsICYmICdCdXR0b25fX3NtYWxsJyxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgKX1cbiAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICB0aXRsZT17dGl0bGV9XG4gICAgICBhcmlhLWxhYmVsPXt0aXRsZX1cbiAgICAgIHsuLi4oZGF0YVRlc3RJZCAmJiB7ICdkYXRhLXRlc3QtaWQnOiBkYXRhVGVzdElkIH0pfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L2J1dHRvbj5cbiAgKTtcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJqb2luQ2xhc3NlcyIsIkJ1dHRvbiIsImRhdGFUZXN0SWQiLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsIm9uQ2xpY2siLCJkaXNhYmxlZCIsInNtYWxsIiwidGl0bGUiLCJidXR0b24iLCJhcmlhLWxhYmVsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/Button.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/Dialog.jsx":
/*!**************************************!*\
  !*** ./src/components/ui/Dialog.jsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DialogActions: function() { return /* binding */ DialogActions; },\n/* harmony export */   DialogButtonsList: function() { return /* binding */ DialogButtonsList; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _Dialog_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Dialog.css */ \"(app-pages-browser)/./src/components/ui/Dialog.css\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ \n\n\n\nfunction DialogButtonsList(param) {\n    let { children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"DialogButtonsList\",\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/ui/Dialog.jsx\",\n        lineNumber: 17,\n        columnNumber: 10\n    }, this);\n}\n_c = DialogButtonsList;\nfunction DialogActions(param) {\n    let { \"data-test-id\": dataTestId, children } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"DialogActions\",\n        \"data-test-id\": dataTestId,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/ui/Dialog.jsx\",\n        lineNumber: 25,\n        columnNumber: 5\n    }, this);\n}\n_c1 = DialogActions;\nvar _c, _c1;\n$RefreshReg$(_c, \"DialogButtonsList\");\n$RefreshReg$(_c1, \"DialogActions\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL0RpYWxvZy5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7OztDQU1DO0FBRXFCO0FBRVM7QUFDRztBQUkzQixTQUFTRSxrQkFBa0IsS0FBWTtRQUFaLEVBQUVDLFFBQVEsRUFBRSxHQUFaO0lBQ2hDLHFCQUFPLDhEQUFDQztRQUFJQyxXQUFVO2tCQUFxQkY7Ozs7OztBQUM3QztLQUZnQkQ7QUFJVCxTQUFTSSxjQUFjLEtBRzdCO1FBSDZCLEVBQzVCLGdCQUFnQkMsVUFBVSxFQUMxQkosUUFBUSxFQUNULEdBSDZCO0lBSTVCLHFCQUNFLDhEQUFDQztRQUFJQyxXQUFVO1FBQWdCRyxnQkFBY0Q7a0JBQzFDSjs7Ozs7O0FBR1A7TUFUZ0JHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3VpL0RpYWxvZy5qc3g/MDEwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCAnLi9EaWFsb2cuY3NzJztcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIERpYWxvZ0J1dHRvbnNMaXN0KHsgY2hpbGRyZW4gfSkge1xuICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJEaWFsb2dCdXR0b25zTGlzdFwiPntjaGlsZHJlbn08L2Rpdj47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEaWFsb2dBY3Rpb25zKHtcbiAgJ2RhdGEtdGVzdC1pZCc6IGRhdGFUZXN0SWQsXG4gIGNoaWxkcmVuLFxufSkge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiRGlhbG9nQWN0aW9uc1wiIGRhdGEtdGVzdC1pZD17ZGF0YVRlc3RJZH0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9kaXY+XG4gICk7XG59Il0sIm5hbWVzIjpbIlJlYWN0IiwiUmVhY3ROb2RlIiwiRGlhbG9nQnV0dG9uc0xpc3QiLCJjaGlsZHJlbiIsImRpdiIsImNsYXNzTmFtZSIsIkRpYWxvZ0FjdGlvbnMiLCJkYXRhVGVzdElkIiwiZGF0YS10ZXN0LWlkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/Dialog.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/FileInput.jsx":
/*!*****************************************!*\
  !*** ./src/components/ui/FileInput.jsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ FileInput; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _Input_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Input.css */ \"(app-pages-browser)/./src/components/ui/Input.css\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ \n\n\nfunction FileInput(param) {\n    let { accept, label, onChange, \"data-test-id\": dataTestId } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"Input__wrapper\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                className: \"Input__label\",\n                children: label\n            }, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/ui/FileInput.jsx\",\n                lineNumber: 23,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                type: \"file\",\n                accept: accept,\n                className: \"Input__input\",\n                onChange: (e)=>onChange(e.target.files),\n                \"data-test-id\": dataTestId\n            }, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/ui/FileInput.jsx\",\n                lineNumber: 24,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/ui/FileInput.jsx\",\n        lineNumber: 22,\n        columnNumber: 5\n    }, this);\n}\n_c = FileInput;\nvar _c;\n$RefreshReg$(_c, \"FileInput\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL0ZpbGVJbnB1dC5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUM7QUFFb0I7QUFFVTtBQUloQixTQUFTQyxVQUFVLEtBS2pDO1FBTGlDLEVBQ2hDQyxNQUFNLEVBQ05DLEtBQUssRUFDTEMsUUFBUSxFQUNSLGdCQUFnQkMsVUFBVSxFQUMzQixHQUxpQztJQU1oQyxxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNKO2dCQUFNSSxXQUFVOzBCQUFnQko7Ozs7OzswQkFDakMsOERBQUNLO2dCQUNDQyxNQUFLO2dCQUNMUCxRQUFRQTtnQkFDUkssV0FBVTtnQkFDVkgsVUFBVSxDQUFDTSxJQUFNTixTQUFTTSxFQUFFQyxNQUFNLENBQUNDLEtBQUs7Z0JBQ3hDQyxnQkFBY1I7Ozs7Ozs7Ozs7OztBQUl0QjtLQWxCd0JKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL3VpL0ZpbGVJbnB1dC5qc3g/YjI0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCAnLi9JbnB1dC5jc3MnO1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGaWxlSW5wdXQoe1xuICBhY2NlcHQsXG4gIGxhYmVsLFxuICBvbkNoYW5nZSxcbiAgJ2RhdGEtdGVzdC1pZCc6IGRhdGFUZXN0SWQsXG59KSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJJbnB1dF9fd3JhcHBlclwiPlxuICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cIklucHV0X19sYWJlbFwiPntsYWJlbH08L2xhYmVsPlxuICAgICAgPGlucHV0XG4gICAgICAgIHR5cGU9XCJmaWxlXCJcbiAgICAgICAgYWNjZXB0PXthY2NlcHR9XG4gICAgICAgIGNsYXNzTmFtZT1cIklucHV0X19pbnB1dFwiXG4gICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gb25DaGFuZ2UoZS50YXJnZXQuZmlsZXMpfVxuICAgICAgICBkYXRhLXRlc3QtaWQ9e2RhdGFUZXN0SWR9XG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApO1xufSJdLCJuYW1lcyI6WyJSZWFjdCIsIkZpbGVJbnB1dCIsImFjY2VwdCIsImxhYmVsIiwib25DaGFuZ2UiLCJkYXRhVGVzdElkIiwiZGl2IiwiY2xhc3NOYW1lIiwiaW5wdXQiLCJ0eXBlIiwiZSIsInRhcmdldCIsImZpbGVzIiwiZGF0YS10ZXN0LWlkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/FileInput.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/Select.jsx":
/*!**************************************!*\
  !*** ./src/components/ui/Select.jsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Select; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _Select_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Select.css */ \"(app-pages-browser)/./src/components/ui/Select.css\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ \n\nfunction Select(param) {\n    let { children, label, className, ...other } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"Input__wrapper\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                style: {\n                    marginTop: \"-1em\"\n                },\n                className: \"Input__label\",\n                children: label\n            }, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/ui/Select.jsx\",\n                lineNumber: 20,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                ...other,\n                className: className || \"select\",\n                children: children\n            }, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/ui/Select.jsx\",\n                lineNumber: 21,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/ui/Select.jsx\",\n        lineNumber: 19,\n        columnNumber: 5\n    }, this);\n}\n_c = Select;\nvar _c;\n$RefreshReg$(_c, \"Select\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL1NlbGVjdC5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7OztDQU1DO0FBRW9CO0FBR04sU0FBU0EsT0FBTyxLQUs5QjtRQUw4QixFQUM3QkMsUUFBUSxFQUNSQyxLQUFLLEVBQ0xDLFNBQVMsRUFDVCxHQUFHQyxPQUNKLEdBTDhCO0lBTTdCLHFCQUNFLDhEQUFDQztRQUFJRixXQUFVOzswQkFDYiw4REFBQ0Q7Z0JBQU1JLE9BQU87b0JBQUVDLFdBQVc7Z0JBQU87Z0JBQUdKLFdBQVU7MEJBQWdCRDs7Ozs7OzBCQUMvRCw4REFBQ007Z0JBQVEsR0FBR0osS0FBSztnQkFBRUQsV0FBV0EsYUFBYTswQkFBV0Y7Ozs7Ozs7Ozs7OztBQUc1RDtLQVp3QkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvdWkvU2VsZWN0LmpzeD80NjdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0ICcuL1NlbGVjdC5jc3MnXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2VsZWN0KHtcbiAgY2hpbGRyZW4sXG4gIGxhYmVsLFxuICBjbGFzc05hbWUsXG4gIC4uLm90aGVyXG59KSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJJbnB1dF9fd3JhcHBlclwiPlxuICAgICAgPGxhYmVsIHN0eWxlPXt7IG1hcmdpblRvcDogJy0xZW0nIH19IGNsYXNzTmFtZT1cIklucHV0X19sYWJlbFwiPntsYWJlbH08L2xhYmVsPlxuICAgICAgPHNlbGVjdCB7Li4ub3RoZXJ9IGNsYXNzTmFtZT17Y2xhc3NOYW1lIHx8ICdzZWxlY3QnfT57Y2hpbGRyZW59PC9zZWxlY3Q+XG4gICAgPC9kaXY+XG4gIClcbn0iXSwibmFtZXMiOlsiU2VsZWN0IiwiY2hpbGRyZW4iLCJsYWJlbCIsImNsYXNzTmFtZSIsIm90aGVyIiwiZGl2Iiwic3R5bGUiLCJtYXJnaW5Ub3AiLCJzZWxlY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/Select.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/TextInput.jsx":
/*!*****************************************!*\
  !*** ./src/components/ui/TextInput.jsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ TextInput; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _Input_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Input.css */ \"(app-pages-browser)/./src/components/ui/Input.css\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ \n\nfunction TextInput(param) {\n    let { label, value, onChange, placeholder = \"\", \"data-test-id\": dataTestId, type = \"text\" } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"Input__wrapper\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                className: \"Input__label\",\n                children: label\n            }, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/ui/TextInput.jsx\",\n                lineNumber: 24,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                type: type,\n                className: \"Input__input\",\n                placeholder: placeholder,\n                value: value,\n                onChange: (e)=>{\n                    onChange(e.target.value);\n                },\n                \"data-test-id\": dataTestId\n            }, void 0, false, {\n                fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/ui/TextInput.jsx\",\n                lineNumber: 25,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/saheliandev/Desktop/Personnal/Site-minist-re/src/components/ui/TextInput.jsx\",\n        lineNumber: 23,\n        columnNumber: 5\n    }, this);\n}\n_c = TextInput;\nvar _c;\n$RefreshReg$(_c, \"TextInput\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL1RleHRJbnB1dC5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7OztDQU1DO0FBRW1CO0FBS0wsU0FBU0EsVUFBVSxLQU9qQztRQVBpQyxFQUNoQ0MsS0FBSyxFQUNMQyxLQUFLLEVBQ0xDLFFBQVEsRUFDUkMsY0FBYyxFQUFFLEVBQ2hCLGdCQUFnQkMsVUFBVSxFQUMxQkMsT0FBTyxNQUFNLEVBQ2QsR0FQaUM7SUFRaEMscUJBQ0UsOERBQUNDO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDUDtnQkFBTU8sV0FBVTswQkFBZ0JQOzs7Ozs7MEJBQ2pDLDhEQUFDUTtnQkFDQ0gsTUFBTUE7Z0JBQ05FLFdBQVU7Z0JBQ1ZKLGFBQWFBO2dCQUNiRixPQUFPQTtnQkFDUEMsVUFBVSxDQUFDTztvQkFDVFAsU0FBU08sRUFBRUMsTUFBTSxDQUFDVCxLQUFLO2dCQUN6QjtnQkFDQVUsZ0JBQWNQOzs7Ozs7Ozs7Ozs7QUFJdEI7S0F2QndCTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy91aS9UZXh0SW5wdXQuanN4P2RjZTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgJy4vSW5wdXQuY3NzJ1xuXG5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUZXh0SW5wdXQoe1xuICBsYWJlbCxcbiAgdmFsdWUsXG4gIG9uQ2hhbmdlLFxuICBwbGFjZWhvbGRlciA9ICcnLFxuICAnZGF0YS10ZXN0LWlkJzogZGF0YVRlc3RJZCxcbiAgdHlwZSA9ICd0ZXh0Jyxcbn0pIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIklucHV0X193cmFwcGVyXCI+XG4gICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiSW5wdXRfX2xhYmVsXCI+e2xhYmVsfTwvbGFiZWw+XG4gICAgICA8aW5wdXRcbiAgICAgICAgdHlwZT17dHlwZX1cbiAgICAgICAgY2xhc3NOYW1lPVwiSW5wdXRfX2lucHV0XCJcbiAgICAgICAgcGxhY2Vob2xkZXI9e3BsYWNlaG9sZGVyfVxuICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4ge1xuICAgICAgICAgIG9uQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKVxuICAgICAgICB9fVxuICAgICAgICBkYXRhLXRlc3QtaWQ9e2RhdGFUZXN0SWR9XG4gICAgICAvPlxuICAgIDwvZGl2PlxuICApXG59Il0sIm5hbWVzIjpbIlRleHRJbnB1dCIsImxhYmVsIiwidmFsdWUiLCJvbkNoYW5nZSIsInBsYWNlaG9sZGVyIiwiZGF0YVRlc3RJZCIsInR5cGUiLCJkaXYiLCJjbGFzc05hbWUiLCJpbnB1dCIsImUiLCJ0YXJnZXQiLCJkYXRhLXRlc3QtaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/TextInput.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0hBQWdIOztBQUVoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QyxnREFBZ0QsTUFBTSxhQUFhOztBQUVqSDtBQUNBLCtDQUErQyxrQ0FBa0MsT0FBTzs7QUFFeEYsdUdBQXVHLGNBQWMsVUFBVSxnR0FBZ0csa0JBQWtCLFVBQVUsVUFBVTs7QUFFclE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiwyREFBMkQsVUFBVTtBQUNyRSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz9jNGE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/MTNlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fsaheliandev%2FDesktop%2FPersonnal%2FSite-minist-re%2Fsrc%2Fapp%2Fcreation%2Fpage.jsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);