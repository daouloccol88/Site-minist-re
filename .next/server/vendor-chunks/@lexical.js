"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical";
exports.ids = ["vendor-chunks/@lexical"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.dev.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar html = __webpack_require__(/*! @lexical/html */ \"(ssr)/./node_modules/@lexical/html/LexicalHtml.js\");\nvar selection = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @returns a string of HTML content\n */\n\n\nfunction $getHtmlContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n\n  return html.$generateHtmlFromNodes(editor, selection);\n}\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @returns\n */\n\nfunction $getLexicalContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\n\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\n\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch {// Fail silently.\n    }\n  }\n\n  const htmlString = dataTransfer.getData('text/html');\n\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = html.$generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch {// Fail silently.\n    }\n  } // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n\n\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n\n  if (text != null) {\n    if (lexical.$isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      const partsLength = parts.length;\n\n      for (let i = 0; i < partsLength; i++) {\n        const part = parts[i];\n\n        if (part === '\\n' || part === '\\r\\n') {\n          selection.insertParagraph();\n        } else if (part === '\\t') {\n          selection.insertNodes([lexical.$createTabNode()]);\n        } else {\n          selection.insertText(part);\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\n\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\n    return;\n  }\n\n  $basicInsertStrategy(nodes, selection);\n  return;\n}\n\nfunction $basicInsertStrategy(nodes, selection) {\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n  const topLevelBlocks = [];\n  let currentBlock = null;\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = lexical.$isLineBreakNode(node);\n\n    if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        topLevelBlocks.push(currentBlock); // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      topLevelBlocks.push(node);\n      currentBlock = null;\n    }\n  }\n\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(topLevelBlocks);\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n\n    anchorCell.append(...topLevelBlocks);\n  }\n}\n\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\n\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const newGridRowNode = newGridRows[newRowIdx];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n\n    newRowIdx++;\n  }\n\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n\n  const serializedChildren = serializedNode.children;\n\n  if (lexical.$isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n\n  return serializedNode;\n}\n\nfunction $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target); // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n\n  if (lexical.$isTextNode(target)) {\n    const text = target.__text; // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n\n  return shouldInclude;\n} // TODO why $ function with Editor instance?\n\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\n\n\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\n\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = lexical.$parseSerializedNode(serializedNode);\n\n    if (lexical.$isTextNode(node)) {\n      selection.$addNodeStyle(node);\n    }\n\n    nodes.push(node);\n  }\n\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null; // TODO custom selection\n// TODO potentially have a node customizable version for plain text\n\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\n\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical.COPY_COMMAND, secondEvent => {\n      if (utils.objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      } // Block the entire copy flow while we wait for the next ClipboardEvent\n\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL); // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n} // TODO shouldn't pass editor (pass namespace directly)\n\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = getDOMSelection(editor._window);\n\n  if (!domSelection) {\n    return false;\n  }\n\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n\n  if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = lexical.$getSelection();\n\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\n\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\nexports.$getHtmlContent = $getHtmlContent;\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.$insertGeneratedNodes = $insertGeneratedNodes;\nexports.copyToClipboard = copyToClipboard;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY2xpcGJvYXJkL0xleGljYWxDbGlwYm9hcmQuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyx3RUFBZTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyx1RkFBb0I7QUFDNUMsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNwQyxjQUFjLG1CQUFPLENBQUMsd0RBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE9BQU87QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFVBQVU7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsVUFBVTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixvQkFBb0Isb0NBQW9DO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFROzs7QUFHUjtBQUNBLEtBQUssc0NBQXNDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDLHlDQUF5QztBQUN6Qyx1QkFBdUI7QUFDdkIsMEJBQTBCO0FBQzFCLHVDQUF1QztBQUN2QyxzQ0FBc0M7QUFDdEMsNkJBQTZCO0FBQzdCLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2NsaXBib2FyZC9MZXhpY2FsQ2xpcGJvYXJkLmRldi5qcz81ODMxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHRtbCA9IHJlcXVpcmUoJ0BsZXhpY2FsL2h0bWwnKTtcbnZhciBzZWxlY3Rpb24gPSByZXF1aXJlKCdAbGV4aWNhbC9zZWxlY3Rpb24nKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IGdldERPTVNlbGVjdGlvbiA9IHRhcmdldFdpbmRvdyA9PiBDQU5fVVNFX0RPTSA/ICh0YXJnZXRXaW5kb3cgfHwgd2luZG93KS5nZXRTZWxlY3Rpb24oKSA6IG51bGw7XG4vKipcbiAqIFJldHVybnMgdGhlICpjdXJyZW50bHkgc2VsZWN0ZWQqIExleGljYWwgY29udGVudCBhcyBhbiBIVE1MIHN0cmluZywgcmVseWluZyBvbiB0aGVcbiAqIGxvZ2ljIGRlZmluZWQgaW4gdGhlIGV4cG9ydERPTSBtZXRob2RzIG9uIHRoZSBMZXhpY2FsTm9kZSBjbGFzc2VzLiBOb3RlIHRoYXRcbiAqIHRoaXMgd2lsbCBub3QgcmV0dXJuIHRoZSBIVE1MIGNvbnRlbnQgb2YgdGhlIGVudGlyZSBlZGl0b3IgKHVubGVzcyBhbGwgdGhlIGNvbnRlbnQgaXMgaW5jbHVkZWRcbiAqIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbikuXG4gKlxuICogQHBhcmFtIGVkaXRvciAtIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gZ2V0IEhUTUwgY29udGVudCBmcm9tXG4gKiBAcmV0dXJucyBhIHN0cmluZyBvZiBIVE1MIGNvbnRlbnRcbiAqL1xuXG5cbmZ1bmN0aW9uICRnZXRIdG1sQ29udGVudChlZGl0b3IpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKHNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHZhbGlkIExleGljYWxTZWxlY3Rpb25gKTtcbiAgICB9XG4gIH0gLy8gSWYgd2UgaGF2ZW4ndCBzZWxlY3RlZCBhbnl0aGluZ1xuXG5cbiAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCBzZWxlY3Rpb24uZ2V0Tm9kZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gaHRtbC4kZ2VuZXJhdGVIdG1sRnJvbU5vZGVzKGVkaXRvciwgc2VsZWN0aW9uKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgKmN1cnJlbnRseSBzZWxlY3RlZCogTGV4aWNhbCBjb250ZW50IGFzIGEgSlNPTiBzdHJpbmcsIHJlbHlpbmcgb24gdGhlXG4gKiBsb2dpYyBkZWZpbmVkIGluIHRoZSBleHBvcnRKU09OIG1ldGhvZHMgb24gdGhlIExleGljYWxOb2RlIGNsYXNzZXMuIE5vdGUgdGhhdFxuICogdGhpcyB3aWxsIG5vdCByZXR1cm4gdGhlIEpTT04gY29udGVudCBvZiB0aGUgZW50aXJlIGVkaXRvciAodW5sZXNzIGFsbCB0aGUgY29udGVudCBpcyBpbmNsdWRlZFxuICogaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uKS5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yICAtIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gZ2V0IHRoZSBKU09OIGNvbnRlbnQgZnJvbVxuICogQHJldHVybnNcbiAqL1xuXG5mdW5jdGlvbiAkZ2V0TGV4aWNhbENvbnRlbnQoZWRpdG9yKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB2YWxpZCBMZXhpY2FsU2VsZWN0aW9uYCk7XG4gICAgfVxuICB9IC8vIElmIHdlIGhhdmVuJ3Qgc2VsZWN0ZWQgYW55dGhpbmdcblxuXG4gIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgc2VsZWN0aW9uLmdldE5vZGVzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJGdlbmVyYXRlSlNPTkZyb21TZWxlY3RlZE5vZGVzKGVkaXRvciwgc2VsZWN0aW9uKSk7XG59XG4vKipcbiAqIEF0dGVtcHRzIHRvIGluc2VydCBjb250ZW50IG9mIHRoZSBtaW1lLXR5cGVzIHRleHQvcGxhaW4gb3IgdGV4dC91cmktbGlzdCBmcm9tXG4gKiB0aGUgcHJvdmlkZWQgRGF0YVRyYW5zZmVyIG9iamVjdCBpbnRvIHRoZSBlZGl0b3IgYXQgdGhlIHByb3ZpZGVkIHNlbGVjdGlvbi5cbiAqIHRleHQvdXJpLWxpc3QgaXMgb25seSB1c2VkIGlmIHRleHQvcGxhaW4gaXMgbm90IGFsc28gcHJvdmlkZWQuXG4gKlxuICogQHBhcmFtIGRhdGFUcmFuc2ZlciBhbiBvYmplY3QgY29uZm9ybWluZyB0byB0aGUgW0RhdGFUcmFuc2ZlciBpbnRlcmZhY2VdIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kbmQuaHRtbCN0aGUtZGF0YXRyYW5zZmVyLWludGVyZmFjZSlcbiAqIEBwYXJhbSBzZWxlY3Rpb24gdGhlIHNlbGVjdGlvbiB0byB1c2UgYXMgdGhlIGluc2VydGlvbiBwb2ludCBmb3IgdGhlIGNvbnRlbnQgaW4gdGhlIERhdGFUcmFuc2ZlciBvYmplY3RcbiAqL1xuXG5mdW5jdGlvbiAkaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUGxhaW5UZXh0KGRhdGFUcmFuc2Zlciwgc2VsZWN0aW9uKSB7XG4gIGNvbnN0IHRleHQgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9wbGFpbicpIHx8IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3VyaS1saXN0Jyk7XG5cbiAgaWYgKHRleHQgIT0gbnVsbCkge1xuICAgIHNlbGVjdGlvbi5pbnNlcnRSYXdUZXh0KHRleHQpO1xuICB9XG59XG4vKipcbiAqIEF0dGVtcHRzIHRvIGluc2VydCBjb250ZW50IG9mIHRoZSBtaW1lLXR5cGVzIGFwcGxpY2F0aW9uL3gtbGV4aWNhbC1lZGl0b3IsIHRleHQvaHRtbCxcbiAqIHRleHQvcGxhaW4sIG9yIHRleHQvdXJpLWxpc3QgKGluIGRlc2NlbmRpbmcgb3JkZXIgb2YgcHJpb3JpdHkpIGZyb20gdGhlIHByb3ZpZGVkIERhdGFUcmFuc2ZlclxuICogb2JqZWN0IGludG8gdGhlIGVkaXRvciBhdCB0aGUgcHJvdmlkZWQgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBkYXRhVHJhbnNmZXIgYW4gb2JqZWN0IGNvbmZvcm1pbmcgdG8gdGhlIFtEYXRhVHJhbnNmZXIgaW50ZXJmYWNlXSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG5kLmh0bWwjdGhlLWRhdGF0cmFuc2Zlci1pbnRlcmZhY2UpXG4gKiBAcGFyYW0gc2VsZWN0aW9uIHRoZSBzZWxlY3Rpb24gdG8gdXNlIGFzIHRoZSBpbnNlcnRpb24gcG9pbnQgZm9yIHRoZSBjb250ZW50IGluIHRoZSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gKiBAcGFyYW0gZWRpdG9yIHRoZSBMZXhpY2FsRWRpdG9yIHRoZSBjb250ZW50IGlzIGJlaW5nIGluc2VydGVkIGludG8uXG4gKi9cblxuZnVuY3Rpb24gJGluc2VydERhdGFUcmFuc2ZlckZvclJpY2hUZXh0KGRhdGFUcmFuc2Zlciwgc2VsZWN0aW9uLCBlZGl0b3IpIHtcbiAgY29uc3QgbGV4aWNhbFN0cmluZyA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCdhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yJyk7XG5cbiAgaWYgKGxleGljYWxTdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UobGV4aWNhbFN0cmluZyk7XG5cbiAgICAgIGlmIChwYXlsb2FkLm5hbWVzcGFjZSA9PT0gZWRpdG9yLl9jb25maWcubmFtZXNwYWNlICYmIEFycmF5LmlzQXJyYXkocGF5bG9hZC5ub2RlcykpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSAkZ2VuZXJhdGVOb2Rlc0Zyb21TZXJpYWxpemVkTm9kZXMocGF5bG9hZC5ub2Rlcyk7XG4gICAgICAgIHJldHVybiAkaW5zZXJ0R2VuZXJhdGVkTm9kZXMoZWRpdG9yLCBub2Rlcywgc2VsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHsvLyBGYWlsIHNpbGVudGx5LlxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGh0bWxTdHJpbmcgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG5cbiAgaWYgKGh0bWxTdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgY29uc3QgZG9tID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sU3RyaW5nLCAndGV4dC9odG1sJyk7XG4gICAgICBjb25zdCBub2RlcyA9IGh0bWwuJGdlbmVyYXRlTm9kZXNGcm9tRE9NKGVkaXRvciwgZG9tKTtcbiAgICAgIHJldHVybiAkaW5zZXJ0R2VuZXJhdGVkTm9kZXMoZWRpdG9yLCBub2Rlcywgc2VsZWN0aW9uKTtcbiAgICB9IGNhdGNoIHsvLyBGYWlsIHNpbGVudGx5LlxuICAgIH1cbiAgfSAvLyBNdWx0aS1saW5lIHBsYWluIHRleHQgaW4gcmljaCB0ZXh0IG1vZGUgcGFzdGVkIGFzIHNlcGFyYXRlIHBhcmFncmFwaHNcbiAgLy8gaW5zdGVhZCBvZiBzaW5nbGUgcGFyYWdyYXBoIHdpdGggbGluZWJyZWFrcy5cbiAgLy8gV2Via2l0LXNwZWNpZmljOiBTdXBwb3J0cyByZWFkICd0ZXh0L3VyaS1saXN0JyBpbiBjbGlwYm9hcmQuXG5cblxuICBjb25zdCB0ZXh0ID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvcGxhaW4nKSB8fCBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC91cmktbGlzdCcpO1xuXG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHRleHQuc3BsaXQoLyhcXHI/XFxufFxcdCkvKTtcbiAgICAgIGNvbnN0IHBhcnRzTGVuZ3RoID0gcGFydHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuXG4gICAgICAgIGlmIChwYXJ0ID09PSAnXFxuJyB8fCBwYXJ0ID09PSAnXFxyXFxuJykge1xuICAgICAgICAgIHNlbGVjdGlvbi5pbnNlcnRQYXJhZ3JhcGgoKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnXFx0Jykge1xuICAgICAgICAgIHNlbGVjdGlvbi5pbnNlcnROb2RlcyhbbGV4aWNhbC4kY3JlYXRlVGFiTm9kZSgpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmluc2VydFRleHQocGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLmluc2VydFJhd1RleHQodGV4dCk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEluc2VydHMgTGV4aWNhbCBub2RlcyBpbnRvIHRoZSBlZGl0b3IgdXNpbmcgZGlmZmVyZW50IHN0cmF0ZWdpZXMgZGVwZW5kaW5nIG9uXG4gKiBzb21lIHNpbXBsZSBzZWxlY3Rpb24tYmFzZWQgaGV1cmlzdGljcy4gSWYgeW91J3JlIGxvb2tpbmcgZm9yIGEgZ2VuZXJpYyB3YXkgdG9cbiAqIHRvIGluc2VydCBub2RlcyBpbnRvIHRoZSBlZGl0b3IgYXQgYSBzcGVjaWZpYyBzZWxlY3Rpb24gcG9pbnQsIHlvdSBwcm9iYWJseSB3YW50XG4gKiB7QGxpbmsgbGV4aWNhbC4kaW5zZXJ0Tm9kZXN9XG4gKlxuICogQHBhcmFtIGVkaXRvciBMZXhpY2FsRWRpdG9yIGluc3RhbmNlIHRvIGluc2VydCB0aGUgbm9kZXMgaW50by5cbiAqIEBwYXJhbSBub2RlcyBUaGUgbm9kZXMgdG8gaW5zZXJ0LlxuICogQHBhcmFtIHNlbGVjdGlvbiBUaGUgc2VsZWN0aW9uIHRvIGluc2VydCB0aGUgbm9kZXMgaW50by5cbiAqL1xuXG5mdW5jdGlvbiAkaW5zZXJ0R2VuZXJhdGVkTm9kZXMoZWRpdG9yLCBub2Rlcywgc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGlzU2VsZWN0aW9uSW5zaWRlT2ZHcmlkID0gbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+IGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkQ2VsbE5vZGUobikpICE9PSBudWxsICYmIHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKSwgbiA9PiBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZENlbGxOb2RlKG4pKSAhPT0gbnVsbDtcblxuICBpZiAoaXNTZWxlY3Rpb25JbnNpZGVPZkdyaWQgJiYgbm9kZXMubGVuZ3RoID09PSAxICYmIGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkTm9kZShub2Rlc1swXSkpIHtcbiAgICAkbWVyZ2VHcmlkTm9kZXNTdHJhdGVneShub2Rlcywgc2VsZWN0aW9uLCBmYWxzZSwgZWRpdG9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAkYmFzaWNJbnNlcnRTdHJhdGVneShub2Rlcywgc2VsZWN0aW9uKTtcbiAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiAkYmFzaWNJbnNlcnRTdHJhdGVneShub2Rlcywgc2VsZWN0aW9uKSB7XG4gIC8vIFdyYXAgdGV4dCBhbmQgaW5saW5lIG5vZGVzIGluIHBhcmFncmFwaCBub2RlcyBzbyB3ZSBoYXZlIGFsbCBibG9ja3MgYXQgdGhlIHRvcC1sZXZlbFxuICBjb25zdCB0b3BMZXZlbEJsb2NrcyA9IFtdO1xuICBsZXQgY3VycmVudEJsb2NrID0gbnVsbDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGNvbnN0IGlzTGluZUJyZWFrTm9kZSA9IGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShub2RlKTtcblxuICAgIGlmIChpc0xpbmVCcmVha05vZGUgfHwgbGV4aWNhbC4kaXNEZWNvcmF0b3JOb2RlKG5vZGUpICYmIG5vZGUuaXNJbmxpbmUoKSB8fCBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuaXNJbmxpbmUoKSB8fCBsZXhpY2FsLiRpc1RleHROb2RlKG5vZGUpIHx8IG5vZGUuaXNQYXJlbnRSZXF1aXJlZCgpKSB7XG4gICAgICBpZiAoY3VycmVudEJsb2NrID09PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRCbG9jayA9IG5vZGUuY3JlYXRlUGFyZW50RWxlbWVudE5vZGUoKTtcbiAgICAgICAgdG9wTGV2ZWxCbG9ja3MucHVzaChjdXJyZW50QmxvY2spOyAvLyBJbiB0aGUgY2FzZSBvZiBMaW5lQnJlYWtOb2RlLCB3ZSBqdXN0IG5lZWQgdG9cbiAgICAgICAgLy8gYWRkIGFuIGVtcHR5IFBhcmFncmFwaE5vZGUgdG8gdGhlIHRvcExldmVsQmxvY2tzLlxuXG4gICAgICAgIGlmIChpc0xpbmVCcmVha05vZGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudEJsb2NrICE9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRCbG9jay5hcHBlbmQobm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcExldmVsQmxvY2tzLnB1c2gobm9kZSk7XG4gICAgICBjdXJyZW50QmxvY2sgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBzZWxlY3Rpb24uaW5zZXJ0Tm9kZXModG9wTGV2ZWxCbG9ja3MpO1xuICB9IGVsc2UgaWYgKGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAvLyBJZiB0aGVyZSdzIGFuIGFjdGl2ZSBncmlkIHNlbGVjdGlvbiBhbmQgYSBub24gZ3JpZCBpcyBwYXN0ZWQsIGFkZCB0byB0aGUgYW5jaG9yLlxuICAgIGNvbnN0IGFuY2hvckNlbGwgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcblxuICAgIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZShhbmNob3JDZWxsKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgR3JpZCBDZWxsIGluIEdyaWQgU2VsZWN0aW9uYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYW5jaG9yQ2VsbC5hcHBlbmQoLi4udG9wTGV2ZWxCbG9ja3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uICRtZXJnZUdyaWROb2Rlc1N0cmF0ZWd5KG5vZGVzLCBzZWxlY3Rpb24sIGlzRnJvbUxleGljYWwsIGVkaXRvcikge1xuICBpZiAobm9kZXMubGVuZ3RoICE9PSAxIHx8ICFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZE5vZGUobm9kZXNbMF0pKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYCRtZXJnZUdyaWROb2Rlc1N0cmF0ZWd5OiBFeHBlY3RlZCBHcmlkIGluc2VydGlvbi5gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBuZXdHcmlkID0gbm9kZXNbMF07XG4gIGNvbnN0IG5ld0dyaWRSb3dzID0gbmV3R3JpZC5nZXRDaGlsZHJlbigpO1xuICBjb25zdCBuZXdDb2x1bW5Db3VudCA9IG5ld0dyaWQuZ2V0Rmlyc3RDaGlsZE9yVGhyb3coKS5nZXRDaGlsZHJlblNpemUoKTtcbiAgY29uc3QgbmV3Um93Q291bnQgPSBuZXdHcmlkLmdldENoaWxkcmVuU2l6ZSgpO1xuICBjb25zdCBncmlkQ2VsbE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+IGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkQ2VsbE5vZGUobikpO1xuICBjb25zdCBncmlkUm93Tm9kZSA9IGdyaWRDZWxsTm9kZSAmJiB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KGdyaWRDZWxsTm9kZSwgbiA9PiBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFJvd05vZGUobikpO1xuICBjb25zdCBncmlkTm9kZSA9IGdyaWRSb3dOb2RlICYmIHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoZ3JpZFJvd05vZGUsIG4gPT4gbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWROb2RlKG4pKTtcblxuICBpZiAoIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkQ2VsbE5vZGUoZ3JpZENlbGxOb2RlKSB8fCAhbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlKGdyaWRSb3dOb2RlKSB8fCAhbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWROb2RlKGdyaWROb2RlKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGAkbWVyZ2VHcmlkTm9kZXNTdHJhdGVneTogRXhwZWN0ZWQgc2VsZWN0aW9uIHRvIGJlIGluc2lkZSBvZiBhIEdyaWQuYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RhcnRZID0gZ3JpZFJvd05vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgY29uc3Qgc3RvcFkgPSBNYXRoLm1pbihncmlkTm9kZS5nZXRDaGlsZHJlblNpemUoKSAtIDEsIHN0YXJ0WSArIG5ld1Jvd0NvdW50IC0gMSk7XG4gIGNvbnN0IHN0YXJ0WCA9IGdyaWRDZWxsTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICBjb25zdCBzdG9wWCA9IE1hdGgubWluKGdyaWRSb3dOb2RlLmdldENoaWxkcmVuU2l6ZSgpIC0gMSwgc3RhcnRYICsgbmV3Q29sdW1uQ291bnQgLSAxKTtcbiAgY29uc3QgZnJvbVggPSBNYXRoLm1pbihzdGFydFgsIHN0b3BYKTtcbiAgY29uc3QgZnJvbVkgPSBNYXRoLm1pbihzdGFydFksIHN0b3BZKTtcbiAgY29uc3QgdG9YID0gTWF0aC5tYXgoc3RhcnRYLCBzdG9wWCk7XG4gIGNvbnN0IHRvWSA9IE1hdGgubWF4KHN0YXJ0WSwgc3RvcFkpO1xuICBjb25zdCBncmlkUm93Tm9kZXMgPSBncmlkTm9kZS5nZXRDaGlsZHJlbigpO1xuICBsZXQgbmV3Um93SWR4ID0gMDtcbiAgbGV0IG5ld0FuY2hvckNlbGxLZXk7XG4gIGxldCBuZXdGb2N1c0NlbGxLZXk7XG5cbiAgZm9yIChsZXQgciA9IGZyb21ZOyByIDw9IHRvWTsgcisrKSB7XG4gICAgY29uc3QgY3VycmVudEdyaWRSb3dOb2RlID0gZ3JpZFJvd05vZGVzW3JdO1xuXG4gICAgaWYgKCFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFJvd05vZGUoY3VycmVudEdyaWRSb3dOb2RlKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgZ2V0Tm9kZXM6IGV4cGVjdGVkIHRvIGZpbmQgR3JpZFJvd05vZGVgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBuZXdHcmlkUm93Tm9kZSA9IG5ld0dyaWRSb3dzW25ld1Jvd0lkeF07XG5cbiAgICBpZiAoIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkUm93Tm9kZShuZXdHcmlkUm93Tm9kZSkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYGdldE5vZGVzOiBleHBlY3RlZCB0byBmaW5kIEdyaWRSb3dOb2RlYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZ3JpZENlbGxOb2RlcyA9IGN1cnJlbnRHcmlkUm93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgIGNvbnN0IG5ld0dyaWRDZWxsTm9kZXMgPSBuZXdHcmlkUm93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgIGxldCBuZXdDb2x1bW5JZHggPSAwO1xuXG4gICAgZm9yIChsZXQgYyA9IGZyb21YOyBjIDw9IHRvWDsgYysrKSB7XG4gICAgICBjb25zdCBjdXJyZW50R3JpZENlbGxOb2RlID0gZ3JpZENlbGxOb2Rlc1tjXTtcblxuICAgICAgaWYgKCFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZENlbGxOb2RlKGN1cnJlbnRHcmlkQ2VsbE5vZGUpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgZ2V0Tm9kZXM6IGV4cGVjdGVkIHRvIGZpbmQgR3JpZENlbGxOb2RlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3R3JpZENlbGxOb2RlID0gbmV3R3JpZENlbGxOb2Rlc1tuZXdDb2x1bW5JZHhdO1xuXG4gICAgICBpZiAoIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkQ2VsbE5vZGUobmV3R3JpZENlbGxOb2RlKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYGdldE5vZGVzOiBleHBlY3RlZCB0byBmaW5kIEdyaWRDZWxsTm9kZWApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyID09PSBmcm9tWSAmJiBjID09PSBmcm9tWCkge1xuICAgICAgICBuZXdBbmNob3JDZWxsS2V5ID0gY3VycmVudEdyaWRDZWxsTm9kZS5nZXRLZXkoKTtcbiAgICAgIH0gZWxzZSBpZiAociA9PT0gdG9ZICYmIGMgPT09IHRvWCkge1xuICAgICAgICBuZXdGb2N1c0NlbGxLZXkgPSBjdXJyZW50R3JpZENlbGxOb2RlLmdldEtleSgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvcmlnaW5hbENoaWxkcmVuID0gY3VycmVudEdyaWRDZWxsTm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgbmV3R3JpZENlbGxOb2RlLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgICAgIGNvbnN0IHBhcmFncmFwaE5vZGUgPSBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAgICAgcGFyYWdyYXBoTm9kZS5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgIGN1cnJlbnRHcmlkQ2VsbE5vZGUuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50R3JpZENlbGxOb2RlLmFwcGVuZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb3JpZ2luYWxDaGlsZHJlbi5mb3JFYWNoKG4gPT4gbi5yZW1vdmUoKSk7XG4gICAgICBuZXdDb2x1bW5JZHgrKztcbiAgICB9XG5cbiAgICBuZXdSb3dJZHgrKztcbiAgfVxuXG4gIGlmIChuZXdBbmNob3JDZWxsS2V5ICYmIG5ld0ZvY3VzQ2VsbEtleSkge1xuICAgIGNvbnN0IG5ld0dyaWRTZWxlY3Rpb24gPSBsZXhpY2FsLkRFUFJFQ0FURURfJGNyZWF0ZUdyaWRTZWxlY3Rpb24oKTtcbiAgICBuZXdHcmlkU2VsZWN0aW9uLnNldChncmlkTm9kZS5nZXRLZXkoKSwgbmV3QW5jaG9yQ2VsbEtleSwgbmV3Rm9jdXNDZWxsS2V5KTtcbiAgICBsZXhpY2FsLiRzZXRTZWxlY3Rpb24obmV3R3JpZFNlbGVjdGlvbik7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLlNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHBvcnROb2RlVG9KU09OKG5vZGUpIHtcbiAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBub2RlLmV4cG9ydEpTT04oKTtcbiAgY29uc3Qgbm9kZUNsYXNzID0gbm9kZS5jb25zdHJ1Y3RvcjsgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIFJlcGxhY2UgQ2xhc3MgdXRpbGl0eSB0eXBlIHdpdGggSW5zdGFuY2VUeXBlXG5cbiAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgIT09IG5vZGVDbGFzcy5nZXRUeXBlKCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IC5leHBvcnRKU09OKCkuYCk7XG4gICAgfVxuICB9IC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETyBSZXBsYWNlIENsYXNzIHV0aWxpdHkgdHlwZSB3aXRoIEluc3RhbmNlVHlwZVxuXG5cbiAgY29uc3Qgc2VyaWFsaXplZENoaWxkcmVuID0gc2VyaWFsaXplZE5vZGUuY2hpbGRyZW47XG5cbiAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VyaWFsaXplZENoaWxkcmVuKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gaXMgYW4gZWxlbWVudCBidXQgLmV4cG9ydEpTT04oKSBkb2VzIG5vdCBoYXZlIGEgY2hpbGRyZW4gYXJyYXkuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWROb2RlO1xufVxuXG5mdW5jdGlvbiAkYXBwZW5kTm9kZXNUb0pTT04oZWRpdG9yLCBzZWxlY3Rpb24kMSwgY3VycmVudE5vZGUsIHRhcmdldEFycmF5ID0gW10pIHtcbiAgbGV0IHNob3VsZEluY2x1ZGUgPSBzZWxlY3Rpb24kMSAhPSBudWxsID8gY3VycmVudE5vZGUuaXNTZWxlY3RlZChzZWxlY3Rpb24kMSkgOiB0cnVlO1xuICBjb25zdCBzaG91bGRFeGNsdWRlID0gbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgY3VycmVudE5vZGUuZXhjbHVkZUZyb21Db3B5KCdodG1sJyk7XG4gIGxldCB0YXJnZXQgPSBjdXJyZW50Tm9kZTtcblxuICBpZiAoc2VsZWN0aW9uJDEgIT09IG51bGwpIHtcbiAgICBsZXQgY2xvbmUgPSBzZWxlY3Rpb24uJGNsb25lV2l0aFByb3BlcnRpZXMoY3VycmVudE5vZGUpO1xuICAgIGNsb25lID0gbGV4aWNhbC4kaXNUZXh0Tm9kZShjbG9uZSkgJiYgc2VsZWN0aW9uJDEgIT0gbnVsbCA/IHNlbGVjdGlvbi4kc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudChzZWxlY3Rpb24kMSwgY2xvbmUpIDogY2xvbmU7XG4gICAgdGFyZ2V0ID0gY2xvbmU7XG4gIH1cblxuICBjb25zdCBjaGlsZHJlbiA9IGxleGljYWwuJGlzRWxlbWVudE5vZGUodGFyZ2V0KSA/IHRhcmdldC5nZXRDaGlsZHJlbigpIDogW107XG4gIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gZXhwb3J0Tm9kZVRvSlNPTih0YXJnZXQpOyAvLyBUT0RPOiBUZXh0Tm9kZSBjYWxscyBnZXRUZXh0Q29udGVudCgpIChOT1Qgbm9kZS5fX3RleHQpIHdpdGhpbiBpdCdzIGV4cG9ydEpTT04gbWV0aG9kXG4gIC8vIHdoaWNoIHVzZXMgZ2V0TGF0ZXN0KCkgdG8gZ2V0IHRoZSB0ZXh0IGZyb20gdGhlIG9yaWdpbmFsIG5vZGUgd2l0aCB0aGUgc2FtZSBrZXkuXG4gIC8vIFRoaXMgaXMgYSBkZWVwZXIgaXNzdWUgd2l0aCB0aGUgd29yZCBcImNsb25lXCIgaGVyZSwgaXQncyBzdGlsbCBhIHJlZmVyZW5jZSB0byB0aGVcbiAgLy8gc2FtZSBub2RlIGFzIGZhciBhcyB0aGUgTGV4aWNhbEVkaXRvciBpcyBjb25jZXJuZWQgc2luY2UgaXQgc2hhcmVzIGEga2V5LlxuICAvLyBXZSBuZWVkIGEgd2F5IHRvIGNyZWF0ZSBhIGNsb25lIG9mIGEgTm9kZSBpbiBtZW1vcnkgd2l0aCBpdCdzIG93biBrZXksIGJ1dFxuICAvLyB1bnRpbCB0aGVuIHRoaXMgaGFjayB3aWxsIHdvcmsgZm9yIHRoZSBzZWxlY3RlZCB0ZXh0IGV4dHJhY3QgdXNlIGNhc2UuXG5cbiAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUodGFyZ2V0KSkge1xuICAgIGNvbnN0IHRleHQgPSB0YXJnZXQuX190ZXh0OyAvLyBJZiBhbiB1bmNvbGxhcHNlZCBzZWxlY3Rpb24gZW5kcyBvciBzdGFydHMgYXQgdGhlIGVuZCBvZiBhIGxpbmUgb2Ygc3BlY2lhbGl6ZWQsXG4gICAgLy8gVGV4dE5vZGVzLCBzdWNoIGFzIGNvZGUgdG9rZW5zLCB3ZSB3aWxsIGdldCBhICdibGFuaycgVGV4dE5vZGUgaGVyZSwgaS5lLiwgb25lXG4gICAgLy8gd2l0aCB0ZXh0IG9mIGxlbmd0aCAwLiBXZSBkb24ndCB3YW50IHRoaXMsIGl0IG1ha2VzIGEgY29uZnVzaW5nIG1lc3MuIFJlc2V0IVxuXG4gICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgc2VyaWFsaXplZE5vZGUudGV4dCA9IHRleHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZEluY2x1ZGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XG4gICAgY29uc3Qgc2hvdWxkSW5jbHVkZUNoaWxkID0gJGFwcGVuZE5vZGVzVG9KU09OKGVkaXRvciwgc2VsZWN0aW9uJDEsIGNoaWxkTm9kZSwgc2VyaWFsaXplZE5vZGUuY2hpbGRyZW4pO1xuXG4gICAgaWYgKCFzaG91bGRJbmNsdWRlICYmIGxleGljYWwuJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmIHNob3VsZEluY2x1ZGVDaGlsZCAmJiBjdXJyZW50Tm9kZS5leHRyYWN0V2l0aENoaWxkKGNoaWxkTm9kZSwgc2VsZWN0aW9uJDEsICdjbG9uZScpKSB7XG4gICAgICBzaG91bGRJbmNsdWRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2hvdWxkSW5jbHVkZSAmJiAhc2hvdWxkRXhjbHVkZSkge1xuICAgIHRhcmdldEFycmF5LnB1c2goc2VyaWFsaXplZE5vZGUpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VyaWFsaXplZE5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZENoaWxkTm9kZSA9IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuW2ldO1xuICAgICAgdGFyZ2V0QXJyYXkucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2hvdWxkSW5jbHVkZTtcbn0gLy8gVE9ETyB3aHkgJCBmdW5jdGlvbiB3aXRoIEVkaXRvciBpbnN0YW5jZT9cblxuLyoqXG4gKiBHZXRzIHRoZSBMZXhpY2FsIEpTT04gb2YgdGhlIG5vZGVzIGluc2lkZSB0aGUgcHJvdmlkZWQgU2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgTGV4aWNhbEVkaXRvciB0byBnZXQgdGhlIEpTT04gY29udGVudCBmcm9tLlxuICogQHBhcmFtIHNlbGVjdGlvbiBTZWxlY3Rpb24gdG8gZ2V0IHRoZSBKU09OIGNvbnRlbnQgZnJvbS5cbiAqIEByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBlZGl0b3IgbmFtZXNwYWNlIGFuZCBhIGxpc3Qgb2Ygc2VyaWFsaXphYmxlIG5vZGVzIGFzIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuXG5cbmZ1bmN0aW9uICRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2RlcyhlZGl0b3IsIHNlbGVjdGlvbikge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBjb25zdCByb290ID0gbGV4aWNhbC4kZ2V0Um9vdCgpO1xuICBjb25zdCB0b3BMZXZlbENoaWxkcmVuID0gcm9vdC5nZXRDaGlsZHJlbigpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9wTGV2ZWxDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvcExldmVsTm9kZSA9IHRvcExldmVsQ2hpbGRyZW5baV07XG4gICAgJGFwcGVuZE5vZGVzVG9KU09OKGVkaXRvciwgc2VsZWN0aW9uLCB0b3BMZXZlbE5vZGUsIG5vZGVzKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZXNwYWNlOiBlZGl0b3IuX2NvbmZpZy5uYW1lc3BhY2UsXG4gICAgbm9kZXNcbiAgfTtcbn1cbi8qKlxuICogVGhpcyBtZXRob2QgdGFrZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb25mb3JtaW5nIHRvIHRoZSBCYXNlU2VyYWxpemVkTm9kZSBpbnRlcmZhY2UgYW5kIHJldHVybnNcbiAqIGFuIEFycmF5IGNvbnRhaW5pbmcgaW5zdGFuY2VzIG9mIHRoZSBjb3JyZXNwb25kaW5nIExleGljYWxOb2RlIGNsYXNzZXMgcmVnaXN0ZXJlZCBvbiB0aGUgZWRpdG9yLlxuICogTm9ybWFsbHksIHlvdSdkIGdldCBhbiBBcnJheSBvZiBCYXNlU2VyaWFsaXplZCBub2RlcyBmcm9tIHtAbGluayAkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXN9XG4gKlxuICogQHBhcmFtIHNlcmlhbGl6ZWROb2RlcyBhbiBBcnJheSBvZiBvYmplY3RzIGNvbmZvcm1pbmcgdG8gdGhlIEJhc2VTZXJpYWxpemVkTm9kZSBpbnRlcmZhY2UuXG4gKiBAcmV0dXJucyBhbiBBcnJheSBvZiBMZXhpY2FsIE5vZGUgb2JqZWN0cy5cbiAqL1xuXG5mdW5jdGlvbiAkZ2VuZXJhdGVOb2Rlc0Zyb21TZXJpYWxpemVkTm9kZXMoc2VyaWFsaXplZE5vZGVzKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXJpYWxpemVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IHNlcmlhbGl6ZWROb2Rlc1tpXTtcbiAgICBjb25zdCBub2RlID0gbGV4aWNhbC4kcGFyc2VTZXJpYWxpemVkTm9kZShzZXJpYWxpemVkTm9kZSk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgc2VsZWN0aW9uLiRhZGROb2RlU3R5bGUobm9kZSk7XG4gICAgfVxuXG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn1cbmNvbnN0IEVWRU5UX0xBVEVOQ1kgPSA1MDtcbmxldCBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSBudWxsOyAvLyBUT0RPIGN1c3RvbSBzZWxlY3Rpb25cbi8vIFRPRE8gcG90ZW50aWFsbHkgaGF2ZSBhIG5vZGUgY3VzdG9taXphYmxlIHZlcnNpb24gZm9yIHBsYWluIHRleHRcblxuLyoqXG4gKiBDb3BpZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHRvIHRoZSBjbGlwYm9hcmQgaW5cbiAqIHRleHQvcGxhaW4sIHRleHQvaHRtbCwgYW5kIGFwcGxpY2F0aW9uL3gtbGV4aWNhbC1lZGl0b3IgKExleGljYWwgSlNPTilcbiAqIGZvcm1hdHMuXG4gKlxuICogQHBhcmFtIGVkaXRvciB0aGUgTGV4aWNhbEVkaXRvciBpbnN0YW5jZSB0byBjb3B5IGNvbnRlbnQgZnJvbVxuICogQHBhcmFtIGV2ZW50IHRoZSBuYXRpdmUgYnJvd3NlciBDbGlwYm9hcmRFdmVudCB0byBhZGQgdGhlIGNvbnRlbnQgdG8uXG4gKiBAcmV0dXJuc1xuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGNvcHlUb0NsaXBib2FyZChlZGl0b3IsIGV2ZW50KSB7XG4gIGlmIChjbGlwYm9hcmRFdmVudFRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAvLyBQcmV2ZW50IHdlaXJkIHJhY2UgY29uZGl0aW9ucyB0aGF0IGNhbiBoYXBwZW4gd2hlbiB0aGlzIGZ1bmN0aW9uIGlzIHJ1biBtdWx0aXBsZSB0aW1lc1xuICAgIC8vIHN5bmNocm9ub3VzbHkuIEluIHRoZSBmdXR1cmUsIHdlIGNhbiBkbyBiZXR0ZXIsIHdlIGNhbiBjYW5jZWwvb3ZlcnJpZGUgdGhlIHByZXZpb3VzbHkgcnVubmluZyBqb2IuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGV2ZW50ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICByZXNvbHZlKCRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIGV2ZW50KSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gIGNvbnN0IHdpbmRvd0RvY3VtZW50ID0gZWRpdG9yLl93aW5kb3cgPT0gbnVsbCA/IHdpbmRvdy5kb2N1bWVudCA6IGVkaXRvci5fd2luZG93LmRvY3VtZW50O1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuXG4gIGlmIChyb290RWxlbWVudCA9PT0gbnVsbCB8fCBkb21TZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBlbGVtZW50ID0gd2luZG93RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBlbGVtZW50LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGZpeGVkOyB0b3A6IC0xMDAwcHg7JztcbiAgZWxlbWVudC5hcHBlbmQod2luZG93RG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJyMnKSk7XG4gIHJvb3RFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgY29uc3QgcmFuZ2UgPSBuZXcgUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoZWxlbWVudCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbGVtZW50LCAxKTtcbiAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICBkb21TZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkNPUFlfQ09NTUFORCwgc2Vjb25kRXZlbnQgPT4ge1xuICAgICAgaWYgKHV0aWxzLm9iamVjdEtsYXNzRXF1YWxzKHNlY29uZEV2ZW50LCBDbGlwYm9hcmRFdmVudCkpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcblxuICAgICAgICBpZiAoY2xpcGJvYXJkRXZlbnRUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChjbGlwYm9hcmRFdmVudFRpbWVvdXQpO1xuICAgICAgICAgIGNsaXBib2FyZEV2ZW50VGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKCRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIHNlY29uZEV2ZW50KSk7XG4gICAgICB9IC8vIEJsb2NrIHRoZSBlbnRpcmUgY29weSBmbG93IHdoaWxlIHdlIHdhaXQgZm9yIHRoZSBuZXh0IENsaXBib2FyZEV2ZW50XG5cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKTsgLy8gSWYgdGhlIGFib3ZlIGhhY2sgZXhlY0NvbW1hbmQgaGFjayB3b3JrcywgdGhpcyB0aW1lb3V0IGNvZGUgc2hvdWxkIG5ldmVyIGZpcmUuIE90aGVyd2lzZSxcbiAgICAvLyB0aGUgbGlzdGVuZXIgd2lsbCBiZSBxdWlja2x5IGZyZWVkIHNvIHRoYXQgdGhlIHVzZXIgY2FuIHJldXNlIGl0IGFnYWluXG5cbiAgICBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgIH0sIEVWRU5UX0xBVEVOQ1kpO1xuICAgIHdpbmRvd0RvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG4gICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgfSk7XG59IC8vIFRPRE8gc2hvdWxkbid0IHBhc3MgZWRpdG9yIChwYXNzIG5hbWVzcGFjZSBkaXJlY3RseSlcblxuZnVuY3Rpb24gJGNvcHlUb0NsaXBib2FyZEV2ZW50KGVkaXRvciwgZXZlbnQpIHtcbiAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcblxuICBpZiAoIWRvbVNlbGVjdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvckRPTSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICBjb25zdCBmb2N1c0RPTSA9IGRvbVNlbGVjdGlvbi5mb2N1c05vZGU7XG5cbiAgaWYgKGFuY2hvckRPTSAhPT0gbnVsbCAmJiBmb2N1c0RPTSAhPT0gbnVsbCAmJiAhbGV4aWNhbC5pc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmIChjbGlwYm9hcmREYXRhID09PSBudWxsIHx8IHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGh0bWxTdHJpbmcgPSAkZ2V0SHRtbENvbnRlbnQoZWRpdG9yKTtcbiAgY29uc3QgbGV4aWNhbFN0cmluZyA9ICRnZXRMZXhpY2FsQ29udGVudChlZGl0b3IpO1xuICBsZXQgcGxhaW5TdHJpbmcgPSAnJztcblxuICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgcGxhaW5TdHJpbmcgPSBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKTtcbiAgfVxuXG4gIGlmIChodG1sU3RyaW5nICE9PSBudWxsKSB7XG4gICAgY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L2h0bWwnLCBodG1sU3RyaW5nKTtcbiAgfVxuXG4gIGlmIChsZXhpY2FsU3RyaW5nICE9PSBudWxsKSB7XG4gICAgY2xpcGJvYXJkRGF0YS5zZXREYXRhKCdhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yJywgbGV4aWNhbFN0cmluZyk7XG4gIH1cblxuICBjbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCBwbGFpblN0cmluZyk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnRzLiRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2RlcyA9ICRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2RlcztcbmV4cG9ydHMuJGdlbmVyYXRlTm9kZXNGcm9tU2VyaWFsaXplZE5vZGVzID0gJGdlbmVyYXRlTm9kZXNGcm9tU2VyaWFsaXplZE5vZGVzO1xuZXhwb3J0cy4kZ2V0SHRtbENvbnRlbnQgPSAkZ2V0SHRtbENvbnRlbnQ7XG5leHBvcnRzLiRnZXRMZXhpY2FsQ29udGVudCA9ICRnZXRMZXhpY2FsQ29udGVudDtcbmV4cG9ydHMuJGluc2VydERhdGFUcmFuc2ZlckZvclBsYWluVGV4dCA9ICRpbnNlcnREYXRhVHJhbnNmZXJGb3JQbGFpblRleHQ7XG5leHBvcnRzLiRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dCA9ICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dDtcbmV4cG9ydHMuJGluc2VydEdlbmVyYXRlZE5vZGVzID0gJGluc2VydEdlbmVyYXRlZE5vZGVzO1xuZXhwb3J0cy5jb3B5VG9DbGlwYm9hcmQgPSBjb3B5VG9DbGlwYm9hcmQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalClipboard =  true ? __webpack_require__(/*! ./LexicalClipboard.dev.js */ \"(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.js\") : 0\nmodule.exports = LexicalClipboard;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY2xpcGJvYXJkL0xleGljYWxDbGlwYm9hcmQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWix5QkFBeUIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLGtHQUEyQixJQUFJLENBQXFDO0FBQzlJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY2xpcGJvYXJkL0xleGljYWxDbGlwYm9hcmQuanM/NjRmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbENsaXBib2FyZCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsQ2xpcGJvYXJkLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsQ2xpcGJvYXJkLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsQ2xpcGJvYXJkOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/code/LexicalCode.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/code/LexicalCode.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar Prism = __webpack_require__(/*! prismjs */ \"(ssr)/./node_modules/prismjs/prism.js\");\n__webpack_require__(/*! prismjs/components/prism-clike */ \"(ssr)/./node_modules/prismjs/components/prism-clike.js\");\n__webpack_require__(/*! prismjs/components/prism-javascript */ \"(ssr)/./node_modules/prismjs/components/prism-javascript.js\");\n__webpack_require__(/*! prismjs/components/prism-markup */ \"(ssr)/./node_modules/prismjs/components/prism-markup.js\");\n__webpack_require__(/*! prismjs/components/prism-markdown */ \"(ssr)/./node_modules/prismjs/components/prism-markdown.js\");\n__webpack_require__(/*! prismjs/components/prism-c */ \"(ssr)/./node_modules/prismjs/components/prism-c.js\");\n__webpack_require__(/*! prismjs/components/prism-css */ \"(ssr)/./node_modules/prismjs/components/prism-css.js\");\n__webpack_require__(/*! prismjs/components/prism-objectivec */ \"(ssr)/./node_modules/prismjs/components/prism-objectivec.js\");\n__webpack_require__(/*! prismjs/components/prism-sql */ \"(ssr)/./node_modules/prismjs/components/prism-sql.js\");\n__webpack_require__(/*! prismjs/components/prism-python */ \"(ssr)/./node_modules/prismjs/components/prism-python.js\");\n__webpack_require__(/*! prismjs/components/prism-rust */ \"(ssr)/./node_modules/prismjs/components/prism-rust.js\");\n__webpack_require__(/*! prismjs/components/prism-swift */ \"(ssr)/./node_modules/prismjs/components/prism-swift.js\");\n__webpack_require__(/*! prismjs/components/prism-typescript */ \"(ssr)/./node_modules/prismjs/components/prism-typescript.js\");\n__webpack_require__(/*! prismjs/components/prism-java */ \"(ssr)/./node_modules/prismjs/components/prism-java.js\");\n__webpack_require__(/*! prismjs/components/prism-cpp */ \"(ssr)/./node_modules/prismjs/components/prism-cpp.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mapToPrismLanguage = language => {\n  // eslint-disable-next-line no-prototype-builtins\n  return language != null && Prism.languages.hasOwnProperty(language) ? language : undefined;\n};\n\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if (utils.isHTMLElement(child) && child.tagName === tagName) {\n      return true;\n    }\n\n    hasChildDOMNodeTag(child, tagName);\n  }\n\n  return false;\n}\n\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n/** @noInheritDoc */\n\nclass CodeNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'code';\n  }\n\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n\n  constructor(language, key) {\n    super(key);\n    this.__language = mapToPrismLanguage(language);\n  } // View\n\n\n  createDOM(config) {\n    const element = document.createElement('code');\n    utils.addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n    }\n\n    return false;\n  }\n\n  exportDOM() {\n    const element = document.createElement('pre');\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: node => ({\n        conversion: convertDivElement,\n        priority: 1\n      }),\n      pre: node => ({\n        conversion: convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node; // domNode is a <table> since we matched it by nodeName\n\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: convertTableElement,\n            priority: 3\n          };\n        }\n\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n\n        if (isGitHubCodeCell(td)) {\n          return {\n            conversion: convertTableCellElement,\n            priority: 3\n          };\n        }\n\n        if (table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n\n        return null;\n      }\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createCodeNode(serializedNode.language);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      language: this.getLanguage(),\n      type: 'code',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = lexical.$createParagraphNode();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    } // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n\n\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const firstPoint = anchor.isBefore(focus) ? anchor : focus;\n    const firstSelectionNode = firstPoint.getNode();\n\n    if ($isCodeHighlightNode(firstSelectionNode) || lexical.$isTabNode(firstSelectionNode)) {\n      let node = getFirstCodeNodeOfLine(firstSelectionNode);\n      const insertNodes = []; // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        if (lexical.$isTabNode(node)) {\n          insertNodes.push(lexical.$createTabNode());\n          node = node.getNextSibling();\n        } else if ($isCodeHighlightNode(node)) {\n          let spaces = 0;\n          const text = node.getTextContent();\n          const textSize = node.getTextContentSize();\n\n          for (; spaces < textSize && text[spaces] === ' '; spaces++);\n\n          if (spaces !== 0) {\n            insertNodes.push($createCodeHighlightNode(' '.repeat(spaces)));\n          }\n\n          if (spaces !== textSize) {\n            break;\n          }\n\n          node = node.getNextSibling();\n        } else {\n          break;\n        }\n      }\n\n      if (insertNodes.length > 0) {\n        selection.insertNodes([lexical.$createLineBreakNode(), ...insertNodes]);\n        return insertNodes[insertNodes.length - 1];\n      }\n    }\n\n    return null;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = mapToPrismLanguage(language);\n  }\n\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n\n}\nfunction $createCodeNode(language) {\n  return lexical.$applyNodeReplacement(new CodeNode(language));\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\n\nfunction convertPreElement(domNode) {\n  let language;\n\n  if (utils.isHTMLElement(domNode)) {\n    language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);\n  }\n\n  return {\n    node: $createCodeNode(language)\n  };\n}\n\nfunction convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n\n  return {\n    after: childLexicalNodes => {\n      const domParent = domNode.parentNode;\n\n      if (domParent != null && domNode !== domParent.lastChild) {\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n\n      return childLexicalNodes;\n    },\n    node: isCode ? $createCodeNode() : null\n  };\n}\n\nfunction convertTableElement() {\n  return {\n    node: $createCodeNode()\n  };\n}\n\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\n\nfunction convertTableCellElement(domNode) {\n  // domNode is a <td> since we matched it by nodeName\n  const cell = domNode;\n  return {\n    after: childLexicalNodes => {\n      if (cell.parentNode && cell.parentNode.nextSibling) {\n        // Append newline between code lines\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n\n      return childLexicalNodes;\n    },\n    node: null\n  };\n}\n\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\n\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n\n    parent = parent.parentElement;\n  }\n\n  return false;\n}\n\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\n\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(Prism.languages).filter( // Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism.languages[language] !== 'function').sort();\n/** @noInheritDoc */\n\nclass CodeHighlightNode extends lexical.TextNode {\n  /** @internal */\n  constructor(text, highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n\n  static getType() {\n    return 'code-highlight';\n  }\n\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    utils.addClassNamesToElement(element, className);\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        utils.removeClassNamesFromElement(dom, prevClassName);\n      }\n\n      if (nextClassName) {\n        utils.addClassNamesToElement(dom, nextClassName);\n      }\n    }\n\n    return update;\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      highlightType: this.getHighlightType(),\n      type: 'code-highlight',\n      version: 1\n    };\n  } // Prevent formatting (bold, underline, etc)\n\n\n  setFormat(format) {\n    return this;\n  }\n\n  isParentRequired() {\n    return true;\n  }\n\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n\n}\n\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\n\nfunction $createCodeHighlightNode(text, highlightType) {\n  return lexical.$applyNodeReplacement(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction getFirstCodeNodeOfLine(anchor) {\n  let previousNode = anchor;\n  let node = anchor;\n\n  while ($isCodeHighlightNode(node) || lexical.$isTabNode(node)) {\n    previousNode = node;\n    node = node.getPreviousSibling();\n  }\n\n  return previousNode;\n}\nfunction getLastCodeNodeOfLine(anchor) {\n  let nextNode = anchor;\n  let node = anchor;\n\n  while ($isCodeHighlightNode(node) || lexical.$isTabNode(node)) {\n    nextNode = node;\n    node = node.getNextSibling();\n  }\n\n  return nextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PrismTokenizer = {\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n\n  tokenize(code, language) {\n    return Prism.tokenize(code, Prism.languages[language || ''] || Prism.languages[this.defaultLanguage]);\n  }\n\n};\nfunction getStartOfCodeInLine(anchor, offset) {\n  let last = null;\n  let lastNonBlank = null;\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent(); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    if (nodeOffset === 0) {\n      node = node.getPreviousSibling();\n\n      if (node === null) {\n        break;\n      }\n\n      if (!($isCodeHighlightNode(node) || lexical.$isTabNode(node) || lexical.$isLineBreakNode(node))) {\n        throw Error(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);\n      }\n\n      if (lexical.$isLineBreakNode(node)) {\n        last = {\n          node,\n          offset: 1\n        };\n        break;\n      }\n\n      nodeOffset = Math.max(0, node.getTextContentSize() - 1);\n      nodeTextContent = node.getTextContent();\n    } else {\n      nodeOffset--;\n    }\n\n    const character = nodeTextContent[nodeOffset];\n\n    if ($isCodeHighlightNode(node) && character !== ' ') {\n      lastNonBlank = {\n        node,\n        offset: nodeOffset\n      };\n    }\n  } // lastNonBlank !== null: anchor in the middle of code; move to line beginning\n\n\n  if (lastNonBlank !== null) {\n    return lastNonBlank;\n  } // Spaces, tabs or nothing ahead of anchor\n\n\n  let codeCharacterAtAnchorOffset = null;\n\n  if (offset < anchor.getTextContentSize()) {\n    if ($isCodeHighlightNode(anchor)) {\n      codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];\n    }\n  } else {\n    const nextSibling = anchor.getNextSibling();\n\n    if ($isCodeHighlightNode(nextSibling)) {\n      codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];\n    }\n  }\n\n  if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== ' ') {\n    // Borderline whitespace and code, move to line beginning\n    return last;\n  } else {\n    const nextNonBlank = findNextNonBlankInLine(anchor, offset);\n\n    if (nextNonBlank !== null) {\n      return nextNonBlank;\n    } else {\n      return last;\n    }\n  }\n}\n\nfunction findNextNonBlankInLine(anchor, offset) {\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  let nodeTextContentSize = anchor.getTextContentSize(); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {\n      node = node.getNextSibling();\n\n      if (node === null || lexical.$isLineBreakNode(node)) {\n        return null;\n      }\n\n      if ($isCodeHighlightNode(node)) {\n        nodeOffset = 0;\n        nodeTextContent = node.getTextContent();\n        nodeTextContentSize = node.getTextContentSize();\n      }\n    }\n\n    if ($isCodeHighlightNode(node)) {\n      if (nodeTextContent[nodeOffset] !== ' ') {\n        return {\n          node,\n          offset: nodeOffset\n        };\n      }\n\n      nodeOffset++;\n    }\n  }\n}\n\nfunction getEndOfCodeInLine(anchor) {\n  const lastNode = getLastCodeNodeOfLine(anchor);\n\n  if (!!lexical.$isLineBreakNode(lastNode)) {\n    throw Error(`Unexpected lineBreakNode in getEndOfCodeInLine`);\n  }\n\n  return lastNode;\n}\n\nfunction textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace(lexical.$createTextNode(node.__text));\n  }\n}\n\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n\n  if (codeElement === null) {\n    return;\n  }\n\n  const children = node.getChildren();\n  const childrenLength = children.length; // @ts-ignore: internal field\n\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  } // @ts-ignore:: internal field\n\n\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n\n  for (let i = 0; i < childrenLength; i++) {\n    if (lexical.$isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n\n  codeElement.setAttribute('data-gutter', gutter);\n} // Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\n\nconst nodesCurrentlyHighlighting = new Set();\n\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n\n  if (nodesCurrentlyHighlighting.has(nodeKey)) {\n    return;\n  }\n\n  nodesCurrentlyHighlighting.add(nodeKey); // When new code block inserted it might not have language selected\n\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  } // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual codehighlight node to be transformed again as it's already\n  // in its final state\n\n\n  editor.update(() => {\n    updateAndRetainSelection(nodeKey, () => {\n      const currentNode = lexical.$getNodeByKey(nodeKey);\n\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n\n      const code = currentNode.getTextContent();\n      const tokens = tokenizer.tokenize(code, currentNode.getLanguage() || tokenizer.defaultLanguage);\n      const highlightNodes = getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(nodeKey);\n    },\n    skipTransforms: true\n  });\n}\n\nfunction getHighlightNodes(tokens, type) {\n  const nodes = [];\n\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      const partials = token.split(/(\\n|\\t)/);\n      const partialsLength = partials.length;\n\n      for (let i = 0; i < partialsLength; i++) {\n        const part = partials[i];\n\n        if (part === '\\n' || part === '\\r\\n') {\n          nodes.push(lexical.$createLineBreakNode());\n        } else if (part === '\\t') {\n          nodes.push(lexical.$createTabNode());\n        } else if (part.length > 0) {\n          nodes.push($createCodeHighlightNode(part, type));\n        }\n      }\n    } else {\n      const {\n        content\n      } = token;\n\n      if (typeof content === 'string') {\n        nodes.push(...getHighlightNodes([content], token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...getHighlightNodes(content, token.type));\n      }\n    }\n  }\n\n  return nodes;\n} // Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\n\n\nfunction updateAndRetainSelection(nodeKey, updateFn) {\n  const node = lexical.$getNodeByKey(nodeKey);\n\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n\n  const selection = lexical.$getSelection(); // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n\n  if (!lexical.$isRangeSelection(selection)) {\n    updateFn();\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && lexical.$isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0; // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n\n  const hasChanges = updateFn();\n\n  if (!hasChanges) {\n    return;\n  } // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n\n\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  } // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n\n\n  node.getChildren().some(_node => {\n    const isText = lexical.$isTextNode(_node);\n\n    if (isText || lexical.$isLineBreakNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n\n        return true;\n      }\n\n      textOffset -= textContentSize;\n    }\n\n    return false;\n  });\n} // Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\n\n\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n\n    leadingMatch++;\n  }\n\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\n\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code higlight nodes, tabs and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || lexical.$isTabNode(nodeA) && lexical.$isTabNode(nodeB) || lexical.$isLineBreakNode(nodeA) && lexical.$isLineBreakNode(nodeB);\n}\n\nfunction $isSelectionInCode(selection) {\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n\n  const anchorNode = selection.anchor.getNode();\n  const focusNode = selection.focus.getNode();\n\n  if (anchorNode.is(focusNode) && $isCodeNode(anchorNode)) {\n    return true;\n  }\n\n  const anchorParent = anchorNode.getParent();\n  return $isCodeNode(anchorParent) && anchorParent.is(focusNode.getParent());\n}\n\nfunction $getCodeLines(selection) {\n  const nodes = selection.getNodes();\n  const lines = [[]];\n\n  if (nodes.length === 1 && $isCodeNode(nodes[0])) {\n    return lines;\n  }\n\n  let lastLine = lines[0];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (!($isCodeHighlightNode(node) || lexical.$isTabNode(node) || lexical.$isLineBreakNode(node))) {\n      throw Error(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);\n    }\n\n    if (lexical.$isLineBreakNode(node)) {\n      if (i !== 0 && lastLine.length > 0) {\n        lastLine = [];\n        lines.push(lastLine);\n      }\n    } else {\n      lastLine.push(node);\n    }\n  }\n\n  return lines;\n}\n\nfunction handleTab(shiftKey) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return null;\n  }\n\n  const indentOrOutdent = !shiftKey ? lexical.INDENT_CONTENT_COMMAND : lexical.OUTDENT_CONTENT_COMMAND;\n  const tabOrOutdent = !shiftKey ? lexical.INSERT_TAB_COMMAND : lexical.OUTDENT_CONTENT_COMMAND; // 1. If multiple lines selected: indent/outdent\n\n  const codeLines = $getCodeLines(selection);\n\n  if (codeLines.length > 1) {\n    return indentOrOutdent;\n  } // 2. If entire line selected: indent/outdent\n\n\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || lexical.$isTabNode(firstNode) || lexical.$isLineBreakNode(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or TabNode`);\n  }\n\n  if ($isCodeNode(firstNode)) {\n    return indentOrOutdent;\n  }\n\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n  const lastOfLine = getLastCodeNodeOfLine(firstNode);\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  let selectionFirst;\n  let selectionLast;\n\n  if (focus.isBefore(anchor)) {\n    selectionFirst = focus;\n    selectionLast = anchor;\n  } else {\n    selectionFirst = anchor;\n    selectionLast = focus;\n  }\n\n  if (firstOfLine !== null && lastOfLine !== null && selectionFirst.key === firstOfLine.getKey() && selectionFirst.offset === 0 && selectionLast.key === lastOfLine.getKey() && selectionLast.offset === lastOfLine.getTextContentSize()) {\n    return indentOrOutdent;\n  } // 3. Else: tab/outdent\n\n\n  return tabOrOutdent;\n}\n\nfunction handleMultilineIndent(type) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return false;\n  }\n\n  const codeLines = $getCodeLines(selection);\n  const codeLinesLength = codeLines.length; // Multiple lines selection\n\n  if (codeLines.length > 1) {\n    for (let i = 0; i < codeLinesLength; i++) {\n      const line = codeLines[i];\n\n      if (line.length > 0) {\n        let firstOfLine = line[0]; // First and last lines might not be complete\n\n        if (i === 0) {\n          firstOfLine = getFirstCodeNodeOfLine(firstOfLine);\n        }\n\n        if (firstOfLine !== null) {\n          if (type === lexical.INDENT_CONTENT_COMMAND) {\n            firstOfLine.insertBefore(lexical.$createTabNode());\n          } else if (lexical.$isTabNode(firstOfLine)) {\n            firstOfLine.remove();\n          }\n        }\n      }\n    }\n\n    return true;\n  } // Just one line\n\n\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || lexical.$isTabNode(firstNode) || lexical.$isLineBreakNode(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or CodeTabNode`);\n  }\n\n  if ($isCodeNode(firstNode)) {\n    // CodeNode is empty\n    if (type === lexical.INDENT_CONTENT_COMMAND) {\n      selection.insertNodes([lexical.$createTabNode()]);\n    }\n\n    return true;\n  }\n\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n\n  if (!(firstOfLine !== null)) {\n    throw Error(`Expected getFirstCodeNodeOfLine to return a valid Code Node`);\n  }\n\n  if (type === lexical.INDENT_CONTENT_COMMAND) {\n    if (lexical.$isLineBreakNode(firstOfLine)) {\n      firstOfLine.insertAfter(lexical.$createTabNode());\n    } else {\n      firstOfLine.insertBefore(lexical.$createTabNode());\n    }\n  } else if (lexical.$isTabNode(firstOfLine)) {\n    firstOfLine.remove();\n  }\n\n  return true;\n}\n\nfunction handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  } // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === lexical.KEY_ARROW_UP_COMMAND; // Ensure the selection is within the codeblock\n\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || lexical.$isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || lexical.$isTabNode(focusNode))) {\n    return false;\n  }\n\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // sibling thats can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  let start;\n  let end;\n\n  if (anchorNode.isBefore(focusNode)) {\n    start = getFirstCodeNodeOfLine(anchorNode);\n    end = getLastCodeNodeOfLine(focusNode);\n  } else {\n    start = getFirstCodeNodeOfLine(focusNode);\n    end = getLastCodeNodeOfLine(anchorNode);\n  }\n\n  if (start == null || end == null) {\n    return false;\n  }\n\n  const range = start.getNodesBetween(end);\n\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n\n    if (!$isCodeHighlightNode(node) && !lexical.$isTabNode(node) && !lexical.$isLineBreakNode(node)) {\n      return false;\n    }\n  } // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n\n\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n\n  if (!lexical.$isLineBreakNode(linebreak)) {\n    return true;\n  }\n\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n\n  if (sibling == null) {\n    return true;\n  }\n\n  const maybeInsertionPoint = $isCodeHighlightNode(sibling) || lexical.$isTabNode(sibling) || lexical.$isLineBreakNode(sibling) ? arrowIsUp ? getFirstCodeNodeOfLine(sibling) : getLastCodeNodeOfLine(sibling) : null;\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n\n  if (type === lexical.KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\n\nfunction handleMoveTo(type, event) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === lexical.MOVE_TO_START;\n\n  if (!($isCodeHighlightNode(anchorNode) || lexical.$isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || lexical.$isTabNode(focusNode))) {\n    return false;\n  }\n\n  if (isMoveToStart) {\n    const start = getStartOfCodeInLine(focusNode, focus.offset);\n\n    if (start !== null) {\n      const {\n        node,\n        offset\n      } = start;\n\n      if (lexical.$isLineBreakNode(node)) {\n        node.selectNext(0, 0);\n      } else {\n        selection.setTextNodeRange(node, offset, node, offset);\n      }\n    } else {\n      focusNode.getParentOrThrow().selectStart();\n    }\n  } else {\n    const node = getEndOfCodeInLine(focusNode);\n    node.select();\n  }\n\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\n\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n\n  return utils.mergeRegister(editor.registerMutationListener(CodeNode, mutations => {\n    editor.update(() => {\n      for (const [key, type] of mutations) {\n        if (type !== 'destroyed') {\n          const node = lexical.$getNodeByKey(key);\n\n          if (node !== null) {\n            updateCodeGutter(node, editor);\n          }\n        }\n      }\n    });\n  }), editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(lexical.TextNode, node => textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => textNodeTransform(node, editor, tokenizer)), editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\n    const command = handleTab(event.shiftKey);\n\n    if (command === null) {\n      return false;\n    }\n\n    event.preventDefault();\n    editor.dispatchCommand(command, undefined);\n    return true;\n  }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.INSERT_TAB_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n\n    lexical.$insertNodes([lexical.$createTabNode()]);\n    return true;\n  }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.INDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.OUTDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_UP_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_DOWN_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_END, payload => handleMoveTo(lexical.MOVE_TO_END, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_START, payload => handleMoveTo(lexical.MOVE_TO_START, payload), lexical.COMMAND_PRIORITY_LOW));\n}\n\nexports.$createCodeHighlightNode = $createCodeHighlightNode;\nexports.$createCodeNode = $createCodeNode;\nexports.$isCodeHighlightNode = $isCodeHighlightNode;\nexports.$isCodeNode = $isCodeNode;\nexports.CODE_LANGUAGE_FRIENDLY_NAME_MAP = CODE_LANGUAGE_FRIENDLY_NAME_MAP;\nexports.CODE_LANGUAGE_MAP = CODE_LANGUAGE_MAP;\nexports.CodeHighlightNode = CodeHighlightNode;\nexports.CodeNode = CodeNode;\nexports.DEFAULT_CODE_LANGUAGE = DEFAULT_CODE_LANGUAGE;\nexports.PrismTokenizer = PrismTokenizer;\nexports.getCodeLanguages = getCodeLanguages;\nexports.getDefaultCodeLanguage = getDefaultCodeLanguage;\nexports.getEndOfCodeInLine = getEndOfCodeInLine;\nexports.getFirstCodeNodeOfLine = getFirstCodeNodeOfLine;\nexports.getLanguageFriendlyName = getLanguageFriendlyName;\nexports.getLastCodeNodeOfLine = getLastCodeNodeOfLine;\nexports.getStartOfCodeInLine = getStartOfCodeInLine;\nexports.normalizeCodeLang = normalizeCodeLang;\nexports.registerCodeHighlighting = registerCodeHighlighting;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY29kZS9MZXhpY2FsQ29kZS5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHNEQUFTO0FBQzdCLG1CQUFPLENBQUMsOEZBQWdDO0FBQ3hDLG1CQUFPLENBQUMsd0dBQXFDO0FBQzdDLG1CQUFPLENBQUMsZ0dBQWlDO0FBQ3pDLG1CQUFPLENBQUMsb0dBQW1DO0FBQzNDLG1CQUFPLENBQUMsc0ZBQTRCO0FBQ3BDLG1CQUFPLENBQUMsMEZBQThCO0FBQ3RDLG1CQUFPLENBQUMsd0dBQXFDO0FBQzdDLG1CQUFPLENBQUMsMEZBQThCO0FBQ3RDLG1CQUFPLENBQUMsZ0dBQWlDO0FBQ3pDLG1CQUFPLENBQUMsNEZBQStCO0FBQ3ZDLG1CQUFPLENBQUMsOEZBQWdDO0FBQ3hDLG1CQUFPLENBQUMsd0dBQXFDO0FBQzdDLG1CQUFPLENBQUMsNEZBQStCO0FBQ3ZDLG1CQUFPLENBQUMsMEZBQThCO0FBQ3RDLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLHdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsMkNBQTJDOztBQUU1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3REFBd0Q7OztBQUc1RDtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG9CQUFvQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlHQUFpRzs7QUFFakc7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDOztBQUVBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0EsMkJBQTJCOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxnQ0FBZ0M7QUFDaEMsdUJBQXVCO0FBQ3ZCLDRCQUE0QjtBQUM1QixtQkFBbUI7QUFDbkIsdUNBQXVDO0FBQ3ZDLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsZ0JBQWdCO0FBQ2hCLDZCQUE2QjtBQUM3QixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLCtCQUErQjtBQUMvQiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLHlCQUF5QjtBQUN6QixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jb2RlL0xleGljYWxDb2RlLmRldi5qcz81NDFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJpc20gPSByZXF1aXJlKCdwcmlzbWpzJyk7XG5yZXF1aXJlKCdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY2xpa2UnKTtcbnJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1qYXZhc2NyaXB0Jyk7XG5yZXF1aXJlKCdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tbWFya3VwJyk7XG5yZXF1aXJlKCdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tbWFya2Rvd24nKTtcbnJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jJyk7XG5yZXF1aXJlKCdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY3NzJyk7XG5yZXF1aXJlKCdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tb2JqZWN0aXZlYycpO1xucmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXNxbCcpO1xucmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXB5dGhvbicpO1xucmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXJ1c3QnKTtcbnJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1zd2lmdCcpO1xucmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXR5cGVzY3JpcHQnKTtcbnJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1qYXZhJyk7XG5yZXF1aXJlKCdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY3BwJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgbWFwVG9QcmlzbUxhbmd1YWdlID0gbGFuZ3VhZ2UgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIHJldHVybiBsYW5ndWFnZSAhPSBudWxsICYmIFByaXNtLmxhbmd1YWdlcy5oYXNPd25Qcm9wZXJ0eShsYW5ndWFnZSkgPyBsYW5ndWFnZSA6IHVuZGVmaW5lZDtcbn07XG5cbmZ1bmN0aW9uIGhhc0NoaWxkRE9NTm9kZVRhZyhub2RlLCB0YWdOYW1lKSB7XG4gIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgaWYgKHV0aWxzLmlzSFRNTEVsZW1lbnQoY2hpbGQpICYmIGNoaWxkLnRhZ05hbWUgPT09IHRhZ05hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGhhc0NoaWxkRE9NTm9kZVRhZyhjaGlsZCwgdGFnTmFtZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IExBTkdVQUdFX0RBVEFfQVRUUklCVVRFID0gJ2RhdGEtaGlnaGxpZ2h0LWxhbmd1YWdlJztcbi8qKiBAbm9Jbmhlcml0RG9jICovXG5cbmNsYXNzIENvZGVOb2RlIGV4dGVuZHMgbGV4aWNhbC5FbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdjb2RlJztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBDb2RlTm9kZShub2RlLl9fbGFuZ3VhZ2UsIG5vZGUuX19rZXkpO1xuICB9XG5cbiAgY29uc3RydWN0b3IobGFuZ3VhZ2UsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX2xhbmd1YWdlID0gbWFwVG9QcmlzbUxhbmd1YWdlKGxhbmd1YWdlKTtcbiAgfSAvLyBWaWV3XG5cblxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvZGUnKTtcbiAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS5jb2RlKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3BlbGxjaGVjaycsICdmYWxzZScpO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gdGhpcy5nZXRMYW5ndWFnZSgpO1xuXG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShMQU5HVUFHRV9EQVRBX0FUVFJJQlVURSwgbGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIGNvbnN0IGxhbmd1YWdlID0gdGhpcy5fX2xhbmd1YWdlO1xuICAgIGNvbnN0IHByZXZMYW5ndWFnZSA9IHByZXZOb2RlLl9fbGFuZ3VhZ2U7XG5cbiAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgIGlmIChsYW5ndWFnZSAhPT0gcHJldkxhbmd1YWdlKSB7XG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUsIGxhbmd1YWdlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZMYW5ndWFnZSkge1xuICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZShMQU5HVUFHRV9EQVRBX0FUVFJJQlVURSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZXhwb3J0RE9NKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwcmUnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3BlbGxjaGVjaycsICdmYWxzZScpO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gdGhpcy5nZXRMYW5ndWFnZSgpO1xuXG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShMQU5HVUFHRV9EQVRBX0FUVFJJQlVURSwgbGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFR5cGljYWxseSA8cHJlPiBpcyB1c2VkIGZvciBjb2RlIGJsb2NrcywgYW5kIDxjb2RlPiBmb3IgaW5saW5lIGNvZGUgc3R5bGVzXG4gICAgICAvLyBidXQgaWYgaXQncyBhIG11bHRpIGxpbmUgPGNvZGU+IHdlJ2xsIGNyZWF0ZSBhIGJsb2NrLiBQYXNzIHRocm91Z2ggdG9cbiAgICAgIC8vIGlubGluZSBmb3JtYXQgaGFuZGxlZCBieSBUZXh0Tm9kZSBvdGhlcndpc2UuXG4gICAgICBjb2RlOiBub2RlID0+IHtcbiAgICAgICAgY29uc3QgaXNNdWx0aUxpbmUgPSBub2RlLnRleHRDb250ZW50ICE9IG51bGwgJiYgKC9cXHI/XFxuLy50ZXN0KG5vZGUudGV4dENvbnRlbnQpIHx8IGhhc0NoaWxkRE9NTm9kZVRhZyhub2RlLCAnQlInKSk7XG4gICAgICAgIHJldHVybiBpc011bHRpTGluZSA/IHtcbiAgICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0UHJlRWxlbWVudCxcbiAgICAgICAgICBwcmlvcml0eTogMVxuICAgICAgICB9IDogbnVsbDtcbiAgICAgIH0sXG4gICAgICBkaXY6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydERpdkVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAxXG4gICAgICB9KSxcbiAgICAgIHByZTogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0UHJlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgdGFibGU6IG5vZGUgPT4ge1xuICAgICAgICBjb25zdCB0YWJsZSA9IG5vZGU7IC8vIGRvbU5vZGUgaXMgYSA8dGFibGU+IHNpbmNlIHdlIG1hdGNoZWQgaXQgYnkgbm9kZU5hbWVcblxuICAgICAgICBpZiAoaXNHaXRIdWJDb2RlVGFibGUodGFibGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUYWJsZUVsZW1lbnQsXG4gICAgICAgICAgICBwcmlvcml0eTogM1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICB0ZDogbm9kZSA9PiB7XG4gICAgICAgIC8vIGVsZW1lbnQgaXMgYSA8dGQ+IHNpbmNlIHdlIG1hdGNoZWQgaXQgYnkgbm9kZU5hbWVcbiAgICAgICAgY29uc3QgdGQgPSBub2RlO1xuICAgICAgICBjb25zdCB0YWJsZSA9IHRkLmNsb3Nlc3QoJ3RhYmxlJyk7XG5cbiAgICAgICAgaWYgKGlzR2l0SHViQ29kZUNlbGwodGQpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUYWJsZUNlbGxFbGVtZW50LFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhYmxlICYmIGlzR2l0SHViQ29kZVRhYmxlKHRhYmxlKSkge1xuICAgICAgICAgIC8vIFJldHVybiBhIG5vLW9wIGlmIGl0J3MgYSB0YWJsZSBjZWxsIGluIGEgY29kZSB0YWJsZSwgYnV0IG5vdCBhIGNvZGUgbGluZS5cbiAgICAgICAgICAvLyBPdGhlcndpc2UgaXQnbGwgZmFsbCBiYWNrIHRvIHRoZSBUXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRDb2RlTm9vcCxcbiAgICAgICAgICAgIHByaW9yaXR5OiAzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHRyOiBub2RlID0+IHtcbiAgICAgICAgLy8gZWxlbWVudCBpcyBhIDx0cj4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICAgICAgICBjb25zdCB0ciA9IG5vZGU7XG4gICAgICAgIGNvbnN0IHRhYmxlID0gdHIuY2xvc2VzdCgndGFibGUnKTtcblxuICAgICAgICBpZiAodGFibGUgJiYgaXNHaXRIdWJDb2RlVGFibGUodGFibGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRDb2RlTm9vcCxcbiAgICAgICAgICAgIHByaW9yaXR5OiAzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlQ29kZU5vZGUoc2VyaWFsaXplZE5vZGUubGFuZ3VhZ2UpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4geyAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBsYW5ndWFnZTogdGhpcy5nZXRMYW5ndWFnZSgpLFxuICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH0gLy8gTXV0YXRpb25cblxuXG4gIGluc2VydE5ld0FmdGVyKHNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICAgIGlmIChjaGlsZHJlbkxlbmd0aCA+PSAyICYmIGNoaWxkcmVuW2NoaWxkcmVuTGVuZ3RoIC0gMV0uZ2V0VGV4dENvbnRlbnQoKSA9PT0gJ1xcbicgJiYgY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAyXS5nZXRUZXh0Q29udGVudCgpID09PSAnXFxuJyAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBzZWxlY3Rpb24uYW5jaG9yLmtleSA9PT0gdGhpcy5fX2tleSAmJiBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gY2hpbGRyZW5MZW5ndGgpIHtcbiAgICAgIGNoaWxkcmVuW2NoaWxkcmVuTGVuZ3RoIC0gMV0ucmVtb3ZlKCk7XG4gICAgICBjaGlsZHJlbltjaGlsZHJlbkxlbmd0aCAtIDJdLnJlbW92ZSgpO1xuICAgICAgY29uc3QgbmV3RWxlbWVudCA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobmV3RWxlbWVudCwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgICB9IC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgd2l0aGluIHRoZSBjb2RlYmxvY2ssIGZpbmQgYWxsIGxlYWRpbmcgdGFicyBhbmRcbiAgICAvLyBzcGFjZXMgb2YgdGhlIGN1cnJlbnQgbGluZS4gQ3JlYXRlIGEgbmV3IGxpbmUgdGhhdCBoYXMgYWxsIHRob3NlXG4gICAgLy8gdGFicyBhbmQgc3BhY2VzLCBzdWNoIHRoYXQgbGVhZGluZyBpbmRlbnRhdGlvbiBpcyBwcmVzZXJ2ZWQuXG5cblxuICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGFuY2hvci5pc0JlZm9yZShmb2N1cykgPyBhbmNob3IgOiBmb2N1cztcbiAgICBjb25zdCBmaXJzdFNlbGVjdGlvbk5vZGUgPSBmaXJzdFBvaW50LmdldE5vZGUoKTtcblxuICAgIGlmICgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShmaXJzdFNlbGVjdGlvbk5vZGUpIHx8IGxleGljYWwuJGlzVGFiTm9kZShmaXJzdFNlbGVjdGlvbk5vZGUpKSB7XG4gICAgICBsZXQgbm9kZSA9IGdldEZpcnN0Q29kZU5vZGVPZkxpbmUoZmlyc3RTZWxlY3Rpb25Ob2RlKTtcbiAgICAgIGNvbnN0IGluc2VydE5vZGVzID0gW107IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGxleGljYWwuJGlzVGFiTm9kZShub2RlKSkge1xuICAgICAgICAgIGluc2VydE5vZGVzLnB1c2gobGV4aWNhbC4kY3JlYXRlVGFiTm9kZSgpKTtcbiAgICAgICAgICBub2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgbGV0IHNwYWNlcyA9IDA7XG4gICAgICAgICAgY29uc3QgdGV4dCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgICBjb25zdCB0ZXh0U2l6ZSA9IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG5cbiAgICAgICAgICBmb3IgKDsgc3BhY2VzIDwgdGV4dFNpemUgJiYgdGV4dFtzcGFjZXNdID09PSAnICc7IHNwYWNlcysrKTtcblxuICAgICAgICAgIGlmIChzcGFjZXMgIT09IDApIHtcbiAgICAgICAgICAgIGluc2VydE5vZGVzLnB1c2goJGNyZWF0ZUNvZGVIaWdobGlnaHROb2RlKCcgJy5yZXBlYXQoc3BhY2VzKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzcGFjZXMgIT09IHRleHRTaXplKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnNlcnROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNlbGVjdGlvbi5pbnNlcnROb2RlcyhbbGV4aWNhbC4kY3JlYXRlTGluZUJyZWFrTm9kZSgpLCAuLi5pbnNlcnROb2Rlc10pO1xuICAgICAgICByZXR1cm4gaW5zZXJ0Tm9kZXNbaW5zZXJ0Tm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIGNvbnN0IHBhcmFncmFwaCA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHBhcmFncmFwaC5hcHBlbmQoY2hpbGQpKTtcbiAgICB0aGlzLnJlcGxhY2UocGFyYWdyYXBoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHNldExhbmd1YWdlKGxhbmd1YWdlKSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX19sYW5ndWFnZSA9IG1hcFRvUHJpc21MYW5ndWFnZShsYW5ndWFnZSk7XG4gIH1cblxuICBnZXRMYW5ndWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2xhbmd1YWdlO1xuICB9XG5cbn1cbmZ1bmN0aW9uICRjcmVhdGVDb2RlTm9kZShsYW5ndWFnZSkge1xuICByZXR1cm4gbGV4aWNhbC4kYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IENvZGVOb2RlKGxhbmd1YWdlKSk7XG59XG5mdW5jdGlvbiAkaXNDb2RlTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgQ29kZU5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRQcmVFbGVtZW50KGRvbU5vZGUpIHtcbiAgbGV0IGxhbmd1YWdlO1xuXG4gIGlmICh1dGlscy5pc0hUTUxFbGVtZW50KGRvbU5vZGUpKSB7XG4gICAgbGFuZ3VhZ2UgPSBkb21Ob2RlLmdldEF0dHJpYnV0ZShMQU5HVUFHRV9EQVRBX0FUVFJJQlVURSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVDb2RlTm9kZShsYW5ndWFnZSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydERpdkVsZW1lbnQoZG9tTm9kZSkge1xuICAvLyBkb21Ob2RlIGlzIGEgPGRpdj4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICBjb25zdCBkaXYgPSBkb21Ob2RlO1xuICBjb25zdCBpc0NvZGUgPSBpc0NvZGVFbGVtZW50KGRpdik7XG5cbiAgaWYgKCFpc0NvZGUgJiYgIWlzQ29kZUNoaWxkRWxlbWVudChkaXYpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZnRlcjogY2hpbGRMZXhpY2FsTm9kZXMgPT4ge1xuICAgICAgY29uc3QgZG9tUGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuXG4gICAgICBpZiAoZG9tUGFyZW50ICE9IG51bGwgJiYgZG9tTm9kZSAhPT0gZG9tUGFyZW50Lmxhc3RDaGlsZCkge1xuICAgICAgICBjaGlsZExleGljYWxOb2Rlcy5wdXNoKGxleGljYWwuJGNyZWF0ZUxpbmVCcmVha05vZGUoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGlsZExleGljYWxOb2RlcztcbiAgICB9LFxuICAgIG5vZGU6IGlzQ29kZSA/ICRjcmVhdGVDb2RlTm9kZSgpIDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VGFibGVFbGVtZW50KCkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVDb2RlTm9kZSgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRDb2RlTm9vcCgpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUYWJsZUNlbGxFbGVtZW50KGRvbU5vZGUpIHtcbiAgLy8gZG9tTm9kZSBpcyBhIDx0ZD4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICBjb25zdCBjZWxsID0gZG9tTm9kZTtcbiAgcmV0dXJuIHtcbiAgICBhZnRlcjogY2hpbGRMZXhpY2FsTm9kZXMgPT4ge1xuICAgICAgaWYgKGNlbGwucGFyZW50Tm9kZSAmJiBjZWxsLnBhcmVudE5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgLy8gQXBwZW5kIG5ld2xpbmUgYmV0d2VlbiBjb2RlIGxpbmVzXG4gICAgICAgIGNoaWxkTGV4aWNhbE5vZGVzLnB1c2gobGV4aWNhbC4kY3JlYXRlTGluZUJyZWFrTm9kZSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoaWxkTGV4aWNhbE5vZGVzO1xuICAgIH0sXG4gICAgbm9kZTogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0NvZGVFbGVtZW50KGRpdikge1xuICByZXR1cm4gZGl2LnN0eWxlLmZvbnRGYW1pbHkubWF0Y2goJ21vbm9zcGFjZScpICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0NvZGVDaGlsZEVsZW1lbnQobm9kZSkge1xuICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoaXNDb2RlRWxlbWVudChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNHaXRIdWJDb2RlQ2VsbChjZWxsKSB7XG4gIHJldHVybiBjZWxsLmNsYXNzTGlzdC5jb250YWlucygnanMtZmlsZS1saW5lJyk7XG59XG5cbmZ1bmN0aW9uIGlzR2l0SHViQ29kZVRhYmxlKHRhYmxlKSB7XG4gIHJldHVybiB0YWJsZS5jbGFzc0xpc3QuY29udGFpbnMoJ2pzLWZpbGUtbGluZS1jb250YWluZXInKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgREVGQVVMVF9DT0RFX0xBTkdVQUdFID0gJ2phdmFzY3JpcHQnO1xuY29uc3QgQ09ERV9MQU5HVUFHRV9GUklFTkRMWV9OQU1FX01BUCA9IHtcbiAgYzogJ0MnLFxuICBjbGlrZTogJ0MtbGlrZScsXG4gIGNwcDogJ0MrKycsXG4gIGNzczogJ0NTUycsXG4gIGh0bWw6ICdIVE1MJyxcbiAgamF2YTogJ0phdmEnLFxuICBqczogJ0phdmFTY3JpcHQnLFxuICBtYXJrZG93bjogJ01hcmtkb3duJyxcbiAgb2JqYzogJ09iamVjdGl2ZS1DJyxcbiAgcGxhaW46ICdQbGFpbiBUZXh0JyxcbiAgcHk6ICdQeXRob24nLFxuICBydXN0OiAnUnVzdCcsXG4gIHNxbDogJ1NRTCcsXG4gIHN3aWZ0OiAnU3dpZnQnLFxuICB0eXBlc2NyaXB0OiAnVHlwZVNjcmlwdCcsXG4gIHhtbDogJ1hNTCdcbn07XG5jb25zdCBDT0RFX0xBTkdVQUdFX01BUCA9IHtcbiAgY3BwOiAnY3BwJyxcbiAgamF2YTogJ2phdmEnLFxuICBqYXZhc2NyaXB0OiAnanMnLFxuICBtZDogJ21hcmtkb3duJyxcbiAgcGxhaW50ZXh0OiAncGxhaW4nLFxuICBweXRob246ICdweScsXG4gIHRleHQ6ICdwbGFpbicsXG4gIHRzOiAndHlwZXNjcmlwdCdcbn07XG5mdW5jdGlvbiBub3JtYWxpemVDb2RlTGFuZyhsYW5nKSB7XG4gIHJldHVybiBDT0RFX0xBTkdVQUdFX01BUFtsYW5nXSB8fCBsYW5nO1xufVxuZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VGcmllbmRseU5hbWUobGFuZykge1xuICBjb25zdCBfbGFuZyA9IG5vcm1hbGl6ZUNvZGVMYW5nKGxhbmcpO1xuXG4gIHJldHVybiBDT0RFX0xBTkdVQUdFX0ZSSUVORExZX05BTUVfTUFQW19sYW5nXSB8fCBfbGFuZztcbn1cbmNvbnN0IGdldERlZmF1bHRDb2RlTGFuZ3VhZ2UgPSAoKSA9PiBERUZBVUxUX0NPREVfTEFOR1VBR0U7XG5jb25zdCBnZXRDb2RlTGFuZ3VhZ2VzID0gKCkgPT4gT2JqZWN0LmtleXMoUHJpc20ubGFuZ3VhZ2VzKS5maWx0ZXIoIC8vIFByaXNtIGhhcyBzZXZlcmFsIGxhbmd1YWdlIGhlbHBlcnMgbWl4ZWQgaW50byBsYW5ndWFnZXMgb2JqZWN0XG4vLyBzbyBmaWx0ZXJpbmcgdGhlbSBvdXQgaGVyZSB0byBnZXQgbGFuZ3MgbGlzdFxubGFuZ3VhZ2UgPT4gdHlwZW9mIFByaXNtLmxhbmd1YWdlc1tsYW5ndWFnZV0gIT09ICdmdW5jdGlvbicpLnNvcnQoKTtcbi8qKiBAbm9Jbmhlcml0RG9jICovXG5cbmNsYXNzIENvZGVIaWdobGlnaHROb2RlIGV4dGVuZHMgbGV4aWNhbC5UZXh0Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IodGV4dCwgaGlnaGxpZ2h0VHlwZSwga2V5KSB7XG4gICAgc3VwZXIodGV4dCwga2V5KTtcbiAgICB0aGlzLl9faGlnaGxpZ2h0VHlwZSA9IGhpZ2hsaWdodFR5cGU7XG4gIH1cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2NvZGUtaGlnaGxpZ2h0JztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBDb2RlSGlnaGxpZ2h0Tm9kZShub2RlLl9fdGV4dCwgbm9kZS5fX2hpZ2hsaWdodFR5cGUgfHwgdW5kZWZpbmVkLCBub2RlLl9fa2V5KTtcbiAgfVxuXG4gIGdldEhpZ2hsaWdodFR5cGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19oaWdobGlnaHRUeXBlO1xuICB9XG5cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBzdXBlci5jcmVhdGVET00oY29uZmlnKTtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBnZXRIaWdobGlnaHRUaGVtZUNsYXNzKGNvbmZpZy50aGVtZSwgdGhpcy5fX2hpZ2hsaWdodFR5cGUpO1xuICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBjb25zdCB1cGRhdGUgPSBzdXBlci51cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKTtcbiAgICBjb25zdCBwcmV2Q2xhc3NOYW1lID0gZ2V0SGlnaGxpZ2h0VGhlbWVDbGFzcyhjb25maWcudGhlbWUsIHByZXZOb2RlLl9faGlnaGxpZ2h0VHlwZSk7XG4gICAgY29uc3QgbmV4dENsYXNzTmFtZSA9IGdldEhpZ2hsaWdodFRoZW1lQ2xhc3MoY29uZmlnLnRoZW1lLCB0aGlzLl9faGlnaGxpZ2h0VHlwZSk7XG5cbiAgICBpZiAocHJldkNsYXNzTmFtZSAhPT0gbmV4dENsYXNzTmFtZSkge1xuICAgICAgaWYgKHByZXZDbGFzc05hbWUpIHtcbiAgICAgICAgdXRpbHMucmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgcHJldkNsYXNzTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0Q2xhc3NOYW1lKSB7XG4gICAgICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCBuZXh0Q2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZUNvZGVIaWdobGlnaHROb2RlKHNlcmlhbGl6ZWROb2RlLnRleHQsIHNlcmlhbGl6ZWROb2RlLmhpZ2hsaWdodFR5cGUpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXREZXRhaWwoc2VyaWFsaXplZE5vZGUuZGV0YWlsKTtcbiAgICBub2RlLnNldE1vZGUoc2VyaWFsaXplZE5vZGUubW9kZSk7XG4gICAgbm9kZS5zZXRTdHlsZShzZXJpYWxpemVkTm9kZS5zdHlsZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGhpZ2hsaWdodFR5cGU6IHRoaXMuZ2V0SGlnaGxpZ2h0VHlwZSgpLFxuICAgICAgdHlwZTogJ2NvZGUtaGlnaGxpZ2h0JyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9IC8vIFByZXZlbnQgZm9ybWF0dGluZyAoYm9sZCwgdW5kZXJsaW5lLCBldGMpXG5cblxuICBzZXRGb3JtYXQoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpc1BhcmVudFJlcXVpcmVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY3JlYXRlUGFyZW50RWxlbWVudE5vZGUoKSB7XG4gICAgcmV0dXJuICRjcmVhdGVDb2RlTm9kZSgpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0VGhlbWVDbGFzcyh0aGVtZSwgaGlnaGxpZ2h0VHlwZSkge1xuICByZXR1cm4gaGlnaGxpZ2h0VHlwZSAmJiB0aGVtZSAmJiB0aGVtZS5jb2RlSGlnaGxpZ2h0ICYmIHRoZW1lLmNvZGVIaWdobGlnaHRbaGlnaGxpZ2h0VHlwZV07XG59XG5cbmZ1bmN0aW9uICRjcmVhdGVDb2RlSGlnaGxpZ2h0Tm9kZSh0ZXh0LCBoaWdobGlnaHRUeXBlKSB7XG4gIHJldHVybiBsZXhpY2FsLiRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgQ29kZUhpZ2hsaWdodE5vZGUodGV4dCwgaGlnaGxpZ2h0VHlwZSkpO1xufVxuZnVuY3Rpb24gJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIENvZGVIaWdobGlnaHROb2RlO1xufVxuZnVuY3Rpb24gZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZShhbmNob3IpIHtcbiAgbGV0IHByZXZpb3VzTm9kZSA9IGFuY2hvcjtcbiAgbGV0IG5vZGUgPSBhbmNob3I7XG5cbiAgd2hpbGUgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpIHx8IGxleGljYWwuJGlzVGFiTm9kZShub2RlKSkge1xuICAgIHByZXZpb3VzTm9kZSA9IG5vZGU7XG4gICAgbm9kZSA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gIH1cblxuICByZXR1cm4gcHJldmlvdXNOb2RlO1xufVxuZnVuY3Rpb24gZ2V0TGFzdENvZGVOb2RlT2ZMaW5lKGFuY2hvcikge1xuICBsZXQgbmV4dE5vZGUgPSBhbmNob3I7XG4gIGxldCBub2RlID0gYW5jaG9yO1xuXG4gIHdoaWxlICgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSB8fCBsZXhpY2FsLiRpc1RhYk5vZGUobm9kZSkpIHtcbiAgICBuZXh0Tm9kZSA9IG5vZGU7XG4gICAgbm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgfVxuXG4gIHJldHVybiBuZXh0Tm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgUHJpc21Ub2tlbml6ZXIgPSB7XG4gIGRlZmF1bHRMYW5ndWFnZTogREVGQVVMVF9DT0RFX0xBTkdVQUdFLFxuXG4gIHRva2VuaXplKGNvZGUsIGxhbmd1YWdlKSB7XG4gICAgcmV0dXJuIFByaXNtLnRva2VuaXplKGNvZGUsIFByaXNtLmxhbmd1YWdlc1tsYW5ndWFnZSB8fCAnJ10gfHwgUHJpc20ubGFuZ3VhZ2VzW3RoaXMuZGVmYXVsdExhbmd1YWdlXSk7XG4gIH1cblxufTtcbmZ1bmN0aW9uIGdldFN0YXJ0T2ZDb2RlSW5MaW5lKGFuY2hvciwgb2Zmc2V0KSB7XG4gIGxldCBsYXN0ID0gbnVsbDtcbiAgbGV0IGxhc3ROb25CbGFuayA9IG51bGw7XG4gIGxldCBub2RlID0gYW5jaG9yO1xuICBsZXQgbm9kZU9mZnNldCA9IG9mZnNldDtcbiAgbGV0IG5vZGVUZXh0Q29udGVudCA9IGFuY2hvci5nZXRUZXh0Q29udGVudCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZU9mZnNldCA9PT0gMCkge1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoISgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSB8fCBsZXhpY2FsLiRpc1RhYk5vZGUobm9kZSkgfHwgbGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYSB2YWxpZCBDb2RlIE5vZGU6IENvZGVIaWdobGlnaHROb2RlLCBUYWJOb2RlLCBMaW5lQnJlYWtOb2RlYCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUobm9kZSkpIHtcbiAgICAgICAgbGFzdCA9IHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIG9mZnNldDogMVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbm9kZU9mZnNldCA9IE1hdGgubWF4KDAsIG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgLSAxKTtcbiAgICAgIG5vZGVUZXh0Q29udGVudCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZU9mZnNldC0tO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYXJhY3RlciA9IG5vZGVUZXh0Q29udGVudFtub2RlT2Zmc2V0XTtcblxuICAgIGlmICgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSAmJiBjaGFyYWN0ZXIgIT09ICcgJykge1xuICAgICAgbGFzdE5vbkJsYW5rID0ge1xuICAgICAgICBub2RlLFxuICAgICAgICBvZmZzZXQ6IG5vZGVPZmZzZXRcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIGxhc3ROb25CbGFuayAhPT0gbnVsbDogYW5jaG9yIGluIHRoZSBtaWRkbGUgb2YgY29kZTsgbW92ZSB0byBsaW5lIGJlZ2lubmluZ1xuXG5cbiAgaWYgKGxhc3ROb25CbGFuayAhPT0gbnVsbCkge1xuICAgIHJldHVybiBsYXN0Tm9uQmxhbms7XG4gIH0gLy8gU3BhY2VzLCB0YWJzIG9yIG5vdGhpbmcgYWhlYWQgb2YgYW5jaG9yXG5cblxuICBsZXQgY29kZUNoYXJhY3RlckF0QW5jaG9yT2Zmc2V0ID0gbnVsbDtcblxuICBpZiAob2Zmc2V0IDwgYW5jaG9yLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKGFuY2hvcikpIHtcbiAgICAgIGNvZGVDaGFyYWN0ZXJBdEFuY2hvck9mZnNldCA9IGFuY2hvci5nZXRUZXh0Q29udGVudCgpW29mZnNldF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gYW5jaG9yLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICBjb2RlQ2hhcmFjdGVyQXRBbmNob3JPZmZzZXQgPSBuZXh0U2libGluZy5nZXRUZXh0Q29udGVudCgpWzBdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb2RlQ2hhcmFjdGVyQXRBbmNob3JPZmZzZXQgIT09IG51bGwgJiYgY29kZUNoYXJhY3RlckF0QW5jaG9yT2Zmc2V0ICE9PSAnICcpIHtcbiAgICAvLyBCb3JkZXJsaW5lIHdoaXRlc3BhY2UgYW5kIGNvZGUsIG1vdmUgdG8gbGluZSBiZWdpbm5pbmdcbiAgICByZXR1cm4gbGFzdDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBuZXh0Tm9uQmxhbmsgPSBmaW5kTmV4dE5vbkJsYW5rSW5MaW5lKGFuY2hvciwgb2Zmc2V0KTtcblxuICAgIGlmIChuZXh0Tm9uQmxhbmsgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXh0Tm9uQmxhbms7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsYXN0O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kTmV4dE5vbkJsYW5rSW5MaW5lKGFuY2hvciwgb2Zmc2V0KSB7XG4gIGxldCBub2RlID0gYW5jaG9yO1xuICBsZXQgbm9kZU9mZnNldCA9IG9mZnNldDtcbiAgbGV0IG5vZGVUZXh0Q29udGVudCA9IGFuY2hvci5nZXRUZXh0Q29udGVudCgpO1xuICBsZXQgbm9kZVRleHRDb250ZW50U2l6ZSA9IGFuY2hvci5nZXRUZXh0Q29udGVudFNpemUoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCEkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSB8fCBub2RlT2Zmc2V0ID09PSBub2RlVGV4dENvbnRlbnRTaXplKSB7XG4gICAgICBub2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuXG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCBsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSkge1xuICAgICAgICBub2RlT2Zmc2V0ID0gMDtcbiAgICAgICAgbm9kZVRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICBub2RlVGV4dENvbnRlbnRTaXplID0gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkpIHtcbiAgICAgIGlmIChub2RlVGV4dENvbnRlbnRbbm9kZU9mZnNldF0gIT09ICcgJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBub2RlT2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVPZmZzZXQrKztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RW5kT2ZDb2RlSW5MaW5lKGFuY2hvcikge1xuICBjb25zdCBsYXN0Tm9kZSA9IGdldExhc3RDb2RlTm9kZU9mTGluZShhbmNob3IpO1xuXG4gIGlmICghIWxleGljYWwuJGlzTGluZUJyZWFrTm9kZShsYXN0Tm9kZSkpIHtcbiAgICB0aHJvdyBFcnJvcihgVW5leHBlY3RlZCBsaW5lQnJlYWtOb2RlIGluIGdldEVuZE9mQ29kZUluTGluZWApO1xuICB9XG5cbiAgcmV0dXJuIGxhc3ROb2RlO1xufVxuXG5mdW5jdGlvbiB0ZXh0Tm9kZVRyYW5zZm9ybShub2RlLCBlZGl0b3IsIHRva2VuaXplcikge1xuICAvLyBTaW5jZSBDb2RlTm9kZSBoYXMgZmxhdCBjaGlsZHJlbiBzdHJ1Y3R1cmUgd2Ugb25seSBuZWVkIHRvIGNoZWNrXG4gIC8vIGlmIG5vZGUncyBwYXJlbnQgaXMgYSBjb2RlIG5vZGUgYW5kIHJ1biBoaWdobGlnaHRpbmcgaWYgc29cbiAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgaWYgKCRpc0NvZGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgY29kZU5vZGVUcmFuc2Zvcm0ocGFyZW50Tm9kZSwgZWRpdG9yLCB0b2tlbml6ZXIpO1xuICB9IGVsc2UgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpKSB7XG4gICAgLy8gV2hlbiBjb2RlIGJsb2NrIGNvbnZlcnRlZCBpbnRvIHBhcmFncmFwaCBvciBvdGhlciBlbGVtZW50XG4gICAgLy8gY29kZSBoaWdobGlnaHQgbm9kZXMgY29udmVydGVkIGJhY2sgdG8gbm9ybWFsIHRleHRcbiAgICBub2RlLnJlcGxhY2UobGV4aWNhbC4kY3JlYXRlVGV4dE5vZGUobm9kZS5fX3RleHQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb2RlR3V0dGVyKG5vZGUsIGVkaXRvcikge1xuICBjb25zdCBjb2RlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkobm9kZS5nZXRLZXkoKSk7XG5cbiAgaWYgKGNvZGVFbGVtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoOyAvLyBAdHMtaWdub3JlOiBpbnRlcm5hbCBmaWVsZFxuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gY29kZUVsZW1lbnQuX19jYWNoZWRDaGlsZHJlbkxlbmd0aCkge1xuICAgIC8vIEF2b2lkIHVwZGF0aW5nIHRoZSBhdHRyaWJ1dGUgaWYgdGhlIGNoaWxkcmVuIGxlbmd0aCBoYXNuJ3QgY2hhbmdlZC5cbiAgICByZXR1cm47XG4gIH0gLy8gQHRzLWlnbm9yZTo6IGludGVybmFsIGZpZWxkXG5cblxuICBjb2RlRWxlbWVudC5fX2NhY2hlZENoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gIGxldCBndXR0ZXIgPSAnMSc7XG4gIGxldCBjb3VudCA9IDE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShjaGlsZHJlbltpXSkpIHtcbiAgICAgIGd1dHRlciArPSAnXFxuJyArICsrY291bnQ7XG4gICAgfVxuICB9XG5cbiAgY29kZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWd1dHRlcicsIGd1dHRlcik7XG59IC8vIFVzaW5nIGBza2lwVHJhbnNmb3Jtc2AgdG8gcHJldmVudCBleHRyYSB0cmFuc2Zvcm1zIHNpbmNlIHJlZm9ybWF0dGluZyB0aGUgY29kZVxuLy8gd2lsbCBub3QgYWZmZWN0IGNvZGUgYmxvY2sgY29udGVudCBpdHNlbGYuXG4vL1xuLy8gVXNpbmcgZXh0cmEgY2FjaGUgKGBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZ2ApIHNpbmNlIGJvdGggQ29kZU5vZGUgYW5kIENvZGVIaWdobGlnaHROb2RlXG4vLyB0cmFuc2Zvcm1zIG1pZ2h0IGJlIGNhbGxlZCBhdCB0aGUgc2FtZSB0aW1lIChlLmcuIG5ldyBDb2RlSGlnaGxpZ2h0IG5vZGUgaW5zZXJ0ZWQpIGFuZFxuLy8gaW4gYm90aCBjYXNlcyB3ZSdsbCByZXJ1biB3aG9sZSByZWZvcm1hdHRpbmcgb3ZlciBDb2RlTm9kZSwgd2hpY2ggaXMgcmVkdW5kYW50LlxuLy8gRXNwZWNpYWxseSB3aGVuIHBhc3RpbmcgY29kZSBpbnRvIENvZGVCbG9jay5cblxuXG5jb25zdCBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZyA9IG5ldyBTZXQoKTtcblxuZnVuY3Rpb24gY29kZU5vZGVUcmFuc2Zvcm0obm9kZSwgZWRpdG9yLCB0b2tlbml6ZXIpIHtcbiAgY29uc3Qgbm9kZUtleSA9IG5vZGUuZ2V0S2V5KCk7XG5cbiAgaWYgKG5vZGVzQ3VycmVudGx5SGlnaGxpZ2h0aW5nLmhhcyhub2RlS2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG5vZGVzQ3VycmVudGx5SGlnaGxpZ2h0aW5nLmFkZChub2RlS2V5KTsgLy8gV2hlbiBuZXcgY29kZSBibG9jayBpbnNlcnRlZCBpdCBtaWdodCBub3QgaGF2ZSBsYW5ndWFnZSBzZWxlY3RlZFxuXG4gIGlmIChub2RlLmdldExhbmd1YWdlKCkgPT09IHVuZGVmaW5lZCkge1xuICAgIG5vZGUuc2V0TGFuZ3VhZ2UodG9rZW5pemVyLmRlZmF1bHRMYW5ndWFnZSk7XG4gIH0gLy8gVXNpbmcgbmVzdGVkIHVwZGF0ZSBjYWxsIHRvIHBhc3MgYHNraXBUcmFuc2Zvcm1zYCBzaW5jZSB3ZSBkb24ndCB3YW50XG4gIC8vIGVhY2ggaW5kaXZpZHVhbCBjb2RlaGlnaGxpZ2h0IG5vZGUgdG8gYmUgdHJhbnNmb3JtZWQgYWdhaW4gYXMgaXQncyBhbHJlYWR5XG4gIC8vIGluIGl0cyBmaW5hbCBzdGF0ZVxuXG5cbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgdXBkYXRlQW5kUmV0YWluU2VsZWN0aW9uKG5vZGVLZXksICgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gbGV4aWNhbC4kZ2V0Tm9kZUJ5S2V5KG5vZGVLZXkpO1xuXG4gICAgICBpZiAoISRpc0NvZGVOb2RlKGN1cnJlbnROb2RlKSB8fCAhY3VycmVudE5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29kZSA9IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZXIudG9rZW5pemUoY29kZSwgY3VycmVudE5vZGUuZ2V0TGFuZ3VhZ2UoKSB8fCB0b2tlbml6ZXIuZGVmYXVsdExhbmd1YWdlKTtcbiAgICAgIGNvbnN0IGhpZ2hsaWdodE5vZGVzID0gZ2V0SGlnaGxpZ2h0Tm9kZXModG9rZW5zKTtcbiAgICAgIGNvbnN0IGRpZmZSYW5nZSA9IGdldERpZmZSYW5nZShjdXJyZW50Tm9kZS5nZXRDaGlsZHJlbigpLCBoaWdobGlnaHROb2Rlcyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgICBub2Rlc0ZvclJlcGxhY2VtZW50XG4gICAgICB9ID0gZGlmZlJhbmdlO1xuXG4gICAgICBpZiAoZnJvbSAhPT0gdG8gfHwgbm9kZXNGb3JSZXBsYWNlbWVudC5sZW5ndGgpIHtcbiAgICAgICAgbm9kZS5zcGxpY2UoZnJvbSwgdG8gLSBmcm9tLCBub2Rlc0ZvclJlcGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfSwge1xuICAgIG9uVXBkYXRlOiAoKSA9PiB7XG4gICAgICBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZy5kZWxldGUobm9kZUtleSk7XG4gICAgfSxcbiAgICBza2lwVHJhbnNmb3JtczogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0Tm9kZXModG9rZW5zLCB0eXBlKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG5cbiAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgcGFydGlhbHMgPSB0b2tlbi5zcGxpdCgvKFxcbnxcXHQpLyk7XG4gICAgICBjb25zdCBwYXJ0aWFsc0xlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0aWFsc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0aWFsc1tpXTtcblxuICAgICAgICBpZiAocGFydCA9PT0gJ1xcbicgfHwgcGFydCA9PT0gJ1xcclxcbicpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKGxleGljYWwuJGNyZWF0ZUxpbmVCcmVha05vZGUoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKGxleGljYWwuJGNyZWF0ZVRhYk5vZGUoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlQ29kZUhpZ2hsaWdodE5vZGUocGFydCwgdHlwZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGVudFxuICAgICAgfSA9IHRva2VuO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5vZGVzLnB1c2goLi4uZ2V0SGlnaGxpZ2h0Tm9kZXMoW2NvbnRlbnRdLCB0b2tlbi50eXBlKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgICAgbm9kZXMucHVzaCguLi5nZXRIaWdobGlnaHROb2Rlcyhjb250ZW50LCB0b2tlbi50eXBlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGVzO1xufSAvLyBXcmFwcGluZyB1cGRhdGUgZnVuY3Rpb24gaW50byBzZWxlY3Rpb24gcmV0YWluZXIsIHRoYXQgdHJpZXMgdG8ga2VlcCBjdXJzb3IgYXQgdGhlIHNhbWVcbi8vIHBvc2l0aW9uIGFzIGJlZm9yZS5cblxuXG5mdW5jdGlvbiB1cGRhdGVBbmRSZXRhaW5TZWxlY3Rpb24obm9kZUtleSwgdXBkYXRlRm4pIHtcbiAgY29uc3Qgbm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleShub2RlS2V5KTtcblxuICBpZiAoISRpc0NvZGVOb2RlKG5vZGUpIHx8ICFub2RlLmlzQXR0YWNoZWQoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpOyAvLyBJZiBpdCdzIG5vdCByYW5nZSBzZWxlY3Rpb24gKG9yIG51bGwgc2VsZWN0aW9uKSB0aGVyZSdzIG5vIG5lZWQgdG8gY2hhbmdlIGl0LFxuICAvLyBidXQgd2UgY2FuIHN0aWxsIHJ1biBoaWdobGlnaHRpbmcgbG9naWNcblxuICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHVwZGF0ZUZuKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgaXNOZXdMaW5lQW5jaG9yID0gYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUobm9kZS5nZXRDaGlsZEF0SW5kZXgoYW5jaG9yLm9mZnNldCAtIDEpKTtcbiAgbGV0IHRleHRPZmZzZXQgPSAwOyAvLyBDYWxjdWxhdGluZyBwcmV2aW91cyB0ZXh0IG9mZnNldCAoYWxsIHRleHQgbm9kZSBwcmlvciB0byBhbmNob3IgKyBhbmNob3Igb3duIHRleHQgb2Zmc2V0KVxuXG4gIGlmICghaXNOZXdMaW5lQW5jaG9yKSB7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgdGV4dE9mZnNldCA9IGFuY2hvck9mZnNldCArIGFuY2hvck5vZGUuZ2V0UHJldmlvdXNTaWJsaW5ncygpLnJlZHVjZSgob2Zmc2V0LCBfbm9kZSkgPT4ge1xuICAgICAgcmV0dXJuIG9mZnNldCArIF9ub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgIH0sIDApO1xuICB9XG5cbiAgY29uc3QgaGFzQ2hhbmdlcyA9IHVwZGF0ZUZuKCk7XG5cbiAgaWYgKCFoYXNDaGFuZ2VzKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE5vbi10ZXh0IGFuY2hvcnMgb25seSBoYXBwZW4gZm9yIGxpbmUgYnJlYWtzLCBvdGhlcndpc2VcbiAgLy8gc2VsZWN0aW9uIHdpbGwgYmUgd2l0aGluIHRleHQgbm9kZSAoY29kZSBoaWdobGlnaHQgbm9kZSlcblxuXG4gIGlmIChpc05ld0xpbmVBbmNob3IpIHtcbiAgICBhbmNob3IuZ2V0Tm9kZSgpLnNlbGVjdChhbmNob3JPZmZzZXQsIGFuY2hvck9mZnNldCk7XG4gICAgcmV0dXJuO1xuICB9IC8vIElmIGl0IHdhcyBub24tZWxlbWVudCBhbmNob3IgdGhlbiB3ZSB3YWxrIHRocm91Z2ggY2hpbGQgbm9kZXNcbiAgLy8gYW5kIGxvb2tpbmcgZm9yIGEgcG9zaXRpb24gb2Ygb3JpZ2luYWwgdGV4dCBvZmZzZXRcblxuXG4gIG5vZGUuZ2V0Q2hpbGRyZW4oKS5zb21lKF9ub2RlID0+IHtcbiAgICBjb25zdCBpc1RleHQgPSBsZXhpY2FsLiRpc1RleHROb2RlKF9ub2RlKTtcblxuICAgIGlmIChpc1RleHQgfHwgbGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKF9ub2RlKSkge1xuICAgICAgY29uc3QgdGV4dENvbnRlbnRTaXplID0gX25vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG5cbiAgICAgIGlmIChpc1RleHQgJiYgdGV4dENvbnRlbnRTaXplID49IHRleHRPZmZzZXQpIHtcbiAgICAgICAgX25vZGUuc2VsZWN0KHRleHRPZmZzZXQsIHRleHRPZmZzZXQpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0ZXh0T2Zmc2V0IC09IHRleHRDb250ZW50U2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufSAvLyBGaW5kcyBtaW5pbWFsIGRpZmYgcmFuZ2UgYmV0d2VlbiB0d28gbm9kZXMgbGlzdHMuIEl0IHJldHVybnMgZnJvbS90byByYW5nZSBib3VuZGFyaWVzIG9mIHByZXZOb2Rlc1xuLy8gdGhhdCBuZWVkcyB0byBiZSByZXBsYWNlZCB3aXRoIGBub2Rlc2AgKHN1YnNldCBvZiBuZXh0Tm9kZXMpIHRvIG1ha2UgcHJldk5vZGVzIGVxdWFsIHRvIG5leHROb2Rlcy5cblxuXG5mdW5jdGlvbiBnZXREaWZmUmFuZ2UocHJldk5vZGVzLCBuZXh0Tm9kZXMpIHtcbiAgbGV0IGxlYWRpbmdNYXRjaCA9IDA7XG5cbiAgd2hpbGUgKGxlYWRpbmdNYXRjaCA8IHByZXZOb2Rlcy5sZW5ndGgpIHtcbiAgICBpZiAoIWlzRXF1YWwocHJldk5vZGVzW2xlYWRpbmdNYXRjaF0sIG5leHROb2Rlc1tsZWFkaW5nTWF0Y2hdKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbGVhZGluZ01hdGNoKys7XG4gIH1cblxuICBjb25zdCBwcmV2Tm9kZXNMZW5ndGggPSBwcmV2Tm9kZXMubGVuZ3RoO1xuICBjb25zdCBuZXh0Tm9kZXNMZW5ndGggPSBuZXh0Tm9kZXMubGVuZ3RoO1xuICBjb25zdCBtYXhUcmFpbGluZ01hdGNoID0gTWF0aC5taW4ocHJldk5vZGVzTGVuZ3RoLCBuZXh0Tm9kZXNMZW5ndGgpIC0gbGVhZGluZ01hdGNoO1xuICBsZXQgdHJhaWxpbmdNYXRjaCA9IDA7XG5cbiAgd2hpbGUgKHRyYWlsaW5nTWF0Y2ggPCBtYXhUcmFpbGluZ01hdGNoKSB7XG4gICAgdHJhaWxpbmdNYXRjaCsrO1xuXG4gICAgaWYgKCFpc0VxdWFsKHByZXZOb2Rlc1twcmV2Tm9kZXNMZW5ndGggLSB0cmFpbGluZ01hdGNoXSwgbmV4dE5vZGVzW25leHROb2Rlc0xlbmd0aCAtIHRyYWlsaW5nTWF0Y2hdKSkge1xuICAgICAgdHJhaWxpbmdNYXRjaC0tO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZnJvbSA9IGxlYWRpbmdNYXRjaDtcbiAgY29uc3QgdG8gPSBwcmV2Tm9kZXNMZW5ndGggLSB0cmFpbGluZ01hdGNoO1xuICBjb25zdCBub2Rlc0ZvclJlcGxhY2VtZW50ID0gbmV4dE5vZGVzLnNsaWNlKGxlYWRpbmdNYXRjaCwgbmV4dE5vZGVzTGVuZ3RoIC0gdHJhaWxpbmdNYXRjaCk7XG4gIHJldHVybiB7XG4gICAgZnJvbSxcbiAgICBub2Rlc0ZvclJlcGxhY2VtZW50LFxuICAgIHRvXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzRXF1YWwobm9kZUEsIG5vZGVCKSB7XG4gIC8vIE9ubHkgY2hlY2tpbmcgZm9yIGNvZGUgaGlnbGlnaHQgbm9kZXMsIHRhYnMgYW5kIGxpbmVicmVha3MuIElmIGl0J3MgcmVndWxhciB0ZXh0IG5vZGVcbiAgLy8gcmV0dXJuaW5nIGZhbHNlIHNvIHRoYXQgaXQncyB0cmFuc2Zvcm1lZCBpbnRvIGNvZGUgaGlnaGxpZ2h0IG5vZGVcbiAgcmV0dXJuICRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGVBKSAmJiAkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlQikgJiYgbm9kZUEuX190ZXh0ID09PSBub2RlQi5fX3RleHQgJiYgbm9kZUEuX19oaWdobGlnaHRUeXBlID09PSBub2RlQi5fX2hpZ2hsaWdodFR5cGUgfHwgbGV4aWNhbC4kaXNUYWJOb2RlKG5vZGVBKSAmJiBsZXhpY2FsLiRpc1RhYk5vZGUobm9kZUIpIHx8IGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShub2RlQSkgJiYgbGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGVCKTtcbn1cblxuZnVuY3Rpb24gJGlzU2VsZWN0aW9uSW5Db2RlKHNlbGVjdGlvbikge1xuICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcblxuICBpZiAoYW5jaG9yTm9kZS5pcyhmb2N1c05vZGUpICYmICRpc0NvZGVOb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBhbmNob3JQYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudCgpO1xuICByZXR1cm4gJGlzQ29kZU5vZGUoYW5jaG9yUGFyZW50KSAmJiBhbmNob3JQYXJlbnQuaXMoZm9jdXNOb2RlLmdldFBhcmVudCgpKTtcbn1cblxuZnVuY3Rpb24gJGdldENvZGVMaW5lcyhzZWxlY3Rpb24pIHtcbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3QgbGluZXMgPSBbW11dO1xuXG4gIGlmIChub2Rlcy5sZW5ndGggPT09IDEgJiYgJGlzQ29kZU5vZGUobm9kZXNbMF0pKSB7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgbGV0IGxhc3RMaW5lID0gbGluZXNbMF07XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmICghKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpIHx8IGxleGljYWwuJGlzVGFiTm9kZShub2RlKSB8fCBsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUobm9kZSkpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgc2VsZWN0aW9uIHRvIGJlIGluc2lkZSBDb2RlQmxvY2sgYW5kIGNvbnNpc3Rpbmcgb2YgQ29kZUhpZ2hsaWdodE5vZGUsIFRhYk5vZGUgYW5kIExpbmVCcmVha05vZGVgKTtcbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICBpZiAoaSAhPT0gMCAmJiBsYXN0TGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxhc3RMaW5lID0gW107XG4gICAgICAgIGxpbmVzLnB1c2gobGFzdExpbmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0TGluZS5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaW5lcztcbn1cblxuZnVuY3Rpb24gaGFuZGxlVGFiKHNoaWZ0S2V5KSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICEkaXNTZWxlY3Rpb25JbkNvZGUoc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgaW5kZW50T3JPdXRkZW50ID0gIXNoaWZ0S2V5ID8gbGV4aWNhbC5JTkRFTlRfQ09OVEVOVF9DT01NQU5EIDogbGV4aWNhbC5PVVRERU5UX0NPTlRFTlRfQ09NTUFORDtcbiAgY29uc3QgdGFiT3JPdXRkZW50ID0gIXNoaWZ0S2V5ID8gbGV4aWNhbC5JTlNFUlRfVEFCX0NPTU1BTkQgOiBsZXhpY2FsLk9VVERFTlRfQ09OVEVOVF9DT01NQU5EOyAvLyAxLiBJZiBtdWx0aXBsZSBsaW5lcyBzZWxlY3RlZDogaW5kZW50L291dGRlbnRcblxuICBjb25zdCBjb2RlTGluZXMgPSAkZ2V0Q29kZUxpbmVzKHNlbGVjdGlvbik7XG5cbiAgaWYgKGNvZGVMaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGluZGVudE9yT3V0ZGVudDtcbiAgfSAvLyAyLiBJZiBlbnRpcmUgbGluZSBzZWxlY3RlZDogaW5kZW50L291dGRlbnRcblxuXG4gIGNvbnN0IHNlbGVjdGlvbk5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGZpcnN0Tm9kZSA9IHNlbGVjdGlvbk5vZGVzWzBdO1xuXG4gIGlmICghKCRpc0NvZGVOb2RlKGZpcnN0Tm9kZSkgfHwgJGlzQ29kZUhpZ2hsaWdodE5vZGUoZmlyc3ROb2RlKSB8fCBsZXhpY2FsLiRpc1RhYk5vZGUoZmlyc3ROb2RlKSB8fCBsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUoZmlyc3ROb2RlKSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgc2VsZWN0aW9uIGZpcnN0Tm9kZSB0byBiZSBDb2RlSGlnaGxpZ2h0Tm9kZSBvciBUYWJOb2RlYCk7XG4gIH1cblxuICBpZiAoJGlzQ29kZU5vZGUoZmlyc3ROb2RlKSkge1xuICAgIHJldHVybiBpbmRlbnRPck91dGRlbnQ7XG4gIH1cblxuICBjb25zdCBmaXJzdE9mTGluZSA9IGdldEZpcnN0Q29kZU5vZGVPZkxpbmUoZmlyc3ROb2RlKTtcbiAgY29uc3QgbGFzdE9mTGluZSA9IGdldExhc3RDb2RlTm9kZU9mTGluZShmaXJzdE5vZGUpO1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgbGV0IHNlbGVjdGlvbkZpcnN0O1xuICBsZXQgc2VsZWN0aW9uTGFzdDtcblxuICBpZiAoZm9jdXMuaXNCZWZvcmUoYW5jaG9yKSkge1xuICAgIHNlbGVjdGlvbkZpcnN0ID0gZm9jdXM7XG4gICAgc2VsZWN0aW9uTGFzdCA9IGFuY2hvcjtcbiAgfSBlbHNlIHtcbiAgICBzZWxlY3Rpb25GaXJzdCA9IGFuY2hvcjtcbiAgICBzZWxlY3Rpb25MYXN0ID0gZm9jdXM7XG4gIH1cblxuICBpZiAoZmlyc3RPZkxpbmUgIT09IG51bGwgJiYgbGFzdE9mTGluZSAhPT0gbnVsbCAmJiBzZWxlY3Rpb25GaXJzdC5rZXkgPT09IGZpcnN0T2ZMaW5lLmdldEtleSgpICYmIHNlbGVjdGlvbkZpcnN0Lm9mZnNldCA9PT0gMCAmJiBzZWxlY3Rpb25MYXN0LmtleSA9PT0gbGFzdE9mTGluZS5nZXRLZXkoKSAmJiBzZWxlY3Rpb25MYXN0Lm9mZnNldCA9PT0gbGFzdE9mTGluZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgIHJldHVybiBpbmRlbnRPck91dGRlbnQ7XG4gIH0gLy8gMy4gRWxzZTogdGFiL291dGRlbnRcblxuXG4gIHJldHVybiB0YWJPck91dGRlbnQ7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU11bHRpbGluZUluZGVudCh0eXBlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICEkaXNTZWxlY3Rpb25JbkNvZGUoc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGNvZGVMaW5lcyA9ICRnZXRDb2RlTGluZXMoc2VsZWN0aW9uKTtcbiAgY29uc3QgY29kZUxpbmVzTGVuZ3RoID0gY29kZUxpbmVzLmxlbmd0aDsgLy8gTXVsdGlwbGUgbGluZXMgc2VsZWN0aW9uXG5cbiAgaWYgKGNvZGVMaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2RlTGluZXNMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZSA9IGNvZGVMaW5lc1tpXTtcblxuICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgZmlyc3RPZkxpbmUgPSBsaW5lWzBdOyAvLyBGaXJzdCBhbmQgbGFzdCBsaW5lcyBtaWdodCBub3QgYmUgY29tcGxldGVcblxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGZpcnN0T2ZMaW5lID0gZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZShmaXJzdE9mTGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlyc3RPZkxpbmUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gbGV4aWNhbC5JTkRFTlRfQ09OVEVOVF9DT01NQU5EKSB7XG4gICAgICAgICAgICBmaXJzdE9mTGluZS5pbnNlcnRCZWZvcmUobGV4aWNhbC4kY3JlYXRlVGFiTm9kZSgpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzVGFiTm9kZShmaXJzdE9mTGluZSkpIHtcbiAgICAgICAgICAgIGZpcnN0T2ZMaW5lLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEp1c3Qgb25lIGxpbmVcblxuXG4gIGNvbnN0IHNlbGVjdGlvbk5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGZpcnN0Tm9kZSA9IHNlbGVjdGlvbk5vZGVzWzBdO1xuXG4gIGlmICghKCRpc0NvZGVOb2RlKGZpcnN0Tm9kZSkgfHwgJGlzQ29kZUhpZ2hsaWdodE5vZGUoZmlyc3ROb2RlKSB8fCBsZXhpY2FsLiRpc1RhYk5vZGUoZmlyc3ROb2RlKSB8fCBsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUoZmlyc3ROb2RlKSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgc2VsZWN0aW9uIGZpcnN0Tm9kZSB0byBiZSBDb2RlSGlnaGxpZ2h0Tm9kZSBvciBDb2RlVGFiTm9kZWApO1xuICB9XG5cbiAgaWYgKCRpc0NvZGVOb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICAvLyBDb2RlTm9kZSBpcyBlbXB0eVxuICAgIGlmICh0eXBlID09PSBsZXhpY2FsLklOREVOVF9DT05URU5UX0NPTU1BTkQpIHtcbiAgICAgIHNlbGVjdGlvbi5pbnNlcnROb2RlcyhbbGV4aWNhbC4kY3JlYXRlVGFiTm9kZSgpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBmaXJzdE9mTGluZSA9IGdldEZpcnN0Q29kZU5vZGVPZkxpbmUoZmlyc3ROb2RlKTtcblxuICBpZiAoIShmaXJzdE9mTGluZSAhPT0gbnVsbCkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZSB0byByZXR1cm4gYSB2YWxpZCBDb2RlIE5vZGVgKTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSBsZXhpY2FsLklOREVOVF9DT05URU5UX0NPTU1BTkQpIHtcbiAgICBpZiAobGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKGZpcnN0T2ZMaW5lKSkge1xuICAgICAgZmlyc3RPZkxpbmUuaW5zZXJ0QWZ0ZXIobGV4aWNhbC4kY3JlYXRlVGFiTm9kZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3RPZkxpbmUuaW5zZXJ0QmVmb3JlKGxleGljYWwuJGNyZWF0ZVRhYk5vZGUoKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGxleGljYWwuJGlzVGFiTm9kZShmaXJzdE9mTGluZSkpIHtcbiAgICBmaXJzdE9mTGluZS5yZW1vdmUoKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTaGlmdExpbmVzKHR5cGUsIGV2ZW50KSB7XG4gIC8vIFdlIG9ubHkgY2FyZSBhYm91dCB0aGUgYWx0K2Fycm93IGtleXNcbiAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSSdtIG5vdCBxdWl0ZSBzdXJlIHdoeSwgYnV0IGl0IHNlZW1zIGxpa2UgY2FsbGluZyBhbmNob3IuZ2V0Tm9kZSgpIGNvbGxhcHNlcyB0aGUgc2VsZWN0aW9uIGhlcmVcbiAgLy8gU28gZmlyc3QsIGdldCB0aGUgYW5jaG9yIGFuZCB0aGUgZm9jdXMsIHRoZW4gZ2V0IHRoZWlyIG5vZGVzXG5cblxuICBjb25zdCB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH0gPSBzZWxlY3Rpb247XG4gIGNvbnN0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICBjb25zdCBhcnJvd0lzVXAgPSB0eXBlID09PSBsZXhpY2FsLktFWV9BUlJPV19VUF9DT01NQU5EOyAvLyBFbnN1cmUgdGhlIHNlbGVjdGlvbiBpcyB3aXRoaW4gdGhlIGNvZGVibG9ja1xuXG4gIGlmICghJGlzU2VsZWN0aW9uSW5Db2RlKHNlbGVjdGlvbikgfHwgISgkaXNDb2RlSGlnaGxpZ2h0Tm9kZShhbmNob3JOb2RlKSB8fCBsZXhpY2FsLiRpc1RhYk5vZGUoYW5jaG9yTm9kZSkpIHx8ICEoJGlzQ29kZUhpZ2hsaWdodE5vZGUoZm9jdXNOb2RlKSB8fCBsZXhpY2FsLiRpc1RhYk5vZGUoZm9jdXNOb2RlKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWV2ZW50LmFsdEtleSkge1xuICAgIC8vIEhhbmRsZSBtb3Zpbmcgc2VsZWN0aW9uIG91dCBvZiB0aGUgY29kZSBibG9jaywgZ2l2ZW4gdGhlcmUgYXJlIG5vXG4gICAgLy8gc2libGluZyB0aGF0cyBjYW4gbmF0aXZlbHkgdGFrZSB0aGUgc2VsZWN0aW9uLlxuICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgY29uc3QgY29kZU5vZGUgPSBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgICAgaWYgKGFycm93SXNVcCAmJiBhbmNob3JPZmZzZXQgPT09IDAgJiYgYW5jaG9yTm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjb2RlTm9kZVNpYmxpbmcgPSBjb2RlTm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgICAgICBpZiAoY29kZU5vZGVTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgY29kZU5vZGUuc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFhcnJvd0lzVXAgJiYgYW5jaG9yT2Zmc2V0ID09PSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpICYmIGFuY2hvck5vZGUuZ2V0TmV4dFNpYmxpbmcoKSA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjb2RlTm9kZVNpYmxpbmcgPSBjb2RlTm9kZS5nZXROZXh0U2libGluZygpO1xuXG4gICAgICAgIGlmIChjb2RlTm9kZVNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICBjb2RlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxldCBzdGFydDtcbiAgbGV0IGVuZDtcblxuICBpZiAoYW5jaG9yTm9kZS5pc0JlZm9yZShmb2N1c05vZGUpKSB7XG4gICAgc3RhcnQgPSBnZXRGaXJzdENvZGVOb2RlT2ZMaW5lKGFuY2hvck5vZGUpO1xuICAgIGVuZCA9IGdldExhc3RDb2RlTm9kZU9mTGluZShmb2N1c05vZGUpO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZShmb2N1c05vZGUpO1xuICAgIGVuZCA9IGdldExhc3RDb2RlTm9kZU9mTGluZShhbmNob3JOb2RlKTtcbiAgfVxuXG4gIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcmFuZ2UgPSBzdGFydC5nZXROb2Rlc0JldHdlZW4oZW5kKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IHJhbmdlW2ldO1xuXG4gICAgaWYgKCEkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSAmJiAhbGV4aWNhbC4kaXNUYWJOb2RlKG5vZGUpICYmICFsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gQWZ0ZXIgdGhpcyBwb2ludCwgd2Uga25vdyB0aGUgc2VsZWN0aW9uIGlzIHdpdGhpbiB0aGUgY29kZWJsb2NrLiBXZSBtYXkgbm90IGJlIGFibGUgdG9cbiAgLy8gYWN0dWFsbHkgbW92ZSB0aGUgbGluZXMgYXJvdW5kLCBidXQgd2Ugd2FudCB0byByZXR1cm4gdHJ1ZSBlaXRoZXIgd2F5IHRvIHByZXZlbnRcbiAgLy8gdGhlIGV2ZW50J3MgZGVmYXVsdCBiZWhhdmlvclxuXG5cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIHJlcXVpcmVkIHRvIHN0b3AgY3Vyc29yIG1vdmVtZW50IHVuZGVyIEZpcmVmb3hcblxuICBjb25zdCBsaW5lYnJlYWsgPSBhcnJvd0lzVXAgPyBzdGFydC5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IGVuZC5nZXROZXh0U2libGluZygpO1xuXG4gIGlmICghbGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKGxpbmVicmVhaykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IHNpYmxpbmcgPSBhcnJvd0lzVXAgPyBsaW5lYnJlYWsuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBsaW5lYnJlYWsuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICBpZiAoc2libGluZyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBtYXliZUluc2VydGlvblBvaW50ID0gJGlzQ29kZUhpZ2hsaWdodE5vZGUoc2libGluZykgfHwgbGV4aWNhbC4kaXNUYWJOb2RlKHNpYmxpbmcpIHx8IGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShzaWJsaW5nKSA/IGFycm93SXNVcCA/IGdldEZpcnN0Q29kZU5vZGVPZkxpbmUoc2libGluZykgOiBnZXRMYXN0Q29kZU5vZGVPZkxpbmUoc2libGluZykgOiBudWxsO1xuICBsZXQgaW5zZXJ0aW9uUG9pbnQgPSBtYXliZUluc2VydGlvblBvaW50ICE9IG51bGwgPyBtYXliZUluc2VydGlvblBvaW50IDogc2libGluZztcbiAgbGluZWJyZWFrLnJlbW92ZSgpO1xuICByYW5nZS5mb3JFYWNoKG5vZGUgPT4gbm9kZS5yZW1vdmUoKSk7XG5cbiAgaWYgKHR5cGUgPT09IGxleGljYWwuS0VZX0FSUk9XX1VQX0NPTU1BTkQpIHtcbiAgICByYW5nZS5mb3JFYWNoKG5vZGUgPT4gaW5zZXJ0aW9uUG9pbnQuaW5zZXJ0QmVmb3JlKG5vZGUpKTtcbiAgICBpbnNlcnRpb25Qb2ludC5pbnNlcnRCZWZvcmUobGluZWJyZWFrKTtcbiAgfSBlbHNlIHtcbiAgICBpbnNlcnRpb25Qb2ludC5pbnNlcnRBZnRlcihsaW5lYnJlYWspO1xuICAgIGluc2VydGlvblBvaW50ID0gbGluZWJyZWFrO1xuICAgIHJhbmdlLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBpbnNlcnRpb25Qb2ludC5pbnNlcnRBZnRlcihub2RlKTtcbiAgICAgIGluc2VydGlvblBvaW50ID0gbm9kZTtcbiAgICB9KTtcbiAgfVxuXG4gIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNb3ZlVG8odHlwZSwgZXZlbnQpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH0gPSBzZWxlY3Rpb247XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IGlzTW92ZVRvU3RhcnQgPSB0eXBlID09PSBsZXhpY2FsLk1PVkVfVE9fU1RBUlQ7XG5cbiAgaWYgKCEoJGlzQ29kZUhpZ2hsaWdodE5vZGUoYW5jaG9yTm9kZSkgfHwgbGV4aWNhbC4kaXNUYWJOb2RlKGFuY2hvck5vZGUpKSB8fCAhKCRpc0NvZGVIaWdobGlnaHROb2RlKGZvY3VzTm9kZSkgfHwgbGV4aWNhbC4kaXNUYWJOb2RlKGZvY3VzTm9kZSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzTW92ZVRvU3RhcnQpIHtcbiAgICBjb25zdCBzdGFydCA9IGdldFN0YXJ0T2ZDb2RlSW5MaW5lKGZvY3VzTm9kZSwgZm9jdXMub2Zmc2V0KTtcblxuICAgIGlmIChzdGFydCAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBub2RlLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBzdGFydDtcblxuICAgICAgaWYgKGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShub2RlKSkge1xuICAgICAgICBub2RlLnNlbGVjdE5leHQoMCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3Rpb24uc2V0VGV4dE5vZGVSYW5nZShub2RlLCBvZmZzZXQsIG5vZGUsIG9mZnNldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvY3VzTm9kZS5nZXRQYXJlbnRPclRocm93KCkuc2VsZWN0U3RhcnQoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgbm9kZSA9IGdldEVuZE9mQ29kZUluTGluZShmb2N1c05vZGUpO1xuICAgIG5vZGUuc2VsZWN0KCk7XG4gIH1cblxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29kZUhpZ2hsaWdodGluZyhlZGl0b3IsIHRva2VuaXplcikge1xuICBpZiAoIWVkaXRvci5oYXNOb2RlcyhbQ29kZU5vZGUsIENvZGVIaWdobGlnaHROb2RlXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVIaWdobGlnaHRQbHVnaW46IENvZGVOb2RlIG9yIENvZGVIaWdobGlnaHROb2RlIG5vdCByZWdpc3RlcmVkIG9uIGVkaXRvcicpO1xuICB9XG5cbiAgaWYgKHRva2VuaXplciA9PSBudWxsKSB7XG4gICAgdG9rZW5pemVyID0gUHJpc21Ub2tlbml6ZXI7XG4gIH1cblxuICByZXR1cm4gdXRpbHMubWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJNdXRhdGlvbkxpc3RlbmVyKENvZGVOb2RlLCBtdXRhdGlvbnMgPT4ge1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB0eXBlXSBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGUgIT09ICdkZXN0cm95ZWQnKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleShrZXkpO1xuXG4gICAgICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNvZGVHdXR0ZXIobm9kZSwgZWRpdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oQ29kZU5vZGUsIG5vZGUgPT4gY29kZU5vZGVUcmFuc2Zvcm0obm9kZSwgZWRpdG9yLCB0b2tlbml6ZXIpKSwgZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShsZXhpY2FsLlRleHROb2RlLCBub2RlID0+IHRleHROb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oQ29kZUhpZ2hsaWdodE5vZGUsIG5vZGUgPT4gdGV4dE5vZGVUcmFuc2Zvcm0obm9kZSwgZWRpdG9yLCB0b2tlbml6ZXIpKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9UQUJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IGNvbW1hbmQgPSBoYW5kbGVUYWIoZXZlbnQuc2hpZnRLZXkpO1xuXG4gICAgaWYgKGNvbW1hbmQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoY29tbWFuZCwgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5JTlNFUlRfVEFCX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghJGlzU2VsZWN0aW9uSW5Db2RlKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXhpY2FsLiRpbnNlcnROb2RlcyhbbGV4aWNhbC4kY3JlYXRlVGFiTm9kZSgpXSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuSU5ERU5UX0NPTlRFTlRfQ09NTUFORCwgcGF5bG9hZCA9PiBoYW5kbGVNdWx0aWxpbmVJbmRlbnQobGV4aWNhbC5JTkRFTlRfQ09OVEVOVF9DT01NQU5EKSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5PVVRERU5UX0NPTlRFTlRfQ09NTUFORCwgcGF5bG9hZCA9PiBoYW5kbGVNdWx0aWxpbmVJbmRlbnQobGV4aWNhbC5PVVRERU5UX0NPTlRFTlRfQ09NTUFORCksIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0FSUk9XX1VQX0NPTU1BTkQsIHBheWxvYWQgPT4gaGFuZGxlU2hpZnRMaW5lcyhsZXhpY2FsLktFWV9BUlJPV19VUF9DT01NQU5ELCBwYXlsb2FkKSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQVJST1dfRE9XTl9DT01NQU5ELCBwYXlsb2FkID0+IGhhbmRsZVNoaWZ0TGluZXMobGV4aWNhbC5LRVlfQVJST1dfRE9XTl9DT01NQU5ELCBwYXlsb2FkKSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5NT1ZFX1RPX0VORCwgcGF5bG9hZCA9PiBoYW5kbGVNb3ZlVG8obGV4aWNhbC5NT1ZFX1RPX0VORCwgcGF5bG9hZCksIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuTU9WRV9UT19TVEFSVCwgcGF5bG9hZCA9PiBoYW5kbGVNb3ZlVG8obGV4aWNhbC5NT1ZFX1RPX1NUQVJULCBwYXlsb2FkKSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVykpO1xufVxuXG5leHBvcnRzLiRjcmVhdGVDb2RlSGlnaGxpZ2h0Tm9kZSA9ICRjcmVhdGVDb2RlSGlnaGxpZ2h0Tm9kZTtcbmV4cG9ydHMuJGNyZWF0ZUNvZGVOb2RlID0gJGNyZWF0ZUNvZGVOb2RlO1xuZXhwb3J0cy4kaXNDb2RlSGlnaGxpZ2h0Tm9kZSA9ICRpc0NvZGVIaWdobGlnaHROb2RlO1xuZXhwb3J0cy4kaXNDb2RlTm9kZSA9ICRpc0NvZGVOb2RlO1xuZXhwb3J0cy5DT0RFX0xBTkdVQUdFX0ZSSUVORExZX05BTUVfTUFQID0gQ09ERV9MQU5HVUFHRV9GUklFTkRMWV9OQU1FX01BUDtcbmV4cG9ydHMuQ09ERV9MQU5HVUFHRV9NQVAgPSBDT0RFX0xBTkdVQUdFX01BUDtcbmV4cG9ydHMuQ29kZUhpZ2hsaWdodE5vZGUgPSBDb2RlSGlnaGxpZ2h0Tm9kZTtcbmV4cG9ydHMuQ29kZU5vZGUgPSBDb2RlTm9kZTtcbmV4cG9ydHMuREVGQVVMVF9DT0RFX0xBTkdVQUdFID0gREVGQVVMVF9DT0RFX0xBTkdVQUdFO1xuZXhwb3J0cy5QcmlzbVRva2VuaXplciA9IFByaXNtVG9rZW5pemVyO1xuZXhwb3J0cy5nZXRDb2RlTGFuZ3VhZ2VzID0gZ2V0Q29kZUxhbmd1YWdlcztcbmV4cG9ydHMuZ2V0RGVmYXVsdENvZGVMYW5ndWFnZSA9IGdldERlZmF1bHRDb2RlTGFuZ3VhZ2U7XG5leHBvcnRzLmdldEVuZE9mQ29kZUluTGluZSA9IGdldEVuZE9mQ29kZUluTGluZTtcbmV4cG9ydHMuZ2V0Rmlyc3RDb2RlTm9kZU9mTGluZSA9IGdldEZpcnN0Q29kZU5vZGVPZkxpbmU7XG5leHBvcnRzLmdldExhbmd1YWdlRnJpZW5kbHlOYW1lID0gZ2V0TGFuZ3VhZ2VGcmllbmRseU5hbWU7XG5leHBvcnRzLmdldExhc3RDb2RlTm9kZU9mTGluZSA9IGdldExhc3RDb2RlTm9kZU9mTGluZTtcbmV4cG9ydHMuZ2V0U3RhcnRPZkNvZGVJbkxpbmUgPSBnZXRTdGFydE9mQ29kZUluTGluZTtcbmV4cG9ydHMubm9ybWFsaXplQ29kZUxhbmcgPSBub3JtYWxpemVDb2RlTGFuZztcbmV4cG9ydHMucmVnaXN0ZXJDb2RlSGlnaGxpZ2h0aW5nID0gcmVnaXN0ZXJDb2RlSGlnaGxpZ2h0aW5nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/code/LexicalCode.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/code/LexicalCode.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/code/LexicalCode.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalCode =  true ? __webpack_require__(/*! ./LexicalCode.dev.js */ \"(ssr)/./node_modules/@lexical/code/LexicalCode.dev.js\") : 0\nmodule.exports = LexicalCode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY29kZS9MZXhpY2FsQ29kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLG9CQUFvQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsbUZBQXNCLElBQUksQ0FBZ0M7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jb2RlL0xleGljYWxDb2RlLmpzP2ZiZDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxDb2RlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxDb2RlLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsQ29kZS5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbENvZGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/code/LexicalCode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lexical/dragon/LexicalDragon.dev.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/dragon */\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n\n    const rootElement = editor.getRootElement();\n\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n\n    const data = event.data;\n\n    if (typeof data === 'string') {\n      let parsedData;\n\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args; // TODO: we should probably handle formatCommand somehow?\n            editor.update(() => {\n              const selection = lexical.$getSelection();\n\n              if (lexical.$isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength; // If the offset is more than the end, make it the end\n\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize(); // If the offset is more than the end, make it the end\n\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                } // block the chrome extension from handling this event\n\n\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\nexports.registerDragonSupport = registerDragonSupport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZHJhZ29uL0xleGljYWxEcmFnb24uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyx3REFBUzs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7O0FBR2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2RyYWdvbi9MZXhpY2FsRHJhZ29uLmRldi5qcz9hZTlkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcblxuLyoqIEBtb2R1bGUgQGxleGljYWwvZHJhZ29uICovXG5mdW5jdGlvbiByZWdpc3RlckRyYWdvblN1cHBvcnQoZWRpdG9yKSB7XG4gIGNvbnN0IG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG5cbiAgY29uc3QgaGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICBpZiAoZXZlbnQub3JpZ2luICE9PSBvcmlnaW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuXG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHJvb3RFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgcGFyc2VkRGF0YTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcnNlZERhdGEgJiYgcGFyc2VkRGF0YS5wcm90b2NvbCA9PT0gJ251YW5yaWFfbWVzc2FnaW5nJyAmJiBwYXJzZWREYXRhLnR5cGUgPT09ICdyZXF1ZXN0Jykge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gcGFyc2VkRGF0YS5wYXlsb2FkO1xuXG4gICAgICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuZnVuY3Rpb25JZCA9PT0gJ21ha2VDaGFuZ2VzJykge1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBwYXlsb2FkLmFyZ3M7XG5cbiAgICAgICAgICBpZiAoYXJncykge1xuICAgICAgICAgICAgY29uc3QgW2VsZW1lbnRTdGFydCwgZWxlbWVudExlbmd0aCwgdGV4dCwgc2VsU3RhcnQsIHNlbExlbmd0aCwgZm9ybWF0Q29tbWFuZF0gPSBhcmdzOyAvLyBUT0RPOiB3ZSBzaG91bGQgcHJvYmFibHkgaGFuZGxlIGZvcm1hdENvbW1hbmQgc29tZWhvdz9cbiAgICAgICAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgICAgICAgICBsZXQgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgbGV0IHNldFNlbFN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgc2V0U2VsRW5kID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzZXQgaW5pdGlhbCBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50U3RhcnQgPj0gMCAmJiBlbGVtZW50TGVuZ3RoID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VsU3RhcnQgPSBlbGVtZW50U3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHNldFNlbEVuZCA9IGVsZW1lbnRTdGFydCArIGVsZW1lbnRMZW5ndGg7IC8vIElmIHRoZSBvZmZzZXQgaXMgbW9yZSB0aGFuIHRoZSBlbmQsIG1ha2UgaXQgdGhlIGVuZFxuXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKGFuY2hvck5vZGUsIHNldFNlbFN0YXJ0LCBhbmNob3JOb2RlLCBzZXRTZWxFbmQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZXRTZWxTdGFydCAhPT0gc2V0U2VsRW5kIHx8IHRleHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dCh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzZXQgZmluYWwgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICBzZXRTZWxTdGFydCA9IHNlbFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgc2V0U2VsRW5kID0gc2VsU3RhcnQgKyBzZWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhbmNob3JOb2RlVGV4dExlbmd0aCA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7IC8vIElmIHRoZSBvZmZzZXQgaXMgbW9yZSB0aGFuIHRoZSBlbmQsIG1ha2UgaXQgdGhlIGVuZFxuXG4gICAgICAgICAgICAgICAgICBzZXRTZWxTdGFydCA9IHNldFNlbFN0YXJ0ID4gYW5jaG9yTm9kZVRleHRMZW5ndGggPyBhbmNob3JOb2RlVGV4dExlbmd0aCA6IHNldFNlbFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgc2V0U2VsRW5kID0gc2V0U2VsRW5kID4gYW5jaG9yTm9kZVRleHRMZW5ndGggPyBhbmNob3JOb2RlVGV4dExlbmd0aCA6IHNldFNlbEVuZDtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKGFuY2hvck5vZGUsIHNldFNlbFN0YXJ0LCBhbmNob3JOb2RlLCBzZXRTZWxFbmQpO1xuICAgICAgICAgICAgICAgIH0gLy8gYmxvY2sgdGhlIGNocm9tZSBleHRlbnNpb24gZnJvbSBoYW5kbGluZyB0aGlzIGV2ZW50XG5cblxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZXIsIHRydWUpO1xuICB9O1xufVxuXG5leHBvcnRzLnJlZ2lzdGVyRHJhZ29uU3VwcG9ydCA9IHJlZ2lzdGVyRHJhZ29uU3VwcG9ydDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/dragon/LexicalDragon.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/dragon/LexicalDragon.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalDragon =  true ? __webpack_require__(/*! ./LexicalDragon.dev.js */ \"(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.js\") : 0\nmodule.exports = LexicalDragon;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZHJhZ29uL0xleGljYWxEcmFnb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWixzQkFBc0IsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLHlGQUF3QixJQUFJLENBQWtDO0FBQ3JJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZHJhZ29uL0xleGljYWxEcmFnb24uanM/OTAxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbERyYWdvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsRHJhZ29uLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsRHJhZ29uLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsRHJhZ29uOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/dragon/LexicalDragon.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/history/LexicalHistory.dev.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/history */\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\n\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n\n    if (dirtyElement !== undefined && !lexical.$isRootNode(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n\n  return nodes;\n}\n\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n\n  if (!lexical.$isRangeSelection(nextSelection) || !lexical.$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  } // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n\n\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && lexical.$isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n\n    return OTHER;\n  }\n\n  const nextDirtyNode = dirtyNodes[0];\n\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n\n  if (!lexical.$isTextNode(prevDirtyNode) || !lexical.$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n\n  if (prevText === nextText) {\n    return OTHER;\n  }\n\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n\n  return OTHER;\n}\n\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n\n  const nextNode = nextEditorState._nodeMap.get(key);\n\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  let isDeletingLine = false;\n\n  if (lexical.$isRangeSelection(prevSelection) && lexical.$isRangeSelection(nextSelection)) {\n    isDeletingLine = prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  }\n\n  if (!isDeletingLine && lexical.$isTextNode(prevNode) && lexical.$isTextNode(nextNode)) {\n    return prevNode.__type === nextNode.__type && prevNode.__text === nextNode.__text && prevNode.__mode === nextNode.__mode && prevNode.__detail === nextNode.__detail && prevNode.__style === nextNode.__style && prevNode.__format === nextNode.__format && prevNode.__parent === nextNode.__parent;\n  }\n\n  return false;\n}\n\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now(); // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\n\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      } // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n\n\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n\n      return HISTORY_PUSH;\n    })();\n\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\n\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\n    }\n\n    const historyStateEntry = redoStack.pop();\n\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n    }\n\n    historyState.current = historyStateEntry || null;\n\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\n\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, true);\n    }\n\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\n    }\n\n    historyState.current = historyStateEntry || null;\n\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\n\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\n\n\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n      }\n\n      if (current !== null) {\n        undoStack.push({ ...current\n        });\n        editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    } // Else we merge\n\n\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n\n  const unregisterCommandListener = utils.mergeRegister(editor.registerCommand(lexical.UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  const unregisterUpdateListener = editor.registerUpdateListener(applyChange);\n  return () => {\n    unregisterCommandListener();\n    unregisterUpdateListener();\n  };\n}\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\n\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\nexports.createEmptyHistoryState = createEmptyHistoryState;\nexports.registerHistory = registerHistory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaGlzdG9yeS9MZXhpY2FsSGlzdG9yeS5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNwQyxjQUFjLG1CQUFPLENBQUMsd0RBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2hpc3RvcnkvTGV4aWNhbEhpc3RvcnkuZGV2LmpzPzNlZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcblxuLyoqIEBtb2R1bGUgQGxleGljYWwvaGlzdG9yeSAqL1xuY29uc3QgSElTVE9SWV9NRVJHRSA9IDA7XG5jb25zdCBISVNUT1JZX1BVU0ggPSAxO1xuY29uc3QgRElTQ0FSRF9ISVNUT1JZX0NBTkRJREFURSA9IDI7XG5jb25zdCBPVEhFUiA9IDA7XG5jb25zdCBDT01QT1NJTkdfQ0hBUkFDVEVSID0gMTtcbmNvbnN0IElOU0VSVF9DSEFSQUNURVJfQUZURVJfU0VMRUNUSU9OID0gMjtcbmNvbnN0IERFTEVURV9DSEFSQUNURVJfQkVGT1JFX1NFTEVDVElPTiA9IDM7XG5jb25zdCBERUxFVEVfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTiA9IDQ7XG5cbmZ1bmN0aW9uIGdldERpcnR5Tm9kZXMoZWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzLCBkaXJ0eUVsZW1lbnRzKSB7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcblxuICBmb3IgKGNvbnN0IGRpcnR5TGVhZktleSBvZiBkaXJ0eUxlYXZlcykge1xuICAgIGNvbnN0IGRpcnR5TGVhZiA9IG5vZGVNYXAuZ2V0KGRpcnR5TGVhZktleSk7XG5cbiAgICBpZiAoZGlydHlMZWFmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5vZGVzLnB1c2goZGlydHlMZWFmKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IFtkaXJ0eUVsZW1lbnRLZXksIGludGVudGlvbmFsbHlNYXJrZWRBc0RpcnR5XSBvZiBkaXJ0eUVsZW1lbnRzKSB7XG4gICAgaWYgKCFpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgZGlydHlFbGVtZW50ID0gbm9kZU1hcC5nZXQoZGlydHlFbGVtZW50S2V5KTtcblxuICAgIGlmIChkaXJ0eUVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJiAhbGV4aWNhbC4kaXNSb290Tm9kZShkaXJ0eUVsZW1lbnQpKSB7XG4gICAgICBub2Rlcy5wdXNoKGRpcnR5RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFuZ2VUeXBlKHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlLCBkaXJ0eUxlYXZlc1NldCwgZGlydHlFbGVtZW50c1NldCwgaXNDb21wb3NpbmcpIHtcbiAgaWYgKHByZXZFZGl0b3JTdGF0ZSA9PT0gbnVsbCB8fCBkaXJ0eUxlYXZlc1NldC5zaXplID09PSAwICYmIGRpcnR5RWxlbWVudHNTZXQuc2l6ZSA9PT0gMCAmJiAhaXNDb21wb3NpbmcpIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cblxuICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBwcmV2RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcblxuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICByZXR1cm4gQ09NUE9TSU5HX0NIQVJBQ1RFUjtcbiAgfVxuXG4gIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSB8fCAhbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSB8fCAhcHJldlNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8ICFuZXh0U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cblxuICBjb25zdCBkaXJ0eU5vZGVzID0gZ2V0RGlydHlOb2RlcyhuZXh0RWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzU2V0LCBkaXJ0eUVsZW1lbnRzU2V0KTtcblxuICBpZiAoZGlydHlOb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH0gLy8gQ2F0Y2hpbmcgdGhlIGNhc2Ugd2hlbiBpbnNlcnRpbmcgbmV3IHRleHQgbm9kZSBpbnRvIGFuIGVsZW1lbnQgKGUuZy4gZmlyc3QgY2hhciBpbiBwYXJhZ3JhcGgvbGlzdCksXG4gIC8vIG9yIGFmdGVyIGV4aXN0aW5nIG5vZGUuXG5cblxuICBpZiAoZGlydHlOb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgbmV4dE5vZGVNYXAgPSBuZXh0RWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gICAgY29uc3QgbmV4dEFuY2hvck5vZGUgPSBuZXh0Tm9kZU1hcC5nZXQobmV4dFNlbGVjdGlvbi5hbmNob3Iua2V5KTtcbiAgICBjb25zdCBwcmV2QW5jaG9yTm9kZSA9IG5leHROb2RlTWFwLmdldChwcmV2U2VsZWN0aW9uLmFuY2hvci5rZXkpO1xuXG4gICAgaWYgKG5leHRBbmNob3JOb2RlICYmIHByZXZBbmNob3JOb2RlICYmICFwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXAuaGFzKG5leHRBbmNob3JOb2RlLl9fa2V5KSAmJiBsZXhpY2FsLiRpc1RleHROb2RlKG5leHRBbmNob3JOb2RlKSAmJiBuZXh0QW5jaG9yTm9kZS5fX3RleHQubGVuZ3RoID09PSAxICYmIG5leHRTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMSkge1xuICAgICAgcmV0dXJuIElOU0VSVF9DSEFSQUNURVJfQUZURVJfU0VMRUNUSU9OO1xuICAgIH1cblxuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuXG4gIGNvbnN0IG5leHREaXJ0eU5vZGUgPSBkaXJ0eU5vZGVzWzBdO1xuXG4gIGNvbnN0IHByZXZEaXJ0eU5vZGUgPSBwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KG5leHREaXJ0eU5vZGUuX19rZXkpO1xuXG4gIGlmICghbGV4aWNhbC4kaXNUZXh0Tm9kZShwcmV2RGlydHlOb2RlKSB8fCAhbGV4aWNhbC4kaXNUZXh0Tm9kZShuZXh0RGlydHlOb2RlKSB8fCBwcmV2RGlydHlOb2RlLl9fbW9kZSAhPT0gbmV4dERpcnR5Tm9kZS5fX21vZGUpIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cblxuICBjb25zdCBwcmV2VGV4dCA9IHByZXZEaXJ0eU5vZGUuX190ZXh0O1xuICBjb25zdCBuZXh0VGV4dCA9IG5leHREaXJ0eU5vZGUuX190ZXh0O1xuXG4gIGlmIChwcmV2VGV4dCA9PT0gbmV4dFRleHQpIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cblxuICBjb25zdCBuZXh0QW5jaG9yID0gbmV4dFNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IHByZXZBbmNob3IgPSBwcmV2U2VsZWN0aW9uLmFuY2hvcjtcblxuICBpZiAobmV4dEFuY2hvci5rZXkgIT09IHByZXZBbmNob3Iua2V5IHx8IG5leHRBbmNob3IudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG5cbiAgY29uc3QgbmV4dEFuY2hvck9mZnNldCA9IG5leHRBbmNob3Iub2Zmc2V0O1xuICBjb25zdCBwcmV2QW5jaG9yT2Zmc2V0ID0gcHJldkFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IHRleHREaWZmID0gbmV4dFRleHQubGVuZ3RoIC0gcHJldlRleHQubGVuZ3RoO1xuXG4gIGlmICh0ZXh0RGlmZiA9PT0gMSAmJiBwcmV2QW5jaG9yT2Zmc2V0ID09PSBuZXh0QW5jaG9yT2Zmc2V0IC0gMSkge1xuICAgIHJldHVybiBJTlNFUlRfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTjtcbiAgfVxuXG4gIGlmICh0ZXh0RGlmZiA9PT0gLTEgJiYgcHJldkFuY2hvck9mZnNldCA9PT0gbmV4dEFuY2hvck9mZnNldCArIDEpIHtcbiAgICByZXR1cm4gREVMRVRFX0NIQVJBQ1RFUl9CRUZPUkVfU0VMRUNUSU9OO1xuICB9XG5cbiAgaWYgKHRleHREaWZmID09PSAtMSAmJiBwcmV2QW5jaG9yT2Zmc2V0ID09PSBuZXh0QW5jaG9yT2Zmc2V0KSB7XG4gICAgcmV0dXJuIERFTEVURV9DSEFSQUNURVJfQUZURVJfU0VMRUNUSU9OO1xuICB9XG5cbiAgcmV0dXJuIE9USEVSO1xufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlVW5jaGFuZ2VkKGtleSwgcHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgcHJldk5vZGUgPSBwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KGtleSk7XG5cbiAgY29uc3QgbmV4dE5vZGUgPSBuZXh0RWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KGtleSk7XG5cbiAgY29uc3QgcHJldlNlbGVjdGlvbiA9IHByZXZFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGxldCBpc0RlbGV0aW5nTGluZSA9IGZhbHNlO1xuXG4gIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24obmV4dFNlbGVjdGlvbikpIHtcbiAgICBpc0RlbGV0aW5nTGluZSA9IHByZXZTZWxlY3Rpb24uYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBwcmV2U2VsZWN0aW9uLmZvY3VzLnR5cGUgPT09ICdlbGVtZW50JyAmJiBuZXh0U2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAndGV4dCcgJiYgbmV4dFNlbGVjdGlvbi5mb2N1cy50eXBlID09PSAndGV4dCc7XG4gIH1cblxuICBpZiAoIWlzRGVsZXRpbmdMaW5lICYmIGxleGljYWwuJGlzVGV4dE5vZGUocHJldk5vZGUpICYmIGxleGljYWwuJGlzVGV4dE5vZGUobmV4dE5vZGUpKSB7XG4gICAgcmV0dXJuIHByZXZOb2RlLl9fdHlwZSA9PT0gbmV4dE5vZGUuX190eXBlICYmIHByZXZOb2RlLl9fdGV4dCA9PT0gbmV4dE5vZGUuX190ZXh0ICYmIHByZXZOb2RlLl9fbW9kZSA9PT0gbmV4dE5vZGUuX19tb2RlICYmIHByZXZOb2RlLl9fZGV0YWlsID09PSBuZXh0Tm9kZS5fX2RldGFpbCAmJiBwcmV2Tm9kZS5fX3N0eWxlID09PSBuZXh0Tm9kZS5fX3N0eWxlICYmIHByZXZOb2RlLl9fZm9ybWF0ID09PSBuZXh0Tm9kZS5fX2Zvcm1hdCAmJiBwcmV2Tm9kZS5fX3BhcmVudCA9PT0gbmV4dE5vZGUuX19wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1lcmdlQWN0aW9uR2V0dGVyKGVkaXRvciwgZGVsYXkpIHtcbiAgbGV0IHByZXZDaGFuZ2VUaW1lID0gRGF0ZS5ub3coKTtcbiAgbGV0IHByZXZDaGFuZ2VUeXBlID0gT1RIRVI7XG4gIHJldHVybiAocHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUsIGN1cnJlbnRIaXN0b3J5RW50cnksIGRpcnR5TGVhdmVzLCBkaXJ0eUVsZW1lbnRzLCB0YWdzKSA9PiB7XG4gICAgY29uc3QgY2hhbmdlVGltZSA9IERhdGUubm93KCk7IC8vIElmIGFwcGx5aW5nIGNoYW5nZXMgZnJvbSBoaXN0b3J5IHN0YWNrIHRoZXJlJ3Mgbm8gbmVlZFxuICAgIC8vIHRvIHJ1biBoaXN0b3J5IGxvZ2ljIGFnYWluLCBhcyBoaXN0b3J5IGVudHJpZXMgYWxyZWFkeSBjYWxjdWxhdGVkXG5cbiAgICBpZiAodGFncy5oYXMoJ2hpc3RvcmljJykpIHtcbiAgICAgIHByZXZDaGFuZ2VUeXBlID0gT1RIRVI7XG4gICAgICBwcmV2Q2hhbmdlVGltZSA9IGNoYW5nZVRpbWU7XG4gICAgICByZXR1cm4gRElTQ0FSRF9ISVNUT1JZX0NBTkRJREFURTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VUeXBlID0gZ2V0Q2hhbmdlVHlwZShwcmV2RWRpdG9yU3RhdGUsIG5leHRFZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXMsIGRpcnR5RWxlbWVudHMsIGVkaXRvci5pc0NvbXBvc2luZygpKTtcblxuICAgIGNvbnN0IG1lcmdlQWN0aW9uID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IGlzU2FtZUVkaXRvciA9IGN1cnJlbnRIaXN0b3J5RW50cnkgPT09IG51bGwgfHwgY3VycmVudEhpc3RvcnlFbnRyeS5lZGl0b3IgPT09IGVkaXRvcjtcbiAgICAgIGNvbnN0IHNob3VsZFB1c2hIaXN0b3J5ID0gdGFncy5oYXMoJ2hpc3RvcnktcHVzaCcpO1xuICAgICAgY29uc3Qgc2hvdWxkTWVyZ2VIaXN0b3J5ID0gIXNob3VsZFB1c2hIaXN0b3J5ICYmIGlzU2FtZUVkaXRvciAmJiB0YWdzLmhhcygnaGlzdG9yeS1tZXJnZScpO1xuXG4gICAgICBpZiAoc2hvdWxkTWVyZ2VIaXN0b3J5KSB7XG4gICAgICAgIHJldHVybiBISVNUT1JZX01FUkdFO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldkVkaXRvclN0YXRlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBISVNUT1JZX1BVU0g7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IG5leHRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICAgICAgY29uc3QgaGFzRGlydHlOb2RlcyA9IGRpcnR5TGVhdmVzLnNpemUgPiAwIHx8IGRpcnR5RWxlbWVudHMuc2l6ZSA+IDA7XG5cbiAgICAgIGlmICghaGFzRGlydHlOb2Rlcykge1xuICAgICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIEhJU1RPUllfTUVSR0U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gRElTQ0FSRF9ISVNUT1JZX0NBTkRJREFURTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFB1c2hIaXN0b3J5ID09PSBmYWxzZSAmJiBjaGFuZ2VUeXBlICE9PSBPVEhFUiAmJiBjaGFuZ2VUeXBlID09PSBwcmV2Q2hhbmdlVHlwZSAmJiBjaGFuZ2VUaW1lIDwgcHJldkNoYW5nZVRpbWUgKyBkZWxheSAmJiBpc1NhbWVFZGl0b3IpIHtcbiAgICAgICAgcmV0dXJuIEhJU1RPUllfTUVSR0U7XG4gICAgICB9IC8vIEEgc2luZ2xlIG5vZGUgbWlnaHQgaGF2ZSBiZWVuIG1hcmtlZCBhcyBkaXJ0eSwgYnV0IG5vdCBoYXZlIGNoYW5nZWRcbiAgICAgIC8vIGR1ZSB0byBzb21lIG5vZGUgdHJhbnNmb3JtIHJldmVydGluZyB0aGUgY2hhbmdlLlxuXG5cbiAgICAgIGlmIChkaXJ0eUxlYXZlcy5zaXplID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGRpcnR5TGVhZktleSA9IEFycmF5LmZyb20oZGlydHlMZWF2ZXMpWzBdO1xuXG4gICAgICAgIGlmIChpc1RleHROb2RlVW5jaGFuZ2VkKGRpcnR5TGVhZktleSwgcHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIEhJU1RPUllfTUVSR0U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEhJU1RPUllfUFVTSDtcbiAgICB9KSgpO1xuXG4gICAgcHJldkNoYW5nZVRpbWUgPSBjaGFuZ2VUaW1lO1xuICAgIHByZXZDaGFuZ2VUeXBlID0gY2hhbmdlVHlwZTtcbiAgICByZXR1cm4gbWVyZ2VBY3Rpb247XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlZG8oZWRpdG9yLCBoaXN0b3J5U3RhdGUpIHtcbiAgY29uc3QgcmVkb1N0YWNrID0gaGlzdG9yeVN0YXRlLnJlZG9TdGFjaztcbiAgY29uc3QgdW5kb1N0YWNrID0gaGlzdG9yeVN0YXRlLnVuZG9TdGFjaztcblxuICBpZiAocmVkb1N0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBoaXN0b3J5U3RhdGUuY3VycmVudDtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB1bmRvU3RhY2sucHVzaChjdXJyZW50KTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5DQU5fVU5ET19DT01NQU5ELCB0cnVlKTtcbiAgICB9XG5cbiAgICBjb25zdCBoaXN0b3J5U3RhdGVFbnRyeSA9IHJlZG9TdGFjay5wb3AoKTtcblxuICAgIGlmIChyZWRvU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuQ0FOX1JFRE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIH1cblxuICAgIGhpc3RvcnlTdGF0ZS5jdXJyZW50ID0gaGlzdG9yeVN0YXRlRW50cnkgfHwgbnVsbDtcblxuICAgIGlmIChoaXN0b3J5U3RhdGVFbnRyeSkge1xuICAgICAgaGlzdG9yeVN0YXRlRW50cnkuZWRpdG9yLnNldEVkaXRvclN0YXRlKGhpc3RvcnlTdGF0ZUVudHJ5LmVkaXRvclN0YXRlLCB7XG4gICAgICAgIHRhZzogJ2hpc3RvcmljJ1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVuZG8oZWRpdG9yLCBoaXN0b3J5U3RhdGUpIHtcbiAgY29uc3QgcmVkb1N0YWNrID0gaGlzdG9yeVN0YXRlLnJlZG9TdGFjaztcbiAgY29uc3QgdW5kb1N0YWNrID0gaGlzdG9yeVN0YXRlLnVuZG9TdGFjaztcbiAgY29uc3QgdW5kb1N0YWNrTGVuZ3RoID0gdW5kb1N0YWNrLmxlbmd0aDtcblxuICBpZiAodW5kb1N0YWNrTGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgY3VycmVudCA9IGhpc3RvcnlTdGF0ZS5jdXJyZW50O1xuICAgIGNvbnN0IGhpc3RvcnlTdGF0ZUVudHJ5ID0gdW5kb1N0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHJlZG9TdGFjay5wdXNoKGN1cnJlbnQpO1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLkNBTl9SRURPX0NPTU1BTkQsIHRydWUpO1xuICAgIH1cblxuICAgIGlmICh1bmRvU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuQ0FOX1VORE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIH1cblxuICAgIGhpc3RvcnlTdGF0ZS5jdXJyZW50ID0gaGlzdG9yeVN0YXRlRW50cnkgfHwgbnVsbDtcblxuICAgIGlmIChoaXN0b3J5U3RhdGVFbnRyeSkge1xuICAgICAgaGlzdG9yeVN0YXRlRW50cnkuZWRpdG9yLnNldEVkaXRvclN0YXRlKGhpc3RvcnlTdGF0ZUVudHJ5LmVkaXRvclN0YXRlLCB7XG4gICAgICAgIHRhZzogJ2hpc3RvcmljJ1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFySGlzdG9yeShoaXN0b3J5U3RhdGUpIHtcbiAgaGlzdG9yeVN0YXRlLnVuZG9TdGFjayA9IFtdO1xuICBoaXN0b3J5U3RhdGUucmVkb1N0YWNrID0gW107XG4gIGhpc3RvcnlTdGF0ZS5jdXJyZW50ID0gbnVsbDtcbn1cbi8qKlxuICogUmVnaXN0ZXJzIG5lY2Vzc2FyeSBsaXN0ZW5lcnMgdG8gbWFuYWdlIHVuZG8vcmVkbyBoaXN0b3J5IHN0YWNrIGFuZCByZWxhdGVkIGVkaXRvciBjb21tYW5kcy5cbiAqIEl0IHJldHVybnMgYHVucmVnaXN0ZXJgIGNhbGxiYWNrIHRoYXQgY2xlYW5zIHVwIGFsbCBsaXN0ZW5lcnMgYW5kIHNob3VsZCBiZSBjYWxsZWQgb24gZWRpdG9yIHVubW91bnQuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICogQHBhcmFtIGhpc3RvcnlTdGF0ZSAtIFRoZSBoaXN0b3J5IHN0YXRlLCBjb250YWluaW5nIHRoZSBjdXJyZW50IHN0YXRlIGFuZCB0aGUgdW5kby9yZWRvIHN0YWNrLlxuICogQHBhcmFtIGRlbGF5IC0gVGhlIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdGhlIGVkaXRvciBzaG91bGQgZGVsYXkgZ2VuZXJhdGluZyBhIG5ldyBoaXN0b3J5IHN0YWNrLFxuICogaW5zdGVhZCBvZiBtZXJnaW5nIHRoZSBjdXJyZW50IGNoYW5nZXMgd2l0aCB0aGUgY3VycmVudCBzdGFjay5cbiAqIEByZXR1cm5zIFRoZSBsaXN0ZW5lcnMgY2xlYW51cCBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVySGlzdG9yeShlZGl0b3IsIGhpc3RvcnlTdGF0ZSwgZGVsYXkpIHtcbiAgY29uc3QgZ2V0TWVyZ2VBY3Rpb24gPSBjcmVhdGVNZXJnZUFjdGlvbkdldHRlcihlZGl0b3IsIGRlbGF5KTtcblxuICBjb25zdCBhcHBseUNoYW5nZSA9ICh7XG4gICAgZWRpdG9yU3RhdGUsXG4gICAgcHJldkVkaXRvclN0YXRlLFxuICAgIGRpcnR5TGVhdmVzLFxuICAgIGRpcnR5RWxlbWVudHMsXG4gICAgdGFnc1xuICB9KSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IGhpc3RvcnlTdGF0ZS5jdXJyZW50O1xuICAgIGNvbnN0IHJlZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2s7XG4gICAgY29uc3QgdW5kb1N0YWNrID0gaGlzdG9yeVN0YXRlLnVuZG9TdGFjaztcbiAgICBjb25zdCBjdXJyZW50RWRpdG9yU3RhdGUgPSBjdXJyZW50ID09PSBudWxsID8gbnVsbCA6IGN1cnJlbnQuZWRpdG9yU3RhdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBlZGl0b3JTdGF0ZSA9PT0gY3VycmVudEVkaXRvclN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWVyZ2VBY3Rpb24gPSBnZXRNZXJnZUFjdGlvbihwcmV2RWRpdG9yU3RhdGUsIGVkaXRvclN0YXRlLCBjdXJyZW50LCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cywgdGFncyk7XG5cbiAgICBpZiAobWVyZ2VBY3Rpb24gPT09IEhJU1RPUllfUFVTSCkge1xuICAgICAgaWYgKHJlZG9TdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgICAgaGlzdG9yeVN0YXRlLnJlZG9TdGFjayA9IFtdO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuQ0FOX1JFRE9fQ09NTUFORCwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICB1bmRvU3RhY2sucHVzaCh7IC4uLmN1cnJlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5DQU5fVU5ET19DT01NQU5ELCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1lcmdlQWN0aW9uID09PSBESVNDQVJEX0hJU1RPUllfQ0FORElEQVRFKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBFbHNlIHdlIG1lcmdlXG5cblxuICAgIGhpc3RvcnlTdGF0ZS5jdXJyZW50ID0ge1xuICAgICAgZWRpdG9yLFxuICAgICAgZWRpdG9yU3RhdGVcbiAgICB9O1xuICB9O1xuXG4gIGNvbnN0IHVucmVnaXN0ZXJDb21tYW5kTGlzdGVuZXIgPSB1dGlscy5tZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5VTkRPX0NPTU1BTkQsICgpID0+IHtcbiAgICB1bmRvKGVkaXRvciwgaGlzdG9yeVN0YXRlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5SRURPX0NPTU1BTkQsICgpID0+IHtcbiAgICByZWRvKGVkaXRvciwgaGlzdG9yeVN0YXRlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5DTEVBUl9FRElUT1JfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNsZWFySGlzdG9yeShoaXN0b3J5U3RhdGUpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5DTEVBUl9ISVNUT1JZX0NPTU1BTkQsICgpID0+IHtcbiAgICBjbGVhckhpc3RvcnkoaGlzdG9yeVN0YXRlKTtcbiAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuQ0FOX1JFRE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5DQU5fVU5ET19DT01NQU5ELCBmYWxzZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcihhcHBseUNoYW5nZSkpO1xuICBjb25zdCB1bnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIgPSBlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcihhcHBseUNoYW5nZSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdW5yZWdpc3RlckNvbW1hbmRMaXN0ZW5lcigpO1xuICAgIHVucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigpO1xuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGVtcHR5IGhpc3Rvcnkgc3RhdGUuXG4gKiBAcmV0dXJucyAtIFRoZSBlbXB0eSBoaXN0b3J5IHN0YXRlLCBhcyBhbiBvYmplY3QuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogbnVsbCxcbiAgICByZWRvU3RhY2s6IFtdLFxuICAgIHVuZG9TdGFjazogW11cbiAgfTtcbn1cblxuZXhwb3J0cy5jcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSA9IGNyZWF0ZUVtcHR5SGlzdG9yeVN0YXRlO1xuZXhwb3J0cy5yZWdpc3Rlckhpc3RvcnkgPSByZWdpc3Rlckhpc3Rvcnk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/history/LexicalHistory.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lexical/history/LexicalHistory.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHistory =  true ? __webpack_require__(/*! ./LexicalHistory.dev.js */ \"(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.js\") : 0\nmodule.exports = LexicalHistory;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaGlzdG9yeS9MZXhpY2FsSGlzdG9yeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLHVCQUF1QixLQUFzQyxHQUFHLG1CQUFPLENBQUMsNEZBQXlCLElBQUksQ0FBbUM7QUFDeEkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9oaXN0b3J5L0xleGljYWxIaXN0b3J5LmpzPzI5NWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxIaXN0b3J5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxIaXN0b3J5LmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsSGlzdG9yeS5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbEhpc3Rvcnk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/history/LexicalHistory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/html/LexicalHtml.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar selection = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/html */\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivilant library and pass in the document here.\n */\n\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n\n  return container.innerHTML;\n}\n\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const {\n    element,\n    after\n  } = target.exportDOM(editor);\n\n  if (!element) {\n    return false;\n  }\n\n  const fragment = document.createDocumentFragment();\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    element.append(fragment);\n    parentElement.append(element);\n\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n\n  return shouldInclude;\n}\n\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n\n  let currentConversion = null;\n\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\n\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\n\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  } // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n\n\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode));\n  }\n\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n\n  return lexicalNodes;\n}\n\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaHRtbC9MZXhpY2FsSHRtbC5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsdUZBQW9CO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQyx3REFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2h0bWwvTGV4aWNhbEh0bWwuZGV2LmpzPzY5NjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzZWxlY3Rpb24gPSByZXF1aXJlKCdAbGV4aWNhbC9zZWxlY3Rpb24nKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xuXG4vKiogQG1vZHVsZSBAbGV4aWNhbC9odG1sICovXG4vKipcbiAqIEhvdyB5b3UgcGFyc2UgeW91ciBodG1sIHN0cmluZyB0byBnZXQgYSBkb2N1bWVudCBpcyBsZWZ0IHVwIHRvIHlvdS4gSW4gdGhlIGJyb3dzZXIgeW91IGNhbiB1c2UgdGhlIG5hdGl2ZVxuICogRE9NUGFyc2VyIEFQSSB0byBnZW5lcmF0ZSBhIGRvY3VtZW50IChzZWUgY2xpcGJvYXJkLnRzKSwgYnV0IHRvIHVzZSBpbiBhIGhlYWRsZXNzIGVudmlyb25tZW50IHlvdSBjYW4gdXNlIEpTRG9tXG4gKiBvciBhbiBlcXVpdmlsYW50IGxpYnJhcnkgYW5kIHBhc3MgaW4gdGhlIGRvY3VtZW50IGhlcmUuXG4gKi9cblxuZnVuY3Rpb24gJGdlbmVyYXRlTm9kZXNGcm9tRE9NKGVkaXRvciwgZG9tKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gZG9tLmJvZHkgPyBkb20uYm9keS5jaGlsZE5vZGVzIDogW107XG4gIGxldCBsZXhpY2FsTm9kZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuXG4gICAgaWYgKCFJR05PUkVfVEFHUy5oYXMoZWxlbWVudC5ub2RlTmFtZSkpIHtcbiAgICAgIGNvbnN0IGxleGljYWxOb2RlID0gJGNyZWF0ZU5vZGVzRnJvbURPTShlbGVtZW50LCBlZGl0b3IpO1xuXG4gICAgICBpZiAobGV4aWNhbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgbGV4aWNhbE5vZGVzID0gbGV4aWNhbE5vZGVzLmNvbmNhdChsZXhpY2FsTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxleGljYWxOb2Rlcztcbn1cbmZ1bmN0aW9uICRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHVzZSAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzIGluIGhlYWRsZXNzIG1vZGUgcGxlYXNlIGluaXRpYWxpemUgYSBoZWFkbGVzcyBicm93c2VyIGltcGxlbWVudGF0aW9uIHN1Y2ggYXMgSlNEb20gYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb25zdCByb290ID0gbGV4aWNhbC4kZ2V0Um9vdCgpO1xuICBjb25zdCB0b3BMZXZlbENoaWxkcmVuID0gcm9vdC5nZXRDaGlsZHJlbigpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9wTGV2ZWxDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvcExldmVsTm9kZSA9IHRvcExldmVsQ2hpbGRyZW5baV07XG4gICAgJGFwcGVuZE5vZGVzVG9IVE1MKGVkaXRvciwgdG9wTGV2ZWxOb2RlLCBjb250YWluZXIsIHNlbGVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gJGFwcGVuZE5vZGVzVG9IVE1MKGVkaXRvciwgY3VycmVudE5vZGUsIHBhcmVudEVsZW1lbnQsIHNlbGVjdGlvbiQxID0gbnVsbCkge1xuICBsZXQgc2hvdWxkSW5jbHVkZSA9IHNlbGVjdGlvbiQxICE9IG51bGwgPyBjdXJyZW50Tm9kZS5pc1NlbGVjdGVkKHNlbGVjdGlvbiQxKSA6IHRydWU7XG4gIGNvbnN0IHNob3VsZEV4Y2x1ZGUgPSBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBjdXJyZW50Tm9kZS5leGNsdWRlRnJvbUNvcHkoJ2h0bWwnKTtcbiAgbGV0IHRhcmdldCA9IGN1cnJlbnROb2RlO1xuXG4gIGlmIChzZWxlY3Rpb24kMSAhPT0gbnVsbCkge1xuICAgIGxldCBjbG9uZSA9IHNlbGVjdGlvbi4kY2xvbmVXaXRoUHJvcGVydGllcyhjdXJyZW50Tm9kZSk7XG4gICAgY2xvbmUgPSBsZXhpY2FsLiRpc1RleHROb2RlKGNsb25lKSAmJiBzZWxlY3Rpb24kMSAhPSBudWxsID8gc2VsZWN0aW9uLiRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50KHNlbGVjdGlvbiQxLCBjbG9uZSkgOiBjbG9uZTtcbiAgICB0YXJnZXQgPSBjbG9uZTtcbiAgfVxuXG4gIGNvbnN0IGNoaWxkcmVuID0gbGV4aWNhbC4kaXNFbGVtZW50Tm9kZSh0YXJnZXQpID8gdGFyZ2V0LmdldENoaWxkcmVuKCkgOiBbXTtcbiAgY29uc3Qge1xuICAgIGVsZW1lbnQsXG4gICAgYWZ0ZXJcbiAgfSA9IHRhcmdldC5leHBvcnRET00oZWRpdG9yKTtcblxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gY2hpbGRyZW5baV07XG4gICAgY29uc3Qgc2hvdWxkSW5jbHVkZUNoaWxkID0gJGFwcGVuZE5vZGVzVG9IVE1MKGVkaXRvciwgY2hpbGROb2RlLCBmcmFnbWVudCwgc2VsZWN0aW9uJDEpO1xuXG4gICAgaWYgKCFzaG91bGRJbmNsdWRlICYmIGxleGljYWwuJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmIHNob3VsZEluY2x1ZGVDaGlsZCAmJiBjdXJyZW50Tm9kZS5leHRyYWN0V2l0aENoaWxkKGNoaWxkTm9kZSwgc2VsZWN0aW9uJDEsICdodG1sJykpIHtcbiAgICAgIHNob3VsZEluY2x1ZGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzaG91bGRJbmNsdWRlICYmICFzaG91bGRFeGNsdWRlKSB7XG4gICAgZWxlbWVudC5hcHBlbmQoZnJhZ21lbnQpO1xuICAgIHBhcmVudEVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuXG4gICAgaWYgKGFmdGVyKSB7XG4gICAgICBjb25zdCBuZXdFbGVtZW50ID0gYWZ0ZXIuY2FsbCh0YXJnZXQsIGVsZW1lbnQpO1xuICAgICAgaWYgKG5ld0VsZW1lbnQpIGVsZW1lbnQucmVwbGFjZVdpdGgobmV3RWxlbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmVudEVsZW1lbnQuYXBwZW5kKGZyYWdtZW50KTtcbiAgfVxuXG4gIHJldHVybiBzaG91bGRJbmNsdWRlO1xufVxuXG5mdW5jdGlvbiBnZXRDb252ZXJzaW9uRnVuY3Rpb24oZG9tTm9kZSwgZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlTmFtZVxuICB9ID0gZG9tTm9kZTtcblxuICBjb25zdCBjYWNoZWRDb252ZXJzaW9ucyA9IGVkaXRvci5faHRtbENvbnZlcnNpb25zLmdldChub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcblxuICBsZXQgY3VycmVudENvbnZlcnNpb24gPSBudWxsO1xuXG4gIGlmIChjYWNoZWRDb252ZXJzaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCBjYWNoZWRDb252ZXJzaW9uIG9mIGNhY2hlZENvbnZlcnNpb25zKSB7XG4gICAgICBjb25zdCBkb21Db252ZXJzaW9uID0gY2FjaGVkQ29udmVyc2lvbihkb21Ob2RlKTtcblxuICAgICAgaWYgKGRvbUNvbnZlcnNpb24gIT09IG51bGwgJiYgKGN1cnJlbnRDb252ZXJzaW9uID09PSBudWxsIHx8IGN1cnJlbnRDb252ZXJzaW9uLnByaW9yaXR5IDwgZG9tQ29udmVyc2lvbi5wcmlvcml0eSkpIHtcbiAgICAgICAgY3VycmVudENvbnZlcnNpb24gPSBkb21Db252ZXJzaW9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50Q29udmVyc2lvbiAhPT0gbnVsbCA/IGN1cnJlbnRDb252ZXJzaW9uLmNvbnZlcnNpb24gOiBudWxsO1xufVxuXG5jb25zdCBJR05PUkVfVEFHUyA9IG5ldyBTZXQoWydTVFlMRScsICdTQ1JJUFQnXSk7XG5cbmZ1bmN0aW9uICRjcmVhdGVOb2Rlc0Zyb21ET00obm9kZSwgZWRpdG9yLCBmb3JDaGlsZE1hcCA9IG5ldyBNYXAoKSwgcGFyZW50TGV4aWNhbE5vZGUpIHtcbiAgbGV0IGxleGljYWxOb2RlcyA9IFtdO1xuXG4gIGlmIChJR05PUkVfVEFHUy5oYXMobm9kZS5ub2RlTmFtZSkpIHtcbiAgICByZXR1cm4gbGV4aWNhbE5vZGVzO1xuICB9XG5cbiAgbGV0IGN1cnJlbnRMZXhpY2FsTm9kZSA9IG51bGw7XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmN0aW9uID0gZ2V0Q29udmVyc2lvbkZ1bmN0aW9uKG5vZGUsIGVkaXRvcik7XG4gIGNvbnN0IHRyYW5zZm9ybU91dHB1dCA9IHRyYW5zZm9ybUZ1bmN0aW9uID8gdHJhbnNmb3JtRnVuY3Rpb24obm9kZSkgOiBudWxsO1xuICBsZXQgcG9zdFRyYW5zZm9ybSA9IG51bGw7XG5cbiAgaWYgKHRyYW5zZm9ybU91dHB1dCAhPT0gbnVsbCkge1xuICAgIHBvc3RUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1PdXRwdXQuYWZ0ZXI7XG4gICAgY29uc3QgdHJhbnNmb3JtTm9kZXMgPSB0cmFuc2Zvcm1PdXRwdXQubm9kZTtcbiAgICBjdXJyZW50TGV4aWNhbE5vZGUgPSBBcnJheS5pc0FycmF5KHRyYW5zZm9ybU5vZGVzKSA/IHRyYW5zZm9ybU5vZGVzW3RyYW5zZm9ybU5vZGVzLmxlbmd0aCAtIDFdIDogdHJhbnNmb3JtTm9kZXM7XG5cbiAgICBpZiAoY3VycmVudExleGljYWxOb2RlICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IFssIGZvckNoaWxkRnVuY3Rpb25dIG9mIGZvckNoaWxkTWFwKSB7XG4gICAgICAgIGN1cnJlbnRMZXhpY2FsTm9kZSA9IGZvckNoaWxkRnVuY3Rpb24oY3VycmVudExleGljYWxOb2RlLCBwYXJlbnRMZXhpY2FsTm9kZSk7XG5cbiAgICAgICAgaWYgKCFjdXJyZW50TGV4aWNhbE5vZGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudExleGljYWxOb2RlKSB7XG4gICAgICAgIGxleGljYWxOb2Rlcy5wdXNoKC4uLihBcnJheS5pc0FycmF5KHRyYW5zZm9ybU5vZGVzKSA/IHRyYW5zZm9ybU5vZGVzIDogW2N1cnJlbnRMZXhpY2FsTm9kZV0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHJhbnNmb3JtT3V0cHV0LmZvckNoaWxkICE9IG51bGwpIHtcbiAgICAgIGZvckNoaWxkTWFwLnNldChub2RlLm5vZGVOYW1lLCB0cmFuc2Zvcm1PdXRwdXQuZm9yQ2hpbGQpO1xuICAgIH1cbiAgfSAvLyBJZiB0aGUgRE9NIG5vZGUgZG9lc24ndCBoYXZlIGEgdHJhbnNmb3JtZXIsIHdlIGRvbid0IGtub3cgd2hhdFxuICAvLyB0byBkbyB3aXRoIGl0IGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIHByb2Nlc3MgYW55IGNoaWxkTm9kZXMuXG5cblxuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgbGV0IGNoaWxkTGV4aWNhbE5vZGVzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNoaWxkTGV4aWNhbE5vZGVzLnB1c2goLi4uJGNyZWF0ZU5vZGVzRnJvbURPTShjaGlsZHJlbltpXSwgZWRpdG9yLCBuZXcgTWFwKGZvckNoaWxkTWFwKSwgY3VycmVudExleGljYWxOb2RlKSk7XG4gIH1cblxuICBpZiAocG9zdFRyYW5zZm9ybSAhPSBudWxsKSB7XG4gICAgY2hpbGRMZXhpY2FsTm9kZXMgPSBwb3N0VHJhbnNmb3JtKGNoaWxkTGV4aWNhbE5vZGVzKTtcbiAgfVxuXG4gIGlmIChjdXJyZW50TGV4aWNhbE5vZGUgPT0gbnVsbCkge1xuICAgIC8vIElmIGl0IGhhc24ndCBiZWVuIGNvbnZlcnRlZCB0byBhIExleGljYWxOb2RlLCB3ZSBob2lzdCBpdHMgY2hpbGRyZW5cbiAgICAvLyB1cCB0byB0aGUgc2FtZSBsZXZlbCBhcyBpdC5cbiAgICBsZXhpY2FsTm9kZXMgPSBsZXhpY2FsTm9kZXMuY29uY2F0KGNoaWxkTGV4aWNhbE5vZGVzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjdXJyZW50TGV4aWNhbE5vZGUpKSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBub2RlIGlzIGEgRWxlbWVudE5vZGUgYWZ0ZXIgY29udmVyc2lvbixcbiAgICAgIC8vIHdlIGNhbiBhcHBlbmQgYWxsIHRoZSBjaGlsZHJlbiB0byBpdC5cbiAgICAgIGN1cnJlbnRMZXhpY2FsTm9kZS5hcHBlbmQoLi4uY2hpbGRMZXhpY2FsTm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsZXhpY2FsTm9kZXM7XG59XG5cbmV4cG9ydHMuJGdlbmVyYXRlSHRtbEZyb21Ob2RlcyA9ICRnZW5lcmF0ZUh0bWxGcm9tTm9kZXM7XG5leHBvcnRzLiRnZW5lcmF0ZU5vZGVzRnJvbURPTSA9ICRnZW5lcmF0ZU5vZGVzRnJvbURPTTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/html/LexicalHtml.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/html/LexicalHtml.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHtml =  true ? __webpack_require__(/*! ./LexicalHtml.dev.js */ \"(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.js\") : 0\nmodule.exports = LexicalHtml;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaHRtbC9MZXhpY2FsSHRtbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLG9CQUFvQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsbUZBQXNCLElBQUksQ0FBZ0M7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9odG1sL0xleGljYWxIdG1sLmpzPzU5ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxIdG1sID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxIdG1sLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsSHRtbC5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbEh0bWw7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/html/LexicalHtml.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/link/LexicalLink.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/link/LexicalLink.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/link */\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n/** @noInheritDoc */\n\nclass LinkNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'link';\n  }\n\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n\n  constructor(url, attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.sanitizeUrl(this.__url);\n\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n\n    if (this.__title !== null) {\n      element.title = this.__title;\n    }\n\n    utils.addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n\n  updateDOM(prevNode, anchor, config) {\n    const url = this.__url;\n    const target = this.__target;\n    const rel = this.__rel;\n    const title = this.__title;\n\n    if (url !== prevNode.__url) {\n      anchor.href = url;\n    }\n\n    if (target !== prevNode.__target) {\n      if (target) {\n        anchor.target = target;\n      } else {\n        anchor.removeAttribute('target');\n      }\n    }\n\n    if (rel !== prevNode.__rel) {\n      if (rel) {\n        anchor.rel = rel;\n      } else {\n        anchor.removeAttribute('rel');\n      }\n    }\n\n    if (title !== prevNode.__title) {\n      if (title) {\n        anchor.title = title;\n      } else {\n        anchor.removeAttribute('title');\n      }\n    }\n\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  sanitizeUrl(url) {\n    try {\n      const parsedUrl = new URL(url); // eslint-disable-next-line no-script-url\n\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch {\n      return url;\n    }\n\n    return url;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      type: 'link',\n      url: this.getURL(),\n      version: 1\n    };\n  }\n\n  getURL() {\n    return this.getLatest().__url;\n  }\n\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n  }\n\n  getTarget() {\n    return this.getLatest().__target;\n  }\n\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n  }\n\n  getRel() {\n    return this.getLatest().__rel;\n  }\n\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n  }\n\n  getTitle() {\n    return this.getLatest().__title;\n  }\n\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n  }\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createLinkNode(this.__url, {\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n\n    return null;\n  }\n\n  canInsertTextBefore() {\n    return false;\n  }\n\n  canInsertTextAfter() {\n    return false;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  isInline() {\n    return true;\n  }\n\n  extractWithChild(child, selection, destination) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n\n}\n\nfunction convertAnchorElement(domNode) {\n  let node = null;\n\n  if (utils.isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n\n    if (content !== null && content !== '') {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n\n  return {\n    node\n  };\n}\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes { target, rel, title }\n * @returns The LinkNode.\n */\n\n\nfunction $createLinkNode(url, attributes) {\n  return lexical.$applyNodeReplacement(new LinkNode(url, attributes));\n}\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\n\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  static getType() {\n    return 'autolink';\n  }\n\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createAutoLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'autolink',\n      version: 1\n    };\n  }\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        rel: this._rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n\n    return null;\n  }\n\n}\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. { target, rel, title }\n * @returns The LinkNode.\n */\n\nfunction $createAutoLinkNode(url, attributes) {\n  return lexical.$applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\n\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = lexical.createCommand('TOGGLE_LINK_COMMAND');\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. { target, rel, title }\n */\n\nfunction toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n\n  const nodes = selection.extract();\n\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parent = node.getParent();\n\n      if ($isLinkNode(parent)) {\n        const children = parent.getChildren();\n\n        for (let i = 0; i < children.length; i++) {\n          parent.insertBefore(children[i]);\n        }\n\n        parent.remove();\n      }\n    });\n  } else {\n    // Add or merge LinkNodes\n    if (nodes.length === 1) {\n      const firstNode = nodes[0]; // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n\n      const linkNode = $isLinkNode(firstNode) ? firstNode : $getLinkAncestor(firstNode);\n\n      if (linkNode !== null) {\n        linkNode.setURL(url);\n\n        if (target !== undefined) {\n          linkNode.setTarget(target);\n        }\n\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n\n        return;\n      }\n    }\n\n    let prevParent = null;\n    let linkNode = null;\n    nodes.forEach(node => {\n      const parent = node.getParent();\n\n      if (parent === linkNode || parent === null || lexical.$isElementNode(node) && !node.isInline()) {\n        return;\n      }\n\n      if ($isLinkNode(parent)) {\n        linkNode = parent;\n        parent.setURL(url);\n\n        if (target !== undefined) {\n          parent.setTarget(target);\n        }\n\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n\n        return;\n      }\n\n      if (!parent.is(prevParent)) {\n        prevParent = parent;\n        linkNode = $createLinkNode(url, {\n          rel,\n          target\n        });\n\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode);\n          } else {\n            parent.insertAfter(linkNode);\n          }\n        } else {\n          node.insertBefore(linkNode);\n        }\n      }\n\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return;\n        }\n\n        if (linkNode !== null) {\n          const children = node.getChildren();\n\n          for (let i = 0; i < children.length; i++) {\n            linkNode.append(children[i]);\n          }\n        }\n\n        node.remove();\n        return;\n      }\n\n      if (linkNode !== null) {\n        linkNode.append(node);\n      }\n    });\n  }\n}\n\nfunction $getLinkAncestor(node) {\n  return $getAncestor(node, $isLinkNode);\n}\n\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n\n  while (parent !== null && (parent = parent.getParent()) !== null && !predicate(parent));\n\n  return parent;\n}\n\nexports.$createAutoLinkNode = $createAutoLinkNode;\nexports.$createLinkNode = $createLinkNode;\nexports.$isAutoLinkNode = $isAutoLinkNode;\nexports.$isLinkNode = $isLinkNode;\nexports.AutoLinkNode = AutoLinkNode;\nexports.LinkNode = LinkNode;\nexports.TOGGLE_LINK_COMMAND = TOGGLE_LINK_COMMAND;\nexports.toggleLink = toggleLink;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGluay9MZXhpY2FsTGluay5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNwQyxjQUFjLG1CQUFPLENBQUMsd0RBQVM7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCLDJCQUEyQjtBQUMzQixrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9saW5rL0xleGljYWxMaW5rLmRldi5qcz8yYTYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG5cbi8qKiBAbW9kdWxlIEBsZXhpY2FsL2xpbmsgKi9cbmNvbnN0IFNVUFBPUlRFRF9VUkxfUFJPVE9DT0xTID0gbmV3IFNldChbJ2h0dHA6JywgJ2h0dHBzOicsICdtYWlsdG86JywgJ3NtczonLCAndGVsOiddKTtcbi8qKiBAbm9Jbmhlcml0RG9jICovXG5cbmNsYXNzIExpbmtOb2RlIGV4dGVuZHMgbGV4aWNhbC5FbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdsaW5rJztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5rTm9kZShub2RlLl9fdXJsLCB7XG4gICAgICByZWw6IG5vZGUuX19yZWwsXG4gICAgICB0YXJnZXQ6IG5vZGUuX190YXJnZXQsXG4gICAgICB0aXRsZTogbm9kZS5fX3RpdGxlXG4gICAgfSwgbm9kZS5fX2tleSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih1cmwsIGF0dHJpYnV0ZXMgPSB7fSwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQgPSBudWxsLFxuICAgICAgcmVsID0gbnVsbCxcbiAgICAgIHRpdGxlID0gbnVsbFxuICAgIH0gPSBhdHRyaWJ1dGVzO1xuICAgIHRoaXMuX191cmwgPSB1cmw7XG4gICAgdGhpcy5fX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9fcmVsID0gcmVsO1xuICAgIHRoaXMuX190aXRsZSA9IHRpdGxlO1xuICB9XG5cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgZWxlbWVudC5ocmVmID0gdGhpcy5zYW5pdGl6ZVVybCh0aGlzLl9fdXJsKTtcblxuICAgIGlmICh0aGlzLl9fdGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnRhcmdldCA9IHRoaXMuX190YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX19yZWwgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnQucmVsID0gdGhpcy5fX3JlbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fX3RpdGxlICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnRpdGxlID0gdGhpcy5fX3RpdGxlO1xuICAgIH1cblxuICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLmxpbmspO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBhbmNob3IsIGNvbmZpZykge1xuICAgIGNvbnN0IHVybCA9IHRoaXMuX191cmw7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fX3RhcmdldDtcbiAgICBjb25zdCByZWwgPSB0aGlzLl9fcmVsO1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy5fX3RpdGxlO1xuXG4gICAgaWYgKHVybCAhPT0gcHJldk5vZGUuX191cmwpIHtcbiAgICAgIGFuY2hvci5ocmVmID0gdXJsO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQgIT09IHByZXZOb2RlLl9fdGFyZ2V0KSB7XG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGFuY2hvci50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmNob3IucmVtb3ZlQXR0cmlidXRlKCd0YXJnZXQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVsICE9PSBwcmV2Tm9kZS5fX3JlbCkge1xuICAgICAgaWYgKHJlbCkge1xuICAgICAgICBhbmNob3IucmVsID0gcmVsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yLnJlbW92ZUF0dHJpYnV0ZSgncmVsJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRpdGxlICE9PSBwcmV2Tm9kZS5fX3RpdGxlKSB7XG4gICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgYW5jaG9yLnRpdGxlID0gdGl0bGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmNob3IucmVtb3ZlQXR0cmlidXRlKCd0aXRsZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydEFuY2hvckVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAxXG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlTGlua05vZGUoc2VyaWFsaXplZE5vZGUudXJsLCB7XG4gICAgICByZWw6IHNlcmlhbGl6ZWROb2RlLnJlbCxcbiAgICAgIHRhcmdldDogc2VyaWFsaXplZE5vZGUudGFyZ2V0LFxuICAgICAgdGl0bGU6IHNlcmlhbGl6ZWROb2RlLnRpdGxlXG4gICAgfSk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldEluZGVudChzZXJpYWxpemVkTm9kZS5pbmRlbnQpO1xuICAgIG5vZGUuc2V0RGlyZWN0aW9uKHNlcmlhbGl6ZWROb2RlLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBzYW5pdGl6ZVVybCh1cmwpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2NyaXB0LXVybFxuXG4gICAgICBpZiAoIVNVUFBPUlRFRF9VUkxfUFJPVE9DT0xTLmhhcyhwYXJzZWRVcmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHJldHVybiAnYWJvdXQ6YmxhbmsnO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4geyAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICByZWw6IHRoaXMuZ2V0UmVsKCksXG4gICAgICB0YXJnZXQ6IHRoaXMuZ2V0VGFyZ2V0KCksXG4gICAgICB0aXRsZTogdGhpcy5nZXRUaXRsZSgpLFxuICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgdXJsOiB0aGlzLmdldFVSTCgpLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cblxuICBnZXRVUkwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX191cmw7XG4gIH1cblxuICBzZXRVUkwodXJsKSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX191cmwgPSB1cmw7XG4gIH1cblxuICBnZXRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX190YXJnZXQ7XG4gIH1cblxuICBzZXRUYXJnZXQodGFyZ2V0KSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX190YXJnZXQgPSB0YXJnZXQ7XG4gIH1cblxuICBnZXRSZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19yZWw7XG4gIH1cblxuICBzZXRSZWwocmVsKSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX19yZWwgPSByZWw7XG4gIH1cblxuICBnZXRUaXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3RpdGxlO1xuICB9XG5cbiAgc2V0VGl0bGUodGl0bGUpIHtcbiAgICBjb25zdCB3cml0YWJsZSA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICB3cml0YWJsZS5fX3RpdGxlID0gdGl0bGU7XG4gIH1cblxuICBpbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpLmluc2VydE5ld0FmdGVyKHNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbik7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShlbGVtZW50KSkge1xuICAgICAgY29uc3QgbGlua05vZGUgPSAkY3JlYXRlTGlua05vZGUodGhpcy5fX3VybCwge1xuICAgICAgICByZWw6IHRoaXMuX19yZWwsXG4gICAgICAgIHRhcmdldDogdGhpcy5fX3RhcmdldCxcbiAgICAgICAgdGl0bGU6IHRoaXMuX190aXRsZVxuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFwcGVuZChsaW5rTm9kZSk7XG4gICAgICByZXR1cm4gbGlua05vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjYW5JbnNlcnRUZXh0QmVmb3JlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNhbkluc2VydFRleHRBZnRlcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzSW5saW5lKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZXh0cmFjdFdpdGhDaGlsZChjaGlsZCwgc2VsZWN0aW9uLCBkZXN0aW5hdGlvbikge1xuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuaXNQYXJlbnRPZihhbmNob3JOb2RlKSAmJiB0aGlzLmlzUGFyZW50T2YoZm9jdXNOb2RlKSAmJiBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGggPiAwO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gY29udmVydEFuY2hvckVsZW1lbnQoZG9tTm9kZSkge1xuICBsZXQgbm9kZSA9IG51bGw7XG5cbiAgaWYgKHV0aWxzLmlzSFRNTEFuY2hvckVsZW1lbnQoZG9tTm9kZSkpIHtcbiAgICBjb25zdCBjb250ZW50ID0gZG9tTm9kZS50ZXh0Q29udGVudDtcblxuICAgIGlmIChjb250ZW50ICE9PSBudWxsICYmIGNvbnRlbnQgIT09ICcnKSB7XG4gICAgICBub2RlID0gJGNyZWF0ZUxpbmtOb2RlKGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJycsIHtcbiAgICAgICAgcmVsOiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgncmVsJyksXG4gICAgICAgIHRhcmdldDogZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpLFxuICAgICAgICB0aXRsZTogZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3RpdGxlJylcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbm9kZVxuICB9O1xufVxuLyoqXG4gKiBUYWtlcyBhIFVSTCBhbmQgY3JlYXRlcyBhIExpbmtOb2RlLlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdGhlIExpbmtOb2RlIHNob3VsZCBkaXJlY3QgdG8uXG4gKiBAcGFyYW0gYXR0cmlidXRlcyAtIE9wdGlvbmFsIEhUTUwgYSB0YWcgYXR0cmlidXRlcyB7IHRhcmdldCwgcmVsLCB0aXRsZSB9XG4gKiBAcmV0dXJucyBUaGUgTGlua05vZGUuXG4gKi9cblxuXG5mdW5jdGlvbiAkY3JlYXRlTGlua05vZGUodXJsLCBhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiBsZXhpY2FsLiRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgTGlua05vZGUodXJsLCBhdHRyaWJ1dGVzKSk7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgbm9kZSBpcyBhIExpbmtOb2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiBub2RlIGlzIGEgTGlua05vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiAkaXNMaW5rTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgTGlua05vZGU7XG59XG4vLyBDdXN0b20gbm9kZSB0eXBlIHRvIG92ZXJyaWRlIGBjYW5JbnNlcnRUZXh0QWZ0ZXJgIHRoYXQgd2lsbFxuLy8gYWxsb3cgdHlwaW5nIHdpdGhpbiB0aGUgbGlua1xuY2xhc3MgQXV0b0xpbmtOb2RlIGV4dGVuZHMgTGlua05vZGUge1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2F1dG9saW5rJztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBBdXRvTGlua05vZGUobm9kZS5fX3VybCwge1xuICAgICAgcmVsOiBub2RlLl9fcmVsLFxuICAgICAgdGFyZ2V0OiBub2RlLl9fdGFyZ2V0LFxuICAgICAgdGl0bGU6IG5vZGUuX190aXRsZVxuICAgIH0sIG5vZGUuX19rZXkpO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZUF1dG9MaW5rTm9kZShzZXJpYWxpemVkTm9kZS51cmwsIHtcbiAgICAgIHJlbDogc2VyaWFsaXplZE5vZGUucmVsLFxuICAgICAgdGFyZ2V0OiBzZXJpYWxpemVkTm9kZS50YXJnZXQsXG4gICAgICB0aXRsZTogc2VyaWFsaXplZE5vZGUudGl0bGVcbiAgICB9KTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgLy8gVE9ETzogU2hvdWxkIGxpbmsgbm9kZSBzaG91bGQgaGFuZGxlIHRoZSBpbXBvcnQgb3ZlciBhdXRvbGluaz9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgdHlwZTogJ2F1dG9saW5rJyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG5cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5pbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24pO1xuXG4gICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUoZWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IGxpbmtOb2RlID0gJGNyZWF0ZUF1dG9MaW5rTm9kZSh0aGlzLl9fdXJsLCB7XG4gICAgICAgIHJlbDogdGhpcy5fcmVsLFxuICAgICAgICB0YXJnZXQ6IHRoaXMuX190YXJnZXQsXG4gICAgICAgIHRpdGxlOiB0aGlzLl9fdGl0bGVcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5hcHBlbmQobGlua05vZGUpO1xuICAgICAgcmV0dXJuIGxpbmtOb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbn1cbi8qKlxuICogVGFrZXMgYSBVUkwgYW5kIGNyZWF0ZXMgYW4gQXV0b0xpbmtOb2RlLiBBdXRvTGlua05vZGVzIGFyZSBnZW5lcmFsbHkgYXV0b21hdGljYWxseSBnZW5lcmF0ZWRcbiAqIGR1cmluZyB0eXBpbmcsIHdoaWNoIGlzIGVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gYSBidXR0b24gdG8gZ2VuZXJhdGUgYSBMaW5rTm9kZSBpcyBub3QgcHJhY3RpY2FsLlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdGhlIExpbmtOb2RlIHNob3VsZCBkaXJlY3QgdG8uXG4gKiBAcGFyYW0gYXR0cmlidXRlcyAtIE9wdGlvbmFsIEhUTUwgYSB0YWcgYXR0cmlidXRlcy4geyB0YXJnZXQsIHJlbCwgdGl0bGUgfVxuICogQHJldHVybnMgVGhlIExpbmtOb2RlLlxuICovXG5cbmZ1bmN0aW9uICRjcmVhdGVBdXRvTGlua05vZGUodXJsLCBhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiBsZXhpY2FsLiRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgQXV0b0xpbmtOb2RlKHVybCwgYXR0cmlidXRlcykpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIG5vZGUgaXMgYW4gQXV0b0xpbmtOb2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiBub2RlIGlzIGFuIEF1dG9MaW5rTm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uICRpc0F1dG9MaW5rTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgQXV0b0xpbmtOb2RlO1xufVxuY29uc3QgVE9HR0xFX0xJTktfQ09NTUFORCA9IGxleGljYWwuY3JlYXRlQ29tbWFuZCgnVE9HR0xFX0xJTktfQ09NTUFORCcpO1xuLyoqXG4gKiBHZW5lcmF0ZXMgb3IgdXBkYXRlcyBhIExpbmtOb2RlLiBJdCBjYW4gYWxzbyBkZWxldGUgYSBMaW5rTm9kZSBpZiB0aGUgVVJMIGlzIG51bGwsXG4gKiBidXQgc2F2ZXMgYW55IGNoaWxkcmVuIGFuZCBicmluZ3MgdGhlbSB1cCB0byB0aGUgcGFyZW50IG5vZGUuXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0aGUgbGluayBkaXJlY3RzIHRvLlxuICogQHBhcmFtIGF0dHJpYnV0ZXMgLSBPcHRpb25hbCBIVE1MIGEgdGFnIGF0dHJpYnV0ZXMuIHsgdGFyZ2V0LCByZWwsIHRpdGxlIH1cbiAqL1xuXG5mdW5jdGlvbiB0b2dnbGVMaW5rKHVybCwgYXR0cmlidXRlcyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB0YXJnZXQsXG4gICAgdGl0bGVcbiAgfSA9IGF0dHJpYnV0ZXM7XG4gIGNvbnN0IHJlbCA9IGF0dHJpYnV0ZXMucmVsID09PSB1bmRlZmluZWQgPyAnbm9yZWZlcnJlcicgOiBhdHRyaWJ1dGVzLnJlbDtcbiAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5leHRyYWN0KCk7XG5cbiAgaWYgKHVybCA9PT0gbnVsbCkge1xuICAgIC8vIFJlbW92ZSBMaW5rTm9kZXNcbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcblxuICAgICAgaWYgKCRpc0xpbmtOb2RlKHBhcmVudCkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuZ2V0Q2hpbGRyZW4oKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZHJlbltpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkIG9yIG1lcmdlIExpbmtOb2Rlc1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGZpcnN0Tm9kZSA9IG5vZGVzWzBdOyAvLyBpZiB0aGUgZmlyc3Qgbm9kZSBpcyBhIExpbmtOb2RlIG9yIGlmIGl0c1xuICAgICAgLy8gcGFyZW50IGlzIGEgTGlua05vZGUsIHdlIHVwZGF0ZSB0aGUgVVJMLCB0YXJnZXQgYW5kIHJlbC5cblxuICAgICAgY29uc3QgbGlua05vZGUgPSAkaXNMaW5rTm9kZShmaXJzdE5vZGUpID8gZmlyc3ROb2RlIDogJGdldExpbmtBbmNlc3RvcihmaXJzdE5vZGUpO1xuXG4gICAgICBpZiAobGlua05vZGUgIT09IG51bGwpIHtcbiAgICAgICAgbGlua05vZGUuc2V0VVJMKHVybCk7XG5cbiAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGlua05vZGUuc2V0VGFyZ2V0KHRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVsICE9PSBudWxsKSB7XG4gICAgICAgICAgbGlua05vZGUuc2V0UmVsKHJlbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxpbmtOb2RlLnNldFRpdGxlKHRpdGxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcHJldlBhcmVudCA9IG51bGw7XG4gICAgbGV0IGxpbmtOb2RlID0gbnVsbDtcbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcblxuICAgICAgaWYgKHBhcmVudCA9PT0gbGlua05vZGUgfHwgcGFyZW50ID09PSBudWxsIHx8IGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICgkaXNMaW5rTm9kZShwYXJlbnQpKSB7XG4gICAgICAgIGxpbmtOb2RlID0gcGFyZW50O1xuICAgICAgICBwYXJlbnQuc2V0VVJMKHVybCk7XG5cbiAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFyZW50LnNldFRhcmdldCh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbCAhPT0gbnVsbCkge1xuICAgICAgICAgIGxpbmtOb2RlLnNldFJlbChyZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpdGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaW5rTm9kZS5zZXRUaXRsZSh0aXRsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyZW50LmlzKHByZXZQYXJlbnQpKSB7XG4gICAgICAgIHByZXZQYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGxpbmtOb2RlID0gJGNyZWF0ZUxpbmtOb2RlKHVybCwge1xuICAgICAgICAgIHJlbCxcbiAgICAgICAgICB0YXJnZXRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCRpc0xpbmtOb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICBpZiAobm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShsaW5rTm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRBZnRlcihsaW5rTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKGxpbmtOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoJGlzTGlua05vZGUobm9kZSkpIHtcbiAgICAgICAgaWYgKG5vZGUuaXMobGlua05vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbmtOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaW5rTm9kZS5hcHBlbmQoY2hpbGRyZW5baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbmtOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGxpbmtOb2RlLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiAkZ2V0TGlua0FuY2VzdG9yKG5vZGUpIHtcbiAgcmV0dXJuICRnZXRBbmNlc3Rvcihub2RlLCAkaXNMaW5rTm9kZSk7XG59XG5cbmZ1bmN0aW9uICRnZXRBbmNlc3Rvcihub2RlLCBwcmVkaWNhdGUpIHtcbiAgbGV0IHBhcmVudCA9IG5vZGU7XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiAocGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpKSAhPT0gbnVsbCAmJiAhcHJlZGljYXRlKHBhcmVudCkpO1xuXG4gIHJldHVybiBwYXJlbnQ7XG59XG5cbmV4cG9ydHMuJGNyZWF0ZUF1dG9MaW5rTm9kZSA9ICRjcmVhdGVBdXRvTGlua05vZGU7XG5leHBvcnRzLiRjcmVhdGVMaW5rTm9kZSA9ICRjcmVhdGVMaW5rTm9kZTtcbmV4cG9ydHMuJGlzQXV0b0xpbmtOb2RlID0gJGlzQXV0b0xpbmtOb2RlO1xuZXhwb3J0cy4kaXNMaW5rTm9kZSA9ICRpc0xpbmtOb2RlO1xuZXhwb3J0cy5BdXRvTGlua05vZGUgPSBBdXRvTGlua05vZGU7XG5leHBvcnRzLkxpbmtOb2RlID0gTGlua05vZGU7XG5leHBvcnRzLlRPR0dMRV9MSU5LX0NPTU1BTkQgPSBUT0dHTEVfTElOS19DT01NQU5EO1xuZXhwb3J0cy50b2dnbGVMaW5rID0gdG9nZ2xlTGluaztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/link/LexicalLink.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/link/LexicalLink.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/link/LexicalLink.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalLink =  true ? __webpack_require__(/*! ./LexicalLink.dev.js */ \"(ssr)/./node_modules/@lexical/link/LexicalLink.dev.js\") : 0\nmodule.exports = LexicalLink;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGluay9MZXhpY2FsTGluay5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLG9CQUFvQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsbUZBQXNCLElBQUksQ0FBZ0M7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9saW5rL0xleGljYWxMaW5rLmpzP2VlMmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxMaW5rID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxMaW5rLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsTGluay5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbExpbms7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/link/LexicalLink.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/list/LexicalList.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/list/LexicalList.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\n\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n\n    return depth;\n  }\n\n  return depth;\n}\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\n\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n\n  let parent = list;\n\n  while (parent !== null) {\n    parent = parent.getParent();\n\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n\n  return list;\n}\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\n\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n\n  return listItemNodes;\n}\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\n\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\n\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n\n    emptyListPtr = parent;\n  }\n\n  emptyListPtr.remove();\n}\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\n\nfunction wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\nfunction $getListItemValue(listItem) {\n  const list = listItem.getParent();\n  let value = 1;\n\n  if (list != null) {\n    if (!$isListNode(list)) {\n      {\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\n      }\n    } else {\n      value = list.getStart();\n    }\n  }\n\n  const siblings = listItem.getPreviousSiblings();\n\n  for (let i = 0; i < siblings.length; i++) {\n    const sibling = siblings[i];\n\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n      value++;\n    }\n  }\n\n  return value;\n}\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\n\n\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n\n          if (lexical.$isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n\n        return;\n      } else {\n        const handled = new Set();\n\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\n            createListOrMerge(node, listType);\n            continue;\n          }\n\n          if (lexical.$isLeafNode(node)) {\n            let parent = node.getParent();\n\n            while (parent != null) {\n              const parentKey = parent.getKey();\n\n              if ($isListNode(parent)) {\n                if (!handled.has(parentKey)) {\n                  const newListNode = $createListNode(listType);\n                  append(newListNode, parent.getChildren());\n                  parent.replace(newListNode);\n                  updateChildrenListItemValue(newListNode);\n                  handled.add(parentKey);\n                }\n\n                break;\n              } else {\n                const nextParent = parent.getParent();\n\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                  handled.add(parentKey);\n                  createListOrMerge(parent, listType);\n                  break;\n                }\n\n                parent = nextParent;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\n\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove(); // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    updateChildrenListItemValue(list);\n    return list;\n  }\n}\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\n\n\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n\n  const toMerge = list2.getChildren();\n\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n    updateChildrenListItemValue(list1);\n  }\n\n  list2.remove();\n}\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\n\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isLeafNode(node)) {\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n\n        for (const listItemNode of listItems) {\n          const paragraph = lexical.$createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph; // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n\n          listItemNode.remove();\n        }\n\n        listNode.remove();\n      }\n    }\n  });\n}\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. If only certain children should be updated, they\n * can be passed optionally in an array.\n * @param list - The list whose children are updated.\n * @param children - An array of the children to be updated.\n */\n\nfunction updateChildrenListItemValue(list, children) {\n  const childrenOrExisting = children || list.getChildren();\n\n  if (childrenOrExisting !== undefined) {\n    for (let i = 0; i < childrenOrExisting.length; i++) {\n      const child = childrenOrExisting[i];\n\n      if ($isListItemNode(child)) {\n        const prevValue = child.getValue();\n        const nextValue = $getListItemValue(child);\n\n        if (prevValue !== nextValue) {\n          child.setValue(nextValue);\n        }\n      }\n    }\n  }\n}\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\n\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n\n  const parent = listItemNode.getParent(); // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling(); // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      updateChildrenListItemValue(innerList);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n\n      updateChildrenListItemValue(newList);\n    }\n  }\n\n  if ($isListNode(parent)) {\n    updateChildrenListItemValue(parent);\n  }\n}\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\n\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined; // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      } // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings()); // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem); // replace the grandparent list item (now between the siblings) with the outdented list item.\n\n      grandparentListItem.replace(listItemNode);\n    }\n\n    updateChildrenListItemValue(parentList);\n    updateChildrenListItemValue(greatGrandparentList);\n  }\n}\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\n\nfunction $handleListInsertParagraph() {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  } // Only run this code on empty list items\n\n\n  const anchor = selection.anchor.getNode();\n\n  if (!$isListItemNode(anchor) || anchor.getTextContent() !== '') {\n    return false;\n  }\n\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n\n  const grandparent = parent.getParent();\n  let replacementNode;\n\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\n    replacementNode = lexical.$createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n\n    if (lexical.$isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  } // Don't leave hanging nested empty lists\n\n\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'listitem';\n  }\n\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    } // @ts-expect-error - this is always HTMLListItemElement\n\n\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static transform() {\n    return node => {\n      const parent = node.getParent();\n\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createListItemNode();\n    node.setChecked(serializedNode.checked);\n    node.setValue(serializedNode.value);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n\n    return this;\n  }\n\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) return replaceWithNode;\n\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n\n    if (includeChildren) {\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n\n    this.remove();\n\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n\n    return replaceWithNode;\n  }\n\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n\n    const siblings = this.getNextSiblings();\n\n    if ($isListItemNode(node)) {\n      const after = super.insertAfter(node, restoreSelection);\n      const afterListNode = node.getParentOrThrow();\n\n      if ($isListNode(afterListNode)) {\n        updateChildrenListItemValue(afterListNode);\n      }\n\n      return after;\n    } // Attempt to merge if the list is of the same type.\n\n\n    if ($isListNode(node)) {\n      let child = node;\n      const children = node.getChildren();\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        child = children[i];\n        this.insertAfter(child, restoreSelection);\n      }\n\n      return child;\n    } // Otherwise, split the list\n    // Split the lists and insert the node in between them\n\n\n    listNode.insertAfter(node, restoreSelection);\n\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n\n    return node;\n  }\n\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    } else if (nextSibling) {\n      const parent = nextSibling.getParent();\n\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n      }\n    }\n  }\n\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart(selection) {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove(); // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n\n    return true;\n  }\n\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return this.getLatest().__indent;\n    } // ListItemNode should always have a ListNode for a parent.\n\n\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n\n    return indentLevel;\n  }\n\n  setIndent(indent) {\n    if (!(typeof indent === 'number' && indent > -1)) {\n      throw Error(`Invalid indent value.`);\n    }\n\n    let currentIndent = this.getIndent();\n\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n\n    return this;\n  }\n\n  insertBefore(nodeToInsert) {\n    if ($isListItemNode(nodeToInsert)) {\n      const parent = this.getParentOrThrow();\n\n      if ($isListNode(parent)) {\n        const siblings = this.getNextSiblings();\n        updateChildrenListItemValue(parent, siblings);\n      }\n    }\n\n    return super.insertBefore(nodeToInsert);\n  }\n\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n\n  canMergeWith(node) {\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\n  }\n\n  extractWithChild(child, selection) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n\n  isParentRequired() {\n    return true;\n  }\n\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n\n}\n\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n\n  if (listItemClassName !== undefined) {\n    const listItemClasses = listItemClassName.split(' ');\n    classesToAdd.push(...listItemClasses);\n  }\n\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\n\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\n\nfunction convertListItemElement(domNode) {\n  const checked = utils.isHTMLElement(domNode) && domNode.getAttribute('aria-checked') === 'true';\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\n\n\nfunction $createListItemNode(checked) {\n  return lexical.$applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\n\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'list';\n  }\n\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n\n  constructor(listType, start, key) {\n    super(key);\n\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n\n  getTag() {\n    return this.__tag;\n  }\n\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n  }\n\n  getListType() {\n    return this.__listType;\n  }\n\n  getStart() {\n    return this.__start;\n  } // View\n\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    } // @ts-expect-error Internal field.\n\n\n    dom.__lexicalListType = this.__listType;\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if (lexical.$isElementNode(currentNode)) {\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n\n        super.append(listItemNode);\n      }\n    }\n\n    updateChildrenListItemValue(this);\n    return this;\n  }\n\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n\n}\n\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n\n    if (listLevelClassName !== undefined) {\n      const listItemClasses = listLevelClassName.split(' ');\n      classesToAdd.push(...listItemClasses);\n\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = nestedListClassName.split(' ');\n\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\n\n\nfunction normalizeChildren(nodes) {\n  const normalizedListItems = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push(wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push(wrapInListItem(node));\n    }\n  }\n\n  return normalizedListItems;\n}\n\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (utils.isHTMLElement(domNode) && domNode.getAttribute('__lexicallisttype') === 'check') {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n\n  return {\n    after: normalizeChildren,\n    node\n  };\n}\n\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\n\nfunction $createListNode(listType, start = 1) {\n  return lexical.$applyNodeReplacement(new ListNode(listType, start));\n}\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\n\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/** @module @lexical/list */\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = lexical.createCommand('REMOVE_LIST_COMMAND');\n\nexports.$createListItemNode = $createListItemNode;\nexports.$createListNode = $createListNode;\nexports.$getListDepth = $getListDepth;\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\nexports.$isListItemNode = $isListItemNode;\nexports.$isListNode = $isListNode;\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\nexports.ListItemNode = ListItemNode;\nexports.ListNode = ListNode;\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\nexports.insertList = insertList;\nexports.removeList = removeList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGlzdC9MZXhpY2FsTGlzdC5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsd0JBQXdCLGtCQUFrQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixrQkFBa0I7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0M7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrR0FBa0c7O0FBRWxHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLFdBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIsa0NBQWtDO0FBQ2xDLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkIsaUNBQWlDO0FBQ2pDLG1DQUFtQztBQUNuQyxxQ0FBcUM7QUFDckMsb0JBQW9CO0FBQ3BCLGdCQUFnQjtBQUNoQiwyQkFBMkI7QUFDM0Isa0JBQWtCO0FBQ2xCLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpc3QvTGV4aWNhbExpc3QuZGV2LmpzPzNkMzUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQGxleGljYWwvdXRpbHMnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuLyoqXG4gKiBDaGVja3MgdGhlIGRlcHRoIG9mIGxpc3ROb2RlIGZyb20gdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSBsaXN0Tm9kZSAtIFRoZSBMaXN0Tm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVGhlIGRlcHRoIG9mIHRoZSBMaXN0Tm9kZS5cbiAqL1xuXG5mdW5jdGlvbiAkZ2V0TGlzdERlcHRoKGxpc3ROb2RlKSB7XG4gIGxldCBkZXB0aCA9IDE7XG4gIGxldCBwYXJlbnQgPSBsaXN0Tm9kZS5nZXRQYXJlbnQoKTtcblxuICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKHBhcmVudCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudExpc3QgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG5cbiAgICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnRMaXN0KSkge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnRMaXN0LmdldFBhcmVudCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgQSBMaXN0SXRlbU5vZGUgbXVzdCBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZXB0aDtcbiAgfVxuXG4gIHJldHVybiBkZXB0aDtcbn1cbi8qKlxuICogRmluZHMgdGhlIG5lYXJlc3QgYW5jZXN0cmFsIExpc3ROb2RlIGFuZCByZXR1cm5zIGl0LCB0aHJvd3MgYW4gaW52YXJpYW50IGlmIGxpc3RJdGVtIGlzIG5vdCBhIExpc3RJdGVtTm9kZS5cbiAqIEBwYXJhbSBsaXN0SXRlbSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBUaGUgTGlzdE5vZGUgZm91bmQuXG4gKi9cblxuZnVuY3Rpb24gJGdldFRvcExpc3ROb2RlKGxpc3RJdGVtKSB7XG4gIGxldCBsaXN0ID0gbGlzdEl0ZW0uZ2V0UGFyZW50KCk7XG5cbiAgaWYgKCEkaXNMaXN0Tm9kZShsaXN0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBBIExpc3RJdGVtTm9kZSBtdXN0IGhhdmUgYSBMaXN0Tm9kZSBmb3IgYSBwYXJlbnQuYCk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHBhcmVudCA9IGxpc3Q7XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcblxuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICBsaXN0ID0gcGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaXN0O1xufVxuLyoqXG4gKiBBIHJlY3Vyc2l2ZSBEZXB0aC1GaXJzdCBTZWFyY2ggKFBvc3RvcmRlciBUcmF2ZXJzYWwpIHRoYXQgZmluZHMgYWxsIG9mIGEgbm9kZSdzIGNoaWxkcmVuXG4gKiB0aGF0IGFyZSBvZiB0eXBlIExpc3RJdGVtTm9kZSBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5LlxuICogQHBhcmFtIG5vZGUgLSBUaGUgTGlzdE5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaC5cbiAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIG5vZGVzIG9mIHR5cGUgTGlzdEl0ZW1Ob2RlIGZvdW5kLlxuICovXG4vLyBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSAkZ2V0QWxsQ2hpbGRyZW5PZlR5cGVcblxuZnVuY3Rpb24gJGdldEFsbExpc3RJdGVtcyhub2RlKSB7XG4gIGxldCBsaXN0SXRlbU5vZGVzID0gW107XG4gIGNvbnN0IGxpc3RDaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKS5maWx0ZXIoJGlzTGlzdEl0ZW1Ob2RlKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpc3RJdGVtTm9kZSA9IGxpc3RDaGlsZHJlbltpXTtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gbGlzdEl0ZW1Ob2RlLmdldEZpcnN0Q2hpbGQoKTtcblxuICAgIGlmICgkaXNMaXN0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgbGlzdEl0ZW1Ob2RlcyA9IGxpc3RJdGVtTm9kZXMuY29uY2F0KCRnZXRBbGxMaXN0SXRlbXMoZmlyc3RDaGlsZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0SXRlbU5vZGVzLnB1c2gobGlzdEl0ZW1Ob2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGlzdEl0ZW1Ob2Rlcztcbn1cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgcGFzc2VkIG5vZGUgaXMgYSBMaXN0SXRlbU5vZGUgYW5kIGhhcyBhIExpc3ROb2RlIGFzIGEgY2hpbGQuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGEgTGlzdEl0ZW1Ob2RlIGFuZCBoYXMgYSBMaXN0Tm9kZSBjaGlsZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzTmVzdGVkTGlzdE5vZGUobm9kZSkge1xuICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpICYmICRpc0xpc3ROb2RlKG5vZGUuZ2V0Rmlyc3RDaGlsZCgpKTtcbn1cbi8qKlxuICogVGFrZXMgYSBkZWVwbHkgbmVzdGVkIExpc3ROb2RlIG9yIExpc3RJdGVtTm9kZSBhbmQgdHJhdmVyc2VzIHVwIHRoZSBicmFuY2ggdG8gZGVsZXRlIHRoZSBmaXJzdFxuICogYW5jZXN0cmFsIExpc3ROb2RlICh3aGljaCBjb3VsZCBiZSB0aGUgcm9vdCBMaXN0Tm9kZSkgb3IgTGlzdEl0ZW1Ob2RlIHdpdGggc2libGluZ3MsIGVzc2VudGlhbGx5XG4gKiBicmluZ2luZyB0aGUgZGVlcGx5IG5lc3RlZCBub2RlIHVwIHRoZSBicmFuY2ggb25jZS4gV291bGQgcmVtb3ZlIHN1Ymxpc3QgaWYgaXQgaGFzIHNpYmxpbmdzLlxuICogU2hvdWxkIG5vdCBicmVhayBMaXN0SXRlbSAtPiBMaXN0IC0+IExpc3RJdGVtIGNoYWluIGFzIGVtcHR5IExpc3QvSXRlbU5vZGVzIHNob3VsZCBiZSByZW1vdmVkIG9uIC5yZW1vdmUoKS5cbiAqIEBwYXJhbSBzdWJsaXN0IC0gVGhlIG5lc3RlZCBMaXN0Tm9kZSBvciBMaXN0SXRlbU5vZGUgdG8gYmUgYnJvdWdodCB1cCB0aGUgYnJhbmNoLlxuICovXG5cbmZ1bmN0aW9uICRyZW1vdmVIaWdoZXN0RW1wdHlMaXN0UGFyZW50KHN1Ymxpc3QpIHtcbiAgLy8gTm9kZXMgbWF5IGJlIHJlcGVhdGVkbHkgaW5kZW50ZWQsIHRvIGNyZWF0ZSBkZWVwbHkgbmVzdGVkIGxpc3RzIHRoYXQgZWFjaFxuICAvLyBjb250YWluIGp1c3Qgb25lIGJ1bGxldC5cbiAgLy8gT3VyIGdvYWwgaXMgdG8gcmVtb3ZlIHRoZXNlIChlbXB0eSkgZGVlcGx5IG5lc3RlZCBsaXN0cy4gVGhlIGVhc2llc3RcbiAgLy8gd2F5IHRvIGRvIHRoYXQgaXMgY3Jhd2wgYmFjayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGEgbm9kZSB0aGF0IGhhcyBzaWJsaW5nc1xuICAvLyAoZS5nLiBpcyBhY3R1YWxseSBwYXJ0IG9mIHRoZSBsaXN0IGNvbnRlbnRzKSBhbmQgZGVsZXRlIHRoYXQsIG9yIGRlbGV0ZVxuICAvLyB0aGUgcm9vdCBvZiB0aGUgbGlzdCAoaWYgbm8gbGlzdCBub2RlcyBoYXZlIHNpYmxpbmdzLilcbiAgbGV0IGVtcHR5TGlzdFB0ciA9IHN1Ymxpc3Q7XG5cbiAgd2hpbGUgKGVtcHR5TGlzdFB0ci5nZXROZXh0U2libGluZygpID09IG51bGwgJiYgZW1wdHlMaXN0UHRyLmdldFByZXZpb3VzU2libGluZygpID09IG51bGwpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBlbXB0eUxpc3RQdHIuZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAocGFyZW50ID09IG51bGwgfHwgISgkaXNMaXN0SXRlbU5vZGUoZW1wdHlMaXN0UHRyKSB8fCAkaXNMaXN0Tm9kZShlbXB0eUxpc3RQdHIpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZW1wdHlMaXN0UHRyID0gcGFyZW50O1xuICB9XG5cbiAgZW1wdHlMaXN0UHRyLnJlbW92ZSgpO1xufVxuLyoqXG4gKiBXcmFwcyBhIG5vZGUgaW50byBhIExpc3RJdGVtTm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgd3JhcHBlZCBpbnRvIGEgTGlzdEl0ZW1Ob2RlXG4gKiBAcmV0dXJucyBUaGUgTGlzdEl0ZW1Ob2RlIHdoaWNoIHRoZSBwYXNzZWQgbm9kZSBpcyB3cmFwcGVkIGluLlxuICovXG5cbmZ1bmN0aW9uIHdyYXBJbkxpc3RJdGVtKG5vZGUpIHtcbiAgY29uc3QgbGlzdEl0ZW1XcmFwcGVyID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICByZXR1cm4gbGlzdEl0ZW1XcmFwcGVyLmFwcGVuZChub2RlKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiAkaXNTZWxlY3RpbmdFbXB0eUxpc3RJdGVtKGFuY2hvck5vZGUsIG5vZGVzKSB7XG4gIHJldHVybiAkaXNMaXN0SXRlbU5vZGUoYW5jaG9yTm9kZSkgJiYgKG5vZGVzLmxlbmd0aCA9PT0gMCB8fCBub2Rlcy5sZW5ndGggPT09IDEgJiYgYW5jaG9yTm9kZS5pcyhub2Rlc1swXSkgJiYgYW5jaG9yTm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCk7XG59XG5cbmZ1bmN0aW9uICRnZXRMaXN0SXRlbVZhbHVlKGxpc3RJdGVtKSB7XG4gIGNvbnN0IGxpc3QgPSBsaXN0SXRlbS5nZXRQYXJlbnQoKTtcbiAgbGV0IHZhbHVlID0gMTtcblxuICBpZiAobGlzdCAhPSBudWxsKSB7XG4gICAgaWYgKCEkaXNMaXN0Tm9kZShsaXN0KSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgJGdldExpc3RJdGVtVmFsdWU6IGxpc3Qgbm9kZSBpcyBub3QgcGFyZW50IG9mIGxpc3QgaXRlbSBub2RlYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gbGlzdC5nZXRTdGFydCgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNpYmxpbmdzID0gbGlzdEl0ZW0uZ2V0UHJldmlvdXNTaWJsaW5ncygpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2libGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XG5cbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKHNpYmxpbmcpICYmICEkaXNMaXN0Tm9kZShzaWJsaW5nLmdldEZpcnN0Q2hpbGQoKSkpIHtcbiAgICAgIHZhbHVlKys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBJbnNlcnRzIGEgbmV3IExpc3ROb2RlLiBJZiB0aGUgc2VsZWN0aW9uJ3MgYW5jaG9yIG5vZGUgaXMgYW4gZW1wdHkgTGlzdEl0ZW1Ob2RlIGFuZCBpcyBhIGNoaWxkIG9mXG4gKiB0aGUgcm9vdC9zaGFkb3cgcm9vdCwgaXQgd2lsbCByZXBsYWNlIHRoZSBMaXN0SXRlbU5vZGUgd2l0aCBhIExpc3ROb2RlIGFuZCB0aGUgb2xkIExpc3RJdGVtTm9kZS5cbiAqIE90aGVyd2lzZSBpdCB3aWxsIHJlcGxhY2UgaXRzIHBhcmVudCB3aXRoIGEgbmV3IExpc3ROb2RlIGFuZCByZS1pbnNlcnQgdGhlIExpc3RJdGVtTm9kZSBhbmQgYW55IHByZXZpb3VzIGNoaWxkcmVuLlxuICogSWYgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBub2RlIGlzIG5vdCBhbiBlbXB0eSBMaXN0SXRlbU5vZGUsIGl0IHdpbGwgYWRkIGEgbmV3IExpc3ROb2RlIG9yIG1lcmdlIGFuIGV4aXN0aW5nIExpc3ROb2RlLFxuICogdW5sZXNzIHRoZSB0aGUgbm9kZSBpcyBhIGxlYWYgbm9kZSwgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGF0dGVtcHQgdG8gZmluZCBhIExpc3ROb2RlIHVwIHRoZSBicmFuY2ggYW5kIHJlcGxhY2UgaXQgd2l0aFxuICogYSBuZXcgTGlzdE5vZGUsIG9yIGNyZWF0ZSBhIG5ldyBMaXN0Tm9kZSBhdCB0aGUgbmVhcmVzdCByb290L3NoYWRvdyByb290LlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBsaXN0VHlwZSAtIFRoZSB0eXBlIG9mIGxpc3QsIFwibnVtYmVyXCIgfCBcImJ1bGxldFwiIHwgXCJjaGVja1wiLlxuICovXG5cblxuZnVuY3Rpb24gaW5zZXJ0TGlzdChlZGl0b3IsIGxpc3RUeXBlKSB7XG4gIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZVBhcmVudCA9IGFuY2hvck5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgICAgIGlmICgkaXNTZWxlY3RpbmdFbXB0eUxpc3RJdGVtKGFuY2hvck5vZGUsIG5vZGVzKSkge1xuICAgICAgICBjb25zdCBsaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcblxuICAgICAgICBpZiAobGV4aWNhbC4kaXNSb290T3JTaGFkb3dSb290KGFuY2hvck5vZGVQYXJlbnQpKSB7XG4gICAgICAgICAgYW5jaG9yTm9kZS5yZXBsYWNlKGxpc3QpO1xuICAgICAgICAgIGNvbnN0IGxpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuXG4gICAgICAgICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgIGxpc3RJdGVtLnNldEZvcm1hdChhbmNob3JOb2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICAgICAgICBsaXN0SXRlbS5zZXRJbmRlbnQoYW5jaG9yTm9kZS5nZXRJbmRlbnQoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdC5hcHBlbmQobGlzdEl0ZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKCRpc0xpc3RJdGVtTm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGFuY2hvck5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICAgIGFwcGVuZChsaXN0LCBwYXJlbnQuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICAgICAgcGFyZW50LnJlcGxhY2UobGlzdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBoYW5kbGVkID0gbmV3IFNldCgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgICAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmlzRW1wdHkoKSAmJiAhaGFuZGxlZC5oYXMobm9kZS5nZXRLZXkoKSkpIHtcbiAgICAgICAgICAgIGNyZWF0ZUxpc3RPck1lcmdlKG5vZGUsIGxpc3RUeXBlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsZXhpY2FsLiRpc0xlYWZOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcmVudEtleSA9IHBhcmVudC5nZXRLZXkoKTtcblxuICAgICAgICAgICAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlZC5oYXMocGFyZW50S2V5KSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbmV3TGlzdE5vZGUgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgICAgICAgICAgICAgICAgYXBwZW5kKG5ld0xpc3ROb2RlLCBwYXJlbnQuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICAgICAgICAgICAgICBwYXJlbnQucmVwbGFjZShuZXdMaXN0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUobmV3TGlzdE5vZGUpO1xuICAgICAgICAgICAgICAgICAgaGFuZGxlZC5hZGQocGFyZW50S2V5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxleGljYWwuJGlzUm9vdE9yU2hhZG93Um9vdChuZXh0UGFyZW50KSAmJiAhaGFuZGxlZC5oYXMocGFyZW50S2V5KSkge1xuICAgICAgICAgICAgICAgICAgaGFuZGxlZC5hZGQocGFyZW50S2V5KTtcbiAgICAgICAgICAgICAgICAgIGNyZWF0ZUxpc3RPck1lcmdlKHBhcmVudCwgbGlzdFR5cGUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbmV4dFBhcmVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZChub2RlLCBub2Rlc1RvQXBwZW5kKSB7XG4gIG5vZGUuc3BsaWNlKG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksIDAsIG5vZGVzVG9BcHBlbmQpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaXN0T3JNZXJnZShub2RlLCBsaXN0VHlwZSkge1xuICBpZiAoJGlzTGlzdE5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGNvbnN0IHByZXZpb3VzU2libGluZyA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gIGNvbnN0IG5leHRTaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICBjb25zdCBsaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgbGlzdEl0ZW0uc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgbGlzdEl0ZW0uc2V0SW5kZW50KG5vZGUuZ2V0SW5kZW50KCkpO1xuICBhcHBlbmQobGlzdEl0ZW0sIG5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG5cbiAgaWYgKCRpc0xpc3ROb2RlKHByZXZpb3VzU2libGluZykgJiYgbGlzdFR5cGUgPT09IHByZXZpb3VzU2libGluZy5nZXRMaXN0VHlwZSgpKSB7XG4gICAgcHJldmlvdXNTaWJsaW5nLmFwcGVuZChsaXN0SXRlbSk7XG4gICAgbm9kZS5yZW1vdmUoKTsgLy8gaWYgdGhlIHNhbWUgdHlwZSBvZiBsaXN0IGlzIG9uIGJvdGggc2lkZXMsIG1lcmdlIHRoZW0uXG5cbiAgICBpZiAoJGlzTGlzdE5vZGUobmV4dFNpYmxpbmcpICYmIGxpc3RUeXBlID09PSBuZXh0U2libGluZy5nZXRMaXN0VHlwZSgpKSB7XG4gICAgICBhcHBlbmQocHJldmlvdXNTaWJsaW5nLCBuZXh0U2libGluZy5nZXRDaGlsZHJlbigpKTtcbiAgICAgIG5leHRTaWJsaW5nLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2aW91c1NpYmxpbmc7XG4gIH0gZWxzZSBpZiAoJGlzTGlzdE5vZGUobmV4dFNpYmxpbmcpICYmIGxpc3RUeXBlID09PSBuZXh0U2libGluZy5nZXRMaXN0VHlwZSgpKSB7XG4gICAgbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZE9yVGhyb3coKS5pbnNlcnRCZWZvcmUobGlzdEl0ZW0pO1xuICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgcmV0dXJuIG5leHRTaWJsaW5nO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgIGxpc3QuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICBub2RlLnJlcGxhY2UobGlzdCk7XG4gICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKGxpc3QpO1xuICAgIHJldHVybiBsaXN0O1xuICB9XG59XG4vKipcbiAqIEEgcmVjdXJzaXZlIGZ1bmN0aW9uIHRoYXQgZ29lcyB0aHJvdWdoIGVhY2ggbGlzdCBhbmQgdGhlaXIgY2hpbGRyZW4sIGluY2x1ZGluZyBuZXN0ZWQgbGlzdHMsXG4gKiBhcHBlbmRpbmcgbGlzdDIgY2hpbGRyZW4gYWZ0ZXIgbGlzdDEgY2hpbGRyZW4gYW5kIHVwZGF0aW5nIExpc3RJdGVtTm9kZSB2YWx1ZXMuXG4gKiBAcGFyYW0gbGlzdDEgLSBUaGUgZmlyc3QgbGlzdCB0byBiZSBtZXJnZWQuXG4gKiBAcGFyYW0gbGlzdDIgLSBUaGUgc2Vjb25kIGxpc3QgdG8gYmUgbWVyZ2VkLlxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VMaXN0cyhsaXN0MSwgbGlzdDIpIHtcbiAgY29uc3QgbGlzdEl0ZW0xID0gbGlzdDEuZ2V0TGFzdENoaWxkKCk7XG4gIGNvbnN0IGxpc3RJdGVtMiA9IGxpc3QyLmdldEZpcnN0Q2hpbGQoKTtcblxuICBpZiAobGlzdEl0ZW0xICYmIGxpc3RJdGVtMiAmJiBpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtMSkgJiYgaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbTIpKSB7XG4gICAgbWVyZ2VMaXN0cyhsaXN0SXRlbTEuZ2V0Rmlyc3RDaGlsZCgpLCBsaXN0SXRlbTIuZ2V0Rmlyc3RDaGlsZCgpKTtcbiAgICBsaXN0SXRlbTIucmVtb3ZlKCk7XG4gIH1cblxuICBjb25zdCB0b01lcmdlID0gbGlzdDIuZ2V0Q2hpbGRyZW4oKTtcblxuICBpZiAodG9NZXJnZS5sZW5ndGggPiAwKSB7XG4gICAgbGlzdDEuYXBwZW5kKC4uLnRvTWVyZ2UpO1xuICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShsaXN0MSk7XG4gIH1cblxuICBsaXN0Mi5yZW1vdmUoKTtcbn1cbi8qKlxuICogU2VhcmNoZXMgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdHJhbCBMaXN0Tm9kZSBhbmQgcmVtb3ZlcyBpdC4gSWYgc2VsZWN0aW9uIGlzIGFuIGVtcHR5IExpc3RJdGVtTm9kZVxuICogaXQgd2lsbCByZW1vdmUgdGhlIHdob2xlIGxpc3QsIGluY2x1ZGluZyB0aGUgTGlzdEl0ZW1Ob2RlLiBGb3IgZWFjaCBMaXN0SXRlbU5vZGUgaW4gdGhlIExpc3ROb2RlLFxuICogcmVtb3ZlTGlzdCB3aWxsIGFsc28gZ2VuZXJhdGUgbmV3IFBhcmFncmFwaE5vZGVzIGluIHRoZSByZW1vdmVkIExpc3ROb2RlJ3MgcGxhY2UuIEFueSBjaGlsZCBub2RlXG4gKiBpbnNpZGUgYSBMaXN0SXRlbU5vZGUgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgbmV3IFBhcmFncmFwaE5vZGVzLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVMaXN0KGVkaXRvcikge1xuICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGxpc3ROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG5cbiAgICAgIGlmICgkaXNTZWxlY3RpbmdFbXB0eUxpc3RJdGVtKGFuY2hvck5vZGUsIG5vZGVzKSkge1xuICAgICAgICBsaXN0Tm9kZXMuYWRkKCRnZXRUb3BMaXN0Tm9kZShhbmNob3JOb2RlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICAgICAgaWYgKGxleGljYWwuJGlzTGVhZk5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RJdGVtTm9kZSA9IHV0aWxzLiRnZXROZWFyZXN0Tm9kZU9mVHlwZShub2RlLCBMaXN0SXRlbU5vZGUpO1xuXG4gICAgICAgICAgICBpZiAobGlzdEl0ZW1Ob2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbGlzdE5vZGVzLmFkZCgkZ2V0VG9wTGlzdE5vZGUobGlzdEl0ZW1Ob2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgbGlzdE5vZGUgb2YgbGlzdE5vZGVzKSB7XG4gICAgICAgIGxldCBpbnNlcnRpb25Qb2ludCA9IGxpc3ROb2RlO1xuICAgICAgICBjb25zdCBsaXN0SXRlbXMgPSAkZ2V0QWxsTGlzdEl0ZW1zKGxpc3ROb2RlKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGxpc3RJdGVtTm9kZSBvZiBsaXN0SXRlbXMpIHtcbiAgICAgICAgICBjb25zdCBwYXJhZ3JhcGggPSBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAgICAgYXBwZW5kKHBhcmFncmFwaCwgbGlzdEl0ZW1Ob2RlLmdldENoaWxkcmVuKCkpO1xuICAgICAgICAgIGluc2VydGlvblBvaW50Lmluc2VydEFmdGVyKHBhcmFncmFwaCk7XG4gICAgICAgICAgaW5zZXJ0aW9uUG9pbnQgPSBwYXJhZ3JhcGg7IC8vIFdoZW4gdGhlIGFuY2hvciBhbmQgZm9jdXMgZmFsbCBvbiB0aGUgdGV4dE5vZGVcbiAgICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIHRvIGNoYW5nZSB0aGUgc2VsZWN0aW9uIGJlY2F1c2UgdGhlIHRleHROb2RlIHdpbGwgYmUgYXBwZW5kZWQgdG9cbiAgICAgICAgICAvLyB0aGUgbmV3bHkgZ2VuZXJhdGVkIHBhcmFncmFwaC5cbiAgICAgICAgICAvLyBXaGVuIHNlbGVjdGlvbiBpcyBpbiBlbXB0eSBuZXN0ZWQgbGlzdCBpdGVtLCBzZWxlY3Rpb24gaXMgYWN0dWFsbHkgb24gdGhlIGxpc3RJdGVtTm9kZS5cbiAgICAgICAgICAvLyBXaGVuIHRoZSBjb3JyZXNwb25kaW5nIGxpc3RJdGVtTm9kZSBpcyBkZWxldGVkIGFuZCByZXBsYWNlZCBieSB0aGUgbmV3bHkgZ2VuZXJhdGVkIHBhcmFncmFwaFxuICAgICAgICAgIC8vIHdlIHNob3VsZCBtYW51YWxseSBzZXQgdGhlIHNlbGVjdGlvbidzIGZvY3VzIGFuZCBhbmNob3IgdG8gdGhlIG5ld2x5IGdlbmVyYXRlZCBwYXJhZ3JhcGguXG5cbiAgICAgICAgICBpZiAobGlzdEl0ZW1Ob2RlLl9fa2V5ID09PSBzZWxlY3Rpb24uYW5jaG9yLmtleSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uLmFuY2hvci5zZXQocGFyYWdyYXBoLmdldEtleSgpLCAwLCAnZWxlbWVudCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsaXN0SXRlbU5vZGUuX19rZXkgPT09IHNlbGVjdGlvbi5mb2N1cy5rZXkpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5mb2N1cy5zZXQocGFyYWdyYXBoLmdldEtleSgpLCAwLCAnZWxlbWVudCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RJdGVtTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3ROb2RlLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIFRha2VzIHRoZSB2YWx1ZSBvZiBhIGNoaWxkIExpc3RJdGVtTm9kZSBhbmQgbWFrZXMgaXQgdGhlIHZhbHVlIHRoZSBMaXN0SXRlbU5vZGVcbiAqIHNob3VsZCBiZSBpZiBpdCBpc24ndCBhbHJlYWR5LiBJZiBvbmx5IGNlcnRhaW4gY2hpbGRyZW4gc2hvdWxkIGJlIHVwZGF0ZWQsIHRoZXlcbiAqIGNhbiBiZSBwYXNzZWQgb3B0aW9uYWxseSBpbiBhbiBhcnJheS5cbiAqIEBwYXJhbSBsaXN0IC0gVGhlIGxpc3Qgd2hvc2UgY2hpbGRyZW4gYXJlIHVwZGF0ZWQuXG4gKiBAcGFyYW0gY2hpbGRyZW4gLSBBbiBhcnJheSBvZiB0aGUgY2hpbGRyZW4gdG8gYmUgdXBkYXRlZC5cbiAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUobGlzdCwgY2hpbGRyZW4pIHtcbiAgY29uc3QgY2hpbGRyZW5PckV4aXN0aW5nID0gY2hpbGRyZW4gfHwgbGlzdC5nZXRDaGlsZHJlbigpO1xuXG4gIGlmIChjaGlsZHJlbk9yRXhpc3RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW5PckV4aXN0aW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuT3JFeGlzdGluZ1tpXTtcblxuICAgICAgaWYgKCRpc0xpc3RJdGVtTm9kZShjaGlsZCkpIHtcbiAgICAgICAgY29uc3QgcHJldlZhbHVlID0gY2hpbGQuZ2V0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gJGdldExpc3RJdGVtVmFsdWUoY2hpbGQpO1xuXG4gICAgICAgIGlmIChwcmV2VmFsdWUgIT09IG5leHRWYWx1ZSkge1xuICAgICAgICAgIGNoaWxkLnNldFZhbHVlKG5leHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQWRkcyBhbiBlbXB0eSBMaXN0Tm9kZS9MaXN0SXRlbU5vZGUgY2hhaW4gYXQgbGlzdEl0ZW1Ob2RlLCBzbyBhcyB0b1xuICogY3JlYXRlIGFuIGluZGVudCBlZmZlY3QuIFdvbid0IGluZGVudCBMaXN0SXRlbU5vZGVzIHRoYXQgaGF2ZSBhIExpc3ROb2RlIGFzXG4gKiBhIGNoaWxkLCBidXQgZG9lcyBtZXJnZSBzaWJsaW5nIExpc3RJdGVtTm9kZXMgaWYgb25lIGhhcyBhIG5lc3RlZCBMaXN0Tm9kZS5cbiAqIEBwYXJhbSBsaXN0SXRlbU5vZGUgLSBUaGUgTGlzdEl0ZW1Ob2RlIHRvIGJlIGluZGVudGVkLlxuICovXG5cbmZ1bmN0aW9uICRoYW5kbGVJbmRlbnQobGlzdEl0ZW1Ob2RlKSB7XG4gIC8vIGdvIHRocm91Z2ggZWFjaCBub2RlIGFuZCBkZWNpZGUgd2hlcmUgdG8gbW92ZSBpdC5cbiAgY29uc3QgcmVtb3ZlZCA9IG5ldyBTZXQoKTtcblxuICBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbU5vZGUpIHx8IHJlbW92ZWQuaGFzKGxpc3RJdGVtTm9kZS5nZXRLZXkoKSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYXJlbnQgPSBsaXN0SXRlbU5vZGUuZ2V0UGFyZW50KCk7IC8vIFdlIGNhbiBjYXN0IGJvdGggb2YgdGhlIGJlbG93IGBpc05lc3RlZExpc3ROb2RlYCBvbmx5IHJldHVybnMgYSBib29sZWFuIHR5cGUgaW5zdGVhZCBvZiBhIHVzZXItZGVmaW5lZCB0eXBlIGd1YXJkc1xuXG4gIGNvbnN0IG5leHRTaWJsaW5nID0gbGlzdEl0ZW1Ob2RlLmdldE5leHRTaWJsaW5nKCk7XG4gIGNvbnN0IHByZXZpb3VzU2libGluZyA9IGxpc3RJdGVtTm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTsgLy8gaWYgdGhlcmUgYXJlIG5lc3RlZCBsaXN0cyBvbiBlaXRoZXIgc2lkZSwgbWVyZ2UgdGhlbSBhbGwgdG9nZXRoZXIuXG5cbiAgaWYgKGlzTmVzdGVkTGlzdE5vZGUobmV4dFNpYmxpbmcpICYmIGlzTmVzdGVkTGlzdE5vZGUocHJldmlvdXNTaWJsaW5nKSkge1xuICAgIGNvbnN0IGlubmVyTGlzdCA9IHByZXZpb3VzU2libGluZy5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICBpZiAoJGlzTGlzdE5vZGUoaW5uZXJMaXN0KSkge1xuICAgICAgaW5uZXJMaXN0LmFwcGVuZChsaXN0SXRlbU5vZGUpO1xuICAgICAgY29uc3QgbmV4dElubmVyTGlzdCA9IG5leHRTaWJsaW5nLmdldEZpcnN0Q2hpbGQoKTtcblxuICAgICAgaWYgKCRpc0xpc3ROb2RlKG5leHRJbm5lckxpc3QpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbmV4dElubmVyTGlzdC5nZXRDaGlsZHJlbigpO1xuICAgICAgICBhcHBlbmQoaW5uZXJMaXN0LCBjaGlsZHJlbik7XG4gICAgICAgIG5leHRTaWJsaW5nLnJlbW92ZSgpO1xuICAgICAgICByZW1vdmVkLmFkZChuZXh0U2libGluZy5nZXRLZXkoKSk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShpbm5lckxpc3QpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc05lc3RlZExpc3ROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgIC8vIGlmIHRoZSBMaXN0SXRlbU5vZGUgaXMgbmV4dCB0byBhIG5lc3RlZCBMaXN0Tm9kZSwgbWVyZ2UgdGhlbVxuICAgIGNvbnN0IGlubmVyTGlzdCA9IG5leHRTaWJsaW5nLmdldEZpcnN0Q2hpbGQoKTtcblxuICAgIGlmICgkaXNMaXN0Tm9kZShpbm5lckxpc3QpKSB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkID0gaW5uZXJMaXN0LmdldEZpcnN0Q2hpbGQoKTtcblxuICAgICAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKGlubmVyTGlzdCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTmVzdGVkTGlzdE5vZGUocHJldmlvdXNTaWJsaW5nKSkge1xuICAgIGNvbnN0IGlubmVyTGlzdCA9IHByZXZpb3VzU2libGluZy5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICBpZiAoJGlzTGlzdE5vZGUoaW5uZXJMaXN0KSkge1xuICAgICAgaW5uZXJMaXN0LmFwcGVuZChsaXN0SXRlbU5vZGUpO1xuICAgICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKGlubmVyTGlzdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIG90aGVyd2lzZSwgd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgbmVzdGVkIExpc3ROb2RlXG4gICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG5ld0xpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgY29uc3QgbmV3TGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShwYXJlbnQuZ2V0TGlzdFR5cGUoKSk7XG4gICAgICBuZXdMaXN0SXRlbS5hcHBlbmQobmV3TGlzdCk7XG4gICAgICBuZXdMaXN0LmFwcGVuZChsaXN0SXRlbU5vZGUpO1xuXG4gICAgICBpZiAocHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIHByZXZpb3VzU2libGluZy5pbnNlcnRBZnRlcihuZXdMaXN0SXRlbSk7XG4gICAgICB9IGVsc2UgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgIG5leHRTaWJsaW5nLmluc2VydEJlZm9yZShuZXdMaXN0SXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuYXBwZW5kKG5ld0xpc3RJdGVtKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKG5ld0xpc3QpO1xuICAgIH1cbiAgfVxuXG4gIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKHBhcmVudCk7XG4gIH1cbn1cbi8qKlxuICogUmVtb3ZlcyBhbiBpbmRlbnQgYnkgcmVtb3ZpbmcgYW4gZW1wdHkgTGlzdE5vZGUvTGlzdEl0ZW1Ob2RlIGNoYWluLiBBbiBpbmRlbnRlZCBMaXN0SXRlbU5vZGVcbiAqIGhhcyBhIGdyZWF0IGdyYW5kcGFyZW50IG5vZGUgb2YgdHlwZSBMaXN0Tm9kZSwgd2hpY2ggaXMgd2hlcmUgdGhlIExpc3RJdGVtTm9kZSB3aWxsIHJlc2lkZVxuICogd2l0aGluIGFzIGEgY2hpbGQuXG4gKiBAcGFyYW0gbGlzdEl0ZW1Ob2RlIC0gVGhlIExpc3RJdGVtTm9kZSB0byByZW1vdmUgdGhlIGluZGVudCAob3V0ZGVudCkuXG4gKi9cblxuZnVuY3Rpb24gJGhhbmRsZU91dGRlbnQobGlzdEl0ZW1Ob2RlKSB7XG4gIC8vIGdvIHRocm91Z2ggZWFjaCBub2RlIGFuZCBkZWNpZGUgd2hlcmUgdG8gbW92ZSBpdC5cbiAgaWYgKGlzTmVzdGVkTGlzdE5vZGUobGlzdEl0ZW1Ob2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBhcmVudExpc3QgPSBsaXN0SXRlbU5vZGUuZ2V0UGFyZW50KCk7XG4gIGNvbnN0IGdyYW5kcGFyZW50TGlzdEl0ZW0gPSBwYXJlbnRMaXN0ID8gcGFyZW50TGlzdC5nZXRQYXJlbnQoKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgZ3JlYXRHcmFuZHBhcmVudExpc3QgPSBncmFuZHBhcmVudExpc3RJdGVtID8gZ3JhbmRwYXJlbnRMaXN0SXRlbS5nZXRQYXJlbnQoKSA6IHVuZGVmaW5lZDsgLy8gSWYgaXQgZG9lc24ndCBoYXZlIHRoZXNlIGFuY2VzdG9ycywgaXQncyBub3QgaW5kZW50ZWQuXG5cbiAgaWYgKCRpc0xpc3ROb2RlKGdyZWF0R3JhbmRwYXJlbnRMaXN0KSAmJiAkaXNMaXN0SXRlbU5vZGUoZ3JhbmRwYXJlbnRMaXN0SXRlbSkgJiYgJGlzTGlzdE5vZGUocGFyZW50TGlzdCkpIHtcbiAgICAvLyBpZiBpdCdzIHRoZSBmaXJzdCBjaGlsZCBpbiBpdCdzIHBhcmVudCBsaXN0LCBpbnNlcnQgaXQgaW50byB0aGVcbiAgICAvLyBncmVhdCBncmFuZHBhcmVudCBsaXN0IGJlZm9yZSB0aGUgZ3JhbmRwYXJlbnRcbiAgICBjb25zdCBmaXJzdENoaWxkID0gcGFyZW50TGlzdCA/IHBhcmVudExpc3QuZ2V0Rmlyc3RDaGlsZCgpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGxhc3RDaGlsZCA9IHBhcmVudExpc3QgPyBwYXJlbnRMaXN0LmdldExhc3RDaGlsZCgpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGxpc3RJdGVtTm9kZS5pcyhmaXJzdENoaWxkKSkge1xuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5pbnNlcnRCZWZvcmUobGlzdEl0ZW1Ob2RlKTtcblxuICAgICAgaWYgKHBhcmVudExpc3QuaXNFbXB0eSgpKSB7XG4gICAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0ucmVtb3ZlKCk7XG4gICAgICB9IC8vIGlmIGl0J3MgdGhlIGxhc3QgY2hpbGQgaW4gaXQncyBwYXJlbnQgbGlzdCwgaW5zZXJ0IGl0IGludG8gdGhlXG4gICAgICAvLyBncmVhdCBncmFuZHBhcmVudCBsaXN0IGFmdGVyIHRoZSBncmFuZHBhcmVudC5cblxuICAgIH0gZWxzZSBpZiAobGlzdEl0ZW1Ob2RlLmlzKGxhc3RDaGlsZCkpIHtcbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QWZ0ZXIobGlzdEl0ZW1Ob2RlKTtcblxuICAgICAgaWYgKHBhcmVudExpc3QuaXNFbXB0eSgpKSB7XG4gICAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0ucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSwgd2UgbmVlZCB0byBzcGxpdCB0aGUgc2libGluZ3MgaW50byB0d28gbmV3IG5lc3RlZCBsaXN0c1xuICAgICAgY29uc3QgbGlzdFR5cGUgPSBwYXJlbnRMaXN0LmdldExpc3RUeXBlKCk7XG4gICAgICBjb25zdCBwcmV2aW91c1NpYmxpbmdzTGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgICBjb25zdCBwcmV2aW91c1NpYmxpbmdzTGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgICBwcmV2aW91c1NpYmxpbmdzTGlzdEl0ZW0uYXBwZW5kKHByZXZpb3VzU2libGluZ3NMaXN0KTtcbiAgICAgIGxpc3RJdGVtTm9kZS5nZXRQcmV2aW91c1NpYmxpbmdzKCkuZm9yRWFjaChzaWJsaW5nID0+IHByZXZpb3VzU2libGluZ3NMaXN0LmFwcGVuZChzaWJsaW5nKSk7XG4gICAgICBjb25zdCBuZXh0U2libGluZ3NMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nc0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgICAgbmV4dFNpYmxpbmdzTGlzdEl0ZW0uYXBwZW5kKG5leHRTaWJsaW5nc0xpc3QpO1xuICAgICAgYXBwZW5kKG5leHRTaWJsaW5nc0xpc3QsIGxpc3RJdGVtTm9kZS5nZXROZXh0U2libGluZ3MoKSk7IC8vIHB1dCB0aGUgc2libGluZyBuZXN0ZWQgbGlzdHMgb24gZWl0aGVyIHNpZGUgb2YgdGhlIGdyYW5kcGFyZW50IGxpc3QgaXRlbSBpbiB0aGUgZ3JlYXQgZ3JhbmRwYXJlbnQuXG5cbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QmVmb3JlKHByZXZpb3VzU2libGluZ3NMaXN0SXRlbSk7XG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLmluc2VydEFmdGVyKG5leHRTaWJsaW5nc0xpc3RJdGVtKTsgLy8gcmVwbGFjZSB0aGUgZ3JhbmRwYXJlbnQgbGlzdCBpdGVtIChub3cgYmV0d2VlbiB0aGUgc2libGluZ3MpIHdpdGggdGhlIG91dGRlbnRlZCBsaXN0IGl0ZW0uXG5cbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0ucmVwbGFjZShsaXN0SXRlbU5vZGUpO1xuICAgIH1cblxuICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShwYXJlbnRMaXN0KTtcbiAgICB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUoZ3JlYXRHcmFuZHBhcmVudExpc3QpO1xuICB9XG59XG4vKipcbiAqIEF0dGVtcHRzIHRvIGluc2VydCBhIFBhcmFncmFwaE5vZGUgYXQgc2VsZWN0aW9uIGFuZCBzZWxlY3RzIHRoZSBuZXcgbm9kZS4gVGhlIHNlbGVjdGlvbiBtdXN0IGNvbnRhaW4gYSBMaXN0SXRlbU5vZGVcbiAqIG9yIGEgbm9kZSB0aGF0IGRvZXMgbm90IGFscmVhZHkgY29udGFpbiB0ZXh0LiBJZiBpdHMgZ3JhbmRwYXJlbnQgaXMgdGhlIHJvb3Qvc2hhZG93IHJvb3QsIGl0IHdpbGwgZ2V0IHRoZSBMaXN0Tm9kZVxuICogKHdoaWNoIHNob3VsZCBiZSB0aGUgcGFyZW50IG5vZGUpIGFuZCBpbnNlcnQgdGhlIFBhcmFncmFwaE5vZGUgYXMgYSBzaWJsaW5nIHRvIHRoZSBMaXN0Tm9kZS4gSWYgdGhlIExpc3ROb2RlIGlzXG4gKiBuZXN0ZWQgaW4gYSBMaXN0SXRlbU5vZGUgaW5zdGVhZCwgaXQgd2lsbCBhZGQgdGhlIFBhcmFncmFwaE5vZGUgYWZ0ZXIgdGhlIGdyYW5kcGFyZW50IExpc3RJdGVtTm9kZS5cbiAqIFRocm93cyBhbiBpbnZhcmlhbnQgaWYgdGhlIHNlbGVjdGlvbiBpcyBub3QgYSBjaGlsZCBvZiBhIExpc3ROb2RlLlxuICogQHJldHVybnMgdHJ1ZSBpZiBhIFBhcmFncmFwaE5vZGUgd2FzIGluc2VydGVkIHN1Y2Nlc2Z1bGx5LCBmYWxzZSBpZiB0aGVyZSBpcyBubyBzZWxlY3Rpb25cbiAqIG9yIHRoZSBzZWxlY3Rpb24gZG9lcyBub3QgY29udGFpbiBhIExpc3RJdGVtTm9kZSBvciB0aGUgbm9kZSBhbHJlYWR5IGhvbGRzIHRleHQuXG4gKi9cblxuZnVuY3Rpb24gJGhhbmRsZUxpc3RJbnNlcnRQYXJhZ3JhcGgoKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBPbmx5IHJ1biB0aGlzIGNvZGUgb24gZW1wdHkgbGlzdCBpdGVtc1xuXG5cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG5cbiAgaWYgKCEkaXNMaXN0SXRlbU5vZGUoYW5jaG9yKSB8fCBhbmNob3IuZ2V0VGV4dENvbnRlbnQoKSAhPT0gJycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCB0b3BMaXN0Tm9kZSA9ICRnZXRUb3BMaXN0Tm9kZShhbmNob3IpO1xuICBjb25zdCBwYXJlbnQgPSBhbmNob3IuZ2V0UGFyZW50KCk7XG5cbiAgaWYgKCEkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEEgTGlzdEl0ZW1Ob2RlIG11c3QgaGF2ZSBhIExpc3ROb2RlIGZvciBhIHBhcmVudC5gKTtcbiAgfVxuXG4gIGNvbnN0IGdyYW5kcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICBsZXQgcmVwbGFjZW1lbnROb2RlO1xuXG4gIGlmIChsZXhpY2FsLiRpc1Jvb3RPclNoYWRvd1Jvb3QoZ3JhbmRwYXJlbnQpKSB7XG4gICAgcmVwbGFjZW1lbnROb2RlID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIHRvcExpc3ROb2RlLmluc2VydEFmdGVyKHJlcGxhY2VtZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGdyYW5kcGFyZW50KSkge1xuICAgIHJlcGxhY2VtZW50Tm9kZSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICBncmFuZHBhcmVudC5pbnNlcnRBZnRlcihyZXBsYWNlbWVudE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJlcGxhY2VtZW50Tm9kZS5zZWxlY3QoKTtcbiAgY29uc3QgbmV4dFNpYmxpbmdzID0gYW5jaG9yLmdldE5leHRTaWJsaW5ncygpO1xuXG4gIGlmIChuZXh0U2libGluZ3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IG5ld0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUocGFyZW50LmdldExpc3RUeXBlKCkpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzUGFyYWdyYXBoTm9kZShyZXBsYWNlbWVudE5vZGUpKSB7XG4gICAgICByZXBsYWNlbWVudE5vZGUuaW5zZXJ0QWZ0ZXIobmV3TGlzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5ld0xpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgbmV3TGlzdEl0ZW0uYXBwZW5kKG5ld0xpc3QpO1xuICAgICAgcmVwbGFjZW1lbnROb2RlLmluc2VydEFmdGVyKG5ld0xpc3RJdGVtKTtcbiAgICB9XG5cbiAgICBuZXh0U2libGluZ3MuZm9yRWFjaChzaWJsaW5nID0+IHtcbiAgICAgIHNpYmxpbmcucmVtb3ZlKCk7XG4gICAgICBuZXdMaXN0LmFwcGVuZChzaWJsaW5nKTtcbiAgICB9KTtcbiAgfSAvLyBEb24ndCBsZWF2ZSBoYW5naW5nIG5lc3RlZCBlbXB0eSBsaXN0c1xuXG5cbiAgJHJlbW92ZUhpZ2hlc3RFbXB0eUxpc3RQYXJlbnQoYW5jaG9yKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpc3RJdGVtTm9kZSBleHRlbmRzIGxleGljYWwuRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2xpc3RpdGVtJztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBMaXN0SXRlbU5vZGUobm9kZS5fX3ZhbHVlLCBub2RlLl9fY2hlY2tlZCwgbm9kZS5fX2tleSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgY2hlY2tlZCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbHVlO1xuICAgIHRoaXMuX19jaGVja2VkID0gY2hlY2tlZDtcbiAgfVxuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkgJiYgcGFyZW50LmdldExpc3RUeXBlKCkgPT09ICdjaGVjaycpIHtcbiAgICAgIHVwZGF0ZUxpc3RJdGVtQ2hlY2tlZChlbGVtZW50LCB0aGlzLCBudWxsKTtcbiAgICB9XG5cbiAgICBlbGVtZW50LnZhbHVlID0gdGhpcy5fX3ZhbHVlO1xuICAgICRzZXRMaXN0SXRlbVRoZW1lQ2xhc3NOYW1lcyhlbGVtZW50LCBjb25maWcudGhlbWUsIHRoaXMpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSAmJiBwYXJlbnQuZ2V0TGlzdFR5cGUoKSA9PT0gJ2NoZWNrJykge1xuICAgICAgdXBkYXRlTGlzdEl0ZW1DaGVja2VkKGRvbSwgdGhpcywgcHJldk5vZGUpO1xuICAgIH0gLy8gQHRzLWV4cGVjdC1lcnJvciAtIHRoaXMgaXMgYWx3YXlzIEhUTUxMaXN0SXRlbUVsZW1lbnRcblxuXG4gICAgZG9tLnZhbHVlID0gdGhpcy5fX3ZhbHVlO1xuICAgICRzZXRMaXN0SXRlbVRoZW1lQ2xhc3NOYW1lcyhkb20sIGNvbmZpZy50aGVtZSwgdGhpcyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIHRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gbm9kZSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgICB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUocGFyZW50KTtcblxuICAgICAgICBpZiAocGFyZW50LmdldExpc3RUeXBlKCkgIT09ICdjaGVjaycgJiYgbm9kZS5nZXRDaGVja2VkKCkgIT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuc2V0Q2hlY2tlZCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRMaXN0SXRlbUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgbm9kZS5zZXRDaGVja2VkKHNlcmlhbGl6ZWROb2RlLmNoZWNrZWQpO1xuICAgIG5vZGUuc2V0VmFsdWUoc2VyaWFsaXplZE5vZGUudmFsdWUpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgY2hlY2tlZDogdGhpcy5nZXRDaGVja2VkKCksXG4gICAgICB0eXBlOiAnbGlzdGl0ZW0nLFxuICAgICAgdmFsdWU6IHRoaXMuZ2V0VmFsdWUoKSxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG5cbiAgYXBwZW5kKC4uLm5vZGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSAmJiB0aGlzLmNhbk1lcmdlV2l0aChub2RlKSkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgdGhpcy5hcHBlbmQoLi4uY2hpbGRyZW4pO1xuICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIuYXBwZW5kKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVwbGFjZShyZXBsYWNlV2l0aE5vZGUsIGluY2x1ZGVDaGlsZHJlbikge1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUocmVwbGFjZVdpdGhOb2RlKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UocmVwbGFjZVdpdGhOb2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEluZGVudCgwKTtcbiAgICBjb25zdCBsaXN0ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgaWYgKCEkaXNMaXN0Tm9kZShsaXN0KSkgcmV0dXJuIHJlcGxhY2VXaXRoTm9kZTtcblxuICAgIGlmIChsaXN0Ll9fZmlyc3QgPT09IHRoaXMuZ2V0S2V5KCkpIHtcbiAgICAgIGxpc3QuaW5zZXJ0QmVmb3JlKHJlcGxhY2VXaXRoTm9kZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0Ll9fbGFzdCA9PT0gdGhpcy5nZXRLZXkoKSkge1xuICAgICAgbGlzdC5pbnNlcnRBZnRlcihyZXBsYWNlV2l0aE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTcGxpdCB0aGUgbGlzdFxuICAgICAgY29uc3QgbmV3TGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0LmdldExpc3RUeXBlKCkpO1xuICAgICAgbGV0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuXG4gICAgICB3aGlsZSAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgY29uc3Qgbm9kZVRvQXBwZW5kID0gbmV4dFNpYmxpbmc7XG4gICAgICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgICAgbmV3TGlzdC5hcHBlbmQobm9kZVRvQXBwZW5kKTtcbiAgICAgIH1cblxuICAgICAgbGlzdC5pbnNlcnRBZnRlcihyZXBsYWNlV2l0aE5vZGUpO1xuICAgICAgcmVwbGFjZVdpdGhOb2RlLmluc2VydEFmdGVyKG5ld0xpc3QpO1xuICAgIH1cblxuICAgIGlmIChpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgcmVwbGFjZVdpdGhOb2RlLmFwcGVuZChjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZSgpO1xuXG4gICAgaWYgKGxpc3QuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgIGxpc3QucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcGxhY2VXaXRoTm9kZTtcbiAgfVxuXG4gIGluc2VydEFmdGVyKG5vZGUsIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgbGlzdE5vZGUgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgIGlmICghJGlzTGlzdE5vZGUobGlzdE5vZGUpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBpbnNlcnRBZnRlcjogbGlzdCBub2RlIGlzIG5vdCBwYXJlbnQgb2YgbGlzdCBpdGVtIG5vZGVgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzaWJsaW5ncyA9IHRoaXMuZ2V0TmV4dFNpYmxpbmdzKCk7XG5cbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpKSB7XG4gICAgICBjb25zdCBhZnRlciA9IHN1cGVyLmluc2VydEFmdGVyKG5vZGUsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgICAgY29uc3QgYWZ0ZXJMaXN0Tm9kZSA9IG5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gICAgICBpZiAoJGlzTGlzdE5vZGUoYWZ0ZXJMaXN0Tm9kZSkpIHtcbiAgICAgICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKGFmdGVyTGlzdE5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWZ0ZXI7XG4gICAgfSAvLyBBdHRlbXB0IHRvIG1lcmdlIGlmIHRoZSBsaXN0IGlzIG9mIHRoZSBzYW1lIHR5cGUuXG5cblxuICAgIGlmICgkaXNMaXN0Tm9kZShub2RlKSkge1xuICAgICAgbGV0IGNoaWxkID0gbm9kZTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuXG4gICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgdGhpcy5pbnNlcnRBZnRlcihjaGlsZCwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9IC8vIE90aGVyd2lzZSwgc3BsaXQgdGhlIGxpc3RcbiAgICAvLyBTcGxpdCB0aGUgbGlzdHMgYW5kIGluc2VydCB0aGUgbm9kZSBpbiBiZXR3ZWVuIHRoZW1cblxuXG4gICAgbGlzdE5vZGUuaW5zZXJ0QWZ0ZXIobm9kZSwgcmVzdG9yZVNlbGVjdGlvbik7XG5cbiAgICBpZiAoc2libGluZ3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBuZXdMaXN0Tm9kZSA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0Tm9kZS5nZXRMaXN0VHlwZSgpKTtcbiAgICAgIHNpYmxpbmdzLmZvckVhY2goc2libGluZyA9PiBuZXdMaXN0Tm9kZS5hcHBlbmQoc2libGluZykpO1xuICAgICAgbm9kZS5pbnNlcnRBZnRlcihuZXdMaXN0Tm9kZSwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZW1vdmUocHJlc2VydmVFbXB0eVBhcmVudCkge1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBzdXBlci5yZW1vdmUocHJlc2VydmVFbXB0eVBhcmVudCk7XG5cbiAgICBpZiAocHJldlNpYmxpbmcgJiYgbmV4dFNpYmxpbmcgJiYgaXNOZXN0ZWRMaXN0Tm9kZShwcmV2U2libGluZykgJiYgaXNOZXN0ZWRMaXN0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIG1lcmdlTGlzdHMocHJldlNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpLCBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkKCkpO1xuICAgICAgbmV4dFNpYmxpbmcucmVtb3ZlKCk7XG4gICAgfSBlbHNlIGlmIChuZXh0U2libGluZykge1xuICAgICAgY29uc3QgcGFyZW50ID0gbmV4dFNpYmxpbmcuZ2V0UGFyZW50KCk7XG5cbiAgICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluc2VydE5ld0FmdGVyKF8sIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9ICRjcmVhdGVMaXN0SXRlbU5vZGUodGhpcy5fX2NoZWNrZWQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGZhbHNlKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKG5ld0VsZW1lbnQsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbiAgY29sbGFwc2VBdFN0YXJ0KHNlbGVjdGlvbikge1xuICAgIGNvbnN0IHBhcmFncmFwaCA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHBhcmFncmFwaC5hcHBlbmQoY2hpbGQpKTtcbiAgICBjb25zdCBsaXN0Tm9kZSA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGxpc3ROb2RlUGFyZW50ID0gbGlzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGlzSW5kZW50ZWQgPSAkaXNMaXN0SXRlbU5vZGUobGlzdE5vZGVQYXJlbnQpO1xuXG4gICAgaWYgKGxpc3ROb2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAxKSB7XG4gICAgICBpZiAoaXNJbmRlbnRlZCkge1xuICAgICAgICAvLyBpZiB0aGUgbGlzdCBub2RlIGlzIG5lc3RlZCwgd2UganVzdCB3YW50IHRvIHJlbW92ZSBpdCxcbiAgICAgICAgLy8gZWZmZWN0aXZlbHkgdW5pbmRlbnRpbmcgaXQuXG4gICAgICAgIGxpc3ROb2RlLnJlbW92ZSgpO1xuICAgICAgICBsaXN0Tm9kZVBhcmVudC5zZWxlY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3ROb2RlLmluc2VydEJlZm9yZShwYXJhZ3JhcGgpO1xuICAgICAgICBsaXN0Tm9kZS5yZW1vdmUoKTsgLy8gSWYgd2UgaGF2ZSBzZWxlY3Rpb24gb24gdGhlIGxpc3QgaXRlbSwgd2UnbGwgbmVlZCB0byBtb3ZlIGl0XG4gICAgICAgIC8vIHRvIHRoZSBwYXJhZ3JhcGhcblxuICAgICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICAgICAgY29uc3Qga2V5ID0gcGFyYWdyYXBoLmdldEtleSgpO1xuXG4gICAgICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGFuY2hvci5nZXROb2RlKCkuaXModGhpcykpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KGtleSwgYW5jaG9yLm9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb2N1cy50eXBlID09PSAnZWxlbWVudCcgJiYgZm9jdXMuZ2V0Tm9kZSgpLmlzKHRoaXMpKSB7XG4gICAgICAgICAgZm9jdXMuc2V0KGtleSwgZm9jdXMub2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3ROb2RlLmluc2VydEJlZm9yZShwYXJhZ3JhcGgpO1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldFZhbHVlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fdmFsdWU7XG4gIH1cblxuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3ZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBnZXRDaGVja2VkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fY2hlY2tlZDtcbiAgfVxuXG4gIHNldENoZWNrZWQoY2hlY2tlZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2NoZWNrZWQgPSBjaGVja2VkO1xuICB9XG5cbiAgdG9nZ2xlQ2hlY2tlZCgpIHtcbiAgICB0aGlzLnNldENoZWNrZWQoIXRoaXMuX19jaGVja2VkKTtcbiAgfVxuXG4gIGdldEluZGVudCgpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgcGFyZW50LCB3ZSBhcmUgbGlrZWx5IHNlcmlhbGl6aW5nXG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faW5kZW50O1xuICAgIH0gLy8gTGlzdEl0ZW1Ob2RlIHNob3VsZCBhbHdheXMgaGF2ZSBhIExpc3ROb2RlIGZvciBhIHBhcmVudC5cblxuXG4gICAgbGV0IGxpc3ROb2RlUGFyZW50ID0gcGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBsZXQgaW5kZW50TGV2ZWwgPSAwO1xuXG4gICAgd2hpbGUgKCRpc0xpc3RJdGVtTm9kZShsaXN0Tm9kZVBhcmVudCkpIHtcbiAgICAgIGxpc3ROb2RlUGFyZW50ID0gbGlzdE5vZGVQYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGluZGVudExldmVsKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGVudExldmVsO1xuICB9XG5cbiAgc2V0SW5kZW50KGluZGVudCkge1xuICAgIGlmICghKHR5cGVvZiBpbmRlbnQgPT09ICdudW1iZXInICYmIGluZGVudCA+IC0xKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgaW5kZW50IHZhbHVlLmApO1xuICAgIH1cblxuICAgIGxldCBjdXJyZW50SW5kZW50ID0gdGhpcy5nZXRJbmRlbnQoKTtcblxuICAgIHdoaWxlIChjdXJyZW50SW5kZW50ICE9PSBpbmRlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50SW5kZW50IDwgaW5kZW50KSB7XG4gICAgICAgICRoYW5kbGVJbmRlbnQodGhpcyk7XG4gICAgICAgIGN1cnJlbnRJbmRlbnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRoYW5kbGVPdXRkZW50KHRoaXMpO1xuICAgICAgICBjdXJyZW50SW5kZW50LS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpbnNlcnRCZWZvcmUobm9kZVRvSW5zZXJ0KSB7XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShub2RlVG9JbnNlcnQpKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLmdldE5leHRTaWJsaW5ncygpO1xuICAgICAgICB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUocGFyZW50LCBzaWJsaW5ncyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmluc2VydEJlZm9yZShub2RlVG9JbnNlcnQpO1xuICB9XG5cbiAgY2FuSW5zZXJ0QWZ0ZXIobm9kZSkge1xuICAgIHJldHVybiAkaXNMaXN0SXRlbU5vZGUobm9kZSk7XG4gIH1cblxuICBjYW5SZXBsYWNlV2l0aChyZXBsYWNlbWVudCkge1xuICAgIHJldHVybiAkaXNMaXN0SXRlbU5vZGUocmVwbGFjZW1lbnQpO1xuICB9XG5cbiAgY2FuTWVyZ2VXaXRoKG5vZGUpIHtcbiAgICByZXR1cm4gbGV4aWNhbC4kaXNQYXJhZ3JhcGhOb2RlKG5vZGUpIHx8ICRpc0xpc3RJdGVtTm9kZShub2RlKTtcbiAgfVxuXG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbikge1xuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuaXNQYXJlbnRPZihhbmNob3JOb2RlKSAmJiB0aGlzLmlzUGFyZW50T2YoZm9jdXNOb2RlKSAmJiB0aGlzLmdldFRleHRDb250ZW50KCkubGVuZ3RoID09PSBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGg7XG4gIH1cblxuICBpc1BhcmVudFJlcXVpcmVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY3JlYXRlUGFyZW50RWxlbWVudE5vZGUoKSB7XG4gICAgcmV0dXJuICRjcmVhdGVMaXN0Tm9kZSgnYnVsbGV0Jyk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiAkc2V0TGlzdEl0ZW1UaGVtZUNsYXNzTmFtZXMoZG9tLCBlZGl0b3JUaGVtZUNsYXNzZXMsIG5vZGUpIHtcbiAgY29uc3QgY2xhc3Nlc1RvQWRkID0gW107XG4gIGNvbnN0IGNsYXNzZXNUb1JlbW92ZSA9IFtdO1xuICBjb25zdCBsaXN0VGhlbWUgPSBlZGl0b3JUaGVtZUNsYXNzZXMubGlzdDtcbiAgY29uc3QgbGlzdEl0ZW1DbGFzc05hbWUgPSBsaXN0VGhlbWUgPyBsaXN0VGhlbWUubGlzdGl0ZW0gOiB1bmRlZmluZWQ7XG4gIGxldCBuZXN0ZWRMaXN0SXRlbUNsYXNzTmFtZTtcblxuICBpZiAobGlzdFRoZW1lICYmIGxpc3RUaGVtZS5uZXN0ZWQpIHtcbiAgICBuZXN0ZWRMaXN0SXRlbUNsYXNzTmFtZSA9IGxpc3RUaGVtZS5uZXN0ZWQubGlzdGl0ZW07XG4gIH1cblxuICBpZiAobGlzdEl0ZW1DbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGxpc3RJdGVtQ2xhc3NlcyA9IGxpc3RJdGVtQ2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gICAgY2xhc3Nlc1RvQWRkLnB1c2goLi4ubGlzdEl0ZW1DbGFzc2VzKTtcbiAgfVxuXG4gIGlmIChsaXN0VGhlbWUpIHtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBjb25zdCBpc0NoZWNrTGlzdCA9ICRpc0xpc3ROb2RlKHBhcmVudE5vZGUpICYmIHBhcmVudE5vZGUuZ2V0TGlzdFR5cGUoKSA9PT0gJ2NoZWNrJztcbiAgICBjb25zdCBjaGVja2VkID0gbm9kZS5nZXRDaGVja2VkKCk7XG5cbiAgICBpZiAoIWlzQ2hlY2tMaXN0IHx8IGNoZWNrZWQpIHtcbiAgICAgIGNsYXNzZXNUb1JlbW92ZS5wdXNoKGxpc3RUaGVtZS5saXN0aXRlbVVuY2hlY2tlZCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0NoZWNrTGlzdCB8fCAhY2hlY2tlZCkge1xuICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2gobGlzdFRoZW1lLmxpc3RpdGVtQ2hlY2tlZCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ2hlY2tMaXN0KSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaChjaGVja2VkID8gbGlzdFRoZW1lLmxpc3RpdGVtQ2hlY2tlZCA6IGxpc3RUaGVtZS5saXN0aXRlbVVuY2hlY2tlZCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5lc3RlZExpc3RJdGVtQ2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBuZXN0ZWRMaXN0SXRlbUNsYXNzZXMgPSBuZXN0ZWRMaXN0SXRlbUNsYXNzTmFtZS5zcGxpdCgnICcpO1xuXG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGRyZW4oKS5zb21lKGNoaWxkID0+ICRpc0xpc3ROb2RlKGNoaWxkKSkpIHtcbiAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLm5lc3RlZExpc3RJdGVtQ2xhc3Nlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsYXNzZXNUb1JlbW92ZS5wdXNoKC4uLm5lc3RlZExpc3RJdGVtQ2xhc3Nlcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNsYXNzZXNUb1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgdXRpbHMucmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgLi4uY2xhc3Nlc1RvUmVtb3ZlKTtcbiAgfVxuXG4gIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9BZGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RJdGVtQ2hlY2tlZChkb20sIGxpc3RJdGVtTm9kZSwgcHJldkxpc3RJdGVtTm9kZSwgbGlzdE5vZGUpIHtcbiAgLy8gT25seSBhZGQgYXR0cmlidXRlcyBmb3IgbGVhZiBsaXN0IGl0ZW1zXG4gIGlmICgkaXNMaXN0Tm9kZShsaXN0SXRlbU5vZGUuZ2V0Rmlyc3RDaGlsZCgpKSkge1xuICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcpO1xuICB9IGVsc2Uge1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnY2hlY2tib3gnKTtcbiAgICBkb20uc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsICctMScpO1xuXG4gICAgaWYgKCFwcmV2TGlzdEl0ZW1Ob2RlIHx8IGxpc3RJdGVtTm9kZS5fX2NoZWNrZWQgIT09IHByZXZMaXN0SXRlbU5vZGUuX19jaGVja2VkKSB7XG4gICAgICBkb20uc2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnLCBsaXN0SXRlbU5vZGUuZ2V0Q2hlY2tlZCgpID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRMaXN0SXRlbUVsZW1lbnQoZG9tTm9kZSkge1xuICBjb25zdCBjaGVja2VkID0gdXRpbHMuaXNIVE1MRWxlbWVudChkb21Ob2RlKSAmJiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJykgPT09ICd0cnVlJztcbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlTGlzdEl0ZW1Ob2RlKGNoZWNrZWQpXG4gIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTGlzdCBJdGVtIG5vZGUsIHBhc3NpbmcgdHJ1ZS9mYWxzZSB3aWxsIGNvbnZlcnQgaXQgdG8gYSBjaGVja2JveCBpbnB1dC5cbiAqIEBwYXJhbSBjaGVja2VkIC0gSXMgdGhlIExpc3QgSXRlbSBhIGNoZWNrYm94IGFuZCwgaWYgc28sIGlzIGl0IGNoZWNrZWQ/IHVuZGVmaW5lZC9udWxsOiBub3QgYSBjaGVja2JveCwgdHJ1ZS9mYWxzZSBpcyBhIGNoZWNrYm94IGFuZCBjaGVja2VkL3VuY2hlY2tlZCwgcmVzcGVjdGl2ZWx5LlxuICogQHJldHVybnMgVGhlIG5ldyBMaXN0IEl0ZW0uXG4gKi9cblxuXG5mdW5jdGlvbiAkY3JlYXRlTGlzdEl0ZW1Ob2RlKGNoZWNrZWQpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBMaXN0SXRlbU5vZGUodW5kZWZpbmVkLCBjaGVja2VkKSk7XG59XG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIG5vZGUgaXMgYSBMaXN0SXRlbU5vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGEgTGlzdEl0ZW1Ob2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaXN0SXRlbU5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpc3ROb2RlIGV4dGVuZHMgbGV4aWNhbC5FbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2xpc3QnO1xuICB9XG5cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICBjb25zdCBsaXN0VHlwZSA9IG5vZGUuX19saXN0VHlwZSB8fCBUQUdfVE9fTElTVF9UWVBFW25vZGUuX190YWddO1xuICAgIHJldHVybiBuZXcgTGlzdE5vZGUobGlzdFR5cGUsIG5vZGUuX19zdGFydCwgbm9kZS5fX2tleSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihsaXN0VHlwZSwgc3RhcnQsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG5cbiAgICBjb25zdCBfbGlzdFR5cGUgPSBUQUdfVE9fTElTVF9UWVBFW2xpc3RUeXBlXSB8fCBsaXN0VHlwZTtcblxuICAgIHRoaXMuX19saXN0VHlwZSA9IF9saXN0VHlwZTtcbiAgICB0aGlzLl9fdGFnID0gX2xpc3RUeXBlID09PSAnbnVtYmVyJyA/ICdvbCcgOiAndWwnO1xuICAgIHRoaXMuX19zdGFydCA9IHN0YXJ0O1xuICB9XG5cbiAgZ2V0VGFnKCkge1xuICAgIHJldHVybiB0aGlzLl9fdGFnO1xuICB9XG5cbiAgc2V0TGlzdFR5cGUodHlwZSkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fbGlzdFR5cGUgPSB0eXBlO1xuICAgIHdyaXRhYmxlLl9fdGFnID0gdHlwZSA9PT0gJ251bWJlcicgPyAnb2wnIDogJ3VsJztcbiAgfVxuXG4gIGdldExpc3RUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9fbGlzdFR5cGU7XG4gIH1cblxuICBnZXRTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3N0YXJ0O1xuICB9IC8vIFZpZXdcblxuXG4gIGNyZWF0ZURPTShjb25maWcsIF9lZGl0b3IpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLl9fdGFnO1xuICAgIGNvbnN0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcblxuICAgIGlmICh0aGlzLl9fc3RhcnQgIT09IDEpIHtcbiAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3N0YXJ0JywgU3RyaW5nKHRoaXMuX19zdGFydCkpO1xuICAgIH0gLy8gQHRzLWV4cGVjdC1lcnJvciBJbnRlcm5hbCBmaWVsZC5cblxuXG4gICAgZG9tLl9fbGV4aWNhbExpc3RUeXBlID0gdGhpcy5fX2xpc3RUeXBlO1xuICAgIHNldExpc3RUaGVtZUNsYXNzTmFtZXMoZG9tLCBjb25maWcudGhlbWUsIHRoaXMpO1xuICAgIHJldHVybiBkb207XG4gIH1cblxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgaWYgKHByZXZOb2RlLl9fdGFnICE9PSB0aGlzLl9fdGFnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBzZXRMaXN0VGhlbWVDbGFzc05hbWVzKGRvbSwgY29uZmlnLnRoZW1lLCB0aGlzKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0TGlzdE5vZGUsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHVsOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRMaXN0Tm9kZSxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVMaXN0Tm9kZShzZXJpYWxpemVkTm9kZS5saXN0VHlwZSwgc2VyaWFsaXplZE5vZGUuc3RhcnQpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgaWYgKHRoaXMuX19zdGFydCAhPT0gMSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3RhcnQnLCBTdHJpbmcodGhpcy5fX3N0YXJ0KSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9fbGlzdFR5cGUgPT09ICdjaGVjaycpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ19fbGV4aWNhbExpc3RUeXBlJywgJ2NoZWNrJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4geyAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBsaXN0VHlwZTogdGhpcy5nZXRMaXN0VHlwZSgpLFxuICAgICAgc3RhcnQ6IHRoaXMuZ2V0U3RhcnQoKSxcbiAgICAgIHRhZzogdGhpcy5nZXRUYWcoKSxcbiAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG5cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgYXBwZW5kKC4uLm5vZGVzVG9BcHBlbmQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzVG9BcHBlbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gbm9kZXNUb0FwcGVuZFtpXTtcblxuICAgICAgaWYgKCRpc0xpc3RJdGVtTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgc3VwZXIuYXBwZW5kKGN1cnJlbnROb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxpc3RJdGVtTm9kZSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcblxuICAgICAgICBpZiAoJGlzTGlzdE5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgbGlzdEl0ZW1Ob2RlLmFwcGVuZChjdXJyZW50Tm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IGxleGljYWwuJGNyZWF0ZVRleHROb2RlKGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50KCkpO1xuICAgICAgICAgIGxpc3RJdGVtTm9kZS5hcHBlbmQodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpc3RJdGVtTm9kZS5hcHBlbmQoY3VycmVudE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuYXBwZW5kKGxpc3RJdGVtTm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZXh0cmFjdFdpdGhDaGlsZChjaGlsZCkge1xuICAgIHJldHVybiAkaXNMaXN0SXRlbU5vZGUoY2hpbGQpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gc2V0TGlzdFRoZW1lQ2xhc3NOYW1lcyhkb20sIGVkaXRvclRoZW1lQ2xhc3Nlcywgbm9kZSkge1xuICBjb25zdCBjbGFzc2VzVG9BZGQgPSBbXTtcbiAgY29uc3QgY2xhc3Nlc1RvUmVtb3ZlID0gW107XG4gIGNvbnN0IGxpc3RUaGVtZSA9IGVkaXRvclRoZW1lQ2xhc3Nlcy5saXN0O1xuXG4gIGlmIChsaXN0VGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGxpc3RMZXZlbHNDbGFzc05hbWVzID0gbGlzdFRoZW1lW2Ake25vZGUuX190YWd9RGVwdGhgXSB8fCBbXTtcbiAgICBjb25zdCBsaXN0RGVwdGggPSAkZ2V0TGlzdERlcHRoKG5vZGUpIC0gMTtcbiAgICBjb25zdCBub3JtYWxpemVkTGlzdERlcHRoID0gbGlzdERlcHRoICUgbGlzdExldmVsc0NsYXNzTmFtZXMubGVuZ3RoO1xuICAgIGNvbnN0IGxpc3RMZXZlbENsYXNzTmFtZSA9IGxpc3RMZXZlbHNDbGFzc05hbWVzW25vcm1hbGl6ZWRMaXN0RGVwdGhdO1xuICAgIGNvbnN0IGxpc3RDbGFzc05hbWUgPSBsaXN0VGhlbWVbbm9kZS5fX3RhZ107XG4gICAgbGV0IG5lc3RlZExpc3RDbGFzc05hbWU7XG4gICAgY29uc3QgbmVzdGVkTGlzdFRoZW1lID0gbGlzdFRoZW1lLm5lc3RlZDtcblxuICAgIGlmIChuZXN0ZWRMaXN0VGhlbWUgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRMaXN0VGhlbWUubGlzdCkge1xuICAgICAgbmVzdGVkTGlzdENsYXNzTmFtZSA9IG5lc3RlZExpc3RUaGVtZS5saXN0O1xuICAgIH1cblxuICAgIGlmIChsaXN0Q2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKGxpc3RDbGFzc05hbWUpO1xuICAgIH1cblxuICAgIGlmIChsaXN0TGV2ZWxDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbGlzdEl0ZW1DbGFzc2VzID0gbGlzdExldmVsQ2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaCguLi5saXN0SXRlbUNsYXNzZXMpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RMZXZlbHNDbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpICE9PSBub3JtYWxpemVkTGlzdERlcHRoKSB7XG4gICAgICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2gobm9kZS5fX3RhZyArIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lc3RlZExpc3RDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbmVzdGVkTGlzdEl0ZW1DbGFzc2VzID0gbmVzdGVkTGlzdENsYXNzTmFtZS5zcGxpdCgnICcpO1xuXG4gICAgICBpZiAobGlzdERlcHRoID4gMSkge1xuICAgICAgICBjbGFzc2VzVG9BZGQucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2goLi4ubmVzdGVkTGlzdEl0ZW1DbGFzc2VzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoY2xhc3Nlc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICB1dGlscy5yZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9SZW1vdmUpO1xuICB9XG5cbiAgaWYgKGNsYXNzZXNUb0FkZC5sZW5ndGggPiAwKSB7XG4gICAgdXRpbHMuYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChkb20sIC4uLmNsYXNzZXNUb0FkZCk7XG4gIH1cbn1cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIG5vcm1hbGl6ZXMgdGhlIGNoaWxkcmVuIG9mIGEgTGlzdE5vZGUgYWZ0ZXIgdGhlIGNvbnZlcnNpb24gZnJvbSBIVE1MLFxuICogZW5zdXJpbmcgdGhhdCB0aGV5IGFyZSBhbGwgTGlzdEl0ZW1Ob2RlcyBhbmQgY29udGFpbiBlaXRoZXIgYSBzaW5nbGUgbmVzdGVkIExpc3ROb2RlXG4gKiBvciBzb21lIG90aGVyIGlubGluZSBjb250ZW50LlxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4obm9kZXMpIHtcbiAgY29uc3Qgbm9ybWFsaXplZExpc3RJdGVtcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpKSB7XG4gICAgICBub3JtYWxpemVkTGlzdEl0ZW1zLnB1c2gobm9kZSk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcblxuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgaWYgKCRpc0xpc3ROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZExpc3RJdGVtcy5wdXNoKHdyYXBJbkxpc3RJdGVtKGNoaWxkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplZExpc3RJdGVtcy5wdXNoKHdyYXBJbkxpc3RJdGVtKG5vZGUpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZExpc3RJdGVtcztcbn1cblxuZnVuY3Rpb24gY29udmVydExpc3ROb2RlKGRvbU5vZGUpIHtcbiAgY29uc3Qgbm9kZU5hbWUgPSBkb21Ob2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGxldCBub2RlID0gbnVsbDtcblxuICBpZiAobm9kZU5hbWUgPT09ICdvbCcpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc3RhcnQgPSBkb21Ob2RlLnN0YXJ0O1xuICAgIG5vZGUgPSAkY3JlYXRlTGlzdE5vZGUoJ251bWJlcicsIHN0YXJ0KTtcbiAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gJ3VsJykge1xuICAgIGlmICh1dGlscy5pc0hUTUxFbGVtZW50KGRvbU5vZGUpICYmIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdfX2xleGljYWxsaXN0dHlwZScpID09PSAnY2hlY2snKSB7XG4gICAgICBub2RlID0gJGNyZWF0ZUxpc3ROb2RlKCdjaGVjaycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gJGNyZWF0ZUxpc3ROb2RlKCdidWxsZXQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFmdGVyOiBub3JtYWxpemVDaGlsZHJlbixcbiAgICBub2RlXG4gIH07XG59XG5cbmNvbnN0IFRBR19UT19MSVNUX1RZUEUgPSB7XG4gIG9sOiAnbnVtYmVyJyxcbiAgdWw6ICdidWxsZXQnXG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgTGlzdE5vZGUgb2YgbGlzdFR5cGUuXG4gKiBAcGFyYW0gbGlzdFR5cGUgLSBUaGUgdHlwZSBvZiBsaXN0IHRvIGJlIGNyZWF0ZWQuIENhbiBiZSAnbnVtYmVyJywgJ2J1bGxldCcsIG9yICdjaGVjaycuXG4gKiBAcGFyYW0gc3RhcnQgLSBXaGVyZSBhbiBvcmRlcmVkIGxpc3Qgc3RhcnRzIGl0cyBjb3VudCwgc3RhcnQgPSAxIGlmIGxlZnQgdW5kZWZpbmVkLlxuICogQHJldHVybnMgVGhlIG5ldyBMaXN0Tm9kZVxuICovXG5cbmZ1bmN0aW9uICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSwgc3RhcnQgPSAxKSB7XG4gIHJldHVybiBsZXhpY2FsLiRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgTGlzdE5vZGUobGlzdFR5cGUsIHN0YXJ0KSk7XG59XG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIG5vZGUgaXMgYSBMaXN0Tm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgYSBMaXN0Tm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uICRpc0xpc3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaXN0Tm9kZTtcbn1cblxuLyoqIEBtb2R1bGUgQGxleGljYWwvbGlzdCAqL1xuY29uc3QgSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQgPSBsZXhpY2FsLmNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5EJyk7XG5jb25zdCBJTlNFUlRfT1JERVJFRF9MSVNUX0NPTU1BTkQgPSBsZXhpY2FsLmNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCcpO1xuY29uc3QgSU5TRVJUX0NIRUNLX0xJU1RfQ09NTUFORCA9IGxleGljYWwuY3JlYXRlQ29tbWFuZCgnSU5TRVJUX0NIRUNLX0xJU1RfQ09NTUFORCcpO1xuY29uc3QgUkVNT1ZFX0xJU1RfQ09NTUFORCA9IGxleGljYWwuY3JlYXRlQ29tbWFuZCgnUkVNT1ZFX0xJU1RfQ09NTUFORCcpO1xuXG5leHBvcnRzLiRjcmVhdGVMaXN0SXRlbU5vZGUgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlO1xuZXhwb3J0cy4kY3JlYXRlTGlzdE5vZGUgPSAkY3JlYXRlTGlzdE5vZGU7XG5leHBvcnRzLiRnZXRMaXN0RGVwdGggPSAkZ2V0TGlzdERlcHRoO1xuZXhwb3J0cy4kaGFuZGxlTGlzdEluc2VydFBhcmFncmFwaCA9ICRoYW5kbGVMaXN0SW5zZXJ0UGFyYWdyYXBoO1xuZXhwb3J0cy4kaXNMaXN0SXRlbU5vZGUgPSAkaXNMaXN0SXRlbU5vZGU7XG5leHBvcnRzLiRpc0xpc3ROb2RlID0gJGlzTGlzdE5vZGU7XG5leHBvcnRzLklOU0VSVF9DSEVDS19MSVNUX0NPTU1BTkQgPSBJTlNFUlRfQ0hFQ0tfTElTVF9DT01NQU5EO1xuZXhwb3J0cy5JTlNFUlRfT1JERVJFRF9MSVNUX0NPTU1BTkQgPSBJTlNFUlRfT1JERVJFRF9MSVNUX0NPTU1BTkQ7XG5leHBvcnRzLklOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5EID0gSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQ7XG5leHBvcnRzLkxpc3RJdGVtTm9kZSA9IExpc3RJdGVtTm9kZTtcbmV4cG9ydHMuTGlzdE5vZGUgPSBMaXN0Tm9kZTtcbmV4cG9ydHMuUkVNT1ZFX0xJU1RfQ09NTUFORCA9IFJFTU9WRV9MSVNUX0NPTU1BTkQ7XG5leHBvcnRzLmluc2VydExpc3QgPSBpbnNlcnRMaXN0O1xuZXhwb3J0cy5yZW1vdmVMaXN0ID0gcmVtb3ZlTGlzdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/list/LexicalList.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/list/LexicalList.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/list/LexicalList.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalList =  true ? __webpack_require__(/*! ./LexicalList.dev.js */ \"(ssr)/./node_modules/@lexical/list/LexicalList.dev.js\") : 0\nmodule.exports = LexicalList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGlzdC9MZXhpY2FsTGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLG9CQUFvQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsbUZBQXNCLElBQUksQ0FBZ0M7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9saXN0L0xleGljYWxMaXN0LmpzPzE5YjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxMaXN0ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxMaXN0LmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsTGlzdC5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbExpc3Q7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/list/LexicalList.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/mark/LexicalMark.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/mark/LexicalMark.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass MarkNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'mark';\n  }\n\n  static clone(node) {\n    return new MarkNode(Array.from(node.__ids), node.__key);\n  }\n\n  static importDOM() {\n    return null;\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createMarkNode(serializedNode.ids);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      ids: this.getIDs(),\n      type: 'mark',\n      version: 1\n    };\n  }\n\n  constructor(ids, key) {\n    super(key);\n    this.__ids = ids || [];\n  }\n\n  createDOM(config) {\n    const element = document.createElement('mark');\n    utils.addClassNamesToElement(element, config.theme.mark);\n\n    if (this.__ids.length > 1) {\n      utils.addClassNamesToElement(element, config.theme.markOverlap);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          utils.addClassNamesToElement(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        utils.removeClassNamesFromElement(element, overlapTheme);\n      }\n    }\n\n    return false;\n  }\n\n  hasID(id) {\n    const ids = this.getIDs();\n\n    for (let i = 0; i < ids.length; i++) {\n      if (id === ids[i]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  getIDs() {\n    const self = this.getLatest();\n    return $isMarkNode(self) ? self.__ids : [];\n  }\n\n  addID(id) {\n    const self = this.getWritable();\n\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n\n      for (let i = 0; i < ids.length; i++) {\n        // If we already have it, don't add again\n        if (id === ids[i]) return;\n      }\n\n      ids.push(id);\n    }\n  }\n\n  deleteID(id) {\n    const self = this.getWritable();\n\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n\n      for (let i = 0; i < ids.length; i++) {\n        if (id === ids[i]) {\n          ids.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n\n    if (lexical.$isElementNode(element)) {\n      const markNode = $createMarkNode(this.__ids);\n      element.append(markNode);\n      return markNode;\n    }\n\n    return null;\n  }\n\n  canInsertTextBefore() {\n    return false;\n  }\n\n  canInsertTextAfter() {\n    return false;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  isInline() {\n    return true;\n  }\n\n  extractWithChild(child, selection, destination) {\n    if (!lexical.$isRangeSelection(selection) || destination === 'html') {\n      return false;\n    }\n\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n\n}\nfunction $createMarkNode(ids) {\n  return lexical.$applyNodeReplacement(new MarkNode(ids));\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/** @module @lexical/mark */\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n\n    target = child;\n  }\n\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {\n  const nodes = selection.getNodes();\n  const anchorOffset = selection.anchor.offset;\n  const focusOffset = selection.focus.offset;\n  const nodesLength = nodes.length;\n  const startOffset = isBackward ? focusOffset : anchorOffset;\n  const endOffset = isBackward ? anchorOffset : focusOffset;\n  let currentNodeParent;\n  let lastCreatedMarkNode; // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n\n    const isFirstNode = i === 0;\n    const isLastNode = i === nodesLength - 1;\n    let targetNode = null;\n\n    if (lexical.$isTextNode(node)) {\n      // Case 1: The node is a text node and we can split it\n      const textContentSize = node.getTextContentSize();\n      const startTextOffset = isFirstNode ? startOffset : 0;\n      const endTextOffset = isLastNode ? endOffset : textContentSize;\n\n      if (startTextOffset === 0 && endTextOffset === 0) {\n        continue;\n      }\n\n      const splitNodes = node.splitText(startTextOffset, endTextOffset);\n      targetNode = splitNodes.length > 1 && (splitNodes.length === 3 || isFirstNode && !isLastNode || endTextOffset === textContentSize) ? splitNodes[1] : splitNodes[0];\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may utlimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n      continue;\n    } else if (lexical.$isElementNode(node) && node.isInline()) {\n      // Case 3: inline element nodes can be added in their entirety to the new\n      // mark\n      targetNode = node;\n    }\n\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n\n      const parentNode = targetNode.getParent();\n\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n\n      currentNodeParent = parentNode;\n\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        const createMarkNode = createNode || $createMarkNode;\n        lastCreatedMarkNode = createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      } // Add the target node to be wrapped in the latest created mark node\n\n\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  } // Make selection collapsed at the end\n\n\n  if (lexical.$isElementNode(lastCreatedMarkNode)) {\n    // eslint-disable-next-line no-unused-expressions\n    isBackward ? lastCreatedMarkNode.selectStart() : lastCreatedMarkNode.selectEnd();\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if (lexical.$isTextNode(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n\n    currentNode = currentNode.getParent();\n  }\n\n  return null;\n}\n\nexports.$createMarkNode = $createMarkNode;\nexports.$getMarkIDs = $getMarkIDs;\nexports.$isMarkNode = $isMarkNode;\nexports.$unwrapMarkNode = $unwrapMarkNode;\nexports.$wrapSelectionInMarkNode = $wrapSelectionInMarkNode;\nexports.MarkNode = MarkNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFyay9MZXhpY2FsTWFyay5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLHVCQUF1QjtBQUN2QixnQ0FBZ0M7QUFDaEMsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFyay9MZXhpY2FsTWFyay5kZXYuanM/YWE2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBNYXJrTm9kZSBleHRlbmRzIGxleGljYWwuRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnbWFyayc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgTWFya05vZGUoQXJyYXkuZnJvbShub2RlLl9faWRzKSwgbm9kZS5fX2tleSk7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZU1hcmtOb2RlKHNlcmlhbGl6ZWROb2RlLmlkcyk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldEluZGVudChzZXJpYWxpemVkTm9kZS5pbmRlbnQpO1xuICAgIG5vZGUuc2V0RGlyZWN0aW9uKHNlcmlhbGl6ZWROb2RlLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGlkczogdGhpcy5nZXRJRHMoKSxcbiAgICAgIHR5cGU6ICdtYXJrJyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoaWRzLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX19pZHMgPSBpZHMgfHwgW107XG4gIH1cblxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21hcmsnKTtcbiAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS5tYXJrKTtcblxuICAgIGlmICh0aGlzLl9faWRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLm1hcmtPdmVybGFwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZWxlbWVudCwgY29uZmlnKSB7XG4gICAgY29uc3QgcHJldklEcyA9IHByZXZOb2RlLl9faWRzO1xuICAgIGNvbnN0IG5leHRJRHMgPSB0aGlzLl9faWRzO1xuICAgIGNvbnN0IHByZXZJRHNDb3VudCA9IHByZXZJRHMubGVuZ3RoO1xuICAgIGNvbnN0IG5leHRJRHNDb3VudCA9IG5leHRJRHMubGVuZ3RoO1xuICAgIGNvbnN0IG92ZXJsYXBUaGVtZSA9IGNvbmZpZy50aGVtZS5tYXJrT3ZlcmxhcDtcblxuICAgIGlmIChwcmV2SURzQ291bnQgIT09IG5leHRJRHNDb3VudCkge1xuICAgICAgaWYgKHByZXZJRHNDb3VudCA9PT0gMSkge1xuICAgICAgICBpZiAobmV4dElEc0NvdW50ID09PSAyKSB7XG4gICAgICAgICAgdXRpbHMuYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBvdmVybGFwVGhlbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5leHRJRHNDb3VudCA9PT0gMSkge1xuICAgICAgICB1dGlscy5yZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZWxlbWVudCwgb3ZlcmxhcFRoZW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYXNJRChpZCkge1xuICAgIGNvbnN0IGlkcyA9IHRoaXMuZ2V0SURzKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlkID09PSBpZHNbaV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0SURzKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiAkaXNNYXJrTm9kZShzZWxmKSA/IHNlbGYuX19pZHMgOiBbXTtcbiAgfVxuXG4gIGFkZElEKGlkKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcblxuICAgIGlmICgkaXNNYXJrTm9kZShzZWxmKSkge1xuICAgICAgY29uc3QgaWRzID0gc2VsZi5fX2lkcztcbiAgICAgIHNlbGYuX19pZHMgPSBpZHM7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSBpdCwgZG9uJ3QgYWRkIGFnYWluXG4gICAgICAgIGlmIChpZCA9PT0gaWRzW2ldKSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlkcy5wdXNoKGlkKTtcbiAgICB9XG4gIH1cblxuICBkZWxldGVJRChpZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG5cbiAgICBpZiAoJGlzTWFya05vZGUoc2VsZikpIHtcbiAgICAgIGNvbnN0IGlkcyA9IHNlbGYuX19pZHM7XG4gICAgICBzZWxmLl9faWRzID0gaWRzO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaWQgPT09IGlkc1tpXSkge1xuICAgICAgICAgIGlkcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5pbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24pO1xuXG4gICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUoZWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IG1hcmtOb2RlID0gJGNyZWF0ZU1hcmtOb2RlKHRoaXMuX19pZHMpO1xuICAgICAgZWxlbWVudC5hcHBlbmQobWFya05vZGUpO1xuICAgICAgcmV0dXJuIG1hcmtOb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbiwgZGVzdGluYXRpb24pIHtcbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBkZXN0aW5hdGlvbiA9PT0gJ2h0bWwnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uTGVuZ3RoID0gaXNCYWNrd2FyZCA/IGFuY2hvci5vZmZzZXQgLSBmb2N1cy5vZmZzZXQgOiBmb2N1cy5vZmZzZXQgLSBhbmNob3Iub2Zmc2V0O1xuICAgIHJldHVybiB0aGlzLmlzUGFyZW50T2YoYW5jaG9yTm9kZSkgJiYgdGhpcy5pc1BhcmVudE9mKGZvY3VzTm9kZSkgJiYgdGhpcy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aCA9PT0gc2VsZWN0aW9uTGVuZ3RoO1xuICB9XG5cbiAgZXhjbHVkZUZyb21Db3B5KGRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uICE9PSAnY2xvbmUnO1xuICB9XG5cbn1cbmZ1bmN0aW9uICRjcmVhdGVNYXJrTm9kZShpZHMpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBNYXJrTm9kZShpZHMpKTtcbn1cbmZ1bmN0aW9uICRpc01hcmtOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBNYXJrTm9kZTtcbn1cblxuLyoqIEBtb2R1bGUgQGxleGljYWwvbWFyayAqL1xuZnVuY3Rpb24gJHVud3JhcE1hcmtOb2RlKG5vZGUpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gIGxldCB0YXJnZXQgPSBudWxsO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIoY2hpbGQpO1xuICAgIH1cblxuICAgIHRhcmdldCA9IGNoaWxkO1xuICB9XG5cbiAgbm9kZS5yZW1vdmUoKTtcbn1cbmZ1bmN0aW9uICR3cmFwU2VsZWN0aW9uSW5NYXJrTm9kZShzZWxlY3Rpb24sIGlzQmFja3dhcmQsIGlkLCBjcmVhdGVOb2RlKSB7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0O1xuICBjb25zdCBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1cy5vZmZzZXQ7XG4gIGNvbnN0IG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuICBjb25zdCBzdGFydE9mZnNldCA9IGlzQmFja3dhcmQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgY29uc3QgZW5kT2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICBsZXQgY3VycmVudE5vZGVQYXJlbnQ7XG4gIGxldCBsYXN0Q3JlYXRlZE1hcmtOb2RlOyAvLyBXZSBvbmx5IHdhbnQgd3JhcCBhZGphY2VudCB0ZXh0IG5vZGVzLCBsaW5lIGJyZWFrIG5vZGVzXG4gIC8vIGFuZCBpbmxpbmUgZWxlbWVudCBub2Rlcy4gRm9yIGRlY29yYXRvciBub2RlcyBhbmQgYmxvY2tcbiAgLy8gZWxlbWVudCBub2Rlcywgd2Ugc3RlcCBvdXQgb2YgdGhlaXIgYm91bmRhcnkgYW5kIHN0YXJ0XG4gIC8vIGFnYWluIGFmdGVyLCBpZiB0aGVyZSBhcmUgbW9yZSBub2Rlcy5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShsYXN0Q3JlYXRlZE1hcmtOb2RlKSAmJiBsYXN0Q3JlYXRlZE1hcmtOb2RlLmlzUGFyZW50T2Yobm9kZSkpIHtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBjaGlsZCBvZiB0aGUgbGFzdCBjcmVhdGVkIG1hcmsgbm9kZSwgdGhlcmUgaXMgbm90aGluZyB0byBkbyBoZXJlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0ZpcnN0Tm9kZSA9IGkgPT09IDA7XG4gICAgY29uc3QgaXNMYXN0Tm9kZSA9IGkgPT09IG5vZGVzTGVuZ3RoIC0gMTtcbiAgICBsZXQgdGFyZ2V0Tm9kZSA9IG51bGw7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgLy8gQ2FzZSAxOiBUaGUgbm9kZSBpcyBhIHRleHQgbm9kZSBhbmQgd2UgY2FuIHNwbGl0IGl0XG4gICAgICBjb25zdCB0ZXh0Q29udGVudFNpemUgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgY29uc3Qgc3RhcnRUZXh0T2Zmc2V0ID0gaXNGaXJzdE5vZGUgPyBzdGFydE9mZnNldCA6IDA7XG4gICAgICBjb25zdCBlbmRUZXh0T2Zmc2V0ID0gaXNMYXN0Tm9kZSA/IGVuZE9mZnNldCA6IHRleHRDb250ZW50U2l6ZTtcblxuICAgICAgaWYgKHN0YXJ0VGV4dE9mZnNldCA9PT0gMCAmJiBlbmRUZXh0T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzcGxpdE5vZGVzID0gbm9kZS5zcGxpdFRleHQoc3RhcnRUZXh0T2Zmc2V0LCBlbmRUZXh0T2Zmc2V0KTtcbiAgICAgIHRhcmdldE5vZGUgPSBzcGxpdE5vZGVzLmxlbmd0aCA+IDEgJiYgKHNwbGl0Tm9kZXMubGVuZ3RoID09PSAzIHx8IGlzRmlyc3ROb2RlICYmICFpc0xhc3ROb2RlIHx8IGVuZFRleHRPZmZzZXQgPT09IHRleHRDb250ZW50U2l6ZSkgPyBzcGxpdE5vZGVzWzFdIDogc3BsaXROb2Rlc1swXTtcbiAgICB9IGVsc2UgaWYgKCRpc01hcmtOb2RlKG5vZGUpKSB7XG4gICAgICAvLyBDYXNlIDI6IHRoZSBub2RlIGlzIGEgbWFyayBub2RlIGFuZCB3ZSBjYW4gaWdub3JlIGl0IGFzIGEgdGFyZ2V0LFxuICAgICAgLy8gbW92aW5nIG9uIHRvIGl0cyBjaGlsZHJlbi4gTm90ZSB0aGF0IHdoZW4gd2UgbWFrZSBhIG1hcmsgaW5zaWRlXG4gICAgICAvLyBhbm90aGVyIG1hcmssIGl0IG1heSB1dGxpbWF0ZWx5IGJlIHVubmVzdGVkIGJ5IGEgY2FsbCB0b1xuICAgICAgLy8gYHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyPE1hcmtOb2RlPmAgc29tZXdoZXJlIGVsc2UgaW4gdGhlXG4gICAgICAvLyBjb2RlYmFzZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCkpIHtcbiAgICAgIC8vIENhc2UgMzogaW5saW5lIGVsZW1lbnQgbm9kZXMgY2FuIGJlIGFkZGVkIGluIHRoZWlyIGVudGlyZXR5IHRvIHRoZSBuZXdcbiAgICAgIC8vIG1hcmtcbiAgICAgIHRhcmdldE5vZGUgPSBub2RlO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXROb2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIGEgdGFyZ2V0IG5vZGUgZm9yIHdyYXBwaW5nIHdpdGggYSBtYXJrLCB3ZSBjYW4gcnVuXG4gICAgICAvLyB0aHJvdWdoIHNwZWNpYWwgY2FzZXMuXG4gICAgICBpZiAodGFyZ2V0Tm9kZSAmJiB0YXJnZXROb2RlLmlzKGN1cnJlbnROb2RlUGFyZW50KSkge1xuICAgICAgICAvLyBUaGUgY3VycmVudCBub2RlIGlzIGEgY2hpbGQgb2YgdGhlIHRhcmdldCBub2RlIHRvIGJlIHdyYXBwZWQsIHRoZXJlXG4gICAgICAgIC8vIGlzIG5vdGhpbmcgdG8gZG8gaGVyZS5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSB0YXJnZXROb2RlLmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAocGFyZW50Tm9kZSA9PSBudWxsIHx8ICFwYXJlbnROb2RlLmlzKGN1cnJlbnROb2RlUGFyZW50KSkge1xuICAgICAgICAvLyBJZiB0aGUgcGFyZW50IG5vZGUgaXMgbm90IHRoZSBjdXJyZW50IG5vZGUncyBwYXJlbnQgbm9kZSwgd2UgY2FuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBsYXN0IGNyZWF0ZWQgbWFyayBub2RlLlxuICAgICAgICBsYXN0Q3JlYXRlZE1hcmtOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50Tm9kZVBhcmVudCA9IHBhcmVudE5vZGU7XG5cbiAgICAgIGlmIChsYXN0Q3JlYXRlZE1hcmtOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNyZWF0ZWQgbWFyayBub2RlLCB3ZSBjYW4gbWFrZSBvbmVcbiAgICAgICAgY29uc3QgY3JlYXRlTWFya05vZGUgPSBjcmVhdGVOb2RlIHx8ICRjcmVhdGVNYXJrTm9kZTtcbiAgICAgICAgbGFzdENyZWF0ZWRNYXJrTm9kZSA9IGNyZWF0ZU1hcmtOb2RlKFtpZF0pO1xuICAgICAgICB0YXJnZXROb2RlLmluc2VydEJlZm9yZShsYXN0Q3JlYXRlZE1hcmtOb2RlKTtcbiAgICAgIH0gLy8gQWRkIHRoZSB0YXJnZXQgbm9kZSB0byBiZSB3cmFwcGVkIGluIHRoZSBsYXRlc3QgY3JlYXRlZCBtYXJrIG5vZGVcblxuXG4gICAgICBsYXN0Q3JlYXRlZE1hcmtOb2RlLmFwcGVuZCh0YXJnZXROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHRhcmdldCBub2RlIHRvIHdyYXAgd2UgY2FuIGNsZWFyIG91ciBzdGF0ZSBhbmRcbiAgICAgIC8vIGNvbnRpbnVlIG9uIHdpdGggdGhlIG5leHQgbm9kZVxuICAgICAgY3VycmVudE5vZGVQYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICBsYXN0Q3JlYXRlZE1hcmtOb2RlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSAvLyBNYWtlIHNlbGVjdGlvbiBjb2xsYXBzZWQgYXQgdGhlIGVuZFxuXG5cbiAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobGFzdENyZWF0ZWRNYXJrTm9kZSkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgaXNCYWNrd2FyZCA/IGxhc3RDcmVhdGVkTWFya05vZGUuc2VsZWN0U3RhcnQoKSA6IGxhc3RDcmVhdGVkTWFya05vZGUuc2VsZWN0RW5kKCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRnZXRNYXJrSURzKG5vZGUsIG9mZnNldCkge1xuICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuXG4gIHdoaWxlIChjdXJyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIGlmICgkaXNNYXJrTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZS5nZXRJRHMoKTtcbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoY3VycmVudE5vZGUpICYmIG9mZnNldCA9PT0gY3VycmVudE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gY3VycmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgaWYgKCRpc01hcmtOb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgICByZXR1cm4gbmV4dFNpYmxpbmcuZ2V0SURzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnQoKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLiRjcmVhdGVNYXJrTm9kZSA9ICRjcmVhdGVNYXJrTm9kZTtcbmV4cG9ydHMuJGdldE1hcmtJRHMgPSAkZ2V0TWFya0lEcztcbmV4cG9ydHMuJGlzTWFya05vZGUgPSAkaXNNYXJrTm9kZTtcbmV4cG9ydHMuJHVud3JhcE1hcmtOb2RlID0gJHVud3JhcE1hcmtOb2RlO1xuZXhwb3J0cy4kd3JhcFNlbGVjdGlvbkluTWFya05vZGUgPSAkd3JhcFNlbGVjdGlvbkluTWFya05vZGU7XG5leHBvcnRzLk1hcmtOb2RlID0gTWFya05vZGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/mark/LexicalMark.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/mark/LexicalMark.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/mark/LexicalMark.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalMark =  true ? __webpack_require__(/*! ./LexicalMark.dev.js */ \"(ssr)/./node_modules/@lexical/mark/LexicalMark.dev.js\") : 0\nmodule.exports = LexicalMark;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFyay9MZXhpY2FsTWFyay5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLG9CQUFvQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsbUZBQXNCLElBQUksQ0FBZ0M7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9tYXJrL0xleGljYWxNYXJrLmpzP2FlODciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxNYXJrID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxNYXJrLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsTWFyay5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbE1hcms7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/mark/LexicalMark.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.dev.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/markdown/LexicalMarkdown.dev.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar code = __webpack_require__(/*! @lexical/code */ \"(ssr)/./node_modules/@lexical/code/LexicalCode.js\");\nvar list = __webpack_require__(/*! @lexical/list */ \"(ssr)/./node_modules/@lexical/list/LexicalList.js\");\nvar richText = __webpack_require__(/*! @lexical/rich-text */ \"(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar link = __webpack_require__(/*! @lexical/link */ \"(ssr)/./node_modules/@lexical/link/LexicalLink.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n\n  for (const item of list) {\n    const key = callback(item);\n\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createMarkdownExport(transformers) {\n  const byType = transformersByType(transformers); // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1);\n  return node => {\n    const output = [];\n    const children = (node || lexical.$getRoot()).getChildren();\n\n    for (const child of children) {\n      const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);\n\n      if (result != null) {\n        output.push(result);\n      }\n    }\n\n    return output.join('\\n\\n');\n  };\n}\n\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n\n    if (result != null) {\n      return result;\n    }\n  }\n\n  if (lexical.$isElementNode(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if (lexical.$isDecoratorNode(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\n\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers) {\n  const output = [];\n  const children = node.getChildren();\n\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));\n\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n\n    if (lexical.$isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if (lexical.$isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));\n    } else if (lexical.$isElementNode(child)) {\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));\n    } else if (lexical.$isDecoratorNode(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n\n  return output.join('');\n}\n\nfunction exportTextFormat(node, textContent, textTransformers) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // We instead want to trim the whitespace out, apply formatting, and then\n  // bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n  const frozenString = textContent.trim();\n  let output = frozenString;\n  const applied = new Set();\n\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format); // Prevent adding opening tag is already opened by the previous sibling\n\n      const previousNode = getTextSibling(node, true);\n\n      if (!hasFormat(previousNode, format)) {\n        output = tag + output;\n      } // Prevent adding closing tag if next sibling will do it\n\n\n      const nextNode = getTextSibling(node, false);\n\n      if (!hasFormat(nextNode, format)) {\n        output += tag;\n      }\n    }\n  } // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n\n\n  return textContent.replace(frozenString, output);\n} // Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\n\n\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  while (sibling) {\n    if (lexical.$isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n\n      if (lexical.$isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n\n    if (lexical.$isTextNode(sibling)) {\n      return sibling;\n    }\n\n    if (!lexical.$isElementNode(sibling)) {\n      return null;\n    }\n  }\n\n  return null;\n}\n\nfunction hasFormat(node, format) {\n  return lexical.$isTextNode(node) && node.hasFormat(format);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nconst CODE_BLOCK_REG_EXP = /^```(\\w{1,10})?\\s?$/;\nfunction createMarkdownImport(transformers) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = node || lexical.$getRoot();\n    root.clear();\n\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i]; // Codeblocks are processed first as anything inside such block\n      // is ignored for further processing\n      // TODO:\n      // Abstract it to be dynamic as other transformers (add multiline match option)\n\n      const [codeBlockNode, shiftedIndex] = importCodeBlock(lines, i, root);\n\n      if (codeBlockNode != null) {\n        i = shiftedIndex;\n        continue;\n      }\n\n      importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);\n    } // Removing empty paragraphs as md does not really\n    // allow empty lines and uses them as dilimiter\n\n\n    const children = root.getChildren();\n\n    for (const child of children) {\n      if (isEmptyParagraph(child)) {\n        child.remove();\n      }\n    }\n\n    if (lexical.$getSelection() !== null) {\n      root.selectEnd();\n    }\n  };\n}\n\nfunction isEmptyParagraph(node) {\n  if (!lexical.$isParagraphNode(node)) {\n    return false;\n  }\n\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\n\nfunction importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {\n  const lineTextTrimmed = lineText.trim();\n  const textNode = lexical.$createTextNode(lineTextTrimmed);\n  const elementNode = lexical.$createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      replace(elementNode, [textNode], match, true);\n      break;\n    }\n  }\n\n  importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers); // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n\n  if (elementNode.isAttached() && lineTextTrimmed.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n\n    if (lexical.$isParagraphNode(previousNode) || richText.$isQuoteNode(previousNode) || list.$isListNode(previousNode)) {\n      let targetNode = previousNode;\n\n      if (list.$isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = utils.$findMatchingParent(lastDescendant, list.$isListItemNode);\n        }\n      }\n\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\n\nfunction importCodeBlock(lines, startLineIndex, rootNode) {\n  const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);\n\n  if (openMatch) {\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n\n    while (++endLineIndex < linesLength) {\n      const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);\n\n      if (closeMatch) {\n        const codeBlockNode = code.$createCodeNode(openMatch[1]);\n        const textNode = lexical.$createTextNode(lines.slice(startLineIndex + 1, endLineIndex).join('\\n'));\n        codeBlockNode.append(textNode);\n        rootNode.append(codeBlockNode);\n        return [codeBlockNode, endLineIndex];\n      }\n    }\n  }\n\n  return [null, startLineIndex];\n} // Processing text content and replaces text format tags.\n// It takes outermost tag match and its content, creates text node with\n// format based on tag and then recursively executed over node's content\n//\n// E.g. for \"*Hello **world**!*\" string it will create text node with\n// \"Hello **world**!\" content and italic format and run recursively over\n// its content to transform \"**world**\" part\n\n\nfunction importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n\n  if (!match) {\n    // Once text format processing is done run text match transformers, as it\n    // only can span within single text node (unline formats that can cover multiple nodes)\n    importTextMatchTransformers(textNode, textMatchTransformers);\n    return;\n  }\n\n  let currentNode, remainderNode, leadingNode; // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n\n  if (match[0] === textContent) {\n    currentNode = textNode;\n  } else {\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n\n    if (startIndex === 0) {\n      [currentNode, remainderNode] = textNode.splitText(endIndex);\n    } else {\n      [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n\n  currentNode.setTextContent(match[2]);\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!currentNode.hasFormat(format)) {\n        currentNode.toggleFormat(format);\n      }\n    }\n  } // Recursively run over inner text if it's not inline code\n\n\n  if (!currentNode.hasFormat('code')) {\n    importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);\n  } // Run over leading/remaining text if any\n\n\n  if (leadingNode) {\n    importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n\n  if (remainderNode) {\n    importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n}\n\nfunction importTextMatchTransformers(textNode_, textMatchTransformers) {\n  let textNode = textNode_;\n\n  mainLoop: while (textNode) {\n    for (const transformer of textMatchTransformers) {\n      const match = textNode.getTextContent().match(transformer.importRegExp);\n\n      if (!match) {\n        continue;\n      }\n\n      const startIndex = match.index || 0;\n      const endIndex = startIndex + match[0].length;\n      let replaceNode, leftTextNode, rightTextNode;\n\n      if (startIndex === 0) {\n        [replaceNode, textNode] = textNode.splitText(endIndex);\n      } else {\n        [leftTextNode, replaceNode, rightTextNode] = textNode.splitText(startIndex, endIndex);\n      }\n\n      if (leftTextNode) {\n        importTextMatchTransformers(leftTextNode, textMatchTransformers);\n      }\n\n      if (rightTextNode) {\n        textNode = rightTextNode;\n      }\n\n      transformer.replace(replaceNode, match);\n      continue mainLoop;\n    }\n\n    break;\n  }\n} // Finds first \"<tag>content<tag>\" match that is not nested into another tag\n\n\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n\n  if (openTagsMatch == null) {\n    return null;\n  }\n\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      } // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n\n\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n\n    if (IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\\\s])(.*?[^${tagRegExp}\\\\s])${tagRegExp}(?!${tagRegExp})`);\n    } else {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    }\n  }\n\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Reg exp to find opening tags\n    openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? '' : `${escapeRegExp}`) + '(' + openTagsRegExp.join('|') + ')', 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n\n  if (!lexical.$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n\n  const textContent = anchorNode.getTextContent(); // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n\n    if (match && match[0].length === anchorOffset) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      leadingNode.remove();\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      replace(parentNode, siblings, match, false);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n\n  if (transformers == null) {\n    return false;\n  } // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n\n\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n\n  for (const transformer of transformers) {\n    const match = textContent.match(transformer.regExp);\n\n    if (match === null) {\n      continue;\n    }\n\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n\n  return false;\n}\n\nfunction runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex]; // Quick check if we're possibly at the end of inline markdown style\n\n  const matchers = textFormatTransformers[closeChar];\n\n  if (!matchers) {\n    return false;\n  }\n\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1; // If tag is not single char check if rest of it matches with text content\n\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    } // Space before closing tag cancels inline markdown\n\n\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    } // Some tags can not be used within words, hence should have newline/space/punctuation after it\n\n\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag); // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n\n    let sibling = openNode;\n\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if (lexical.$isLineBreakNode(sibling)) {\n        break;\n      }\n\n      if (lexical.$isTextNode(sibling)) {\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    } // Opening tag is not found\n\n\n    if (openTagStartIndex < 0) {\n      continue;\n    } // No content between opening and closing tag\n\n\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    } // Checking longer tags for repeating chars (e.g. *** vs **)\n\n\n    const prevOpenNodeText = openNode.getTextContent();\n\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    } // Some tags can not be used within words, hence should have newline/space/punctuation before it\n\n\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    } // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n\n\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = lexical.$getSelection();\n    const nextSelection = lexical.$createRangeSelection();\n    lexical.$setSelection(nextSelection); // Adjust offset based on deleted chars\n\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text'); // Apply formatting to selected text\n\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    } // Collapse selection up to the focus point\n\n\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type); // Remove formatting from collapsed selection\n\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n\n    if (lexical.$isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) && // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n\n  return -1;\n}\n\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersIndex = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n\n  for (const transformer of transformers) {\n    const type = transformer.type;\n\n    if (type === 'element' || type === 'text-match') {\n      const dependencies = transformer.dependencies;\n\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          {\n            throw Error(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n  }\n\n  const transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {\n      return;\n    }\n\n    runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);\n  };\n\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from undo/redo (as changes already calculated)\n    if (tags.has('historic')) {\n      return;\n    } // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n\n\n    if (editor.isComposing()) {\n      return;\n    }\n\n    const selection = editorState.read(lexical.$getSelection);\n    const prevSelection = prevEditorState.read(lexical.$getSelection);\n\n    if (!lexical.$isRangeSelection(prevSelection) || !lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return;\n    }\n\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n\n    if (!lexical.$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {\n      return;\n    }\n\n    editor.update(() => {\n      // Markdown is not available inside code\n      if (anchorNode.hasFormat('code')) {\n        return;\n      }\n\n      const parentNode = anchorNode.getParent();\n\n      if (parentNode === null || code.$isCodeNode(parentNode)) {\n        return;\n      }\n\n      transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst createBlockNode = createNode => {\n  return (parentNode, children, match) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  };\n}; // Amount of spaces that define indentation level\n// TODO: should be an option\n\n\nconst LIST_INDENT_SIZE = 4;\n\nconst listReplace = listType => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const nextNode = parentNode.getNextSibling();\n    const listItem = list.$createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n\n    if (list.$isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild();\n\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem);\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem);\n      }\n\n      parentNode.remove();\n    } else if (list.$isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list$1 = list.$createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list$1.append(listItem);\n      parentNode.replace(list$1);\n    }\n\n    listItem.append(...children);\n    listItem.select(0, 0);\n    const indent = Math.floor(match[1].length / LIST_INDENT_SIZE);\n\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\n\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n\n  for (const listItemNode of children) {\n    if (list.$isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n\n        if (list.$isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n\n  return output.join('\\n');\n};\n\nconst HEADING = {\n  dependencies: [richText.HeadingNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isHeadingNode(node)) {\n      return null;\n    }\n\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: /^(#{1,6})\\s/,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return richText.$createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [richText.QuoteNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isQuoteNode(node)) {\n      return null;\n    }\n\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n\n    return output.join('\\n');\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n\n      if (richText.$isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...children]);\n        previousNode.select(0, 0);\n        parentNode.remove();\n        return;\n      }\n    }\n\n    const node = richText.$createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [code.CodeNode],\n  export: node => {\n    if (!code.$isCodeNode(node)) {\n      return null;\n    }\n\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExp: /^```(\\w{1,10})?\\s/,\n  replace: createBlockNode(match => {\n    return code.$createCodeNode(match ? match[1] : undefined);\n  }),\n  type: 'element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(\\d{1,})\\.\\s/,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n}; // Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\n\nconst LINK = {\n  dependencies: [link.LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!link.$isLinkNode(node)) {\n      return null;\n    }\n\n    const title = node.getTitle();\n    const linkContent = title ? `[${node.getTextContent()}](${node.getURL()} \"${title}\")` : `[${node.getTextContent()}](${node.getURL()})`;\n    const firstChild = node.getFirstChild(); // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n\n    if (node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild)) {\n      return exportFormat(firstChild, linkContent);\n    } else {\n      return linkContent;\n    }\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl, linkTitle] = match;\n    const linkNode = link.$createLinkNode(linkUrl, {\n      title: linkTitle\n    });\n    const linkTextNode = lexical.$createTextNode(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n  },\n  trigger: ')',\n  type: 'text-match'\n};\n\n/** @module @lexical/markdown */\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, CODE, UNORDERED_LIST, ORDERED_LIST]; // Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\n\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\n\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node) {\n  const importMarkdown = createMarkdownImport(transformers);\n  return importMarkdown(markdown, node);\n}\n\nfunction $convertToMarkdownString(transformers = TRANSFORMERS, node) {\n  const exportMarkdown = createMarkdownExport(transformers);\n  return exportMarkdown(node);\n}\n\nexports.$convertFromMarkdownString = $convertFromMarkdownString;\nexports.$convertToMarkdownString = $convertToMarkdownString;\nexports.BOLD_ITALIC_STAR = BOLD_ITALIC_STAR;\nexports.BOLD_ITALIC_UNDERSCORE = BOLD_ITALIC_UNDERSCORE;\nexports.BOLD_STAR = BOLD_STAR;\nexports.BOLD_UNDERSCORE = BOLD_UNDERSCORE;\nexports.CHECK_LIST = CHECK_LIST;\nexports.CODE = CODE;\nexports.ELEMENT_TRANSFORMERS = ELEMENT_TRANSFORMERS;\nexports.HEADING = HEADING;\nexports.HIGHLIGHT = HIGHLIGHT;\nexports.INLINE_CODE = INLINE_CODE;\nexports.ITALIC_STAR = ITALIC_STAR;\nexports.ITALIC_UNDERSCORE = ITALIC_UNDERSCORE;\nexports.LINK = LINK;\nexports.ORDERED_LIST = ORDERED_LIST;\nexports.QUOTE = QUOTE;\nexports.STRIKETHROUGH = STRIKETHROUGH;\nexports.TEXT_FORMAT_TRANSFORMERS = TEXT_FORMAT_TRANSFORMERS;\nexports.TEXT_MATCH_TRANSFORMERS = TEXT_MATCH_TRANSFORMERS;\nexports.TRANSFORMERS = TRANSFORMERS;\nexports.UNORDERED_LIST = UNORDERED_LIST;\nexports.registerMarkdownShortcuts = registerMarkdownShortcuts;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFya2Rvd24vTGV4aWNhbE1hcmtkb3duLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsd0RBQVM7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLHdFQUFlO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyx3RUFBZTtBQUNsQyxlQUFlLG1CQUFPLENBQUMsc0ZBQW9CO0FBQzNDLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLHdFQUFlOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7O0FBRUEsK0VBQStFOztBQUUvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDLG9DQUFvQyxLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhGQUE4RjtBQUM5RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsVUFBVSxPQUFPLFVBQVUsYUFBYSxVQUFVLE9BQU8sVUFBVSxLQUFLLFVBQVU7QUFDbkksTUFBTTtBQUNOLHlEQUF5RCxVQUFVLEtBQUssVUFBVSxTQUFTLFVBQVUsU0FBUyxVQUFVLFdBQVcsVUFBVSwrQkFBK0IsVUFBVSxXQUFXLFVBQVU7QUFDM007QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixhQUFhO0FBQzlGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsaUVBQWlFOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdGQUF3RjtBQUN4Rjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR04sNkdBQTZHOztBQUU3RztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxnQkFBZ0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCw0QkFBNEIsbUNBQW1DLHNDQUFzQztBQUNySjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWUsSUFBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHFCQUFxQixHQUFHO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxzQkFBc0IsSUFBSSxlQUFlLEdBQUcsTUFBTSxVQUFVLHNCQUFzQixJQUFJLGNBQWM7QUFDeEksNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDLGdDQUFnQztBQUNoQyx3QkFBd0I7QUFDeEIsOEJBQThCO0FBQzlCLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWiw0QkFBNEI7QUFDNUIsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLHlCQUF5QjtBQUN6QixZQUFZO0FBQ1osb0JBQW9CO0FBQ3BCLGFBQWE7QUFDYixxQkFBcUI7QUFDckIsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL21hcmtkb3duL0xleGljYWxNYXJrZG93bi5kZXYuanM/NTBmMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG52YXIgY29kZSA9IHJlcXVpcmUoJ0BsZXhpY2FsL2NvZGUnKTtcbnZhciBsaXN0ID0gcmVxdWlyZSgnQGxleGljYWwvbGlzdCcpO1xudmFyIHJpY2hUZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmljaC10ZXh0Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxpbmsgPSByZXF1aXJlKCdAbGV4aWNhbC9saW5rJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gaW5kZXhCeShsaXN0LCBjYWxsYmFjaykge1xuICBjb25zdCBpbmRleCA9IHt9O1xuXG4gIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0KSB7XG4gICAgY29uc3Qga2V5ID0gY2FsbGJhY2soaXRlbSk7XG5cbiAgICBpZiAoaW5kZXhba2V5XSkge1xuICAgICAgaW5kZXhba2V5XS5wdXNoKGl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleFtrZXldID0gW2l0ZW1dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyc0J5VHlwZSh0cmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgYnlUeXBlID0gaW5kZXhCeSh0cmFuc2Zvcm1lcnMsIHQgPT4gdC50eXBlKTtcbiAgcmV0dXJuIHtcbiAgICBlbGVtZW50OiBieVR5cGUuZWxlbWVudCB8fCBbXSxcbiAgICB0ZXh0Rm9ybWF0OiBieVR5cGVbJ3RleHQtZm9ybWF0J10gfHwgW10sXG4gICAgdGV4dE1hdGNoOiBieVR5cGVbJ3RleHQtbWF0Y2gnXSB8fCBbXVxuICB9O1xufVxuY29uc3QgUFVOQ1RVQVRJT05fT1JfU1BBQ0UgPSAvWyEtLzotQFstYHstflxcc10vO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBjcmVhdGVNYXJrZG93bkV4cG9ydCh0cmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgYnlUeXBlID0gdHJhbnNmb3JtZXJzQnlUeXBlKHRyYW5zZm9ybWVycyk7IC8vIEV4cG9ydCBvbmx5IHVzZXMgdGV4dCBmb3JtYXRzIHRoYXQgYXJlIHJlc3BvbnNpYmxlIGZvciBzaW5nbGUgZm9ybWF0XG4gIC8vIGUuZy4gaXQgd2lsbCBmaWx0ZXIgb3V0ICoqKiAoYm9sZCwgaXRhbGljKSBhbmQgaW5zdGVhZCB1c2Ugc2VwYXJhdGUgKiogYW5kICpcblxuICBjb25zdCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzID0gYnlUeXBlLnRleHRGb3JtYXQuZmlsdGVyKHRyYW5zZm9ybWVyID0+IHRyYW5zZm9ybWVyLmZvcm1hdC5sZW5ndGggPT09IDEpO1xuICByZXR1cm4gbm9kZSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgY29uc3QgY2hpbGRyZW4gPSAobm9kZSB8fCBsZXhpY2FsLiRnZXRSb290KCkpLmdldENoaWxkcmVuKCk7XG5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBleHBvcnRUb3BMZXZlbEVsZW1lbnRzKGNoaWxkLCBieVR5cGUuZWxlbWVudCwgdGV4dEZvcm1hdFRyYW5zZm9ybWVycywgYnlUeXBlLnRleHRNYXRjaCk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBvdXRwdXQucHVzaChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbignXFxuXFxuJyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cG9ydFRvcExldmVsRWxlbWVudHMobm9kZSwgZWxlbWVudFRyYW5zZm9ybWVycywgdGV4dFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpIHtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiBlbGVtZW50VHJhbnNmb3JtZXJzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNmb3JtZXIuZXhwb3J0KG5vZGUsIF9ub2RlID0+IGV4cG9ydENoaWxkcmVuKF9ub2RlLCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycykpO1xuXG4gICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIGV4cG9ydENoaWxkcmVuKG5vZGUsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKTtcbiAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cG9ydENoaWxkcmVuKG5vZGUsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcblxuICBtYWluTG9vcDogZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0cmFuc2Zvcm1lci5leHBvcnQoY2hpbGQsIHBhcmVudE5vZGUgPT4gZXhwb3J0Q2hpbGRyZW4ocGFyZW50Tm9kZSwgdGV4dFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpLCAodGV4dE5vZGUsIHRleHRDb250ZW50KSA9PiBleHBvcnRUZXh0Rm9ybWF0KHRleHROb2RlLCB0ZXh0Q29udGVudCwgdGV4dFRyYW5zZm9ybWVyc0luZGV4KSk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBvdXRwdXQucHVzaChyZXN1bHQpO1xuICAgICAgICBjb250aW51ZSBtYWluTG9vcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKGNoaWxkKSkge1xuICAgICAgb3V0cHV0LnB1c2goJ1xcbicpO1xuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGV4cG9ydFRleHRGb3JtYXQoY2hpbGQsIGNoaWxkLmdldFRleHRDb250ZW50KCksIHRleHRUcmFuc2Zvcm1lcnNJbmRleCkpO1xuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjaGlsZCkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGV4cG9ydENoaWxkcmVuKGNoaWxkLCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycykpO1xuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNEZWNvcmF0b3JOb2RlKGNoaWxkKSkge1xuICAgICAgb3V0cHV0LnB1c2goY2hpbGQuZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gZXhwb3J0VGV4dEZvcm1hdChub2RlLCB0ZXh0Q29udGVudCwgdGV4dFRyYW5zZm9ybWVycykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIGNhc2Ugb2YgYSBzdHJpbmcgbG9va2luZyBsaWtlIHRoaXM6IFwiICAgZm9vICAgXCJcbiAgLy8gV2hlcmUgaXQgd291bGQgYmUgaW52YWxpZCBtYXJrZG93biB0byBnZW5lcmF0ZTogXCIqKiAgIGZvbyAgICoqXCJcbiAgLy8gV2UgaW5zdGVhZCB3YW50IHRvIHRyaW0gdGhlIHdoaXRlc3BhY2Ugb3V0LCBhcHBseSBmb3JtYXR0aW5nLCBhbmQgdGhlblxuICAvLyBicmluZyB0aGUgd2hpdGVzcGFjZSBiYWNrLiBTbyBvdXIgcmV0dXJuZWQgc3RyaW5nIGxvb2tzIGxpa2UgdGhpczogXCIgICAqKmZvbyoqICAgXCJcbiAgY29uc3QgZnJvemVuU3RyaW5nID0gdGV4dENvbnRlbnQudHJpbSgpO1xuICBsZXQgb3V0cHV0ID0gZnJvemVuU3RyaW5nO1xuICBjb25zdCBhcHBsaWVkID0gbmV3IFNldCgpO1xuXG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdGV4dFRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRyYW5zZm9ybWVyLmZvcm1hdFswXTtcbiAgICBjb25zdCB0YWcgPSB0cmFuc2Zvcm1lci50YWc7XG5cbiAgICBpZiAoaGFzRm9ybWF0KG5vZGUsIGZvcm1hdCkgJiYgIWFwcGxpZWQuaGFzKGZvcm1hdCkpIHtcbiAgICAgIC8vIE11bHRpcGxlIHRhZ3MgbWlnaHQgYmUgdXNlZCBmb3IgdGhlIHNhbWUgZm9ybWF0ICgqLCBfKVxuICAgICAgYXBwbGllZC5hZGQoZm9ybWF0KTsgLy8gUHJldmVudCBhZGRpbmcgb3BlbmluZyB0YWcgaXMgYWxyZWFkeSBvcGVuZWQgYnkgdGhlIHByZXZpb3VzIHNpYmxpbmdcblxuICAgICAgY29uc3QgcHJldmlvdXNOb2RlID0gZ2V0VGV4dFNpYmxpbmcobm9kZSwgdHJ1ZSk7XG5cbiAgICAgIGlmICghaGFzRm9ybWF0KHByZXZpb3VzTm9kZSwgZm9ybWF0KSkge1xuICAgICAgICBvdXRwdXQgPSB0YWcgKyBvdXRwdXQ7XG4gICAgICB9IC8vIFByZXZlbnQgYWRkaW5nIGNsb3NpbmcgdGFnIGlmIG5leHQgc2libGluZyB3aWxsIGRvIGl0XG5cblxuICAgICAgY29uc3QgbmV4dE5vZGUgPSBnZXRUZXh0U2libGluZyhub2RlLCBmYWxzZSk7XG5cbiAgICAgIGlmICghaGFzRm9ybWF0KG5leHROb2RlLCBmb3JtYXQpKSB7XG4gICAgICAgIG91dHB1dCArPSB0YWc7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlcGxhY2UgdHJpbW1lZCB2ZXJzaW9uIG9mIHRleHRDb250ZW50IGVuc3VyaW5nIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2UgaXMgbm90IG1vZGlmaWVkXG5cblxuICByZXR1cm4gdGV4dENvbnRlbnQucmVwbGFjZShmcm96ZW5TdHJpbmcsIG91dHB1dCk7XG59IC8vIEdldCBuZXh0IG9yIHByZXZpb3VzIHRleHQgc2libGluZyBhIHRleHQgbm9kZSwgaW5jbHVkaW5nIGNhc2VzXG4vLyB3aGVuIGl0J3MgYSBjaGlsZCBvZiBpbmxpbmUgZWxlbWVudCAoZS5nLiBsaW5rKVxuXG5cbmZ1bmN0aW9uIGdldFRleHRTaWJsaW5nKG5vZGUsIGJhY2t3YXJkKSB7XG4gIGxldCBzaWJsaW5nID0gYmFja3dhcmQgPyBub2RlLmdldFByZXZpb3VzU2libGluZygpIDogbm9kZS5nZXROZXh0U2libGluZygpO1xuXG4gIGlmICghc2libGluZykge1xuICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gICAgaWYgKHBhcmVudC5pc0lubGluZSgpKSB7XG4gICAgICBzaWJsaW5nID0gYmFja3dhcmQgPyBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBwYXJlbnQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoc2libGluZykge1xuICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKHNpYmxpbmcpKSB7XG4gICAgICBpZiAoIXNpYmxpbmcuaXNJbmxpbmUoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVzY2VuZGFudCA9IGJhY2t3YXJkID8gc2libGluZy5nZXRMYXN0RGVzY2VuZGFudCgpIDogc2libGluZy5nZXRGaXJzdERlc2NlbmRhbnQoKTtcblxuICAgICAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoZGVzY2VuZGFudCkpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NlbmRhbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWJsaW5nID0gYmFja3dhcmQgPyBzaWJsaW5nLmdldFByZXZpb3VzU2libGluZygpIDogc2libGluZy5nZXROZXh0U2libGluZygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKHNpYmxpbmcpKSB7XG4gICAgICByZXR1cm4gc2libGluZztcbiAgICB9XG5cbiAgICBpZiAoIWxleGljYWwuJGlzRWxlbWVudE5vZGUoc2libGluZykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBoYXNGb3JtYXQobm9kZSwgZm9ybWF0KSB7XG4gIHJldHVybiBsZXhpY2FsLiRpc1RleHROb2RlKG5vZGUpICYmIG5vZGUuaGFzRm9ybWF0KGZvcm1hdCk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgZG9jdW1lbnRNb2RlID0gQ0FOX1VTRV9ET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBudWxsO1xuQ0FOX1VTRV9ET00gJiYgL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5DQU5fVVNFX0RPTSAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5DQU5fVVNFX0RPTSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcbmNvbnN0IElTX1NBRkFSSSA9IENBTl9VU0VfRE9NICYmIC9WZXJzaW9uXFwvW1xcZC5dKy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgSVNfSU9TID0gQ0FOX1VTRV9ET00gJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTsgLy8gS2VlcCB0aGVzZSBpbiBjYXNlIHdlIG5lZWQgdG8gdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZS5cbi8vIGV4cG9ydCBjb25zdCBJU19XSU5ET1dTOiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG5jb25zdCBJU19DSFJPTUUgPSBDQU5fVVNFX0RPTSAmJiAvXig/PS4qQ2hyb21lKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gZXhwb3J0IGNvbnN0IGNhblVzZVRleHRJbnB1dEV2ZW50OiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbmNvbnN0IElTX0FQUExFX1dFQktJVCA9IENBTl9VU0VfRE9NICYmIC9BcHBsZVdlYktpdFxcL1tcXGQuXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIUlTX0NIUk9NRTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgTUFSS0RPV05fRU1QVFlfTElORV9SRUdfRVhQID0gL15cXHN7MCwzfSQvO1xuY29uc3QgQ09ERV9CTE9DS19SRUdfRVhQID0gL15gYGAoXFx3ezEsMTB9KT9cXHM/JC87XG5mdW5jdGlvbiBjcmVhdGVNYXJrZG93bkltcG9ydCh0cmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgYnlUeXBlID0gdHJhbnNmb3JtZXJzQnlUeXBlKHRyYW5zZm9ybWVycyk7XG4gIGNvbnN0IHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCA9IGNyZWF0ZVRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleChieVR5cGUudGV4dEZvcm1hdCk7XG4gIHJldHVybiAobWFya2Rvd25TdHJpbmcsIG5vZGUpID0+IHtcbiAgICBjb25zdCBsaW5lcyA9IG1hcmtkb3duU3RyaW5nLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBsaW5lc0xlbmd0aCA9IGxpbmVzLmxlbmd0aDtcbiAgICBjb25zdCByb290ID0gbm9kZSB8fCBsZXhpY2FsLiRnZXRSb290KCk7XG4gICAgcm9vdC5jbGVhcigpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lc0xlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsaW5lVGV4dCA9IGxpbmVzW2ldOyAvLyBDb2RlYmxvY2tzIGFyZSBwcm9jZXNzZWQgZmlyc3QgYXMgYW55dGhpbmcgaW5zaWRlIHN1Y2ggYmxvY2tcbiAgICAgIC8vIGlzIGlnbm9yZWQgZm9yIGZ1cnRoZXIgcHJvY2Vzc2luZ1xuICAgICAgLy8gVE9ETzpcbiAgICAgIC8vIEFic3RyYWN0IGl0IHRvIGJlIGR5bmFtaWMgYXMgb3RoZXIgdHJhbnNmb3JtZXJzIChhZGQgbXVsdGlsaW5lIG1hdGNoIG9wdGlvbilcblxuICAgICAgY29uc3QgW2NvZGVCbG9ja05vZGUsIHNoaWZ0ZWRJbmRleF0gPSBpbXBvcnRDb2RlQmxvY2sobGluZXMsIGksIHJvb3QpO1xuXG4gICAgICBpZiAoY29kZUJsb2NrTm9kZSAhPSBudWxsKSB7XG4gICAgICAgIGkgPSBzaGlmdGVkSW5kZXg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpbXBvcnRCbG9ja3MobGluZVRleHQsIHJvb3QsIGJ5VHlwZS5lbGVtZW50LCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIGJ5VHlwZS50ZXh0TWF0Y2gpO1xuICAgIH0gLy8gUmVtb3ZpbmcgZW1wdHkgcGFyYWdyYXBocyBhcyBtZCBkb2VzIG5vdCByZWFsbHlcbiAgICAvLyBhbGxvdyBlbXB0eSBsaW5lcyBhbmQgdXNlcyB0aGVtIGFzIGRpbGltaXRlclxuXG5cbiAgICBjb25zdCBjaGlsZHJlbiA9IHJvb3QuZ2V0Q2hpbGRyZW4oKTtcblxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChpc0VtcHR5UGFyYWdyYXBoKGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCkgIT09IG51bGwpIHtcbiAgICAgIHJvb3Quc2VsZWN0RW5kKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0VtcHR5UGFyYWdyYXBoKG5vZGUpIHtcbiAgaWYgKCFsZXhpY2FsLiRpc1BhcmFncmFwaE5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBmaXJzdENoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gIHJldHVybiBmaXJzdENoaWxkID09IG51bGwgfHwgbm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSAmJiBsZXhpY2FsLiRpc1RleHROb2RlKGZpcnN0Q2hpbGQpICYmIE1BUktET1dOX0VNUFRZX0xJTkVfUkVHX0VYUC50ZXN0KGZpcnN0Q2hpbGQuZ2V0VGV4dENvbnRlbnQoKSk7XG59XG5cbmZ1bmN0aW9uIGltcG9ydEJsb2NrcyhsaW5lVGV4dCwgcm9vdE5vZGUsIGVsZW1lbnRUcmFuc2Zvcm1lcnMsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IGxpbmVUZXh0VHJpbW1lZCA9IGxpbmVUZXh0LnRyaW0oKTtcbiAgY29uc3QgdGV4dE5vZGUgPSBsZXhpY2FsLiRjcmVhdGVUZXh0Tm9kZShsaW5lVGV4dFRyaW1tZWQpO1xuICBjb25zdCBlbGVtZW50Tm9kZSA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgZWxlbWVudE5vZGUuYXBwZW5kKHRleHROb2RlKTtcbiAgcm9vdE5vZGUuYXBwZW5kKGVsZW1lbnROb2RlKTtcblxuICBmb3IgKGNvbnN0IHtcbiAgICByZWdFeHAsXG4gICAgcmVwbGFjZVxuICB9IG9mIGVsZW1lbnRUcmFuc2Zvcm1lcnMpIHtcbiAgICBjb25zdCBtYXRjaCA9IGxpbmVUZXh0Lm1hdGNoKHJlZ0V4cCk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHRleHROb2RlLnNldFRleHRDb250ZW50KGxpbmVUZXh0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCkpO1xuICAgICAgcmVwbGFjZShlbGVtZW50Tm9kZSwgW3RleHROb2RlXSwgbWF0Y2gsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaW1wb3J0VGV4dEZvcm1hdFRyYW5zZm9ybWVycyh0ZXh0Tm9kZSwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpOyAvLyBJZiBubyB0cmFuc2Zvcm1lciBmb3VuZCBhbmQgd2UgbGVmdCB3aXRoIG9yaWdpbmFsIHBhcmFncmFwaCBub2RlXG4gIC8vIGNhbiBjaGVjayBpZiBpdHMgY29udGVudCBjYW4gYmUgYXBwZW5kZWQgdG8gdGhlIHByZXZpb3VzIG5vZGVcbiAgLy8gaWYgaXQncyBhIHBhcmFncmFwaCwgcXVvdGUgb3IgbGlzdFxuXG4gIGlmIChlbGVtZW50Tm9kZS5pc0F0dGFjaGVkKCkgJiYgbGluZVRleHRUcmltbWVkLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBwcmV2aW91c05vZGUgPSBlbGVtZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1BhcmFncmFwaE5vZGUocHJldmlvdXNOb2RlKSB8fCByaWNoVGV4dC4kaXNRdW90ZU5vZGUocHJldmlvdXNOb2RlKSB8fCBsaXN0LiRpc0xpc3ROb2RlKHByZXZpb3VzTm9kZSkpIHtcbiAgICAgIGxldCB0YXJnZXROb2RlID0gcHJldmlvdXNOb2RlO1xuXG4gICAgICBpZiAobGlzdC4kaXNMaXN0Tm9kZShwcmV2aW91c05vZGUpKSB7XG4gICAgICAgIGNvbnN0IGxhc3REZXNjZW5kYW50ID0gcHJldmlvdXNOb2RlLmdldExhc3REZXNjZW5kYW50KCk7XG5cbiAgICAgICAgaWYgKGxhc3REZXNjZW5kYW50ID09IG51bGwpIHtcbiAgICAgICAgICB0YXJnZXROb2RlID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXROb2RlID0gdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChsYXN0RGVzY2VuZGFudCwgbGlzdC4kaXNMaXN0SXRlbU5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXROb2RlICE9IG51bGwgJiYgdGFyZ2V0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSA+IDApIHtcbiAgICAgICAgdGFyZ2V0Tm9kZS5zcGxpY2UodGFyZ2V0Tm9kZS5nZXRDaGlsZHJlblNpemUoKSwgMCwgW2xleGljYWwuJGNyZWF0ZUxpbmVCcmVha05vZGUoKSwgLi4uZWxlbWVudE5vZGUuZ2V0Q2hpbGRyZW4oKV0pO1xuICAgICAgICBlbGVtZW50Tm9kZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW1wb3J0Q29kZUJsb2NrKGxpbmVzLCBzdGFydExpbmVJbmRleCwgcm9vdE5vZGUpIHtcbiAgY29uc3Qgb3Blbk1hdGNoID0gbGluZXNbc3RhcnRMaW5lSW5kZXhdLm1hdGNoKENPREVfQkxPQ0tfUkVHX0VYUCk7XG5cbiAgaWYgKG9wZW5NYXRjaCkge1xuICAgIGxldCBlbmRMaW5lSW5kZXggPSBzdGFydExpbmVJbmRleDtcbiAgICBjb25zdCBsaW5lc0xlbmd0aCA9IGxpbmVzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2VuZExpbmVJbmRleCA8IGxpbmVzTGVuZ3RoKSB7XG4gICAgICBjb25zdCBjbG9zZU1hdGNoID0gbGluZXNbZW5kTGluZUluZGV4XS5tYXRjaChDT0RFX0JMT0NLX1JFR19FWFApO1xuXG4gICAgICBpZiAoY2xvc2VNYXRjaCkge1xuICAgICAgICBjb25zdCBjb2RlQmxvY2tOb2RlID0gY29kZS4kY3JlYXRlQ29kZU5vZGUob3Blbk1hdGNoWzFdKTtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBsZXhpY2FsLiRjcmVhdGVUZXh0Tm9kZShsaW5lcy5zbGljZShzdGFydExpbmVJbmRleCArIDEsIGVuZExpbmVJbmRleCkuam9pbignXFxuJykpO1xuICAgICAgICBjb2RlQmxvY2tOb2RlLmFwcGVuZCh0ZXh0Tm9kZSk7XG4gICAgICAgIHJvb3ROb2RlLmFwcGVuZChjb2RlQmxvY2tOb2RlKTtcbiAgICAgICAgcmV0dXJuIFtjb2RlQmxvY2tOb2RlLCBlbmRMaW5lSW5kZXhdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbbnVsbCwgc3RhcnRMaW5lSW5kZXhdO1xufSAvLyBQcm9jZXNzaW5nIHRleHQgY29udGVudCBhbmQgcmVwbGFjZXMgdGV4dCBmb3JtYXQgdGFncy5cbi8vIEl0IHRha2VzIG91dGVybW9zdCB0YWcgbWF0Y2ggYW5kIGl0cyBjb250ZW50LCBjcmVhdGVzIHRleHQgbm9kZSB3aXRoXG4vLyBmb3JtYXQgYmFzZWQgb24gdGFnIGFuZCB0aGVuIHJlY3Vyc2l2ZWx5IGV4ZWN1dGVkIG92ZXIgbm9kZSdzIGNvbnRlbnRcbi8vXG4vLyBFLmcuIGZvciBcIipIZWxsbyAqKndvcmxkKiohKlwiIHN0cmluZyBpdCB3aWxsIGNyZWF0ZSB0ZXh0IG5vZGUgd2l0aFxuLy8gXCJIZWxsbyAqKndvcmxkKiohXCIgY29udGVudCBhbmQgaXRhbGljIGZvcm1hdCBhbmQgcnVuIHJlY3Vyc2l2ZWx5IG92ZXJcbi8vIGl0cyBjb250ZW50IHRvIHRyYW5zZm9ybSBcIioqd29ybGQqKlwiIHBhcnRcblxuXG5mdW5jdGlvbiBpbXBvcnRUZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKHRleHROb2RlLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycykge1xuICBjb25zdCB0ZXh0Q29udGVudCA9IHRleHROb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IG1hdGNoID0gZmluZE91dGVybW9zdE1hdGNoKHRleHRDb250ZW50LCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICAvLyBPbmNlIHRleHQgZm9ybWF0IHByb2Nlc3NpbmcgaXMgZG9uZSBydW4gdGV4dCBtYXRjaCB0cmFuc2Zvcm1lcnMsIGFzIGl0XG4gICAgLy8gb25seSBjYW4gc3BhbiB3aXRoaW4gc2luZ2xlIHRleHQgbm9kZSAodW5saW5lIGZvcm1hdHMgdGhhdCBjYW4gY292ZXIgbXVsdGlwbGUgbm9kZXMpXG4gICAgaW1wb3J0VGV4dE1hdGNoVHJhbnNmb3JtZXJzKHRleHROb2RlLCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBjdXJyZW50Tm9kZSwgcmVtYWluZGVyTm9kZSwgbGVhZGluZ05vZGU7IC8vIElmIG1hdGNoaW5nIGZ1bGwgY29udGVudCB0aGVyZSdzIG5vIG5lZWQgdG8gcnVuIHNwbGl0VGV4dCBhbmQgY2FuIHJldXNlIGV4aXN0aW5nIHRleHROb2RlXG4gIC8vIHRvIHVwZGF0ZSBpdHMgY29udGVudCBhbmQgYXBwbHkgZm9ybWF0LiBFLmcuIGZvciAqKl9IZWxsb18qKiBzdHJpbmcgYWZ0ZXIgYXBwbHlpbmcgYm9sZFxuICAvLyBmb3JtYXQgKCoqKSBpdCB3aWxsIHJldXNlIHRoZSBzYW1lIHRleHQgbm9kZSB0byBhcHBseSBpdGFsaWMgKF8pXG5cbiAgaWYgKG1hdGNoWzBdID09PSB0ZXh0Q29udGVudCkge1xuICAgIGN1cnJlbnROb2RlID0gdGV4dE5vZGU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IG1hdGNoLmluZGV4IHx8IDA7XG4gICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuXG4gICAgaWYgKHN0YXJ0SW5kZXggPT09IDApIHtcbiAgICAgIFtjdXJyZW50Tm9kZSwgcmVtYWluZGVyTm9kZV0gPSB0ZXh0Tm9kZS5zcGxpdFRleHQoZW5kSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBbbGVhZGluZ05vZGUsIGN1cnJlbnROb2RlLCByZW1haW5kZXJOb2RlXSA9IHRleHROb2RlLnNwbGl0VGV4dChzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgY3VycmVudE5vZGUuc2V0VGV4dENvbnRlbnQobWF0Y2hbMl0pO1xuICBjb25zdCB0cmFuc2Zvcm1lciA9IHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleC50cmFuc2Zvcm1lcnNCeVRhZ1ttYXRjaFsxXV07XG5cbiAgaWYgKHRyYW5zZm9ybWVyKSB7XG4gICAgZm9yIChjb25zdCBmb3JtYXQgb2YgdHJhbnNmb3JtZXIuZm9ybWF0KSB7XG4gICAgICBpZiAoIWN1cnJlbnROb2RlLmhhc0Zvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIGN1cnJlbnROb2RlLnRvZ2dsZUZvcm1hdChmb3JtYXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZWN1cnNpdmVseSBydW4gb3ZlciBpbm5lciB0ZXh0IGlmIGl0J3Mgbm90IGlubGluZSBjb2RlXG5cblxuICBpZiAoIWN1cnJlbnROb2RlLmhhc0Zvcm1hdCgnY29kZScpKSB7XG4gICAgaW1wb3J0VGV4dEZvcm1hdFRyYW5zZm9ybWVycyhjdXJyZW50Tm9kZSwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuICB9IC8vIFJ1biBvdmVyIGxlYWRpbmcvcmVtYWluaW5nIHRleHQgaWYgYW55XG5cblxuICBpZiAobGVhZGluZ05vZGUpIHtcbiAgICBpbXBvcnRUZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKGxlYWRpbmdOb2RlLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7XG4gIH1cblxuICBpZiAocmVtYWluZGVyTm9kZSkge1xuICAgIGltcG9ydFRleHRGb3JtYXRUcmFuc2Zvcm1lcnMocmVtYWluZGVyTm9kZSwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGltcG9ydFRleHRNYXRjaFRyYW5zZm9ybWVycyh0ZXh0Tm9kZV8sIHRleHRNYXRjaFRyYW5zZm9ybWVycykge1xuICBsZXQgdGV4dE5vZGUgPSB0ZXh0Tm9kZV87XG5cbiAgbWFpbkxvb3A6IHdoaWxlICh0ZXh0Tm9kZSkge1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IHRleHROb2RlLmdldFRleHRDb250ZW50KCkubWF0Y2godHJhbnNmb3JtZXIuaW1wb3J0UmVnRXhwKTtcblxuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IG1hdGNoLmluZGV4IHx8IDA7XG4gICAgICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICBsZXQgcmVwbGFjZU5vZGUsIGxlZnRUZXh0Tm9kZSwgcmlnaHRUZXh0Tm9kZTtcblxuICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IDApIHtcbiAgICAgICAgW3JlcGxhY2VOb2RlLCB0ZXh0Tm9kZV0gPSB0ZXh0Tm9kZS5zcGxpdFRleHQoZW5kSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgW2xlZnRUZXh0Tm9kZSwgcmVwbGFjZU5vZGUsIHJpZ2h0VGV4dE5vZGVdID0gdGV4dE5vZGUuc3BsaXRUZXh0KHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxlZnRUZXh0Tm9kZSkge1xuICAgICAgICBpbXBvcnRUZXh0TWF0Y2hUcmFuc2Zvcm1lcnMobGVmdFRleHROb2RlLCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmlnaHRUZXh0Tm9kZSkge1xuICAgICAgICB0ZXh0Tm9kZSA9IHJpZ2h0VGV4dE5vZGU7XG4gICAgICB9XG5cbiAgICAgIHRyYW5zZm9ybWVyLnJlcGxhY2UocmVwbGFjZU5vZGUsIG1hdGNoKTtcbiAgICAgIGNvbnRpbnVlIG1haW5Mb29wO1xuICAgIH1cblxuICAgIGJyZWFrO1xuICB9XG59IC8vIEZpbmRzIGZpcnN0IFwiPHRhZz5jb250ZW50PHRhZz5cIiBtYXRjaCB0aGF0IGlzIG5vdCBuZXN0ZWQgaW50byBhbm90aGVyIHRhZ1xuXG5cbmZ1bmN0aW9uIGZpbmRPdXRlcm1vc3RNYXRjaCh0ZXh0Q29udGVudCwgdGV4dFRyYW5zZm9ybWVyc0luZGV4KSB7XG4gIGNvbnN0IG9wZW5UYWdzTWF0Y2ggPSB0ZXh0Q29udGVudC5tYXRjaCh0ZXh0VHJhbnNmb3JtZXJzSW5kZXgub3BlblRhZ3NSZWdFeHApO1xuXG4gIGlmIChvcGVuVGFnc01hdGNoID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZvciAoY29uc3QgbWF0Y2ggb2Ygb3BlblRhZ3NNYXRjaCkge1xuICAgIC8vIE9wZW4gdGFncyByZWcgZXhwIG1pZ2h0IGNhcHR1cmUgbGVhZGluZyBzcGFjZSBzbyByZW1vdmluZyBpdFxuICAgIC8vIGJlZm9yZSB1c2luZyBtYXRjaCB0byBmaW5kIHRyYW5zZm9ybWVyXG4gICAgY29uc3QgdGFnID0gbWF0Y2gucmVwbGFjZSgvXlxccy8sICcnKTtcbiAgICBjb25zdCBmdWxsTWF0Y2hSZWdFeHAgPSB0ZXh0VHJhbnNmb3JtZXJzSW5kZXguZnVsbE1hdGNoUmVnRXhwQnlUYWdbdGFnXTtcblxuICAgIGlmIChmdWxsTWF0Y2hSZWdFeHAgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgZnVsbE1hdGNoID0gdGV4dENvbnRlbnQubWF0Y2goZnVsbE1hdGNoUmVnRXhwKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IHRleHRUcmFuc2Zvcm1lcnNJbmRleC50cmFuc2Zvcm1lcnNCeVRhZ1t0YWddO1xuXG4gICAgaWYgKGZ1bGxNYXRjaCAhPSBudWxsICYmIHRyYW5zZm9ybWVyICE9IG51bGwpIHtcbiAgICAgIGlmICh0cmFuc2Zvcm1lci5pbnRyYXdvcmQgIT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmdWxsTWF0Y2g7XG4gICAgICB9IC8vIEZvciBub24taW50cmF3b3JkIHRyYW5zZm9ybWVycyBjaGVja2luZyBpZiBpdCdzIHdpdGhpbiBhIHdvcmRcbiAgICAgIC8vIG9yIHN1cnJvdW5kZWQgd2l0aCBzcGFjZS9wdW5jdHVhdGlvbi9uZXdsaW5lXG5cblxuICAgICAgY29uc3Qge1xuICAgICAgICBpbmRleCA9IDBcbiAgICAgIH0gPSBmdWxsTWF0Y2g7XG4gICAgICBjb25zdCBiZWZvcmVDaGFyID0gdGV4dENvbnRlbnRbaW5kZXggLSAxXTtcbiAgICAgIGNvbnN0IGFmdGVyQ2hhciA9IHRleHRDb250ZW50W2luZGV4ICsgZnVsbE1hdGNoWzBdLmxlbmd0aF07XG5cbiAgICAgIGlmICgoIWJlZm9yZUNoYXIgfHwgUFVOQ1RVQVRJT05fT1JfU1BBQ0UudGVzdChiZWZvcmVDaGFyKSkgJiYgKCFhZnRlckNoYXIgfHwgUFVOQ1RVQVRJT05fT1JfU1BBQ0UudGVzdChhZnRlckNoYXIpKSkge1xuICAgICAgICByZXR1cm4gZnVsbE1hdGNoO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgodGV4dFRyYW5zZm9ybWVycykge1xuICBjb25zdCB0cmFuc2Zvcm1lcnNCeVRhZyA9IHt9O1xuICBjb25zdCBmdWxsTWF0Y2hSZWdFeHBCeVRhZyA9IHt9O1xuICBjb25zdCBvcGVuVGFnc1JlZ0V4cCA9IFtdO1xuICBjb25zdCBlc2NhcGVSZWdFeHAgPSBgKD88IVtcXFxcXFxcXF0pYDtcblxuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRleHRUcmFuc2Zvcm1lcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YWdcbiAgICB9ID0gdHJhbnNmb3JtZXI7XG4gICAgdHJhbnNmb3JtZXJzQnlUYWdbdGFnXSA9IHRyYW5zZm9ybWVyO1xuICAgIGNvbnN0IHRhZ1JlZ0V4cCA9IHRhZy5yZXBsYWNlKC8oXFwqfFxcXnxcXCspL2csICdcXFxcJDEnKTtcbiAgICBvcGVuVGFnc1JlZ0V4cC5wdXNoKHRhZ1JlZ0V4cCk7XG5cbiAgICBpZiAoSVNfU0FGQVJJIHx8IElTX0lPUyB8fCBJU19BUFBMRV9XRUJLSVQpIHtcbiAgICAgIGZ1bGxNYXRjaFJlZ0V4cEJ5VGFnW3RhZ10gPSBuZXcgUmVnRXhwKGAoJHt0YWdSZWdFeHB9KSg/IVske3RhZ1JlZ0V4cH1cXFxcc10pKC4qP1teJHt0YWdSZWdFeHB9XFxcXHNdKSR7dGFnUmVnRXhwfSg/ISR7dGFnUmVnRXhwfSlgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVsbE1hdGNoUmVnRXhwQnlUYWdbdGFnXSA9IG5ldyBSZWdFeHAoYCg/PCFbXFxcXFxcXFwke3RhZ1JlZ0V4cH1dKSgke3RhZ1JlZ0V4cH0pKChcXFxcXFxcXCR7dGFnUmVnRXhwfSk/Lio/W14ke3RhZ1JlZ0V4cH1cXFxcc10oXFxcXFxcXFwke3RhZ1JlZ0V4cH0pPykoKD88IVxcXFxcXFxcKXwoPzw9XFxcXFxcXFxcXFxcXFxcXCkpKCR7dGFnUmVnRXhwfSkoPyFbXFxcXFxcXFwke3RhZ1JlZ0V4cH1dKWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gUmVnIGV4cCB0byBmaW5kIG9wZW4gdGFnICsgY29udGVudCArIGNsb3NlIHRhZ1xuICAgIGZ1bGxNYXRjaFJlZ0V4cEJ5VGFnLFxuICAgIC8vIFJlZyBleHAgdG8gZmluZCBvcGVuaW5nIHRhZ3NcbiAgICBvcGVuVGFnc1JlZ0V4cDogbmV3IFJlZ0V4cCgoSVNfU0FGQVJJIHx8IElTX0lPUyB8fCBJU19BUFBMRV9XRUJLSVQgPyAnJyA6IGAke2VzY2FwZVJlZ0V4cH1gKSArICcoJyArIG9wZW5UYWdzUmVnRXhwLmpvaW4oJ3wnKSArICcpJywgJ2cnKSxcbiAgICB0cmFuc2Zvcm1lcnNCeVRhZ1xuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHJ1bkVsZW1lbnRUcmFuc2Zvcm1lcnMocGFyZW50Tm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBlbGVtZW50VHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IGdyYW5kUGFyZW50Tm9kZSA9IHBhcmVudE5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgaWYgKCFsZXhpY2FsLiRpc1Jvb3RPclNoYWRvd1Jvb3QoZ3JhbmRQYXJlbnROb2RlKSB8fCBwYXJlbnROb2RlLmdldEZpcnN0Q2hpbGQoKSAhPT0gYW5jaG9yTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHRleHRDb250ZW50ID0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpOyAvLyBDaGVja2luZyBmb3IgYW5jaG9yT2Zmc2V0IHBvc2l0aW9uIHRvIHByZXZlbnQgYW55IGNoZWNrcyBmb3IgY2FzZXMgd2hlbiBjYXJldCBpcyB0b28gZmFyXG4gIC8vIGZyb20gYSBsaW5lIHN0YXJ0IHRvIGJlIGEgcGFydCBvZiBibG9jay1sZXZlbCBtYXJrZG93biB0cmlnZ2VyLlxuICAvL1xuICAvLyBUT0RPOlxuICAvLyBDYW4gaGF2ZSBhIHF1aWNrIGNoZWNrIGlmIGNhcmV0IGlzIGNsb3NlIGVub3VnaCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmcgKGUuZy4gb2Zmc2V0IGxlc3MgdGhhbiAxMC0yMClcbiAgLy8gc2luY2Ugb3RoZXJ3aXNlIGl0IHdvbid0IGJlIGEgbWFya2Rvd24gc2hvcnRjdXQsIGJ1dCB0YWJsZXMgYXJlIGV4Y2VwdGlvblxuXG4gIGlmICh0ZXh0Q29udGVudFthbmNob3JPZmZzZXQgLSAxXSAhPT0gJyAnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCB7XG4gICAgcmVnRXhwLFxuICAgIHJlcGxhY2VcbiAgfSBvZiBlbGVtZW50VHJhbnNmb3JtZXJzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0ZXh0Q29udGVudC5tYXRjaChyZWdFeHApO1xuXG4gICAgaWYgKG1hdGNoICYmIG1hdGNoWzBdLmxlbmd0aCA9PT0gYW5jaG9yT2Zmc2V0KSB7XG4gICAgICBjb25zdCBuZXh0U2libGluZ3MgPSBhbmNob3JOb2RlLmdldE5leHRTaWJsaW5ncygpO1xuICAgICAgY29uc3QgW2xlYWRpbmdOb2RlLCByZW1haW5kZXJOb2RlXSA9IGFuY2hvck5vZGUuc3BsaXRUZXh0KGFuY2hvck9mZnNldCk7XG4gICAgICBsZWFkaW5nTm9kZS5yZW1vdmUoKTtcbiAgICAgIGNvbnN0IHNpYmxpbmdzID0gcmVtYWluZGVyTm9kZSA/IFtyZW1haW5kZXJOb2RlLCAuLi5uZXh0U2libGluZ3NdIDogbmV4dFNpYmxpbmdzO1xuICAgICAgcmVwbGFjZShwYXJlbnROb2RlLCBzaWJsaW5ncywgbWF0Y2gsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcnVuVGV4dE1hdGNoVHJhbnNmb3JtZXJzKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgdHJhbnNmb3JtZXJzQnlUcmlnZ2VyKSB7XG4gIGxldCB0ZXh0Q29udGVudCA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgY29uc3QgbGFzdENoYXIgPSB0ZXh0Q29udGVudFthbmNob3JPZmZzZXQgLSAxXTtcbiAgY29uc3QgdHJhbnNmb3JtZXJzID0gdHJhbnNmb3JtZXJzQnlUcmlnZ2VyW2xhc3RDaGFyXTtcblxuICBpZiAodHJhbnNmb3JtZXJzID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSWYgdHlwaW5nIGluIHRoZSBtaWRkbGUgb2YgY29udGVudCwgcmVtb3ZlIHRoZSB0YWlsIHRvIGRvXG4gIC8vIHJlZyBleHAgbWF0Y2ggdXAgdG8gYSBzdHJpbmcgZW5kIChjYXJldCBwb3NpdGlvbilcblxuXG4gIGlmIChhbmNob3JPZmZzZXQgPCB0ZXh0Q29udGVudC5sZW5ndGgpIHtcbiAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDAsIGFuY2hvck9mZnNldCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IG1hdGNoID0gdGV4dENvbnRlbnQubWF0Y2godHJhbnNmb3JtZXIucmVnRXhwKTtcblxuICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IG1hdGNoLmluZGV4IHx8IDA7XG4gICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIGxldCByZXBsYWNlTm9kZTtcblxuICAgIGlmIChzdGFydEluZGV4ID09PSAwKSB7XG4gICAgICBbcmVwbGFjZU5vZGVdID0gYW5jaG9yTm9kZS5zcGxpdFRleHQoZW5kSW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBbLCByZXBsYWNlTm9kZV0gPSBhbmNob3JOb2RlLnNwbGl0VGV4dChzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgfVxuXG4gICAgcmVwbGFjZU5vZGUuc2VsZWN0TmV4dCgwLCAwKTtcbiAgICB0cmFuc2Zvcm1lci5yZXBsYWNlKHJlcGxhY2VOb2RlLCBtYXRjaCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJ1blRleHRGb3JtYXRUcmFuc2Zvcm1lcnMoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IHRleHRDb250ZW50ID0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICBjb25zdCBjbG9zZVRhZ0VuZEluZGV4ID0gYW5jaG9yT2Zmc2V0IC0gMTtcbiAgY29uc3QgY2xvc2VDaGFyID0gdGV4dENvbnRlbnRbY2xvc2VUYWdFbmRJbmRleF07IC8vIFF1aWNrIGNoZWNrIGlmIHdlJ3JlIHBvc3NpYmx5IGF0IHRoZSBlbmQgb2YgaW5saW5lIG1hcmtkb3duIHN0eWxlXG5cbiAgY29uc3QgbWF0Y2hlcnMgPSB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzW2Nsb3NlQ2hhcl07XG5cbiAgaWYgKCFtYXRjaGVycykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgbWF0Y2hlciBvZiBtYXRjaGVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIHRhZ1xuICAgIH0gPSBtYXRjaGVyO1xuICAgIGNvbnN0IHRhZ0xlbmd0aCA9IHRhZy5sZW5ndGg7XG4gICAgY29uc3QgY2xvc2VUYWdTdGFydEluZGV4ID0gY2xvc2VUYWdFbmRJbmRleCAtIHRhZ0xlbmd0aCArIDE7IC8vIElmIHRhZyBpcyBub3Qgc2luZ2xlIGNoYXIgY2hlY2sgaWYgcmVzdCBvZiBpdCBtYXRjaGVzIHdpdGggdGV4dCBjb250ZW50XG5cbiAgICBpZiAodGFnTGVuZ3RoID4gMSkge1xuICAgICAgaWYgKCFpc0VxdWFsU3ViU3RyaW5nKHRleHRDb250ZW50LCBjbG9zZVRhZ1N0YXJ0SW5kZXgsIHRhZywgMCwgdGFnTGVuZ3RoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IC8vIFNwYWNlIGJlZm9yZSBjbG9zaW5nIHRhZyBjYW5jZWxzIGlubGluZSBtYXJrZG93blxuXG5cbiAgICBpZiAodGV4dENvbnRlbnRbY2xvc2VUYWdTdGFydEluZGV4IC0gMV0gPT09ICcgJykge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBTb21lIHRhZ3MgY2FuIG5vdCBiZSB1c2VkIHdpdGhpbiB3b3JkcywgaGVuY2Ugc2hvdWxkIGhhdmUgbmV3bGluZS9zcGFjZS9wdW5jdHVhdGlvbiBhZnRlciBpdFxuXG5cbiAgICBjb25zdCBhZnRlckNsb3NlVGFnQ2hhciA9IHRleHRDb250ZW50W2Nsb3NlVGFnRW5kSW5kZXggKyAxXTtcblxuICAgIGlmIChtYXRjaGVyLmludHJhd29yZCA9PT0gZmFsc2UgJiYgYWZ0ZXJDbG9zZVRhZ0NoYXIgJiYgIVBVTkNUVUFUSU9OX09SX1NQQUNFLnRlc3QoYWZ0ZXJDbG9zZVRhZ0NoYXIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBjbG9zZU5vZGUgPSBhbmNob3JOb2RlO1xuICAgIGxldCBvcGVuTm9kZSA9IGNsb3NlTm9kZTtcbiAgICBsZXQgb3BlblRhZ1N0YXJ0SW5kZXggPSBnZXRPcGVuVGFnU3RhcnRJbmRleCh0ZXh0Q29udGVudCwgY2xvc2VUYWdTdGFydEluZGV4LCB0YWcpOyAvLyBHbyB0aHJvdWdoIHRleHQgbm9kZSBzaWJsaW5ncyBhbmQgc2VhcmNoIGZvciBvcGVuaW5nIHRhZ1xuICAgIC8vIGlmIGhhdmVuJ3QgZm91bmQgaXQgd2l0aGluIHRoZSBzYW1lIHRleHQgbm9kZSBhcyBjbG9zaW5nIHRhZ1xuXG4gICAgbGV0IHNpYmxpbmcgPSBvcGVuTm9kZTtcblxuICAgIHdoaWxlIChvcGVuVGFnU3RhcnRJbmRleCA8IDAgJiYgKHNpYmxpbmcgPSBzaWJsaW5nLmdldFByZXZpb3VzU2libGluZygpKSkge1xuICAgICAgaWYgKGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShzaWJsaW5nKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoc2libGluZykpIHtcbiAgICAgICAgY29uc3Qgc2libGluZ1RleHRDb250ZW50ID0gc2libGluZy5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICBvcGVuTm9kZSA9IHNpYmxpbmc7XG4gICAgICAgIG9wZW5UYWdTdGFydEluZGV4ID0gZ2V0T3BlblRhZ1N0YXJ0SW5kZXgoc2libGluZ1RleHRDb250ZW50LCBzaWJsaW5nVGV4dENvbnRlbnQubGVuZ3RoLCB0YWcpO1xuICAgICAgfVxuICAgIH0gLy8gT3BlbmluZyB0YWcgaXMgbm90IGZvdW5kXG5cblxuICAgIGlmIChvcGVuVGFnU3RhcnRJbmRleCA8IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gTm8gY29udGVudCBiZXR3ZWVuIG9wZW5pbmcgYW5kIGNsb3NpbmcgdGFnXG5cblxuICAgIGlmIChvcGVuTm9kZSA9PT0gY2xvc2VOb2RlICYmIG9wZW5UYWdTdGFydEluZGV4ICsgdGFnTGVuZ3RoID09PSBjbG9zZVRhZ1N0YXJ0SW5kZXgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gQ2hlY2tpbmcgbG9uZ2VyIHRhZ3MgZm9yIHJlcGVhdGluZyBjaGFycyAoZS5nLiAqKiogdnMgKiopXG5cblxuICAgIGNvbnN0IHByZXZPcGVuTm9kZVRleHQgPSBvcGVuTm9kZS5nZXRUZXh0Q29udGVudCgpO1xuXG4gICAgaWYgKG9wZW5UYWdTdGFydEluZGV4ID4gMCAmJiBwcmV2T3Blbk5vZGVUZXh0W29wZW5UYWdTdGFydEluZGV4IC0gMV0gPT09IGNsb3NlQ2hhcikge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBTb21lIHRhZ3MgY2FuIG5vdCBiZSB1c2VkIHdpdGhpbiB3b3JkcywgaGVuY2Ugc2hvdWxkIGhhdmUgbmV3bGluZS9zcGFjZS9wdW5jdHVhdGlvbiBiZWZvcmUgaXRcblxuXG4gICAgY29uc3QgYmVmb3JlT3BlblRhZ0NoYXIgPSBwcmV2T3Blbk5vZGVUZXh0W29wZW5UYWdTdGFydEluZGV4IC0gMV07XG5cbiAgICBpZiAobWF0Y2hlci5pbnRyYXdvcmQgPT09IGZhbHNlICYmIGJlZm9yZU9wZW5UYWdDaGFyICYmICFQVU5DVFVBVElPTl9PUl9TUEFDRS50ZXN0KGJlZm9yZU9wZW5UYWdDaGFyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBDbGVhbiB0ZXh0IGZyb20gb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIChzdGFydGluZyBmcm9tIGNsb3NpbmcgdGFnXG4gICAgLy8gdG8gcHJldmVudCBhbnkgb2Zmc2V0IHNoaWZ0cyBpZiB3ZSBzdGFydCBmcm9tIG9wZW5pbmcgb25lKVxuXG5cbiAgICBjb25zdCBwcmV2Q2xvc2VOb2RlVGV4dCA9IGNsb3NlTm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IGNsb3NlTm9kZVRleHQgPSBwcmV2Q2xvc2VOb2RlVGV4dC5zbGljZSgwLCBjbG9zZVRhZ1N0YXJ0SW5kZXgpICsgcHJldkNsb3NlTm9kZVRleHQuc2xpY2UoY2xvc2VUYWdFbmRJbmRleCArIDEpO1xuICAgIGNsb3NlTm9kZS5zZXRUZXh0Q29udGVudChjbG9zZU5vZGVUZXh0KTtcbiAgICBjb25zdCBvcGVuTm9kZVRleHQgPSBvcGVuTm9kZSA9PT0gY2xvc2VOb2RlID8gY2xvc2VOb2RlVGV4dCA6IHByZXZPcGVuTm9kZVRleHQ7XG4gICAgb3Blbk5vZGUuc2V0VGV4dENvbnRlbnQob3Blbk5vZGVUZXh0LnNsaWNlKDAsIG9wZW5UYWdTdGFydEluZGV4KSArIG9wZW5Ob2RlVGV4dC5zbGljZShvcGVuVGFnU3RhcnRJbmRleCArIHRhZ0xlbmd0aCkpO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IG5leHRTZWxlY3Rpb24gPSBsZXhpY2FsLiRjcmVhdGVSYW5nZVNlbGVjdGlvbigpO1xuICAgIGxleGljYWwuJHNldFNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKTsgLy8gQWRqdXN0IG9mZnNldCBiYXNlZCBvbiBkZWxldGVkIGNoYXJzXG5cbiAgICBjb25zdCBuZXdPZmZzZXQgPSBjbG9zZVRhZ0VuZEluZGV4IC0gdGFnTGVuZ3RoICogKG9wZW5Ob2RlID09PSBjbG9zZU5vZGUgPyAyIDogMSkgKyAxO1xuICAgIG5leHRTZWxlY3Rpb24uYW5jaG9yLnNldChvcGVuTm9kZS5fX2tleSwgb3BlblRhZ1N0YXJ0SW5kZXgsICd0ZXh0Jyk7XG4gICAgbmV4dFNlbGVjdGlvbi5mb2N1cy5zZXQoY2xvc2VOb2RlLl9fa2V5LCBuZXdPZmZzZXQsICd0ZXh0Jyk7IC8vIEFwcGx5IGZvcm1hdHRpbmcgdG8gc2VsZWN0ZWQgdGV4dFxuXG4gICAgZm9yIChjb25zdCBmb3JtYXQgb2YgbWF0Y2hlci5mb3JtYXQpIHtcbiAgICAgIGlmICghbmV4dFNlbGVjdGlvbi5oYXNGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICBuZXh0U2VsZWN0aW9uLmZvcm1hdFRleHQoZm9ybWF0KTtcbiAgICAgIH1cbiAgICB9IC8vIENvbGxhcHNlIHNlbGVjdGlvbiB1cCB0byB0aGUgZm9jdXMgcG9pbnRcblxuXG4gICAgbmV4dFNlbGVjdGlvbi5hbmNob3Iuc2V0KG5leHRTZWxlY3Rpb24uZm9jdXMua2V5LCBuZXh0U2VsZWN0aW9uLmZvY3VzLm9mZnNldCwgbmV4dFNlbGVjdGlvbi5mb2N1cy50eXBlKTsgLy8gUmVtb3ZlIGZvcm1hdHRpbmcgZnJvbSBjb2xsYXBzZWQgc2VsZWN0aW9uXG5cbiAgICBmb3IgKGNvbnN0IGZvcm1hdCBvZiBtYXRjaGVyLmZvcm1hdCkge1xuICAgICAgaWYgKG5leHRTZWxlY3Rpb24uaGFzRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgbmV4dFNlbGVjdGlvbi50b2dnbGVGb3JtYXQoZm9ybWF0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBuZXh0U2VsZWN0aW9uLmZvcm1hdCA9IHNlbGVjdGlvbi5mb3JtYXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldE9wZW5UYWdTdGFydEluZGV4KHN0cmluZywgbWF4SW5kZXgsIHRhZykge1xuICBjb25zdCB0YWdMZW5ndGggPSB0YWcubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSBtYXhJbmRleDsgaSA+PSB0YWdMZW5ndGg7IGktLSkge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBpIC0gdGFnTGVuZ3RoO1xuXG4gICAgaWYgKGlzRXF1YWxTdWJTdHJpbmcoc3RyaW5nLCBzdGFydEluZGV4LCB0YWcsIDAsIHRhZ0xlbmd0aCkgJiYgLy8gU3BhY2UgYWZ0ZXIgb3BlbmluZyB0YWcgY2FuY2VscyB0cmFuc2Zvcm1hdGlvblxuICAgIHN0cmluZ1tzdGFydEluZGV4ICsgdGFnTGVuZ3RoXSAhPT0gJyAnKSB7XG4gICAgICByZXR1cm4gc3RhcnRJbmRleDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIGlzRXF1YWxTdWJTdHJpbmcoc3RyaW5nQSwgYVN0YXJ0LCBzdHJpbmdCLCBiU3RhcnQsIGxlbmd0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0cmluZ0FbYVN0YXJ0ICsgaV0gIT09IHN0cmluZ0JbYlN0YXJ0ICsgaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJNYXJrZG93blNob3J0Y3V0cyhlZGl0b3IsIHRyYW5zZm9ybWVycyA9IFRSQU5TRk9STUVSUykge1xuICBjb25zdCBieVR5cGUgPSB0cmFuc2Zvcm1lcnNCeVR5cGUodHJhbnNmb3JtZXJzKTtcbiAgY29uc3QgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4ID0gaW5kZXhCeShieVR5cGUudGV4dEZvcm1hdCwgKHtcbiAgICB0YWdcbiAgfSkgPT4gdGFnW3RhZy5sZW5ndGggLSAxXSk7XG4gIGNvbnN0IHRleHRNYXRjaFRyYW5zZm9ybWVyc0luZGV4ID0gaW5kZXhCeShieVR5cGUudGV4dE1hdGNoLCAoe1xuICAgIHRyaWdnZXJcbiAgfSkgPT4gdHJpZ2dlcik7XG5cbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpIHtcbiAgICBjb25zdCB0eXBlID0gdHJhbnNmb3JtZXIudHlwZTtcblxuICAgIGlmICh0eXBlID09PSAnZWxlbWVudCcgfHwgdHlwZSA9PT0gJ3RleHQtbWF0Y2gnKSB7XG4gICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSB0cmFuc2Zvcm1lci5kZXBlbmRlbmNpZXM7XG5cbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgaWYgKCFlZGl0b3IuaGFzTm9kZShub2RlKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBNYXJrZG93blNob3J0Y3V0czogbWlzc2luZyBkZXBlbmRlbmN5ICR7bm9kZS5nZXRUeXBlKCl9IGZvciB0cmFuc2Zvcm1lci4gRW5zdXJlIG5vZGUgZGVwZW5kZW5jeSBpcyBpbmNsdWRlZCBpbiBlZGl0b3IgaW5pdGlhbCBjb25maWcuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdHJhbnNmb3JtID0gKHBhcmVudE5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkgPT4ge1xuICAgIGlmIChydW5FbGVtZW50VHJhbnNmb3JtZXJzKHBhcmVudE5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgYnlUeXBlLmVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHJ1blRleHRNYXRjaFRyYW5zZm9ybWVycyhhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIHRleHRNYXRjaFRyYW5zZm9ybWVyc0luZGV4KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJ1blRleHRGb3JtYXRUcmFuc2Zvcm1lcnMoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgpO1xuICB9O1xuXG4gIHJldHVybiBlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoe1xuICAgIHRhZ3MsXG4gICAgZGlydHlMZWF2ZXMsXG4gICAgZWRpdG9yU3RhdGUsXG4gICAgcHJldkVkaXRvclN0YXRlXG4gIH0pID0+IHtcbiAgICAvLyBJZ25vcmUgdXBkYXRlcyBmcm9tIHVuZG8vcmVkbyAoYXMgY2hhbmdlcyBhbHJlYWR5IGNhbGN1bGF0ZWQpXG4gICAgaWYgKHRhZ3MuaGFzKCdoaXN0b3JpYycpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiBlZGl0b3IgaXMgc3RpbGwgY29tcG9zaW5nIChpLmUuIGJhY2t0aWNrcykgd2UgbXVzdCB3YWl0IGJlZm9yZSB0aGUgdXNlciBjb25maXJtcyB0aGUga2V5XG5cblxuICAgIGlmIChlZGl0b3IuaXNDb21wb3NpbmcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvclN0YXRlLnJlYWQobGV4aWNhbC4kZ2V0U2VsZWN0aW9uKTtcbiAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gcHJldkVkaXRvclN0YXRlLnJlYWQobGV4aWNhbC4kZ2V0U2VsZWN0aW9uKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSB8fCAhbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuY2hvcktleSA9IHNlbGVjdGlvbi5hbmNob3Iua2V5O1xuICAgIGNvbnN0IGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0O1xuXG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChhbmNob3JLZXkpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1RleHROb2RlKGFuY2hvck5vZGUpIHx8ICFkaXJ0eUxlYXZlcy5oYXMoYW5jaG9yS2V5KSB8fCBhbmNob3JPZmZzZXQgIT09IDEgJiYgYW5jaG9yT2Zmc2V0ID4gcHJldlNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ICsgMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgLy8gTWFya2Rvd24gaXMgbm90IGF2YWlsYWJsZSBpbnNpZGUgY29kZVxuICAgICAgaWYgKGFuY2hvck5vZGUuaGFzRm9ybWF0KCdjb2RlJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gYW5jaG9yTm9kZS5nZXRQYXJlbnQoKTtcblxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IG51bGwgfHwgY29kZS4kaXNDb2RlTm9kZShwYXJlbnROb2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRyYW5zZm9ybShwYXJlbnROb2RlLCBhbmNob3JOb2RlLCBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IGNyZWF0ZUJsb2NrTm9kZSA9IGNyZWF0ZU5vZGUgPT4ge1xuICByZXR1cm4gKHBhcmVudE5vZGUsIGNoaWxkcmVuLCBtYXRjaCkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBjcmVhdGVOb2RlKG1hdGNoKTtcbiAgICBub2RlLmFwcGVuZCguLi5jaGlsZHJlbik7XG4gICAgcGFyZW50Tm9kZS5yZXBsYWNlKG5vZGUpO1xuICAgIG5vZGUuc2VsZWN0KDAsIDApO1xuICB9O1xufTsgLy8gQW1vdW50IG9mIHNwYWNlcyB0aGF0IGRlZmluZSBpbmRlbnRhdGlvbiBsZXZlbFxuLy8gVE9ETzogc2hvdWxkIGJlIGFuIG9wdGlvblxuXG5cbmNvbnN0IExJU1RfSU5ERU5UX1NJWkUgPSA0O1xuXG5jb25zdCBsaXN0UmVwbGFjZSA9IGxpc3RUeXBlID0+IHtcbiAgcmV0dXJuIChwYXJlbnROb2RlLCBjaGlsZHJlbiwgbWF0Y2gpID0+IHtcbiAgICBjb25zdCBwcmV2aW91c05vZGUgPSBwYXJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGNvbnN0IG5leHROb2RlID0gcGFyZW50Tm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIGNvbnN0IGxpc3RJdGVtID0gbGlzdC4kY3JlYXRlTGlzdEl0ZW1Ob2RlKGxpc3RUeXBlID09PSAnY2hlY2snID8gbWF0Y2hbM10gPT09ICd4JyA6IHVuZGVmaW5lZCk7XG5cbiAgICBpZiAobGlzdC4kaXNMaXN0Tm9kZShuZXh0Tm9kZSkgJiYgbmV4dE5vZGUuZ2V0TGlzdFR5cGUoKSA9PT0gbGlzdFR5cGUpIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBuZXh0Tm9kZS5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKGxpc3RJdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNob3VsZCBuZXZlciBoYXBwZW4sIGJ1dCBsZXQncyBoYW5kbGUgZ3JhY2VmdWxseSwganVzdCBpbiBjYXNlLlxuICAgICAgICBuZXh0Tm9kZS5hcHBlbmQobGlzdEl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnROb2RlLnJlbW92ZSgpO1xuICAgIH0gZWxzZSBpZiAobGlzdC4kaXNMaXN0Tm9kZShwcmV2aW91c05vZGUpICYmIHByZXZpb3VzTm9kZS5nZXRMaXN0VHlwZSgpID09PSBsaXN0VHlwZSkge1xuICAgICAgcHJldmlvdXNOb2RlLmFwcGVuZChsaXN0SXRlbSk7XG4gICAgICBwYXJlbnROb2RlLnJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsaXN0JDEgPSBsaXN0LiRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSwgbGlzdFR5cGUgPT09ICdudW1iZXInID8gTnVtYmVyKG1hdGNoWzJdKSA6IHVuZGVmaW5lZCk7XG4gICAgICBsaXN0JDEuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICAgIHBhcmVudE5vZGUucmVwbGFjZShsaXN0JDEpO1xuICAgIH1cblxuICAgIGxpc3RJdGVtLmFwcGVuZCguLi5jaGlsZHJlbik7XG4gICAgbGlzdEl0ZW0uc2VsZWN0KDAsIDApO1xuICAgIGNvbnN0IGluZGVudCA9IE1hdGguZmxvb3IobWF0Y2hbMV0ubGVuZ3RoIC8gTElTVF9JTkRFTlRfU0laRSk7XG5cbiAgICBpZiAoaW5kZW50KSB7XG4gICAgICBsaXN0SXRlbS5zZXRJbmRlbnQoaW5kZW50KTtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBsaXN0RXhwb3J0ID0gKGxpc3ROb2RlLCBleHBvcnRDaGlsZHJlbiwgZGVwdGgpID0+IHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGNvbnN0IGNoaWxkcmVuID0gbGlzdE5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgbGV0IGluZGV4ID0gMDtcblxuICBmb3IgKGNvbnN0IGxpc3RJdGVtTm9kZSBvZiBjaGlsZHJlbikge1xuICAgIGlmIChsaXN0LiRpc0xpc3RJdGVtTm9kZShsaXN0SXRlbU5vZGUpKSB7XG4gICAgICBpZiAobGlzdEl0ZW1Ob2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBsaXN0SXRlbU5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgICAgIGlmIChsaXN0LiRpc0xpc3ROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2gobGlzdEV4cG9ydChmaXJzdENoaWxkLCBleHBvcnRDaGlsZHJlbiwgZGVwdGggKyAxKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZW50ID0gJyAnLnJlcGVhdChkZXB0aCAqIExJU1RfSU5ERU5UX1NJWkUpO1xuICAgICAgY29uc3QgbGlzdFR5cGUgPSBsaXN0Tm9kZS5nZXRMaXN0VHlwZSgpO1xuICAgICAgY29uc3QgcHJlZml4ID0gbGlzdFR5cGUgPT09ICdudW1iZXInID8gYCR7bGlzdE5vZGUuZ2V0U3RhcnQoKSArIGluZGV4fS4gYCA6IGxpc3RUeXBlID09PSAnY2hlY2snID8gYC0gWyR7bGlzdEl0ZW1Ob2RlLmdldENoZWNrZWQoKSA/ICd4JyA6ICcgJ31dIGAgOiAnLSAnO1xuICAgICAgb3V0cHV0LnB1c2goaW5kZW50ICsgcHJlZml4ICsgZXhwb3J0Q2hpbGRyZW4obGlzdEl0ZW1Ob2RlKSk7XG4gICAgICBpbmRleCsrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQuam9pbignXFxuJyk7XG59O1xuXG5jb25zdCBIRUFESU5HID0ge1xuICBkZXBlbmRlbmNpZXM6IFtyaWNoVGV4dC5IZWFkaW5nTm9kZV0sXG4gIGV4cG9ydDogKG5vZGUsIGV4cG9ydENoaWxkcmVuKSA9PiB7XG4gICAgaWYgKCFyaWNoVGV4dC4kaXNIZWFkaW5nTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbGV2ZWwgPSBOdW1iZXIobm9kZS5nZXRUYWcoKS5zbGljZSgxKSk7XG4gICAgcmV0dXJuICcjJy5yZXBlYXQobGV2ZWwpICsgJyAnICsgZXhwb3J0Q2hpbGRyZW4obm9kZSk7XG4gIH0sXG4gIHJlZ0V4cDogL14oI3sxLDZ9KVxccy8sXG4gIHJlcGxhY2U6IGNyZWF0ZUJsb2NrTm9kZShtYXRjaCA9PiB7XG4gICAgY29uc3QgdGFnID0gJ2gnICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgIHJldHVybiByaWNoVGV4dC4kY3JlYXRlSGVhZGluZ05vZGUodGFnKTtcbiAgfSksXG4gIHR5cGU6ICdlbGVtZW50J1xufTtcbmNvbnN0IFFVT1RFID0ge1xuICBkZXBlbmRlbmNpZXM6IFtyaWNoVGV4dC5RdW90ZU5vZGVdLFxuICBleHBvcnQ6IChub2RlLCBleHBvcnRDaGlsZHJlbikgPT4ge1xuICAgIGlmICghcmljaFRleHQuJGlzUXVvdGVOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBsaW5lcyA9IGV4cG9ydENoaWxkcmVuKG5vZGUpLnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcblxuICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgb3V0cHV0LnB1c2goJz4gJyArIGxpbmUpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbignXFxuJyk7XG4gIH0sXG4gIHJlZ0V4cDogL14+XFxzLyxcbiAgcmVwbGFjZTogKHBhcmVudE5vZGUsIGNoaWxkcmVuLCBfbWF0Y2gsIGlzSW1wb3J0KSA9PiB7XG4gICAgaWYgKGlzSW1wb3J0KSB7XG4gICAgICBjb25zdCBwcmV2aW91c05vZGUgPSBwYXJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuXG4gICAgICBpZiAocmljaFRleHQuJGlzUXVvdGVOb2RlKHByZXZpb3VzTm9kZSkpIHtcbiAgICAgICAgcHJldmlvdXNOb2RlLnNwbGljZShwcmV2aW91c05vZGUuZ2V0Q2hpbGRyZW5TaXplKCksIDAsIFtsZXhpY2FsLiRjcmVhdGVMaW5lQnJlYWtOb2RlKCksIC4uLmNoaWxkcmVuXSk7XG4gICAgICAgIHByZXZpb3VzTm9kZS5zZWxlY3QoMCwgMCk7XG4gICAgICAgIHBhcmVudE5vZGUucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gcmljaFRleHQuJGNyZWF0ZVF1b3RlTm9kZSgpO1xuICAgIG5vZGUuYXBwZW5kKC4uLmNoaWxkcmVuKTtcbiAgICBwYXJlbnROb2RlLnJlcGxhY2Uobm9kZSk7XG4gICAgbm9kZS5zZWxlY3QoMCwgMCk7XG4gIH0sXG4gIHR5cGU6ICdlbGVtZW50J1xufTtcbmNvbnN0IENPREUgPSB7XG4gIGRlcGVuZGVuY2llczogW2NvZGUuQ29kZU5vZGVdLFxuICBleHBvcnQ6IG5vZGUgPT4ge1xuICAgIGlmICghY29kZS4kaXNDb2RlTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dENvbnRlbnQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgcmV0dXJuICdgYGAnICsgKG5vZGUuZ2V0TGFuZ3VhZ2UoKSB8fCAnJykgKyAodGV4dENvbnRlbnQgPyAnXFxuJyArIHRleHRDb250ZW50IDogJycpICsgJ1xcbicgKyAnYGBgJztcbiAgfSxcbiAgcmVnRXhwOiAvXmBgYChcXHd7MSwxMH0pP1xccy8sXG4gIHJlcGxhY2U6IGNyZWF0ZUJsb2NrTm9kZShtYXRjaCA9PiB7XG4gICAgcmV0dXJuIGNvZGUuJGNyZWF0ZUNvZGVOb2RlKG1hdGNoID8gbWF0Y2hbMV0gOiB1bmRlZmluZWQpO1xuICB9KSxcbiAgdHlwZTogJ2VsZW1lbnQnXG59O1xuY29uc3QgVU5PUkRFUkVEX0xJU1QgPSB7XG4gIGRlcGVuZGVuY2llczogW2xpc3QuTGlzdE5vZGUsIGxpc3QuTGlzdEl0ZW1Ob2RlXSxcbiAgZXhwb3J0OiAobm9kZSwgZXhwb3J0Q2hpbGRyZW4pID0+IHtcbiAgICByZXR1cm4gbGlzdC4kaXNMaXN0Tm9kZShub2RlKSA/IGxpc3RFeHBvcnQobm9kZSwgZXhwb3J0Q2hpbGRyZW4sIDApIDogbnVsbDtcbiAgfSxcbiAgcmVnRXhwOiAvXihcXHMqKVstKitdXFxzLyxcbiAgcmVwbGFjZTogbGlzdFJlcGxhY2UoJ2J1bGxldCcpLFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBDSEVDS19MSVNUID0ge1xuICBkZXBlbmRlbmNpZXM6IFtsaXN0Lkxpc3ROb2RlLCBsaXN0Lkxpc3RJdGVtTm9kZV0sXG4gIGV4cG9ydDogKG5vZGUsIGV4cG9ydENoaWxkcmVuKSA9PiB7XG4gICAgcmV0dXJuIGxpc3QuJGlzTGlzdE5vZGUobm9kZSkgPyBsaXN0RXhwb3J0KG5vZGUsIGV4cG9ydENoaWxkcmVuLCAwKSA6IG51bGw7XG4gIH0sXG4gIHJlZ0V4cDogL14oXFxzKikoPzotXFxzKT9cXHM/KFxcWyhcXHN8eCk/XFxdKVxccy9pLFxuICByZXBsYWNlOiBsaXN0UmVwbGFjZSgnY2hlY2snKSxcbiAgdHlwZTogJ2VsZW1lbnQnXG59O1xuY29uc3QgT1JERVJFRF9MSVNUID0ge1xuICBkZXBlbmRlbmNpZXM6IFtsaXN0Lkxpc3ROb2RlLCBsaXN0Lkxpc3RJdGVtTm9kZV0sXG4gIGV4cG9ydDogKG5vZGUsIGV4cG9ydENoaWxkcmVuKSA9PiB7XG4gICAgcmV0dXJuIGxpc3QuJGlzTGlzdE5vZGUobm9kZSkgPyBsaXN0RXhwb3J0KG5vZGUsIGV4cG9ydENoaWxkcmVuLCAwKSA6IG51bGw7XG4gIH0sXG4gIHJlZ0V4cDogL14oXFxzKikoXFxkezEsfSlcXC5cXHMvLFxuICByZXBsYWNlOiBsaXN0UmVwbGFjZSgnbnVtYmVyJyksXG4gIHR5cGU6ICdlbGVtZW50J1xufTtcbmNvbnN0IElOTElORV9DT0RFID0ge1xuICBmb3JtYXQ6IFsnY29kZSddLFxuICB0YWc6ICdgJyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTtcbmNvbnN0IEhJR0hMSUdIVCA9IHtcbiAgZm9ybWF0OiBbJ2hpZ2hsaWdodCddLFxuICB0YWc6ICc9PScsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBCT0xEX0lUQUxJQ19TVEFSID0ge1xuICBmb3JtYXQ6IFsnYm9sZCcsICdpdGFsaWMnXSxcbiAgdGFnOiAnKioqJyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTtcbmNvbnN0IEJPTERfSVRBTElDX1VOREVSU0NPUkUgPSB7XG4gIGZvcm1hdDogWydib2xkJywgJ2l0YWxpYyddLFxuICBpbnRyYXdvcmQ6IGZhbHNlLFxuICB0YWc6ICdfX18nLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuY29uc3QgQk9MRF9TVEFSID0ge1xuICBmb3JtYXQ6IFsnYm9sZCddLFxuICB0YWc6ICcqKicsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBCT0xEX1VOREVSU0NPUkUgPSB7XG4gIGZvcm1hdDogWydib2xkJ10sXG4gIGludHJhd29yZDogZmFsc2UsXG4gIHRhZzogJ19fJyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTtcbmNvbnN0IFNUUklLRVRIUk9VR0ggPSB7XG4gIGZvcm1hdDogWydzdHJpa2V0aHJvdWdoJ10sXG4gIHRhZzogJ35+JyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTtcbmNvbnN0IElUQUxJQ19TVEFSID0ge1xuICBmb3JtYXQ6IFsnaXRhbGljJ10sXG4gIHRhZzogJyonLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuY29uc3QgSVRBTElDX1VOREVSU0NPUkUgPSB7XG4gIGZvcm1hdDogWydpdGFsaWMnXSxcbiAgaW50cmF3b3JkOiBmYWxzZSxcbiAgdGFnOiAnXycsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07IC8vIE9yZGVyIG9mIHRleHQgdHJhbnNmb3JtZXJzIG1hdHRlcnM6XG4vL1xuLy8gLSBjb2RlIHNob3VsZCBnbyBmaXJzdCBhcyBpdCBwcmV2ZW50cyBhbnkgdHJhbnNmb3JtYXRpb25zIGluc2lkZVxuLy8gLSB0aGVuIGxvbmdlciB0YWdzIG1hdGNoIChlLmcuICoqIG9yIF9fIHNob3VsZCBnbyBiZWZvcmUgKiBvciBfKVxuXG5jb25zdCBMSU5LID0ge1xuICBkZXBlbmRlbmNpZXM6IFtsaW5rLkxpbmtOb2RlXSxcbiAgZXhwb3J0OiAobm9kZSwgZXhwb3J0Q2hpbGRyZW4sIGV4cG9ydEZvcm1hdCkgPT4ge1xuICAgIGlmICghbGluay4kaXNMaW5rTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdGl0bGUgPSBub2RlLmdldFRpdGxlKCk7XG4gICAgY29uc3QgbGlua0NvbnRlbnQgPSB0aXRsZSA/IGBbJHtub2RlLmdldFRleHRDb250ZW50KCl9XSgke25vZGUuZ2V0VVJMKCl9IFwiJHt0aXRsZX1cIilgIDogYFske25vZGUuZ2V0VGV4dENvbnRlbnQoKX1dKCR7bm9kZS5nZXRVUkwoKX0pYDtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7IC8vIEFkZCB0ZXh0IHN0eWxlcyBvbmx5IGlmIGxpbmsgaGFzIHNpbmdsZSB0ZXh0IG5vZGUgaW5zaWRlLiBJZiBpdCdzIG1vcmVcbiAgICAvLyB0aGVuIG9uZSB3ZSBpZ25vcmUgaXQgYXMgbWFya2Rvd24gZG9lcyBub3Qgc3VwcG9ydCBuZXN0ZWQgc3R5bGVzIGZvciBsaW5rc1xuXG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDEgJiYgbGV4aWNhbC4kaXNUZXh0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgcmV0dXJuIGV4cG9ydEZvcm1hdChmaXJzdENoaWxkLCBsaW5rQ29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBsaW5rQ29udGVudDtcbiAgICB9XG4gIH0sXG4gIGltcG9ydFJlZ0V4cDogLyg/OlxcWyhbXltdKylcXF0pKD86XFwoKD86KFteKClcXHNdKykoPzpcXHNcIigoPzpbXlwiXSpcXFxcXCIpKlteXCJdKilcIlxccyopPylcXCkpLyxcbiAgcmVnRXhwOiAvKD86XFxbKFteW10rKVxcXSkoPzpcXCgoPzooW14oKVxcc10rKSg/Olxcc1wiKCg/OlteXCJdKlxcXFxcIikqW15cIl0qKVwiXFxzKik/KVxcKSkkLyxcbiAgcmVwbGFjZTogKHRleHROb2RlLCBtYXRjaCkgPT4ge1xuICAgIGNvbnN0IFssIGxpbmtUZXh0LCBsaW5rVXJsLCBsaW5rVGl0bGVdID0gbWF0Y2g7XG4gICAgY29uc3QgbGlua05vZGUgPSBsaW5rLiRjcmVhdGVMaW5rTm9kZShsaW5rVXJsLCB7XG4gICAgICB0aXRsZTogbGlua1RpdGxlXG4gICAgfSk7XG4gICAgY29uc3QgbGlua1RleHROb2RlID0gbGV4aWNhbC4kY3JlYXRlVGV4dE5vZGUobGlua1RleHQpO1xuICAgIGxpbmtUZXh0Tm9kZS5zZXRGb3JtYXQodGV4dE5vZGUuZ2V0Rm9ybWF0KCkpO1xuICAgIGxpbmtOb2RlLmFwcGVuZChsaW5rVGV4dE5vZGUpO1xuICAgIHRleHROb2RlLnJlcGxhY2UobGlua05vZGUpO1xuICB9LFxuICB0cmlnZ2VyOiAnKScsXG4gIHR5cGU6ICd0ZXh0LW1hdGNoJ1xufTtcblxuLyoqIEBtb2R1bGUgQGxleGljYWwvbWFya2Rvd24gKi9cbmNvbnN0IEVMRU1FTlRfVFJBTlNGT1JNRVJTID0gW0hFQURJTkcsIFFVT1RFLCBDT0RFLCBVTk9SREVSRURfTElTVCwgT1JERVJFRF9MSVNUXTsgLy8gT3JkZXIgb2YgdGV4dCBmb3JtYXQgdHJhbnNmb3JtZXJzIG1hdHRlcnM6XG4vL1xuLy8gLSBjb2RlIHNob3VsZCBnbyBmaXJzdCBhcyBpdCBwcmV2ZW50cyBhbnkgdHJhbnNmb3JtYXRpb25zIGluc2lkZVxuLy8gLSB0aGVuIGxvbmdlciB0YWdzIG1hdGNoIChlLmcuICoqIG9yIF9fIHNob3VsZCBnbyBiZWZvcmUgKiBvciBfKVxuXG5jb25zdCBURVhUX0ZPUk1BVF9UUkFOU0ZPUk1FUlMgPSBbSU5MSU5FX0NPREUsIEJPTERfSVRBTElDX1NUQVIsIEJPTERfSVRBTElDX1VOREVSU0NPUkUsIEJPTERfU1RBUiwgQk9MRF9VTkRFUlNDT1JFLCBISUdITElHSFQsIElUQUxJQ19TVEFSLCBJVEFMSUNfVU5ERVJTQ09SRSwgU1RSSUtFVEhST1VHSF07XG5jb25zdCBURVhUX01BVENIX1RSQU5TRk9STUVSUyA9IFtMSU5LXTtcbmNvbnN0IFRSQU5TRk9STUVSUyA9IFsuLi5FTEVNRU5UX1RSQU5TRk9STUVSUywgLi4uVEVYVF9GT1JNQVRfVFJBTlNGT1JNRVJTLCAuLi5URVhUX01BVENIX1RSQU5TRk9STUVSU107XG5cbmZ1bmN0aW9uICRjb252ZXJ0RnJvbU1hcmtkb3duU3RyaW5nKG1hcmtkb3duLCB0cmFuc2Zvcm1lcnMgPSBUUkFOU0ZPUk1FUlMsIG5vZGUpIHtcbiAgY29uc3QgaW1wb3J0TWFya2Rvd24gPSBjcmVhdGVNYXJrZG93bkltcG9ydCh0cmFuc2Zvcm1lcnMpO1xuICByZXR1cm4gaW1wb3J0TWFya2Rvd24obWFya2Rvd24sIG5vZGUpO1xufVxuXG5mdW5jdGlvbiAkY29udmVydFRvTWFya2Rvd25TdHJpbmcodHJhbnNmb3JtZXJzID0gVFJBTlNGT1JNRVJTLCBub2RlKSB7XG4gIGNvbnN0IGV4cG9ydE1hcmtkb3duID0gY3JlYXRlTWFya2Rvd25FeHBvcnQodHJhbnNmb3JtZXJzKTtcbiAgcmV0dXJuIGV4cG9ydE1hcmtkb3duKG5vZGUpO1xufVxuXG5leHBvcnRzLiRjb252ZXJ0RnJvbU1hcmtkb3duU3RyaW5nID0gJGNvbnZlcnRGcm9tTWFya2Rvd25TdHJpbmc7XG5leHBvcnRzLiRjb252ZXJ0VG9NYXJrZG93blN0cmluZyA9ICRjb252ZXJ0VG9NYXJrZG93blN0cmluZztcbmV4cG9ydHMuQk9MRF9JVEFMSUNfU1RBUiA9IEJPTERfSVRBTElDX1NUQVI7XG5leHBvcnRzLkJPTERfSVRBTElDX1VOREVSU0NPUkUgPSBCT0xEX0lUQUxJQ19VTkRFUlNDT1JFO1xuZXhwb3J0cy5CT0xEX1NUQVIgPSBCT0xEX1NUQVI7XG5leHBvcnRzLkJPTERfVU5ERVJTQ09SRSA9IEJPTERfVU5ERVJTQ09SRTtcbmV4cG9ydHMuQ0hFQ0tfTElTVCA9IENIRUNLX0xJU1Q7XG5leHBvcnRzLkNPREUgPSBDT0RFO1xuZXhwb3J0cy5FTEVNRU5UX1RSQU5TRk9STUVSUyA9IEVMRU1FTlRfVFJBTlNGT1JNRVJTO1xuZXhwb3J0cy5IRUFESU5HID0gSEVBRElORztcbmV4cG9ydHMuSElHSExJR0hUID0gSElHSExJR0hUO1xuZXhwb3J0cy5JTkxJTkVfQ09ERSA9IElOTElORV9DT0RFO1xuZXhwb3J0cy5JVEFMSUNfU1RBUiA9IElUQUxJQ19TVEFSO1xuZXhwb3J0cy5JVEFMSUNfVU5ERVJTQ09SRSA9IElUQUxJQ19VTkRFUlNDT1JFO1xuZXhwb3J0cy5MSU5LID0gTElOSztcbmV4cG9ydHMuT1JERVJFRF9MSVNUID0gT1JERVJFRF9MSVNUO1xuZXhwb3J0cy5RVU9URSA9IFFVT1RFO1xuZXhwb3J0cy5TVFJJS0VUSFJPVUdIID0gU1RSSUtFVEhST1VHSDtcbmV4cG9ydHMuVEVYVF9GT1JNQVRfVFJBTlNGT1JNRVJTID0gVEVYVF9GT1JNQVRfVFJBTlNGT1JNRVJTO1xuZXhwb3J0cy5URVhUX01BVENIX1RSQU5TRk9STUVSUyA9IFRFWFRfTUFUQ0hfVFJBTlNGT1JNRVJTO1xuZXhwb3J0cy5UUkFOU0ZPUk1FUlMgPSBUUkFOU0ZPUk1FUlM7XG5leHBvcnRzLlVOT1JERVJFRF9MSVNUID0gVU5PUkRFUkVEX0xJU1Q7XG5leHBvcnRzLnJlZ2lzdGVyTWFya2Rvd25TaG9ydGN1dHMgPSByZWdpc3Rlck1hcmtkb3duU2hvcnRjdXRzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lexical/markdown/LexicalMarkdown.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalMarkdown =  true ? __webpack_require__(/*! ./LexicalMarkdown.dev.js */ \"(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.dev.js\") : 0\nmodule.exports = LexicalMarkdown;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFya2Rvd24vTGV4aWNhbE1hcmtkb3duLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osd0JBQXdCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQywrRkFBMEIsSUFBSSxDQUFvQztBQUMzSSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL21hcmtkb3duL0xleGljYWxNYXJrZG93bi5qcz85YWEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsTWFya2Rvd24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbE1hcmtkb3duLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsTWFya2Rvd24ucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxNYXJrZG93bjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction AutoFocusPlugin({\n  defaultSelection\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    editor.focus(() => {\n      // If we try and move selection to the same point with setBaseAndExtent, it won't\n      // trigger a re-focus on the element. So in the case this occurs, we'll need to correct it.\n      // Normally this is fine, Selection API !== Focus API, but fore the intents of the naming\n      // of this plugin, which should preserve focus too.\n      const activeElement = document.activeElement;\n      const rootElement = editor.getRootElement();\n\n      if (rootElement !== null && (activeElement === null || !rootElement.contains(activeElement))) {\n        // Note: preventScroll won't work in Webkit.\n        rootElement.focus({\n          preventScroll: true\n        });\n      }\n    }, {\n      defaultSelection\n    });\n  }, [defaultSelection, editor]);\n  return null;\n}\n\nexports.AutoFocusPlugin = AutoFocusPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEF1dG9Gb2N1c1BsdWdpbi5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsNEdBQXVDO0FBQzVFLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQSx1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQXV0b0ZvY3VzUGx1Z2luLmRldi5qcz9jYjVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIEF1dG9Gb2N1c1BsdWdpbih7XG4gIGRlZmF1bHRTZWxlY3Rpb25cbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBlZGl0b3IuZm9jdXMoKCkgPT4ge1xuICAgICAgLy8gSWYgd2UgdHJ5IGFuZCBtb3ZlIHNlbGVjdGlvbiB0byB0aGUgc2FtZSBwb2ludCB3aXRoIHNldEJhc2VBbmRFeHRlbnQsIGl0IHdvbid0XG4gICAgICAvLyB0cmlnZ2VyIGEgcmUtZm9jdXMgb24gdGhlIGVsZW1lbnQuIFNvIGluIHRoZSBjYXNlIHRoaXMgb2NjdXJzLCB3ZSdsbCBuZWVkIHRvIGNvcnJlY3QgaXQuXG4gICAgICAvLyBOb3JtYWxseSB0aGlzIGlzIGZpbmUsIFNlbGVjdGlvbiBBUEkgIT09IEZvY3VzIEFQSSwgYnV0IGZvcmUgdGhlIGludGVudHMgb2YgdGhlIG5hbWluZ1xuICAgICAgLy8gb2YgdGhpcyBwbHVnaW4sIHdoaWNoIHNob3VsZCBwcmVzZXJ2ZSBmb2N1cyB0b28uXG4gICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG5cbiAgICAgIGlmIChyb290RWxlbWVudCAhPT0gbnVsbCAmJiAoYWN0aXZlRWxlbWVudCA9PT0gbnVsbCB8fCAhcm9vdEVsZW1lbnQuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpKSB7XG4gICAgICAgIC8vIE5vdGU6IHByZXZlbnRTY3JvbGwgd29uJ3Qgd29yayBpbiBXZWJraXQuXG4gICAgICAgIHJvb3RFbGVtZW50LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGRlZmF1bHRTZWxlY3Rpb25cbiAgICB9KTtcbiAgfSwgW2RlZmF1bHRTZWxlY3Rpb24sIGVkaXRvcl0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5BdXRvRm9jdXNQbHVnaW4gPSBBdXRvRm9jdXNQbHVnaW47XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalAutoFocusPlugin.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalAutoFocusPlugin =  true ? __webpack_require__(/*! ./LexicalAutoFocusPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js\") : 0\nmodule.exports = LexicalAutoFocusPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEF1dG9Gb2N1c1BsdWdpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLCtCQUErQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsMEdBQWlDLElBQUksQ0FBMkM7QUFDaEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQXV0b0ZvY3VzUGx1Z2luLmpzPzgwYjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxBdXRvRm9jdXNQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbEF1dG9Gb2N1c1BsdWdpbi5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbEF1dG9Gb2N1c1BsdWdpbi5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbEF1dG9Gb2N1c1BsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.dev.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalCollaborationContext.dev.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst entries = [['Cat', 'rgb(125, 50, 0)'], ['Dog', 'rgb(100, 0, 0)'], ['Rabbit', 'rgb(150, 0, 0)'], ['Frog', 'rgb(200, 0, 0)'], ['Fox', 'rgb(200, 75, 0)'], ['Hedgehog', 'rgb(0, 75, 0)'], ['Pigeon', 'rgb(0, 125, 0)'], ['Squirrel', 'rgb(75, 100, 0)'], ['Bear', 'rgb(125, 100, 0)'], ['Tiger', 'rgb(0, 0, 150)'], ['Leopard', 'rgb(0, 0, 200)'], ['Zebra', 'rgb(0, 0, 250)'], ['Wolf', 'rgb(0, 100, 150)'], ['Owl', 'rgb(0, 100, 100)'], ['Gull', 'rgb(100, 0, 100)'], ['Squid', 'rgb(150, 0, 150)']];\nconst randomEntry = entries[Math.floor(Math.random() * entries.length)];\nconst CollaborationContext = /*#__PURE__*/react.createContext({\n  clientID: 0,\n  color: randomEntry[1],\n  isCollabActive: false,\n  name: randomEntry[0],\n  yjsDocMap: new Map()\n});\nfunction useCollaborationContext(username, color) {\n  const collabContext = react.useContext(CollaborationContext);\n\n  if (username != null) {\n    collabContext.name = username;\n  }\n\n  if (color != null) {\n    collabContext.color = color;\n  }\n\n  return collabContext;\n}\n\nexports.CollaborationContext = CollaborationContext;\nexports.useCollaborationContext = useCollaborationContext;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbGxhYm9yYXRpb25Db250ZXh0LmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbGxhYm9yYXRpb25Db250ZXh0LmRldi5qcz83YjcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBlbnRyaWVzID0gW1snQ2F0JywgJ3JnYigxMjUsIDUwLCAwKSddLCBbJ0RvZycsICdyZ2IoMTAwLCAwLCAwKSddLCBbJ1JhYmJpdCcsICdyZ2IoMTUwLCAwLCAwKSddLCBbJ0Zyb2cnLCAncmdiKDIwMCwgMCwgMCknXSwgWydGb3gnLCAncmdiKDIwMCwgNzUsIDApJ10sIFsnSGVkZ2Vob2cnLCAncmdiKDAsIDc1LCAwKSddLCBbJ1BpZ2VvbicsICdyZ2IoMCwgMTI1LCAwKSddLCBbJ1NxdWlycmVsJywgJ3JnYig3NSwgMTAwLCAwKSddLCBbJ0JlYXInLCAncmdiKDEyNSwgMTAwLCAwKSddLCBbJ1RpZ2VyJywgJ3JnYigwLCAwLCAxNTApJ10sIFsnTGVvcGFyZCcsICdyZ2IoMCwgMCwgMjAwKSddLCBbJ1plYnJhJywgJ3JnYigwLCAwLCAyNTApJ10sIFsnV29sZicsICdyZ2IoMCwgMTAwLCAxNTApJ10sIFsnT3dsJywgJ3JnYigwLCAxMDAsIDEwMCknXSwgWydHdWxsJywgJ3JnYigxMDAsIDAsIDEwMCknXSwgWydTcXVpZCcsICdyZ2IoMTUwLCAwLCAxNTApJ11dO1xuY29uc3QgcmFuZG9tRW50cnkgPSBlbnRyaWVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGVudHJpZXMubGVuZ3RoKV07XG5jb25zdCBDb2xsYWJvcmF0aW9uQ29udGV4dCA9IC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgY2xpZW50SUQ6IDAsXG4gIGNvbG9yOiByYW5kb21FbnRyeVsxXSxcbiAgaXNDb2xsYWJBY3RpdmU6IGZhbHNlLFxuICBuYW1lOiByYW5kb21FbnRyeVswXSxcbiAgeWpzRG9jTWFwOiBuZXcgTWFwKClcbn0pO1xuZnVuY3Rpb24gdXNlQ29sbGFib3JhdGlvbkNvbnRleHQodXNlcm5hbWUsIGNvbG9yKSB7XG4gIGNvbnN0IGNvbGxhYkNvbnRleHQgPSByZWFjdC51c2VDb250ZXh0KENvbGxhYm9yYXRpb25Db250ZXh0KTtcblxuICBpZiAodXNlcm5hbWUgIT0gbnVsbCkge1xuICAgIGNvbGxhYkNvbnRleHQubmFtZSA9IHVzZXJuYW1lO1xuICB9XG5cbiAgaWYgKGNvbG9yICE9IG51bGwpIHtcbiAgICBjb2xsYWJDb250ZXh0LmNvbG9yID0gY29sb3I7XG4gIH1cblxuICByZXR1cm4gY29sbGFiQ29udGV4dDtcbn1cblxuZXhwb3J0cy5Db2xsYWJvcmF0aW9uQ29udGV4dCA9IENvbGxhYm9yYXRpb25Db250ZXh0O1xuZXhwb3J0cy51c2VDb2xsYWJvcmF0aW9uQ29udGV4dCA9IHVzZUNvbGxhYm9yYXRpb25Db250ZXh0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalCollaborationContext.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalCollaborationContext =  true ? __webpack_require__(/*! ./LexicalCollaborationContext.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.dev.js\") : 0\nmodule.exports = LexicalCollaborationContext;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbGxhYm9yYXRpb25Db250ZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osb0NBQW9DLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxvSEFBc0MsSUFBSSxDQUFnRDtBQUMvSyIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb2xsYWJvcmF0aW9uQ29udGV4dC5qcz9jMmRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsQ29sbGFib3JhdGlvbkNvbnRleHQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbENvbGxhYm9yYXRpb25Db250ZXh0LmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsQ29sbGFib3JhdGlvbkNvbnRleHQucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxDb2xsYWJvcmF0aW9uQ29udGV4dDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalComposer.dev.js":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposer.dev.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst HISTORY_MERGE_OPTIONS = {\n  tag: 'history-merge'\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = React.useMemo(() => {\n    const {\n      theme,\n      namespace,\n      editor__DEPRECATED: initialEditor,\n      nodes,\n      onError,\n      editorState: initialEditorState\n    } = initialConfig;\n    const context = LexicalComposerContext.createLexicalComposerContext(null, theme);\n    let editor = initialEditor || null;\n\n    if (editor === null) {\n      const newEditor = lexical.createEditor({\n        editable: initialConfig.editable,\n        namespace,\n        nodes,\n        onError: error => onError(error, newEditor),\n        theme\n      });\n      initializeEditor(newEditor, initialEditorState);\n      editor = newEditor;\n    }\n\n    return [editor, context];\n  }, // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffect(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true); // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/React.createElement(LexicalComposerContext.LexicalComposerContext.Provider, {\n    value: composerContext\n  }, children);\n}\n\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = lexical.$getRoot();\n\n      if (root.isEmpty()) {\n        const paragraph = lexical.$createParagraphNode();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n\n        if (lexical.$getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n\n      case 'function':\n        {\n          editor.update(() => {\n            const root = lexical.$getRoot();\n\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\n\nexports.LexicalComposer = LexicalComposer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyLmRldi5qcz9mMTdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCB1c2VMYXlvdXRFZmZlY3RJbXBsID0gQ0FOX1VTRV9ET00gPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG52YXIgdXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0SW1wbDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgSElTVE9SWV9NRVJHRV9PUFRJT05TID0ge1xuICB0YWc6ICdoaXN0b3J5LW1lcmdlJ1xufTtcbmZ1bmN0aW9uIExleGljYWxDb21wb3Nlcih7XG4gIGluaXRpYWxDb25maWcsXG4gIGNoaWxkcmVuXG59KSB7XG4gIGNvbnN0IGNvbXBvc2VyQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHRoZW1lLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgZWRpdG9yX19ERVBSRUNBVEVEOiBpbml0aWFsRWRpdG9yLFxuICAgICAgbm9kZXMsXG4gICAgICBvbkVycm9yLFxuICAgICAgZWRpdG9yU3RhdGU6IGluaXRpYWxFZGl0b3JTdGF0ZVxuICAgIH0gPSBpbml0aWFsQ29uZmlnO1xuICAgIGNvbnN0IGNvbnRleHQgPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LmNyZWF0ZUxleGljYWxDb21wb3NlckNvbnRleHQobnVsbCwgdGhlbWUpO1xuICAgIGxldCBlZGl0b3IgPSBpbml0aWFsRWRpdG9yIHx8IG51bGw7XG5cbiAgICBpZiAoZWRpdG9yID09PSBudWxsKSB7XG4gICAgICBjb25zdCBuZXdFZGl0b3IgPSBsZXhpY2FsLmNyZWF0ZUVkaXRvcih7XG4gICAgICAgIGVkaXRhYmxlOiBpbml0aWFsQ29uZmlnLmVkaXRhYmxlLFxuICAgICAgICBuYW1lc3BhY2UsXG4gICAgICAgIG5vZGVzLFxuICAgICAgICBvbkVycm9yOiBlcnJvciA9PiBvbkVycm9yKGVycm9yLCBuZXdFZGl0b3IpLFxuICAgICAgICB0aGVtZVxuICAgICAgfSk7XG4gICAgICBpbml0aWFsaXplRWRpdG9yKG5ld0VkaXRvciwgaW5pdGlhbEVkaXRvclN0YXRlKTtcbiAgICAgIGVkaXRvciA9IG5ld0VkaXRvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gW2VkaXRvciwgY29udGV4dF07XG4gIH0sIC8vIFdlIG9ubHkgZG8gdGhpcyBmb3IgaW5pdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpc0VkaXRhYmxlID0gaW5pdGlhbENvbmZpZy5lZGl0YWJsZTtcbiAgICBjb25zdCBbZWRpdG9yXSA9IGNvbXBvc2VyQ29udGV4dDtcbiAgICBlZGl0b3Iuc2V0RWRpdGFibGUoaXNFZGl0YWJsZSAhPT0gdW5kZWZpbmVkID8gaXNFZGl0YWJsZSA6IHRydWUpOyAvLyBXZSBvbmx5IGRvIHRoaXMgZm9yIGluaXRcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KExleGljYWxDb21wb3NlckNvbnRleHQuTGV4aWNhbENvbXBvc2VyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb21wb3NlckNvbnRleHRcbiAgfSwgY2hpbGRyZW4pO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplRWRpdG9yKGVkaXRvciwgaW5pdGlhbEVkaXRvclN0YXRlKSB7XG4gIGlmIChpbml0aWFsRWRpdG9yU3RhdGUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoaW5pdGlhbEVkaXRvclN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHJvb3QgPSBsZXhpY2FsLiRnZXRSb290KCk7XG5cbiAgICAgIGlmIChyb290LmlzRW1wdHkoKSkge1xuICAgICAgICBjb25zdCBwYXJhZ3JhcGggPSBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAgIHJvb3QuYXBwZW5kKHBhcmFncmFwaCk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBDQU5fVVNFX0RPTSA/IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgOiBudWxsO1xuXG4gICAgICAgIGlmIChsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKSAhPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50ICE9PSBudWxsICYmIGFjdGl2ZUVsZW1lbnQgPT09IGVkaXRvci5nZXRSb290RWxlbWVudCgpKSB7XG4gICAgICAgICAgcGFyYWdyYXBoLnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgfSBlbHNlIGlmIChpbml0aWFsRWRpdG9yU3RhdGUgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBpbml0aWFsRWRpdG9yU3RhdGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRFZGl0b3JTdGF0ZSA9IGVkaXRvci5wYXJzZUVkaXRvclN0YXRlKGluaXRpYWxFZGl0b3JTdGF0ZSk7XG4gICAgICAgICAgZWRpdG9yLnNldEVkaXRvclN0YXRlKHBhcnNlZEVkaXRvclN0YXRlLCBISVNUT1JZX01FUkdFX09QVElPTlMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHtcbiAgICAgICAgICBlZGl0b3Iuc2V0RWRpdG9yU3RhdGUoaW5pdGlhbEVkaXRvclN0YXRlLCBISVNUT1JZX01FUkdFX09QVElPTlMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IGxleGljYWwuJGdldFJvb3QoKTtcblxuICAgICAgICAgICAgaWYgKHJvb3QuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgIGluaXRpYWxFZGl0b3JTdGF0ZShlZGl0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIEhJU1RPUllfTUVSR0VfT1BUSU9OUyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5MZXhpY2FsQ29tcG9zZXIgPSBMZXhpY2FsQ29tcG9zZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalComposer.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalComposer.js":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposer.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalComposer =  true ? __webpack_require__(/*! ./LexicalComposer.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalComposer.dev.js\") : 0\nmodule.exports = LexicalComposer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osd0JBQXdCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyw0RkFBMEIsSUFBSSxDQUFvQztBQUMzSSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3Nlci5qcz85ZTJhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsQ29tcG9zZXIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbENvbXBvc2VyLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsQ29tcG9zZXIucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxDb21wb3NlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalComposer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposerContext.dev.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst LexicalComposerContext = /*#__PURE__*/react.createContext(null);\nfunction createLexicalComposerContext(parent, theme) {\n  let parentContext = null;\n\n  if (parent != null) {\n    parentContext = parent[1];\n  }\n\n  function getTheme() {\n    if (theme != null) {\n      return theme;\n    }\n\n    return parentContext != null ? parentContext.getTheme() : null;\n  }\n\n  return {\n    getTheme\n  };\n}\nfunction useLexicalComposerContext() {\n  const composerContext = react.useContext(LexicalComposerContext);\n\n  if (composerContext == null) {\n    {\n      throw Error(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);\n    }\n  }\n\n  return composerContext;\n}\n\nexports.LexicalComposerContext = LexicalComposerContext;\nexports.createLexicalComposerContext = createLexicalComposerContext;\nexports.useLexicalComposerContext = useLexicalComposerContext;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dC5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QixvQ0FBb0M7QUFDcEMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dC5kZXYuanM/MGE0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gY3JlYXRlTGV4aWNhbENvbXBvc2VyQ29udGV4dChwYXJlbnQsIHRoZW1lKSB7XG4gIGxldCBwYXJlbnRDb250ZXh0ID0gbnVsbDtcblxuICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICBwYXJlbnRDb250ZXh0ID0gcGFyZW50WzFdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGhlbWUoKSB7XG4gICAgaWYgKHRoZW1lICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGVtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50Q29udGV4dCAhPSBudWxsID8gcGFyZW50Q29udGV4dC5nZXRUaGVtZSgpIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0VGhlbWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKSB7XG4gIGNvbnN0IGNvbXBvc2VyQ29udGV4dCA9IHJlYWN0LnVzZUNvbnRleHQoTGV4aWNhbENvbXBvc2VyQ29udGV4dCk7XG5cbiAgaWYgKGNvbXBvc2VyQ29udGV4dCA9PSBudWxsKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dDogY2Fubm90IGZpbmQgYSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0YCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbXBvc2VyQ29udGV4dDtcbn1cblxuZXhwb3J0cy5MZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dDtcbmV4cG9ydHMuY3JlYXRlTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IGNyZWF0ZUxleGljYWxDb21wb3NlckNvbnRleHQ7XG5leHBvcnRzLnVzZUxleGljYWxDb21wb3NlckNvbnRleHQgPSB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposerContext.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalComposerContext =  true ? __webpack_require__(/*! ./LexicalComposerContext.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.js\") : 0\nmodule.exports = LexicalComposerContext;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLCtCQUErQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsMEdBQWlDLElBQUksQ0FBMkM7QUFDaEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0LmpzPzllM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxDb21wb3NlckNvbnRleHQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbENvbXBvc2VyQ29udGV4dC5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbENvbXBvc2VyQ29udGV4dC5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalContentEditable.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalContentEditable.dev.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\nfunction ContentEditable({\n  ariaActiveDescendant,\n  ariaAutoComplete,\n  ariaControls,\n  ariaDescribedBy,\n  ariaExpanded,\n  ariaLabel,\n  ariaLabelledBy,\n  ariaMultiline,\n  ariaOwns,\n  ariaRequired,\n  autoCapitalize,\n  className,\n  id,\n  role = 'textbox',\n  spellCheck = true,\n  style,\n  tabIndex,\n  'data-testid': testid,\n  ...rest\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isEditable, setEditable] = React.useState(false);\n  const ref = React.useCallback(rootElement => {\n    editor.setRootElement(rootElement);\n  }, [editor]);\n  useLayoutEffect(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  return /*#__PURE__*/React.createElement(\"div\", _extends({}, rest, {\n    \"aria-activedescendant\": !isEditable ? undefined : ariaActiveDescendant,\n    \"aria-autocomplete\": !isEditable ? 'none' : ariaAutoComplete,\n    \"aria-controls\": !isEditable ? undefined : ariaControls,\n    \"aria-describedby\": ariaDescribedBy,\n    \"aria-expanded\": !isEditable ? undefined : role === 'combobox' ? !!ariaExpanded : undefined,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-multiline\": ariaMultiline,\n    \"aria-owns\": !isEditable ? undefined : ariaOwns,\n    \"aria-readonly\": !isEditable ? true : undefined,\n    \"aria-required\": ariaRequired,\n    autoCapitalize: autoCapitalize,\n    className: className,\n    contentEditable: isEditable,\n    \"data-testid\": testid,\n    id: id,\n    ref: ref,\n    role: role,\n    spellCheck: spellCheck,\n    style: style,\n    tabIndex: tabIndex\n  }));\n}\n\nexports.ContentEditable = ContentEditable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsNEdBQXVDO0FBQzVFLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5kZXYuanM/ZGM5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgdXNlTGF5b3V0RWZmZWN0SW1wbCA9IENBTl9VU0VfRE9NID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xudmFyIHVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdEltcGw7XG5cbmZ1bmN0aW9uIENvbnRlbnRFZGl0YWJsZSh7XG4gIGFyaWFBY3RpdmVEZXNjZW5kYW50LFxuICBhcmlhQXV0b0NvbXBsZXRlLFxuICBhcmlhQ29udHJvbHMsXG4gIGFyaWFEZXNjcmliZWRCeSxcbiAgYXJpYUV4cGFuZGVkLFxuICBhcmlhTGFiZWwsXG4gIGFyaWFMYWJlbGxlZEJ5LFxuICBhcmlhTXVsdGlsaW5lLFxuICBhcmlhT3ducyxcbiAgYXJpYVJlcXVpcmVkLFxuICBhdXRvQ2FwaXRhbGl6ZSxcbiAgY2xhc3NOYW1lLFxuICBpZCxcbiAgcm9sZSA9ICd0ZXh0Ym94JyxcbiAgc3BlbGxDaGVjayA9IHRydWUsXG4gIHN0eWxlLFxuICB0YWJJbmRleCxcbiAgJ2RhdGEtdGVzdGlkJzogdGVzdGlkLFxuICAuLi5yZXN0XG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IFtpc0VkaXRhYmxlLCBzZXRFZGl0YWJsZV0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKHJvb3RFbGVtZW50ID0+IHtcbiAgICBlZGl0b3Iuc2V0Um9vdEVsZW1lbnQocm9vdEVsZW1lbnQpO1xuICB9LCBbZWRpdG9yXSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2V0RWRpdGFibGUoZWRpdG9yLmlzRWRpdGFibGUoKSk7XG4gICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIoY3VycmVudElzRWRpdGFibGUgPT4ge1xuICAgICAgc2V0RWRpdGFibGUoY3VycmVudElzRWRpdGFibGUpO1xuICAgIH0pO1xuICB9LCBbZWRpdG9yXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgIFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6ICFpc0VkaXRhYmxlID8gdW5kZWZpbmVkIDogYXJpYUFjdGl2ZURlc2NlbmRhbnQsXG4gICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiAhaXNFZGl0YWJsZSA/ICdub25lJyA6IGFyaWFBdXRvQ29tcGxldGUsXG4gICAgXCJhcmlhLWNvbnRyb2xzXCI6ICFpc0VkaXRhYmxlID8gdW5kZWZpbmVkIDogYXJpYUNvbnRyb2xzLFxuICAgIFwiYXJpYS1kZXNjcmliZWRieVwiOiBhcmlhRGVzY3JpYmVkQnksXG4gICAgXCJhcmlhLWV4cGFuZGVkXCI6ICFpc0VkaXRhYmxlID8gdW5kZWZpbmVkIDogcm9sZSA9PT0gJ2NvbWJvYm94JyA/ICEhYXJpYUV4cGFuZGVkIDogdW5kZWZpbmVkLFxuICAgIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsXG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogYXJpYUxhYmVsbGVkQnksXG4gICAgXCJhcmlhLW11bHRpbGluZVwiOiBhcmlhTXVsdGlsaW5lLFxuICAgIFwiYXJpYS1vd25zXCI6ICFpc0VkaXRhYmxlID8gdW5kZWZpbmVkIDogYXJpYU93bnMsXG4gICAgXCJhcmlhLXJlYWRvbmx5XCI6ICFpc0VkaXRhYmxlID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtcmVxdWlyZWRcIjogYXJpYVJlcXVpcmVkLFxuICAgIGF1dG9DYXBpdGFsaXplOiBhdXRvQ2FwaXRhbGl6ZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBjb250ZW50RWRpdGFibGU6IGlzRWRpdGFibGUsXG4gICAgXCJkYXRhLXRlc3RpZFwiOiB0ZXN0aWQsXG4gICAgaWQ6IGlkLFxuICAgIHJlZjogcmVmLFxuICAgIHJvbGU6IHJvbGUsXG4gICAgc3BlbGxDaGVjazogc3BlbGxDaGVjayxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgdGFiSW5kZXg6IHRhYkluZGV4XG4gIH0pKTtcbn1cblxuZXhwb3J0cy5Db250ZW50RWRpdGFibGUgPSBDb250ZW50RWRpdGFibGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalContentEditable.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalContentEditable.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalContentEditable.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalContentEditable =  true ? __webpack_require__(/*! ./LexicalContentEditable.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalContentEditable.dev.js\") : 0\nmodule.exports = LexicalContentEditable;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLCtCQUErQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsMEdBQWlDLElBQUksQ0FBMkM7QUFDaEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29udGVudEVkaXRhYmxlLmpzP2YxMjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxDb250ZW50RWRpdGFibGUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbENvbnRlbnRFZGl0YWJsZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalContentEditable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalErrorBoundary.dev.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n\nvar changedArray = function changedArray(a, b) {\n  if (a === void 0) {\n    a = [];\n  }\n\n  if (b === void 0) {\n    b = [];\n  }\n\n  return a.length !== b.length || a.some(function (item, index) {\n    return !Object.is(item, b[index]);\n  });\n};\n\nvar initialState = {\n  error: null\n};\n\nvar ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n    _this.state = initialState;\n\n    _this.resetErrorBoundary = function () {\n      var _this$props;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n      _this.reset();\n    };\n\n    return _this;\n  }\n\n  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  };\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.reset = function reset() {\n    this.setState(initialState);\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n\n    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var error = this.state.error;\n    var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n    // happens to *also* be in the resetKeys array, we'd end up resetting\n    // the error boundary immediately. This would likely trigger a second\n    // error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call\n    // of cDU after the error is set\n\n    if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onResetKe, _this$props3;\n\n      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n      this.reset();\n    }\n  };\n\n  _proto.render = function render() {\n    var error = this.state.error;\n    var _this$props4 = this.props,\n        fallbackRender = _this$props4.fallbackRender,\n        FallbackComponent = _this$props4.FallbackComponent,\n        fallback = _this$props4.fallback;\n\n    if (error !== null) {\n      var _props = {\n        error: error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n\n      if ( /*#__PURE__*/React.isValidElement(fallback)) {\n        return fallback;\n      } else if (typeof fallbackRender === 'function') {\n        return fallbackRender(_props);\n      } else if (FallbackComponent) {\n        return /*#__PURE__*/React.createElement(FallbackComponent, _props);\n      } else {\n        throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n      }\n    }\n\n    return this.props.children;\n  };\n\n  return ErrorBoundary;\n}(React.Component);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction LexicalErrorBoundary({\n  children,\n  onError\n}) {\n  return /*#__PURE__*/React.createElement(ErrorBoundary, {\n    fallback: /*#__PURE__*/React.createElement(\"div\", {\n      style: {\n        border: '1px solid #f00',\n        color: '#f00',\n        padding: '8px'\n      }\n    }, \"An error was thrown.\"),\n    onError: onError\n  }, children);\n}\n\nmodule.exports = LexicalErrorBoundary;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEVycm9yQm91bmRhcnkuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZFQUE2RSxlQUFlO0FBQzVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxFcnJvckJvdW5kYXJ5LmRldi5qcz82M2IyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxudmFyIGNoYW5nZWRBcnJheSA9IGZ1bmN0aW9uIGNoYW5nZWRBcnJheShhLCBiKSB7XG4gIGlmIChhID09PSB2b2lkIDApIHtcbiAgICBhID0gW107XG4gIH1cblxuICBpZiAoYiA9PT0gdm9pZCAwKSB7XG4gICAgYiA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGEubGVuZ3RoICE9PSBiLmxlbmd0aCB8fCBhLnNvbWUoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuICFPYmplY3QuaXMoaXRlbSwgYltpbmRleF0pO1xuICB9KTtcbn07XG5cbnZhciBpbml0aWFsU3RhdGUgPSB7XG4gIGVycm9yOiBudWxsXG59O1xuXG52YXIgRXJyb3JCb3VuZGFyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShFcnJvckJvdW5kYXJ5LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBFcnJvckJvdW5kYXJ5KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBfYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoX2FyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXG4gICAgX3RoaXMucmVzZXRFcnJvckJvdW5kYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5wcm9wcy5vblJlc2V0ID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcykub25SZXNldC5hcHBseShfdGhpcyRwcm9wcywgYXJncyk7XG5cbiAgICAgIF90aGlzLnJlc2V0KCk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEVycm9yQm91bmRhcnkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBlcnJvclxuICAgIH07XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IEVycm9yQm91bmRhcnkucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuc2V0U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkQ2F0Y2ggPSBmdW5jdGlvbiBjb21wb25lbnREaWRDYXRjaChlcnJvciwgaW5mbykge1xuICAgIHZhciBfdGhpcyRwcm9wcyRvbkVycm9yLCBfdGhpcyRwcm9wczI7XG5cbiAgICAoX3RoaXMkcHJvcHMkb25FcnJvciA9IChfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzKS5vbkVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkb25FcnJvci5jYWxsKF90aGlzJHByb3BzMiwgZXJyb3IsIGluZm8pO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgIHZhciByZXNldEtleXMgPSB0aGlzLnByb3BzLnJlc2V0S2V5czsgLy8gVGhlcmUncyBhbiBlZGdlIGNhc2Ugd2hlcmUgaWYgdGhlIHRoaW5nIHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvclxuICAgIC8vIGhhcHBlbnMgdG8gKmFsc28qIGJlIGluIHRoZSByZXNldEtleXMgYXJyYXksIHdlJ2QgZW5kIHVwIHJlc2V0dGluZ1xuICAgIC8vIHRoZSBlcnJvciBib3VuZGFyeSBpbW1lZGlhdGVseS4gVGhpcyB3b3VsZCBsaWtlbHkgdHJpZ2dlciBhIHNlY29uZFxuICAgIC8vIGVycm9yIHRvIGJlIHRocm93bi5cbiAgICAvLyBTbyB3ZSBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGUgcmVzZXRLZXlzIG9uIHRoZSBmaXJzdCBjYWxsXG4gICAgLy8gb2YgY0RVIGFmdGVyIHRoZSBlcnJvciBpcyBzZXRcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCAmJiBwcmV2U3RhdGUuZXJyb3IgIT09IG51bGwgJiYgY2hhbmdlZEFycmF5KHByZXZQcm9wcy5yZXNldEtleXMsIHJlc2V0S2V5cykpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRvblJlc2V0S2UsIF90aGlzJHByb3BzMztcblxuICAgICAgKF90aGlzJHByb3BzJG9uUmVzZXRLZSA9IChfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzKS5vblJlc2V0S2V5c0NoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHByb3BzJG9uUmVzZXRLZS5jYWxsKF90aGlzJHByb3BzMywgcHJldlByb3BzLnJlc2V0S2V5cywgcmVzZXRLZXlzKTtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICBmYWxsYmFja1JlbmRlciA9IF90aGlzJHByb3BzNC5mYWxsYmFja1JlbmRlcixcbiAgICAgICAgRmFsbGJhY2tDb21wb25lbnQgPSBfdGhpcyRwcm9wczQuRmFsbGJhY2tDb21wb25lbnQsXG4gICAgICAgIGZhbGxiYWNrID0gX3RoaXMkcHJvcHM0LmZhbGxiYWNrO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICB2YXIgX3Byb3BzID0ge1xuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIHJlc2V0RXJyb3JCb3VuZGFyeTogdGhpcy5yZXNldEVycm9yQm91bmRhcnlcbiAgICAgIH07XG5cbiAgICAgIGlmICggLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGZhbGxiYWNrKSkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmYWxsYmFja1JlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tSZW5kZXIoX3Byb3BzKTtcbiAgICAgIH0gZWxzZSBpZiAoRmFsbGJhY2tDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZhbGxiYWNrQ29tcG9uZW50LCBfcHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWFjdC1lcnJvci1ib3VuZGFyeSByZXF1aXJlcyBlaXRoZXIgYSBmYWxsYmFjaywgZmFsbGJhY2tSZW5kZXIsIG9yIEZhbGxiYWNrQ29tcG9uZW50IHByb3AnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfTtcblxuICByZXR1cm4gRXJyb3JCb3VuZGFyeTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gTGV4aWNhbEVycm9yQm91bmRhcnkoe1xuICBjaGlsZHJlbixcbiAgb25FcnJvclxufSkge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeSwge1xuICAgIGZhbGxiYWNrOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBib3JkZXI6ICcxcHggc29saWQgI2YwMCcsXG4gICAgICAgIGNvbG9yOiAnI2YwMCcsXG4gICAgICAgIHBhZGRpbmc6ICc4cHgnXG4gICAgICB9XG4gICAgfSwgXCJBbiBlcnJvciB3YXMgdGhyb3duLlwiKSxcbiAgICBvbkVycm9yOiBvbkVycm9yXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsRXJyb3JCb3VuZGFyeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalErrorBoundary.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalErrorBoundary =  true ? __webpack_require__(/*! ./LexicalErrorBoundary.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.js\") : 0\nmodule.exports = LexicalErrorBoundary;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEVycm9yQm91bmRhcnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWiw2QkFBNkIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLHNHQUErQixJQUFJLENBQXlDO0FBQzFKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEVycm9yQm91bmRhcnkuanM/Y2Q1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbEVycm9yQm91bmRhcnkgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbEVycm9yQm91bmRhcnkuZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxFcnJvckJvdW5kYXJ5LnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsRXJyb3JCb3VuZGFyeTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar history = __webpack_require__(/*! @lexical/history */ \"(ssr)/./node_modules/@lexical/history/LexicalHistory.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useHistory(editor, externalHistoryState, delay = 1000) {\n  const historyState = react.useMemo(() => externalHistoryState || history.createEmptyHistoryState(), [externalHistoryState]);\n  react.useEffect(() => {\n    return history.registerHistory(editor, historyState, delay);\n  }, [delay, editor, historyState]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction HistoryPlugin({\n  externalHistoryState\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useHistory(editor, externalHistoryState);\n  return null;\n}\n\nexports.createEmptyHistoryState = history.createEmptyHistoryState;\nexports.HistoryPlugin = HistoryPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhpc3RvcnlQbHVnaW4uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLDRHQUF1QztBQUM1RSxjQUFjLG1CQUFPLENBQUMsaUZBQWtCO0FBQ3hDLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxIaXN0b3J5UGx1Z2luLmRldi5qcz9mZWFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciBoaXN0b3J5ID0gcmVxdWlyZSgnQGxleGljYWwvaGlzdG9yeScpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlSGlzdG9yeShlZGl0b3IsIGV4dGVybmFsSGlzdG9yeVN0YXRlLCBkZWxheSA9IDEwMDApIHtcbiAgY29uc3QgaGlzdG9yeVN0YXRlID0gcmVhY3QudXNlTWVtbygoKSA9PiBleHRlcm5hbEhpc3RvcnlTdGF0ZSB8fCBoaXN0b3J5LmNyZWF0ZUVtcHR5SGlzdG9yeVN0YXRlKCksIFtleHRlcm5hbEhpc3RvcnlTdGF0ZV0pO1xuICByZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBoaXN0b3J5LnJlZ2lzdGVySGlzdG9yeShlZGl0b3IsIGhpc3RvcnlTdGF0ZSwgZGVsYXkpO1xuICB9LCBbZGVsYXksIGVkaXRvciwgaGlzdG9yeVN0YXRlXSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIEhpc3RvcnlQbHVnaW4oe1xuICBleHRlcm5hbEhpc3RvcnlTdGF0ZVxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICB1c2VIaXN0b3J5KGVkaXRvciwgZXh0ZXJuYWxIaXN0b3J5U3RhdGUpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5jcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSA9IGhpc3RvcnkuY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGU7XG5leHBvcnRzLkhpc3RvcnlQbHVnaW4gPSBIaXN0b3J5UGx1Z2luO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHistoryPlugin.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHistoryPlugin =  true ? __webpack_require__(/*! ./LexicalHistoryPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js\") : 0\nmodule.exports = LexicalHistoryPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhpc3RvcnlQbHVnaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWiw2QkFBNkIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLHNHQUErQixJQUFJLENBQXlDO0FBQzFKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhpc3RvcnlQbHVnaW4uanM/N2JmMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbEhpc3RvcnlQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbEhpc3RvcnlQbHVnaW4uZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxIaXN0b3J5UGx1Z2luLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsSGlzdG9yeVBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar useLexicalNodeSelection = __webpack_require__(/*! @lexical/react/useLexicalNodeSelection */ \"(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst INSERT_HORIZONTAL_RULE_COMMAND = lexical.createCommand('INSERT_HORIZONTAL_RULE_COMMAND');\n\nfunction HorizontalRuleComponent({\n  nodeKey\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection.useLexicalNodeSelection(nodeKey);\n  const onDelete = React.useCallback(event => {\n    if (isSelected && lexical.$isNodeSelection(lexical.$getSelection())) {\n      event.preventDefault();\n      const node = lexical.$getNodeByKey(nodeKey);\n\n      if ($isHorizontalRuleNode(node)) {\n        node.remove();\n      }\n    }\n\n    return false;\n  }, [isSelected, nodeKey]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, event => {\n      const hrElem = editor.getElementByKey(nodeKey);\n\n      if (event.target === hrElem) {\n        if (!event.shiftKey) {\n          clearSelection();\n        }\n\n        setSelected(!isSelected);\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_DELETE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW));\n  }, [clearSelection, editor, isSelected, nodeKey, onDelete, setSelected]);\n  React.useEffect(() => {\n    const hrElem = editor.getElementByKey(nodeKey);\n\n    if (hrElem !== null) {\n      hrElem.className = isSelected ? 'selected' : '';\n    }\n  }, [editor, isSelected, nodeKey]);\n  return null;\n}\n\nclass HorizontalRuleNode extends lexical.DecoratorNode {\n  static getType() {\n    return 'horizontalrule';\n  }\n\n  static clone(node) {\n    return new HorizontalRuleNode(node.__key);\n  }\n\n  static importJSON(serializedNode) {\n    return $createHorizontalRuleNode();\n  }\n\n  static importDOM() {\n    return {\n      hr: () => ({\n        conversion: convertHorizontalRuleElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportJSON() {\n    return {\n      type: 'horizontalrule',\n      version: 1\n    };\n  }\n\n  exportDOM() {\n    return {\n      element: document.createElement('hr')\n    };\n  }\n\n  createDOM() {\n    return document.createElement('hr');\n  }\n\n  getTextContent() {\n    return '\\n';\n  }\n\n  isInline() {\n    return false;\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  decorate() {\n    return /*#__PURE__*/React.createElement(HorizontalRuleComponent, {\n      nodeKey: this.__key\n    });\n  }\n\n}\n\nfunction convertHorizontalRuleElement() {\n  return {\n    node: $createHorizontalRuleNode()\n  };\n}\n\nfunction $createHorizontalRuleNode() {\n  return lexical.$applyNodeReplacement(new HorizontalRuleNode());\n}\nfunction $isHorizontalRuleNode(node) {\n  return node instanceof HorizontalRuleNode;\n}\n\nexports.$createHorizontalRuleNode = $createHorizontalRuleNode;\nexports.$isHorizontalRuleNode = $isHorizontalRuleNode;\nexports.HorizontalRuleNode = HorizontalRuleNode;\nexports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZS5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsNEdBQXVDO0FBQzVFLDhCQUE4QixtQkFBTyxDQUFDLDhHQUF3QztBQUM5RSxZQUFZLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyx3REFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0IsMEJBQTBCO0FBQzFCLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxIb3Jpem9udGFsUnVsZU5vZGUuZGV2LmpzPzc3NmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIHVzZUxleGljYWxOb2RlU2VsZWN0aW9uID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24nKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IElOU0VSVF9IT1JJWk9OVEFMX1JVTEVfQ09NTUFORCA9IGxleGljYWwuY3JlYXRlQ29tbWFuZCgnSU5TRVJUX0hPUklaT05UQUxfUlVMRV9DT01NQU5EJyk7XG5cbmZ1bmN0aW9uIEhvcml6b250YWxSdWxlQ29tcG9uZW50KHtcbiAgbm9kZUtleVxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICBjb25zdCBbaXNTZWxlY3RlZCwgc2V0U2VsZWN0ZWQsIGNsZWFyU2VsZWN0aW9uXSA9IHVzZUxleGljYWxOb2RlU2VsZWN0aW9uLnVzZUxleGljYWxOb2RlU2VsZWN0aW9uKG5vZGVLZXkpO1xuICBjb25zdCBvbkRlbGV0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBpZiAoaXNTZWxlY3RlZCAmJiBsZXhpY2FsLiRpc05vZGVTZWxlY3Rpb24obGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCkpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3Qgbm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleShub2RlS2V5KTtcblxuICAgICAgaWYgKCRpc0hvcml6b250YWxSdWxlTm9kZShub2RlKSkge1xuICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgW2lzU2VsZWN0ZWQsIG5vZGVLZXldKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gdXRpbHMubWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuQ0xJQ0tfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgaHJFbGVtID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShub2RlS2V5KTtcblxuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gaHJFbGVtKSB7XG4gICAgICAgIGlmICghZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICBjbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0U2VsZWN0ZWQoIWlzU2VsZWN0ZWQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0RFTEVURV9DT01NQU5ELCBvbkRlbGV0ZSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQkFDS1NQQUNFX0NPTU1BTkQsIG9uRGVsZXRlLCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSk7XG4gIH0sIFtjbGVhclNlbGVjdGlvbiwgZWRpdG9yLCBpc1NlbGVjdGVkLCBub2RlS2V5LCBvbkRlbGV0ZSwgc2V0U2VsZWN0ZWRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBockVsZW0gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KG5vZGVLZXkpO1xuXG4gICAgaWYgKGhyRWxlbSAhPT0gbnVsbCkge1xuICAgICAgaHJFbGVtLmNsYXNzTmFtZSA9IGlzU2VsZWN0ZWQgPyAnc2VsZWN0ZWQnIDogJyc7XG4gICAgfVxuICB9LCBbZWRpdG9yLCBpc1NlbGVjdGVkLCBub2RlS2V5XSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5jbGFzcyBIb3Jpem9udGFsUnVsZU5vZGUgZXh0ZW5kcyBsZXhpY2FsLkRlY29yYXRvck5vZGUge1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2hvcml6b250YWxydWxlJztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBIb3Jpem9udGFsUnVsZU5vZGUobm9kZS5fX2tleSk7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlSG9yaXpvbnRhbFJ1bGVOb2RlKCk7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBocjogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydEhvcml6b250YWxSdWxlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdob3Jpem9udGFscnVsZScsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIGV4cG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaHInKVxuICAgIH07XG4gIH1cblxuICBjcmVhdGVET00oKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2hyJyk7XG4gIH1cblxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICByZXR1cm4gJ1xcbic7XG4gIH1cblxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB1cGRhdGVET00oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZGVjb3JhdGUoKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEhvcml6b250YWxSdWxlQ29tcG9uZW50LCB7XG4gICAgICBub2RlS2V5OiB0aGlzLl9fa2V5XG4gICAgfSk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBjb252ZXJ0SG9yaXpvbnRhbFJ1bGVFbGVtZW50KCkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVIb3Jpem9udGFsUnVsZU5vZGUoKVxuICB9O1xufVxuXG5mdW5jdGlvbiAkY3JlYXRlSG9yaXpvbnRhbFJ1bGVOb2RlKCkge1xuICByZXR1cm4gbGV4aWNhbC4kYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IEhvcml6b250YWxSdWxlTm9kZSgpKTtcbn1cbmZ1bmN0aW9uICRpc0hvcml6b250YWxSdWxlTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgSG9yaXpvbnRhbFJ1bGVOb2RlO1xufVxuXG5leHBvcnRzLiRjcmVhdGVIb3Jpem9udGFsUnVsZU5vZGUgPSAkY3JlYXRlSG9yaXpvbnRhbFJ1bGVOb2RlO1xuZXhwb3J0cy4kaXNIb3Jpem9udGFsUnVsZU5vZGUgPSAkaXNIb3Jpem9udGFsUnVsZU5vZGU7XG5leHBvcnRzLkhvcml6b250YWxSdWxlTm9kZSA9IEhvcml6b250YWxSdWxlTm9kZTtcbmV4cG9ydHMuSU5TRVJUX0hPUklaT05UQUxfUlVMRV9DT01NQU5EID0gSU5TRVJUX0hPUklaT05UQUxfUlVMRV9DT01NQU5EO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHorizontalRuleNode.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHorizontalRuleNode =  true ? __webpack_require__(/*! ./LexicalHorizontalRuleNode.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js\") : 0\nmodule.exports = LexicalHorizontalRuleNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLGtDQUFrQyxLQUFzQyxHQUFHLG1CQUFPLENBQUMsZ0hBQW9DLElBQUksQ0FBOEM7QUFDeksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsSG9yaXpvbnRhbFJ1bGVOb2RlLmpzPzg2M2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxIb3Jpem9udGFsUnVsZU5vZGUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZS5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZS5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalLinkPlugin.dev.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalLinkPlugin.dev.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar link = __webpack_require__(/*! @lexical/link */ \"(ssr)/./node_modules/@lexical/link/LexicalLink.js\");\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction LinkPlugin({\n  validateUrl\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    if (!editor.hasNodes([link.LinkNode])) {\n      throw new Error('LinkPlugin: LinkNode not registered on editor');\n    }\n\n    return utils.mergeRegister(editor.registerCommand(link.TOGGLE_LINK_COMMAND, payload => {\n      if (payload === null) {\n        link.toggleLink(payload);\n        return true;\n      } else if (typeof payload === 'string') {\n        if (validateUrl === undefined || validateUrl(payload)) {\n          link.toggleLink(payload);\n          return true;\n        }\n\n        return false;\n      } else {\n        const {\n          url,\n          target,\n          rel,\n          title\n        } = payload;\n        link.toggleLink(url, {\n          rel,\n          target,\n          title\n        });\n        return true;\n      }\n    }, lexical.COMMAND_PRIORITY_LOW), validateUrl !== undefined ? editor.registerCommand(lexical.PASTE_COMMAND, event => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.$isRangeSelection(selection) || selection.isCollapsed() || !(event instanceof ClipboardEvent) || event.clipboardData == null) {\n        return false;\n      }\n\n      const clipboardText = event.clipboardData.getData('text');\n\n      if (!validateUrl(clipboardText)) {\n        return false;\n      } // If we select nodes that are elements then avoid applying the link.\n\n\n      if (!selection.getNodes().some(node => lexical.$isElementNode(node))) {\n        editor.dispatchCommand(link.TOGGLE_LINK_COMMAND, clipboardText);\n        event.preventDefault();\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW) : () => {// Don't paste arbritrary text as a link when there's no validate function\n    });\n  }, [editor, validateUrl]);\n  return null;\n}\n\nexports.LinkPlugin = LinkPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpbmtQbHVnaW4uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyx3RUFBZTtBQUNsQyw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNwQyxjQUFjLG1CQUFPLENBQUMsd0RBQVM7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyx5Q0FBeUM7QUFDOUMsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxMaW5rUGx1Z2luLmRldi5qcz8zZDg4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGluayA9IHJlcXVpcmUoJ0BsZXhpY2FsL2xpbmsnKTtcbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQGxleGljYWwvdXRpbHMnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gTGlua1BsdWdpbih7XG4gIHZhbGlkYXRlVXJsXG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIHJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlZGl0b3IuaGFzTm9kZXMoW2xpbmsuTGlua05vZGVdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMaW5rUGx1Z2luOiBMaW5rTm9kZSBub3QgcmVnaXN0ZXJlZCBvbiBlZGl0b3InKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMubWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxpbmsuVE9HR0xFX0xJTktfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgICBpZiAocGF5bG9hZCA9PT0gbnVsbCkge1xuICAgICAgICBsaW5rLnRvZ2dsZUxpbmsocGF5bG9hZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHZhbGlkYXRlVXJsID09PSB1bmRlZmluZWQgfHwgdmFsaWRhdGVVcmwocGF5bG9hZCkpIHtcbiAgICAgICAgICBsaW5rLnRvZ2dsZUxpbmsocGF5bG9hZCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICByZWwsXG4gICAgICAgICAgdGl0bGVcbiAgICAgICAgfSA9IHBheWxvYWQ7XG4gICAgICAgIGxpbmsudG9nZ2xlTGluayh1cmwsIHtcbiAgICAgICAgICByZWwsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHRpdGxlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgdmFsaWRhdGVVcmwgIT09IHVuZGVmaW5lZCA/IGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5QQVNURV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgIShldmVudCBpbnN0YW5jZW9mIENsaXBib2FyZEV2ZW50KSB8fCBldmVudC5jbGlwYm9hcmREYXRhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjbGlwYm9hcmRUZXh0ID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0Jyk7XG5cbiAgICAgIGlmICghdmFsaWRhdGVVcmwoY2xpcGJvYXJkVGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBJZiB3ZSBzZWxlY3Qgbm9kZXMgdGhhdCBhcmUgZWxlbWVudHMgdGhlbiBhdm9pZCBhcHBseWluZyB0aGUgbGluay5cblxuXG4gICAgICBpZiAoIXNlbGVjdGlvbi5nZXROb2RlcygpLnNvbWUobm9kZSA9PiBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG5vZGUpKSkge1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxpbmsuVE9HR0xFX0xJTktfQ09NTUFORCwgY2xpcGJvYXJkVGV4dCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVykgOiAoKSA9PiB7Ly8gRG9uJ3QgcGFzdGUgYXJicml0cmFyeSB0ZXh0IGFzIGEgbGluayB3aGVuIHRoZXJlJ3Mgbm8gdmFsaWRhdGUgZnVuY3Rpb25cbiAgICB9KTtcbiAgfSwgW2VkaXRvciwgdmFsaWRhdGVVcmxdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydHMuTGlua1BsdWdpbiA9IExpbmtQbHVnaW47XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalLinkPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalLinkPlugin.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalLinkPlugin.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalLinkPlugin =  true ? __webpack_require__(/*! ./LexicalLinkPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalLinkPlugin.dev.js\") : 0\nmodule.exports = LexicalLinkPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpbmtQbHVnaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWiwwQkFBMEIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLGdHQUE0QixJQUFJLENBQXNDO0FBQ2pKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpbmtQbHVnaW4uanM/MWI4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbExpbmtQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbExpbmtQbHVnaW4uZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxMaW5rUGx1Z2luLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsTGlua1BsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalLinkPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalListPlugin.dev.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalListPlugin.dev.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar list = __webpack_require__(/*! @lexical/list */ \"(ssr)/./node_modules/@lexical/list/LexicalList.js\");\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useList(editor) {\n  react.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(list.INSERT_ORDERED_LIST_COMMAND, () => {\n      list.insertList(editor, 'number');\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(list.INSERT_UNORDERED_LIST_COMMAND, () => {\n      list.insertList(editor, 'bullet');\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(list.REMOVE_LIST_COMMAND, () => {\n      list.removeList(editor);\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n      const hasHandledInsertParagraph = list.$handleListInsertParagraph();\n\n      if (hasHandledInsertParagraph) {\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW));\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction ListPlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    if (!editor.hasNodes([list.ListNode, list.ListItemNode])) {\n      throw new Error('ListPlugin: ListNode and/or ListItemNode not registered on editor');\n    }\n  }, [editor]);\n  useList(editor);\n  return null;\n}\n\nexports.ListPlugin = ListPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpc3RQbHVnaW4uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyx3RUFBZTtBQUNsQyw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsWUFBWSxtQkFBTyxDQUFDLHdHQUFPO0FBQzNCLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLHdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxMaXN0UGx1Z2luLmRldi5qcz9iMjgyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGlzdCA9IHJlcXVpcmUoJ0BsZXhpY2FsL2xpc3QnKTtcbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlTGlzdChlZGl0b3IpIHtcbiAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gdXRpbHMubWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxpc3QuSU5TRVJUX09SREVSRURfTElTVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgICBsaXN0Lmluc2VydExpc3QoZWRpdG9yLCAnbnVtYmVyJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsaXN0LklOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgICBsaXN0Lmluc2VydExpc3QoZWRpdG9yLCAnYnVsbGV0Jyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsaXN0LlJFTU9WRV9MSVNUX0NPTU1BTkQsICgpID0+IHtcbiAgICAgIGxpc3QucmVtb3ZlTGlzdChlZGl0b3IpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5JTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsICgpID0+IHtcbiAgICAgIGNvbnN0IGhhc0hhbmRsZWRJbnNlcnRQYXJhZ3JhcGggPSBsaXN0LiRoYW5kbGVMaXN0SW5zZXJ0UGFyYWdyYXBoKCk7XG5cbiAgICAgIGlmIChoYXNIYW5kbGVkSW5zZXJ0UGFyYWdyYXBoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVykpO1xuICB9LCBbZWRpdG9yXSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIExpc3RQbHVnaW4oKSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIHJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlZGl0b3IuaGFzTm9kZXMoW2xpc3QuTGlzdE5vZGUsIGxpc3QuTGlzdEl0ZW1Ob2RlXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTGlzdFBsdWdpbjogTGlzdE5vZGUgYW5kL29yIExpc3RJdGVtTm9kZSBub3QgcmVnaXN0ZXJlZCBvbiBlZGl0b3InKTtcbiAgICB9XG4gIH0sIFtlZGl0b3JdKTtcbiAgdXNlTGlzdChlZGl0b3IpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5MaXN0UGx1Z2luID0gTGlzdFBsdWdpbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalListPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalListPlugin.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalListPlugin.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalListPlugin =  true ? __webpack_require__(/*! ./LexicalListPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalListPlugin.dev.js\") : 0\nmodule.exports = LexicalListPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpc3RQbHVnaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWiwwQkFBMEIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLGdHQUE0QixJQUFJLENBQXNDO0FBQ2pKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpc3RQbHVnaW4uanM/NzU2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbExpc3RQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbExpc3RQbHVnaW4uZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxMaXN0UGx1Z2luLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsTGlzdFBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalListPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar markdown = __webpack_require__(/*! @lexical/markdown */ \"(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.js\");\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar LexicalHorizontalRuleNode = __webpack_require__(/*! @lexical/react/LexicalHorizontalRuleNode */ \"(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst HR = {\n  dependencies: [LexicalHorizontalRuleNode.HorizontalRuleNode],\n  export: node => {\n    return LexicalHorizontalRuleNode.$isHorizontalRuleNode(node) ? '***' : null;\n  },\n  regExp: /^(---|\\*\\*\\*|___)\\s?$/,\n  replace: (parentNode, _1, _2, isImport) => {\n    const line = LexicalHorizontalRuleNode.$createHorizontalRuleNode(); // TODO: Get rid of isImport flag\n\n    if (isImport || parentNode.getNextSibling() != null) {\n      parentNode.replace(line);\n    } else {\n      parentNode.insertBefore(line);\n    }\n\n    line.selectNext();\n  },\n  type: 'element'\n};\nconst DEFAULT_TRANSFORMERS = [HR, ...markdown.TRANSFORMERS];\nfunction MarkdownShortcutPlugin({\n  transformers = DEFAULT_TRANSFORMERS\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    return markdown.registerMarkdownShortcuts(editor, transformers);\n  }, [editor, transformers]);\n  return null;\n}\n\nexports.DEFAULT_TRANSFORMERS = DEFAULT_TRANSFORMERS;\nexports.MarkdownShortcutPlugin = MarkdownShortcutPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE1hcmtkb3duU2hvcnRjdXRQbHVnaW4uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxvRkFBbUI7QUFDMUMsNkJBQTZCLG1CQUFPLENBQUMsNEdBQXVDO0FBQzVFLGdDQUFnQyxtQkFBTyxDQUFDLGtIQUEwQztBQUNsRixZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdFQUF3RTs7QUFFeEU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCLDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxNYXJrZG93blNob3J0Y3V0UGx1Z2luLmRldi5qcz84ZGVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFya2Rvd24gPSByZXF1aXJlKCdAbGV4aWNhbC9tYXJrZG93bicpO1xudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZSA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxIb3Jpem9udGFsUnVsZU5vZGUnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IEhSID0ge1xuICBkZXBlbmRlbmNpZXM6IFtMZXhpY2FsSG9yaXpvbnRhbFJ1bGVOb2RlLkhvcml6b250YWxSdWxlTm9kZV0sXG4gIGV4cG9ydDogbm9kZSA9PiB7XG4gICAgcmV0dXJuIExleGljYWxIb3Jpem9udGFsUnVsZU5vZGUuJGlzSG9yaXpvbnRhbFJ1bGVOb2RlKG5vZGUpID8gJyoqKicgOiBudWxsO1xuICB9LFxuICByZWdFeHA6IC9eKC0tLXxcXCpcXCpcXCp8X19fKVxccz8kLyxcbiAgcmVwbGFjZTogKHBhcmVudE5vZGUsIF8xLCBfMiwgaXNJbXBvcnQpID0+IHtcbiAgICBjb25zdCBsaW5lID0gTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZS4kY3JlYXRlSG9yaXpvbnRhbFJ1bGVOb2RlKCk7IC8vIFRPRE86IEdldCByaWQgb2YgaXNJbXBvcnQgZmxhZ1xuXG4gICAgaWYgKGlzSW1wb3J0IHx8IHBhcmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKSAhPSBudWxsKSB7XG4gICAgICBwYXJlbnROb2RlLnJlcGxhY2UobGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGxpbmUpO1xuICAgIH1cblxuICAgIGxpbmUuc2VsZWN0TmV4dCgpO1xuICB9LFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBERUZBVUxUX1RSQU5TRk9STUVSUyA9IFtIUiwgLi4ubWFya2Rvd24uVFJBTlNGT1JNRVJTXTtcbmZ1bmN0aW9uIE1hcmtkb3duU2hvcnRjdXRQbHVnaW4oe1xuICB0cmFuc2Zvcm1lcnMgPSBERUZBVUxUX1RSQU5TRk9STUVSU1xufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICByZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBtYXJrZG93bi5yZWdpc3Rlck1hcmtkb3duU2hvcnRjdXRzKGVkaXRvciwgdHJhbnNmb3JtZXJzKTtcbiAgfSwgW2VkaXRvciwgdHJhbnNmb3JtZXJzXSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLkRFRkFVTFRfVFJBTlNGT1JNRVJTID0gREVGQVVMVF9UUkFOU0ZPUk1FUlM7XG5leHBvcnRzLk1hcmtkb3duU2hvcnRjdXRQbHVnaW4gPSBNYXJrZG93blNob3J0Y3V0UGx1Z2luO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalMarkdownShortcutPlugin =  true ? __webpack_require__(/*! ./LexicalMarkdownShortcutPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js\") : 0\nmodule.exports = LexicalMarkdownShortcutPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE1hcmtkb3duU2hvcnRjdXRQbHVnaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWixzQ0FBc0MsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLHdIQUF3QyxJQUFJLENBQWtEO0FBQ3JMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE1hcmtkb3duU2hvcnRjdXRQbHVnaW4uanM/NDlmZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbE1hcmtkb3duU2hvcnRjdXRQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbE1hcmtkb3duU2hvcnRjdXRQbHVnaW4uZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxNYXJrZG93blNob3J0Y3V0UGx1Z2luLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsTWFya2Rvd25TaG9ydGN1dFBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalNestedComposer.dev.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalNestedComposer.dev.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalCollaborationContext = __webpack_require__(/*! @lexical/react/LexicalCollaborationContext */ \"(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.js\");\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction LexicalNestedComposer({\n  initialEditor,\n  children,\n  initialNodes,\n  initialTheme,\n  skipCollabChecks\n}) {\n  const wasCollabPreviouslyReadyRef = React.useRef(false);\n  const parentContext = React.useContext(LexicalComposerContext.LexicalComposerContext);\n\n  if (parentContext == null) {\n    {\n      throw Error(`Unexpected parent context null on a nested composer`);\n    }\n  }\n\n  const [parentEditor, {\n    getTheme: getParentTheme\n  }] = parentContext;\n  const composerContext = React.useMemo(() => {\n    const composerTheme = initialTheme || getParentTheme() || undefined;\n    const context = LexicalComposerContext.createLexicalComposerContext(parentContext, composerTheme);\n\n    if (composerTheme !== undefined) {\n      initialEditor._config.theme = composerTheme;\n    }\n\n    initialEditor._parentEditor = parentEditor;\n\n    if (!initialNodes) {\n      const parentNodes = initialEditor._nodes = new Map(parentEditor._nodes);\n\n      for (const [type, entry] of parentNodes) {\n        initialEditor._nodes.set(type, {\n          klass: entry.klass,\n          replace: entry.replace,\n          replaceWithKlass: entry.replaceWithKlass,\n          transforms: new Set()\n        });\n      }\n    } else {\n      for (const klass of initialNodes) {\n        const type = klass.getType();\n\n        initialEditor._nodes.set(type, {\n          klass,\n          replace: null,\n          replaceWithKlass: null,\n          transforms: new Set()\n        });\n      }\n    }\n\n    initialEditor._config.namespace = parentEditor._config.namespace;\n    initialEditor._editable = parentEditor._editable;\n    return [initialEditor, context];\n  }, // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []); // If collaboration is enabled, make sure we don't render the children until the collaboration subdocument is ready.\n\n  const {\n    isCollabActive,\n    yjsDocMap\n  } = LexicalCollaborationContext.useCollaborationContext();\n  const isCollabReady = skipCollabChecks || wasCollabPreviouslyReadyRef.current || yjsDocMap.has(initialEditor.getKey());\n  React.useEffect(() => {\n    if (isCollabReady) {\n      wasCollabPreviouslyReadyRef.current = true;\n    }\n  }, [isCollabReady]); // Update `isEditable` state of nested editor in response to the same change on parent editor.\n\n  React.useEffect(() => {\n    return parentEditor.registerEditableListener(editable => {\n      initialEditor.setEditable(editable);\n    });\n  }, [initialEditor, parentEditor]);\n  return /*#__PURE__*/React.createElement(LexicalComposerContext.LexicalComposerContext.Provider, {\n    value: composerContext\n  }, !isCollabActive || isCollabReady ? children : null);\n}\n\nexports.LexicalNestedComposer = LexicalNestedComposer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE5lc3RlZENvbXBvc2VyLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixrQ0FBa0MsbUJBQU8sQ0FBQyxzSEFBNEM7QUFDdEYsNkJBQTZCLG1CQUFPLENBQUMsNEdBQXVDO0FBQzVFLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQkFBb0I7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsTmVzdGVkQ29tcG9zZXIuZGV2LmpzPzI5M2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMZXhpY2FsQ29sbGFib3JhdGlvbkNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29sbGFib3JhdGlvbkNvbnRleHQnKTtcbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gTGV4aWNhbE5lc3RlZENvbXBvc2VyKHtcbiAgaW5pdGlhbEVkaXRvcixcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxOb2RlcyxcbiAgaW5pdGlhbFRoZW1lLFxuICBza2lwQ29sbGFiQ2hlY2tzXG59KSB7XG4gIGNvbnN0IHdhc0NvbGxhYlByZXZpb3VzbHlSZWFkeVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHBhcmVudENvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KExleGljYWxDb21wb3NlckNvbnRleHQuTGV4aWNhbENvbXBvc2VyQ29udGV4dCk7XG5cbiAgaWYgKHBhcmVudENvbnRleHQgPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBVbmV4cGVjdGVkIHBhcmVudCBjb250ZXh0IG51bGwgb24gYSBuZXN0ZWQgY29tcG9zZXJgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBbcGFyZW50RWRpdG9yLCB7XG4gICAgZ2V0VGhlbWU6IGdldFBhcmVudFRoZW1lXG4gIH1dID0gcGFyZW50Q29udGV4dDtcbiAgY29uc3QgY29tcG9zZXJDb250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgY29tcG9zZXJUaGVtZSA9IGluaXRpYWxUaGVtZSB8fCBnZXRQYXJlbnRUaGVtZSgpIHx8IHVuZGVmaW5lZDtcbiAgICBjb25zdCBjb250ZXh0ID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC5jcmVhdGVMZXhpY2FsQ29tcG9zZXJDb250ZXh0KHBhcmVudENvbnRleHQsIGNvbXBvc2VyVGhlbWUpO1xuXG4gICAgaWYgKGNvbXBvc2VyVGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5pdGlhbEVkaXRvci5fY29uZmlnLnRoZW1lID0gY29tcG9zZXJUaGVtZTtcbiAgICB9XG5cbiAgICBpbml0aWFsRWRpdG9yLl9wYXJlbnRFZGl0b3IgPSBwYXJlbnRFZGl0b3I7XG5cbiAgICBpZiAoIWluaXRpYWxOb2Rlcykge1xuICAgICAgY29uc3QgcGFyZW50Tm9kZXMgPSBpbml0aWFsRWRpdG9yLl9ub2RlcyA9IG5ldyBNYXAocGFyZW50RWRpdG9yLl9ub2Rlcyk7XG5cbiAgICAgIGZvciAoY29uc3QgW3R5cGUsIGVudHJ5XSBvZiBwYXJlbnROb2Rlcykge1xuICAgICAgICBpbml0aWFsRWRpdG9yLl9ub2Rlcy5zZXQodHlwZSwge1xuICAgICAgICAgIGtsYXNzOiBlbnRyeS5rbGFzcyxcbiAgICAgICAgICByZXBsYWNlOiBlbnRyeS5yZXBsYWNlLFxuICAgICAgICAgIHJlcGxhY2VXaXRoS2xhc3M6IGVudHJ5LnJlcGxhY2VXaXRoS2xhc3MsXG4gICAgICAgICAgdHJhbnNmb3JtczogbmV3IFNldCgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGtsYXNzIG9mIGluaXRpYWxOb2Rlcykge1xuICAgICAgICBjb25zdCB0eXBlID0ga2xhc3MuZ2V0VHlwZSgpO1xuXG4gICAgICAgIGluaXRpYWxFZGl0b3IuX25vZGVzLnNldCh0eXBlLCB7XG4gICAgICAgICAga2xhc3MsXG4gICAgICAgICAgcmVwbGFjZTogbnVsbCxcbiAgICAgICAgICByZXBsYWNlV2l0aEtsYXNzOiBudWxsLFxuICAgICAgICAgIHRyYW5zZm9ybXM6IG5ldyBTZXQoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0aWFsRWRpdG9yLl9jb25maWcubmFtZXNwYWNlID0gcGFyZW50RWRpdG9yLl9jb25maWcubmFtZXNwYWNlO1xuICAgIGluaXRpYWxFZGl0b3IuX2VkaXRhYmxlID0gcGFyZW50RWRpdG9yLl9lZGl0YWJsZTtcbiAgICByZXR1cm4gW2luaXRpYWxFZGl0b3IsIGNvbnRleHRdO1xuICB9LCAvLyBXZSBvbmx5IGRvIHRoaXMgZm9yIGluaXRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbXSk7IC8vIElmIGNvbGxhYm9yYXRpb24gaXMgZW5hYmxlZCwgbWFrZSBzdXJlIHdlIGRvbid0IHJlbmRlciB0aGUgY2hpbGRyZW4gdW50aWwgdGhlIGNvbGxhYm9yYXRpb24gc3ViZG9jdW1lbnQgaXMgcmVhZHkuXG5cbiAgY29uc3Qge1xuICAgIGlzQ29sbGFiQWN0aXZlLFxuICAgIHlqc0RvY01hcFxuICB9ID0gTGV4aWNhbENvbGxhYm9yYXRpb25Db250ZXh0LnVzZUNvbGxhYm9yYXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IGlzQ29sbGFiUmVhZHkgPSBza2lwQ29sbGFiQ2hlY2tzIHx8IHdhc0NvbGxhYlByZXZpb3VzbHlSZWFkeVJlZi5jdXJyZW50IHx8IHlqc0RvY01hcC5oYXMoaW5pdGlhbEVkaXRvci5nZXRLZXkoKSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzQ29sbGFiUmVhZHkpIHtcbiAgICAgIHdhc0NvbGxhYlByZXZpb3VzbHlSZWFkeVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtpc0NvbGxhYlJlYWR5XSk7IC8vIFVwZGF0ZSBgaXNFZGl0YWJsZWAgc3RhdGUgb2YgbmVzdGVkIGVkaXRvciBpbiByZXNwb25zZSB0byB0aGUgc2FtZSBjaGFuZ2Ugb24gcGFyZW50IGVkaXRvci5cblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBwYXJlbnRFZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKGVkaXRhYmxlID0+IHtcbiAgICAgIGluaXRpYWxFZGl0b3Iuc2V0RWRpdGFibGUoZWRpdGFibGUpO1xuICAgIH0pO1xuICB9LCBbaW5pdGlhbEVkaXRvciwgcGFyZW50RWRpdG9yXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMZXhpY2FsQ29tcG9zZXJDb250ZXh0LkxleGljYWxDb21wb3NlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29tcG9zZXJDb250ZXh0XG4gIH0sICFpc0NvbGxhYkFjdGl2ZSB8fCBpc0NvbGxhYlJlYWR5ID8gY2hpbGRyZW4gOiBudWxsKTtcbn1cblxuZXhwb3J0cy5MZXhpY2FsTmVzdGVkQ29tcG9zZXIgPSBMZXhpY2FsTmVzdGVkQ29tcG9zZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalNestedComposer.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalNestedComposer.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalNestedComposer.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalNestedComposer =  true ? __webpack_require__(/*! ./LexicalNestedComposer.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalNestedComposer.dev.js\") : 0\nmodule.exports = LexicalNestedComposer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE5lc3RlZENvbXBvc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osOEJBQThCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyx3R0FBZ0MsSUFBSSxDQUEwQztBQUM3SiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxOZXN0ZWRDb21wb3Nlci5qcz8zZjIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsTmVzdGVkQ29tcG9zZXIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbE5lc3RlZENvbXBvc2VyLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsTmVzdGVkQ29tcG9zZXIucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxOZXN0ZWRDb21wb3NlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalNestedComposer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalOnChangePlugin.dev.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalOnChangePlugin.dev.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? react.useLayoutEffect : react.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction OnChangePlugin({\n  ignoreHistoryMergeTagChange = true,\n  ignoreSelectionChange = false,\n  onChange\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useLayoutEffect(() => {\n    if (onChange) {\n      return editor.registerUpdateListener(({\n        editorState,\n        dirtyElements,\n        dirtyLeaves,\n        prevEditorState,\n        tags\n      }) => {\n        if (ignoreSelectionChange && dirtyElements.size === 0 && dirtyLeaves.size === 0 || ignoreHistoryMergeTagChange && tags.has('history-merge') || prevEditorState.isEmpty()) {\n          return;\n        }\n\n        onChange(editorState, editor, tags);\n      });\n    }\n  }, [editor, ignoreHistoryMergeTagChange, ignoreSelectionChange, onChange]);\n  return null;\n}\n\nexports.OnChangePlugin = OnChangePlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE9uQ2hhbmdlUGx1Z2luLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsT25DaGFuZ2VQbHVnaW4uZGV2LmpzPzMwNWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCB1c2VMYXlvdXRFZmZlY3RJbXBsID0gQ0FOX1VTRV9ET00gPyByZWFjdC51c2VMYXlvdXRFZmZlY3QgOiByZWFjdC51c2VFZmZlY3Q7XG52YXIgdXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0SW1wbDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gT25DaGFuZ2VQbHVnaW4oe1xuICBpZ25vcmVIaXN0b3J5TWVyZ2VUYWdDaGFuZ2UgPSB0cnVlLFxuICBpZ25vcmVTZWxlY3Rpb25DaGFuZ2UgPSBmYWxzZSxcbiAgb25DaGFuZ2Vcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgIHJldHVybiBlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoe1xuICAgICAgICBlZGl0b3JTdGF0ZSxcbiAgICAgICAgZGlydHlFbGVtZW50cyxcbiAgICAgICAgZGlydHlMZWF2ZXMsXG4gICAgICAgIHByZXZFZGl0b3JTdGF0ZSxcbiAgICAgICAgdGFnc1xuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoaWdub3JlU2VsZWN0aW9uQ2hhbmdlICYmIGRpcnR5RWxlbWVudHMuc2l6ZSA9PT0gMCAmJiBkaXJ0eUxlYXZlcy5zaXplID09PSAwIHx8IGlnbm9yZUhpc3RvcnlNZXJnZVRhZ0NoYW5nZSAmJiB0YWdzLmhhcygnaGlzdG9yeS1tZXJnZScpIHx8IHByZXZFZGl0b3JTdGF0ZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvbkNoYW5nZShlZGl0b3JTdGF0ZSwgZWRpdG9yLCB0YWdzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2VkaXRvciwgaWdub3JlSGlzdG9yeU1lcmdlVGFnQ2hhbmdlLCBpZ25vcmVTZWxlY3Rpb25DaGFuZ2UsIG9uQ2hhbmdlXSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLk9uQ2hhbmdlUGx1Z2luID0gT25DaGFuZ2VQbHVnaW47XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalOnChangePlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalOnChangePlugin.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalOnChangePlugin.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalOnChangePlugin =  true ? __webpack_require__(/*! ./LexicalOnChangePlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalOnChangePlugin.dev.js\") : 0\nmodule.exports = LexicalOnChangePlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE9uQ2hhbmdlUGx1Z2luLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osOEJBQThCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyx3R0FBZ0MsSUFBSSxDQUEwQztBQUM3SiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxPbkNoYW5nZVBsdWdpbi5qcz9kNWQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsT25DaGFuZ2VQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbE9uQ2hhbmdlUGx1Z2luLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsT25DaGFuZ2VQbHVnaW4ucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxPbkNoYW5nZVBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalOnChangePlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar useLexicalEditable = __webpack_require__(/*! @lexical/react/useLexicalEditable */ \"(ssr)/./node_modules/@lexical/react/useLexicalEditable.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar text = __webpack_require__(/*! @lexical/text */ \"(ssr)/./node_modules/@lexical/text/LexicalText.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar reactDom = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar dragon = __webpack_require__(/*! @lexical/dragon */ \"(ssr)/./node_modules/@lexical/dragon/LexicalDragon.js\");\nvar richText = __webpack_require__(/*! @lexical/rich-text */ \"(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read(text.$canShowPlaceholderCurry(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\n\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = React.useState(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffect(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n\n    resetCanShowPlaceholder();\n    return utils.mergeRegister(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useDecorators(editor, ErrorBoundary) {\n  const [decorators, setDecorators] = React.useState(() => editor.getDecorators()); // Subscribe to changes\n\n  useLayoutEffect(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      reactDom.flushSync(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]);\n  React.useEffect(() => {\n    // If the content editable mounts before the subscription is added, then\n    // nothing will be rendered on initial pass. We can get around that by\n    // ensuring that we set the value.\n    setDecorators(editor.getDecorators());\n  }, [editor]); // Return decorators defined as React Portals\n\n  return React.useMemo(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = /*#__PURE__*/React.createElement(ErrorBoundary, {\n        onError: e => editor._onError(e)\n      }, /*#__PURE__*/React.createElement(React.Suspense, {\n        fallback: null\n      }, decorators[nodeKey]));\n      const element = editor.getElementByKey(nodeKey);\n\n      if (element !== null) {\n        decoratedPortals.push( /*#__PURE__*/reactDom.createPortal(reactDecorator, element, nodeKey));\n      }\n    }\n\n    return decoratedPortals;\n  }, [ErrorBoundary, decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useRichTextSetup(editor) {\n  useLayoutEffect(() => {\n    return utils.mergeRegister(richText.registerRichText(editor), dragon.registerDragonSupport(editor)); // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction RichTextPlugin({\n  contentEditable,\n  placeholder,\n  ErrorBoundary\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const decorators = useDecorators(editor, ErrorBoundary);\n  useRichTextSetup(editor);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, contentEditable, /*#__PURE__*/React.createElement(Placeholder, {\n    content: placeholder\n  }), decorators);\n}\n\nfunction Placeholder({\n  content\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const editable = useLexicalEditable();\n\n  if (!showPlaceholder) {\n    return null;\n  }\n\n  if (typeof content === 'function') {\n    return content(editable);\n  } else {\n    return content;\n  }\n}\n\nexports.RichTextPlugin = RichTextPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFJpY2hUZXh0UGx1Z2luLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUseUJBQXlCLG1CQUFPLENBQUMsb0dBQW1DO0FBQ3BFLFlBQVksbUJBQU8sQ0FBQyx3R0FBTztBQUMzQixXQUFXLG1CQUFPLENBQUMsd0VBQWU7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNwQyxlQUFlLG1CQUFPLENBQUMsZ0hBQVc7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDhFQUFpQjtBQUN0QyxlQUFlLG1CQUFPLENBQUMsc0ZBQW9COztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjs7QUFFcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhOztBQUVoQjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFJpY2hUZXh0UGx1Z2luLmRldi5qcz9mZDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciB1c2VMZXhpY2FsRWRpdGFibGUgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsRWRpdGFibGUnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgdGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3RleHQnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG52YXIgcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBkcmFnb24gPSByZXF1aXJlKCdAbGV4aWNhbC9kcmFnb24nKTtcbnZhciByaWNoVGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JpY2gtdGV4dCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IHVzZUxheW91dEVmZmVjdEltcGwgPSBDQU5fVVNFX0RPTSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbnZhciB1c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3RJbXBsO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKSB7XG4gIGNvbnN0IGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXIgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKHRleHQuJGNhblNob3dQbGFjZWhvbGRlckN1cnJ5KGVkaXRvci5pc0NvbXBvc2luZygpKSk7XG4gIHJldHVybiBjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyO1xufVxuXG5mdW5jdGlvbiB1c2VDYW5TaG93UGxhY2Vob2xkZXIoZWRpdG9yKSB7XG4gIGNvbnN0IFtjYW5TaG93UGxhY2Vob2xkZXIsIHNldENhblNob3dQbGFjZWhvbGRlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjYW5TaG93UGxhY2Vob2xkZXJGcm9tQ3VycmVudEVkaXRvclN0YXRlKGVkaXRvcikpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCkge1xuICAgICAgY29uc3QgY3VycmVudENhblNob3dQbGFjZWhvbGRlciA9IGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKTtcbiAgICAgIHNldENhblNob3dQbGFjZWhvbGRlcihjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyKTtcbiAgICB9XG5cbiAgICByZXNldENhblNob3dQbGFjZWhvbGRlcigpO1xuICAgIHJldHVybiB1dGlscy5tZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCk7XG4gICAgfSksIGVkaXRvci5yZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgcmVzZXRDYW5TaG93UGxhY2Vob2xkZXIoKTtcbiAgICB9KSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgcmV0dXJuIGNhblNob3dQbGFjZWhvbGRlcjtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlRGVjb3JhdG9ycyhlZGl0b3IsIEVycm9yQm91bmRhcnkpIHtcbiAgY29uc3QgW2RlY29yYXRvcnMsIHNldERlY29yYXRvcnNdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gZWRpdG9yLmdldERlY29yYXRvcnMoKSk7IC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzXG5cbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyRGVjb3JhdG9yTGlzdGVuZXIobmV4dERlY29yYXRvcnMgPT4ge1xuICAgICAgcmVhY3REb20uZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgc2V0RGVjb3JhdG9ycyhuZXh0RGVjb3JhdG9ycyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgW2VkaXRvcl0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElmIHRoZSBjb250ZW50IGVkaXRhYmxlIG1vdW50cyBiZWZvcmUgdGhlIHN1YnNjcmlwdGlvbiBpcyBhZGRlZCwgdGhlblxuICAgIC8vIG5vdGhpbmcgd2lsbCBiZSByZW5kZXJlZCBvbiBpbml0aWFsIHBhc3MuIFdlIGNhbiBnZXQgYXJvdW5kIHRoYXQgYnlcbiAgICAvLyBlbnN1cmluZyB0aGF0IHdlIHNldCB0aGUgdmFsdWUuXG4gICAgc2V0RGVjb3JhdG9ycyhlZGl0b3IuZ2V0RGVjb3JhdG9ycygpKTtcbiAgfSwgW2VkaXRvcl0pOyAvLyBSZXR1cm4gZGVjb3JhdG9ycyBkZWZpbmVkIGFzIFJlYWN0IFBvcnRhbHNcblxuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgZGVjb3JhdGVkUG9ydGFscyA9IFtdO1xuICAgIGNvbnN0IGRlY29yYXRvcktleXMgPSBPYmplY3Qua2V5cyhkZWNvcmF0b3JzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb3JhdG9yS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZUtleSA9IGRlY29yYXRvcktleXNbaV07XG4gICAgICBjb25zdCByZWFjdERlY29yYXRvciA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIHtcbiAgICAgICAgb25FcnJvcjogZSA9PiBlZGl0b3IuX29uRXJyb3IoZSlcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LlN1c3BlbnNlLCB7XG4gICAgICAgIGZhbGxiYWNrOiBudWxsXG4gICAgICB9LCBkZWNvcmF0b3JzW25vZGVLZXldKSk7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShub2RlS2V5KTtcblxuICAgICAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgZGVjb3JhdGVkUG9ydGFscy5wdXNoKCAvKiNfX1BVUkVfXyovcmVhY3REb20uY3JlYXRlUG9ydGFsKHJlYWN0RGVjb3JhdG9yLCBlbGVtZW50LCBub2RlS2V5KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY29yYXRlZFBvcnRhbHM7XG4gIH0sIFtFcnJvckJvdW5kYXJ5LCBkZWNvcmF0b3JzLCBlZGl0b3JdKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlUmljaFRleHRTZXR1cChlZGl0b3IpIHtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gdXRpbHMubWVyZ2VSZWdpc3RlcihyaWNoVGV4dC5yZWdpc3RlclJpY2hUZXh0KGVkaXRvciksIGRyYWdvbi5yZWdpc3RlckRyYWdvblN1cHBvcnQoZWRpdG9yKSk7IC8vIFdlIG9ubHkgZG8gdGhpcyBmb3IgaW5pdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2VkaXRvcl0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBSaWNoVGV4dFBsdWdpbih7XG4gIGNvbnRlbnRFZGl0YWJsZSxcbiAgcGxhY2Vob2xkZXIsXG4gIEVycm9yQm91bmRhcnlcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgZGVjb3JhdG9ycyA9IHVzZURlY29yYXRvcnMoZWRpdG9yLCBFcnJvckJvdW5kYXJ5KTtcbiAgdXNlUmljaFRleHRTZXR1cChlZGl0b3IpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNvbnRlbnRFZGl0YWJsZSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUGxhY2Vob2xkZXIsIHtcbiAgICBjb250ZW50OiBwbGFjZWhvbGRlclxuICB9KSwgZGVjb3JhdG9ycyk7XG59XG5cbmZ1bmN0aW9uIFBsYWNlaG9sZGVyKHtcbiAgY29udGVudFxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICBjb25zdCBzaG93UGxhY2Vob2xkZXIgPSB1c2VDYW5TaG93UGxhY2Vob2xkZXIoZWRpdG9yKTtcbiAgY29uc3QgZWRpdGFibGUgPSB1c2VMZXhpY2FsRWRpdGFibGUoKTtcblxuICBpZiAoIXNob3dQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQoZWRpdGFibGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG59XG5cbmV4cG9ydHMuUmljaFRleHRQbHVnaW4gPSBSaWNoVGV4dFBsdWdpbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalRichTextPlugin.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalRichTextPlugin.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalRichTextPlugin =  true ? __webpack_require__(/*! ./LexicalRichTextPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js\") : 0\nmodule.exports = LexicalRichTextPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFJpY2hUZXh0UGx1Z2luLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osOEJBQThCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyx3R0FBZ0MsSUFBSSxDQUEwQztBQUM3SiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxSaWNoVGV4dFBsdWdpbi5qcz9mYTkxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsUmljaFRleHRQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFJpY2hUZXh0UGx1Z2luLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsUmljaFRleHRQbHVnaW4ucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxSaWNoVGV4dFBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalRichTextPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalTreeView.dev.js":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTreeView.dev.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar html = __webpack_require__(/*! @lexical/html */ \"(ssr)/./node_modules/@lexical/html/LexicalHtml.js\");\nvar link = __webpack_require__(/*! @lexical/link */ \"(ssr)/./node_modules/@lexical/link/LexicalLink.js\");\nvar mark = __webpack_require__(/*! @lexical/mark */ \"(ssr)/./node_modules/@lexical/mark/LexicalMark.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({\n  '\\t': '\\\\t',\n  '\\n': '\\\\n'\n});\nconst NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join('|'), 'g');\nconst SYMBOLS = Object.freeze({\n  ancestorHasNextSibling: '|',\n  ancestorIsLastChild: ' ',\n  hasNextSibling: '',\n  isLastChild: '',\n  selectedChar: '^',\n  selectedLine: '>'\n});\nfunction TreeView({\n  treeTypeButtonClassName,\n  timeTravelButtonClassName,\n  timeTravelPanelSliderClassName,\n  timeTravelPanelButtonClassName,\n  viewClassName,\n  timeTravelPanelClassName,\n  editor\n}) {\n  const [timeStampedEditorStates, setTimeStampedEditorStates] = React.useState([]);\n  const [content, setContent] = React.useState('');\n  const [timeTravelEnabled, setTimeTravelEnabled] = React.useState(false);\n  const [showExportDOM, setShowExportDOM] = React.useState(false);\n  const playingIndexRef = React.useRef(0);\n  const treeElementRef = React.useRef(null);\n  const inputRef = React.useRef(null);\n  const [isPlaying, setIsPlaying] = React.useState(false);\n  const [isLimited, setIsLimited] = React.useState(false);\n  const [showLimited, setShowLimited] = React.useState(false);\n  const lastEditorStateRef = React.useRef(null);\n  const commandsLog = useLexicalCommandsLog(editor);\n  const generateTree = React.useCallback(editorState => {\n    const treeText = generateContent(editor, commandsLog, showExportDOM);\n    setContent(treeText);\n\n    if (!timeTravelEnabled) {\n      setTimeStampedEditorStates(currentEditorStates => [...currentEditorStates, [Date.now(), editorState]]);\n    }\n  }, [commandsLog, editor, timeTravelEnabled, showExportDOM]);\n  React.useEffect(() => {\n    const editorState = editor.getEditorState();\n\n    if (!showLimited && editorState._nodeMap.size < 1000) {\n      setContent(generateContent(editor, commandsLog, showExportDOM));\n    }\n  }, [commandsLog, editor, showLimited, showExportDOM]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerUpdateListener(({\n      editorState\n    }) => {\n      if (!showLimited && editorState._nodeMap.size > 1000) {\n        lastEditorStateRef.current = editorState;\n        setIsLimited(true);\n\n        if (!showLimited) {\n          return;\n        }\n      }\n\n      generateTree(editorState);\n    }), editor.registerEditableListener(() => {\n      const treeText = generateContent(editor, commandsLog, showExportDOM);\n      setContent(treeText);\n    }));\n  }, [commandsLog, editor, showExportDOM, isLimited, generateTree, showLimited]);\n  const totalEditorStates = timeStampedEditorStates.length;\n  React.useEffect(() => {\n    if (isPlaying) {\n      let timeoutId;\n\n      const play = () => {\n        const currentIndex = playingIndexRef.current;\n\n        if (currentIndex === totalEditorStates - 1) {\n          setIsPlaying(false);\n          return;\n        }\n\n        const currentTime = timeStampedEditorStates[currentIndex][0];\n        const nextTime = timeStampedEditorStates[currentIndex + 1][0];\n        const timeDiff = nextTime - currentTime;\n        timeoutId = setTimeout(() => {\n          playingIndexRef.current++;\n          const index = playingIndexRef.current;\n          const input = inputRef.current;\n\n          if (input !== null) {\n            input.value = String(index);\n          }\n\n          editor.setEditorState(timeStampedEditorStates[index][1]);\n          play();\n        }, timeDiff);\n      };\n\n      play();\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    }\n  }, [timeStampedEditorStates, isPlaying, editor, totalEditorStates]);\n  React.useEffect(() => {\n    const element = treeElementRef.current;\n\n    if (element !== null) {\n      // @ts-ignore Internal field\n      element.__lexicalEditor = editor;\n      return () => {\n        // @ts-ignore Internal field\n        element.__lexicalEditor = null;\n      };\n    }\n  }, [editor]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: viewClassName\n  }, !showLimited && isLimited ? /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      padding: 20\n    }\n  }, /*#__PURE__*/React.createElement(\"span\", {\n    style: {\n      marginRight: 20\n    }\n  }, \"Detected large EditorState, this can impact debugging performance.\"), /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => {\n      setShowLimited(true);\n      const editorState = lastEditorStateRef.current;\n\n      if (editorState !== null) {\n        lastEditorStateRef.current = null;\n        generateTree(editorState);\n      }\n    },\n    style: {\n      background: 'transparent',\n      border: '1px solid white',\n      color: 'white',\n      cursor: 'pointer',\n      padding: 5\n    }\n  }, \"Show full tree\")) : null, !showLimited ? /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => setShowExportDOM(!showExportDOM),\n    className: treeTypeButtonClassName,\n    type: \"button\"\n  }, showExportDOM ? 'Tree' : 'Export DOM') : null, !timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2 && /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => {\n      const rootElement = editor.getRootElement();\n\n      if (rootElement !== null) {\n        rootElement.contentEditable = 'false';\n        playingIndexRef.current = totalEditorStates - 1;\n        setTimeTravelEnabled(true);\n      }\n    },\n    className: timeTravelButtonClassName,\n    type: \"button\"\n  }, \"Time Travel\"), (showLimited || !isLimited) && /*#__PURE__*/React.createElement(\"pre\", {\n    ref: treeElementRef\n  }, content), timeTravelEnabled && (showLimited || !isLimited) && /*#__PURE__*/React.createElement(\"div\", {\n    className: timeTravelPanelClassName\n  }, /*#__PURE__*/React.createElement(\"button\", {\n    className: timeTravelPanelButtonClassName,\n    onClick: () => {\n      if (playingIndexRef.current === totalEditorStates - 1) {\n        playingIndexRef.current = 1;\n      }\n\n      setIsPlaying(!isPlaying);\n    },\n    type: \"button\"\n  }, isPlaying ? 'Pause' : 'Play'), /*#__PURE__*/React.createElement(\"input\", {\n    className: timeTravelPanelSliderClassName,\n    ref: inputRef,\n    onChange: event => {\n      const editorStateIndex = Number(event.target.value);\n      const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];\n\n      if (timeStampedEditorState) {\n        playingIndexRef.current = editorStateIndex;\n        editor.setEditorState(timeStampedEditorState[1]);\n      }\n    },\n    type: \"range\",\n    min: \"1\",\n    max: totalEditorStates - 1\n  }), /*#__PURE__*/React.createElement(\"button\", {\n    className: timeTravelPanelButtonClassName,\n    onClick: () => {\n      const rootElement = editor.getRootElement();\n\n      if (rootElement !== null) {\n        rootElement.contentEditable = 'true';\n        const index = timeStampedEditorStates.length - 1;\n        const timeStampedEditorState = timeStampedEditorStates[index];\n        editor.setEditorState(timeStampedEditorState[1]);\n        const input = inputRef.current;\n\n        if (input !== null) {\n          input.value = String(index);\n        }\n\n        setTimeTravelEnabled(false);\n        setIsPlaying(false);\n      }\n    },\n    type: \"button\"\n  }, \"Exit\")));\n}\n\nfunction useLexicalCommandsLog(editor) {\n  const [loggedCommands, setLoggedCommands] = React.useState([]);\n  React.useEffect(() => {\n    const unregisterCommandListeners = new Set();\n\n    for (const [command] of editor._commands) {\n      unregisterCommandListeners.add(editor.registerCommand(command, payload => {\n        setLoggedCommands(state => {\n          const newState = [...state];\n          newState.push({\n            payload,\n            type: command.type ? command.type : 'UNKNOWN'\n          });\n\n          if (newState.length > 10) {\n            newState.shift();\n          }\n\n          return newState;\n        });\n        return false;\n      }, lexical.COMMAND_PRIORITY_HIGH));\n    }\n\n    return () => unregisterCommandListeners.forEach(unregister => unregister());\n  }, [editor]);\n  return React.useMemo(() => loggedCommands, [loggedCommands]);\n}\n\nfunction printRangeSelection(selection) {\n  let res = '';\n  const formatText = printFormatProperties(selection);\n  res += `: range ${formatText !== '' ? `{ ${formatText} }` : ''} ${selection.style !== '' ? `{ style: ${selection.style} } ` : ''}`;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  res += `\\n   anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? 'null' : anchorOffset}, type: ${anchor.type} }`;\n  res += `\\n   focus { key: ${focus.key}, offset: ${focusOffset === null ? 'null' : focusOffset}, type: ${focus.type} }`;\n  return res;\n}\n\nfunction printNodeSelection(selection) {\n  return `: node\\n   [${Array.from(selection._nodes).join(', ')}]`;\n}\n\nfunction printGridSelection(selection) {\n  return `: grid\\n   { grid: ${selection.gridKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;\n}\n\nfunction generateContent(editor, commandsLog, exportDOM) {\n  const editorState = editor.getEditorState();\n  const editorConfig = editor._config;\n  const compositionKey = editor._compositionKey;\n  const editable = editor._editable;\n\n  if (exportDOM) {\n    let htmlString = '';\n    editorState.read(() => {\n      htmlString = printPrettyHTML(html.$generateHtmlFromNodes(editor));\n    });\n    return htmlString;\n  }\n\n  let res = ' root\\n';\n  const selectionString = editorState.read(() => {\n    const selection = lexical.$getSelection();\n    visitTree(lexical.$getRoot(), (node, indent) => {\n      const nodeKey = node.getKey();\n      const nodeKeyDisplay = `(${nodeKey})`;\n      const typeDisplay = node.getType() || '';\n      const isSelected = node.isSelected();\n      const idsDisplay = mark.$isMarkNode(node) ? ` id: [ ${node.getIDs().join(', ')} ] ` : '';\n      res += `${isSelected ? SYMBOLS.selectedLine : ' '} ${indent.join(' ')} ${nodeKeyDisplay} ${typeDisplay} ${idsDisplay} ${printNode(node)}\\n`;\n      res += printSelectedCharsLine({\n        indent,\n        isSelected,\n        node,\n        nodeKeyDisplay,\n        selection,\n        typeDisplay\n      });\n    });\n    return selection === null ? ': null' : lexical.$isRangeSelection(selection) ? printRangeSelection(selection) : lexical.DEPRECATED_$isGridSelection(selection) ? printGridSelection(selection) : printNodeSelection(selection);\n  });\n  res += '\\n selection' + selectionString;\n  res += '\\n\\n commands:';\n\n  if (commandsLog.length) {\n    for (const {\n      type,\n      payload\n    } of commandsLog) {\n      res += `\\n   { type: ${type}, payload: ${payload instanceof Event ? payload.constructor.name : payload} }`;\n    }\n  } else {\n    res += '\\n   None dispatched.';\n  }\n\n  res += '\\n\\n editor:';\n  res += `\\n   namespace ${editorConfig.namespace}`;\n\n  if (compositionKey !== null) {\n    res += `\\n   compositionKey ${compositionKey}`;\n  }\n\n  res += `\\n   editable ${String(editable)}`;\n  return res;\n}\n\nfunction visitTree(currentNode, visitor, indent = []) {\n  const childNodes = currentNode.getChildren();\n  const childNodesLength = childNodes.length;\n  childNodes.forEach((childNode, i) => {\n    visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));\n\n    if (lexical.$isElementNode(childNode)) {\n      visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));\n    }\n  });\n}\n\nfunction normalize(text) {\n  return Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, [key, value]) => acc.replace(new RegExp(key, 'g'), String(value)), text);\n} // TODO Pass via props to allow customizability\n\n\nfunction printNode(node) {\n  if (lexical.$isTextNode(node)) {\n    const text = node.getTextContent();\n    const title = text.length === 0 ? '(empty)' : `\"${normalize(text)}\"`;\n    const properties = printAllTextNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if (link.$isLinkNode(node)) {\n    const link = node.getURL();\n    const title = link.length === 0 ? '(empty)' : `\"${normalize(link)}\"`;\n    const properties = printAllLinkNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else {\n    return '';\n  }\n}\n\nconst FORMAT_PREDICATES = [node => node.hasFormat('bold') && 'Bold', node => node.hasFormat('code') && 'Code', node => node.hasFormat('italic') && 'Italic', node => node.hasFormat('strikethrough') && 'Strikethrough', node => node.hasFormat('subscript') && 'Subscript', node => node.hasFormat('superscript') && 'Superscript', node => node.hasFormat('underline') && 'Underline'];\nconst DETAIL_PREDICATES = [node => node.isDirectionless() && 'Directionless', node => node.isUnmergeable() && 'Unmergeable'];\nconst MODE_PREDICATES = [node => node.isToken() && 'Token', node => node.isSegmented() && 'Segmented'];\n\nfunction printAllTextNodeProperties(node) {\n  return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node)].filter(Boolean).join(', ');\n}\n\nfunction printAllLinkNodeProperties(node) {\n  return [printTargetProperties(node), printRelProperties(node), printTitleProperties(node)].filter(Boolean).join(', ');\n}\n\nfunction printDetailProperties(nodeOrSelection) {\n  let str = DETAIL_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n\n  if (str !== '') {\n    str = 'detail: ' + str;\n  }\n\n  return str;\n}\n\nfunction printModeProperties(nodeOrSelection) {\n  let str = MODE_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n\n  if (str !== '') {\n    str = 'mode: ' + str;\n  }\n\n  return str;\n}\n\nfunction printFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n\n  return str;\n}\n\nfunction printTargetProperties(node) {\n  let str = node.getTarget(); // TODO Fix nullish on LinkNode\n\n  if (str != null) {\n    str = 'target: ' + str;\n  }\n\n  return str;\n}\n\nfunction printRelProperties(node) {\n  let str = node.getRel(); // TODO Fix nullish on LinkNode\n\n  if (str != null) {\n    str = 'rel: ' + str;\n  }\n\n  return str;\n}\n\nfunction printTitleProperties(node) {\n  let str = node.getTitle(); // TODO Fix nullish on LinkNode\n\n  if (str != null) {\n    str = 'title: ' + str;\n  }\n\n  return str;\n}\n\nfunction printSelectedCharsLine({\n  indent,\n  isSelected,\n  node,\n  nodeKeyDisplay,\n  selection,\n  typeDisplay\n}) {\n  // No selection or node is not selected.\n  if (!lexical.$isTextNode(node) || !lexical.$isRangeSelection(selection) || !isSelected || lexical.$isElementNode(node)) {\n    return '';\n  } // No selected characters.\n\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n\n  if (node.getTextContent() === '' || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {\n    return '';\n  }\n\n  const [start, end] = $getSelectionStartEnd(node, selection);\n\n  if (start === end) {\n    return '';\n  }\n\n  const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;\n  const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];\n  const unselectedChars = Array(start + 1).fill(' ');\n  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);\n  const paddingLength = typeDisplay.length + 3; // 2 for the spaces around + 1 for the double quote.\n\n  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(' ');\n  return [SYMBOLS.selectedLine, indentionChars.join(' '), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join('')].join(' ') + '\\n';\n}\n\nfunction printPrettyHTML(str) {\n  const div = document.createElement('div');\n  div.innerHTML = str.trim();\n  return prettifyHTML(div, 0).innerHTML;\n}\n\nfunction prettifyHTML(node, level) {\n  const indentBefore = new Array(level++ + 1).join('  ');\n  const indentAfter = new Array(level - 1).join('  ');\n  let textNode;\n\n  for (let i = 0; i < node.children.length; i++) {\n    textNode = document.createTextNode('\\n' + indentBefore);\n    node.insertBefore(textNode, node.children[i]);\n    prettifyHTML(node.children[i], level);\n\n    if (node.lastElementChild === node.children[i]) {\n      textNode = document.createTextNode('\\n' + indentAfter);\n      node.appendChild(textNode);\n    }\n  }\n\n  return node;\n}\n\nfunction $getSelectionStartEnd(node, selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const textContent = node.getTextContent();\n  const textLength = textContent.length;\n  let start = -1;\n  let end = -1; // Only one node is being selected.\n\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n\n    if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {\n      [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];\n    } else if (node === anchorNode) {\n      [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];\n    } else if (node === focusNode) {\n      [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];\n    } else {\n      // Node is within selection but not the anchor nor focus.\n      [start, end] = [0, textLength];\n    }\n  } // Account for non-single width characters.\n\n\n  const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];\n}\n\nexports.TreeView = TreeView;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFRyZWVWaWV3LmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsd0VBQWU7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLHdFQUFlO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyx3RUFBZTtBQUNsQyxZQUFZLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyx3REFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QixFQUFFLGFBQWEsUUFBUSxFQUFFLDRCQUE0QixTQUFTLG1CQUFtQixPQUFPO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sV0FBVyxZQUFZLDhDQUE4QyxVQUFVLGNBQWM7QUFDN0gsd0JBQXdCLE9BQU8sVUFBVSxZQUFZLDRDQUE0QyxVQUFVLGFBQWE7QUFDeEg7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qix3Q0FBd0M7QUFDakU7O0FBRUE7QUFDQSx3QkFBd0IsUUFBUSxrQkFBa0IsZ0JBQWdCLHFCQUFxQixlQUFlLHNCQUFzQjtBQUM1SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQSw0REFBNEQsMEJBQTBCO0FBQ3RGLGdCQUFnQix5Q0FBeUMsRUFBRSxrQkFBa0IsRUFBRSxnQkFBZ0IsRUFBRSxhQUFhLEVBQUUsWUFBWSxFQUFFLGdCQUFnQjtBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzQkFBc0IsUUFBUSxLQUFLLGFBQWEsZ0VBQWdFO0FBQ2hIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsdUJBQXVCOztBQUVuRDtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEOztBQUVBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdCQUFnQjtBQUN0RTtBQUNBLGdEQUFnRCxFQUFFLGFBQWE7QUFDL0QsSUFBSTtBQUNKO0FBQ0Esc0RBQXNELGdCQUFnQjtBQUN0RTtBQUNBLGdEQUFnRCxFQUFFLGFBQWE7QUFDL0QsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxUcmVlVmlldy5kZXYuanM/ZDBjYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGh0bWwgPSByZXF1aXJlKCdAbGV4aWNhbC9odG1sJyk7XG52YXIgbGluayA9IHJlcXVpcmUoJ0BsZXhpY2FsL2xpbmsnKTtcbnZhciBtYXJrID0gcmVxdWlyZSgnQGxleGljYWwvbWFyaycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQGxleGljYWwvdXRpbHMnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgTk9OX1NJTkdMRV9XSURUSF9DSEFSU19SRVBMQUNFTUVOVCA9IE9iamVjdC5mcmVlemUoe1xuICAnXFx0JzogJ1xcXFx0JyxcbiAgJ1xcbic6ICdcXFxcbidcbn0pO1xuY29uc3QgTk9OX1NJTkdMRV9XSURUSF9DSEFSU19SRUdFWCA9IG5ldyBSZWdFeHAoT2JqZWN0LmtleXMoTk9OX1NJTkdMRV9XSURUSF9DSEFSU19SRVBMQUNFTUVOVCkuam9pbignfCcpLCAnZycpO1xuY29uc3QgU1lNQk9MUyA9IE9iamVjdC5mcmVlemUoe1xuICBhbmNlc3Rvckhhc05leHRTaWJsaW5nOiAnfCcsXG4gIGFuY2VzdG9ySXNMYXN0Q2hpbGQ6ICcgJyxcbiAgaGFzTmV4dFNpYmxpbmc6ICfilJwnLFxuICBpc0xhc3RDaGlsZDogJ+KUlCcsXG4gIHNlbGVjdGVkQ2hhcjogJ14nLFxuICBzZWxlY3RlZExpbmU6ICc+J1xufSk7XG5mdW5jdGlvbiBUcmVlVmlldyh7XG4gIHRyZWVUeXBlQnV0dG9uQ2xhc3NOYW1lLFxuICB0aW1lVHJhdmVsQnV0dG9uQ2xhc3NOYW1lLFxuICB0aW1lVHJhdmVsUGFuZWxTbGlkZXJDbGFzc05hbWUsXG4gIHRpbWVUcmF2ZWxQYW5lbEJ1dHRvbkNsYXNzTmFtZSxcbiAgdmlld0NsYXNzTmFtZSxcbiAgdGltZVRyYXZlbFBhbmVsQ2xhc3NOYW1lLFxuICBlZGl0b3Jcbn0pIHtcbiAgY29uc3QgW3RpbWVTdGFtcGVkRWRpdG9yU3RhdGVzLCBzZXRUaW1lU3RhbXBlZEVkaXRvclN0YXRlc10gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtjb250ZW50LCBzZXRDb250ZW50XSA9IFJlYWN0LnVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3RpbWVUcmF2ZWxFbmFibGVkLCBzZXRUaW1lVHJhdmVsRW5hYmxlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93RXhwb3J0RE9NLCBzZXRTaG93RXhwb3J0RE9NXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgcGxheWluZ0luZGV4UmVmID0gUmVhY3QudXNlUmVmKDApO1xuICBjb25zdCB0cmVlRWxlbWVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaW5wdXRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtpc1BsYXlpbmcsIHNldElzUGxheWluZ10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0xpbWl0ZWQsIHNldElzTGltaXRlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93TGltaXRlZCwgc2V0U2hvd0xpbWl0ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBsYXN0RWRpdG9yU3RhdGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGNvbW1hbmRzTG9nID0gdXNlTGV4aWNhbENvbW1hbmRzTG9nKGVkaXRvcik7XG4gIGNvbnN0IGdlbmVyYXRlVHJlZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGVkaXRvclN0YXRlID0+IHtcbiAgICBjb25zdCB0cmVlVGV4dCA9IGdlbmVyYXRlQ29udGVudChlZGl0b3IsIGNvbW1hbmRzTG9nLCBzaG93RXhwb3J0RE9NKTtcbiAgICBzZXRDb250ZW50KHRyZWVUZXh0KTtcblxuICAgIGlmICghdGltZVRyYXZlbEVuYWJsZWQpIHtcbiAgICAgIHNldFRpbWVTdGFtcGVkRWRpdG9yU3RhdGVzKGN1cnJlbnRFZGl0b3JTdGF0ZXMgPT4gWy4uLmN1cnJlbnRFZGl0b3JTdGF0ZXMsIFtEYXRlLm5vdygpLCBlZGl0b3JTdGF0ZV1dKTtcbiAgICB9XG4gIH0sIFtjb21tYW5kc0xvZywgZWRpdG9yLCB0aW1lVHJhdmVsRW5hYmxlZCwgc2hvd0V4cG9ydERPTV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGVkaXRvclN0YXRlID0gZWRpdG9yLmdldEVkaXRvclN0YXRlKCk7XG5cbiAgICBpZiAoIXNob3dMaW1pdGVkICYmIGVkaXRvclN0YXRlLl9ub2RlTWFwLnNpemUgPCAxMDAwKSB7XG4gICAgICBzZXRDb250ZW50KGdlbmVyYXRlQ29udGVudChlZGl0b3IsIGNvbW1hbmRzTG9nLCBzaG93RXhwb3J0RE9NKSk7XG4gICAgfVxuICB9LCBbY29tbWFuZHNMb2csIGVkaXRvciwgc2hvd0xpbWl0ZWQsIHNob3dFeHBvcnRET01dKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gdXRpbHMubWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoe1xuICAgICAgZWRpdG9yU3RhdGVcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoIXNob3dMaW1pdGVkICYmIGVkaXRvclN0YXRlLl9ub2RlTWFwLnNpemUgPiAxMDAwKSB7XG4gICAgICAgIGxhc3RFZGl0b3JTdGF0ZVJlZi5jdXJyZW50ID0gZWRpdG9yU3RhdGU7XG4gICAgICAgIHNldElzTGltaXRlZCh0cnVlKTtcblxuICAgICAgICBpZiAoIXNob3dMaW1pdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRlVHJlZShlZGl0b3JTdGF0ZSk7XG4gICAgfSksIGVkaXRvci5yZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgY29uc3QgdHJlZVRleHQgPSBnZW5lcmF0ZUNvbnRlbnQoZWRpdG9yLCBjb21tYW5kc0xvZywgc2hvd0V4cG9ydERPTSk7XG4gICAgICBzZXRDb250ZW50KHRyZWVUZXh0KTtcbiAgICB9KSk7XG4gIH0sIFtjb21tYW5kc0xvZywgZWRpdG9yLCBzaG93RXhwb3J0RE9NLCBpc0xpbWl0ZWQsIGdlbmVyYXRlVHJlZSwgc2hvd0xpbWl0ZWRdKTtcbiAgY29uc3QgdG90YWxFZGl0b3JTdGF0ZXMgPSB0aW1lU3RhbXBlZEVkaXRvclN0YXRlcy5sZW5ndGg7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzUGxheWluZykge1xuICAgICAgbGV0IHRpbWVvdXRJZDtcblxuICAgICAgY29uc3QgcGxheSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gcGxheWluZ0luZGV4UmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gdG90YWxFZGl0b3JTdGF0ZXMgLSAxKSB7XG4gICAgICAgICAgc2V0SXNQbGF5aW5nKGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IHRpbWVTdGFtcGVkRWRpdG9yU3RhdGVzW2N1cnJlbnRJbmRleF1bMF07XG4gICAgICAgIGNvbnN0IG5leHRUaW1lID0gdGltZVN0YW1wZWRFZGl0b3JTdGF0ZXNbY3VycmVudEluZGV4ICsgMV1bMF07XG4gICAgICAgIGNvbnN0IHRpbWVEaWZmID0gbmV4dFRpbWUgLSBjdXJyZW50VGltZTtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcGxheWluZ0luZGV4UmVmLmN1cnJlbnQrKztcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHBsYXlpbmdJbmRleFJlZi5jdXJyZW50O1xuICAgICAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRSZWYuY3VycmVudDtcblxuICAgICAgICAgIGlmIChpbnB1dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBTdHJpbmcoaW5kZXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVkaXRvci5zZXRFZGl0b3JTdGF0ZSh0aW1lU3RhbXBlZEVkaXRvclN0YXRlc1tpbmRleF1bMV0pO1xuICAgICAgICAgIHBsYXkoKTtcbiAgICAgICAgfSwgdGltZURpZmYpO1xuICAgICAgfTtcblxuICAgICAgcGxheSgpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3RpbWVTdGFtcGVkRWRpdG9yU3RhdGVzLCBpc1BsYXlpbmcsIGVkaXRvciwgdG90YWxFZGl0b3JTdGF0ZXNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gdHJlZUVsZW1lbnRSZWYuY3VycmVudDtcblxuICAgIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBAdHMtaWdub3JlIEludGVybmFsIGZpZWxkXG4gICAgICBlbGVtZW50Ll9fbGV4aWNhbEVkaXRvciA9IGVkaXRvcjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgSW50ZXJuYWwgZmllbGRcbiAgICAgICAgZWxlbWVudC5fX2xleGljYWxFZGl0b3IgPSBudWxsO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtlZGl0b3JdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IHZpZXdDbGFzc05hbWVcbiAgfSwgIXNob3dMaW1pdGVkICYmIGlzTGltaXRlZCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgcGFkZGluZzogMjBcbiAgICB9XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIG1hcmdpblJpZ2h0OiAyMFxuICAgIH1cbiAgfSwgXCJEZXRlY3RlZCBsYXJnZSBFZGl0b3JTdGF0ZSwgdGhpcyBjYW4gaW1wYWN0IGRlYnVnZ2luZyBwZXJmb3JtYW5jZS5cIiksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICBzZXRTaG93TGltaXRlZCh0cnVlKTtcbiAgICAgIGNvbnN0IGVkaXRvclN0YXRlID0gbGFzdEVkaXRvclN0YXRlUmVmLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChlZGl0b3JTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBsYXN0RWRpdG9yU3RhdGVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGdlbmVyYXRlVHJlZShlZGl0b3JTdGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgYmFja2dyb3VuZDogJ3RyYW5zcGFyZW50JyxcbiAgICAgIGJvcmRlcjogJzFweCBzb2xpZCB3aGl0ZScsXG4gICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgcGFkZGluZzogNVxuICAgIH1cbiAgfSwgXCJTaG93IGZ1bGwgdHJlZVwiKSkgOiBudWxsLCAhc2hvd0xpbWl0ZWQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAgb25DbGljazogKCkgPT4gc2V0U2hvd0V4cG9ydERPTSghc2hvd0V4cG9ydERPTSksXG4gICAgY2xhc3NOYW1lOiB0cmVlVHlwZUJ1dHRvbkNsYXNzTmFtZSxcbiAgICB0eXBlOiBcImJ1dHRvblwiXG4gIH0sIHNob3dFeHBvcnRET00gPyAnVHJlZScgOiAnRXhwb3J0IERPTScpIDogbnVsbCwgIXRpbWVUcmF2ZWxFbmFibGVkICYmIChzaG93TGltaXRlZCB8fCAhaXNMaW1pdGVkKSAmJiB0b3RhbEVkaXRvclN0YXRlcyA+IDIgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG5cbiAgICAgIGlmIChyb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICByb290RWxlbWVudC5jb250ZW50RWRpdGFibGUgPSAnZmFsc2UnO1xuICAgICAgICBwbGF5aW5nSW5kZXhSZWYuY3VycmVudCA9IHRvdGFsRWRpdG9yU3RhdGVzIC0gMTtcbiAgICAgICAgc2V0VGltZVRyYXZlbEVuYWJsZWQodHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGFzc05hbWU6IHRpbWVUcmF2ZWxCdXR0b25DbGFzc05hbWUsXG4gICAgdHlwZTogXCJidXR0b25cIlxuICB9LCBcIlRpbWUgVHJhdmVsXCIpLCAoc2hvd0xpbWl0ZWQgfHwgIWlzTGltaXRlZCkgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwge1xuICAgIHJlZjogdHJlZUVsZW1lbnRSZWZcbiAgfSwgY29udGVudCksIHRpbWVUcmF2ZWxFbmFibGVkICYmIChzaG93TGltaXRlZCB8fCAhaXNMaW1pdGVkKSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiB0aW1lVHJhdmVsUGFuZWxDbGFzc05hbWVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIGNsYXNzTmFtZTogdGltZVRyYXZlbFBhbmVsQnV0dG9uQ2xhc3NOYW1lLFxuICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgIGlmIChwbGF5aW5nSW5kZXhSZWYuY3VycmVudCA9PT0gdG90YWxFZGl0b3JTdGF0ZXMgLSAxKSB7XG4gICAgICAgIHBsYXlpbmdJbmRleFJlZi5jdXJyZW50ID0gMTtcbiAgICAgIH1cblxuICAgICAgc2V0SXNQbGF5aW5nKCFpc1BsYXlpbmcpO1xuICAgIH0sXG4gICAgdHlwZTogXCJidXR0b25cIlxuICB9LCBpc1BsYXlpbmcgPyAnUGF1c2UnIDogJ1BsYXknKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7XG4gICAgY2xhc3NOYW1lOiB0aW1lVHJhdmVsUGFuZWxTbGlkZXJDbGFzc05hbWUsXG4gICAgcmVmOiBpbnB1dFJlZixcbiAgICBvbkNoYW5nZTogZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZWRpdG9yU3RhdGVJbmRleCA9IE51bWJlcihldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgY29uc3QgdGltZVN0YW1wZWRFZGl0b3JTdGF0ZSA9IHRpbWVTdGFtcGVkRWRpdG9yU3RhdGVzW2VkaXRvclN0YXRlSW5kZXhdO1xuXG4gICAgICBpZiAodGltZVN0YW1wZWRFZGl0b3JTdGF0ZSkge1xuICAgICAgICBwbGF5aW5nSW5kZXhSZWYuY3VycmVudCA9IGVkaXRvclN0YXRlSW5kZXg7XG4gICAgICAgIGVkaXRvci5zZXRFZGl0b3JTdGF0ZSh0aW1lU3RhbXBlZEVkaXRvclN0YXRlWzFdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICBtaW46IFwiMVwiLFxuICAgIG1heDogdG90YWxFZGl0b3JTdGF0ZXMgLSAxXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAgY2xhc3NOYW1lOiB0aW1lVHJhdmVsUGFuZWxCdXR0b25DbGFzc05hbWUsXG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcblxuICAgICAgaWYgKHJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJvb3RFbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9ICd0cnVlJztcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aW1lU3RhbXBlZEVkaXRvclN0YXRlcy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCB0aW1lU3RhbXBlZEVkaXRvclN0YXRlID0gdGltZVN0YW1wZWRFZGl0b3JTdGF0ZXNbaW5kZXhdO1xuICAgICAgICBlZGl0b3Iuc2V0RWRpdG9yU3RhdGUodGltZVN0YW1wZWRFZGl0b3JTdGF0ZVsxXSk7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRSZWYuY3VycmVudDtcblxuICAgICAgICBpZiAoaW5wdXQgIT09IG51bGwpIHtcbiAgICAgICAgICBpbnB1dC52YWx1ZSA9IFN0cmluZyhpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lVHJhdmVsRW5hYmxlZChmYWxzZSk7XG4gICAgICAgIHNldElzUGxheWluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0eXBlOiBcImJ1dHRvblwiXG4gIH0sIFwiRXhpdFwiKSkpO1xufVxuXG5mdW5jdGlvbiB1c2VMZXhpY2FsQ29tbWFuZHNMb2coZWRpdG9yKSB7XG4gIGNvbnN0IFtsb2dnZWRDb21tYW5kcywgc2V0TG9nZ2VkQ29tbWFuZHNdID0gUmVhY3QudXNlU3RhdGUoW10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHVucmVnaXN0ZXJDb21tYW5kTGlzdGVuZXJzID0gbmV3IFNldCgpO1xuXG4gICAgZm9yIChjb25zdCBbY29tbWFuZF0gb2YgZWRpdG9yLl9jb21tYW5kcykge1xuICAgICAgdW5yZWdpc3RlckNvbW1hbmRMaXN0ZW5lcnMuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoY29tbWFuZCwgcGF5bG9hZCA9PiB7XG4gICAgICAgIHNldExvZ2dlZENvbW1hbmRzKHN0YXRlID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IFsuLi5zdGF0ZV07XG4gICAgICAgICAgbmV3U3RhdGUucHVzaCh7XG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgdHlwZTogY29tbWFuZC50eXBlID8gY29tbWFuZC50eXBlIDogJ1VOS05PV04nXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAobmV3U3RhdGUubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgIG5ld1N0YXRlLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4gdW5yZWdpc3RlckNvbW1hbmRMaXN0ZW5lcnMuZm9yRWFjaCh1bnJlZ2lzdGVyID0+IHVucmVnaXN0ZXIoKSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gbG9nZ2VkQ29tbWFuZHMsIFtsb2dnZWRDb21tYW5kc10pO1xufVxuXG5mdW5jdGlvbiBwcmludFJhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICBsZXQgcmVzID0gJyc7XG4gIGNvbnN0IGZvcm1hdFRleHQgPSBwcmludEZvcm1hdFByb3BlcnRpZXMoc2VsZWN0aW9uKTtcbiAgcmVzICs9IGA6IHJhbmdlICR7Zm9ybWF0VGV4dCAhPT0gJycgPyBgeyAke2Zvcm1hdFRleHR9IH1gIDogJyd9ICR7c2VsZWN0aW9uLnN0eWxlICE9PSAnJyA/IGB7IHN0eWxlOiAke3NlbGVjdGlvbi5zdHlsZX0gfSBgIDogJyd9YDtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICByZXMgKz0gYFxcbiAg4pScIGFuY2hvciB7IGtleTogJHthbmNob3Iua2V5fSwgb2Zmc2V0OiAke2FuY2hvck9mZnNldCA9PT0gbnVsbCA/ICdudWxsJyA6IGFuY2hvck9mZnNldH0sIHR5cGU6ICR7YW5jaG9yLnR5cGV9IH1gO1xuICByZXMgKz0gYFxcbiAg4pSUIGZvY3VzIHsga2V5OiAke2ZvY3VzLmtleX0sIG9mZnNldDogJHtmb2N1c09mZnNldCA9PT0gbnVsbCA/ICdudWxsJyA6IGZvY3VzT2Zmc2V0fSwgdHlwZTogJHtmb2N1cy50eXBlfSB9YDtcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcHJpbnROb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICByZXR1cm4gYDogbm9kZVxcbiAg4pSUIFske0FycmF5LmZyb20oc2VsZWN0aW9uLl9ub2Rlcykuam9pbignLCAnKX1dYDtcbn1cblxuZnVuY3Rpb24gcHJpbnRHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICByZXR1cm4gYDogZ3JpZFxcbiAg4pSUIHsgZ3JpZDogJHtzZWxlY3Rpb24uZ3JpZEtleX0sIGFuY2hvckNlbGw6ICR7c2VsZWN0aW9uLmFuY2hvci5rZXl9LCBmb2N1c0NlbGw6ICR7c2VsZWN0aW9uLmZvY3VzLmtleX0gfWA7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudChlZGl0b3IsIGNvbW1hbmRzTG9nLCBleHBvcnRET00pIHtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgZWRpdG9yQ29uZmlnID0gZWRpdG9yLl9jb25maWc7XG4gIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gZWRpdG9yLl9jb21wb3NpdGlvbktleTtcbiAgY29uc3QgZWRpdGFibGUgPSBlZGl0b3IuX2VkaXRhYmxlO1xuXG4gIGlmIChleHBvcnRET00pIHtcbiAgICBsZXQgaHRtbFN0cmluZyA9ICcnO1xuICAgIGVkaXRvclN0YXRlLnJlYWQoKCkgPT4ge1xuICAgICAgaHRtbFN0cmluZyA9IHByaW50UHJldHR5SFRNTChodG1sLiRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMoZWRpdG9yKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGh0bWxTdHJpbmc7XG4gIH1cblxuICBsZXQgcmVzID0gJyByb290XFxuJztcbiAgY29uc3Qgc2VsZWN0aW9uU3RyaW5nID0gZWRpdG9yU3RhdGUucmVhZCgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG4gICAgdmlzaXRUcmVlKGxleGljYWwuJGdldFJvb3QoKSwgKG5vZGUsIGluZGVudCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZUtleSA9IG5vZGUuZ2V0S2V5KCk7XG4gICAgICBjb25zdCBub2RlS2V5RGlzcGxheSA9IGAoJHtub2RlS2V5fSlgO1xuICAgICAgY29uc3QgdHlwZURpc3BsYXkgPSBub2RlLmdldFR5cGUoKSB8fCAnJztcbiAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBub2RlLmlzU2VsZWN0ZWQoKTtcbiAgICAgIGNvbnN0IGlkc0Rpc3BsYXkgPSBtYXJrLiRpc01hcmtOb2RlKG5vZGUpID8gYCBpZDogWyAke25vZGUuZ2V0SURzKCkuam9pbignLCAnKX0gXSBgIDogJyc7XG4gICAgICByZXMgKz0gYCR7aXNTZWxlY3RlZCA/IFNZTUJPTFMuc2VsZWN0ZWRMaW5lIDogJyAnfSAke2luZGVudC5qb2luKCcgJyl9ICR7bm9kZUtleURpc3BsYXl9ICR7dHlwZURpc3BsYXl9ICR7aWRzRGlzcGxheX0gJHtwcmludE5vZGUobm9kZSl9XFxuYDtcbiAgICAgIHJlcyArPSBwcmludFNlbGVjdGVkQ2hhcnNMaW5lKHtcbiAgICAgICAgaW5kZW50LFxuICAgICAgICBpc1NlbGVjdGVkLFxuICAgICAgICBub2RlLFxuICAgICAgICBub2RlS2V5RGlzcGxheSxcbiAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICB0eXBlRGlzcGxheVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGVjdGlvbiA9PT0gbnVsbCA/ICc6IG51bGwnIDogbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pID8gcHJpbnRSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIDogbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSA/IHByaW50R3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pIDogcHJpbnROb2RlU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gIH0pO1xuICByZXMgKz0gJ1xcbiBzZWxlY3Rpb24nICsgc2VsZWN0aW9uU3RyaW5nO1xuICByZXMgKz0gJ1xcblxcbiBjb21tYW5kczonO1xuXG4gIGlmIChjb21tYW5kc0xvZy5sZW5ndGgpIHtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBwYXlsb2FkXG4gICAgfSBvZiBjb21tYW5kc0xvZykge1xuICAgICAgcmVzICs9IGBcXG4gIOKUlCB7IHR5cGU6ICR7dHlwZX0sIHBheWxvYWQ6ICR7cGF5bG9hZCBpbnN0YW5jZW9mIEV2ZW50ID8gcGF5bG9hZC5jb25zdHJ1Y3Rvci5uYW1lIDogcGF5bG9hZH0gfWA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcyArPSAnXFxuICDilJQgTm9uZSBkaXNwYXRjaGVkLic7XG4gIH1cblxuICByZXMgKz0gJ1xcblxcbiBlZGl0b3I6JztcbiAgcmVzICs9IGBcXG4gIOKUlCBuYW1lc3BhY2UgJHtlZGl0b3JDb25maWcubmFtZXNwYWNlfWA7XG5cbiAgaWYgKGNvbXBvc2l0aW9uS2V5ICE9PSBudWxsKSB7XG4gICAgcmVzICs9IGBcXG4gIOKUlCBjb21wb3NpdGlvbktleSAke2NvbXBvc2l0aW9uS2V5fWA7XG4gIH1cblxuICByZXMgKz0gYFxcbiAg4pSUIGVkaXRhYmxlICR7U3RyaW5nKGVkaXRhYmxlKX1gO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiB2aXNpdFRyZWUoY3VycmVudE5vZGUsIHZpc2l0b3IsIGluZGVudCA9IFtdKSB7XG4gIGNvbnN0IGNoaWxkTm9kZXMgPSBjdXJyZW50Tm9kZS5nZXRDaGlsZHJlbigpO1xuICBjb25zdCBjaGlsZE5vZGVzTGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gIGNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROb2RlLCBpKSA9PiB7XG4gICAgdmlzaXRvcihjaGlsZE5vZGUsIGluZGVudC5jb25jYXQoaSA9PT0gY2hpbGROb2Rlc0xlbmd0aCAtIDEgPyBTWU1CT0xTLmlzTGFzdENoaWxkIDogU1lNQk9MUy5oYXNOZXh0U2libGluZykpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUoY2hpbGROb2RlKSkge1xuICAgICAgdmlzaXRUcmVlKGNoaWxkTm9kZSwgdmlzaXRvciwgaW5kZW50LmNvbmNhdChpID09PSBjaGlsZE5vZGVzTGVuZ3RoIC0gMSA/IFNZTUJPTFMuYW5jZXN0b3JJc0xhc3RDaGlsZCA6IFNZTUJPTFMuYW5jZXN0b3JIYXNOZXh0U2libGluZykpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh0ZXh0KSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhOT05fU0lOR0xFX1dJRFRIX0NIQVJTX1JFUExBQ0VNRU5UKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiBhY2MucmVwbGFjZShuZXcgUmVnRXhwKGtleSwgJ2cnKSwgU3RyaW5nKHZhbHVlKSksIHRleHQpO1xufSAvLyBUT0RPIFBhc3MgdmlhIHByb3BzIHRvIGFsbG93IGN1c3RvbWl6YWJpbGl0eVxuXG5cbmZ1bmN0aW9uIHByaW50Tm9kZShub2RlKSB7XG4gIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgY29uc3QgdGV4dCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBjb25zdCB0aXRsZSA9IHRleHQubGVuZ3RoID09PSAwID8gJyhlbXB0eSknIDogYFwiJHtub3JtYWxpemUodGV4dCl9XCJgO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBwcmludEFsbFRleHROb2RlUHJvcGVydGllcyhub2RlKTtcbiAgICByZXR1cm4gW3RpdGxlLCBwcm9wZXJ0aWVzLmxlbmd0aCAhPT0gMCA/IGB7ICR7cHJvcGVydGllc30gfWAgOiBudWxsXS5maWx0ZXIoQm9vbGVhbikuam9pbignICcpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsaW5rLiRpc0xpbmtOb2RlKG5vZGUpKSB7XG4gICAgY29uc3QgbGluayA9IG5vZGUuZ2V0VVJMKCk7XG4gICAgY29uc3QgdGl0bGUgPSBsaW5rLmxlbmd0aCA9PT0gMCA/ICcoZW1wdHkpJyA6IGBcIiR7bm9ybWFsaXplKGxpbmspfVwiYDtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gcHJpbnRBbGxMaW5rTm9kZVByb3BlcnRpZXMobm9kZSk7XG4gICAgcmV0dXJuIFt0aXRsZSwgcHJvcGVydGllcy5sZW5ndGggIT09IDAgPyBgeyAke3Byb3BlcnRpZXN9IH1gIDogbnVsbF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKS50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmNvbnN0IEZPUk1BVF9QUkVESUNBVEVTID0gW25vZGUgPT4gbm9kZS5oYXNGb3JtYXQoJ2JvbGQnKSAmJiAnQm9sZCcsIG5vZGUgPT4gbm9kZS5oYXNGb3JtYXQoJ2NvZGUnKSAmJiAnQ29kZScsIG5vZGUgPT4gbm9kZS5oYXNGb3JtYXQoJ2l0YWxpYycpICYmICdJdGFsaWMnLCBub2RlID0+IG5vZGUuaGFzRm9ybWF0KCdzdHJpa2V0aHJvdWdoJykgJiYgJ1N0cmlrZXRocm91Z2gnLCBub2RlID0+IG5vZGUuaGFzRm9ybWF0KCdzdWJzY3JpcHQnKSAmJiAnU3Vic2NyaXB0Jywgbm9kZSA9PiBub2RlLmhhc0Zvcm1hdCgnc3VwZXJzY3JpcHQnKSAmJiAnU3VwZXJzY3JpcHQnLCBub2RlID0+IG5vZGUuaGFzRm9ybWF0KCd1bmRlcmxpbmUnKSAmJiAnVW5kZXJsaW5lJ107XG5jb25zdCBERVRBSUxfUFJFRElDQVRFUyA9IFtub2RlID0+IG5vZGUuaXNEaXJlY3Rpb25sZXNzKCkgJiYgJ0RpcmVjdGlvbmxlc3MnLCBub2RlID0+IG5vZGUuaXNVbm1lcmdlYWJsZSgpICYmICdVbm1lcmdlYWJsZSddO1xuY29uc3QgTU9ERV9QUkVESUNBVEVTID0gW25vZGUgPT4gbm9kZS5pc1Rva2VuKCkgJiYgJ1Rva2VuJywgbm9kZSA9PiBub2RlLmlzU2VnbWVudGVkKCkgJiYgJ1NlZ21lbnRlZCddO1xuXG5mdW5jdGlvbiBwcmludEFsbFRleHROb2RlUHJvcGVydGllcyhub2RlKSB7XG4gIHJldHVybiBbcHJpbnRGb3JtYXRQcm9wZXJ0aWVzKG5vZGUpLCBwcmludERldGFpbFByb3BlcnRpZXMobm9kZSksIHByaW50TW9kZVByb3BlcnRpZXMobm9kZSldLmZpbHRlcihCb29sZWFuKS5qb2luKCcsICcpO1xufVxuXG5mdW5jdGlvbiBwcmludEFsbExpbmtOb2RlUHJvcGVydGllcyhub2RlKSB7XG4gIHJldHVybiBbcHJpbnRUYXJnZXRQcm9wZXJ0aWVzKG5vZGUpLCBwcmludFJlbFByb3BlcnRpZXMobm9kZSksIHByaW50VGl0bGVQcm9wZXJ0aWVzKG5vZGUpXS5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKTtcbn1cblxuZnVuY3Rpb24gcHJpbnREZXRhaWxQcm9wZXJ0aWVzKG5vZGVPclNlbGVjdGlvbikge1xuICBsZXQgc3RyID0gREVUQUlMX1BSRURJQ0FURVMubWFwKHByZWRpY2F0ZSA9PiBwcmVkaWNhdGUobm9kZU9yU2VsZWN0aW9uKSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcblxuICBpZiAoc3RyICE9PSAnJykge1xuICAgIHN0ciA9ICdkZXRhaWw6ICcgKyBzdHI7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBwcmludE1vZGVQcm9wZXJ0aWVzKG5vZGVPclNlbGVjdGlvbikge1xuICBsZXQgc3RyID0gTU9ERV9QUkVESUNBVEVTLm1hcChwcmVkaWNhdGUgPT4gcHJlZGljYXRlKG5vZGVPclNlbGVjdGlvbikpLmZpbHRlcihCb29sZWFuKS5qb2luKCcsICcpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHN0ciAhPT0gJycpIHtcbiAgICBzdHIgPSAnbW9kZTogJyArIHN0cjtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHByaW50Rm9ybWF0UHJvcGVydGllcyhub2RlT3JTZWxlY3Rpb24pIHtcbiAgbGV0IHN0ciA9IEZPUk1BVF9QUkVESUNBVEVTLm1hcChwcmVkaWNhdGUgPT4gcHJlZGljYXRlKG5vZGVPclNlbGVjdGlvbikpLmZpbHRlcihCb29sZWFuKS5qb2luKCcsICcpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHN0ciAhPT0gJycpIHtcbiAgICBzdHIgPSAnZm9ybWF0OiAnICsgc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gcHJpbnRUYXJnZXRQcm9wZXJ0aWVzKG5vZGUpIHtcbiAgbGV0IHN0ciA9IG5vZGUuZ2V0VGFyZ2V0KCk7IC8vIFRPRE8gRml4IG51bGxpc2ggb24gTGlua05vZGVcblxuICBpZiAoc3RyICE9IG51bGwpIHtcbiAgICBzdHIgPSAndGFyZ2V0OiAnICsgc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gcHJpbnRSZWxQcm9wZXJ0aWVzKG5vZGUpIHtcbiAgbGV0IHN0ciA9IG5vZGUuZ2V0UmVsKCk7IC8vIFRPRE8gRml4IG51bGxpc2ggb24gTGlua05vZGVcblxuICBpZiAoc3RyICE9IG51bGwpIHtcbiAgICBzdHIgPSAncmVsOiAnICsgc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gcHJpbnRUaXRsZVByb3BlcnRpZXMobm9kZSkge1xuICBsZXQgc3RyID0gbm9kZS5nZXRUaXRsZSgpOyAvLyBUT0RPIEZpeCBudWxsaXNoIG9uIExpbmtOb2RlXG5cbiAgaWYgKHN0ciAhPSBudWxsKSB7XG4gICAgc3RyID0gJ3RpdGxlOiAnICsgc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gcHJpbnRTZWxlY3RlZENoYXJzTGluZSh7XG4gIGluZGVudCxcbiAgaXNTZWxlY3RlZCxcbiAgbm9kZSxcbiAgbm9kZUtleURpc3BsYXksXG4gIHNlbGVjdGlvbixcbiAgdHlwZURpc3BsYXlcbn0pIHtcbiAgLy8gTm8gc2VsZWN0aW9uIG9yIG5vZGUgaXMgbm90IHNlbGVjdGVkLlxuICBpZiAoIWxleGljYWwuJGlzVGV4dE5vZGUobm9kZSkgfHwgIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhaXNTZWxlY3RlZCB8fCBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9IC8vIE5vIHNlbGVjdGVkIGNoYXJhY3RlcnMuXG5cblxuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcblxuICBpZiAobm9kZS5nZXRUZXh0Q29udGVudCgpID09PSAnJyB8fCBhbmNob3IuZ2V0Tm9kZSgpID09PSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpICYmIGFuY2hvci5vZmZzZXQgPT09IGZvY3VzLm9mZnNldCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGNvbnN0IFtzdGFydCwgZW5kXSA9ICRnZXRTZWxlY3Rpb25TdGFydEVuZChub2RlLCBzZWxlY3Rpb24pO1xuXG4gIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgY29uc3Qgc2VsZWN0aW9uTGFzdEluZGVudCA9IGluZGVudFtpbmRlbnQubGVuZ3RoIC0gMV0gPT09IFNZTUJPTFMuaGFzTmV4dFNpYmxpbmcgPyBTWU1CT0xTLmFuY2VzdG9ySGFzTmV4dFNpYmxpbmcgOiBTWU1CT0xTLmFuY2VzdG9ySXNMYXN0Q2hpbGQ7XG4gIGNvbnN0IGluZGVudGlvbkNoYXJzID0gWy4uLmluZGVudC5zbGljZSgwLCBpbmRlbnQubGVuZ3RoIC0gMSksIHNlbGVjdGlvbkxhc3RJbmRlbnRdO1xuICBjb25zdCB1bnNlbGVjdGVkQ2hhcnMgPSBBcnJheShzdGFydCArIDEpLmZpbGwoJyAnKTtcbiAgY29uc3Qgc2VsZWN0ZWRDaGFycyA9IEFycmF5KGVuZCAtIHN0YXJ0KS5maWxsKFNZTUJPTFMuc2VsZWN0ZWRDaGFyKTtcbiAgY29uc3QgcGFkZGluZ0xlbmd0aCA9IHR5cGVEaXNwbGF5Lmxlbmd0aCArIDM7IC8vIDIgZm9yIHRoZSBzcGFjZXMgYXJvdW5kICsgMSBmb3IgdGhlIGRvdWJsZSBxdW90ZS5cblxuICBjb25zdCBub2RlUHJpbnRTcGFjZXMgPSBBcnJheShub2RlS2V5RGlzcGxheS5sZW5ndGggKyBwYWRkaW5nTGVuZ3RoKS5maWxsKCcgJyk7XG4gIHJldHVybiBbU1lNQk9MUy5zZWxlY3RlZExpbmUsIGluZGVudGlvbkNoYXJzLmpvaW4oJyAnKSwgWy4uLm5vZGVQcmludFNwYWNlcywgLi4udW5zZWxlY3RlZENoYXJzLCAuLi5zZWxlY3RlZENoYXJzXS5qb2luKCcnKV0uam9pbignICcpICsgJ1xcbic7XG59XG5cbmZ1bmN0aW9uIHByaW50UHJldHR5SFRNTChzdHIpIHtcbiAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBzdHIudHJpbSgpO1xuICByZXR1cm4gcHJldHRpZnlIVE1MKGRpdiwgMCkuaW5uZXJIVE1MO1xufVxuXG5mdW5jdGlvbiBwcmV0dGlmeUhUTUwobm9kZSwgbGV2ZWwpIHtcbiAgY29uc3QgaW5kZW50QmVmb3JlID0gbmV3IEFycmF5KGxldmVsKysgKyAxKS5qb2luKCcgICcpO1xuICBjb25zdCBpbmRlbnRBZnRlciA9IG5ldyBBcnJheShsZXZlbCAtIDEpLmpvaW4oJyAgJyk7XG4gIGxldCB0ZXh0Tm9kZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXG4nICsgaW5kZW50QmVmb3JlKTtcbiAgICBub2RlLmluc2VydEJlZm9yZSh0ZXh0Tm9kZSwgbm9kZS5jaGlsZHJlbltpXSk7XG4gICAgcHJldHRpZnlIVE1MKG5vZGUuY2hpbGRyZW5baV0sIGxldmVsKTtcblxuICAgIGlmIChub2RlLmxhc3RFbGVtZW50Q2hpbGQgPT09IG5vZGUuY2hpbGRyZW5baV0pIHtcbiAgICAgIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcbicgKyBpbmRlbnRBZnRlcik7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gJGdldFNlbGVjdGlvblN0YXJ0RW5kKG5vZGUsIHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgdGV4dENvbnRlbnQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IHRleHRMZW5ndGggPSB0ZXh0Q29udGVudC5sZW5ndGg7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7IC8vIE9ubHkgb25lIG5vZGUgaXMgYmVpbmcgc2VsZWN0ZWQuXG5cbiAgaWYgKGFuY2hvci50eXBlID09PSAndGV4dCcgJiYgZm9jdXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuXG4gICAgaWYgKGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBub2RlID09PSBhbmNob3JOb2RlICYmIGFuY2hvci5vZmZzZXQgIT09IGZvY3VzLm9mZnNldCkge1xuICAgICAgW3N0YXJ0LCBlbmRdID0gYW5jaG9yLm9mZnNldCA8IGZvY3VzLm9mZnNldCA/IFthbmNob3Iub2Zmc2V0LCBmb2N1cy5vZmZzZXRdIDogW2ZvY3VzLm9mZnNldCwgYW5jaG9yLm9mZnNldF07XG4gICAgfSBlbHNlIGlmIChub2RlID09PSBhbmNob3JOb2RlKSB7XG4gICAgICBbc3RhcnQsIGVuZF0gPSBhbmNob3JOb2RlLmlzQmVmb3JlKGZvY3VzTm9kZSkgPyBbYW5jaG9yLm9mZnNldCwgdGV4dExlbmd0aF0gOiBbMCwgYW5jaG9yLm9mZnNldF07XG4gICAgfSBlbHNlIGlmIChub2RlID09PSBmb2N1c05vZGUpIHtcbiAgICAgIFtzdGFydCwgZW5kXSA9IGZvY3VzTm9kZS5pc0JlZm9yZShhbmNob3JOb2RlKSA/IFtmb2N1cy5vZmZzZXQsIHRleHRMZW5ndGhdIDogWzAsIGZvY3VzLm9mZnNldF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vZGUgaXMgd2l0aGluIHNlbGVjdGlvbiBidXQgbm90IHRoZSBhbmNob3Igbm9yIGZvY3VzLlxuICAgICAgW3N0YXJ0LCBlbmRdID0gWzAsIHRleHRMZW5ndGhdO1xuICAgIH1cbiAgfSAvLyBBY2NvdW50IGZvciBub24tc2luZ2xlIHdpZHRoIGNoYXJhY3RlcnMuXG5cblxuICBjb25zdCBudW1Ob25TaW5nbGVXaWR0aENoYXJCZWZvcmVTZWxlY3Rpb24gPSAodGV4dENvbnRlbnQuc2xpY2UoMCwgc3RhcnQpLm1hdGNoKE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVHRVgpIHx8IFtdKS5sZW5ndGg7XG4gIGNvbnN0IG51bU5vblNpbmdsZVdpZHRoQ2hhckluU2VsZWN0aW9uID0gKHRleHRDb250ZW50LnNsaWNlKHN0YXJ0LCBlbmQpLm1hdGNoKE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVHRVgpIHx8IFtdKS5sZW5ndGg7XG4gIHJldHVybiBbc3RhcnQgKyBudW1Ob25TaW5nbGVXaWR0aENoYXJCZWZvcmVTZWxlY3Rpb24sIGVuZCArIG51bU5vblNpbmdsZVdpZHRoQ2hhckJlZm9yZVNlbGVjdGlvbiArIG51bU5vblNpbmdsZVdpZHRoQ2hhckluU2VsZWN0aW9uXTtcbn1cblxuZXhwb3J0cy5UcmVlVmlldyA9IFRyZWVWaWV3O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalTreeView.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalTreeView.js":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTreeView.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalTreeView =  true ? __webpack_require__(/*! ./LexicalTreeView.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalTreeView.dev.js\") : 0\nmodule.exports = LexicalTreeView;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFRyZWVWaWV3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osd0JBQXdCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyw0RkFBMEIsSUFBSSxDQUFvQztBQUMzSSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxUcmVlVmlldy5qcz8zMTllIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsVHJlZVZpZXcgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFRyZWVWaWV3LmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsVHJlZVZpZXcucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxUcmVlVmlldzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalTreeView.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalEditable.dev.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? react.useLayoutEffect : react.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Shortcut to Lexical subscriptions when values are used for render.\n */\nfunction useLexicalSubscription(subscription) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const initializedSubscription = react.useMemo(() => subscription(editor), [editor, subscription]);\n  const valueRef = react.useRef(initializedSubscription.initialValueFn());\n  const [value, setValue] = react.useState(valueRef.current);\n  useLayoutEffect(() => {\n    const {\n      initialValueFn,\n      subscribe\n    } = initializedSubscription;\n    const currentValue = initialValueFn();\n\n    if (valueRef.current !== currentValue) {\n      valueRef.current = currentValue;\n      setValue(currentValue);\n    }\n\n    return subscribe(newValue => {\n      valueRef.current = newValue;\n      setValue(newValue);\n    });\n  }, [initializedSubscription, subscription]);\n  return value;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction subscription(editor) {\n  return {\n    initialValueFn: () => editor.isEditable(),\n    subscribe: callback => {\n      return editor.registerEditableListener(callback);\n    }\n  };\n}\n\nfunction useLexicalEditable() {\n  return useLexicalSubscription(subscription);\n}\n\nmodule.exports = useLexicalEditable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlLmRldi5qcz8xODFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgdXNlTGF5b3V0RWZmZWN0SW1wbCA9IENBTl9VU0VfRE9NID8gcmVhY3QudXNlTGF5b3V0RWZmZWN0IDogcmVhY3QudXNlRWZmZWN0O1xudmFyIHVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdEltcGw7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBTaG9ydGN1dCB0byBMZXhpY2FsIHN1YnNjcmlwdGlvbnMgd2hlbiB2YWx1ZXMgYXJlIHVzZWQgZm9yIHJlbmRlci5cbiAqL1xuZnVuY3Rpb24gdXNlTGV4aWNhbFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgaW5pdGlhbGl6ZWRTdWJzY3JpcHRpb24gPSByZWFjdC51c2VNZW1vKCgpID0+IHN1YnNjcmlwdGlvbihlZGl0b3IpLCBbZWRpdG9yLCBzdWJzY3JpcHRpb25dKTtcbiAgY29uc3QgdmFsdWVSZWYgPSByZWFjdC51c2VSZWYoaW5pdGlhbGl6ZWRTdWJzY3JpcHRpb24uaW5pdGlhbFZhbHVlRm4oKSk7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gcmVhY3QudXNlU3RhdGUodmFsdWVSZWYuY3VycmVudCk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgaW5pdGlhbFZhbHVlRm4sXG4gICAgICBzdWJzY3JpYmVcbiAgICB9ID0gaW5pdGlhbGl6ZWRTdWJzY3JpcHRpb247XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gaW5pdGlhbFZhbHVlRm4oKTtcblxuICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ICE9PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBjdXJyZW50VmFsdWU7XG4gICAgICBzZXRWYWx1ZShjdXJyZW50VmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzY3JpYmUobmV3VmFsdWUgPT4ge1xuICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5ld1ZhbHVlO1xuICAgICAgc2V0VmFsdWUobmV3VmFsdWUpO1xuICAgIH0pO1xuICB9LCBbaW5pdGlhbGl6ZWRTdWJzY3JpcHRpb24sIHN1YnNjcmlwdGlvbl0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gc3Vic2NyaXB0aW9uKGVkaXRvcikge1xuICByZXR1cm4ge1xuICAgIGluaXRpYWxWYWx1ZUZuOiAoKSA9PiBlZGl0b3IuaXNFZGl0YWJsZSgpLFxuICAgIHN1YnNjcmliZTogY2FsbGJhY2sgPT4ge1xuICAgICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIoY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTGV4aWNhbEVkaXRhYmxlKCkge1xuICByZXR1cm4gdXNlTGV4aWNhbFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVzZUxleGljYWxFZGl0YWJsZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/useLexicalEditable.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalEditable.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst useLexicalEditable =  true ? __webpack_require__(/*! ./useLexicalEditable.dev.js */ \"(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.js\") : 0\nmodule.exports = useLexicalEditable;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osMkJBQTJCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxrR0FBNkIsSUFBSSxDQUF1QztBQUNwSiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L3VzZUxleGljYWxFZGl0YWJsZS5qcz9hNGQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCB1c2VMZXhpY2FsRWRpdGFibGUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vdXNlTGV4aWNhbEVkaXRhYmxlLmRldi5qcycpIDogcmVxdWlyZSgnLi91c2VMZXhpY2FsRWRpdGFibGUucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IHVzZUxleGljYWxFZGl0YWJsZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/useLexicalEditable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.dev.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalNodeSelection.dev.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction isNodeSelected(editor, key) {\n  return editor.getEditorState().read(() => {\n    const node = lexical.$getNodeByKey(key);\n\n    if (node === null) {\n      return false;\n    }\n\n    return node.isSelected();\n  });\n}\n\nfunction useLexicalNodeSelection(key) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isSelected, setIsSelected] = react.useState(() => isNodeSelected(editor, key));\n  react.useEffect(() => {\n    let isMounted = true;\n    const unregister = editor.registerUpdateListener(() => {\n      if (isMounted) {\n        setIsSelected(isNodeSelected(editor, key));\n      }\n    });\n    return () => {\n      isMounted = false;\n      unregister();\n    };\n  }, [editor, key]);\n  const setSelected = react.useCallback(selected => {\n    editor.update(() => {\n      let selection = lexical.$getSelection();\n\n      if (!lexical.$isNodeSelection(selection)) {\n        selection = lexical.$createNodeSelection();\n        lexical.$setSelection(selection);\n      }\n\n      if (selected) {\n        selection.add(key);\n      } else {\n        selection.delete(key);\n      }\n    });\n  }, [editor, key]);\n  const clearSelected = react.useCallback(() => {\n    editor.update(() => {\n      const selection = lexical.$getSelection();\n\n      if (lexical.$isNodeSelection(selection)) {\n        selection.clear();\n      }\n    });\n  }, [editor]);\n  return [isSelected, setSelected, clearSelected];\n}\n\nexports.useLexicalNodeSelection = useLexicalNodeSelection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLDRHQUF1QztBQUM1RSxjQUFjLG1CQUFPLENBQUMsd0RBQVM7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L3VzZUxleGljYWxOb2RlU2VsZWN0aW9uLmRldi5qcz82ZTM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBpc05vZGVTZWxlY3RlZChlZGl0b3IsIGtleSkge1xuICByZXR1cm4gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleShrZXkpO1xuXG4gICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZS5pc1NlbGVjdGVkKCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VMZXhpY2FsTm9kZVNlbGVjdGlvbihrZXkpIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgW2lzU2VsZWN0ZWQsIHNldElzU2VsZWN0ZWRdID0gcmVhY3QudXNlU3RhdGUoKCkgPT4gaXNOb2RlU2VsZWN0ZWQoZWRpdG9yLCBrZXkpKTtcbiAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgaXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjb25zdCB1bnJlZ2lzdGVyID0gZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgaWYgKGlzTW91bnRlZCkge1xuICAgICAgICBzZXRJc1NlbGVjdGVkKGlzTm9kZVNlbGVjdGVkKGVkaXRvciwga2V5KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgdW5yZWdpc3RlcigpO1xuICAgIH07XG4gIH0sIFtlZGl0b3IsIGtleV0pO1xuICBjb25zdCBzZXRTZWxlY3RlZCA9IHJlYWN0LnVzZUNhbGxiYWNrKHNlbGVjdGVkID0+IHtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGxldCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKCFsZXhpY2FsLiRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBzZWxlY3Rpb24gPSBsZXhpY2FsLiRjcmVhdGVOb2RlU2VsZWN0aW9uKCk7XG4gICAgICAgIGxleGljYWwuJHNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgc2VsZWN0aW9uLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbZWRpdG9yLCBrZXldKTtcbiAgY29uc3QgY2xlYXJTZWxlY3RlZCA9IHJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAobGV4aWNhbC4kaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgc2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgcmV0dXJuIFtpc1NlbGVjdGVkLCBzZXRTZWxlY3RlZCwgY2xlYXJTZWxlY3RlZF07XG59XG5cbmV4cG9ydHMudXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24gPSB1c2VMZXhpY2FsTm9kZVNlbGVjdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalNodeSelection.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst useLexicalNodeSelection =  true ? __webpack_require__(/*! ./useLexicalNodeSelection.dev.js */ \"(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.dev.js\") : 0\nmodule.exports = useLexicalNodeSelection;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWixnQ0FBZ0MsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLDRHQUFrQyxJQUFJLENBQTRDO0FBQ25LIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24uanM/ZDc1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24uZGV2LmpzJykgOiByZXF1aXJlKCcuL3VzZUxleGljYWxOb2RlU2VsZWN0aW9uLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSB1c2VMZXhpY2FsTm9kZVNlbGVjdGlvbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.dev.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/rich-text/LexicalRichText.dev.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar clipboard = __webpack_require__(/*! @lexical/clipboard */ \"(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.js\");\nvar selection = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n\n    if (range === null) {\n      return null;\n    }\n\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    }; // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n\n    if (range === null) {\n      return null;\n    }\n\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/** @module @lexical/rich-text */\nconst DRAG_DROP_PASTE = lexical.createCommand('DRAG_DROP_PASTE_FILE');\n\n/** @noInheritDoc */\nclass QuoteNode extends lexical.ElementNode {\n  static getType() {\n    return 'quote';\n  }\n\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n\n  constructor(key) {\n    super(key);\n  } // View\n\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    utils.addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element && this.isEmpty()) {\n      element.append(document.createElement('br'));\n    }\n\n    if (element) {\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'quote'\n    };\n  } // Mutation\n\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n}\nfunction $createQuoteNode() {\n  return lexical.$applyNodeReplacement(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n\n/** @noInheritDoc */\nclass HeadingNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'heading';\n  }\n\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n\n  getTag() {\n    return this.__tag;\n  } // View\n\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      utils.addClassNamesToElement(element, className);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n\n        return null;\n      }\n    };\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element && this.isEmpty()) {\n      element.append(document.createElement('br'));\n    }\n\n    if (element) {\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const newElement = anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n\n  extractWithChild() {\n    return true;\n  }\n\n}\n\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n\n  return false;\n}\n\nfunction convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n\n    if (element.style !== null) {\n      node.setFormat(element.style.textAlign);\n    }\n  }\n\n  return {\n    node\n  };\n}\n\nfunction convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n  }\n\n  return {\n    node\n  };\n}\n\nfunction $createHeadingNode(headingTag) {\n  return lexical.$applyNodeReplacement(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\n\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;\n\n    if (clipboardData != null && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n      clipboard.$insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\n\nasync function onCutForRichText(event, editor) {\n  await clipboard.copyToClipboard(editor, utils.objectKlassEquals(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      selection.removeText();\n    } else if (lexical.$isNodeSelection(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n} // Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain ocassions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\n\n\nfunction eventFiles(event) {\n  let dataTransfer = null;\n\n  if (event instanceof DragEvent) {\n    dataTransfer = event.dataTransfer;\n  } else if (event instanceof ClipboardEvent) {\n    dataTransfer = event.clipboardData;\n  }\n\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\n\nfunction handleIndentAndOutdent(indentOrOutdent) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n\n    const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);\n    const parentKey = parentBlock.getKey();\n\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n\n  return alreadyHandled.size > 0;\n}\n\nfunction $isTargetWithinDecorator(target) {\n  const node = lexical.$getNearestNodeFromDOMNode(target);\n  return lexical.$isDecoratorNode(node);\n}\n\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === lexical.$getRoot().getChildrenSize();\n}\n\nfunction registerRichText(editor) {\n  const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n\n    return false;\n  }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = lexical.$getSelection();\n\n    if (typeof eventOrText === 'string') {\n      if (lexical.$isRangeSelection(selection)) {\n        selection.insertText(eventOrText);\n      } else if (lexical.DEPRECATED_$isGridSelection(selection)) ;\n    } else {\n      if (!lexical.$isRangeSelection(selection) && !lexical.DEPRECATED_$isGridSelection(selection)) {\n        return false;\n      }\n\n      const dataTransfer = eventOrText.dataTransfer;\n\n      if (dataTransfer != null) {\n        clipboard.$insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if (lexical.$isRangeSelection(selection)) {\n        const data = eventOrText.data;\n\n        if (data) {\n          selection.insertText(data);\n        }\n\n        return true;\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.removeText();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.formatText(format);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection) && !lexical.$isNodeSelection(selection)) {\n      return false;\n    }\n\n    const nodes = selection.getNodes();\n\n    for (const node of nodes) {\n      const element = utils.$findMatchingParent(node, parentNode => lexical.$isElementNode(parentNode) && !parentNode.isInline());\n\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertParagraph();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_TAB_COMMAND, () => {\n    lexical.$insertNodes([lexical.$createTabNode()]);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {\n    return handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {\n    return handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n\n      if (indent > 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if (lexical.$isRangeSelection(selection)) {\n      const possibleNode = lexical.$getAdjacentNode(selection.focus, true);\n\n      if (!event.shiftKey && lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if (lexical.$isRangeSelection(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n\n      const possibleNode = lexical.$getAdjacentNode(selection.focus, false);\n\n      if (!event.shiftKey && lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection$1)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, true);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection$1) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    const isHoldingShift = event.shiftKey;\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, false);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n\n    if (selection.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);\n\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n\n      event.preventDefault();\n\n      if (event.shiftKey) {\n        return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n\n    return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, undefined);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    editor.blur();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = lexical.$getNearestNodeFromDOMNode(domNode);\n\n        if (node !== null) {\n          const selection = lexical.$createRangeSelection();\n\n          if (lexical.$isTextNode(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n\n          const normalizedSelection = lexical.$normalizeSelection__EXPERIMENTAL(selection);\n          lexical.$setSelection(normalizedSelection);\n        }\n\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n\n      event.preventDefault();\n      return true;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = lexical.$getSelection();\n\n    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = lexical.$getSelection();\n\n    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n\n    if (eventRange !== null) {\n      const node = lexical.$getNearestNodeFromDOMNode(eventRange.node);\n\n      if (lexical.$isDecoratorNode(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, event => {\n    clipboard.copyToClipboard(editor, utils.objectKlassEquals(event, ClipboardEvent) ? event : null);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    } // if inputs then paste within the input ignore creating a new node on paste event\n\n\n    if (lexical.isSelectionCapturedInDecoratorInput(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\nexports.$createHeadingNode = $createHeadingNode;\nexports.$createQuoteNode = $createQuoteNode;\nexports.$isHeadingNode = $isHeadingNode;\nexports.$isQuoteNode = $isQuoteNode;\nexports.DRAG_DROP_PASTE = DRAG_DROP_PASTE;\nexports.HeadingNode = HeadingNode;\nexports.QuoteNode = QuoteNode;\nexports.eventFiles = eventFiles;\nexports.registerRichText = registerRichText;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmljaC10ZXh0L0xleGljYWxSaWNoVGV4dC5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsdUZBQW9CO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLHVGQUFvQjtBQUM1QyxZQUFZLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyx3REFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7O0FBRUEsK0VBQStFOztBQUUvRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsb0JBQW9CO0FBQ3BCLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQix3QkFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yaWNoLXRleHQvTGV4aWNhbFJpY2hUZXh0LmRldi5qcz8xZWI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xpcGJvYXJkID0gcmVxdWlyZSgnQGxleGljYWwvY2xpcGJvYXJkJyk7XG52YXIgc2VsZWN0aW9uID0gcmVxdWlyZSgnQGxleGljYWwvc2VsZWN0aW9uJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIGNhcmV0RnJvbVBvaW50KHgsIHkpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcblxuICAgIGlmIChyYW5nZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IHJhbmdlLnN0YXJ0Q29udGFpbmVyLFxuICAgICAgb2Zmc2V0OiByYW5nZS5zdGFydE9mZnNldFxuICAgIH07IC8vIEB0cy1pZ25vcmVcbiAgfSBlbHNlIGlmIChkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEB0cy1pZ25vcmUgRkYgLSBubyB0eXBlc1xuICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcblxuICAgIGlmIChyYW5nZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IHJhbmdlLm9mZnNldE5vZGUsXG4gICAgICBvZmZzZXQ6IHJhbmdlLm9mZnNldFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gR3JhY2VmdWxseSBoYW5kbGUgSUVcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IGRvY3VtZW50TW9kZSA9IENBTl9VU0VfRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogbnVsbDtcbkNBTl9VU0VfRE9NICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuQ0FOX1VTRV9ET00gJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3gpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgQ0FOX1VTRV9CRUZPUkVfSU5QVVQgPSBDQU5fVVNFX0RPTSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcbmNvbnN0IElTX1NBRkFSSSA9IENBTl9VU0VfRE9NICYmIC9WZXJzaW9uXFwvW1xcZC5dKy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgSVNfSU9TID0gQ0FOX1VTRV9ET00gJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTsgLy8gS2VlcCB0aGVzZSBpbiBjYXNlIHdlIG5lZWQgdG8gdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZS5cbi8vIGV4cG9ydCBjb25zdCBJU19XSU5ET1dTOiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG5jb25zdCBJU19DSFJPTUUgPSBDQU5fVVNFX0RPTSAmJiAvXig/PS4qQ2hyb21lKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gZXhwb3J0IGNvbnN0IGNhblVzZVRleHRJbnB1dEV2ZW50OiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbmNvbnN0IElTX0FQUExFX1dFQktJVCA9IENBTl9VU0VfRE9NICYmIC9BcHBsZVdlYktpdFxcL1tcXGQuXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIUlTX0NIUk9NRTtcblxuLyoqIEBtb2R1bGUgQGxleGljYWwvcmljaC10ZXh0ICovXG5jb25zdCBEUkFHX0RST1BfUEFTVEUgPSBsZXhpY2FsLmNyZWF0ZUNvbW1hbmQoJ0RSQUdfRFJPUF9QQVNURV9GSUxFJyk7XG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBRdW90ZU5vZGUgZXh0ZW5kcyBsZXhpY2FsLkVsZW1lbnROb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdxdW90ZSc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgUXVvdGVOb2RlKG5vZGUuX19rZXkpO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgfSAvLyBWaWV3XG5cblxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jsb2NrcXVvdGUnKTtcbiAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS5xdW90ZSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJsb2NrcXVvdGU6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydEJsb2NrcXVvdGVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG5cbiAgICBpZiAoZWxlbWVudCAmJiB0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgZWxlbWVudC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKSk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGZvcm1hdFR5cGUgPSB0aGlzLmdldEZvcm1hdFR5cGUoKTtcbiAgICAgIGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gZm9ybWF0VHlwZTtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCk7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgZWxlbWVudC5kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZVF1b3RlTm9kZSgpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4geyAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICB0eXBlOiAncXVvdGUnXG4gICAgfTtcbiAgfSAvLyBNdXRhdGlvblxuXG5cbiAgaW5zZXJ0TmV3QWZ0ZXIoXywgcmVzdG9yZVNlbGVjdGlvbikge1xuICAgIGNvbnN0IG5ld0Jsb2NrID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCk7XG4gICAgbmV3QmxvY2suc2V0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgdGhpcy5pbnNlcnRBZnRlcihuZXdCbG9jaywgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgcmV0dXJuIG5ld0Jsb2NrO1xuICB9XG5cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIGNvbnN0IHBhcmFncmFwaCA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHBhcmFncmFwaC5hcHBlbmQoY2hpbGQpKTtcbiAgICB0aGlzLnJlcGxhY2UocGFyYWdyYXBoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG59XG5mdW5jdGlvbiAkY3JlYXRlUXVvdGVOb2RlKCkge1xuICByZXR1cm4gbGV4aWNhbC4kYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFF1b3RlTm9kZSgpKTtcbn1cbmZ1bmN0aW9uICRpc1F1b3RlTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgUXVvdGVOb2RlO1xufVxuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgSGVhZGluZ05vZGUgZXh0ZW5kcyBsZXhpY2FsLkVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2hlYWRpbmcnO1xuICB9XG5cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IEhlYWRpbmdOb2RlKG5vZGUuX190YWcsIG5vZGUuX19rZXkpO1xuICB9XG5cbiAgY29uc3RydWN0b3IodGFnLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX190YWcgPSB0YWc7XG4gIH1cblxuICBnZXRUYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190YWc7XG4gIH0gLy8gVmlld1xuXG5cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuX190YWc7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBjb25zdCB0aGVtZSA9IGNvbmZpZy50aGVtZTtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gdGhlbWUuaGVhZGluZztcblxuICAgIGlmIChjbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbdGFnXTtcbiAgICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaDE6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoMjogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0SGVhZGluZ0VsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIGgzOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDQ6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoNTogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0SGVhZGluZ0VsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIGg2OiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgcDogbm9kZSA9PiB7XG4gICAgICAgIC8vIGRvbU5vZGUgaXMgYSA8cD4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICAgICAgICBjb25zdCBwYXJhZ3JhcGggPSBub2RlO1xuICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gcGFyYWdyYXBoLmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwgJiYgaXNHb29nbGVEb2NzVGl0bGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udmVyc2lvbjogKCkgPT4gKHtcbiAgICAgICAgICAgICAgbm9kZTogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwcmlvcml0eTogM1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBzcGFuOiBub2RlID0+IHtcbiAgICAgICAgaWYgKGlzR29vZ2xlRG9jc1RpdGxlKG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb246IGRvbU5vZGUgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5vZGU6ICRjcmVhdGVIZWFkaW5nTm9kZSgnaDEnKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByaW9yaXR5OiAzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcblxuICAgIGlmIChlbGVtZW50ICYmIHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICBlbGVtZW50LmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgY29uc3QgZm9ybWF0VHlwZSA9IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpO1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBmb3JtYXRUeXBlO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcblxuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICBlbGVtZW50LmRpciA9IGRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlSGVhZGluZ05vZGUoc2VyaWFsaXplZE5vZGUudGFnKTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgdGFnOiB0aGlzLmdldFRhZygpLFxuICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH0gLy8gTXV0YXRpb25cblxuXG4gIGluc2VydE5ld0FmdGVyKHNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBhbmNob3JPZmZldCA9IHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0IDogMDtcbiAgICBjb25zdCBuZXdFbGVtZW50ID0gYW5jaG9yT2ZmZXQgPiAwICYmIGFuY2hvck9mZmV0IDwgdGhpcy5nZXRUZXh0Q29udGVudFNpemUoKSA/ICRjcmVhdGVIZWFkaW5nTm9kZSh0aGlzLmdldFRhZygpKSA6IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldERpcmVjdGlvbigpO1xuICAgIG5ld0VsZW1lbnQuc2V0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgdGhpcy5pbnNlcnRBZnRlcihuZXdFbGVtZW50LCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuXG4gIGNvbGxhcHNlQXRTdGFydCgpIHtcbiAgICBjb25zdCBuZXdFbGVtZW50ID0gIXRoaXMuaXNFbXB0eSgpID8gJGNyZWF0ZUhlYWRpbmdOb2RlKHRoaXMuZ2V0VGFnKCkpIDogbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gbmV3RWxlbWVudC5hcHBlbmQoY2hpbGQpKTtcbiAgICB0aGlzLnJlcGxhY2UobmV3RWxlbWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBleHRyYWN0V2l0aENoaWxkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gaXNHb29nbGVEb2NzVGl0bGUoZG9tTm9kZSkge1xuICBpZiAoZG9tTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3BhbicpIHtcbiAgICByZXR1cm4gZG9tTm9kZS5zdHlsZS5mb250U2l6ZSA9PT0gJzI2cHQnO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0SGVhZGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbGV0IG5vZGUgPSBudWxsO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2gxJyB8fCBub2RlTmFtZSA9PT0gJ2gyJyB8fCBub2RlTmFtZSA9PT0gJ2gzJyB8fCBub2RlTmFtZSA9PT0gJ2g0JyB8fCBub2RlTmFtZSA9PT0gJ2g1JyB8fCBub2RlTmFtZSA9PT0gJ2g2Jykge1xuICAgIG5vZGUgPSAkY3JlYXRlSGVhZGluZ05vZGUobm9kZU5hbWUpO1xuXG4gICAgaWYgKGVsZW1lbnQuc3R5bGUgIT09IG51bGwpIHtcbiAgICAgIG5vZGUuc2V0Rm9ybWF0KGVsZW1lbnQuc3R5bGUudGV4dEFsaWduKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5vZGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydEJsb2NrcXVvdGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgY29uc3Qgbm9kZSA9ICRjcmVhdGVRdW90ZU5vZGUoKTtcblxuICBpZiAoZWxlbWVudC5zdHlsZSAhPT0gbnVsbCkge1xuICAgIG5vZGUuc2V0Rm9ybWF0KGVsZW1lbnQuc3R5bGUudGV4dEFsaWduKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbm9kZVxuICB9O1xufVxuXG5mdW5jdGlvbiAkY3JlYXRlSGVhZGluZ05vZGUoaGVhZGluZ1RhZykge1xuICByZXR1cm4gbGV4aWNhbC4kYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IEhlYWRpbmdOb2RlKGhlYWRpbmdUYWcpKTtcbn1cbmZ1bmN0aW9uICRpc0hlYWRpbmdOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBIZWFkaW5nTm9kZTtcbn1cblxuZnVuY3Rpb24gb25QYXN0ZUZvclJpY2hUZXh0KGV2ZW50LCBlZGl0b3IpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGV2ZW50IGluc3RhbmNlb2YgSW5wdXRFdmVudCB8fCBldmVudCBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcblxuICAgIGlmIChjbGlwYm9hcmREYXRhICE9IG51bGwgJiYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgICAgY2xpcGJvYXJkLiRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dChjbGlwYm9hcmREYXRhLCBzZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgfVxuICB9LCB7XG4gICAgdGFnOiAncGFzdGUnXG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBvbkN1dEZvclJpY2hUZXh0KGV2ZW50LCBlZGl0b3IpIHtcbiAgYXdhaXQgY2xpcGJvYXJkLmNvcHlUb0NsaXBib2FyZChlZGl0b3IsIHV0aWxzLm9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBDbGlwYm9hcmRFdmVudCkgPyBldmVudCA6IG51bGwpO1xuICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5yZW1vdmVUZXh0KCk7XG4gICAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgc2VsZWN0aW9uLmdldE5vZGVzKCkuZm9yRWFjaChub2RlID0+IG5vZGUucmVtb3ZlKCkpO1xuICAgIH1cbiAgfSk7XG59IC8vIENsaXBib2FyZCBtYXkgY29udGFpbiBmaWxlcyB0aGF0IHdlIGFyZW4ndCBhbGxvd2VkIHRvIHJlYWQuIFdoaWxlIHRoZSBldmVudCBpcyBhcmd1YWJseSB1c2VsZXNzLFxuLy8gaW4gY2VydGFpbiBvY2Fzc2lvbnMsIHdlIHdhbnQgdG8ga25vdyB3aGV0aGVyIGl0IHdhcyBhIGZpbGUgdHJhbnNmZXIsIGFzIG9wcG9zZWQgdG8gdGV4dC4gV2Vcbi8vIGNvbnRyb2wgdGhpcyB3aXRoIHRoZSBmaXJzdCBib29sZWFuIGZsYWcuXG5cblxuZnVuY3Rpb24gZXZlbnRGaWxlcyhldmVudCkge1xuICBsZXQgZGF0YVRyYW5zZmVyID0gbnVsbDtcblxuICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBEcmFnRXZlbnQpIHtcbiAgICBkYXRhVHJhbnNmZXIgPSBldmVudC5kYXRhVHJhbnNmZXI7XG4gIH0gZWxzZSBpZiAoZXZlbnQgaW5zdGFuY2VvZiBDbGlwYm9hcmRFdmVudCkge1xuICAgIGRhdGFUcmFuc2ZlciA9IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gIH1cblxuICBpZiAoZGF0YVRyYW5zZmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFtmYWxzZSwgW10sIGZhbHNlXTtcbiAgfVxuXG4gIGNvbnN0IHR5cGVzID0gZGF0YVRyYW5zZmVyLnR5cGVzO1xuICBjb25zdCBoYXNGaWxlcyA9IHR5cGVzLmluY2x1ZGVzKCdGaWxlcycpO1xuICBjb25zdCBoYXNDb250ZW50ID0gdHlwZXMuaW5jbHVkZXMoJ3RleHQvaHRtbCcpIHx8IHR5cGVzLmluY2x1ZGVzKCd0ZXh0L3BsYWluJyk7XG4gIHJldHVybiBbaGFzRmlsZXMsIEFycmF5LmZyb20oZGF0YVRyYW5zZmVyLmZpbGVzKSwgaGFzQ29udGVudF07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUluZGVudEFuZE91dGRlbnQoaW5kZW50T3JPdXRkZW50KSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgYWxyZWFkeUhhbmRsZWQgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBjb25zdCBrZXkgPSBub2RlLmdldEtleSgpO1xuXG4gICAgaWYgKGFscmVhZHlIYW5kbGVkLmhhcyhrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnRCbG9jayA9IHV0aWxzLiRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93KG5vZGUpO1xuICAgIGNvbnN0IHBhcmVudEtleSA9IHBhcmVudEJsb2NrLmdldEtleSgpO1xuXG4gICAgaWYgKHBhcmVudEJsb2NrLmNhbkluZGVudCgpICYmICFhbHJlYWR5SGFuZGxlZC5oYXMocGFyZW50S2V5KSkge1xuICAgICAgYWxyZWFkeUhhbmRsZWQuYWRkKHBhcmVudEtleSk7XG4gICAgICBpbmRlbnRPck91dGRlbnQocGFyZW50QmxvY2spO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbHJlYWR5SGFuZGxlZC5zaXplID4gMDtcbn1cblxuZnVuY3Rpb24gJGlzVGFyZ2V0V2l0aGluRGVjb3JhdG9yKHRhcmdldCkge1xuICBjb25zdCBub2RlID0gbGV4aWNhbC4kZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZSh0YXJnZXQpO1xuICByZXR1cm4gbGV4aWNhbC4kaXNEZWNvcmF0b3JOb2RlKG5vZGUpO1xufVxuXG5mdW5jdGlvbiAkaXNTZWxlY3Rpb25BdEVuZE9mUm9vdChzZWxlY3Rpb24pIHtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIHJldHVybiBmb2N1cy5rZXkgPT09ICdyb290JyAmJiBmb2N1cy5vZmZzZXQgPT09IGxleGljYWwuJGdldFJvb3QoKS5nZXRDaGlsZHJlblNpemUoKTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJSaWNoVGV4dChlZGl0b3IpIHtcbiAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSB1dGlscy5tZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5DTElDS19DT01NQU5ELCBwYXlsb2FkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgc2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIDApLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBpc0JhY2t3YXJkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uLmRlbGV0ZUNoYXJhY3Rlcihpc0JhY2t3YXJkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5ERUxFVEVfV09SRF9DT01NQU5ELCBpc0JhY2t3YXJkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uLmRlbGV0ZVdvcmQoaXNCYWNrd2FyZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuREVMRVRFX0xJTkVfQ09NTUFORCwgaXNCYWNrd2FyZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNlbGVjdGlvbi5kZWxldGVMaW5lKGlzQmFja3dhcmQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkNPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgZXZlbnRPclRleHQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKHR5cGVvZiBldmVudE9yVGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgc2VsZWN0aW9uLmluc2VydFRleHQoZXZlbnRPclRleHQpO1xuICAgICAgfSBlbHNlIGlmIChsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmICFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YVRyYW5zZmVyID0gZXZlbnRPclRleHQuZGF0YVRyYW5zZmVyO1xuXG4gICAgICBpZiAoZGF0YVRyYW5zZmVyICE9IG51bGwpIHtcbiAgICAgICAgY2xpcGJvYXJkLiRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dChkYXRhVHJhbnNmZXIsIHNlbGVjdGlvbiwgZWRpdG9yKTtcbiAgICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBldmVudE9yVGV4dC5kYXRhO1xuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmluc2VydFRleHQoZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5SRU1PVkVfVEVYVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNlbGVjdGlvbi5yZW1vdmVUZXh0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuRk9STUFUX1RFWFRfQ09NTUFORCwgZm9ybWF0ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uLmZvcm1hdFRleHQoZm9ybWF0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5GT1JNQVRfRUxFTUVOVF9DT01NQU5ELCBmb3JtYXQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgIWxleGljYWwuJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcblxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgcGFyZW50Tm9kZSA9PiBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKHBhcmVudE5vZGUpICYmICFwYXJlbnROb2RlLmlzSW5saW5lKCkpO1xuXG4gICAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50LnNldEZvcm1hdChmb3JtYXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLklOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQsIHNlbGVjdFN0YXJ0ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uLmluc2VydExpbmVCcmVhayhzZWxlY3RTdGFydCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNlbGVjdGlvbi5pbnNlcnRQYXJhZ3JhcGgoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5JTlNFUlRfVEFCX0NPTU1BTkQsICgpID0+IHtcbiAgICBsZXhpY2FsLiRpbnNlcnROb2RlcyhbbGV4aWNhbC4kY3JlYXRlVGFiTm9kZSgpXSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuSU5ERU5UX0NPTlRFTlRfQ09NTUFORCwgKCkgPT4ge1xuICAgIHJldHVybiBoYW5kbGVJbmRlbnRBbmRPdXRkZW50KGJsb2NrID0+IHtcbiAgICAgIGNvbnN0IGluZGVudCA9IGJsb2NrLmdldEluZGVudCgpO1xuICAgICAgYmxvY2suc2V0SW5kZW50KGluZGVudCArIDEpO1xuICAgIH0pO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLk9VVERFTlRfQ09OVEVOVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgcmV0dXJuIGhhbmRsZUluZGVudEFuZE91dGRlbnQoYmxvY2sgPT4ge1xuICAgICAgY29uc3QgaW5kZW50ID0gYmxvY2suZ2V0SW5kZW50KCk7XG5cbiAgICAgIGlmIChpbmRlbnQgPiAwKSB7XG4gICAgICAgIGJsb2NrLnNldEluZGVudChpbmRlbnQgLSAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQVJST1dfVVBfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmICEkaXNUYXJnZXRXaXRoaW5EZWNvcmF0b3IoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgLy8gSWYgc2VsZWN0aW9uIGlzIG9uIGEgbm9kZSwgbGV0J3MgdHJ5IGFuZCBtb3ZlIHNlbGVjdGlvblxuICAgICAgLy8gYmFjayB0byBiZWluZyBhIHJhbmdlIHNlbGVjdGlvbi5cbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5vZGVzWzBdLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBwb3NzaWJsZU5vZGUgPSBsZXhpY2FsLiRnZXRBZGphY2VudE5vZGUoc2VsZWN0aW9uLmZvY3VzLCB0cnVlKTtcblxuICAgICAgaWYgKCFldmVudC5zaGlmdEtleSAmJiBsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSAmJiAhcG9zc2libGVOb2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgcG9zc2libGVOb2RlLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQVJST1dfRE9XTl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBvbiBhIG5vZGUsIGxldCdzIHRyeSBhbmQgbW92ZSBzZWxlY3Rpb25cbiAgICAgIC8vIGJhY2sgdG8gYmVpbmcgYSByYW5nZSBzZWxlY3Rpb24uXG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuXG4gICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBub2Rlc1swXS5zZWxlY3ROZXh0KDAsIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgaWYgKCRpc1NlbGVjdGlvbkF0RW5kT2ZSb290KHNlbGVjdGlvbikpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvc3NpYmxlTm9kZSA9IGxleGljYWwuJGdldEFkamFjZW50Tm9kZShzZWxlY3Rpb24uZm9jdXMsIGZhbHNlKTtcblxuICAgICAgaWYgKCFldmVudC5zaGlmdEtleSAmJiBsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSAmJiAhcG9zc2libGVOb2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgcG9zc2libGVOb2RlLnNlbGVjdE5leHQoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9BUlJPV19MRUZUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24kMSA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24kMSkpIHtcbiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBvbiBhIG5vZGUsIGxldCdzIHRyeSBhbmQgbW92ZSBzZWxlY3Rpb25cbiAgICAgIC8vIGJhY2sgdG8gYmVpbmcgYSByYW5nZSBzZWxlY3Rpb24uXG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbiQxLmdldE5vZGVzKCk7XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG5vZGVzWzBdLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24kMSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0aW9uLiRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24oc2VsZWN0aW9uJDEsIHRydWUpKSB7XG4gICAgICBjb25zdCBpc0hvbGRpbmdTaGlmdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNlbGVjdGlvbi4kbW92ZUNoYXJhY3RlcihzZWxlY3Rpb24kMSwgaXNIb2xkaW5nU2hpZnQsIHRydWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9BUlJPV19SSUdIVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uJDEgPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uJDEpICYmICEkaXNUYXJnZXRXaXRoaW5EZWNvcmF0b3IoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgLy8gSWYgc2VsZWN0aW9uIGlzIG9uIGEgbm9kZSwgbGV0J3MgdHJ5IGFuZCBtb3ZlIHNlbGVjdGlvblxuICAgICAgLy8gYmFjayB0byBiZWluZyBhIHJhbmdlIHNlbGVjdGlvbi5cbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uJDEuZ2V0Tm9kZXMoKTtcblxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbm9kZXNbMF0uc2VsZWN0TmV4dCgwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbiQxKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGlzSG9sZGluZ1NoaWZ0ID0gZXZlbnQuc2hpZnRLZXk7XG5cbiAgICBpZiAoc2VsZWN0aW9uLiRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24oc2VsZWN0aW9uJDEsIGZhbHNlKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNlbGVjdGlvbi4kbW92ZUNoYXJhY3RlcihzZWxlY3Rpb24kMSwgaXNIb2xkaW5nU2hpZnQsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQkFDS1NQQUNFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBpZiAoJGlzVGFyZ2V0V2l0aGluRGVjb3JhdG9yKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuXG4gICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIGFuY2hvci5vZmZzZXQgPT09IDAgJiYgIWxleGljYWwuJGlzUm9vdE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlscy4kZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdyhhbmNob3JOb2RlKTtcblxuICAgICAgaWYgKGVsZW1lbnQuZ2V0SW5kZW50KCkgPiAwKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuT1VUREVOVF9DT05URU5UX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5ERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIHRydWUpO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9ERUxFVEVfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGlmICgkaXNUYXJnZXRXaXRoaW5EZWNvcmF0b3IoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBmYWxzZSk7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0VOVEVSX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGJlZm9yZWlucHV0LCB0aGVuIHdlIGNhbiBhdm9pZCBibG9ja2luZ1xuICAgICAgLy8gdGhlIGRlZmF1bHQgYmVoYXZpb3IuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBpT1MgY2FuXG4gICAgICAvLyBpbnRlcmNlcHQgdGhhdCB3ZSdyZSBhY3R1YWxseSBpbnNlcnRpbmcgYSBwYXJhZ3JhcGgsXG4gICAgICAvLyBhbmQgYXV0b2NvbXBsZXRlLCBhdXRvY2FwaXRhbGl6ZSBldGMgd29yayBhcyBpbnRlbmRlZC5cbiAgICAgIC8vIFRoaXMgY2FuIGFsc28gY2F1c2UgYSBzdHJhbmdlIHBlcmZvcm1hbmNlIGlzc3VlIGluXG4gICAgICAvLyBTYWZhcmksIHdoZXJlIHRoZXJlIGlzIGEgbm90aWNlYWJsZSBwYXVzZSBkdWUgdG9cbiAgICAgIC8vIHByZXZlbnRpbmcgdGhlIGtleSBkb3duIG9mIGVudGVyLlxuICAgICAgaWYgKChJU19JT1MgfHwgSVNfU0FGQVJJIHx8IElTX0FQUExFX1dFQktJVCkgJiYgQ0FOX1VTRV9CRUZPUkVfSU5QVVQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5JTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5JTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0VTQ0FQRV9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGVkaXRvci5ibHVyKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuRFJPUF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3QgWywgZmlsZXNdID0gZXZlbnRGaWxlcyhldmVudCk7XG5cbiAgICBpZiAoZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICBjb25zdCB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIGNvbnN0IGV2ZW50UmFuZ2UgPSBjYXJldEZyb21Qb2ludCh4LCB5KTtcblxuICAgICAgaWYgKGV2ZW50UmFuZ2UgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG9mZnNldDogZG9tT2Zmc2V0LFxuICAgICAgICAgIG5vZGU6IGRvbU5vZGVcbiAgICAgICAgfSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGRvbU5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKTtcblxuICAgICAgICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldChub2RlLmdldEtleSgpLCBkb21PZmZzZXQsICd0ZXh0Jyk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXMuc2V0KG5vZGUuZ2V0S2V5KCksIGRvbU9mZnNldCwgJ3RleHQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCkuZ2V0S2V5KCk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBub2RlLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyAxO1xuICAgICAgICAgICAgc2VsZWN0aW9uLmFuY2hvci5zZXQocGFyZW50S2V5LCBvZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXMuc2V0KHBhcmVudEtleSwgb2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTZWxlY3Rpb24gPSBsZXhpY2FsLiRub3JtYWxpemVTZWxlY3Rpb25fX0VYUEVSSU1FTlRBTChzZWxlY3Rpb24pO1xuICAgICAgICAgIGxleGljYWwuJHNldFNlbGVjdGlvbihub3JtYWxpemVkU2VsZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoRFJBR19EUk9QX1BBU1RFLCBmaWxlcyk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5EUkFHU1RBUlRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IFtpc0ZpbGVUcmFuc2Zlcl0gPSBldmVudEZpbGVzKGV2ZW50KTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChpc0ZpbGVUcmFuc2ZlciAmJiAhbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuRFJBR09WRVJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IFtpc0ZpbGVUcmFuc2Zlcl0gPSBldmVudEZpbGVzKGV2ZW50KTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChpc0ZpbGVUcmFuc2ZlciAmJiAhbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFg7XG4gICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFk7XG4gICAgY29uc3QgZXZlbnRSYW5nZSA9IGNhcmV0RnJvbVBvaW50KHgsIHkpO1xuXG4gICAgaWYgKGV2ZW50UmFuZ2UgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGV2ZW50UmFuZ2Uubm9kZSk7XG5cbiAgICAgIGlmIChsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUobm9kZSkpIHtcbiAgICAgICAgLy8gU2hvdyBicm93c2VyIGNhcmV0IGFzIHRoZSB1c2VyIGlzIGRyYWdnaW5nIHRoZSBtZWRpYSBhY3Jvc3MgdGhlIHNjcmVlbi4gV29uJ3Qgd29ya1xuICAgICAgICAvLyBmb3IgRGVjb3JhdG9yTm9kZSBub3IgaXQncyByZWxldmFudC5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5DT1BZX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjbGlwYm9hcmQuY29weVRvQ2xpcGJvYXJkKGVkaXRvciwgdXRpbHMub2JqZWN0S2xhc3NFcXVhbHMoZXZlbnQsIENsaXBib2FyZEV2ZW50KSA/IGV2ZW50IDogbnVsbCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuQ1VUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBvbkN1dEZvclJpY2hUZXh0KGV2ZW50LCBlZGl0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLlBBU1RFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBbLCBmaWxlcywgaGFzVGV4dENvbnRlbnRdID0gZXZlbnRGaWxlcyhldmVudCk7XG5cbiAgICBpZiAoZmlsZXMubGVuZ3RoID4gMCAmJiAhaGFzVGV4dENvbnRlbnQpIHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoRFJBR19EUk9QX1BBU1RFLCBmaWxlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIGlmIGlucHV0cyB0aGVuIHBhc3RlIHdpdGhpbiB0aGUgaW5wdXQgaWdub3JlIGNyZWF0aW5nIGEgbmV3IG5vZGUgb24gcGFzdGUgZXZlbnRcblxuXG4gICAgaWYgKGxleGljYWwuaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9ySW5wdXQoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBvblBhc3RlRm9yUmljaFRleHQoZXZlbnQsIGVkaXRvcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpKTtcbiAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xufVxuXG5leHBvcnRzLiRjcmVhdGVIZWFkaW5nTm9kZSA9ICRjcmVhdGVIZWFkaW5nTm9kZTtcbmV4cG9ydHMuJGNyZWF0ZVF1b3RlTm9kZSA9ICRjcmVhdGVRdW90ZU5vZGU7XG5leHBvcnRzLiRpc0hlYWRpbmdOb2RlID0gJGlzSGVhZGluZ05vZGU7XG5leHBvcnRzLiRpc1F1b3RlTm9kZSA9ICRpc1F1b3RlTm9kZTtcbmV4cG9ydHMuRFJBR19EUk9QX1BBU1RFID0gRFJBR19EUk9QX1BBU1RFO1xuZXhwb3J0cy5IZWFkaW5nTm9kZSA9IEhlYWRpbmdOb2RlO1xuZXhwb3J0cy5RdW90ZU5vZGUgPSBRdW90ZU5vZGU7XG5leHBvcnRzLmV2ZW50RmlsZXMgPSBldmVudEZpbGVzO1xuZXhwb3J0cy5yZWdpc3RlclJpY2hUZXh0ID0gcmVnaXN0ZXJSaWNoVGV4dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.js":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/rich-text/LexicalRichText.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalRichText =  true ? __webpack_require__(/*! ./LexicalRichText.dev.js */ \"(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.dev.js\") : 0\nmodule.exports = LexicalRichText;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmljaC10ZXh0L0xleGljYWxSaWNoVGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLHdCQUF3QixLQUFzQyxHQUFHLG1CQUFPLENBQUMsZ0dBQTBCLElBQUksQ0FBb0M7QUFDM0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yaWNoLXRleHQvTGV4aWNhbFJpY2hUZXh0LmpzP2U3ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxSaWNoVGV4dCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsUmljaFRleHQuZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxSaWNoVGV4dC5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbFJpY2hUZXh0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.dev.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n\n    node = node.firstChild;\n  }\n\n  return null;\n}\n\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\n\n\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n\n  if (lexical.$isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n\n  if (lexical.$isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n\n  const firstChild = anchorDOM.firstChild;\n\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n\n  return range;\n}\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\n\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n\n  if (rootElement === null) {\n    return [];\n  }\n\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length; //sort rects from top left to bottom right.\n\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top; // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n\n    return top;\n  });\n  let prevRect;\n\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i]; // Exclude rects that overlap preceding Rects in the sorted list.\n\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left; // Exclude selections that span the entire element\n\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n\n    prevRect = selectionRect;\n  }\n\n  return selectionRects;\n}\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\n\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n\n      styleObject[key.trim()] = value.trim();\n    }\n  }\n\n  return styleObject;\n}\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\n\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n\n  return value;\n}\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\n\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $updateElementNodeProperties(target, source) {\n  target.__first = source.__first;\n  target.__last = source.__last;\n  target.__size = source.__size;\n  target.__format = source.__format;\n  target.__indent = source.__indent;\n  target.__dir = source.__dir;\n  return target;\n}\n\nfunction $updateTextNodeProperties(target, source) {\n  target.__format = source.__format;\n  target.__style = source.__style;\n  target.__mode = source.__mode;\n  target.__detail = source.__detail;\n  return target;\n}\n/**\n * Returns a copy of a node, but generates a new key for the copy.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\n\n\nfunction $cloneWithProperties(node) {\n  const latest = node.getLatest();\n  const constructor = latest.constructor; // @ts-expect-error\n\n  const clone = constructor.clone(latest);\n  clone.__parent = latest.__parent;\n  clone.__next = latest.__next;\n  clone.__prev = latest.__prev;\n\n  if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {\n    return $updateElementNodeProperties(clone, latest);\n  }\n\n  if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {\n    return $updateTextNodeProperties(clone, latest);\n  }\n\n  return clone;\n}\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\n\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n\n    if (isAnchor || isFocus) {\n      const isBackward = selection.isBackward();\n      const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n\n  return textNode;\n}\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\n\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n\n  return point.offset === point.getNode().getChildrenSize();\n}\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\n\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n\n  if (lexical.$isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n\n  while (remaining > 0 && currentNode !== null) {\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n\n      while (parentSibling === null) {\n        parent = parent.getParent();\n\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n\n        parentSibling = parent.getPreviousSibling();\n      }\n\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n\n        if (lexical.$isElementNode(parentSibling)) {\n          nextNode = parentSibling.getLastDescendant();\n        } else {\n          nextNode = parentSibling;\n        }\n      }\n    }\n\n    let text = currentNode.getTextContent(); // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n\n    if (text === '' && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n\n    const currentNodeSize = currentNode.getTextContentSize();\n\n    if (!lexical.$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n\n      if (parent != null && parent.getChildrenSize() === 0 && !lexical.$isRootNode(parent)) {\n        parent.remove();\n      }\n\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey(); // See if we can just revert it to what was in the last editor state\n\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = lexical.$getNodeByKey(key);\n\n        if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = lexical.$getPreviousSelection();\n        let target = currentNode;\n\n        if (!currentNode.isSimpleText()) {\n          const textNode = lexical.$createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n\n        if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset; // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = lexical.$createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n\n      remaining = 0;\n    }\n  }\n}\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\n\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n\n    return styles;\n  }, { ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. { CSSProperty: value }\n */\n\n\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n\n  if (selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key; // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n\n  if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n\n    if (lexical.$isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  } // This is the case where we only selected a single node\n\n\n  if (selectedNodes.length === 1) {\n    if (lexical.$isTextNode(firstNode)) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset; // No actual text is selected, so do nothing.\n\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n\n  } else {\n    if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n      }\n\n      $patchStyle(firstNode, patch);\n    }\n\n    if (lexical.$isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length; // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      } // if the entire last node isn't selected, split it\n\n\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n\n      if (endOffset !== 0) {\n        $patchStyle(lastNode, patch);\n      }\n    } // style all the text nodes in between\n\n\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n\n      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\n\nfunction $setBlocksType(selection, createElement) {\n  if (selection.anchor.key === 'root') {\n    const element = createElement();\n    const root = lexical.$getRoot();\n    const firstChild = root.getFirstChild();\n\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n\n    return;\n  }\n\n  const nodes = selection.getNodes();\n  let maybeBlock = selection.anchor.getNode().getParentOrThrow();\n\n  if (nodes.indexOf(maybeBlock) === -1) {\n    nodes.push(maybeBlock);\n  }\n\n  if (maybeBlock.isInline()) {\n    maybeBlock = maybeBlock.getParentOrThrow();\n\n    if (nodes.indexOf(maybeBlock) === -1) {\n      nodes.push(maybeBlock);\n    }\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (!isBlock(node)) {\n      continue;\n    }\n\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\n\nfunction isBlock(node) {\n  if (!lexical.$isElementNode(node) || lexical.$isRootOrShadowRoot(node)) {\n    return false;\n  }\n\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || lexical.$isLineBreakNode(firstChild) || lexical.$isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\n\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\n\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n\n  while (node !== null && !lexical.$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n\n    node = parentNode;\n  }\n}\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\n\n\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  const anchor = selection.anchor;\n\n  if (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n\n    target.replace(element);\n    return;\n  }\n\n  let topLevelNode = null;\n  let descendants = [];\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i]; // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n\n    if (lexical.$isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\n\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = []; // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n\n  let targetIsPrevSibling = false;\n\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n\n    target = target.getParentOrThrow();\n\n    if (lexical.$isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n\n  const emptyElements = new Set(); // Find any top level empty elements\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n\n  const movedNodes = new Set(); // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n\n    if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement); // Move node and its siblings to the new\n        // element.\n\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n\n          if (lexical.$isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n\n  let lastElement = null; // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n\n  if (lexical.$isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n\n      if (lexical.$isElementNode(firstChild)) {\n        target = firstChild;\n      }\n\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n\n  const prevSelection = lexical.$getPreviousSelection();\n\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    lexical.$setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\n\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\n\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\n\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\n\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n/**\n * Expands the current Selection to cover all of the content in the editor.\n * @param selection - The current selection.\n */\n\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n\n  if (lexical.$isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n\n  if (lexical.$isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\n\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n\n  return defaultValue;\n}\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\n\n\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n\n  if (selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]; // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n\n    if (lexical.$isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n\n  return styleValue === null ? defaultValue : styleValue;\n}\n\nexports.$addNodeStyle = $addNodeStyle;\nexports.$cloneWithProperties = $cloneWithProperties;\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\nexports.$isAtNodeEnd = $isAtNodeEnd;\nexports.$isParentElementRTL = $isParentElementRTL;\nexports.$moveCaretSelection = $moveCaretSelection;\nexports.$moveCharacter = $moveCharacter;\nexports.$patchStyleText = $patchStyleText;\nexports.$selectAll = $selectAll;\nexports.$setBlocksType = $setBlocksType;\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\nexports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;\nexports.$wrapNodes = $wrapNodes;\nexports.createDOMRange = createDOMRange;\nexports.createRectsFromDOMRange = createRectsFromDOMRange;\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\nexports.trimTextContentFromAnchor = trimTextContentFromAnchor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyx3REFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGtCQUFrQiwwQkFBMEI7QUFDNUMsNkNBQTZDOztBQUU3QywwTEFBMEw7O0FBRTFMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTSxJQUFJLGVBQWU7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTix3Q0FBd0M7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsR0FBRyxJQUFJO0FBQ1AsSUFBSSxLQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLHlIQUF5SDs7QUFFekg7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR04sb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DOztBQUVuQyxrQkFBa0IsaUJBQWlCO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEMsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQiw0QkFBNEI7QUFDNUIsMENBQTBDO0FBQzFDLG9CQUFvQjtBQUNwQiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCLHNCQUFzQjtBQUN0QixnREFBZ0Q7QUFDaEQscUNBQXFDO0FBQ3JDLGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEIsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3QixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9zZWxlY3Rpb24vTGV4aWNhbFNlbGVjdGlvbi5kZXYuanM/MDQ0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENTU19UT19TVFlMRVMgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gZ2V0RE9NVGV4dE5vZGUoZWxlbWVudCkge1xuICBsZXQgbm9kZSA9IGVsZW1lbnQ7XG5cbiAgd2hpbGUgKG5vZGUgIT0gbnVsbCkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRET01JbmRleFdpdGhpblBhcmVudChub2RlKSB7XG4gIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcblxuICBpZiAocGFyZW50ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBuZXZlciBoYXBwZW4nKTtcbiAgfVxuXG4gIHJldHVybiBbcGFyZW50LCBBcnJheS5mcm9tKHBhcmVudC5jaGlsZE5vZGVzKS5pbmRleE9mKG5vZGUpXTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHNlbGVjdGlvbiByYW5nZSBmb3IgdGhlIERPTS5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gYW5jaG9yTm9kZSAtIFRoZSBhbmNob3Igbm9kZSBvZiBhIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBfYW5jaG9yT2Zmc2V0IC0gVGhlIGFtb3VudCBvZiBzcGFjZSBvZmZzZXQgZnJvbSB0aGUgYW5jaG9yIHRvIHRoZSBmb2N1cy5cbiAqIEBwYXJhbSBmb2N1c05vZGUgLSBUaGUgY3VycmVudCBmb2N1cy5cbiAqIEBwYXJhbSBfZm9jdXNPZmZzZXQgLSBUaGUgYW1vdW50IG9mIHNwYWNlIG9mZnNldCBmcm9tIHRoZSBmb2N1cyB0byB0aGUgYW5jaG9yLlxuICogQHJldHVybnMgVGhlIHJhbmdlIG9mIHNlbGVjdGlvbiBmb3IgdGhlIERPTSB0aGF0IHdhcyBjcmVhdGVkLlxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRE9NUmFuZ2UoZWRpdG9yLCBhbmNob3JOb2RlLCBfYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIF9mb2N1c09mZnNldCkge1xuICBjb25zdCBhbmNob3JLZXkgPSBhbmNob3JOb2RlLmdldEtleSgpO1xuICBjb25zdCBmb2N1c0tleSA9IGZvY3VzTm9kZS5nZXRLZXkoKTtcbiAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBsZXQgYW5jaG9yRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JLZXkpO1xuICBsZXQgZm9jdXNET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGZvY3VzS2V5KTtcbiAgbGV0IGFuY2hvck9mZnNldCA9IF9hbmNob3JPZmZzZXQ7XG4gIGxldCBmb2N1c09mZnNldCA9IF9mb2N1c09mZnNldDtcblxuICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgIGFuY2hvckRPTSA9IGdldERPTVRleHROb2RlKGFuY2hvckRPTSk7XG4gIH1cblxuICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShmb2N1c05vZGUpKSB7XG4gICAgZm9jdXNET00gPSBnZXRET01UZXh0Tm9kZShmb2N1c0RPTSk7XG4gIH1cblxuICBpZiAoYW5jaG9yTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGZvY3VzTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGFuY2hvckRPTSA9PT0gbnVsbCB8fCBmb2N1c0RPTSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGFuY2hvckRPTS5ub2RlTmFtZSA9PT0gJ0JSJykge1xuICAgIFthbmNob3JET00sIGFuY2hvck9mZnNldF0gPSBnZXRET01JbmRleFdpdGhpblBhcmVudChhbmNob3JET00pO1xuICB9XG5cbiAgaWYgKGZvY3VzRE9NLm5vZGVOYW1lID09PSAnQlInKSB7XG4gICAgW2ZvY3VzRE9NLCBmb2N1c09mZnNldF0gPSBnZXRET01JbmRleFdpdGhpblBhcmVudChmb2N1c0RPTSk7XG4gIH1cblxuICBjb25zdCBmaXJzdENoaWxkID0gYW5jaG9yRE9NLmZpcnN0Q2hpbGQ7XG5cbiAgaWYgKGFuY2hvckRPTSA9PT0gZm9jdXNET00gJiYgZmlyc3RDaGlsZCAhPSBudWxsICYmIGZpcnN0Q2hpbGQubm9kZU5hbWUgPT09ICdCUicgJiYgYW5jaG9yT2Zmc2V0ID09PSAwICYmIGZvY3VzT2Zmc2V0ID09PSAwKSB7XG4gICAgZm9jdXNPZmZzZXQgPSAxO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByYW5nZS5zZXRTdGFydChhbmNob3JET00sIGFuY2hvck9mZnNldCk7XG4gICAgcmFuZ2Uuc2V0RW5kKGZvY3VzRE9NLCBmb2N1c09mZnNldCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChyYW5nZS5jb2xsYXBzZWQgJiYgKGFuY2hvck9mZnNldCAhPT0gZm9jdXNPZmZzZXQgfHwgYW5jaG9yS2V5ICE9PSBmb2N1c0tleSkpIHtcbiAgICAvLyBSYW5nZSBpcyBiYWNrd2FyZHMsIHdlIG5lZWQgdG8gcmV2ZXJzZSBpdFxuICAgIHJhbmdlLnNldFN0YXJ0KGZvY3VzRE9NLCBmb2N1c09mZnNldCk7XG4gICAgcmFuZ2Uuc2V0RW5kKGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiByYW5nZTtcbn1cbi8qKlxuICogQ3JlYXRlcyBET01SZWN0cywgZ2VuZXJhbGx5IHVzZWQgdG8gaGVscCB0aGUgZWRpdG9yIGZpbmQgYSBzcGVjaWZpYyBsb2NhdGlvbiBvbiB0aGUgc2NyZWVuLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIHJhbmdlIC0gQSBmcmFnbWVudCBvZiBhIGRvY3VtZW50IHRoYXQgY2FuIGNvbnRhaW4gbm9kZXMgYW5kIHBhcnRzIG9mIHRleHQgbm9kZXMuXG4gKiBAcmV0dXJucyBUaGUgc2VsZWN0aW9uUmVjdHMgYXMgYW4gYXJyYXkuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuXG4gIGlmIChyb290RWxlbWVudCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHJvb3RSZWN0ID0gcm9vdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHJvb3RFbGVtZW50KTtcbiAgY29uc3Qgcm9vdFBhZGRpbmcgPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCk7XG4gIGNvbnN0IHNlbGVjdGlvblJlY3RzID0gQXJyYXkuZnJvbShyYW5nZS5nZXRDbGllbnRSZWN0cygpKTtcbiAgbGV0IHNlbGVjdGlvblJlY3RzTGVuZ3RoID0gc2VsZWN0aW9uUmVjdHMubGVuZ3RoOyAvL3NvcnQgcmVjdHMgZnJvbSB0b3AgbGVmdCB0byBib3R0b20gcmlnaHQuXG5cbiAgc2VsZWN0aW9uUmVjdHMuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHRvcCA9IGEudG9wIC0gYi50b3A7IC8vIFNvbWUgcmVjdHMgbWF0Y2ggcG9zaXRpb24gY2xvc2VseSwgYnV0IG5vdCBwZXJmZWN0bHksXG4gICAgLy8gc28gd2UgZ2l2ZSBhIDNweCB0b2xlcmFuY2UuXG5cbiAgICBpZiAoTWF0aC5hYnModG9wKSA8PSAzKSB7XG4gICAgICByZXR1cm4gYS5sZWZ0IC0gYi5sZWZ0O1xuICAgIH1cblxuICAgIHJldHVybiB0b3A7XG4gIH0pO1xuICBsZXQgcHJldlJlY3Q7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb25SZWN0c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uUmVjdCA9IHNlbGVjdGlvblJlY3RzW2ldOyAvLyBFeGNsdWRlIHJlY3RzIHRoYXQgb3ZlcmxhcCBwcmVjZWRpbmcgUmVjdHMgaW4gdGhlIHNvcnRlZCBsaXN0LlxuXG4gICAgY29uc3QgaXNPdmVybGFwcGluZ1JlY3QgPSBwcmV2UmVjdCAmJiBwcmV2UmVjdC50b3AgPD0gc2VsZWN0aW9uUmVjdC50b3AgJiYgcHJldlJlY3QudG9wICsgcHJldlJlY3QuaGVpZ2h0ID4gc2VsZWN0aW9uUmVjdC50b3AgJiYgcHJldlJlY3QubGVmdCArIHByZXZSZWN0LndpZHRoID4gc2VsZWN0aW9uUmVjdC5sZWZ0OyAvLyBFeGNsdWRlIHNlbGVjdGlvbnMgdGhhdCBzcGFuIHRoZSBlbnRpcmUgZWxlbWVudFxuXG4gICAgY29uc3Qgc2VsZWN0aW9uU3BhbnNFbGVtZW50ID0gc2VsZWN0aW9uUmVjdC53aWR0aCArIHJvb3RQYWRkaW5nID09PSByb290UmVjdC53aWR0aDtcblxuICAgIGlmIChpc092ZXJsYXBwaW5nUmVjdCB8fCBzZWxlY3Rpb25TcGFuc0VsZW1lbnQpIHtcbiAgICAgIHNlbGVjdGlvblJlY3RzLnNwbGljZShpLS0sIDEpO1xuICAgICAgc2VsZWN0aW9uUmVjdHNMZW5ndGgtLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHByZXZSZWN0ID0gc2VsZWN0aW9uUmVjdDtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb25SZWN0cztcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHN0eWxlcyBhbmQgdGhlaXIgdmFsdWVzIHByb3ZpZGVkIGluIHRoZSBDU1Mgc3RyaW5nLlxuICogQHBhcmFtIGNzcyAtIFRoZSBDU1Mgc3RyaW5nIG9mIHN0eWxlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICogQHJldHVybnMgVGhlIHN0eWxlT2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRTdHlsZU9iamVjdEZyb21SYXdDU1MoY3NzKSB7XG4gIGNvbnN0IHN0eWxlT2JqZWN0ID0ge307XG4gIGNvbnN0IHN0eWxlcyA9IGNzcy5zcGxpdCgnOycpO1xuXG4gIGZvciAoY29uc3Qgc3R5bGUgb2Ygc3R5bGVzKSB7XG4gICAgaWYgKHN0eWxlICE9PSAnJykge1xuICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gc3R5bGUuc3BsaXQoLzooW15dKykvKTsgLy8gc3BsaXQgb24gZmlyc3QgY29sb25cblxuICAgICAgc3R5bGVPYmplY3Rba2V5LnRyaW0oKV0gPSB2YWx1ZS50cmltKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0eWxlT2JqZWN0O1xufVxuLyoqXG4gKiBHaXZlbiBhIENTUyBzdHJpbmcsIHJldHVybnMgYW4gb2JqZWN0IGZyb20gdGhlIHN0eWxlIGNhY2hlLlxuICogQHBhcmFtIGNzcyAtIFRoZSBDU1MgcHJvcGVydHkgYXMgYSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIGdpdmVuIENTUyBwcm9wZXJ0eS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRTdHlsZU9iamVjdEZyb21DU1MoY3NzKSB7XG4gIGxldCB2YWx1ZSA9IENTU19UT19TVFlMRVMuZ2V0KGNzcyk7XG5cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFN0eWxlT2JqZWN0RnJvbVJhd0NTUyhjc3MpO1xuICAgIENTU19UT19TVFlMRVMuc2V0KGNzcywgdmFsdWUpO1xuICB9XG5cbiAge1xuICAgIC8vIEZyZWV6ZSB0aGUgdmFsdWUgaW4gREVWIHRvIHByZXZlbnQgYWNjaWRlbnRhbCBtdXRhdGlvbnNcbiAgICBPYmplY3QuZnJlZXplKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogR2V0cyB0aGUgQ1NTIHN0eWxlcyBmcm9tIHRoZSBzdHlsZSBvYmplY3QuXG4gKiBAcGFyYW0gc3R5bGVzIC0gVGhlIHN0eWxlIG9iamVjdCBjb250YWluaW5nIHRoZSBzdHlsZXMgdG8gZ2V0LlxuICogQHJldHVybnMgQSBzdHJpbmcgY29udGFpbmluZyB0aGUgQ1NTIHN0eWxlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIGdldENTU0Zyb21TdHlsZU9iamVjdChzdHlsZXMpIHtcbiAgbGV0IGNzcyA9ICcnO1xuXG4gIGZvciAoY29uc3Qgc3R5bGUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBjc3MgKz0gYCR7c3R5bGV9OiAke3N0eWxlc1tzdHlsZV19O2A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNzcztcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiAkdXBkYXRlRWxlbWVudE5vZGVQcm9wZXJ0aWVzKHRhcmdldCwgc291cmNlKSB7XG4gIHRhcmdldC5fX2ZpcnN0ID0gc291cmNlLl9fZmlyc3Q7XG4gIHRhcmdldC5fX2xhc3QgPSBzb3VyY2UuX19sYXN0O1xuICB0YXJnZXQuX19zaXplID0gc291cmNlLl9fc2l6ZTtcbiAgdGFyZ2V0Ll9fZm9ybWF0ID0gc291cmNlLl9fZm9ybWF0O1xuICB0YXJnZXQuX19pbmRlbnQgPSBzb3VyY2UuX19pbmRlbnQ7XG4gIHRhcmdldC5fX2RpciA9IHNvdXJjZS5fX2RpcjtcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gJHVwZGF0ZVRleHROb2RlUHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSkge1xuICB0YXJnZXQuX19mb3JtYXQgPSBzb3VyY2UuX19mb3JtYXQ7XG4gIHRhcmdldC5fX3N0eWxlID0gc291cmNlLl9fc3R5bGU7XG4gIHRhcmdldC5fX21vZGUgPSBzb3VyY2UuX19tb2RlO1xuICB0YXJnZXQuX19kZXRhaWwgPSBzb3VyY2UuX19kZXRhaWw7XG4gIHJldHVybiB0YXJnZXQ7XG59XG4vKipcbiAqIFJldHVybnMgYSBjb3B5IG9mIGEgbm9kZSwgYnV0IGdlbmVyYXRlcyBhIG5ldyBrZXkgZm9yIHRoZSBjb3B5LlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjbG9uZWQuXG4gKiBAcmV0dXJucyBUaGUgY2xvbmUgb2YgdGhlIG5vZGUuXG4gKi9cblxuXG5mdW5jdGlvbiAkY2xvbmVXaXRoUHJvcGVydGllcyhub2RlKSB7XG4gIGNvbnN0IGxhdGVzdCA9IG5vZGUuZ2V0TGF0ZXN0KCk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gbGF0ZXN0LmNvbnN0cnVjdG9yOyAvLyBAdHMtZXhwZWN0LWVycm9yXG5cbiAgY29uc3QgY2xvbmUgPSBjb25zdHJ1Y3Rvci5jbG9uZShsYXRlc3QpO1xuICBjbG9uZS5fX3BhcmVudCA9IGxhdGVzdC5fX3BhcmVudDtcbiAgY2xvbmUuX19uZXh0ID0gbGF0ZXN0Ll9fbmV4dDtcbiAgY2xvbmUuX19wcmV2ID0gbGF0ZXN0Ll9fcHJldjtcblxuICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShsYXRlc3QpICYmIGxleGljYWwuJGlzRWxlbWVudE5vZGUoY2xvbmUpKSB7XG4gICAgcmV0dXJuICR1cGRhdGVFbGVtZW50Tm9kZVByb3BlcnRpZXMoY2xvbmUsIGxhdGVzdCk7XG4gIH1cblxuICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShsYXRlc3QpICYmIGxleGljYWwuJGlzVGV4dE5vZGUoY2xvbmUpKSB7XG4gICAgcmV0dXJuICR1cGRhdGVUZXh0Tm9kZVByb3BlcnRpZXMoY2xvbmUsIGxhdGVzdCk7XG4gIH1cblxuICByZXR1cm4gY2xvbmU7XG59XG4vKipcbiAqIEdlbmVyYWxseSB1c2VkIHRvIGFwcGVuZCB0ZXh0IGNvbnRlbnQgdG8gSFRNTCBhbmQgSlNPTi4gR3JhYnMgdGhlIHRleHQgY29udGVudCBhbmQgXCJzbGljZXNcIlxuICogaXQgdG8gYmUgZ2VuZXJhdGVkIGludG8gdGhlIG5ldyBUZXh0Tm9kZS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIGNvbnRhaW5pbmcgdGhlIG5vZGUgd2hvc2UgVGV4dE5vZGUgaXMgdG8gYmUgZWRpdGVkLlxuICogQHBhcmFtIHRleHROb2RlIC0gVGhlIFRleHROb2RlIHRvIGJlIGVkaXRlZC5cbiAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIFRleHROb2RlLlxuICovXG5cbmZ1bmN0aW9uICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50KHNlbGVjdGlvbiwgdGV4dE5vZGUpIHtcbiAgaWYgKHRleHROb2RlLmlzU2VsZWN0ZWQoKSAmJiAhdGV4dE5vZGUuaXNTZWdtZW50ZWQoKSAmJiAhdGV4dE5vZGUuaXNUb2tlbigpICYmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgICBjb25zdCBpc0FuY2hvciA9IHRleHROb2RlLmlzKGFuY2hvck5vZGUpO1xuICAgIGNvbnN0IGlzRm9jdXMgPSB0ZXh0Tm9kZS5pcyhmb2N1c05vZGUpO1xuXG4gICAgaWYgKGlzQW5jaG9yIHx8IGlzRm9jdXMpIHtcbiAgICAgIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICAgICAgY29uc3QgW2FuY2hvck9mZnNldCwgZm9jdXNPZmZzZXRdID0gc2VsZWN0aW9uLmdldENoYXJhY3Rlck9mZnNldHMoKTtcbiAgICAgIGNvbnN0IGlzU2FtZSA9IGFuY2hvck5vZGUuaXMoZm9jdXNOb2RlKTtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSB0ZXh0Tm9kZS5pcyhpc0JhY2t3YXJkID8gZm9jdXNOb2RlIDogYW5jaG9yTm9kZSk7XG4gICAgICBjb25zdCBpc0xhc3QgPSB0ZXh0Tm9kZS5pcyhpc0JhY2t3YXJkID8gYW5jaG9yTm9kZSA6IGZvY3VzTm9kZSk7XG4gICAgICBsZXQgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgbGV0IGVuZE9mZnNldCA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGlzU2FtZSkge1xuICAgICAgICBzdGFydE9mZnNldCA9IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgICAgIGVuZE9mZnNldCA9IGFuY2hvck9mZnNldCA+IGZvY3VzT2Zmc2V0ID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gICAgICB9IGVsc2UgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBzdGFydE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgZW5kT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChpc0xhc3QpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICAgIGVuZE9mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cblxuICAgICAgdGV4dE5vZGUuX190ZXh0ID0gdGV4dE5vZGUuX190ZXh0LnNsaWNlKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgcmV0dXJuIHRleHROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0ZXh0Tm9kZTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgYXQgdGhlIGVuZCBvZiB0aGUgbm9kZS5cbiAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCBvZiB0aGUgc2VsZWN0aW9uIHRvIHRlc3QuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBwb2ludCBvZmZzZXQgaXMgaW4gdGhlIGxhc3QgcG9zc2libGUgcG9zaXRpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiAkaXNBdE5vZGVFbmQocG9pbnQpIHtcbiAgaWYgKHBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IHBvaW50LmdldE5vZGUoKS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludC5vZmZzZXQgPT09IHBvaW50LmdldE5vZGUoKS5nZXRDaGlsZHJlblNpemUoKTtcbn1cbi8qKlxuICogVHJpbXMgdGV4dCBmcm9tIGEgbm9kZSBpbiBvcmRlciB0byBzaG9ydGVuIGl0LCBlZy4gdG8gZW5mb3JjZSBhIHRleHQncyBtYXggbGVuZ3RoLiBJZiBpdCBkZWxldGVzIHRleHRcbiAqIHRoYXQgaXMgYW4gYW5jZXN0b3Igb2YgdGhlIGFuY2hvciB0aGVuIGl0IHdpbGwgbGVhdmUgMiBpbmRlbnRzLCBvdGhlcndpc2UsIGlmIG5vIHRleHQgY29udGVudCBleGlzdHMsIGl0IGRlbGV0ZXNcbiAqIHRoZSBUZXh0Tm9kZS4gSXQgd2lsbCBtb3ZlIHRoZSBmb2N1cyB0byBlaXRoZXIgdGhlIGVuZCBvZiBhbnkgbGVmdCBvdmVyIHRleHQgb3IgYmVnaW5uaW5nIG9mIGEgbmV3IFRleHROb2RlLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBhbmNob3IgLSBUaGUgYW5jaG9yIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiwgd2hlcmUgdGhlIHNlbGVjdGlvbiBzaG91bGQgYmUgcG9pbnRpbmcuXG4gKiBAcGFyYW0gZGVsQ291bnQgLSBUaGUgYW1vdW50IG9mIGNoYXJhY3RlcnMgdG8gZGVsZXRlLiBVc2VmdWwgYXMgYSBkeW5hbWljIHZhcmlhYmxlIGVnLiB0ZXh0Q29udGVudFNpemUgLSBtYXhMZW5ndGg7XG4gKi9cblxuZnVuY3Rpb24gdHJpbVRleHRDb250ZW50RnJvbUFuY2hvcihlZGl0b3IsIGFuY2hvciwgZGVsQ291bnQpIHtcbiAgLy8gV29yayBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBhbmNob3IgcG9pbnRcbiAgbGV0IGN1cnJlbnROb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgbGV0IHJlbWFpbmluZyA9IGRlbENvdW50O1xuXG4gIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSkge1xuICAgIGNvbnN0IGRlc2NlbmRhbnROb2RlID0gY3VycmVudE5vZGUuZ2V0RGVzY2VuZGFudEJ5SW5kZXgoYW5jaG9yLm9mZnNldCk7XG5cbiAgICBpZiAoZGVzY2VuZGFudE5vZGUgIT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnROb2RlID0gZGVzY2VuZGFudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKHJlbWFpbmluZyA+IDAgJiYgY3VycmVudE5vZGUgIT09IG51bGwpIHtcbiAgICBsZXQgbmV4dE5vZGUgPSBjdXJyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBsZXQgYWRkaXRpb25hbEVsZW1lbnRXaGl0ZXNwYWNlID0gMDtcblxuICAgIGlmIChuZXh0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgbGV0IHBhcmVudCA9IGN1cnJlbnROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGxldCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpO1xuXG4gICAgICB3aGlsZSAocGFyZW50U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIG5leHROb2RlID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgYWRkaXRpb25hbEVsZW1lbnRXaGl0ZXNwYWNlID0gcGFyZW50LmlzSW5saW5lKCkgPyAwIDogMjtcblxuICAgICAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShwYXJlbnRTaWJsaW5nKSkge1xuICAgICAgICAgIG5leHROb2RlID0gcGFyZW50U2libGluZy5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHROb2RlID0gcGFyZW50U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0ZXh0ID0gY3VycmVudE5vZGUuZ2V0VGV4dENvbnRlbnQoKTsgLy8gSWYgdGhlIHRleHQgaXMgZW1wdHksIHdlIG5lZWQgdG8gY29uc2lkZXIgYWRkaW5nIGluIHR3byBsaW5lIGJyZWFrcyB0byBtYXRjaFxuICAgIC8vIHRoZSBjb250ZW50IGlmIHdlIHdlcmUgdG8gZ2V0IGl0IGZyb20gaXRzIHBhcmVudC5cblxuICAgIGlmICh0ZXh0ID09PSAnJyAmJiBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiAhY3VycmVudE5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgYmUgaGFuZGxlZCBpbiBjb3JlP1xuICAgICAgdGV4dCA9ICdcXG5cXG4nO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnROb2RlU2l6ZSA9IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1RleHROb2RlKGN1cnJlbnROb2RlKSB8fCByZW1haW5pbmcgPj0gY3VycmVudE5vZGVTaXplKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGN1cnJlbnROb2RlLnJlbW92ZSgpO1xuXG4gICAgICBpZiAocGFyZW50ICE9IG51bGwgJiYgcGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID09PSAwICYmICFsZXhpY2FsLiRpc1Jvb3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50LnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICByZW1haW5pbmcgLT0gY3VycmVudE5vZGVTaXplICsgYWRkaXRpb25hbEVsZW1lbnRXaGl0ZXNwYWNlO1xuICAgICAgY3VycmVudE5vZGUgPSBuZXh0Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5ID0gY3VycmVudE5vZGUuZ2V0S2V5KCk7IC8vIFNlZSBpZiB3ZSBjYW4ganVzdCByZXZlcnQgaXQgdG8gd2hhdCB3YXMgaW4gdGhlIGxhc3QgZWRpdG9yIHN0YXRlXG5cbiAgICAgIGNvbnN0IHByZXZUZXh0Q29udGVudCA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoKCkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2Tm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleShrZXkpO1xuXG4gICAgICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKHByZXZOb2RlKSAmJiBwcmV2Tm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgICAgIHJldHVybiBwcmV2Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGN1cnJlbnROb2RlU2l6ZSAtIHJlbWFpbmluZztcbiAgICAgIGNvbnN0IHNsaWNlZFRleHQgPSB0ZXh0LnNsaWNlKDAsIG9mZnNldCk7XG5cbiAgICAgIGlmIChwcmV2VGV4dENvbnRlbnQgIT09IG51bGwgJiYgcHJldlRleHRDb250ZW50ICE9PSB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gY3VycmVudE5vZGU7XG5cbiAgICAgICAgaWYgKCFjdXJyZW50Tm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gbGV4aWNhbC4kY3JlYXRlVGV4dE5vZGUocHJldlRleHRDb250ZW50KTtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgICAgICB0YXJnZXQgPSB0ZXh0Tm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRUZXh0Q29udGVudChwcmV2VGV4dENvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgcHJldlNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgICAgY29uc3QgcHJldk9mZnNldCA9IHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgICAgICAgICB0YXJnZXQuc2VsZWN0KHByZXZPZmZzZXQsIHByZXZPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnROb2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICAgIC8vIFNwbGl0IHRleHRcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IGFuY2hvci5rZXkgPT09IGtleTtcbiAgICAgICAgbGV0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7IC8vIE1vdmUgb2Zmc2V0IHRvIGVuZCBpZiBpdCdzIGxlc3MgdGhhbiB0aGUgcmVtYWluaW5nIG51bWJlciwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIHdlJ2xsIGhhdmUgYSBuZWdhdGl2ZSBzcGxpdFN0YXJ0LlxuXG4gICAgICAgIGlmIChhbmNob3JPZmZzZXQgPCByZW1haW5pbmcpIHtcbiAgICAgICAgICBhbmNob3JPZmZzZXQgPSBjdXJyZW50Tm9kZVNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzcGxpdFN0YXJ0ID0gaXNTZWxlY3RlZCA/IGFuY2hvck9mZnNldCAtIHJlbWFpbmluZyA6IDA7XG4gICAgICAgIGNvbnN0IHNwbGl0RW5kID0gaXNTZWxlY3RlZCA/IGFuY2hvck9mZnNldCA6IG9mZnNldDtcblxuICAgICAgICBpZiAoaXNTZWxlY3RlZCAmJiBzcGxpdFN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgW2V4Y2Vzc05vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KHNwbGl0U3RhcnQsIHNwbGl0RW5kKTtcbiAgICAgICAgICBleGNlc3NOb2RlLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IFssIGV4Y2Vzc05vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KHNwbGl0U3RhcnQsIHNwbGl0RW5kKTtcbiAgICAgICAgICBleGNlc3NOb2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IGxleGljYWwuJGNyZWF0ZVRleHROb2RlKHNsaWNlZFRleHQpO1xuICAgICAgICBjdXJyZW50Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgIH1cblxuICAgICAgcmVtYWluaW5nID0gMDtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2V0cyB0aGUgVGV4dE5vZGUncyBzdHlsZSBvYmplY3QgYW5kIGFkZHMgdGhlIHN0eWxlcyB0byB0aGUgQ1NTLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgVGV4dE5vZGUgdG8gYWRkIHN0eWxlcyB0by5cbiAqL1xuXG5mdW5jdGlvbiAkYWRkTm9kZVN0eWxlKG5vZGUpIHtcbiAgY29uc3QgQ1NTVGV4dCA9IG5vZGUuZ2V0U3R5bGUoKTtcbiAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVPYmplY3RGcm9tUmF3Q1NTKENTU1RleHQpO1xuICBDU1NfVE9fU1RZTEVTLnNldChDU1NUZXh0LCBzdHlsZXMpO1xufVxuXG5mdW5jdGlvbiAkcGF0Y2hTdHlsZSh0YXJnZXQsIHBhdGNoKSB7XG4gIGNvbnN0IHByZXZTdHlsZXMgPSBnZXRTdHlsZU9iamVjdEZyb21DU1MoJ2dldFN0eWxlJyBpbiB0YXJnZXQgPyB0YXJnZXQuZ2V0U3R5bGUoKSA6IHRhcmdldC5zdHlsZSk7XG4gIGNvbnN0IG5ld1N0eWxlcyA9IE9iamVjdC5lbnRyaWVzKHBhdGNoKS5yZWR1Y2UoKHN0eWxlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICBkZWxldGUgc3R5bGVzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc1trZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfSwgeyAuLi5wcmV2U3R5bGVzXG4gIH0gfHwge30pO1xuICBjb25zdCBuZXdDU1NUZXh0ID0gZ2V0Q1NTRnJvbVN0eWxlT2JqZWN0KG5ld1N0eWxlcyk7XG4gIHRhcmdldC5zZXRTdHlsZShuZXdDU1NUZXh0KTtcbiAgQ1NTX1RPX1NUWUxFUy5zZXQobmV3Q1NTVGV4dCwgbmV3U3R5bGVzKTtcbn1cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvdmlkZWQgc3R5bGVzIHRvIHRoZSBUZXh0Tm9kZXMgaW4gdGhlIHByb3ZpZGVkIFNlbGVjdGlvbi5cbiAqIFdpbGwgdXBkYXRlIHBhcnRpYWxseSBzZWxlY3RlZCBUZXh0Tm9kZXMgYnkgc3BsaXR0aW5nIHRoZSBUZXh0Tm9kZSBhbmQgYXBwbHlpbmdcbiAqIHRoZSBzdHlsZXMgdG8gdGhlIGFwcHJvcHJpYXRlIG9uZS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0ZWQgbm9kZShzKSB0byB1cGRhdGUuXG4gKiBAcGFyYW0gcGF0Y2ggLSBUaGUgcGF0Y2ggdG8gYXBwbHksIHdoaWNoIGNhbiBpbmNsdWRlIG11bHRpcGxlIHN0eWxlcy4geyBDU1NQcm9wZXJ0eTogdmFsdWUgfVxuICovXG5cblxuZnVuY3Rpb24gJHBhdGNoU3R5bGVUZXh0KHNlbGVjdGlvbiwgcGF0Y2gpIHtcbiAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBzZWxlY3RlZE5vZGVzTGVuZ3RoID0gc2VsZWN0ZWROb2Rlcy5sZW5ndGg7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHNlbGVjdGVkTm9kZXNMZW5ndGggLSAxO1xuICBsZXQgZmlyc3ROb2RlID0gc2VsZWN0ZWROb2Rlc1swXTtcbiAgbGV0IGxhc3ROb2RlID0gc2VsZWN0ZWROb2Rlc1tsYXN0SW5kZXhdO1xuXG4gIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICRwYXRjaFN0eWxlKHNlbGVjdGlvbiwgcGF0Y2gpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBmaXJzdE5vZGVUZXh0ID0gZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IGZpcnN0Tm9kZVRleHRMZW5ndGggPSBmaXJzdE5vZGVUZXh0Lmxlbmd0aDtcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gIGxldCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gIGxldCBzdGFydE9mZnNldCA9IGlzQmVmb3JlID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gIGxldCBlbmRPZmZzZXQgPSBpc0JlZm9yZSA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICBjb25zdCBzdGFydFR5cGUgPSBpc0JlZm9yZSA/IGFuY2hvci50eXBlIDogZm9jdXMudHlwZTtcbiAgY29uc3QgZW5kVHlwZSA9IGlzQmVmb3JlID8gZm9jdXMudHlwZSA6IGFuY2hvci50eXBlO1xuICBjb25zdCBlbmRLZXkgPSBpc0JlZm9yZSA/IGZvY3VzLmtleSA6IGFuY2hvci5rZXk7IC8vIFRoaXMgaXMgdGhlIGNhc2Ugd2hlcmUgdGhlIHVzZXIgb25seSBzZWxlY3RlZCB0aGUgdmVyeSBlbmQgb2YgdGhlXG4gIC8vIGZpcnN0IG5vZGUgc28gd2UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlIGl0IGluIHRoZSBmb3JtYXR0aW5nIGNoYW5nZS5cblxuICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShmaXJzdE5vZGUpICYmIHN0YXJ0T2Zmc2V0ID09PSBmaXJzdE5vZGVUZXh0TGVuZ3RoKSB7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBmaXJzdE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgLy8gd2UgYmFzaWNhbGx5IG1ha2UgdGhlIHNlY29uZCBub2RlIHRoZSBmaXJzdE5vZGUsIGNoYW5naW5nIG9mZnNldHMgYWNjb3JkaW5nbHlcbiAgICAgIGFuY2hvck9mZnNldCA9IDA7XG4gICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICBmaXJzdE5vZGUgPSBuZXh0U2libGluZztcbiAgICB9XG4gIH0gLy8gVGhpcyBpcyB0aGUgY2FzZSB3aGVyZSB3ZSBvbmx5IHNlbGVjdGVkIGEgc2luZ2xlIG5vZGVcblxuXG4gIGlmIChzZWxlY3RlZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gc3RhcnRUeXBlID09PSAnZWxlbWVudCcgPyAwIDogYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgIGVuZE9mZnNldCA9IGVuZFR5cGUgPT09ICdlbGVtZW50JyA/IGZpcnN0Tm9kZVRleHRMZW5ndGggOiBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0OyAvLyBObyBhY3R1YWwgdGV4dCBpcyBzZWxlY3RlZCwgc28gZG8gbm90aGluZy5cblxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSBlbmRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUaGUgZW50aXJlIG5vZGUgaXMgc2VsZWN0ZWQsIHNvIGp1c3QgZm9ybWF0IGl0XG5cblxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAwICYmIGVuZE9mZnNldCA9PT0gZmlyc3ROb2RlVGV4dExlbmd0aCkge1xuICAgICAgICAkcGF0Y2hTdHlsZShmaXJzdE5vZGUsIHBhdGNoKTtcbiAgICAgICAgZmlyc3ROb2RlLnNlbGVjdChzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBub2RlIGlzIHBhcnRpYWxseSBzZWxlY3RlZCwgc28gc3BsaXQgaXQgaW50byB0d28gbm9kZXNcbiAgICAgICAgLy8gYW5kIHN0eWxlIHRoZSBzZWxlY3RlZCBvbmUuXG4gICAgICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHN0YXJ0T2Zmc2V0ID09PSAwID8gc3BsaXROb2Rlc1swXSA6IHNwbGl0Tm9kZXNbMV07XG4gICAgICAgICRwYXRjaFN0eWxlKHJlcGxhY2VtZW50LCBwYXRjaCk7XG4gICAgICAgIHJlcGxhY2VtZW50LnNlbGVjdCgwLCBlbmRPZmZzZXQgLSBzdGFydE9mZnNldCk7XG4gICAgICB9XG4gICAgfSAvLyBtdWx0aXBsZSBub2RlcyBzZWxlY3RlZC5cblxuICB9IGVsc2Uge1xuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGZpcnN0Tm9kZSkgJiYgc3RhcnRPZmZzZXQgPCBmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgIGlmIChzdGFydE9mZnNldCAhPT0gMCkge1xuICAgICAgICAvLyB0aGUgZW50aXJlIGZpcnN0IG5vZGUgaXNuJ3Qgc2VsZWN0ZWQsIHNvIHNwbGl0IGl0XG4gICAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQpWzFdO1xuICAgICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICB9XG5cbiAgICAgICRwYXRjaFN0eWxlKGZpcnN0Tm9kZSwgcGF0Y2gpO1xuICAgIH1cblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGxhc3ROb2RlKSkge1xuICAgICAgY29uc3QgbGFzdE5vZGVUZXh0ID0gbGFzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgIGNvbnN0IGxhc3ROb2RlVGV4dExlbmd0aCA9IGxhc3ROb2RlVGV4dC5sZW5ndGg7IC8vIFRoZSBsYXN0IG5vZGUgbWlnaHQgbm90IGFjdHVhbGx5IGJlIHRoZSBlbmQgbm9kZVxuICAgICAgLy9cbiAgICAgIC8vIElmIG5vdCwgYXNzdW1lIHRoZSBsYXN0IG5vZGUgaXMgZnVsbHktc2VsZWN0ZWQgdW5sZXNzIHRoZSBlbmQgb2Zmc2V0IGlzXG4gICAgICAvLyB6ZXJvLlxuXG4gICAgICBpZiAobGFzdE5vZGUuX19rZXkgIT09IGVuZEtleSAmJiBlbmRPZmZzZXQgIT09IDApIHtcbiAgICAgICAgZW5kT2Zmc2V0ID0gbGFzdE5vZGVUZXh0TGVuZ3RoO1xuICAgICAgfSAvLyBpZiB0aGUgZW50aXJlIGxhc3Qgbm9kZSBpc24ndCBzZWxlY3RlZCwgc3BsaXQgaXRcblxuXG4gICAgICBpZiAoZW5kT2Zmc2V0ICE9PSBsYXN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgICAgW2xhc3ROb2RlXSA9IGxhc3ROb2RlLnNwbGl0VGV4dChlbmRPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICRwYXRjaFN0eWxlKGxhc3ROb2RlLCBwYXRjaCk7XG4gICAgICB9XG4gICAgfSAvLyBzdHlsZSBhbGwgdGhlIHRleHQgbm9kZXMgaW4gYmV0d2VlblxuXG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGUgPSBzZWxlY3RlZE5vZGVzW2ldO1xuICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlS2V5ID0gc2VsZWN0ZWROb2RlLmdldEtleSgpO1xuXG4gICAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShzZWxlY3RlZE5vZGUpICYmIHNlbGVjdGVkTm9kZUtleSAhPT0gZmlyc3ROb2RlLmdldEtleSgpICYmIHNlbGVjdGVkTm9kZUtleSAhPT0gbGFzdE5vZGUuZ2V0S2V5KCkgJiYgIXNlbGVjdGVkTm9kZS5pc1Rva2VuKCkpIHtcbiAgICAgICAgJHBhdGNoU3R5bGUoc2VsZWN0ZWROb2RlLCBwYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbi8qKlxuICogQ29udmVydHMgYWxsIG5vZGVzIGluIHRoZSBzZWxlY3Rpb24gdGhhdCBhcmUgb2Ygb25lIGJsb2NrIHR5cGUgdG8gYW5vdGhlci5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0ZWQgYmxvY2tzIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEBwYXJhbSBjcmVhdGVFbGVtZW50IC0gVGhlIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgbm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICovXG5cbmZ1bmN0aW9uICRzZXRCbG9ja3NUeXBlKHNlbGVjdGlvbiwgY3JlYXRlRWxlbWVudCkge1xuICBpZiAoc2VsZWN0aW9uLmFuY2hvci5rZXkgPT09ICdyb290Jykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgY29uc3Qgcm9vdCA9IGxleGljYWwuJGdldFJvb3QoKTtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gcm9vdC5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgZmlyc3RDaGlsZC5yZXBsYWNlKGVsZW1lbnQsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290LmFwcGVuZChlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBsZXQgbWF5YmVCbG9jayA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLmdldFBhcmVudE9yVGhyb3coKTtcblxuICBpZiAobm9kZXMuaW5kZXhPZihtYXliZUJsb2NrKSA9PT0gLTEpIHtcbiAgICBub2Rlcy5wdXNoKG1heWJlQmxvY2spO1xuICB9XG5cbiAgaWYgKG1heWJlQmxvY2suaXNJbmxpbmUoKSkge1xuICAgIG1heWJlQmxvY2sgPSBtYXliZUJsb2NrLmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgIGlmIChub2Rlcy5pbmRleE9mKG1heWJlQmxvY2spID09PSAtMSkge1xuICAgICAgbm9kZXMucHVzaChtYXliZUJsb2NrKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgaWYgKCFpc0Jsb2NrKG5vZGUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgIHRhcmdldEVsZW1lbnQuc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICB0YXJnZXRFbGVtZW50LnNldEluZGVudChub2RlLmdldEluZGVudCgpKTtcbiAgICBub2RlLnJlcGxhY2UodGFyZ2V0RWxlbWVudCwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNCbG9jayhub2RlKSB7XG4gIGlmICghbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSB8fCBsZXhpY2FsLiRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBmaXJzdENoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gIGNvbnN0IGlzTGVhZkVsZW1lbnQgPSBmaXJzdENoaWxkID09PSBudWxsIHx8IGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShmaXJzdENoaWxkKSB8fCBsZXhpY2FsLiRpc1RleHROb2RlKGZpcnN0Q2hpbGQpIHx8IGZpcnN0Q2hpbGQuaXNJbmxpbmUoKTtcbiAgcmV0dXJuICFub2RlLmlzSW5saW5lKCkgJiYgbm9kZS5jYW5CZUVtcHR5KCkgIT09IGZhbHNlICYmIGlzTGVhZkVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzUG9pbnRBdHRhY2hlZChwb2ludCkge1xuICByZXR1cm4gcG9pbnQuZ2V0Tm9kZSgpLmlzQXR0YWNoZWQoKTtcbn1cblxuZnVuY3Rpb24gJHJlbW92ZVBhcmVudEVtcHR5RWxlbWVudHMoc3RhcnRpbmdOb2RlKSB7XG4gIGxldCBub2RlID0gc3RhcnRpbmdOb2RlO1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsICYmICFsZXhpY2FsLiRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICBjb25zdCBsYXRlc3QgPSBub2RlLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKGxhdGVzdC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkge1xuICAgICAgbm9kZS5yZW1vdmUodHJ1ZSk7XG4gICAgfVxuXG4gICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gIH1cbn1cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqIFdyYXBzIGFsbCBub2RlcyBpbiB0aGUgc2VsZWN0aW9uIGludG8gYW5vdGhlciBub2RlIG9mIHRoZSB0eXBlIHJldHVybmVkIGJ5IGNyZWF0ZUVsZW1lbnQuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiBub2RlcyB0byBiZSB3cmFwcGVkLlxuICogQHBhcmFtIGNyZWF0ZUVsZW1lbnQgLSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgd3JhcHBpbmcgRWxlbWVudE5vZGUuIGVnLiAkY3JlYXRlUGFyYWdyYXBoTm9kZS5cbiAqIEBwYXJhbSB3cmFwcGluZ0VsZW1lbnQgLSBBbiBlbGVtZW50IHRvIGFwcGVuZCB0aGUgd3JhcHBlZCBzZWxlY3Rpb24gYW5kIGl0cyBjaGlsZHJlbiB0by5cbiAqL1xuXG5cbmZ1bmN0aW9uICR3cmFwTm9kZXMoc2VsZWN0aW9uLCBjcmVhdGVFbGVtZW50LCB3cmFwcGluZ0VsZW1lbnQgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuXG4gIGlmIChub2Rlc0xlbmd0aCA9PT0gMCB8fCBub2Rlc0xlbmd0aCA9PT0gMSAmJiBhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGFuY2hvci5nZXROb2RlKCkuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICBjb25zdCB0YXJnZXQgPSBhbmNob3IudHlwZSA9PT0gJ3RleHQnID8gYW5jaG9yLmdldE5vZGUoKS5nZXRQYXJlbnRPclRocm93KCkgOiBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGFyZ2V0LmdldENoaWxkcmVuKCk7XG4gICAgbGV0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgZWxlbWVudC5zZXRGb3JtYXQodGFyZ2V0LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgZWxlbWVudC5zZXRJbmRlbnQodGFyZ2V0LmdldEluZGVudCgpKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGVsZW1lbnQuYXBwZW5kKGNoaWxkKSk7XG5cbiAgICBpZiAod3JhcHBpbmdFbGVtZW50KSB7XG4gICAgICBlbGVtZW50ID0gd3JhcHBpbmdFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICB9XG5cbiAgICB0YXJnZXQucmVwbGFjZShlbGVtZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgdG9wTGV2ZWxOb2RlID0gbnVsbDtcbiAgbGV0IGRlc2NlbmRhbnRzID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldOyAvLyBEZXRlcm1pbmUgd2hldGhlciB3cmFwcGluZyBoYXMgdG8gYmUgYnJva2VuIGRvd24gaW50byBtdWx0aXBsZSBjaHVua3MuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGVcbiAgICAvLyB1c2VyIHNlbGVjdGVkIG11bHRpcGxlIFJvb3QtbGlrZSBub2RlcyB0aGF0IGhhdmUgdG8gYmUgdHJlYXRlZCBzZXBhcmF0ZWx5IGFzIGlmIHRoZXkgYXJlXG4gICAgLy8gdGhlaXIgb3duIGJyYW5jaC4gSS5lLiB5b3UgZG9uJ3Qgd2FudCB0byB3cmFwIGEgd2hvbGUgdGFibGUsIGJ1dCByYXRoZXIgdGhlIGNvbnRlbnRzIG9mIGVhY2hcbiAgICAvLyBvZiBlYWNoIG9mIHRoZSBjZWxsIG5vZGVzLlxuXG4gICAgaWYgKGxleGljYWwuJGlzUm9vdE9yU2hhZG93Um9vdChub2RlKSkge1xuICAgICAgJHdyYXBOb2Rlc0ltcGwoc2VsZWN0aW9uLCBkZXNjZW5kYW50cywgZGVzY2VuZGFudHMubGVuZ3RoLCBjcmVhdGVFbGVtZW50LCB3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgZGVzY2VuZGFudHMgPSBbXTtcbiAgICAgIHRvcExldmVsTm9kZSA9IG5vZGU7XG4gICAgfSBlbHNlIGlmICh0b3BMZXZlbE5vZGUgPT09IG51bGwgfHwgdG9wTGV2ZWxOb2RlICE9PSBudWxsICYmIGxleGljYWwuJGhhc0FuY2VzdG9yKG5vZGUsIHRvcExldmVsTm9kZSkpIHtcbiAgICAgIGRlc2NlbmRhbnRzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzLmxlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIGRlc2NlbmRhbnRzID0gW25vZGVdO1xuICAgIH1cbiAgfVxuXG4gICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzLmxlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50KTtcbn1cbi8qKlxuICogV3JhcHMgZWFjaCBub2RlIGludG8gYSBuZXcgRWxlbWVudE5vZGUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiBub2RlcyB0byB3cmFwLlxuICogQHBhcmFtIG5vZGVzIC0gQW4gYXJyYXkgb2Ygbm9kZXMsIGdlbmVyYWxseSB0aGUgZGVzY2VuZGFudHMgb2YgdGhlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBub2Rlc0xlbmd0aCAtIFRoZSBsZW5ndGggb2Ygbm9kZXMuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGluZyBFbGVtZW50Tm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtIHdyYXBwaW5nRWxlbWVudCAtIEFuIGVsZW1lbnQgdG8gd3JhcCBhbGwgdGhlIG5vZGVzIGludG8uXG4gKiBAcmV0dXJuc1xuICovXG5cbmZ1bmN0aW9uICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgbm9kZXMsIG5vZGVzTGVuZ3RoLCBjcmVhdGVFbGVtZW50LCB3cmFwcGluZ0VsZW1lbnQgPSBudWxsKSB7XG4gIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBmaXJzdE5vZGUgPSBub2Rlc1swXTtcbiAgY29uc3QgZWxlbWVudE1hcHBpbmcgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGVsZW1lbnRzID0gW107IC8vIFRoZSBiZWxvdyBsb2dpYyBpcyB0byBmaW5kIHRoZSByaWdodCB0YXJnZXQgZm9yIHVzIHRvXG4gIC8vIGVpdGhlciBpbnNlcnRBZnRlci9pbnNlcnRCZWZvcmUvYXBwZW5kIHRoZSBjb3JyZXNwb25kaW5nXG4gIC8vIGVsZW1lbnRzIHRvLiBUaGlzIGlzIG1hZGUgbW9yZSBjb21wbGljYXRlZCBkdWUgdG8gbmVzdGVkXG4gIC8vIHN0cnVjdHVyZXMuXG5cbiAgbGV0IHRhcmdldCA9IGxleGljYWwuJGlzRWxlbWVudE5vZGUoZmlyc3ROb2RlKSA/IGZpcnN0Tm9kZSA6IGZpcnN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgaWYgKHRhcmdldC5pc0lubGluZSgpKSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuXG4gIGxldCB0YXJnZXRJc1ByZXZTaWJsaW5nID0gZmFsc2U7XG5cbiAgd2hpbGUgKHRhcmdldCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGFyZ2V0LmdldFByZXZpb3VzU2libGluZygpO1xuXG4gICAgaWYgKHByZXZTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICB0YXJnZXQgPSBwcmV2U2libGluZztcbiAgICAgIHRhcmdldElzUHJldlNpYmxpbmcgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1Jvb3RPclNoYWRvd1Jvb3QodGFyZ2V0KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZW1wdHlFbGVtZW50cyA9IG5ldyBTZXQoKTsgLy8gRmluZCBhbnkgdG9wIGxldmVsIGVtcHR5IGVsZW1lbnRzXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkge1xuICAgICAgZW1wdHlFbGVtZW50cy5hZGQobm9kZS5nZXRLZXkoKSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbW92ZWROb2RlcyA9IG5ldyBTZXQoKTsgLy8gTW92ZSBvdXQgYWxsIGxlYWYgbm9kZXMgaW50byBvdXIgZWxlbWVudHMgYXJyYXkuXG4gIC8vIElmIHdlIGZpbmQgYSB0b3AgbGV2ZWwgZW1wdHkgZWxlbWVudCwgYWxzbyBtb3ZlIG1ha2VcbiAgLy8gYW4gZWxlbWVudCBmb3IgdGhhdC5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5pc0lubGluZSgpKSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCAmJiBsZXhpY2FsLiRpc0xlYWZOb2RlKG5vZGUpICYmICFtb3ZlZE5vZGVzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgY29uc3QgcGFyZW50S2V5ID0gcGFyZW50LmdldEtleSgpO1xuXG4gICAgICBpZiAoZWxlbWVudE1hcHBpbmcuZ2V0KHBhcmVudEtleSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgICAgICB0YXJnZXRFbGVtZW50LnNldEZvcm1hdChwYXJlbnQuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRJbmRlbnQocGFyZW50LmdldEluZGVudCgpKTtcbiAgICAgICAgZWxlbWVudHMucHVzaCh0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgZWxlbWVudE1hcHBpbmcuc2V0KHBhcmVudEtleSwgdGFyZ2V0RWxlbWVudCk7IC8vIE1vdmUgbm9kZSBhbmQgaXRzIHNpYmxpbmdzIHRvIHRoZSBuZXdcbiAgICAgICAgLy8gZWxlbWVudC5cblxuICAgICAgICBwYXJlbnQuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICB0YXJnZXRFbGVtZW50LmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgbW92ZWROb2Rlcy5hZGQoY2hpbGQuZ2V0S2V5KCkpO1xuXG4gICAgICAgICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICAvLyBTa2lwIG5lc3RlZCBsZWFmIG5vZGVzIGlmIHRoZSBwYXJlbnQgaGFzIGFscmVhZHkgYmVlbiBtb3ZlZFxuICAgICAgICAgICAgY2hpbGQuZ2V0Q2hpbGRyZW5LZXlzKCkuZm9yRWFjaChrZXkgPT4gbW92ZWROb2Rlcy5hZGQoa2V5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgJHJlbW92ZVBhcmVudEVtcHR5RWxlbWVudHMocGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVtcHR5RWxlbWVudHMuaGFzKG5vZGUuZ2V0S2V5KCkpKSB7XG4gICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgICAgdGFyZ2V0RWxlbWVudC5zZXRGb3JtYXQobm9kZS5nZXRGb3JtYXRUeXBlKCkpO1xuICAgICAgdGFyZ2V0RWxlbWVudC5zZXRJbmRlbnQobm9kZS5nZXRJbmRlbnQoKSk7XG4gICAgICBlbGVtZW50cy5wdXNoKHRhcmdldEVsZW1lbnQpO1xuICAgICAgbm9kZS5yZW1vdmUodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHdyYXBwaW5nRWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIHdyYXBwaW5nRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgbGV0IGxhc3RFbGVtZW50ID0gbnVsbDsgLy8gSWYgb3VyIHRhcmdldCBpcyBSb290LWxpa2UsIGxldCdzIHNlZSBpZiB3ZSBjYW4gcmUtYWRqdXN0XG4gIC8vIHNvIHRoYXQgdGhlIHRhcmdldCBpcyB0aGUgZmlyc3QgY2hpbGQgaW5zdGVhZC5cblxuICBpZiAobGV4aWNhbC4kaXNSb290T3JTaGFkb3dSb290KHRhcmdldCkpIHtcbiAgICBpZiAodGFyZ2V0SXNQcmV2U2libGluZykge1xuICAgICAgaWYgKHdyYXBwaW5nRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIod3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IHRhcmdldC5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgIHRhcmdldCA9IGZpcnN0Q2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdENoaWxkID09PSBudWxsKSB7XG4gICAgICAgIGlmICh3cmFwcGluZ0VsZW1lbnQpIHtcbiAgICAgICAgICB0YXJnZXQuYXBwZW5kKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZSh3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKGVsZW1lbnQpO1xuICAgICAgICAgICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAod3JhcHBpbmdFbGVtZW50KSB7XG4gICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIod3JhcHBpbmdFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IGVsZW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKGVsZW1lbnQpO1xuICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcHJldlNlbGVjdGlvbiA9IGxleGljYWwuJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG5cbiAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgaXNQb2ludEF0dGFjaGVkKHByZXZTZWxlY3Rpb24uYW5jaG9yKSAmJiBpc1BvaW50QXR0YWNoZWQocHJldlNlbGVjdGlvbi5mb2N1cykpIHtcbiAgICBsZXhpY2FsLiRzZXRTZWxlY3Rpb24ocHJldlNlbGVjdGlvbi5jbG9uZSgpKTtcbiAgfSBlbHNlIGlmIChsYXN0RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGxhc3RFbGVtZW50LnNlbGVjdEVuZCgpO1xuICB9IGVsc2Uge1xuICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gIH1cbn1cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIgc2VsZWN0aW9uIHNob3VsZCBiZSBvdmVycmlkZGVuLiBVc2VkIHdpdGggRGVjb3JhdG9yTm9kZXNcbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHdob3NlIGRlZmF1bHQgY2hhcmFjdGVyIHNlbGVjdGlvbiBtYXkgbmVlZCB0byBiZSBvdmVycmlkZGVuLlxuICogQHBhcmFtIGlzQmFja3dhcmQgLSBJcyB0aGUgc2VsZWN0aW9uIGJhY2t3YXJkcyAodGhlIGZvY3VzIGNvbWVzIGJlZm9yZSB0aGUgYW5jaG9yKT9cbiAqIEByZXR1cm5zIHRydWUgaWYgaXQgc2hvdWxkIGJlIG92ZXJyaWRkZW4sIGZhbHNlIGlmIG5vdC5cbiAqL1xuXG5mdW5jdGlvbiAkc2hvdWxkT3ZlcnJpZGVEZWZhdWx0Q2hhcmFjdGVyU2VsZWN0aW9uKHNlbGVjdGlvbiwgaXNCYWNrd2FyZCkge1xuICBjb25zdCBwb3NzaWJsZU5vZGUgPSBsZXhpY2FsLiRnZXRBZGphY2VudE5vZGUoc2VsZWN0aW9uLmZvY3VzLCBpc0JhY2t3YXJkKTtcbiAgcmV0dXJuIGxleGljYWwuJGlzRGVjb3JhdG9yTm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJc29sYXRlZCgpIHx8IGxleGljYWwuJGlzRWxlbWVudE5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSW5saW5lKCkgJiYgIXBvc3NpYmxlTm9kZS5jYW5CZUVtcHR5KCk7XG59XG4vKipcbiAqIE1vdmVzIHRoZSBzZWxlY3Rpb24gYWNjb3JkaW5nIHRvIHRoZSBhcmd1bWVudHMuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGVkIHRleHQgb3Igbm9kZXMuXG4gKiBAcGFyYW0gaXNIb2xkaW5nU2hpZnQgLSBJcyB0aGUgc2hpZnQga2V5IGJlaW5nIGhlbGQgZG93biBkdXJpbmcgdGhlIG9wZXJhdGlvbi5cbiAqIEBwYXJhbSBpc0JhY2t3YXJkIC0gSXMgdGhlIHNlbGVjdGlvbiBzZWxlY3RlZCBiYWNrd2FyZHMgKHRoZSBmb2N1cyBjb21lcyBiZWZvcmUgdGhlIGFuY2hvcik/XG4gKiBAcGFyYW0gZ3JhbnVsYXJpdHkgLSBUaGUgZGlzdGFuY2UgdG8gYWRqdXN0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiAkbW92ZUNhcmV0U2VsZWN0aW9uKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGlzQmFja3dhcmQsIGdyYW51bGFyaXR5KSB7XG4gIHNlbGVjdGlvbi5tb2RpZnkoaXNIb2xkaW5nU2hpZnQgPyAnZXh0ZW5kJyA6ICdtb3ZlJywgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHkpO1xufVxuLyoqXG4gKiBUZXN0cyBhIHBhcmVudCBlbGVtZW50IGZvciByaWdodCB0byBsZWZ0IGRpcmVjdGlvbi5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHdob3NlIHBhcmVudCBpcyB0byBiZSB0ZXN0ZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBzZWxlY3Rpb25zJyBwYXJlbnQgZWxlbWVudCBoYXMgYSBkaXJlY3Rpb24gb2YgJ3J0bCcgKHJpZ2h0IHRvIGxlZnQpLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gJGlzUGFyZW50RWxlbWVudFJUTChzZWxlY3Rpb24pIHtcbiAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBwYXJlbnQgPSBsZXhpY2FsLiRpc1Jvb3ROb2RlKGFuY2hvck5vZGUpID8gYW5jaG9yTm9kZSA6IGFuY2hvck5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICByZXR1cm4gcGFyZW50LmdldERpcmVjdGlvbigpID09PSAncnRsJztcbn1cbi8qKlxuICogTW92ZXMgc2VsZWN0aW9uIGJ5IGNoYXJhY3RlciBhY2NvcmRpbmcgdG8gYXJndW1lbnRzLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gb2YgdGhlIGNoYXJhY3RlcnMgdG8gbW92ZS5cbiAqIEBwYXJhbSBpc0hvbGRpbmdTaGlmdCAtIElzIHRoZSBzaGlmdCBrZXkgYmVpbmcgaGVsZCBkb3duIGR1cmluZyB0aGUgb3BlcmF0aW9uLlxuICogQHBhcmFtIGlzQmFja3dhcmQgLSBJcyB0aGUgc2VsZWN0aW9uIGJhY2t3YXJkICh0aGUgZm9jdXMgY29tZXMgYmVmb3JlIHRoZSBhbmNob3IpP1xuICovXG5cbmZ1bmN0aW9uICRtb3ZlQ2hhcmFjdGVyKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGlzQmFja3dhcmQpIHtcbiAgY29uc3QgaXNSVEwgPSAkaXNQYXJlbnRFbGVtZW50UlRMKHNlbGVjdGlvbik7XG4gICRtb3ZlQ2FyZXRTZWxlY3Rpb24oc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCA/ICFpc1JUTCA6IGlzUlRMLCAnY2hhcmFjdGVyJyk7XG59XG4vKipcbiAqIEV4cGFuZHMgdGhlIGN1cnJlbnQgU2VsZWN0aW9uIHRvIGNvdmVyIGFsbCBvZiB0aGUgY29udGVudCBpbiB0aGUgZWRpdG9yLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiAkc2VsZWN0QWxsKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IHRvcFBhcmVudCA9IGFuY2hvck5vZGUuZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdygpO1xuICBjb25zdCByb290ID0gdG9wUGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgbGV0IGZpcnN0Tm9kZSA9IHJvb3QuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gIGxldCBsYXN0Tm9kZSA9IHJvb3QuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgbGV0IGZpcnN0VHlwZSA9ICdlbGVtZW50JztcbiAgbGV0IGxhc3RUeXBlID0gJ2VsZW1lbnQnO1xuICBsZXQgbGFzdE9mZnNldCA9IDA7XG5cbiAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSkge1xuICAgIGZpcnN0VHlwZSA9ICd0ZXh0JztcbiAgfSBlbHNlIGlmICghbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpICYmIGZpcnN0Tm9kZSAhPT0gbnVsbCkge1xuICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cblxuICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShsYXN0Tm9kZSkpIHtcbiAgICBsYXN0VHlwZSA9ICd0ZXh0JztcbiAgICBsYXN0T2Zmc2V0ID0gbGFzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gIH0gZWxzZSBpZiAoIWxleGljYWwuJGlzRWxlbWVudE5vZGUobGFzdE5vZGUpICYmIGxhc3ROb2RlICE9PSBudWxsKSB7XG4gICAgbGFzdE5vZGUgPSBsYXN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cblxuICBpZiAoZmlyc3ROb2RlICYmIGxhc3ROb2RlKSB7XG4gICAgYW5jaG9yLnNldChmaXJzdE5vZGUuZ2V0S2V5KCksIDAsIGZpcnN0VHlwZSk7XG4gICAgZm9jdXMuc2V0KGxhc3ROb2RlLmdldEtleSgpLCBsYXN0T2Zmc2V0LCBsYXN0VHlwZSk7XG4gIH1cbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIENTUyBwcm9wZXJ0eSBmb3IgTm9kZXMsIGlmIHNldC4gSWYgbm90IHNldCwgaXQgcmV0dXJucyB0aGUgZGVmYXVsdFZhbHVlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB3aG9zZSBzdHlsZSB2YWx1ZSB0byBnZXQuXG4gKiBAcGFyYW0gc3R5bGVQcm9wZXJ0eSAtIFRoZSBDU1Mgc3R5bGUgcHJvcGVydHkuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgZm9yIG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gJGdldE5vZGVTdHlsZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgc3R5bGVQcm9wZXJ0eSwgZGVmYXVsdFZhbHVlKSB7XG4gIGNvbnN0IGNzcyA9IG5vZGUuZ2V0U3R5bGUoKTtcbiAgY29uc3Qgc3R5bGVPYmplY3QgPSBnZXRTdHlsZU9iamVjdEZyb21DU1MoY3NzKTtcblxuICBpZiAoc3R5bGVPYmplY3QgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc3R5bGVPYmplY3Rbc3R5bGVQcm9wZXJ0eV0gfHwgZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIENTUyBwcm9wZXJ0eSBmb3IgVGV4dE5vZGVzIGluIHRoZSBTZWxlY3Rpb24sIGlmIHNldC4gSWYgbm90IHNldCwgaXQgcmV0dXJucyB0aGUgZGVmYXVsdFZhbHVlLlxuICogSWYgYWxsIFRleHROb2RlcyBkbyBub3QgaGF2ZSB0aGUgc2FtZSB2YWx1ZSwgaXQgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiBUZXh0Tm9kZXMgd2hvc2UgdmFsdWUgdG8gZmluZC5cbiAqIEBwYXJhbSBzdHlsZVByb3BlcnR5IC0gVGhlIENTUyBzdHlsZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHByb3BlcnR5LCBkZWZhdWx0cyB0byBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGZvciB0aGUgc2VsZWN0ZWQgVGV4dE5vZGVzLlxuICovXG5cblxuZnVuY3Rpb24gJGdldFNlbGVjdGlvblN0eWxlVmFsdWVGb3JQcm9wZXJ0eShzZWxlY3Rpb24sIHN0eWxlUHJvcGVydHksIGRlZmF1bHRWYWx1ZSA9ICcnKSB7XG4gIGxldCBzdHlsZVZhbHVlID0gbnVsbDtcbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICBjb25zdCBlbmRPZmZzZXQgPSBpc0JhY2t3YXJkID8gZm9jdXMub2Zmc2V0IDogYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgZW5kTm9kZSA9IGlzQmFja3dhcmQgPyBmb2N1cy5nZXROb2RlKCkgOiBhbmNob3IuZ2V0Tm9kZSgpO1xuXG4gIGlmIChzZWxlY3Rpb24uc3R5bGUgIT09ICcnKSB7XG4gICAgY29uc3QgY3NzID0gc2VsZWN0aW9uLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlT2JqZWN0ID0gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKGNzcyk7XG5cbiAgICBpZiAoc3R5bGVPYmplY3QgIT09IG51bGwgJiYgc3R5bGVQcm9wZXJ0eSBpbiBzdHlsZU9iamVjdCkge1xuICAgICAgcmV0dXJuIHN0eWxlT2JqZWN0W3N0eWxlUHJvcGVydHldO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07IC8vIGlmIG5vIGFjdHVhbCBjaGFyYWN0ZXJzIGluIHRoZSBlbmQgbm9kZSBhcmUgc2VsZWN0ZWQsIHdlIGRvbid0XG4gICAgLy8gaW5jbHVkZSBpdCBpbiB0aGUgc2VsZWN0aW9uIGZvciBwdXJwb3NlcyBvZiBkZXRlcm1pbmluZyBzdHlsZVxuICAgIC8vIHZhbHVlXG5cbiAgICBpZiAoaSAhPT0gMCAmJiBlbmRPZmZzZXQgPT09IDAgJiYgbm9kZS5pcyhlbmROb2RlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IG5vZGVTdHlsZVZhbHVlID0gJGdldE5vZGVTdHlsZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgc3R5bGVQcm9wZXJ0eSwgZGVmYXVsdFZhbHVlKTtcblxuICAgICAgaWYgKHN0eWxlVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgc3R5bGVWYWx1ZSA9IG5vZGVTdHlsZVZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZVZhbHVlICE9PSBub2RlU3R5bGVWYWx1ZSkge1xuICAgICAgICAvLyBtdWx0aXBsZSB0ZXh0IG5vZGVzIGFyZSBpbiB0aGUgc2VsZWN0aW9uIGFuZCB0aGV5IGRvbid0IGFsbFxuICAgICAgICAvLyBoYXZlIHRoZSBzYW1lIHN0eWxlLlxuICAgICAgICBzdHlsZVZhbHVlID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZVZhbHVlID09PSBudWxsID8gZGVmYXVsdFZhbHVlIDogc3R5bGVWYWx1ZTtcbn1cblxuZXhwb3J0cy4kYWRkTm9kZVN0eWxlID0gJGFkZE5vZGVTdHlsZTtcbmV4cG9ydHMuJGNsb25lV2l0aFByb3BlcnRpZXMgPSAkY2xvbmVXaXRoUHJvcGVydGllcztcbmV4cG9ydHMuJGdldFNlbGVjdGlvblN0eWxlVmFsdWVGb3JQcm9wZXJ0eSA9ICRnZXRTZWxlY3Rpb25TdHlsZVZhbHVlRm9yUHJvcGVydHk7XG5leHBvcnRzLiRpc0F0Tm9kZUVuZCA9ICRpc0F0Tm9kZUVuZDtcbmV4cG9ydHMuJGlzUGFyZW50RWxlbWVudFJUTCA9ICRpc1BhcmVudEVsZW1lbnRSVEw7XG5leHBvcnRzLiRtb3ZlQ2FyZXRTZWxlY3Rpb24gPSAkbW92ZUNhcmV0U2VsZWN0aW9uO1xuZXhwb3J0cy4kbW92ZUNoYXJhY3RlciA9ICRtb3ZlQ2hhcmFjdGVyO1xuZXhwb3J0cy4kcGF0Y2hTdHlsZVRleHQgPSAkcGF0Y2hTdHlsZVRleHQ7XG5leHBvcnRzLiRzZWxlY3RBbGwgPSAkc2VsZWN0QWxsO1xuZXhwb3J0cy4kc2V0QmxvY2tzVHlwZSA9ICRzZXRCbG9ja3NUeXBlO1xuZXhwb3J0cy4kc2hvdWxkT3ZlcnJpZGVEZWZhdWx0Q2hhcmFjdGVyU2VsZWN0aW9uID0gJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbjtcbmV4cG9ydHMuJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQgPSAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudDtcbmV4cG9ydHMuJHdyYXBOb2RlcyA9ICR3cmFwTm9kZXM7XG5leHBvcnRzLmNyZWF0ZURPTVJhbmdlID0gY3JlYXRlRE9NUmFuZ2U7XG5leHBvcnRzLmNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlID0gY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2U7XG5leHBvcnRzLmdldFN0eWxlT2JqZWN0RnJvbUNTUyA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUztcbmV4cG9ydHMudHJpbVRleHRDb250ZW50RnJvbUFuY2hvciA9IHRyaW1UZXh0Q29udGVudEZyb21BbmNob3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/selection/LexicalSelection.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalSelection =  true ? __webpack_require__(/*! ./LexicalSelection.dev.js */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.js\") : 0\nmodule.exports = LexicalSelection;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWix5QkFBeUIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLGtHQUEyQixJQUFJLENBQXFDO0FBQzlJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uanM/YTQ4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbFNlbGVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsU2VsZWN0aW9uLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsU2VsZWN0aW9uLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsU2VsZWN0aW9uOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/selection/LexicalSelection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/table/LexicalTable.dev.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lexical/table/LexicalTable.dev.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n\n/** @noInheritDoc */\nclass TableCellNode extends lexical.DEPRECATED_GridCellNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'tablecell';\n  }\n\n  static clone(node) {\n    const cellNode = new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n    cellNode.__rowSpan = node.__rowSpan;\n    cellNode.__backgroundColor = node.__backgroundColor;\n    return cellNode;\n  }\n\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const colSpan = serializedNode.colSpan || 1;\n    const rowSpan = serializedNode.rowSpan || 1;\n    const cellNode = $createTableCellNode(serializedNode.headerState, colSpan, serializedNode.width || undefined);\n    cellNode.__rowSpan = rowSpan;\n    cellNode.__backgroundColor = serializedNode.backgroundColor || null;\n    return cellNode;\n  }\n\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(colSpan, key);\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n\n    utils.addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element) {\n      const element_ = element;\n      const maxWidth = 700;\n      const colCount = this.getParentOrThrow().getChildrenSize();\n      element_.style.border = '1px solid black';\n\n      if (this.__colSpan > 1) {\n        element_.colSpan = this.__colSpan;\n      }\n\n      if (this.__rowSpan > 1) {\n        element_.rowSpan = this.__rowSpan;\n      }\n\n      element_.style.width = `${this.getWidth() || Math.max(90, maxWidth / colCount)}px`;\n      element_.style.verticalAlign = 'top';\n      element_.style.textAlign = 'start';\n      const backgroundColor = this.getBackgroundColor();\n\n      if (backgroundColor !== null) {\n        element_.style.backgroundColor = backgroundColor;\n      } else if (this.hasHeader()) {\n        element_.style.backgroundColor = '#f2f3f5';\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      headerState: this.__headerState,\n      type: 'tablecell',\n      width: this.getWidth()\n    };\n  }\n\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n\n  setHeaderStyles(headerState) {\n    const self = this.getWritable();\n    self.__headerState = headerState;\n    return this.__headerState;\n  }\n\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return this.__width;\n  }\n\n  getWidth() {\n    return this.getLatest().__width;\n  }\n\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n\n  setBackgroundColor(newBackgroundColor) {\n    this.getWritable().__backgroundColor = newBackgroundColor;\n  }\n\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n\n    return self;\n  }\n\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n\n  isShadowRoot() {\n    return true;\n  }\n\n  collapseAtStart() {\n    return true;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n}\nfunction convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n\n  return {\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !lexical.$isElementNode(lexicalNode)) {\n        const paragraphNode = lexical.$createParagraphNode();\n\n        if (lexical.$isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState, colSpan = 1, width) {\n  return lexical.$applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends lexical.DEPRECATED_GridRowNode {\n  /** @internal */\n  static getType() {\n    return 'tablerow';\n  }\n\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    return $createTableRowNode(serializedNode.height);\n  }\n\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'tablerow',\n      version: 1\n    };\n  }\n\n  createDOM(config) {\n    const element = document.createElement('tr');\n\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n\n    utils.addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n\n  isShadowRoot() {\n    return true;\n  }\n\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n\n  getHeight() {\n    return this.getLatest().__height;\n  }\n\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n}\nfunction convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n\n  return {\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return lexical.$applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n\nclass TableSelection {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.grid = {\n      cells: [],\n      columns: 0,\n      rows: 0\n    };\n    this.gridSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTableGrid();\n  }\n\n  getGrid() {\n    return this.grid;\n  }\n\n  removeListeners() {\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n  }\n\n  trackTableGrid() {\n    const observer = new MutationObserver(records => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n\n          if (nodeName === 'TABLE' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n\n        if (!gridNeedsRedraw) {\n          return;\n        }\n\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n\n        this.grid = getTableGrid(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      this.grid = getTableGrid(tableElement);\n      observer.observe(tableElement, {\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n\n  clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.gridSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.enableHighlightStyle();\n    editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      const grid = getTableGrid(tableElement);\n      $updateDOMForSelection(editor, grid, null);\n      lexical.$setSelection(null);\n      editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n\n  enableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      utils.removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n\n  disableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      utils.addClassNamesToElement(tableElement, editor._config.theme.tableSelection);\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n\n  updateTableGridSelection(selection) {\n    if (selection != null && selection.gridKey === this.tableNodeKey) {\n      const editor = this.editor;\n      this.gridSelection = selection;\n      this.isHighlightingCells = true;\n      this.disableHighlightStyle();\n      $updateDOMForSelection(editor, this.grid, this.gridSelection);\n    } else if (selection == null) {\n      this.clearHighlight();\n    }\n  }\n\n  setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n\n      if (this.anchorCell !== null) {\n        const domSelection = getDOMSelection(editor._window); // Collapse the selection\n\n        if (domSelection) {\n          domSelection.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);\n        }\n      }\n\n      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.focusX && cellY === this.focusY) {\n        return;\n      }\n\n      this.focusX = cellX;\n      this.focusY = cellY;\n\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n        if (this.gridSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode)) {\n          const focusNodeKey = focusTableCellNode.getKey();\n          this.gridSelection = this.gridSelection.clone() || lexical.DEPRECATED_$createGridSelection();\n          this.focusCellNodeKey = focusNodeKey;\n          this.gridSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey);\n          lexical.$setSelection(this.gridSelection);\n          editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n          $updateDOMForSelection(editor, this.grid, this.gridSelection);\n        }\n      }\n    });\n  }\n\n  setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    this.editor.update(() => {\n      const anchorTableCellNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.gridSelection = lexical.DEPRECATED_$createGridSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n\n  formatCells(type) {\n    this.editor.update(() => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.DEPRECATED_$isGridSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n\n      const formatSelection = lexical.$createRangeSelection();\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n      selection.getNodes().forEach(cellNode => {\n        if ($isTableCellNode(cellNode) && cellNode.getTextContentSize() !== 0) {\n          anchor.set(cellNode.getKey(), 0, 'element');\n          focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n          formatSelection.formatText(type);\n        }\n      });\n      lexical.$setSelection(selection);\n      this.editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n\n  clearText() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const selection = lexical.$getSelection();\n\n      if (!lexical.DEPRECATED_$isGridSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n\n      if (selectedNodes.length === this.grid.columns * this.grid.rows) {\n        tableNode.selectPrevious(); // Delete entire table\n\n        tableNode.remove();\n        const rootNode = lexical.$getRoot();\n        rootNode.selectStart();\n        return;\n      }\n\n      selectedNodes.forEach(cellNode => {\n        if (lexical.$isElementNode(cellNode)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          const textNode = lexical.$createTextNode();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach(child => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n      $updateDOMForSelection(editor, this.grid, null);\n      lexical.$setSelection(null);\n      editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nfunction applyTableHandlers(tableNode, tableElement, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n\n  const tableSelection = new TableSelection(editor, tableNode.getKey());\n  const editorWindow = editor._window || window;\n  attachTableSelectionToTableElement(tableElement, tableSelection);\n  tableElement.addEventListener('mousedown', event => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      }\n\n      if (!editorWindow) {\n        return;\n      }\n\n      const anchorCell = getCellFromTarget(event.target);\n\n      if (anchorCell !== null) {\n        stopEvent(event);\n        tableSelection.setAnchorCellForSelection(anchorCell);\n      }\n\n      const onMouseUp = () => {\n        editorWindow.removeEventListener('mouseup', onMouseUp);\n        editorWindow.removeEventListener('mousemove', onMouseMove);\n      };\n\n      const onMouseMove = moveEvent => {\n        const focusCell = getCellFromTarget(moveEvent.target);\n\n        if (focusCell !== null && (tableSelection.anchorX !== focusCell.x || tableSelection.anchorY !== focusCell.y)) {\n          moveEvent.preventDefault();\n          tableSelection.setFocusCellForSelection(focusCell);\n        }\n      };\n\n      editorWindow.addEventListener('mouseup', onMouseUp);\n      editorWindow.addEventListener('mousemove', onMouseMove);\n    }, 0);\n  }); // Clear selection when clicking outside of dom.\n\n  const mouseDownCallback = event => {\n    if (event.button !== 0) {\n      return;\n    }\n\n    editor.update(() => {\n      const selection = lexical.$getSelection();\n      const target = event.target;\n\n      if (lexical.DEPRECATED_$isGridSelection(selection) && selection.gridKey === tableSelection.tableNodeKey && rootElement.contains(target)) {\n        tableSelection.clearHighlight();\n      }\n    });\n  };\n\n  editorWindow.addEventListener('mousedown', mouseDownCallback);\n  tableSelection.listenersToRemove.add(() => editorWindow.removeEventListener('mousedown', mouseDownCallback));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => $handleArrowKey(editor, event, 'down', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => $handleArrowKey(editor, event, 'up', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => $handleArrowKey(editor, event, 'backward', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => $handleArrowKey(editor, event, 'forward', tableNode, tableSelection), lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      const focusCellNode = utils.$findMatchingParent(selection.focus.getNode(), $isTableCellNode);\n\n      if ($isTableCellNode(focusCellNode)) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_HIGH));\n\n  const deleteTextHandler = command => () => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.clearText();\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n\n      if (selectionContainsPartialTable) {\n        tableSelection.clearText();\n        return true;\n      }\n\n      const nearestElementNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && utils.$findMatchingParent(nearestElementNode, n => lexical.$isElementNode(n) && $isTableCellNode(n.getParent()));\n\n      if (!lexical.$isElementNode(topLevelCellElementNode) || !lexical.$isElementNode(nearestElementNode)) {\n        return false;\n      }\n\n      if (command === lexical.DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n\n      if (command === lexical.DELETE_CHARACTER_COMMAND || command === lexical.DELETE_WORD_COMMAND) {\n        if (selection.isCollapsed() && selection.anchor.offset === 0) {\n          if (nearestElementNode !== topLevelCellElementNode) {\n            const children = nearestElementNode.getChildren();\n            const newParagraphNode = lexical.$createParagraphNode();\n            children.forEach(child => newParagraphNode.append(child));\n            nearestElementNode.replace(newParagraphNode);\n            nearestElementNode.getWritable().__parent = tableCellNode.getKey();\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  [lexical.DELETE_WORD_COMMAND, lexical.DELETE_LINE_COMMAND, lexical.DELETE_CHARACTER_COMMAND].forEach(command => {\n    tableSelection.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), lexical.COMMAND_PRIORITY_CRITICAL));\n  });\n\n  const deleteCellHandler = event => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      event.preventDefault();\n      event.stopPropagation();\n      tableSelection.clearText();\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  };\n\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, deleteCellHandler, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_DELETE_COMMAND, deleteCellHandler, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.formatCells(payload);\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.clearHighlight();\n      return false;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n\n  if (hasTabHandler) {\n    tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n\n      if (tableCellNode === null) {\n        return false;\n      }\n\n      stopEvent(event);\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n      selectGridNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL));\n  }\n\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, lexical.COMMAND_PRIORITY_HIGH));\n\n  function getCellFromCellNode(tableCellNode) {\n    const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n    return tableNode.getCellFromCordsOrThrow(currentCords.x, currentCords.y, tableSelection.grid);\n  }\n\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.SELECTION_CHANGE_COMMAND, () => {\n    const selection = lexical.$getSelection();\n    const prevSelection = lexical.$getPreviousSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode(); // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = anchorCellNode && tableNode.is($findTableNode(anchorCellNode));\n      const isFocusInside = focusCellNode && tableNode.is($findTableNode(focusCellNode));\n      const isPartialyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n\n      if (isPartialyWithinTable) {\n        const newSelection = selection.clone();\n        newSelection.focus.set(tableNode.getKey(), isBackward ? 0 : tableNode.getChildrenSize(), 'element');\n        lexical.$setSelection(newSelection);\n        $addHighlightStyleToTable(editor, tableSelection);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into grid selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableSelection.setAnchorCellForSelection(getCellFromCellNode(anchorCellNode));\n          tableSelection.setFocusCellForSelection(getCellFromCellNode(focusCellNode), true);\n        }\n      }\n    }\n\n    if (selection && !selection.is(prevSelection) && (lexical.DEPRECATED_$isGridSelection(selection) || lexical.DEPRECATED_$isGridSelection(prevSelection)) && tableSelection.gridSelection && !tableSelection.gridSelection.is(prevSelection)) {\n      if (lexical.DEPRECATED_$isGridSelection(selection) && selection.gridKey === tableSelection.tableNodeKey) {\n        tableSelection.updateTableGridSelection(selection);\n      } else if (!lexical.DEPRECATED_$isGridSelection(selection) && lexical.DEPRECATED_$isGridSelection(prevSelection) && prevSelection.gridKey === tableSelection.tableNodeKey) {\n        tableSelection.updateTableGridSelection(null);\n      }\n\n      return false;\n    }\n\n    if (tableSelection.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableSelection);\n    } else if (!tableSelection.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableSelection);\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  return tableSelection;\n}\nfunction attachTableSelectionToTableElement(tableElement, tableSelection) {\n  tableElement[LEXICAL_ELEMENT_KEY] = tableSelection;\n}\nfunction getTableSelectionFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY];\n}\nfunction getCellFromTarget(node) {\n  let currentNode = node;\n\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n\n      if (cell === undefined) {\n        return null;\n      }\n\n      return cell;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n}\nfunction getTableGrid(tableElement) {\n  const cells = [];\n  const grid = {\n    cells,\n    columns: 0,\n    rows: 0\n  };\n  let currentNode = tableElement.firstChild;\n  let x = 0;\n  let y = 0;\n  cells.length = 0;\n\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      }; // @ts-expect-error: internal field\n\n      currentNode._cell = cell;\n\n      if (cells[y] === undefined) {\n        cells[y] = [];\n      }\n\n      cells[y][x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n\n    const sibling = currentNode.nextSibling;\n\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n\n    const parent = currentNode.parentNode;\n\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n\n      if (parentSibling == null) {\n        break;\n      }\n\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, grid, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachGridCell(grid, (cell, lexicalNode) => {\n    const elem = cell.elem;\n\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachGridCell(grid, cb) {\n  const {\n    cells\n  } = grid;\n\n  for (let y = 0; y < cells.length; y++) {\n    const row = cells[y];\n\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      const lexicalNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.disableHighlightStyle();\n  $forEachGridCell(tableSelection.grid, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.enableHighlightStyle();\n  $forEachGridCell(tableSelection.grid, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\n\nconst selectGridNodeInDirection = (tableSelection, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableSelection.grid.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableSelection.grid), isForward);\n      } else {\n        if (y !== (isForward ? tableSelection.grid.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableSelection.grid.columns - 1, y + (isForward ? 1 : -1), tableSelection.grid), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n\n      return true;\n\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableSelection.grid), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n\n      return true;\n\n    case 'down':\n      if (y !== tableSelection.grid.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableSelection.grid), true);\n      } else {\n        tableNode.selectNext();\n      }\n\n      return true;\n\n    default:\n      return false;\n  }\n};\n\nconst adjustFocusNodeInDirection = (tableSelection, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableSelection.grid.columns - 1 : 0)) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableSelection.grid));\n      }\n\n      return true;\n\n    case 'up':\n      if (y !== 0) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x, y - 1, tableSelection.grid));\n        return true;\n      } else {\n        return false;\n      }\n\n    case 'down':\n      if (y !== tableSelection.grid.rows - 1) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x, y + 1, tableSelection.grid));\n        return true;\n      } else {\n        return false;\n      }\n\n    default:\n      return false;\n  }\n};\n\nfunction $isSelectionInTable(selection, tableNode) {\n  if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n\n  return false;\n}\n\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\n\nconst BROWSER_BLUE_RGB = '172,206,247';\n\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const node = lexical.$getNearestNodeFromDOMNode(element);\n\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n\n  const backgroundColor = node.getBackgroundColor();\n\n  if (backgroundColor === null) {\n    element.style.setProperty('background-color', `rgb(${BROWSER_BLUE_RGB})`);\n  } else {\n    element.style.setProperty('background-image', `linear-gradient(to right, rgba(${BROWSER_BLUE_RGB},0.85), rgba(${BROWSER_BLUE_RGB},0.85))`);\n  }\n\n  element.style.setProperty('caret-color', 'transparent');\n}\n\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = lexical.$getNearestNodeFromDOMNode(element);\n\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n\n  const backgroundColor = node.getBackgroundColor();\n\n  if (backgroundColor === null) {\n    element.style.removeProperty('background-color');\n  }\n\n  element.style.removeProperty('background-image');\n  element.style.removeProperty('caret-color');\n}\n\nfunction $findCellNode(node) {\n  const cellNode = utils.$findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\n\nfunction $findTableNode(node) {\n  const tableNode = utils.$findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\n\nfunction $handleArrowKey(editor, event, direction, tableNode, tableSelection) {\n  const selection = lexical.$getSelection();\n\n  if (!$isSelectionInTable(selection, tableNode)) {\n    return false;\n  }\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed()) {\n    // Horizontal move between cels seem to work well without interruption\n    // so just exit early, and handle vertical moves\n    if (direction === 'backward' || direction === 'forward') {\n      return false;\n    }\n\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = utils.$findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = utils.$findMatchingParent(focus.getNode(), $isTableCellNode);\n\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n\n    let edgeSelectionRect;\n\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = window.getSelection();\n\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n\n    if (edgeChild == null) {\n      return false;\n    }\n\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n\n    if (edgeChildDOM == null) {\n      return false;\n    }\n\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableSelection.grid);\n\n      if (event.shiftKey) {\n        const cell = tableNode.getCellFromCordsOrThrow(cords.x, cords.y, tableSelection.grid);\n        tableSelection.setAnchorCellForSelection(cell);\n        tableSelection.setFocusCellForSelection(cell, true);\n      } else {\n        return selectGridNodeInDirection(tableSelection, tableNode, cords.x, cords.y, direction);\n      }\n\n      return true;\n    }\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = utils.$findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = utils.$findMatchingParent(focus.getNode(), $isTableCellNode);\n\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode)) {\n      return false;\n    }\n\n    stopEvent(event);\n\n    if (event.shiftKey) {\n      const cords = tableNode.getCordsFromCellNode(focusCellNode, tableSelection.grid);\n      return adjustFocusNodeInDirection(tableSelection, tableNode, cords.x, cords.y, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableNode extends lexical.DEPRECATED_GridNode {\n  /** @internal */\n  static getType() {\n    return 'table';\n  }\n\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: convertTableElement,\n        priority: 1\n      })\n    };\n  }\n\n  static importJSON(_serializedNode) {\n    return $createTableNode();\n  }\n\n  constructor(key) {\n    super(key);\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'table',\n      version: 1\n    };\n  }\n\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    utils.addClassNamesToElement(tableElement, config.theme.table);\n    return tableElement;\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  exportDOM(editor) {\n    return { ...super.exportDOM(editor),\n      after: tableElement => {\n        if (tableElement) {\n          const newElement = tableElement.cloneNode();\n          const colGroup = document.createElement('colgroup');\n          const tBody = document.createElement('tbody');\n          tBody.append(...tableElement.children);\n          const firstRow = this.getFirstChildOrThrow();\n\n          if (!$isTableRowNode(firstRow)) {\n            throw new Error('Expected to find row node.');\n          }\n\n          const colCount = firstRow.getChildrenSize();\n\n          for (let i = 0; i < colCount; i++) {\n            const col = document.createElement('col');\n            colGroup.append(col);\n          }\n\n          newElement.replaceChildren(colGroup, tBody);\n          return newElement;\n        }\n      }\n    };\n  } // TODO 0.10 deprecate\n\n\n  canExtractContents() {\n    return false;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  isShadowRoot() {\n    return true;\n  }\n\n  getCordsFromCellNode(tableCellNode, grid) {\n    const {\n      rows,\n      cells\n    } = grid;\n\n    for (let y = 0; y < rows; y++) {\n      const row = cells[y];\n\n      if (row == null) {\n        throw new Error(`Row not found at y:${y}`);\n      }\n\n      const x = row.findIndex(({\n        elem\n      }) => {\n        const cellNode = lexical.$getNearestNodeFromDOMNode(elem);\n        return cellNode === tableCellNode;\n      });\n\n      if (x !== -1) {\n        return {\n          x,\n          y\n        };\n      }\n    }\n\n    throw new Error('Cell not found in table.');\n  }\n\n  getCellFromCords(x, y, grid) {\n    const {\n      cells\n    } = grid;\n    const row = cells[y];\n\n    if (row == null) {\n      return null;\n    }\n\n    const cell = row[x];\n\n    if (cell == null) {\n      return null;\n    }\n\n    return cell;\n  }\n\n  getCellFromCordsOrThrow(x, y, grid) {\n    const cell = this.getCellFromCords(x, y, grid);\n\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n\n    return cell;\n  }\n\n  getCellNodeFromCords(x, y, grid) {\n    const cell = this.getCellFromCords(x, y, grid);\n\n    if (cell == null) {\n      return null;\n    }\n\n    const node = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n\n    return null;\n  }\n\n  getCellNodeFromCordsOrThrow(x, y, grid) {\n    const node = this.getCellNodeFromCords(x, y, grid);\n\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n\n    return node;\n  }\n\n  canSelectBefore() {\n    return true;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n}\nfunction $getElementGridForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n\n  return getTableGrid(tableElement);\n}\nfunction convertTableElement(_domNode) {\n  return {\n    node: $createTableNode()\n  };\n}\nfunction $createTableNode() {\n  return lexical.$applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) headerState |= TableCellHeaderStates.ROW;\n        if (iColumn === 0 && includeHeaders.columns) headerState |= TableCellHeaderStates.COLUMN;\n      } else if (includeHeaders) {\n        if (iRow === 0) headerState |= TableCellHeaderStates.ROW;\n        if (iColumn === 0) headerState |= TableCellHeaderStates.COLUMN;\n      }\n\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = lexical.$createParagraphNode();\n      paragraphNode.append(lexical.$createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n\n    tableNode.append(tableRowNode);\n  }\n\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableCellNode(n));\n\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableRowNode(n));\n\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableNode(n));\n\n  if ($isTableNode(node)) {\n    return node;\n  }\n\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, grid) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, grid);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, grid),\n    below: tableNode.getCellNodeFromCords(x, y + 1, grid),\n    left: tableNode.getCellNodeFromCords(x - 1, y, grid),\n    right: tableNode.getCellNodeFromCords(x + 1, y, grid)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, grid) {\n  const tableRows = tableNode.getChildren();\n\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n\n  const targetRowNode = tableRows[targetIndex];\n\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, grid);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append(lexical.$createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n\n  return tableNode;\n}\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const focus = selection.focus.getNode();\n  const [focusCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, focusCellMap] = lexical.DEPRECATED_$computeGridMap(grid, focusCell, focusCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n\n  if (insertAfter) {\n    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n    const focusEndRowMap = gridMap[focusEndRow];\n    const newRow = $createTableRowNode();\n\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusEndRowMap[i];\n\n      if (startRow + cell.__rowSpan - 1 <= focusEndRow) {\n        newRow.append($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n\n    const focusEndRowNode = grid.getChildAtIndex(focusEndRow);\n\n    if (!lexical.DEPRECATED_$isGridRowNode(focusEndRowNode)) {\n      throw Error(`focusEndRow is not a GridRowNode`);\n    }\n\n    focusEndRowNode.insertAfter(newRow);\n  } else {\n    const focusStartRowMap = gridMap[focusStartRow];\n    const newRow = $createTableRowNode();\n\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusStartRowMap[i];\n\n      if (startRow === focusStartRow) {\n        newRow.append($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n\n    const focusStartRowNode = grid.getChildAtIndex(focusStartRow);\n\n    if (!lexical.DEPRECATED_$isGridRowNode(focusStartRowNode)) {\n      throw Error(`focusEndRow is not a GridRowNode`);\n    }\n\n    focusStartRowNode.insertBefore(newRow);\n  }\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, grid) {\n  const tableRows = tableNode.getChildren();\n\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n\n        const targetCell = tableRowChildren[targetIndex];\n\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, grid);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append(lexical.$createParagraphNode());\n\n        if (shouldInsertAfter) {\n          targetCell.insertAfter(newTableCell);\n        } else {\n          targetCell.insertBefore(newTableCell);\n        }\n      }\n    }\n  }\n\n  return tableNode;\n}\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const [focusCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = lexical.DEPRECATED_$computeGridMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n\n  if (!lexical.DEPRECATED_$isGridRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n\n  let firstInsertedCell = null;\n\n  function $createTableCellNodeForInsertTableColumn() {\n    const cell = $createTableCellNode(TableCellHeaderStates.NO_STATUS).append(lexical.$createParagraphNode());\n\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n\n    return cell;\n  }\n\n  let loopRow = gridFirstChild;\n\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n\n      if (!lexical.DEPRECATED_$isGridRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n\n      loopRow = currentRow;\n    }\n\n    const rowMap = gridMap[i];\n\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn());\n      continue;\n    }\n\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn());\n          continue rowLoop;\n        }\n      }\n\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn());\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const [focusCell] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = lexical.DEPRECATED_$computeGridMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      } // Rows overflowing top have to be trimmed\n\n\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        cell.setRowSpan(cell.__rowSpan - (cellStartRow - anchorStartRow));\n      } // Rows overflowing bottom have to be trimmed and moved to the next row\n\n\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n\n        if (column === 0) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          const {\n            cell: previousCell\n          } = nextRow[column - 1];\n          previousCell.insertAfter(cell);\n        }\n      }\n    }\n\n    const rowNode = grid.getChildAtIndex(row);\n\n    if (!lexical.DEPRECATED_$isGridRowNode(rowNode)) {\n      throw Error(`Expected GridNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n\n    rowNode.remove();\n  }\n\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const [focusCell] = lexical.DEPRECATED_$getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = lexical.DEPRECATED_$computeGridMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n\n  const rowCount = gridMap.length;\n\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn; // Overflowing left\n\n          cell.setColSpan(cell.__colSpan - // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = focusRowMap[focusStartColumn + focusCell.__colSpan];\n\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusRowMap[focusStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n}\n\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n\n  if (!(firstDescendant !== null)) {\n    throw Error(`Unexpected empty cell`);\n  }\n\n  firstDescendant.getParentOrThrow().selectStart();\n}\n\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\nfunction $unmergeCell() {\n  const selection = lexical.$getSelection();\n\n  if (!(lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    throw Error(`Expected a RangeSelection or GridSelection`);\n  }\n\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = lexical.DEPRECATED_$getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n    }\n\n    cell.setColSpan(1);\n  }\n\n  if (rowSpan > 1) {\n    const [map, cellMap] = lexical.DEPRECATED_$computeGridMap(grid, cell, cell);\n    const {\n      startColumn,\n      startRow\n    } = cellMap;\n    let currentRowNode;\n\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = row.getNextSibling();\n\n      if (!lexical.DEPRECATED_$isGridRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n\n      let insertAfterCell = null;\n\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n\n      if (insertAfterCell === null) {\n        for (let j = 0; j < colSpan; j++) {\n          $insertFirst(currentRowNode, $createTableCellNode(TableCellHeaderStates.NO_STATUS));\n        }\n      } else {\n        for (let j = 0; j < colSpan; j++) {\n          insertAfterCell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS));\n        }\n      }\n    }\n\n    cell.setRowSpan(1);\n  }\n}\n\n/** @module @lexical/table */\nconst INSERT_TABLE_COMMAND = lexical.createCommand('INSERT_TABLE_COMMAND');\n\nexports.$createTableCellNode = $createTableCellNode;\nexports.$createTableNode = $createTableNode;\nexports.$createTableNodeWithDimensions = $createTableNodeWithDimensions;\nexports.$createTableRowNode = $createTableRowNode;\nexports.$deleteTableColumn = $deleteTableColumn;\nexports.$deleteTableColumn__EXPERIMENTAL = $deleteTableColumn__EXPERIMENTAL;\nexports.$deleteTableRow__EXPERIMENTAL = $deleteTableRow__EXPERIMENTAL;\nexports.$getElementGridForTableNode = $getElementGridForTableNode;\nexports.$getTableCellNodeFromLexicalNode = $getTableCellNodeFromLexicalNode;\nexports.$getTableColumnIndexFromTableCellNode = $getTableColumnIndexFromTableCellNode;\nexports.$getTableNodeFromLexicalNodeOrThrow = $getTableNodeFromLexicalNodeOrThrow;\nexports.$getTableRowIndexFromTableCellNode = $getTableRowIndexFromTableCellNode;\nexports.$getTableRowNodeFromTableCellNodeOrThrow = $getTableRowNodeFromTableCellNodeOrThrow;\nexports.$insertTableColumn = $insertTableColumn;\nexports.$insertTableColumn__EXPERIMENTAL = $insertTableColumn__EXPERIMENTAL;\nexports.$insertTableRow = $insertTableRow;\nexports.$insertTableRow__EXPERIMENTAL = $insertTableRow__EXPERIMENTAL;\nexports.$isTableCellNode = $isTableCellNode;\nexports.$isTableNode = $isTableNode;\nexports.$isTableRowNode = $isTableRowNode;\nexports.$removeTableRowAtIndex = $removeTableRowAtIndex;\nexports.$unmergeCell = $unmergeCell;\nexports.INSERT_TABLE_COMMAND = INSERT_TABLE_COMMAND;\nexports.TableCellHeaderStates = TableCellHeaderStates;\nexports.TableCellNode = TableCellNode;\nexports.TableNode = TableNode;\nexports.TableRowNode = TableRowNode;\nexports.TableSelection = TableSelection;\nexports.applyTableHandlers = applyTableHandlers;\nexports.getCellFromTarget = getCellFromTarget;\nexports.getTableSelectionFromTableElement = getTableSelectionFromTableElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGFibGUvTGV4aWNhbFRhYmxlLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsd0RBQVM7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MscURBQXFEO0FBQ3JGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlEQUF5RCxpQkFBaUI7QUFDMUUsSUFBSTtBQUNKLG9GQUFvRixpQkFBaUIsZUFBZSxpQkFBaUI7QUFDckk7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLG9CQUFvQixVQUFVO0FBQzlCOztBQUVBO0FBQ0EsOENBQThDLEVBQUU7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGlCQUFpQjtBQUN0Qzs7QUFFQSwwQkFBMEIsdUJBQXVCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixzQkFBc0I7QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLHVCQUF1QjtBQUNyRCx1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEMsbUNBQW1DLHFCQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsd0JBQXdCO0FBQ3hCLHNDQUFzQztBQUN0QywyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLHdDQUF3QztBQUN4QyxxQ0FBcUM7QUFDckMsbUNBQW1DO0FBQ25DLHdDQUF3QztBQUN4Qyw2Q0FBNkM7QUFDN0MsMkNBQTJDO0FBQzNDLDBDQUEwQztBQUMxQyxnREFBZ0Q7QUFDaEQsMEJBQTBCO0FBQzFCLHdDQUF3QztBQUN4Qyx1QkFBdUI7QUFDdkIscUNBQXFDO0FBQ3JDLHdCQUF3QjtBQUN4QixvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5QixvQkFBb0I7QUFDcEIsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6Qix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90YWJsZS9MZXhpY2FsVGFibGUuZGV2LmpzPzJiYWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQGxleGljYWwvdXRpbHMnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgUElYRUxfVkFMVUVfUkVHX0VYUCA9IC9eKFxcZCsoPzpcXC5cXGQrKT8pcHgkLztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgVGFibGVDZWxsSGVhZGVyU3RhdGVzID0ge1xuICBCT1RIOiAzLFxuICBDT0xVTU46IDIsXG4gIE5PX1NUQVRVUzogMCxcbiAgUk9XOiAxXG59O1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgVGFibGVDZWxsTm9kZSBleHRlbmRzIGxleGljYWwuREVQUkVDQVRFRF9HcmlkQ2VsbE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWJsZWNlbGwnO1xuICB9XG5cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICBjb25zdCBjZWxsTm9kZSA9IG5ldyBUYWJsZUNlbGxOb2RlKG5vZGUuX19oZWFkZXJTdGF0ZSwgbm9kZS5fX2NvbFNwYW4sIG5vZGUuX193aWR0aCwgbm9kZS5fX2tleSk7XG4gICAgY2VsbE5vZGUuX19yb3dTcGFuID0gbm9kZS5fX3Jvd1NwYW47XG4gICAgY2VsbE5vZGUuX19iYWNrZ3JvdW5kQ29sb3IgPSBub2RlLl9fYmFja2dyb3VuZENvbG9yO1xuICAgIHJldHVybiBjZWxsTm9kZTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRkOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUYWJsZUNlbGxOb2RlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgdGg6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRhYmxlQ2VsbE5vZGVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBjb2xTcGFuID0gc2VyaWFsaXplZE5vZGUuY29sU3BhbiB8fCAxO1xuICAgIGNvbnN0IHJvd1NwYW4gPSBzZXJpYWxpemVkTm9kZS5yb3dTcGFuIHx8IDE7XG4gICAgY29uc3QgY2VsbE5vZGUgPSAkY3JlYXRlVGFibGVDZWxsTm9kZShzZXJpYWxpemVkTm9kZS5oZWFkZXJTdGF0ZSwgY29sU3Bhbiwgc2VyaWFsaXplZE5vZGUud2lkdGggfHwgdW5kZWZpbmVkKTtcbiAgICBjZWxsTm9kZS5fX3Jvd1NwYW4gPSByb3dTcGFuO1xuICAgIGNlbGxOb2RlLl9fYmFja2dyb3VuZENvbG9yID0gc2VyaWFsaXplZE5vZGUuYmFja2dyb3VuZENvbG9yIHx8IG51bGw7XG4gICAgcmV0dXJuIGNlbGxOb2RlO1xuICB9XG5cbiAgY29uc3RydWN0b3IoaGVhZGVyU3RhdGUgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTLCBjb2xTcGFuID0gMSwgd2lkdGgsIGtleSkge1xuICAgIHN1cGVyKGNvbFNwYW4sIGtleSk7XG4gICAgdGhpcy5fX2hlYWRlclN0YXRlID0gaGVhZGVyU3RhdGU7XG4gICAgdGhpcy5fX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5fX2JhY2tncm91bmRDb2xvciA9IG51bGw7XG4gIH1cblxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5nZXRUYWcoKSk7XG5cbiAgICBpZiAodGhpcy5fX3dpZHRoKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gYCR7dGhpcy5fX3dpZHRofXB4YDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICBlbGVtZW50LmNvbFNwYW4gPSB0aGlzLl9fY29sU3BhbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fX3Jvd1NwYW4gPiAxKSB7XG4gICAgICBlbGVtZW50LnJvd1NwYW4gPSB0aGlzLl9fcm93U3BhbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fX2JhY2tncm91bmRDb2xvciAhPT0gbnVsbCkge1xuICAgICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl9fYmFja2dyb3VuZENvbG9yO1xuICAgIH1cblxuICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLnRhYmxlQ2VsbCwgdGhpcy5oYXNIZWFkZXIoKSAmJiBjb25maWcudGhlbWUudGFibGVDZWxsSGVhZGVyKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50XG4gICAgfSA9IHN1cGVyLmV4cG9ydERPTShlZGl0b3IpO1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRfID0gZWxlbWVudDtcbiAgICAgIGNvbnN0IG1heFdpZHRoID0gNzAwO1xuICAgICAgY29uc3QgY29sQ291bnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5nZXRDaGlsZHJlblNpemUoKTtcbiAgICAgIGVsZW1lbnRfLnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgYmxhY2snO1xuXG4gICAgICBpZiAodGhpcy5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICAgIGVsZW1lbnRfLmNvbFNwYW4gPSB0aGlzLl9fY29sU3BhbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX19yb3dTcGFuID4gMSkge1xuICAgICAgICBlbGVtZW50Xy5yb3dTcGFuID0gdGhpcy5fX3Jvd1NwYW47XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnRfLnN0eWxlLndpZHRoID0gYCR7dGhpcy5nZXRXaWR0aCgpIHx8IE1hdGgubWF4KDkwLCBtYXhXaWR0aCAvIGNvbENvdW50KX1weGA7XG4gICAgICBlbGVtZW50Xy5zdHlsZS52ZXJ0aWNhbEFsaWduID0gJ3RvcCc7XG4gICAgICBlbGVtZW50Xy5zdHlsZS50ZXh0QWxpZ24gPSAnc3RhcnQnO1xuICAgICAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gdGhpcy5nZXRCYWNrZ3JvdW5kQ29sb3IoKTtcblxuICAgICAgaWYgKGJhY2tncm91bmRDb2xvciAhPT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50Xy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzSGVhZGVyKCkpIHtcbiAgICAgICAgZWxlbWVudF8uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNmMmYzZjUnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmdldEJhY2tncm91bmRDb2xvcigpLFxuICAgICAgaGVhZGVyU3RhdGU6IHRoaXMuX19oZWFkZXJTdGF0ZSxcbiAgICAgIHR5cGU6ICd0YWJsZWNlbGwnLFxuICAgICAgd2lkdGg6IHRoaXMuZ2V0V2lkdGgoKVxuICAgIH07XG4gIH1cblxuICBnZXRUYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzSGVhZGVyKCkgPyAndGgnIDogJ3RkJztcbiAgfVxuXG4gIHNldEhlYWRlclN0eWxlcyhoZWFkZXJTdGF0ZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2hlYWRlclN0YXRlID0gaGVhZGVyU3RhdGU7XG4gICAgcmV0dXJuIHRoaXMuX19oZWFkZXJTdGF0ZTtcbiAgfVxuXG4gIGdldEhlYWRlclN0eWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2hlYWRlclN0YXRlO1xuICB9XG5cbiAgc2V0V2lkdGgod2lkdGgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX193aWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiB0aGlzLl9fd2lkdGg7XG4gIH1cblxuICBnZXRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3dpZHRoO1xuICB9XG5cbiAgZ2V0QmFja2dyb3VuZENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fYmFja2dyb3VuZENvbG9yO1xuICB9XG5cbiAgc2V0QmFja2dyb3VuZENvbG9yKG5ld0JhY2tncm91bmRDb2xvcikge1xuICAgIHRoaXMuZ2V0V3JpdGFibGUoKS5fX2JhY2tncm91bmRDb2xvciA9IG5ld0JhY2tncm91bmRDb2xvcjtcbiAgfVxuXG4gIHRvZ2dsZUhlYWRlclN0eWxlKGhlYWRlclN0YXRlVG9Ub2dnbGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuXG4gICAgaWYgKChzZWxmLl9faGVhZGVyU3RhdGUgJiBoZWFkZXJTdGF0ZVRvVG9nZ2xlKSA9PT0gaGVhZGVyU3RhdGVUb1RvZ2dsZSkge1xuICAgICAgc2VsZi5fX2hlYWRlclN0YXRlIC09IGhlYWRlclN0YXRlVG9Ub2dnbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuX19oZWFkZXJTdGF0ZSArPSBoZWFkZXJTdGF0ZVRvVG9nZ2xlO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgaGFzSGVhZGVyU3RhdGUoaGVhZGVyU3RhdGUpIHtcbiAgICByZXR1cm4gKHRoaXMuZ2V0SGVhZGVyU3R5bGVzKCkgJiBoZWFkZXJTdGF0ZSkgPT09IGhlYWRlclN0YXRlO1xuICB9XG5cbiAgaGFzSGVhZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faGVhZGVyU3RhdGUgIT09IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gIH1cblxuICB1cGRhdGVET00ocHJldk5vZGUpIHtcbiAgICByZXR1cm4gcHJldk5vZGUuX19oZWFkZXJTdGF0ZSAhPT0gdGhpcy5fX2hlYWRlclN0YXRlIHx8IHByZXZOb2RlLl9fd2lkdGggIT09IHRoaXMuX193aWR0aCB8fCBwcmV2Tm9kZS5fX2NvbFNwYW4gIT09IHRoaXMuX19jb2xTcGFuIHx8IHByZXZOb2RlLl9fcm93U3BhbiAhPT0gdGhpcy5fX3Jvd1NwYW4gfHwgcHJldk5vZGUuX19iYWNrZ3JvdW5kQ29sb3IgIT09IHRoaXMuX19iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cblxuICBpc1NoYWRvd1Jvb3QoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb2xsYXBzZUF0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNhbkluZGVudCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxufVxuZnVuY3Rpb24gY29udmVydFRhYmxlQ2VsbE5vZGVFbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgZG9tTm9kZV8gPSBkb21Ob2RlO1xuICBjb25zdCBub2RlTmFtZSA9IGRvbU5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbGV0IHdpZHRoID0gdW5kZWZpbmVkO1xuXG4gIGlmIChQSVhFTF9WQUxVRV9SRUdfRVhQLnRlc3QoZG9tTm9kZV8uc3R5bGUud2lkdGgpKSB7XG4gICAgd2lkdGggPSBwYXJzZUZsb2F0KGRvbU5vZGVfLnN0eWxlLndpZHRoKTtcbiAgfVxuXG4gIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSAkY3JlYXRlVGFibGVDZWxsTm9kZShub2RlTmFtZSA9PT0gJ3RoJyA/IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1cgOiBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTLCBkb21Ob2RlXy5jb2xTcGFuLCB3aWR0aCk7XG4gIHRhYmxlQ2VsbE5vZGUuX19yb3dTcGFuID0gZG9tTm9kZV8ucm93U3BhbjtcbiAgY29uc3QgYmFja2dyb3VuZENvbG9yID0gZG9tTm9kZV8uc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuXG4gIGlmIChiYWNrZ3JvdW5kQ29sb3IgIT09ICcnKSB7XG4gICAgdGFibGVDZWxsTm9kZS5fX2JhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZm9yQ2hpbGQ6IChsZXhpY2FsTm9kZSwgcGFyZW50TGV4aWNhbE5vZGUpID0+IHtcbiAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKHBhcmVudExleGljYWxOb2RlKSAmJiAhbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShsZXhpY2FsTm9kZSkpIHtcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcblxuICAgICAgICBpZiAobGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKGxleGljYWxOb2RlKSAmJiBsZXhpY2FsTm9kZS5nZXRUZXh0Q29udGVudCgpID09PSAnXFxuJykge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYWdyYXBoTm9kZS5hcHBlbmQobGV4aWNhbE5vZGUpO1xuICAgICAgICByZXR1cm4gcGFyYWdyYXBoTm9kZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxleGljYWxOb2RlO1xuICAgIH0sXG4gICAgbm9kZTogdGFibGVDZWxsTm9kZVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUsIGNvbFNwYW4gPSAxLCB3aWR0aCkge1xuICByZXR1cm4gbGV4aWNhbC4kYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUsIGNvbFNwYW4sIHdpZHRoKSk7XG59XG5mdW5jdGlvbiAkaXNUYWJsZUNlbGxOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUYWJsZUNlbGxOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBUYWJsZVJvd05vZGUgZXh0ZW5kcyBsZXhpY2FsLkRFUFJFQ0FURURfR3JpZFJvd05vZGUge1xuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAndGFibGVyb3cnO1xuICB9XG5cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFRhYmxlUm93Tm9kZShub2RlLl9faGVpZ2h0LCBub2RlLl9fa2V5KTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUYWJsZVJvd0VsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlVGFibGVSb3dOb2RlKHNlcmlhbGl6ZWROb2RlLmhlaWdodCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihoZWlnaHQsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX2hlaWdodCA9IGhlaWdodDtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgdHlwZTogJ3RhYmxlcm93JyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuXG4gICAgaWYgKHRoaXMuX19oZWlnaHQpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5fX2hlaWdodH1weGA7XG4gICAgfVxuXG4gICAgdXRpbHMuYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjb25maWcudGhlbWUudGFibGVSb3cpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2hlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gdGhpcy5fX2hlaWdodDtcbiAgfVxuXG4gIGdldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2hlaWdodDtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSkge1xuICAgIHJldHVybiBwcmV2Tm9kZS5fX2hlaWdodCAhPT0gdGhpcy5fX2hlaWdodDtcbiAgfVxuXG4gIGNhbkJlRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59XG5mdW5jdGlvbiBjb252ZXJ0VGFibGVSb3dFbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgZG9tTm9kZV8gPSBkb21Ob2RlO1xuICBsZXQgaGVpZ2h0ID0gdW5kZWZpbmVkO1xuXG4gIGlmIChQSVhFTF9WQUxVRV9SRUdfRVhQLnRlc3QoZG9tTm9kZV8uc3R5bGUuaGVpZ2h0KSkge1xuICAgIGhlaWdodCA9IHBhcnNlRmxvYXQoZG9tTm9kZV8uc3R5bGUuaGVpZ2h0KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZVRhYmxlUm93Tm9kZShoZWlnaHQpXG4gIH07XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFibGVSb3dOb2RlKGhlaWdodCkge1xuICByZXR1cm4gbGV4aWNhbC4kYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRhYmxlUm93Tm9kZShoZWlnaHQpKTtcbn1cbmZ1bmN0aW9uICRpc1RhYmxlUm93Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGFibGVSb3dOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgZ2V0RE9NU2VsZWN0aW9uID0gdGFyZ2V0V2luZG93ID0+IENBTl9VU0VfRE9NID8gKHRhcmdldFdpbmRvdyB8fCB3aW5kb3cpLmdldFNlbGVjdGlvbigpIDogbnVsbDtcblxuY2xhc3MgVGFibGVTZWxlY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihlZGl0b3IsIHRhYmxlTm9kZUtleSkge1xuICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IGZhbHNlO1xuICAgIHRoaXMuYW5jaG9yWCA9IC0xO1xuICAgIHRoaXMuYW5jaG9yWSA9IC0xO1xuICAgIHRoaXMuZm9jdXNYID0gLTE7XG4gICAgdGhpcy5mb2N1c1kgPSAtMTtcbiAgICB0aGlzLmxpc3RlbmVyc1RvUmVtb3ZlID0gbmV3IFNldCgpO1xuICAgIHRoaXMudGFibGVOb2RlS2V5ID0gdGFibGVOb2RlS2V5O1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMuZ3JpZCA9IHtcbiAgICAgIGNlbGxzOiBbXSxcbiAgICAgIGNvbHVtbnM6IDAsXG4gICAgICByb3dzOiAwXG4gICAgfTtcbiAgICB0aGlzLmdyaWRTZWxlY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNDZWxsTm9kZUtleSA9IG51bGw7XG4gICAgdGhpcy5hbmNob3JDZWxsID0gbnVsbDtcbiAgICB0aGlzLmZvY3VzQ2VsbCA9IG51bGw7XG4gICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IGZhbHNlO1xuICAgIHRoaXMudHJhY2tUYWJsZUdyaWQoKTtcbiAgfVxuXG4gIGdldEdyaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JpZDtcbiAgfVxuXG4gIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBBcnJheS5mcm9tKHRoaXMubGlzdGVuZXJzVG9SZW1vdmUpLmZvckVhY2gocmVtb3ZlTGlzdGVuZXIgPT4gcmVtb3ZlTGlzdGVuZXIoKSk7XG4gIH1cblxuICB0cmFja1RhYmxlR3JpZCgpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHJlY29yZHMgPT4ge1xuICAgICAgdGhpcy5lZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgbGV0IGdyaWROZWVkc1JlZHJhdyA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHJlY29yZHNbaV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICBjb25zdCBub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZTtcblxuICAgICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ1RBQkxFJyB8fCBub2RlTmFtZSA9PT0gJ1RSJykge1xuICAgICAgICAgICAgZ3JpZE5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZ3JpZE5lZWRzUmVkcmF3KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFibGVFbGVtZW50ID0gdGhpcy5lZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcblxuICAgICAgICBpZiAoIXRhYmxlRWxlbWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBUYWJsZUVsZW1lbnQgaW4gRE9NJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdyaWQgPSBnZXRUYWJsZUdyaWQodGFibGVFbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSB0aGlzLmVkaXRvci5nZXRFbGVtZW50QnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuXG4gICAgICBpZiAoIXRhYmxlRWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgVGFibGVFbGVtZW50IGluIERPTScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmdyaWQgPSBnZXRUYWJsZUdyaWQodGFibGVFbGVtZW50KTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUodGFibGVFbGVtZW50LCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBjbGVhckhpZ2hsaWdodCgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICB0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgPSBmYWxzZTtcbiAgICB0aGlzLmFuY2hvclggPSAtMTtcbiAgICB0aGlzLmFuY2hvclkgPSAtMTtcbiAgICB0aGlzLmZvY3VzWCA9IC0xO1xuICAgIHRoaXMuZm9jdXNZID0gLTE7XG4gICAgdGhpcy5ncmlkU2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmZvY3VzQ2VsbE5vZGVLZXkgPSBudWxsO1xuICAgIHRoaXMuYW5jaG9yQ2VsbCA9IG51bGw7XG4gICAgdGhpcy5mb2N1c0NlbGwgPSBudWxsO1xuICAgIHRoaXMuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgPSBmYWxzZTtcbiAgICB0aGlzLmVuYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZU5vZGUgPSBsZXhpY2FsLiRnZXROb2RlQnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuXG4gICAgICBpZiAoISRpc1RhYmxlTm9kZSh0YWJsZU5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVGFibGVOb2RlLicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcblxuICAgICAgaWYgKCF0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZ3JpZCA9IGdldFRhYmxlR3JpZCh0YWJsZUVsZW1lbnQpO1xuICAgICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIGdyaWQsIG51bGwpO1xuICAgICAgbGV4aWNhbC4kc2V0U2VsZWN0aW9uKG51bGwpO1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLlNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfVxuXG4gIGVuYWJsZUhpZ2hsaWdodFN0eWxlKCkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgdGFibGVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG5cbiAgICAgIGlmICghdGFibGVFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBUYWJsZUVsZW1lbnQgaW4gRE9NJyk7XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLnJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudCh0YWJsZUVsZW1lbnQsIGVkaXRvci5fY29uZmlnLnRoZW1lLnRhYmxlU2VsZWN0aW9uKTtcbiAgICAgIHRhYmxlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkaXNhYmxlLXNlbGVjdGlvbicpO1xuICAgICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzYWJsZUhpZ2hsaWdodFN0eWxlKCkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgdGFibGVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG5cbiAgICAgIGlmICghdGFibGVFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBUYWJsZUVsZW1lbnQgaW4gRE9NJyk7XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQodGFibGVFbGVtZW50LCBlZGl0b3IuX2NvbmZpZy50aGVtZS50YWJsZVNlbGVjdGlvbik7XG4gICAgICB0aGlzLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVRhYmxlR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwgJiYgc2VsZWN0aW9uLmdyaWRLZXkgPT09IHRoaXMudGFibGVOb2RlS2V5KSB7XG4gICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgIHRoaXMuZ3JpZFNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IHRydWU7XG4gICAgICB0aGlzLmRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRoaXMuZ3JpZCwgdGhpcy5ncmlkU2VsZWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICB0aGlzLmNsZWFySGlnaGxpZ2h0KCk7XG4gICAgfVxuICB9XG5cbiAgc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGNlbGwsIGlnbm9yZVN0YXJ0ID0gZmFsc2UpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlTm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG5cbiAgICAgIGlmICghJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBUYWJsZU5vZGUuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuXG4gICAgICBpZiAoIXRhYmxlRWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgVGFibGVFbGVtZW50IGluIERPTScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjZWxsWCA9IGNlbGwueDtcbiAgICAgIGNvbnN0IGNlbGxZID0gY2VsbC55O1xuICAgICAgdGhpcy5mb2N1c0NlbGwgPSBjZWxsO1xuXG4gICAgICBpZiAodGhpcy5hbmNob3JDZWxsICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7IC8vIENvbGxhcHNlIHRoZSBzZWxlY3Rpb25cblxuICAgICAgICBpZiAoZG9tU2VsZWN0aW9uKSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLnNldEJhc2VBbmRFeHRlbnQodGhpcy5hbmNob3JDZWxsLmVsZW0sIDAsIHRoaXMuZm9jdXNDZWxsLmVsZW0sIDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzICYmICh0aGlzLmFuY2hvclggIT09IGNlbGxYIHx8IHRoaXMuYW5jaG9yWSAhPT0gY2VsbFkgfHwgaWdub3JlU3RhcnQpKSB7XG4gICAgICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICAgICB9IGVsc2UgaWYgKGNlbGxYID09PSB0aGlzLmZvY3VzWCAmJiBjZWxsWSA9PT0gdGhpcy5mb2N1c1kpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZvY3VzWCA9IGNlbGxYO1xuICAgICAgdGhpcy5mb2N1c1kgPSBjZWxsWTtcblxuICAgICAgaWYgKHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscykge1xuICAgICAgICBjb25zdCBmb2N1c1RhYmxlQ2VsbE5vZGUgPSBsZXhpY2FsLiRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGNlbGwuZWxlbSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JpZFNlbGVjdGlvbiAhPSBudWxsICYmIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgIT0gbnVsbCAmJiAkaXNUYWJsZUNlbGxOb2RlKGZvY3VzVGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBmb2N1c05vZGVLZXkgPSBmb2N1c1RhYmxlQ2VsbE5vZGUuZ2V0S2V5KCk7XG4gICAgICAgICAgdGhpcy5ncmlkU2VsZWN0aW9uID0gdGhpcy5ncmlkU2VsZWN0aW9uLmNsb25lKCkgfHwgbGV4aWNhbC5ERVBSRUNBVEVEXyRjcmVhdGVHcmlkU2VsZWN0aW9uKCk7XG4gICAgICAgICAgdGhpcy5mb2N1c0NlbGxOb2RlS2V5ID0gZm9jdXNOb2RlS2V5O1xuICAgICAgICAgIHRoaXMuZ3JpZFNlbGVjdGlvbi5zZXQodGhpcy50YWJsZU5vZGVLZXksIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXksIHRoaXMuZm9jdXNDZWxsTm9kZUtleSk7XG4gICAgICAgICAgbGV4aWNhbC4kc2V0U2VsZWN0aW9uKHRoaXMuZ3JpZFNlbGVjdGlvbik7XG4gICAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLlNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAkdXBkYXRlRE9NRm9yU2VsZWN0aW9uKGVkaXRvciwgdGhpcy5ncmlkLCB0aGlzLmdyaWRTZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGNlbGwpIHtcbiAgICB0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgPSBmYWxzZTtcbiAgICB0aGlzLmFuY2hvckNlbGwgPSBjZWxsO1xuICAgIHRoaXMuYW5jaG9yWCA9IGNlbGwueDtcbiAgICB0aGlzLmFuY2hvclkgPSBjZWxsLnk7XG4gICAgdGhpcy5lZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IGFuY2hvclRhYmxlQ2VsbE5vZGUgPSBsZXhpY2FsLiRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGNlbGwuZWxlbSk7XG5cbiAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGFuY2hvclRhYmxlQ2VsbE5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvck5vZGVLZXkgPSBhbmNob3JUYWJsZUNlbGxOb2RlLmdldEtleSgpO1xuICAgICAgICB0aGlzLmdyaWRTZWxlY3Rpb24gPSBsZXhpY2FsLkRFUFJFQ0FURURfJGNyZWF0ZUdyaWRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5hbmNob3JDZWxsTm9kZUtleSA9IGFuY2hvck5vZGVLZXk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmb3JtYXRDZWxscyh0eXBlKSB7XG4gICAgdGhpcy5lZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAoIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBncmlkIHNlbGVjdGlvbmApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZvcm1hdFNlbGVjdGlvbiA9IGxleGljYWwuJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCk7XG4gICAgICBjb25zdCBhbmNob3IgPSBmb3JtYXRTZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgZm9jdXMgPSBmb3JtYXRTZWxlY3Rpb24uZm9jdXM7XG4gICAgICBzZWxlY3Rpb24uZ2V0Tm9kZXMoKS5mb3JFYWNoKGNlbGxOb2RlID0+IHtcbiAgICAgICAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUoY2VsbE5vZGUpICYmIGNlbGxOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpICE9PSAwKSB7XG4gICAgICAgICAgYW5jaG9yLnNldChjZWxsTm9kZS5nZXRLZXkoKSwgMCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICBmb2N1cy5zZXQoY2VsbE5vZGUuZ2V0S2V5KCksIGNlbGxOb2RlLmdldENoaWxkcmVuU2l6ZSgpLCAnZWxlbWVudCcpO1xuICAgICAgICAgIGZvcm1hdFNlbGVjdGlvbi5mb3JtYXRUZXh0KHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxleGljYWwuJHNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgdGhpcy5lZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9XG5cbiAgY2xlYXJUZXh0KCkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgdGFibGVOb2RlID0gbGV4aWNhbC4kZ2V0Tm9kZUJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcblxuICAgICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFRhYmxlTm9kZS4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGdyaWQgc2VsZWN0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpLmZpbHRlcigkaXNUYWJsZUNlbGxOb2RlKTtcblxuICAgICAgaWYgKHNlbGVjdGVkTm9kZXMubGVuZ3RoID09PSB0aGlzLmdyaWQuY29sdW1ucyAqIHRoaXMuZ3JpZC5yb3dzKSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpOyAvLyBEZWxldGUgZW50aXJlIHRhYmxlXG5cbiAgICAgICAgdGFibGVOb2RlLnJlbW92ZSgpO1xuICAgICAgICBjb25zdCByb290Tm9kZSA9IGxleGljYWwuJGdldFJvb3QoKTtcbiAgICAgICAgcm9vdE5vZGUuc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3RlZE5vZGVzLmZvckVhY2goY2VsbE5vZGUgPT4ge1xuICAgICAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjZWxsTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhOb2RlID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gbGV4aWNhbC4kY3JlYXRlVGV4dE5vZGUoKTtcbiAgICAgICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgY2VsbE5vZGUuYXBwZW5kKHBhcmFncmFwaE5vZGUpO1xuICAgICAgICAgIGNlbGxOb2RlLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgIT09IHBhcmFncmFwaE5vZGUpIHtcbiAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRoaXMuZ3JpZCwgbnVsbCk7XG4gICAgICBsZXhpY2FsLiRzZXRTZWxlY3Rpb24obnVsbCk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9XG5cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgTEVYSUNBTF9FTEVNRU5UX0tFWSA9ICdfX2xleGljYWxUYWJsZVNlbGVjdGlvbic7XG5mdW5jdGlvbiBhcHBseVRhYmxlSGFuZGxlcnModGFibGVOb2RlLCB0YWJsZUVsZW1lbnQsIGVkaXRvciwgaGFzVGFiSGFuZGxlcikge1xuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuXG4gIGlmIChyb290RWxlbWVudCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gcm9vdCBlbGVtZW50LicpO1xuICB9XG5cbiAgY29uc3QgdGFibGVTZWxlY3Rpb24gPSBuZXcgVGFibGVTZWxlY3Rpb24oZWRpdG9yLCB0YWJsZU5vZGUuZ2V0S2V5KCkpO1xuICBjb25zdCBlZGl0b3JXaW5kb3cgPSBlZGl0b3IuX3dpbmRvdyB8fCB3aW5kb3c7XG4gIGF0dGFjaFRhYmxlU2VsZWN0aW9uVG9UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50LCB0YWJsZVNlbGVjdGlvbik7XG4gIHRhYmxlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBldmVudCA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlZGl0b3JXaW5kb3cpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhbmNob3JDZWxsID0gZ2V0Q2VsbEZyb21UYXJnZXQoZXZlbnQudGFyZ2V0KTtcblxuICAgICAgaWYgKGFuY2hvckNlbGwgIT09IG51bGwpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgdGFibGVTZWxlY3Rpb24uc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihhbmNob3JDZWxsKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb25Nb3VzZVVwID0gKCkgPT4ge1xuICAgICAgICBlZGl0b3JXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBvbk1vdXNlTW92ZSA9IG1vdmVFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGZvY3VzQ2VsbCA9IGdldENlbGxGcm9tVGFyZ2V0KG1vdmVFdmVudC50YXJnZXQpO1xuXG4gICAgICAgIGlmIChmb2N1c0NlbGwgIT09IG51bGwgJiYgKHRhYmxlU2VsZWN0aW9uLmFuY2hvclggIT09IGZvY3VzQ2VsbC54IHx8IHRhYmxlU2VsZWN0aW9uLmFuY2hvclkgIT09IGZvY3VzQ2VsbC55KSkge1xuICAgICAgICAgIG1vdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRhYmxlU2VsZWN0aW9uLnNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihmb2N1c0NlbGwpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBlZGl0b3JXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgICBlZGl0b3JXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIH0sIDApO1xuICB9KTsgLy8gQ2xlYXIgc2VsZWN0aW9uIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiBkb20uXG5cbiAgY29uc3QgbW91c2VEb3duQ2FsbGJhY2sgPSBldmVudCA9PiB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cbiAgICAgIGlmIChsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5ncmlkS2V5ID09PSB0YWJsZVNlbGVjdGlvbi50YWJsZU5vZGVLZXkgJiYgcm9vdEVsZW1lbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICB0YWJsZVNlbGVjdGlvbi5jbGVhckhpZ2hsaWdodCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBtb3VzZURvd25DYWxsYmFjayk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZCgoKSA9PiBlZGl0b3JXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2VEb3duQ2FsbGJhY2spKTtcbiAgdGFibGVTZWxlY3Rpb24ubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQVJST1dfRE9XTl9DT01NQU5ELCBldmVudCA9PiAkaGFuZGxlQXJyb3dLZXkoZWRpdG9yLCBldmVudCwgJ2Rvd24nLCB0YWJsZU5vZGUsIHRhYmxlU2VsZWN0aW9uKSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgdGFibGVTZWxlY3Rpb24ubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQVJST1dfVVBfQ09NTUFORCwgZXZlbnQgPT4gJGhhbmRsZUFycm93S2V5KGVkaXRvciwgZXZlbnQsICd1cCcsIHRhYmxlTm9kZSwgdGFibGVTZWxlY3Rpb24pLCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfSElHSCkpO1xuICB0YWJsZVNlbGVjdGlvbi5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9BUlJPV19MRUZUX0NPTU1BTkQsIGV2ZW50ID0+ICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCAnYmFja3dhcmQnLCB0YWJsZU5vZGUsIHRhYmxlU2VsZWN0aW9uKSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgdGFibGVTZWxlY3Rpb24ubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQVJST1dfUklHSFRfQ09NTUFORCwgZXZlbnQgPT4gJGhhbmRsZUFycm93S2V5KGVkaXRvciwgZXZlbnQsICdmb3J3YXJkJywgdGFibGVOb2RlLCB0YWJsZVNlbGVjdGlvbiksIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0VTQ0FQRV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgZm9jdXNDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG5cbiAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIGZvY3VzQ2VsbE5vZGUuc2VsZWN0RW5kKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcblxuICBjb25zdCBkZWxldGVUZXh0SGFuZGxlciA9IGNvbW1hbmQgPT4gKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICB0YWJsZVNlbGVjdGlvbi5jbGVhclRleHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcblxuICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGlzQW5jaG9ySW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2YoYW5jaG9yTm9kZSk7XG4gICAgICBjb25zdCBpc0ZvY3VzSW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2YoZm9jdXNOb2RlKTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbnRhaW5zUGFydGlhbFRhYmxlID0gaXNBbmNob3JJbnNpZGUgJiYgIWlzRm9jdXNJbnNpZGUgfHwgaXNGb2N1c0luc2lkZSAmJiAhaXNBbmNob3JJbnNpZGU7XG5cbiAgICAgIGlmIChzZWxlY3Rpb25Db250YWluc1BhcnRpYWxUYWJsZSkge1xuICAgICAgICB0YWJsZVNlbGVjdGlvbi5jbGVhclRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5lYXJlc3RFbGVtZW50Tm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShuKSk7XG4gICAgICBjb25zdCB0b3BMZXZlbENlbGxFbGVtZW50Tm9kZSA9IG5lYXJlc3RFbGVtZW50Tm9kZSAmJiB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KG5lYXJlc3RFbGVtZW50Tm9kZSwgbiA9PiBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG4pICYmICRpc1RhYmxlQ2VsbE5vZGUobi5nZXRQYXJlbnQoKSkpO1xuXG4gICAgICBpZiAoIWxleGljYWwuJGlzRWxlbWVudE5vZGUodG9wTGV2ZWxDZWxsRWxlbWVudE5vZGUpIHx8ICFsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG5lYXJlc3RFbGVtZW50Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tbWFuZCA9PT0gbGV4aWNhbC5ERUxFVEVfTElORV9DT01NQU5EICYmIHRvcExldmVsQ2VsbEVsZW1lbnROb2RlLmdldFByZXZpb3VzU2libGluZygpID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IEZpeCBEZWxldGUgTGluZSBpbiBUYWJsZSBDZWxscy5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21tYW5kID09PSBsZXhpY2FsLkRFTEVURV9DSEFSQUNURVJfQ09NTUFORCB8fCBjb21tYW5kID09PSBsZXhpY2FsLkRFTEVURV9XT1JEX0NPTU1BTkQpIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5lYXJlc3RFbGVtZW50Tm9kZSAhPT0gdG9wTGV2ZWxDZWxsRWxlbWVudE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbmVhcmVzdEVsZW1lbnROb2RlLmdldENoaWxkcmVuKCk7XG4gICAgICAgICAgICBjb25zdCBuZXdQYXJhZ3JhcGhOb2RlID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBuZXdQYXJhZ3JhcGhOb2RlLmFwcGVuZChjaGlsZCkpO1xuICAgICAgICAgICAgbmVhcmVzdEVsZW1lbnROb2RlLnJlcGxhY2UobmV3UGFyYWdyYXBoTm9kZSk7XG4gICAgICAgICAgICBuZWFyZXN0RWxlbWVudE5vZGUuZ2V0V3JpdGFibGUoKS5fX3BhcmVudCA9IHRhYmxlQ2VsbE5vZGUuZ2V0S2V5KCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgW2xleGljYWwuREVMRVRFX1dPUkRfQ09NTUFORCwgbGV4aWNhbC5ERUxFVEVfTElORV9DT01NQU5ELCBsZXhpY2FsLkRFTEVURV9DSEFSQUNURVJfQ09NTUFORF0uZm9yRWFjaChjb21tYW5kID0+IHtcbiAgICB0YWJsZVNlbGVjdGlvbi5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChjb21tYW5kLCBkZWxldGVUZXh0SGFuZGxlcihjb21tYW5kKSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIH0pO1xuXG4gIGNvbnN0IGRlbGV0ZUNlbGxIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0YWJsZVNlbGVjdGlvbi5jbGVhclRleHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcblxuICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgdGFibGVTZWxlY3Rpb24ubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQkFDS1NQQUNFX0NPTU1BTkQsIGRlbGV0ZUNlbGxIYW5kbGVyLCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVTZWxlY3Rpb24ubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfREVMRVRFX0NPTU1BTkQsIGRlbGV0ZUNlbGxIYW5kbGVyLCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVTZWxlY3Rpb24ubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5GT1JNQVRfVEVYVF9DT01NQU5ELCBwYXlsb2FkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgdGFibGVTZWxlY3Rpb24uZm9ybWF0Q2VsbHMocGF5bG9hZCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG5cbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVTZWxlY3Rpb24ubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5DT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICB0YWJsZVNlbGVjdGlvbi5jbGVhckhpZ2hsaWdodCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcblxuICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuXG4gIGlmIChoYXNUYWJIYW5kbGVyKSB7XG4gICAgdGFibGVTZWxlY3Rpb24ubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfVEFCX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kQ2VsbE5vZGUoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuXG4gICAgICBpZiAodGFibGVDZWxsTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICBjb25zdCBjdXJyZW50Q29yZHMgPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgdGFibGVTZWxlY3Rpb24uZ3JpZCk7XG4gICAgICBzZWxlY3RHcmlkTm9kZUluRGlyZWN0aW9uKHRhYmxlU2VsZWN0aW9uLCB0YWJsZU5vZGUsIGN1cnJlbnRDb3Jkcy54LCBjdXJyZW50Q29yZHMueSwgIWV2ZW50LnNoaWZ0S2V5ID8gJ2ZvcndhcmQnIDogJ2JhY2t3YXJkJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgfVxuXG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuRk9DVVNfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgcmV0dXJuIHRhYmxlTm9kZS5pc1NlbGVjdGVkKCk7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG5cbiAgZnVuY3Rpb24gZ2V0Q2VsbEZyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSB7XG4gICAgY29uc3QgY3VycmVudENvcmRzID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlU2VsZWN0aW9uLmdyaWQpO1xuICAgIHJldHVybiB0YWJsZU5vZGUuZ2V0Q2VsbEZyb21Db3Jkc09yVGhyb3coY3VycmVudENvcmRzLngsIGN1cnJlbnRDb3Jkcy55LCB0YWJsZVNlbGVjdGlvbi5ncmlkKTtcbiAgfVxuXG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3QgcHJldlNlbGVjdGlvbiA9IGxleGljYWwuJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZm9jdXNcbiAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTsgLy8gVXNpbmcgZXhwbGljaXQgY29tcGFyaXNvbiB3aXRoIHRhYmxlIG5vZGUgdG8gZW5zdXJlIGl0J3Mgbm90IGEgbmVzdGVkIHRhYmxlXG4gICAgICAvLyBhcyBpbiB0aGF0IGNhc2Ugd2UnbGwgbGVhdmUgc2VsZWN0aW9uIHJlc29sdmluZyB0byB0aGF0IHRhYmxlXG5cbiAgICAgIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGZpbmRDZWxsTm9kZShhbmNob3JOb2RlKTtcbiAgICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSAkZmluZENlbGxOb2RlKGZvY3VzTm9kZSk7XG4gICAgICBjb25zdCBpc0FuY2hvckluc2lkZSA9IGFuY2hvckNlbGxOb2RlICYmIHRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShhbmNob3JDZWxsTm9kZSkpO1xuICAgICAgY29uc3QgaXNGb2N1c0luc2lkZSA9IGZvY3VzQ2VsbE5vZGUgJiYgdGFibGVOb2RlLmlzKCRmaW5kVGFibGVOb2RlKGZvY3VzQ2VsbE5vZGUpKTtcbiAgICAgIGNvbnN0IGlzUGFydGlhbHlXaXRoaW5UYWJsZSA9IGlzQW5jaG9ySW5zaWRlICE9PSBpc0ZvY3VzSW5zaWRlO1xuICAgICAgY29uc3QgaXNXaXRoaW5UYWJsZSA9IGlzQW5jaG9ySW5zaWRlICYmIGlzRm9jdXNJbnNpZGU7XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcblxuICAgICAgaWYgKGlzUGFydGlhbHlXaXRoaW5UYWJsZSkge1xuICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBzZWxlY3Rpb24uY2xvbmUoKTtcbiAgICAgICAgbmV3U2VsZWN0aW9uLmZvY3VzLnNldCh0YWJsZU5vZGUuZ2V0S2V5KCksIGlzQmFja3dhcmQgPyAwIDogdGFibGVOb2RlLmdldENoaWxkcmVuU2l6ZSgpLCAnZWxlbWVudCcpO1xuICAgICAgICBsZXhpY2FsLiRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgJGFkZEhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlU2VsZWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNXaXRoaW5UYWJsZSkge1xuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIHNlbGVjdGlvbiBzcGFucyBhY3Jvc3MgbXVsdGlwbGUgY2VsbHMgYnV0IHN0aWxsXG4gICAgICAgIC8vIGhhcyByYW5nZSBzZWxlY3Rpb24sIHRoZW4gd2UgY29udmVydCBpdCBpbnRvIGdyaWQgc2VsZWN0aW9uXG4gICAgICAgIGlmICghYW5jaG9yQ2VsbE5vZGUuaXMoZm9jdXNDZWxsTm9kZSkpIHtcbiAgICAgICAgICB0YWJsZVNlbGVjdGlvbi5zZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGdldENlbGxGcm9tQ2VsbE5vZGUoYW5jaG9yQ2VsbE5vZGUpKTtcbiAgICAgICAgICB0YWJsZVNlbGVjdGlvbi5zZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oZ2V0Q2VsbEZyb21DZWxsTm9kZShmb2N1c0NlbGxOb2RlKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0aW9uICYmICFzZWxlY3Rpb24uaXMocHJldlNlbGVjdGlvbikgJiYgKGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikpICYmIHRhYmxlU2VsZWN0aW9uLmdyaWRTZWxlY3Rpb24gJiYgIXRhYmxlU2VsZWN0aW9uLmdyaWRTZWxlY3Rpb24uaXMocHJldlNlbGVjdGlvbikpIHtcbiAgICAgIGlmIChsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5ncmlkS2V5ID09PSB0YWJsZVNlbGVjdGlvbi50YWJsZU5vZGVLZXkpIHtcbiAgICAgICAgdGFibGVTZWxlY3Rpb24udXBkYXRlVGFibGVHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKCFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pICYmIGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIHByZXZTZWxlY3Rpb24uZ3JpZEtleSA9PT0gdGFibGVTZWxlY3Rpb24udGFibGVOb2RlS2V5KSB7XG4gICAgICAgIHRhYmxlU2VsZWN0aW9uLnVwZGF0ZVRhYmxlR3JpZFNlbGVjdGlvbihudWxsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0YWJsZVNlbGVjdGlvbi5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyAmJiAhdGFibGVOb2RlLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgJHJlbW92ZUhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlU2VsZWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKCF0YWJsZVNlbGVjdGlvbi5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyAmJiB0YWJsZU5vZGUuaXNTZWxlY3RlZCgpKSB7XG4gICAgICAkYWRkSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVTZWxlY3Rpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHJldHVybiB0YWJsZVNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIGF0dGFjaFRhYmxlU2VsZWN0aW9uVG9UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50LCB0YWJsZVNlbGVjdGlvbikge1xuICB0YWJsZUVsZW1lbnRbTEVYSUNBTF9FTEVNRU5UX0tFWV0gPSB0YWJsZVNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIGdldFRhYmxlU2VsZWN0aW9uRnJvbVRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQpIHtcbiAgcmV0dXJuIHRhYmxlRWxlbWVudFtMRVhJQ0FMX0VMRU1FTlRfS0VZXTtcbn1cbmZ1bmN0aW9uIGdldENlbGxGcm9tVGFyZ2V0KG5vZGUpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcblxuICB3aGlsZSAoY3VycmVudE5vZGUgIT0gbnVsbCkge1xuICAgIGNvbnN0IG5vZGVOYW1lID0gY3VycmVudE5vZGUubm9kZU5hbWU7XG5cbiAgICBpZiAobm9kZU5hbWUgPT09ICdURCcgfHwgbm9kZU5hbWUgPT09ICdUSCcpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gICAgICBjb25zdCBjZWxsID0gY3VycmVudE5vZGUuX2NlbGw7XG5cbiAgICAgIGlmIChjZWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjZWxsO1xuICAgIH1cblxuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VGFibGVHcmlkKHRhYmxlRWxlbWVudCkge1xuICBjb25zdCBjZWxscyA9IFtdO1xuICBjb25zdCBncmlkID0ge1xuICAgIGNlbGxzLFxuICAgIGNvbHVtbnM6IDAsXG4gICAgcm93czogMFxuICB9O1xuICBsZXQgY3VycmVudE5vZGUgPSB0YWJsZUVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGNlbGxzLmxlbmd0aCA9IDA7XG5cbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICBjb25zdCBub2RlTWFtZSA9IGN1cnJlbnROb2RlLm5vZGVOYW1lO1xuXG4gICAgaWYgKG5vZGVNYW1lID09PSAnVEQnIHx8IG5vZGVNYW1lID09PSAnVEgnKSB7XG4gICAgICBjb25zdCBlbGVtID0gY3VycmVudE5vZGU7XG4gICAgICBjb25zdCBjZWxsID0ge1xuICAgICAgICBlbGVtLFxuICAgICAgICBoYXNCYWNrZ3JvdW5kQ29sb3I6IGVsZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yICE9PSAnJyxcbiAgICAgICAgaGlnaGxpZ2h0ZWQ6IGZhbHNlLFxuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9OyAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuXG4gICAgICBjdXJyZW50Tm9kZS5fY2VsbCA9IGNlbGw7XG5cbiAgICAgIGlmIChjZWxsc1t5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNlbGxzW3ldID0gW107XG4gICAgICB9XG5cbiAgICAgIGNlbGxzW3ldW3hdID0gY2VsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGQgPSBjdXJyZW50Tm9kZS5maXJzdENoaWxkO1xuXG4gICAgICBpZiAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzaWJsaW5nID0gY3VycmVudE5vZGUubmV4dFNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZyAhPSBudWxsKSB7XG4gICAgICB4Kys7XG4gICAgICBjdXJyZW50Tm9kZSA9IHNpYmxpbmc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnQgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuXG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnRTaWJsaW5nID0gcGFyZW50Lm5leHRTaWJsaW5nO1xuXG4gICAgICBpZiAocGFyZW50U2libGluZyA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB5Kys7XG4gICAgICB4ID0gMDtcbiAgICAgIGN1cnJlbnROb2RlID0gcGFyZW50U2libGluZztcbiAgICB9XG4gIH1cblxuICBncmlkLmNvbHVtbnMgPSB4ICsgMTtcbiAgZ3JpZC5yb3dzID0geSArIDE7XG4gIHJldHVybiBncmlkO1xufVxuZnVuY3Rpb24gJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIGdyaWQsIHNlbGVjdGlvbikge1xuICBjb25zdCBzZWxlY3RlZENlbGxOb2RlcyA9IG5ldyBTZXQoc2VsZWN0aW9uID8gc2VsZWN0aW9uLmdldE5vZGVzKCkgOiBbXSk7XG4gICRmb3JFYWNoR3JpZENlbGwoZ3JpZCwgKGNlbGwsIGxleGljYWxOb2RlKSA9PiB7XG4gICAgY29uc3QgZWxlbSA9IGNlbGwuZWxlbTtcblxuICAgIGlmIChzZWxlY3RlZENlbGxOb2Rlcy5oYXMobGV4aWNhbE5vZGUpKSB7XG4gICAgICBjZWxsLmhpZ2hsaWdodGVkID0gdHJ1ZTtcbiAgICAgICRhZGRIaWdobGlnaHRUb0RPTShlZGl0b3IsIGNlbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgICAkcmVtb3ZlSGlnaGxpZ2h0RnJvbURPTShlZGl0b3IsIGNlbGwpO1xuXG4gICAgICBpZiAoIWVsZW0uZ2V0QXR0cmlidXRlKCdzdHlsZScpKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiAkZm9yRWFjaEdyaWRDZWxsKGdyaWQsIGNiKSB7XG4gIGNvbnN0IHtcbiAgICBjZWxsc1xuICB9ID0gZ3JpZDtcblxuICBmb3IgKGxldCB5ID0gMDsgeSA8IGNlbGxzLmxlbmd0aDsgeSsrKSB7XG4gICAgY29uc3Qgcm93ID0gY2VsbHNbeV07XG5cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJvdy5sZW5ndGg7IHgrKykge1xuICAgICAgY29uc3QgY2VsbCA9IHJvd1t4XTtcbiAgICAgIGNvbnN0IGxleGljYWxOb2RlID0gbGV4aWNhbC4kZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShjZWxsLmVsZW0pO1xuXG4gICAgICBpZiAobGV4aWNhbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY2IoY2VsbCwgbGV4aWNhbE5vZGUsIHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkYWRkSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVTZWxlY3Rpb24pIHtcbiAgdGFibGVTZWxlY3Rpb24uZGlzYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICRmb3JFYWNoR3JpZENlbGwodGFibGVTZWxlY3Rpb24uZ3JpZCwgY2VsbCA9PiB7XG4gICAgY2VsbC5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgJGFkZEhpZ2hsaWdodFRvRE9NKGVkaXRvciwgY2VsbCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gJHJlbW92ZUhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlU2VsZWN0aW9uKSB7XG4gIHRhYmxlU2VsZWN0aW9uLmVuYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICRmb3JFYWNoR3JpZENlbGwodGFibGVTZWxlY3Rpb24uZ3JpZCwgY2VsbCA9PiB7XG4gICAgY29uc3QgZWxlbSA9IGNlbGwuZWxlbTtcbiAgICBjZWxsLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKTtcblxuICAgIGlmICghZWxlbS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIH1cbiAgfSk7XG59XG5cbmNvbnN0IHNlbGVjdEdyaWROb2RlSW5EaXJlY3Rpb24gPSAodGFibGVTZWxlY3Rpb24sIHRhYmxlTm9kZSwgeCwgeSwgZGlyZWN0aW9uKSA9PiB7XG4gIGNvbnN0IGlzRm9yd2FyZCA9IGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnO1xuXG4gIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgY2FzZSAnYmFja3dhcmQnOlxuICAgIGNhc2UgJ2ZvcndhcmQnOlxuICAgICAgaWYgKHggIT09IChpc0ZvcndhcmQgPyB0YWJsZVNlbGVjdGlvbi5ncmlkLmNvbHVtbnMgLSAxIDogMCkpIHtcbiAgICAgICAgc2VsZWN0VGFibGVDZWxsTm9kZSh0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHNPclRocm93KHggKyAoaXNGb3J3YXJkID8gMSA6IC0xKSwgeSwgdGFibGVTZWxlY3Rpb24uZ3JpZCksIGlzRm9yd2FyZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoeSAhPT0gKGlzRm9yd2FyZCA/IHRhYmxlU2VsZWN0aW9uLmdyaWQucm93cyAtIDEgOiAwKSkge1xuICAgICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyhpc0ZvcndhcmQgPyAwIDogdGFibGVTZWxlY3Rpb24uZ3JpZC5jb2x1bW5zIC0gMSwgeSArIChpc0ZvcndhcmQgPyAxIDogLTEpLCB0YWJsZVNlbGVjdGlvbi5ncmlkKSwgaXNGb3J3YXJkKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNGb3J3YXJkKSB7XG4gICAgICAgICAgdGFibGVOb2RlLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFibGVOb2RlLnNlbGVjdE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ3VwJzpcbiAgICAgIGlmICh5ICE9PSAwKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4LCB5IC0gMSwgdGFibGVTZWxlY3Rpb24uZ3JpZCksIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgaWYgKHkgIT09IHRhYmxlU2VsZWN0aW9uLmdyaWQucm93cyAtIDEpIHtcbiAgICAgICAgc2VsZWN0VGFibGVDZWxsTm9kZSh0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHNPclRocm93KHgsIHkgKyAxLCB0YWJsZVNlbGVjdGlvbi5ncmlkKSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWJsZU5vZGUuc2VsZWN0TmV4dCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IGFkanVzdEZvY3VzTm9kZUluRGlyZWN0aW9uID0gKHRhYmxlU2VsZWN0aW9uLCB0YWJsZU5vZGUsIHgsIHksIGRpcmVjdGlvbikgPT4ge1xuICBjb25zdCBpc0ZvcndhcmQgPSBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJztcblxuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgJ2JhY2t3YXJkJzpcbiAgICBjYXNlICdmb3J3YXJkJzpcbiAgICAgIGlmICh4ICE9PSAoaXNGb3J3YXJkID8gdGFibGVTZWxlY3Rpb24uZ3JpZC5jb2x1bW5zIC0gMSA6IDApKSB7XG4gICAgICAgIHRhYmxlU2VsZWN0aW9uLnNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbih0YWJsZU5vZGUuZ2V0Q2VsbEZyb21Db3Jkc09yVGhyb3coeCArIChpc0ZvcndhcmQgPyAxIDogLTEpLCB5LCB0YWJsZVNlbGVjdGlvbi5ncmlkKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSAndXAnOlxuICAgICAgaWYgKHkgIT09IDApIHtcbiAgICAgICAgdGFibGVTZWxlY3Rpb24uc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKHRhYmxlTm9kZS5nZXRDZWxsRnJvbUNvcmRzT3JUaHJvdyh4LCB5IC0gMSwgdGFibGVTZWxlY3Rpb24uZ3JpZCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgaWYgKHkgIT09IHRhYmxlU2VsZWN0aW9uLmdyaWQucm93cyAtIDEpIHtcbiAgICAgICAgdGFibGVTZWxlY3Rpb24uc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKHRhYmxlTm9kZS5nZXRDZWxsRnJvbUNvcmRzT3JUaHJvdyh4LCB5ICsgMSwgdGFibGVTZWxlY3Rpb24uZ3JpZCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uICRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpIHtcbiAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSk7XG4gICAgY29uc3QgaXNGb2N1c0luc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCkpO1xuICAgIHJldHVybiBpc0FuY2hvckluc2lkZSAmJiBpc0ZvY3VzSW5zaWRlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbCwgZnJvbVN0YXJ0KSB7XG4gIGlmIChmcm9tU3RhcnQpIHtcbiAgICB0YWJsZUNlbGwuc2VsZWN0U3RhcnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0YWJsZUNlbGwuc2VsZWN0RW5kKCk7XG4gIH1cbn1cblxuY29uc3QgQlJPV1NFUl9CTFVFX1JHQiA9ICcxNzIsMjA2LDI0Nyc7XG5cbmZ1bmN0aW9uICRhZGRIaWdobGlnaHRUb0RPTShlZGl0b3IsIGNlbGwpIHtcbiAgY29uc3QgZWxlbWVudCA9IGNlbGwuZWxlbTtcbiAgY29uc3Qgbm9kZSA9IGxleGljYWwuJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZWxlbWVudCk7XG5cbiAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRvIGZpbmQgTGV4aWNhbE5vZGUgZnJvbSBUYWJsZSBDZWxsIERPTU5vZGVgKTtcbiAgfVxuXG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IG5vZGUuZ2V0QmFja2dyb3VuZENvbG9yKCk7XG5cbiAgaWYgKGJhY2tncm91bmRDb2xvciA9PT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtY29sb3InLCBgcmdiKCR7QlJPV1NFUl9CTFVFX1JHQn0pYCk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1pbWFnZScsIGBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIHJnYmEoJHtCUk9XU0VSX0JMVUVfUkdCfSwwLjg1KSwgcmdiYSgke0JST1dTRVJfQkxVRV9SR0J9LDAuODUpKWApO1xuICB9XG5cbiAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnY2FyZXQtY29sb3InLCAndHJhbnNwYXJlbnQnKTtcbn1cblxuZnVuY3Rpb24gJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBjZWxsLmVsZW07XG4gIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGVsZW1lbnQpO1xuXG4gIGlmICghJGlzVGFibGVDZWxsTm9kZShub2RlKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0byBmaW5kIExleGljYWxOb2RlIGZyb20gVGFibGUgQ2VsbCBET01Ob2RlYCk7XG4gIH1cblxuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBub2RlLmdldEJhY2tncm91bmRDb2xvcigpO1xuXG4gIGlmIChiYWNrZ3JvdW5kQ29sb3IgPT09IG51bGwpIHtcbiAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gIH1cblxuICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KCdiYWNrZ3JvdW5kLWltYWdlJyk7XG4gIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2NhcmV0LWNvbG9yJyk7XG59XG5cbmZ1bmN0aW9uICRmaW5kQ2VsbE5vZGUobm9kZSkge1xuICBjb25zdCBjZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gIHJldHVybiAkaXNUYWJsZUNlbGxOb2RlKGNlbGxOb2RlKSA/IGNlbGxOb2RlIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gJGZpbmRUYWJsZU5vZGUobm9kZSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KG5vZGUsICRpc1RhYmxlTm9kZSk7XG4gIHJldHVybiAkaXNUYWJsZU5vZGUodGFibGVOb2RlKSA/IHRhYmxlTm9kZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCBkaXJlY3Rpb24sIHRhYmxlTm9kZSwgdGFibGVTZWxlY3Rpb24pIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAvLyBIb3Jpem9udGFsIG1vdmUgYmV0d2VlbiBjZWxzIHNlZW0gdG8gd29yayB3ZWxsIHdpdGhvdXQgaW50ZXJydXB0aW9uXG4gICAgLy8gc28ganVzdCBleGl0IGVhcmx5LCBhbmQgaGFuZGxlIHZlcnRpY2FsIG1vdmVzXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJyB8fCBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBhbmNob3JDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgY29uc3QgZm9jdXNDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXMuZ2V0Tm9kZSgpLCAkaXNUYWJsZUNlbGxOb2RlKTtcblxuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShhbmNob3JDZWxsTm9kZSkgfHwgIWFuY2hvckNlbGxOb2RlLmlzKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgYW5jaG9yQ2VsbERvbSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yQ2VsbE5vZGUuX19rZXkpO1xuICAgIGNvbnN0IGFuY2hvckRPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yLmtleSk7XG5cbiAgICBpZiAoYW5jaG9yRE9NID09IG51bGwgfHwgYW5jaG9yQ2VsbERvbSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGVkZ2VTZWxlY3Rpb25SZWN0O1xuXG4gICAgaWYgKGFuY2hvci50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgIGVkZ2VTZWxlY3Rpb25SZWN0ID0gYW5jaG9yRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkb21TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmIChkb21TZWxlY3Rpb24gPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByYW5nZSA9IGRvbVNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgZWRnZVNlbGVjdGlvblJlY3QgPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG5cbiAgICBjb25zdCBlZGdlQ2hpbGQgPSBkaXJlY3Rpb24gPT09ICd1cCcgPyBhbmNob3JDZWxsTm9kZS5nZXRGaXJzdENoaWxkKCkgOiBhbmNob3JDZWxsTm9kZS5nZXRMYXN0Q2hpbGQoKTtcblxuICAgIGlmIChlZGdlQ2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGVkZ2VDaGlsZERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZWRnZUNoaWxkLl9fa2V5KTtcblxuICAgIGlmIChlZGdlQ2hpbGRET00gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGVkZ2VSZWN0ID0gZWRnZUNoaWxkRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGlzRXhpdGluZyA9IGRpcmVjdGlvbiA9PT0gJ3VwJyA/IGVkZ2VSZWN0LnRvcCA+IGVkZ2VTZWxlY3Rpb25SZWN0LnRvcCAtIGVkZ2VTZWxlY3Rpb25SZWN0LmhlaWdodCA6IGVkZ2VTZWxlY3Rpb25SZWN0LmJvdHRvbSArIGVkZ2VTZWxlY3Rpb25SZWN0LmhlaWdodCA+IGVkZ2VSZWN0LmJvdHRvbTtcblxuICAgIGlmIChpc0V4aXRpbmcpIHtcbiAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICBjb25zdCBjb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZShhbmNob3JDZWxsTm9kZSwgdGFibGVTZWxlY3Rpb24uZ3JpZCk7XG5cbiAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICBjb25zdCBjZWxsID0gdGFibGVOb2RlLmdldENlbGxGcm9tQ29yZHNPclRocm93KGNvcmRzLngsIGNvcmRzLnksIHRhYmxlU2VsZWN0aW9uLmdyaWQpO1xuICAgICAgICB0YWJsZVNlbGVjdGlvbi5zZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGNlbGwpO1xuICAgICAgICB0YWJsZVNlbGVjdGlvbi5zZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oY2VsbCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZWN0R3JpZE5vZGVJbkRpcmVjdGlvbih0YWJsZVNlbGVjdGlvbiwgdGFibGVOb2RlLCBjb3Jkcy54LCBjb3Jkcy55LCBkaXJlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBhbmNob3JDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgY29uc3QgZm9jdXNDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXMuZ2V0Tm9kZSgpLCAkaXNUYWJsZUNlbGxOb2RlKTtcblxuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShhbmNob3JDZWxsTm9kZSkgfHwgISRpc1RhYmxlQ2VsbE5vZGUoZm9jdXNDZWxsTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzdG9wRXZlbnQoZXZlbnQpO1xuXG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICBjb25zdCBjb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZShmb2N1c0NlbGxOb2RlLCB0YWJsZVNlbGVjdGlvbi5ncmlkKTtcbiAgICAgIHJldHVybiBhZGp1c3RGb2N1c05vZGVJbkRpcmVjdGlvbih0YWJsZVNlbGVjdGlvbiwgdGFibGVOb2RlLCBjb3Jkcy54LCBjb3Jkcy55LCBkaXJlY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb2N1c0NlbGxOb2RlLnNlbGVjdEVuZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBUYWJsZU5vZGUgZXh0ZW5kcyBsZXhpY2FsLkRFUFJFQ0FURURfR3JpZE5vZGUge1xuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAndGFibGUnO1xuICB9XG5cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFRhYmxlTm9kZShub2RlLl9fa2V5KTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhYmxlOiBfbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGFibGVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMVxuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oX3NlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVUYWJsZU5vZGUoKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZURPTShjb25maWcsIGVkaXRvcikge1xuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG4gICAgdXRpbHMuYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCh0YWJsZUVsZW1lbnQsIGNvbmZpZy50aGVtZS50YWJsZSk7XG4gICAgcmV0dXJuIHRhYmxlRWxlbWVudDtcbiAgfVxuXG4gIHVwZGF0ZURPTSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0RE9NKGVkaXRvciksXG4gICAgICBhZnRlcjogdGFibGVFbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKHRhYmxlRWxlbWVudCkge1xuICAgICAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSB0YWJsZUVsZW1lbnQuY2xvbmVOb2RlKCk7XG4gICAgICAgICAgY29uc3QgY29sR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2xncm91cCcpO1xuICAgICAgICAgIGNvbnN0IHRCb2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGJvZHknKTtcbiAgICAgICAgICB0Qm9keS5hcHBlbmQoLi4udGFibGVFbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgICAgICBjb25zdCBmaXJzdFJvdyA9IHRoaXMuZ2V0Rmlyc3RDaGlsZE9yVGhyb3coKTtcblxuICAgICAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKGZpcnN0Um93KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHJvdyBub2RlLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGNvbENvdW50ID0gZmlyc3RSb3cuZ2V0Q2hpbGRyZW5TaXplKCk7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvbCcpO1xuICAgICAgICAgICAgY29sR3JvdXAuYXBwZW5kKGNvbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3RWxlbWVudC5yZXBsYWNlQ2hpbGRyZW4oY29sR3JvdXAsIHRCb2R5KTtcbiAgICAgICAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gLy8gVE9ETyAwLjEwIGRlcHJlY2F0ZVxuXG5cbiAgY2FuRXh0cmFjdENvbnRlbnRzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNhbkJlRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZ2V0Q29yZHNGcm9tQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgZ3JpZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJvd3MsXG4gICAgICBjZWxsc1xuICAgIH0gPSBncmlkO1xuXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCByb3dzOyB5KyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IGNlbGxzW3ldO1xuXG4gICAgICBpZiAocm93ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb3cgbm90IGZvdW5kIGF0IHk6JHt5fWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB4ID0gcm93LmZpbmRJbmRleCgoe1xuICAgICAgICBlbGVtXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNlbGxOb2RlID0gbGV4aWNhbC4kZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShlbGVtKTtcbiAgICAgICAgcmV0dXJuIGNlbGxOb2RlID09PSB0YWJsZUNlbGxOb2RlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignQ2VsbCBub3QgZm91bmQgaW4gdGFibGUuJyk7XG4gIH1cblxuICBnZXRDZWxsRnJvbUNvcmRzKHgsIHksIGdyaWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsc1xuICAgIH0gPSBncmlkO1xuICAgIGNvbnN0IHJvdyA9IGNlbGxzW3ldO1xuXG4gICAgaWYgKHJvdyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBjZWxsID0gcm93W3hdO1xuXG4gICAgaWYgKGNlbGwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbGw7XG4gIH1cblxuICBnZXRDZWxsRnJvbUNvcmRzT3JUaHJvdyh4LCB5LCBncmlkKSB7XG4gICAgY29uc3QgY2VsbCA9IHRoaXMuZ2V0Q2VsbEZyb21Db3Jkcyh4LCB5LCBncmlkKTtcblxuICAgIGlmICghY2VsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDZWxsIG5vdCBmb3VuZCBhdCBjb3Jkcy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2VsbDtcbiAgfVxuXG4gIGdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHksIGdyaWQpIHtcbiAgICBjb25zdCBjZWxsID0gdGhpcy5nZXRDZWxsRnJvbUNvcmRzKHgsIHksIGdyaWQpO1xuXG4gICAgaWYgKGNlbGwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IGxleGljYWwuJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoY2VsbC5lbGVtKTtcblxuICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4LCB5LCBncmlkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCwgeSwgZ3JpZCk7XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBhdCBjb3JkcyBub3QgVGFibGVDZWxsTm9kZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGNhblNlbGVjdEJlZm9yZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNhbkluZGVudCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxufVxuZnVuY3Rpb24gJGdldEVsZW1lbnRHcmlkRm9yVGFibGVOb2RlKGVkaXRvciwgdGFibGVOb2RlKSB7XG4gIGNvbnN0IHRhYmxlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGFibGVOb2RlLmdldEtleSgpKTtcblxuICBpZiAodGFibGVFbGVtZW50ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIEVsZW1lbnQgTm90IEZvdW5kJyk7XG4gIH1cblxuICByZXR1cm4gZ2V0VGFibGVHcmlkKHRhYmxlRWxlbWVudCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VGFibGVFbGVtZW50KF9kb21Ob2RlKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZVRhYmxlTm9kZSgpXG4gIH07XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFibGVOb2RlKCkge1xuICByZXR1cm4gbGV4aWNhbC4kYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRhYmxlTm9kZSgpKTtcbn1cbmZ1bmN0aW9uICRpc1RhYmxlTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGFibGVOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiAkY3JlYXRlVGFibGVOb2RlV2l0aERpbWVuc2lvbnMocm93Q291bnQsIGNvbHVtbkNvdW50LCBpbmNsdWRlSGVhZGVycyA9IHRydWUpIHtcbiAgY29uc3QgdGFibGVOb2RlID0gJGNyZWF0ZVRhYmxlTm9kZSgpO1xuXG4gIGZvciAobGV0IGlSb3cgPSAwOyBpUm93IDwgcm93Q291bnQ7IGlSb3crKykge1xuICAgIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcblxuICAgIGZvciAobGV0IGlDb2x1bW4gPSAwOyBpQ29sdW1uIDwgY29sdW1uQ291bnQ7IGlDb2x1bW4rKykge1xuICAgICAgbGV0IGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUztcblxuICAgICAgaWYgKHR5cGVvZiBpbmNsdWRlSGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGlSb3cgPT09IDAgJiYgaW5jbHVkZUhlYWRlcnMucm93cykgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVztcbiAgICAgICAgaWYgKGlDb2x1bW4gPT09IDAgJiYgaW5jbHVkZUhlYWRlcnMuY29sdW1ucykgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTjtcbiAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZUhlYWRlcnMpIHtcbiAgICAgICAgaWYgKGlSb3cgPT09IDApIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1c7XG4gICAgICAgIGlmIChpQ29sdW1uID09PSAwKSBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpO1xuICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgIHBhcmFncmFwaE5vZGUuYXBwZW5kKGxleGljYWwuJGNyZWF0ZVRleHROb2RlKCkpO1xuICAgICAgdGFibGVDZWxsTm9kZS5hcHBlbmQocGFyYWdyYXBoTm9kZSk7XG4gICAgICB0YWJsZVJvd05vZGUuYXBwZW5kKHRhYmxlQ2VsbE5vZGUpO1xuICAgIH1cblxuICAgIHRhYmxlTm9kZS5hcHBlbmQodGFibGVSb3dOb2RlKTtcbiAgfVxuXG4gIHJldHVybiB0YWJsZU5vZGU7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVDZWxsTm9kZUZyb21MZXhpY2FsTm9kZShzdGFydGluZ05vZGUpIHtcbiAgY29uc3Qgbm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnRpbmdOb2RlLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpO1xuXG4gIGlmICgkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3coc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0aW5nTm9kZSwgbiA9PiAkaXNUYWJsZVJvd05vZGUobikpO1xuXG4gIGlmICgkaXNUYWJsZVJvd05vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGFibGUgY2VsbCB0byBiZSBpbnNpZGUgb2YgdGFibGUgcm93LicpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3coc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0aW5nTm9kZSwgbiA9PiAkaXNUYWJsZU5vZGUobikpO1xuXG4gIGlmICgkaXNUYWJsZU5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGFibGUgY2VsbCB0byBiZSBpbnNpZGUgb2YgdGFibGUuJyk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVSb3dJbmRleEZyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpIHtcbiAgY29uc3QgdGFibGVSb3dOb2RlID0gJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdyh0YWJsZUNlbGxOb2RlKTtcbiAgY29uc3QgdGFibGVOb2RlID0gJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3codGFibGVSb3dOb2RlKTtcbiAgcmV0dXJuIHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpLmZpbmRJbmRleChuID0+IG4uaXModGFibGVSb3dOb2RlKSk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVDb2x1bW5JbmRleEZyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpIHtcbiAgY29uc3QgdGFibGVSb3dOb2RlID0gJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdyh0YWJsZUNlbGxOb2RlKTtcbiAgcmV0dXJuIHRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpLmZpbmRJbmRleChuID0+IG4uaXModGFibGVDZWxsTm9kZSkpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ2VsbFNpYmxpbmdzRnJvbVRhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgZ3JpZCkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkZ2V0VGFibGVOb2RlRnJvbUxleGljYWxOb2RlT3JUaHJvdyh0YWJsZUNlbGxOb2RlKTtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeVxuICB9ID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIGdyaWQpO1xuICByZXR1cm4ge1xuICAgIGFib3ZlOiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCwgeSAtIDEsIGdyaWQpLFxuICAgIGJlbG93OiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCwgeSArIDEsIGdyaWQpLFxuICAgIGxlZnQ6IHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkcyh4IC0gMSwgeSwgZ3JpZCksXG4gICAgcmlnaHQ6IHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkcyh4ICsgMSwgeSwgZ3JpZClcbiAgfTtcbn1cbmZ1bmN0aW9uICRyZW1vdmVUYWJsZVJvd0F0SW5kZXgodGFibGVOb2RlLCBpbmRleFRvRGVsZXRlKSB7XG4gIGNvbnN0IHRhYmxlUm93cyA9IHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpO1xuXG4gIGlmIChpbmRleFRvRGVsZXRlID49IHRhYmxlUm93cy5sZW5ndGggfHwgaW5kZXhUb0RlbGV0ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRhYmxlIGNlbGwgdG8gYmUgaW5zaWRlIG9mIHRhYmxlIHJvdy4nKTtcbiAgfVxuXG4gIGNvbnN0IHRhcmdldFJvd05vZGUgPSB0YWJsZVJvd3NbaW5kZXhUb0RlbGV0ZV07XG4gIHRhcmdldFJvd05vZGUucmVtb3ZlKCk7XG4gIHJldHVybiB0YWJsZU5vZGU7XG59XG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVSb3codGFibGVOb2RlLCB0YXJnZXRJbmRleCwgc2hvdWxkSW5zZXJ0QWZ0ZXIgPSB0cnVlLCByb3dDb3VudCwgZ3JpZCkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcblxuICBpZiAodGFyZ2V0SW5kZXggPj0gdGFibGVSb3dzLmxlbmd0aCB8fCB0YXJnZXRJbmRleCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIHJvdyB0YXJnZXQgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cblxuICBjb25zdCB0YXJnZXRSb3dOb2RlID0gdGFibGVSb3dzW3RhcmdldEluZGV4XTtcblxuICBpZiAoJGlzVGFibGVSb3dOb2RlKHRhcmdldFJvd05vZGUpKSB7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3dDb3VudDsgcisrKSB7XG4gICAgICBjb25zdCB0YWJsZVJvd0NlbGxzID0gdGFyZ2V0Um93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgY29uc3QgdGFibGVDb2x1bW5Db3VudCA9IHRhYmxlUm93Q2VsbHMubGVuZ3RoO1xuICAgICAgY29uc3QgbmV3VGFibGVSb3dOb2RlID0gJGNyZWF0ZVRhYmxlUm93Tm9kZSgpO1xuXG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRhYmxlQ29sdW1uQ291bnQ7IGMrKykge1xuICAgICAgICBjb25zdCB0YWJsZUNlbGxGcm9tVGFyZ2V0Um93ID0gdGFibGVSb3dDZWxsc1tjXTtcblxuICAgICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsRnJvbVRhcmdldFJvdykpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdGFibGUgY2VsbGApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFib3ZlLFxuICAgICAgICAgIGJlbG93XG4gICAgICAgIH0gPSAkZ2V0VGFibGVDZWxsU2libGluZ3NGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxGcm9tVGFyZ2V0Um93LCBncmlkKTtcbiAgICAgICAgbGV0IGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUztcbiAgICAgICAgY29uc3Qgd2lkdGggPSBhYm92ZSAmJiBhYm92ZS5nZXRXaWR0aCgpIHx8IGJlbG93ICYmIGJlbG93LmdldFdpZHRoKCkgfHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChhYm92ZSAmJiBhYm92ZS5oYXNIZWFkZXJTdGF0ZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OKSB8fCBiZWxvdyAmJiBiZWxvdy5oYXNIZWFkZXJTdGF0ZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OKSkge1xuICAgICAgICAgIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUsIDEsIHdpZHRoKTtcbiAgICAgICAgdGFibGVDZWxsTm9kZS5hcHBlbmQobGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpKTtcbiAgICAgICAgbmV3VGFibGVSb3dOb2RlLmFwcGVuZCh0YWJsZUNlbGxOb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZEluc2VydEFmdGVyKSB7XG4gICAgICAgIHRhcmdldFJvd05vZGUuaW5zZXJ0QWZ0ZXIobmV3VGFibGVSb3dOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFJvd05vZGUuaW5zZXJ0QmVmb3JlKG5ld1RhYmxlUm93Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignUm93IGJlZm9yZSBpbnNlcnRpb24gaW5kZXggZG9lcyBub3QgZXhpc3QuJyk7XG4gIH1cblxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuZnVuY3Rpb24gJGluc2VydFRhYmxlUm93X19FWFBFUklNRU5UQUwoaW5zZXJ0QWZ0ZXIgPSB0cnVlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIEdyaWRTZWxlY3Rpb25gKTtcbiAgfVxuXG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgW2ZvY3VzQ2VsbCwsIGdyaWRdID0gbGV4aWNhbC5ERVBSRUNBVEVEXyRnZXROb2RlVHJpcGxldChmb2N1cyk7XG4gIGNvbnN0IFtncmlkTWFwLCBmb2N1c0NlbGxNYXBdID0gbGV4aWNhbC5ERVBSRUNBVEVEXyRjb21wdXRlR3JpZE1hcChncmlkLCBmb2N1c0NlbGwsIGZvY3VzQ2VsbCk7XG4gIGNvbnN0IGNvbHVtbkNvdW50ID0gZ3JpZE1hcFswXS5sZW5ndGg7XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdzogZm9jdXNTdGFydFJvd1xuICB9ID0gZm9jdXNDZWxsTWFwO1xuXG4gIGlmIChpbnNlcnRBZnRlcikge1xuICAgIGNvbnN0IGZvY3VzRW5kUm93ID0gZm9jdXNTdGFydFJvdyArIGZvY3VzQ2VsbC5fX3Jvd1NwYW4gLSAxO1xuICAgIGNvbnN0IGZvY3VzRW5kUm93TWFwID0gZ3JpZE1hcFtmb2N1c0VuZFJvd107XG4gICAgY29uc3QgbmV3Um93ID0gJGNyZWF0ZVRhYmxlUm93Tm9kZSgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Um93XG4gICAgICB9ID0gZm9jdXNFbmRSb3dNYXBbaV07XG5cbiAgICAgIGlmIChzdGFydFJvdyArIGNlbGwuX19yb3dTcGFuIC0gMSA8PSBmb2N1c0VuZFJvdykge1xuICAgICAgICBuZXdSb3cuYXBwZW5kKCRjcmVhdGVUYWJsZUNlbGxOb2RlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGwuc2V0Um93U3BhbihjZWxsLl9fcm93U3BhbiArIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZvY3VzRW5kUm93Tm9kZSA9IGdyaWQuZ2V0Q2hpbGRBdEluZGV4KGZvY3VzRW5kUm93KTtcblxuICAgIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlKGZvY3VzRW5kUm93Tm9kZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBmb2N1c0VuZFJvdyBpcyBub3QgYSBHcmlkUm93Tm9kZWApO1xuICAgIH1cblxuICAgIGZvY3VzRW5kUm93Tm9kZS5pbnNlcnRBZnRlcihuZXdSb3cpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZvY3VzU3RhcnRSb3dNYXAgPSBncmlkTWFwW2ZvY3VzU3RhcnRSb3ddO1xuICAgIGNvbnN0IG5ld1JvdyA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydFJvd1xuICAgICAgfSA9IGZvY3VzU3RhcnRSb3dNYXBbaV07XG5cbiAgICAgIGlmIChzdGFydFJvdyA9PT0gZm9jdXNTdGFydFJvdykge1xuICAgICAgICBuZXdSb3cuYXBwZW5kKCRjcmVhdGVUYWJsZUNlbGxOb2RlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGwuc2V0Um93U3BhbihjZWxsLl9fcm93U3BhbiArIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZvY3VzU3RhcnRSb3dOb2RlID0gZ3JpZC5nZXRDaGlsZEF0SW5kZXgoZm9jdXNTdGFydFJvdyk7XG5cbiAgICBpZiAoIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkUm93Tm9kZShmb2N1c1N0YXJ0Um93Tm9kZSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBmb2N1c0VuZFJvdyBpcyBub3QgYSBHcmlkUm93Tm9kZWApO1xuICAgIH1cblxuICAgIGZvY3VzU3RhcnRSb3dOb2RlLmluc2VydEJlZm9yZShuZXdSb3cpO1xuICB9XG59XG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVDb2x1bW4odGFibGVOb2RlLCB0YXJnZXRJbmRleCwgc2hvdWxkSW5zZXJ0QWZ0ZXIgPSB0cnVlLCBjb2x1bW5Db3VudCwgZ3JpZCkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcblxuICBmb3IgKGxldCByID0gMDsgciA8IHRhYmxlUm93cy5sZW5ndGg7IHIrKykge1xuICAgIGNvbnN0IGN1cnJlbnRUYWJsZVJvd05vZGUgPSB0YWJsZVJvd3Nbcl07XG5cbiAgICBpZiAoJGlzVGFibGVSb3dOb2RlKGN1cnJlbnRUYWJsZVJvd05vZGUpKSB7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGNvbHVtbkNvdW50OyBjKyspIHtcbiAgICAgICAgY29uc3QgdGFibGVSb3dDaGlsZHJlbiA9IGN1cnJlbnRUYWJsZVJvd05vZGUuZ2V0Q2hpbGRyZW4oKTtcblxuICAgICAgICBpZiAodGFyZ2V0SW5kZXggPj0gdGFibGVSb3dDaGlsZHJlbi5sZW5ndGggfHwgdGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWJsZSBjb2x1bW4gdGFyZ2V0IGluZGV4IG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0Q2VsbCA9IHRhYmxlUm93Q2hpbGRyZW5bdGFyZ2V0SW5kZXhdO1xuXG4gICAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YXJnZXRDZWxsKSkge1xuICAgICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCB0YWJsZSBjZWxsYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICByaWdodFxuICAgICAgICB9ID0gJGdldFRhYmxlQ2VsbFNpYmxpbmdzRnJvbVRhYmxlQ2VsbE5vZGUodGFyZ2V0Q2VsbCwgZ3JpZCk7XG4gICAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG5cbiAgICAgICAgaWYgKGxlZnQgJiYgbGVmdC5oYXNIZWFkZXJTdGF0ZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XKSB8fCByaWdodCAmJiByaWdodC5oYXNIZWFkZXJTdGF0ZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XKSkge1xuICAgICAgICAgIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1c7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdUYWJsZUNlbGwgPSAkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSk7XG4gICAgICAgIG5ld1RhYmxlQ2VsbC5hcHBlbmQobGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpKTtcblxuICAgICAgICBpZiAoc2hvdWxkSW5zZXJ0QWZ0ZXIpIHtcbiAgICAgICAgICB0YXJnZXRDZWxsLmluc2VydEFmdGVyKG5ld1RhYmxlQ2VsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0Q2VsbC5pbnNlcnRCZWZvcmUobmV3VGFibGVDZWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YWJsZU5vZGU7XG59XG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTChpbnNlcnRBZnRlciA9IHRydWUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCEobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGEgUmFuZ2VTZWxlY3Rpb24gb3IgR3JpZFNlbGVjdGlvbmApO1xuICB9XG5cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgW2FuY2hvckNlbGxdID0gbGV4aWNhbC5ERVBSRUNBVEVEXyRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICBjb25zdCBbZm9jdXNDZWxsLCwgZ3JpZF0gPSBsZXhpY2FsLkRFUFJFQ0FURURfJGdldE5vZGVUcmlwbGV0KGZvY3VzKTtcbiAgY29uc3QgW2dyaWRNYXAsIGZvY3VzQ2VsbE1hcCwgYW5jaG9yQ2VsbE1hcF0gPSBsZXhpY2FsLkRFUFJFQ0FURURfJGNvbXB1dGVHcmlkTWFwKGdyaWQsIGZvY3VzQ2VsbCwgYW5jaG9yQ2VsbCk7XG4gIGNvbnN0IHJvd0NvdW50ID0gZ3JpZE1hcC5sZW5ndGg7XG4gIGNvbnN0IHN0YXJ0Q29sdW1uID0gaW5zZXJ0QWZ0ZXIgPyBNYXRoLm1heChmb2N1c0NlbGxNYXAuc3RhcnRDb2x1bW4sIGFuY2hvckNlbGxNYXAuc3RhcnRDb2x1bW4pIDogTWF0aC5taW4oZm9jdXNDZWxsTWFwLnN0YXJ0Q29sdW1uLCBhbmNob3JDZWxsTWFwLnN0YXJ0Q29sdW1uKTtcbiAgY29uc3QgaW5zZXJ0QWZ0ZXJDb2x1bW4gPSBpbnNlcnRBZnRlciA/IHN0YXJ0Q29sdW1uICsgZm9jdXNDZWxsLl9fY29sU3BhbiAtIDEgOiBzdGFydENvbHVtbiAtIDE7XG4gIGNvbnN0IGdyaWRGaXJzdENoaWxkID0gZ3JpZC5nZXRGaXJzdENoaWxkKCk7XG5cbiAgaWYgKCFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFJvd05vZGUoZ3JpZEZpcnN0Q2hpbGQpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGZpcnN0VGFibGUgY2hpbGQgdG8gYmUgYSByb3dgKTtcbiAgfVxuXG4gIGxldCBmaXJzdEluc2VydGVkQ2VsbCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gJGNyZWF0ZVRhYmxlQ2VsbE5vZGVGb3JJbnNlcnRUYWJsZUNvbHVtbigpIHtcbiAgICBjb25zdCBjZWxsID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUykuYXBwZW5kKGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG5cbiAgICBpZiAoZmlyc3RJbnNlcnRlZENlbGwgPT09IG51bGwpIHtcbiAgICAgIGZpcnN0SW5zZXJ0ZWRDZWxsID0gY2VsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2VsbDtcbiAgfVxuXG4gIGxldCBsb29wUm93ID0gZ3JpZEZpcnN0Q2hpbGQ7XG5cbiAgcm93TG9vcDogZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgaWYgKGkgIT09IDApIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3cgPSBsb29wUm93LmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICAgIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlKGN1cnJlbnRSb3cpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCByb3cgbmV4dFNpYmxpbmcgdG8gYmUgYSByb3dgKTtcbiAgICAgIH1cblxuICAgICAgbG9vcFJvdyA9IGN1cnJlbnRSb3c7XG4gICAgfVxuXG4gICAgY29uc3Qgcm93TWFwID0gZ3JpZE1hcFtpXTtcblxuICAgIGlmIChpbnNlcnRBZnRlckNvbHVtbiA8IDApIHtcbiAgICAgICRpbnNlcnRGaXJzdChsb29wUm93LCAkY3JlYXRlVGFibGVDZWxsTm9kZUZvckluc2VydFRhYmxlQ29sdW1uKCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgY2VsbDogY3VycmVudENlbGwsXG4gICAgICBzdGFydENvbHVtbjogY3VycmVudFN0YXJ0Q29sdW1uLFxuICAgICAgc3RhcnRSb3c6IGN1cnJlbnRTdGFydFJvd1xuICAgIH0gPSByb3dNYXBbaW5zZXJ0QWZ0ZXJDb2x1bW5dO1xuXG4gICAgaWYgKGN1cnJlbnRTdGFydENvbHVtbiArIGN1cnJlbnRDZWxsLl9fY29sU3BhbiAtIDEgPD0gaW5zZXJ0QWZ0ZXJDb2x1bW4pIHtcbiAgICAgIGxldCBpbnNlcnRBZnRlckNlbGwgPSBjdXJyZW50Q2VsbDtcbiAgICAgIGxldCBpbnNlcnRBZnRlckNlbGxSb3dTdGFydCA9IGN1cnJlbnRTdGFydFJvdztcbiAgICAgIGxldCBwcmV2Q2VsbEluZGV4ID0gaW5zZXJ0QWZ0ZXJDb2x1bW47XG5cbiAgICAgIHdoaWxlIChpbnNlcnRBZnRlckNlbGxSb3dTdGFydCAhPT0gaSAmJiBpbnNlcnRBZnRlckNlbGwuX19yb3dTcGFuID4gMSkge1xuICAgICAgICBwcmV2Q2VsbEluZGV4IC09IGN1cnJlbnRDZWxsLl9fY29sU3BhbjtcblxuICAgICAgICBpZiAocHJldkNlbGxJbmRleCA+PSAwKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY2VsbDogY2VsbF8sXG4gICAgICAgICAgICBzdGFydFJvdzogc3RhcnRSb3dfXG4gICAgICAgICAgfSA9IHJvd01hcFtwcmV2Q2VsbEluZGV4XTtcbiAgICAgICAgICBpbnNlcnRBZnRlckNlbGwgPSBjZWxsXztcbiAgICAgICAgICBpbnNlcnRBZnRlckNlbGxSb3dTdGFydCA9IHN0YXJ0Um93XztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb29wUm93LmFwcGVuZCgkY3JlYXRlVGFibGVDZWxsTm9kZUZvckluc2VydFRhYmxlQ29sdW1uKCkpO1xuICAgICAgICAgIGNvbnRpbnVlIHJvd0xvb3A7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5zZXJ0QWZ0ZXJDZWxsLmluc2VydEFmdGVyKCRjcmVhdGVUYWJsZUNlbGxOb2RlRm9ySW5zZXJ0VGFibGVDb2x1bW4oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDZWxsLnNldENvbFNwYW4oY3VycmVudENlbGwuX19jb2xTcGFuICsgMSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpcnN0SW5zZXJ0ZWRDZWxsICE9PSBudWxsKSB7XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoZmlyc3RJbnNlcnRlZENlbGwpO1xuICB9XG59XG5mdW5jdGlvbiAkZGVsZXRlVGFibGVDb2x1bW4odGFibGVOb2RlLCB0YXJnZXRJbmRleCkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYmxlUm93cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnJlbnRUYWJsZVJvd05vZGUgPSB0YWJsZVJvd3NbaV07XG5cbiAgICBpZiAoJGlzVGFibGVSb3dOb2RlKGN1cnJlbnRUYWJsZVJvd05vZGUpKSB7XG4gICAgICBjb25zdCB0YWJsZVJvd0NoaWxkcmVuID0gY3VycmVudFRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpO1xuXG4gICAgICBpZiAodGFyZ2V0SW5kZXggPj0gdGFibGVSb3dDaGlsZHJlbi5sZW5ndGggfHwgdGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGFibGUgY29sdW1uIHRhcmdldCBpbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgIH1cblxuICAgICAgdGFibGVSb3dDaGlsZHJlblt0YXJnZXRJbmRleF0ucmVtb3ZlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cbmZ1bmN0aW9uICRkZWxldGVUYWJsZVJvd19fRVhQRVJJTUVOVEFMKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIShsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBHcmlkU2VsZWN0aW9uYCk7XG4gIH1cblxuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICBjb25zdCBbYW5jaG9yQ2VsbCwsIGdyaWRdID0gbGV4aWNhbC5ERVBSRUNBVEVEXyRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICBjb25zdCBbZm9jdXNDZWxsXSA9IGxleGljYWwuREVQUkVDQVRFRF8kZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbZ3JpZE1hcCwgYW5jaG9yQ2VsbE1hcCwgZm9jdXNDZWxsTWFwXSA9IGxleGljYWwuREVQUkVDQVRFRF8kY29tcHV0ZUdyaWRNYXAoZ3JpZCwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBhbmNob3JTdGFydFJvd1xuICB9ID0gYW5jaG9yQ2VsbE1hcDtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBmb2N1c1N0YXJ0Um93XG4gIH0gPSBmb2N1c0NlbGxNYXA7XG4gIGNvbnN0IGZvY3VzRW5kUm93ID0gZm9jdXNTdGFydFJvdyArIGZvY3VzQ2VsbC5fX3Jvd1NwYW4gLSAxO1xuXG4gIGlmIChncmlkTWFwLmxlbmd0aCA9PT0gZm9jdXNFbmRSb3cgLSBhbmNob3JTdGFydFJvdyArIDEpIHtcbiAgICAvLyBFbXB0eSBncmlkXG4gICAgZ3JpZC5yZW1vdmUoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBjb2x1bW5Db3VudCA9IGdyaWRNYXBbMF0ubGVuZ3RoO1xuICBjb25zdCBuZXh0Um93ID0gZ3JpZE1hcFtmb2N1c0VuZFJvdyArIDFdO1xuICBjb25zdCBuZXh0Um93Tm9kZSA9IGdyaWQuZ2V0Q2hpbGRBdEluZGV4KGZvY3VzRW5kUm93ICsgMSk7XG5cbiAgZm9yIChsZXQgcm93ID0gZm9jdXNFbmRSb3c7IHJvdyA+PSBhbmNob3JTdGFydFJvdzsgcm93LS0pIHtcbiAgICBmb3IgKGxldCBjb2x1bW4gPSBjb2x1bW5Db3VudCAtIDE7IGNvbHVtbiA+PSAwOyBjb2x1bW4tLSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydFJvdzogY2VsbFN0YXJ0Um93LFxuICAgICAgICBzdGFydENvbHVtbjogY2VsbFN0YXJ0Q29sdW1uXG4gICAgICB9ID0gZ3JpZE1hcFtyb3ddW2NvbHVtbl07XG5cbiAgICAgIGlmIChjZWxsU3RhcnRDb2x1bW4gIT09IGNvbHVtbikge1xuICAgICAgICAvLyBEb24ndCByZXBlYXQgd29yayBmb3IgdGhlIHNhbWUgQ2VsbFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gUm93cyBvdmVyZmxvd2luZyB0b3AgaGF2ZSB0byBiZSB0cmltbWVkXG5cblxuICAgICAgaWYgKHJvdyA9PT0gYW5jaG9yU3RhcnRSb3cgJiYgY2VsbFN0YXJ0Um93IDwgYW5jaG9yU3RhcnRSb3cpIHtcbiAgICAgICAgY2VsbC5zZXRSb3dTcGFuKGNlbGwuX19yb3dTcGFuIC0gKGNlbGxTdGFydFJvdyAtIGFuY2hvclN0YXJ0Um93KSk7XG4gICAgICB9IC8vIFJvd3Mgb3ZlcmZsb3dpbmcgYm90dG9tIGhhdmUgdG8gYmUgdHJpbW1lZCBhbmQgbW92ZWQgdG8gdGhlIG5leHQgcm93XG5cblxuICAgICAgaWYgKGNlbGxTdGFydFJvdyA+PSBhbmNob3JTdGFydFJvdyAmJiBjZWxsU3RhcnRSb3cgKyBjZWxsLl9fcm93U3BhbiAtIDEgPiBmb2N1c0VuZFJvdykge1xuICAgICAgICBjZWxsLnNldFJvd1NwYW4oY2VsbC5fX3Jvd1NwYW4gLSAoZm9jdXNFbmRSb3cgLSBjZWxsU3RhcnRSb3cgKyAxKSk7XG5cbiAgICAgICAgaWYgKCEobmV4dFJvd05vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIG5leHRSb3dOb2RlIG5vdCB0byBiZSBudWxsYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sdW1uID09PSAwKSB7XG4gICAgICAgICAgJGluc2VydEZpcnN0KG5leHRSb3dOb2RlLCBjZWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjZWxsOiBwcmV2aW91c0NlbGxcbiAgICAgICAgICB9ID0gbmV4dFJvd1tjb2x1bW4gLSAxXTtcbiAgICAgICAgICBwcmV2aW91c0NlbGwuaW5zZXJ0QWZ0ZXIoY2VsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByb3dOb2RlID0gZ3JpZC5nZXRDaGlsZEF0SW5kZXgocm93KTtcblxuICAgIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlKHJvd05vZGUpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgR3JpZE5vZGUgY2hpbGRBdEluZGV4KCR7U3RyaW5nKHJvdyl9KSB0byBiZSBSb3dOb2RlYCk7XG4gICAgfVxuXG4gICAgcm93Tm9kZS5yZW1vdmUoKTtcbiAgfVxuXG4gIGlmIChuZXh0Um93ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IG5leHRSb3dbMF07XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJldmlvdXNSb3cgPSBncmlkTWFwW2FuY2hvclN0YXJ0Um93IC0gMV07XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFxuICAgIH0gPSBwcmV2aW91c1Jvd1swXTtcbiAgICAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKTtcbiAgfVxufVxuZnVuY3Rpb24gJGRlbGV0ZVRhYmxlQ29sdW1uX19FWFBFUklNRU5UQUwoKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIEdyaWRTZWxlY3Rpb25gKTtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IFthbmNob3JDZWxsLCwgZ3JpZF0gPSBsZXhpY2FsLkRFUFJFQ0FURURfJGdldE5vZGVUcmlwbGV0KGFuY2hvcik7XG4gIGNvbnN0IFtmb2N1c0NlbGxdID0gbGV4aWNhbC5ERVBSRUNBVEVEXyRnZXROb2RlVHJpcGxldChmb2N1cyk7XG4gIGNvbnN0IFtncmlkTWFwLCBhbmNob3JDZWxsTWFwLCBmb2N1c0NlbGxNYXBdID0gbGV4aWNhbC5ERVBSRUNBVEVEXyRjb21wdXRlR3JpZE1hcChncmlkLCBhbmNob3JDZWxsLCBmb2N1c0NlbGwpO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW46IGFuY2hvclN0YXJ0Q29sdW1uXG4gIH0gPSBhbmNob3JDZWxsTWFwO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3c6IGZvY3VzU3RhcnRSb3csXG4gICAgc3RhcnRDb2x1bW46IGZvY3VzU3RhcnRDb2x1bW5cbiAgfSA9IGZvY3VzQ2VsbE1hcDtcbiAgY29uc3Qgc3RhcnRDb2x1bW4gPSBNYXRoLm1pbihhbmNob3JTdGFydENvbHVtbiwgZm9jdXNTdGFydENvbHVtbik7XG4gIGNvbnN0IGVuZENvbHVtbiA9IE1hdGgubWF4KGFuY2hvclN0YXJ0Q29sdW1uICsgYW5jaG9yQ2VsbC5fX2NvbFNwYW4gLSAxLCBmb2N1c1N0YXJ0Q29sdW1uICsgZm9jdXNDZWxsLl9fY29sU3BhbiAtIDEpO1xuICBjb25zdCBzZWxlY3RlZENvbHVtbkNvdW50ID0gZW5kQ29sdW1uIC0gc3RhcnRDb2x1bW4gKyAxO1xuICBjb25zdCBjb2x1bW5Db3VudCA9IGdyaWRNYXBbMF0ubGVuZ3RoO1xuXG4gIGlmIChjb2x1bW5Db3VudCA9PT0gZW5kQ29sdW1uIC0gc3RhcnRDb2x1bW4gKyAxKSB7XG4gICAgLy8gRW1wdHkgZ3JpZFxuICAgIGdyaWQuc2VsZWN0UHJldmlvdXMoKTtcbiAgICBncmlkLnJlbW92ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHJvd0NvdW50ID0gZ3JpZE1hcC5sZW5ndGg7XG5cbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93Q291bnQ7IHJvdysrKSB7XG4gICAgZm9yIChsZXQgY29sdW1uID0gc3RhcnRDb2x1bW47IGNvbHVtbiA8PSBlbmRDb2x1bW47IGNvbHVtbisrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Q29sdW1uOiBjZWxsU3RhcnRDb2x1bW5cbiAgICAgIH0gPSBncmlkTWFwW3Jvd11bY29sdW1uXTtcblxuICAgICAgaWYgKGNlbGxTdGFydENvbHVtbiA8IHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgIGlmIChjb2x1bW4gPT09IHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgY29uc3Qgb3ZlcmZsb3dMZWZ0ID0gc3RhcnRDb2x1bW4gLSBjZWxsU3RhcnRDb2x1bW47IC8vIE92ZXJmbG93aW5nIGxlZnRcblxuICAgICAgICAgIGNlbGwuc2V0Q29sU3BhbihjZWxsLl9fY29sU3BhbiAtIC8vIFBvc3NpYmxlIG92ZXJmbG93IHJpZ2h0IHRvb1xuICAgICAgICAgIE1hdGgubWluKHNlbGVjdGVkQ29sdW1uQ291bnQsIGNlbGwuX19jb2xTcGFuIC0gb3ZlcmZsb3dMZWZ0KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2VsbFN0YXJ0Q29sdW1uICsgY2VsbC5fX2NvbFNwYW4gLSAxID4gZW5kQ29sdW1uKSB7XG4gICAgICAgIGlmIChjb2x1bW4gPT09IGVuZENvbHVtbikge1xuICAgICAgICAgIC8vIE92ZXJmbG93aW5nIHJpZ2h0XG4gICAgICAgICAgY29uc3QgaW5TZWxlY3RlZEFyZWEgPSBlbmRDb2x1bW4gLSBjZWxsU3RhcnRDb2x1bW4gKyAxO1xuICAgICAgICAgIGNlbGwuc2V0Q29sU3BhbihjZWxsLl9fY29sU3BhbiAtIGluU2VsZWN0ZWRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2VsbC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBmb2N1c1Jvd01hcCA9IGdyaWRNYXBbZm9jdXNTdGFydFJvd107XG4gIGNvbnN0IG5leHRDb2x1bW4gPSBmb2N1c1Jvd01hcFtmb2N1c1N0YXJ0Q29sdW1uICsgZm9jdXNDZWxsLl9fY29sU3Bhbl07XG5cbiAgaWYgKG5leHRDb2x1bW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNlbGxcbiAgICB9ID0gbmV4dENvbHVtbjtcbiAgICAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcmV2aW91c1JvdyA9IGZvY3VzUm93TWFwW2ZvY3VzU3RhcnRDb2x1bW4gLSAxXTtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IHByZXZpb3VzUm93O1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpIHtcbiAgY29uc3QgZmlyc3REZXNjZW5kYW50ID0gY2VsbC5nZXRGaXJzdERlc2NlbmRhbnQoKTtcblxuICBpZiAoIShmaXJzdERlc2NlbmRhbnQgIT09IG51bGwpKSB7XG4gICAgdGhyb3cgRXJyb3IoYFVuZXhwZWN0ZWQgZW1wdHkgY2VsbGApO1xuICB9XG5cbiAgZmlyc3REZXNjZW5kYW50LmdldFBhcmVudE9yVGhyb3coKS5zZWxlY3RTdGFydCgpO1xufVxuXG5mdW5jdGlvbiAkaW5zZXJ0Rmlyc3QocGFyZW50LCBub2RlKSB7XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJlbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50LmFwcGVuZChub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiAkdW5tZXJnZUNlbGwoKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIEdyaWRTZWxlY3Rpb25gKTtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBbY2VsbCwgcm93LCBncmlkXSA9IGxleGljYWwuREVQUkVDQVRFRF8kZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgY29uc3QgY29sU3BhbiA9IGNlbGwuX19jb2xTcGFuO1xuICBjb25zdCByb3dTcGFuID0gY2VsbC5fX3Jvd1NwYW47XG5cbiAgaWYgKGNvbFNwYW4gPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb2xTcGFuOyBpKyspIHtcbiAgICAgIGNlbGwuaW5zZXJ0QWZ0ZXIoJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUykpO1xuICAgIH1cblxuICAgIGNlbGwuc2V0Q29sU3BhbigxKTtcbiAgfVxuXG4gIGlmIChyb3dTcGFuID4gMSkge1xuICAgIGNvbnN0IFttYXAsIGNlbGxNYXBdID0gbGV4aWNhbC5ERVBSRUNBVEVEXyRjb21wdXRlR3JpZE1hcChncmlkLCBjZWxsLCBjZWxsKTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydENvbHVtbixcbiAgICAgIHN0YXJ0Um93XG4gICAgfSA9IGNlbGxNYXA7XG4gICAgbGV0IGN1cnJlbnRSb3dOb2RlO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByb3dTcGFuOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3cgPSBzdGFydFJvdyArIGk7XG4gICAgICBjb25zdCBjdXJyZW50Um93TWFwID0gbWFwW2N1cnJlbnRSb3ddO1xuICAgICAgY3VycmVudFJvd05vZGUgPSByb3cuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgaWYgKCFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFJvd05vZGUoY3VycmVudFJvd05vZGUpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCByb3cgbmV4dCBzaWJsaW5nIHRvIGJlIGEgcm93YCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBpbnNlcnRBZnRlckNlbGwgPSBudWxsO1xuXG4gICAgICBmb3IgKGxldCBjb2x1bW4gPSAwOyBjb2x1bW4gPCBzdGFydENvbHVtbjsgY29sdW1uKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudENlbGxNYXAgPSBjdXJyZW50Um93TWFwW2NvbHVtbl07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsID0gY3VycmVudENlbGxNYXAuY2VsbDtcblxuICAgICAgICBpZiAoY3VycmVudENlbGxNYXAuc3RhcnRSb3cgPT09IGN1cnJlbnRSb3cpIHtcbiAgICAgICAgICBpbnNlcnRBZnRlckNlbGwgPSBjdXJyZW50Q2VsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50Q2VsbC5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICAgICAgY29sdW1uICs9IGN1cnJlbnRDZWxsLl9fY29sU3BhbiAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluc2VydEFmdGVyQ2VsbCA9PT0gbnVsbCkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbFNwYW47IGorKykge1xuICAgICAgICAgICRpbnNlcnRGaXJzdChjdXJyZW50Um93Tm9kZSwgJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbFNwYW47IGorKykge1xuICAgICAgICAgIGluc2VydEFmdGVyQ2VsbC5pbnNlcnRBZnRlcigkY3JlYXRlVGFibGVDZWxsTm9kZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjZWxsLnNldFJvd1NwYW4oMSk7XG4gIH1cbn1cblxuLyoqIEBtb2R1bGUgQGxleGljYWwvdGFibGUgKi9cbmNvbnN0IElOU0VSVF9UQUJMRV9DT01NQU5EID0gbGV4aWNhbC5jcmVhdGVDb21tYW5kKCdJTlNFUlRfVEFCTEVfQ09NTUFORCcpO1xuXG5leHBvcnRzLiRjcmVhdGVUYWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGU7XG5leHBvcnRzLiRjcmVhdGVUYWJsZU5vZGUgPSAkY3JlYXRlVGFibGVOb2RlO1xuZXhwb3J0cy4kY3JlYXRlVGFibGVOb2RlV2l0aERpbWVuc2lvbnMgPSAkY3JlYXRlVGFibGVOb2RlV2l0aERpbWVuc2lvbnM7XG5leHBvcnRzLiRjcmVhdGVUYWJsZVJvd05vZGUgPSAkY3JlYXRlVGFibGVSb3dOb2RlO1xuZXhwb3J0cy4kZGVsZXRlVGFibGVDb2x1bW4gPSAkZGVsZXRlVGFibGVDb2x1bW47XG5leHBvcnRzLiRkZWxldGVUYWJsZUNvbHVtbl9fRVhQRVJJTUVOVEFMID0gJGRlbGV0ZVRhYmxlQ29sdW1uX19FWFBFUklNRU5UQUw7XG5leHBvcnRzLiRkZWxldGVUYWJsZVJvd19fRVhQRVJJTUVOVEFMID0gJGRlbGV0ZVRhYmxlUm93X19FWFBFUklNRU5UQUw7XG5leHBvcnRzLiRnZXRFbGVtZW50R3JpZEZvclRhYmxlTm9kZSA9ICRnZXRFbGVtZW50R3JpZEZvclRhYmxlTm9kZTtcbmV4cG9ydHMuJGdldFRhYmxlQ2VsbE5vZGVGcm9tTGV4aWNhbE5vZGUgPSAkZ2V0VGFibGVDZWxsTm9kZUZyb21MZXhpY2FsTm9kZTtcbmV4cG9ydHMuJGdldFRhYmxlQ29sdW1uSW5kZXhGcm9tVGFibGVDZWxsTm9kZSA9ICRnZXRUYWJsZUNvbHVtbkluZGV4RnJvbVRhYmxlQ2VsbE5vZGU7XG5leHBvcnRzLiRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93ID0gJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3c7XG5leHBvcnRzLiRnZXRUYWJsZVJvd0luZGV4RnJvbVRhYmxlQ2VsbE5vZGUgPSAkZ2V0VGFibGVSb3dJbmRleEZyb21UYWJsZUNlbGxOb2RlO1xuZXhwb3J0cy4kZ2V0VGFibGVSb3dOb2RlRnJvbVRhYmxlQ2VsbE5vZGVPclRocm93ID0gJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdztcbmV4cG9ydHMuJGluc2VydFRhYmxlQ29sdW1uID0gJGluc2VydFRhYmxlQ29sdW1uO1xuZXhwb3J0cy4kaW5zZXJ0VGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTCA9ICRpbnNlcnRUYWJsZUNvbHVtbl9fRVhQRVJJTUVOVEFMO1xuZXhwb3J0cy4kaW5zZXJ0VGFibGVSb3cgPSAkaW5zZXJ0VGFibGVSb3c7XG5leHBvcnRzLiRpbnNlcnRUYWJsZVJvd19fRVhQRVJJTUVOVEFMID0gJGluc2VydFRhYmxlUm93X19FWFBFUklNRU5UQUw7XG5leHBvcnRzLiRpc1RhYmxlQ2VsbE5vZGUgPSAkaXNUYWJsZUNlbGxOb2RlO1xuZXhwb3J0cy4kaXNUYWJsZU5vZGUgPSAkaXNUYWJsZU5vZGU7XG5leHBvcnRzLiRpc1RhYmxlUm93Tm9kZSA9ICRpc1RhYmxlUm93Tm9kZTtcbmV4cG9ydHMuJHJlbW92ZVRhYmxlUm93QXRJbmRleCA9ICRyZW1vdmVUYWJsZVJvd0F0SW5kZXg7XG5leHBvcnRzLiR1bm1lcmdlQ2VsbCA9ICR1bm1lcmdlQ2VsbDtcbmV4cG9ydHMuSU5TRVJUX1RBQkxFX0NPTU1BTkQgPSBJTlNFUlRfVEFCTEVfQ09NTUFORDtcbmV4cG9ydHMuVGFibGVDZWxsSGVhZGVyU3RhdGVzID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzO1xuZXhwb3J0cy5UYWJsZUNlbGxOb2RlID0gVGFibGVDZWxsTm9kZTtcbmV4cG9ydHMuVGFibGVOb2RlID0gVGFibGVOb2RlO1xuZXhwb3J0cy5UYWJsZVJvd05vZGUgPSBUYWJsZVJvd05vZGU7XG5leHBvcnRzLlRhYmxlU2VsZWN0aW9uID0gVGFibGVTZWxlY3Rpb247XG5leHBvcnRzLmFwcGx5VGFibGVIYW5kbGVycyA9IGFwcGx5VGFibGVIYW5kbGVycztcbmV4cG9ydHMuZ2V0Q2VsbEZyb21UYXJnZXQgPSBnZXRDZWxsRnJvbVRhcmdldDtcbmV4cG9ydHMuZ2V0VGFibGVTZWxlY3Rpb25Gcm9tVGFibGVFbGVtZW50ID0gZ2V0VGFibGVTZWxlY3Rpb25Gcm9tVGFibGVFbGVtZW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/table/LexicalTable.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/table/LexicalTable.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lexical/table/LexicalTable.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalTable =  true ? __webpack_require__(/*! ./LexicalTable.dev.js */ \"(ssr)/./node_modules/@lexical/table/LexicalTable.dev.js\") : 0\nmodule.exports = LexicalTable;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGFibGUvTGV4aWNhbFRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1oscUJBQXFCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxzRkFBdUIsSUFBSSxDQUFpQztBQUNsSSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3RhYmxlL0xleGljYWxUYWJsZS5qcz83MmY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsVGFibGUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFRhYmxlLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsVGFibGUucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxUYWJsZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/table/LexicalTable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/text/LexicalText.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/text/LexicalText.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/text */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n\n  mainLoop: while (node !== null) {\n    if (lexical.$isElementNode(node)) {\n      const child = node.getFirstChild();\n\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if (lexical.$isTextNode(node)) {\n      const characters = node.getTextContentSize();\n\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n\n      currentCharacters += characters;\n    }\n\n    const sibling = node.getNextSibling();\n\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n\n    let parent = node.getParent();\n\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n\n      parent = parent.getParent();\n    }\n\n    break;\n  }\n\n  return null;\n}\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\n\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n\n  let text = $rootTextContent();\n\n  if (trim) {\n    text = text.trim();\n  }\n\n  return text === '';\n}\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\n\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\n\nfunction $rootTextContent() {\n  const root = lexical.$getRoot();\n  return root.getTextContent();\n}\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\n\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n\n  const root = lexical.$getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n\n  if (childrenLength > 1) {\n    return false;\n  }\n\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n\n    if (lexical.$isDecoratorNode(topBlock)) {\n      return false;\n    }\n\n    if (lexical.$isElementNode(topBlock)) {\n      if (!lexical.$isParagraphNode(topBlock)) {\n        return false;\n      }\n\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n\n        if (!lexical.$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\n\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Returns a touple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n\n  const replaceWithSimpleText = node => {\n    const textNode = lexical.$createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n\n  const textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n\n    const prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n\n    if (lexical.$isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    } // eslint-disable-next-line no-constant-condition\n\n\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n\n        if (lexical.$isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      } else {\n        const nextMatch = getMatch(nextText);\n\n        if (nextMatch !== null && nextMatch.start === 0) {\n          return;\n        }\n      }\n\n      if (match === null) {\n        return;\n      }\n\n      if (match.start === 0 && lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        continue;\n      }\n\n      let nodeToReplace;\n\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);\n      }\n\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n\n      if (currentNode == null) {\n        return;\n      }\n    }\n  };\n\n  const reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n\n    if (match === null || match.start !== 0) {\n      replaceWithSimpleText(node);\n      return;\n    }\n\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n\n    const prevSibling = node.getPreviousSibling();\n\n    if (lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      replaceWithSimpleText(prevSibling);\n      replaceWithSimpleText(node);\n    }\n\n    const nextSibling = node.getNextSibling();\n\n    if (lexical.$isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      replaceWithSimpleText(nextSibling); // This may have already been converted in the previous block\n\n      if (isTargetNode(node)) {\n        replaceWithSimpleText(node);\n      }\n    }\n  };\n\n  const removePlainTextTransform = editor.registerNodeTransform(lexical.TextNode, textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexports.$canShowPlaceholder = $canShowPlaceholder;\nexports.$canShowPlaceholderCurry = $canShowPlaceholderCurry;\nexports.$findTextIntersectionFromCharacters = $findTextIntersectionFromCharacters;\nexports.$isRootTextContentEmpty = $isRootTextContentEmpty;\nexports.$isRootTextContentEmptyCurry = $isRootTextContentEmptyCurry;\nexports.$rootTextContent = $rootTextContent;\nexports.registerLexicalTextEntity = registerLexicalTextEntity;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGV4dC9MZXhpY2FsVGV4dC5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHdEQUFTOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLDRCQUE0QjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLGdDQUFnQztBQUNoQywyQ0FBMkM7QUFDM0MsK0JBQStCO0FBQy9CLG9DQUFvQztBQUNwQyx3QkFBd0I7QUFDeEIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGV4dC9MZXhpY2FsVGV4dC5kZXYuanM/ZTZmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG5cbi8qKiBAbW9kdWxlIEBsZXhpY2FsL3RleHQgKi9cblxuLyoqXG4gKiBGaW5kcyBhIFRleHROb2RlIHdpdGggYSBzaXplIGxhcmdlciB0aGFuIHRhcmdldENoYXJhY3RlcnMgYW5kIHJldHVybnNcbiAqIHRoZSBub2RlIGFsb25nIHdpdGggdGhlIHJlbWFpbmluZyBsZW5ndGggb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gcm9vdCAtIFRoZSBSb290Tm9kZS5cbiAqIEBwYXJhbSB0YXJnZXRDaGFyYWN0ZXJzIC0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHdob3NlIFRleHROb2RlIG11c3QgYmUgbGFyZ2VyIHRoYW4uXG4gKiBAcmV0dXJucyBUaGUgVGV4dE5vZGUgYW5kIHRoZSBpbnRlcnNlY3Rpb25zIG9mZnNldCwgb3IgbnVsbCBpZiBubyBUZXh0Tm9kZSBpcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gJGZpbmRUZXh0SW50ZXJzZWN0aW9uRnJvbUNoYXJhY3RlcnMocm9vdCwgdGFyZ2V0Q2hhcmFjdGVycykge1xuICBsZXQgbm9kZSA9IHJvb3QuZ2V0Rmlyc3RDaGlsZCgpO1xuICBsZXQgY3VycmVudENoYXJhY3RlcnMgPSAwO1xuXG4gIG1haW5Mb29wOiB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNoYXJhY3RlcnMgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuXG4gICAgICBpZiAoY3VycmVudENoYXJhY3RlcnMgKyBjaGFyYWN0ZXJzID4gdGFyZ2V0Q2hhcmFjdGVycykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiB0YXJnZXRDaGFyYWN0ZXJzIC0gY3VycmVudENoYXJhY3RlcnNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudENoYXJhY3RlcnMgKz0gY2hhcmFjdGVycztcbiAgICB9XG5cbiAgICBjb25zdCBzaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBzaWJsaW5nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICAgIGlmIChwYXJlbnRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBwYXJlbnRTaWJsaW5nO1xuICAgICAgICBjb250aW51ZSBtYWluTG9vcDtcbiAgICAgIH1cblxuICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIH1cblxuICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHJvb3QgaGFzIGFueSB0ZXh0IGNvbnRlbnQgYW5kIGNhbiB0cmltIGFueSB3aGl0ZXNwYWNlIGlmIGl0IGRvZXMuXG4gKiBAcGFyYW0gaXNFZGl0b3JDb21wb3NpbmcgLSBJcyB0aGUgZWRpdG9yIGluIGNvbXBvc2l0aW9uIG1vZGUgZHVlIHRvIGFuIGFjdGl2ZSBJbnB1dCBNZXRob2QgRWRpdG9yP1xuICogQHBhcmFtIHRyaW0gLSBTaG91bGQgdGhlIHJvb3QgdGV4dCBoYXZlIGl0cyB3aGl0ZXNwYWNlZCB0cmltbWVkPyBEZWZhdWx0cyB0byB0cnVlLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0ZXh0IGNvbnRlbnQgaXMgZW1wdHksIGZhbHNlIGlmIHRoZXJlIGlzIHRleHQgb3IgaXNFZGl0b3JDb21wb3NpbmcgaXMgdHJ1ZS5cbiAqL1xuXG5mdW5jdGlvbiAkaXNSb290VGV4dENvbnRlbnRFbXB0eShpc0VkaXRvckNvbXBvc2luZywgdHJpbSA9IHRydWUpIHtcbiAgaWYgKGlzRWRpdG9yQ29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGV0IHRleHQgPSAkcm9vdFRleHRDb250ZW50KCk7XG5cbiAgaWYgKHRyaW0pIHtcbiAgICB0ZXh0ID0gdGV4dC50cmltKCk7XG4gIH1cblxuICByZXR1cm4gdGV4dCA9PT0gJyc7XG59XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIHtAbGluayAkaXNSb290VGV4dENvbnRlbnRFbXB0eX1cbiAqIEBwYXJhbSBpc0VkaXRvckNvbXBvc2luZyAtIElzIHRoZSBlZGl0b3IgaW4gY29tcG9zaXRpb24gbW9kZSBkdWUgdG8gYW4gYWN0aXZlIElucHV0IE1ldGhvZCBFZGl0b3I/XG4gKiBAcGFyYW0gdHJpbSAtIFNob3VsZCB0aGUgcm9vdCB0ZXh0IGhhdmUgaXRzIHdoaXRlc3BhY2VkIHRyaW1tZWQ/IERlZmF1bHRzIHRvIHRydWUuXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgJGlzUm9vdFRleHRDb250ZW50RW1wdHkgYmFzZWQgb24gYXJndW1lbnRzLlxuICovXG5cbmZ1bmN0aW9uICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5Q3VycnkoaXNFZGl0b3JDb21wb3NpbmcsIHRyaW0pIHtcbiAgcmV0dXJuICgpID0+ICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5KGlzRWRpdG9yQ29tcG9zaW5nLCB0cmltKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcm9vdCdzIHRleHQgY29udGVudC5cbiAqIEByZXR1cm5zIFRoZSByb290J3MgdGV4dCBjb250ZW50LlxuICovXG5cbmZ1bmN0aW9uICRyb290VGV4dENvbnRlbnQoKSB7XG4gIGNvbnN0IHJvb3QgPSBsZXhpY2FsLiRnZXRSb290KCk7XG4gIHJldHVybiByb290LmdldFRleHRDb250ZW50KCk7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IHNob3VsZCBzaG93IHRoZSBwbGFjZWhvbGRlci4gSWYgYW55dGhpbmcgaXMgaW5cbiAqIGluIHRoZSByb290IHRoZSBwbGFjZWhvbGRlciBzaG91bGQgbm90IGJlIHNob3duLlxuICogQHBhcmFtIGlzQ29tcG9zaW5nIC0gSXMgdGhlIGVkaXRvciBpbiBjb21wb3NpdGlvbiBtb2RlIGR1ZSB0byBhbiBhY3RpdmUgSW5wdXQgTWV0aG9kIEVkaXRvcj9cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IHNob3VsZCBzaG93IHRoZSBwbGFjZWhvbGRlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uICRjYW5TaG93UGxhY2Vob2xkZXIoaXNDb21wb3NpbmcpIHtcbiAgaWYgKCEkaXNSb290VGV4dENvbnRlbnRFbXB0eShpc0NvbXBvc2luZywgZmFsc2UpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgcm9vdCA9IGxleGljYWwuJGdldFJvb3QoKTtcbiAgY29uc3QgY2hpbGRyZW4gPSByb290LmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b3BCbG9jayA9IGNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKGxleGljYWwuJGlzRGVjb3JhdG9yTm9kZSh0b3BCbG9jaykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZSh0b3BCbG9jaykpIHtcbiAgICAgIGlmICghbGV4aWNhbC4kaXNQYXJhZ3JhcGhOb2RlKHRvcEJsb2NrKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b3BCbG9jay5fX2luZGVudCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRvcEJsb2NrQ2hpbGRyZW4gPSB0b3BCbG9jay5nZXRDaGlsZHJlbigpO1xuICAgICAgY29uc3QgdG9wQmxvY2tDaGlsZHJlbkxlbmd0aCA9IHRvcEJsb2NrQ2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICBmb3IgKGxldCBzID0gMDsgcyA8IHRvcEJsb2NrQ2hpbGRyZW5MZW5ndGg7IHMrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRvcEJsb2NrQ2hpbGRyZW5baV07XG5cbiAgICAgICAgaWYgKCFsZXhpY2FsLiRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyB7QGxpbmsgJGNhblNob3dQbGFjZWhvbGRlcn1cbiAqIEBwYXJhbSBpc0VkaXRvckNvbXBvc2luZyAtIElzIHRoZSBlZGl0b3IgaW4gY29tcG9zaXRpb24gbW9kZSBkdWUgdG8gYW4gYWN0aXZlIElucHV0IE1ldGhvZCBFZGl0b3I/XG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgJGNhblNob3dQbGFjZWhvbGRlciB3aXRoIGFyZ3VtZW50cy5cbiAqL1xuXG5mdW5jdGlvbiAkY2FuU2hvd1BsYWNlaG9sZGVyQ3VycnkoaXNFZGl0b3JDb21wb3NpbmcpIHtcbiAgcmV0dXJuICgpID0+ICRjYW5TaG93UGxhY2Vob2xkZXIoaXNFZGl0b3JDb21wb3NpbmcpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB0b3VwbGUgdGhhdCBjYW4gYmUgcmVzdGVkICguLi4pIGludG8gbWVyZ2VSZWdpc3RlciB0byBjbGVhbiB1cFxuICogbm9kZSB0cmFuc2Zvcm1zIGxpc3RlbmVycyB0aGF0IHRyYW5zZm9ybXMgdGV4dCBpbnRvIGFub3RoZXIgbm9kZSwgZWcuIGEgSGFzaHRhZ05vZGUuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gbWVyZ2VSZWdpc3RlcihcbiAgICAgIC4uLnJlZ2lzdGVyTGV4aWNhbFRleHRFbnRpdHkoZWRpdG9yLCBnZXRNYXRjaCwgdGFyZ2V0Tm9kZSwgY3JlYXRlTm9kZSksXG4gICAgKTtcbiAgfSwgW2NyZWF0ZU5vZGUsIGVkaXRvciwgZ2V0TWF0Y2gsIHRhcmdldE5vZGVdKTtcbiAqIGBgYFxuICogV2hlcmUgdGFyZ2V0Tm9kZSBpcyB0aGUgdHlwZSBvZiBub2RlIGNvbnRhaW5pbmcgdGhlIHRleHQgeW91IHdhbnQgdG8gdHJhbnNmb3JtIChsaWtlIGEgdGV4dCBpbnB1dCksXG4gKiB0aGVuIGdldE1hdGNoIHVzZXMgYSByZWdleCB0byBmaW5kIGEgbWF0Y2hpbmcgdGV4dCBhbmQgY3JlYXRlcyB0aGUgcHJvcGVyIG5vZGUgdG8gaW5jbHVkZSB0aGUgbWF0Y2hpbmcgdGV4dC5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gZ2V0TWF0Y2ggLSBGaW5kcyBhIG1hdGNoaW5nIHN0cmluZyB0aGF0IHNhdGlzZmllcyBhIHJlZ2V4IGV4cHJlc3Npb24uXG4gKiBAcGFyYW0gdGFyZ2V0Tm9kZSAtIFRoZSBub2RlIHR5cGUgdGhhdCBjb250YWlucyB0ZXh0IHRvIG1hdGNoIHdpdGguIGVnLiBIYXNodGFnTm9kZVxuICogQHBhcmFtIGNyZWF0ZU5vZGUgLSBBIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBub2RlIHRvIGNvbnRhaW4gdGhlIG1hdGNoZWQgdGV4dC4gZWcgY3JlYXRlSGFzaHRhZ05vZGVcbiAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBsYWluIHRleHQgYW5kIHJldmVyc2Ugbm9kZSB0cmFuc2Zvcm0gbGlzdGVuZXJzLlxuICovXG5mdW5jdGlvbiByZWdpc3RlckxleGljYWxUZXh0RW50aXR5KGVkaXRvciwgZ2V0TWF0Y2gsIHRhcmdldE5vZGUsIGNyZWF0ZU5vZGUpIHtcbiAgY29uc3QgaXNUYXJnZXROb2RlID0gbm9kZSA9PiB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiB0YXJnZXROb2RlO1xuICB9O1xuXG4gIGNvbnN0IHJlcGxhY2VXaXRoU2ltcGxlVGV4dCA9IG5vZGUgPT4ge1xuICAgIGNvbnN0IHRleHROb2RlID0gbGV4aWNhbC4kY3JlYXRlVGV4dE5vZGUobm9kZS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICB0ZXh0Tm9kZS5zZXRGb3JtYXQobm9kZS5nZXRGb3JtYXQoKSk7XG4gICAgbm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgfTtcblxuICBjb25zdCBnZXRNb2RlID0gbm9kZSA9PiB7XG4gICAgcmV0dXJuIG5vZGUuZ2V0TGF0ZXN0KCkuX19tb2RlO1xuICB9O1xuXG4gIGNvbnN0IHRleHROb2RlVHJhbnNmb3JtID0gbm9kZSA9PiB7XG4gICAgaWYgKCFub2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGxldCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgbGV0IG1hdGNoO1xuXG4gICAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1RleHQgPSBwcmV2U2libGluZy5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgY29uc3QgY29tYmluZWRUZXh0ID0gcHJldmlvdXNUZXh0ICsgdGV4dDtcbiAgICAgIGNvbnN0IHByZXZNYXRjaCA9IGdldE1hdGNoKGNvbWJpbmVkVGV4dCk7XG5cbiAgICAgIGlmIChpc1RhcmdldE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICAgIGlmIChwcmV2TWF0Y2ggPT09IG51bGwgfHwgZ2V0TW9kZShwcmV2U2libGluZykgIT09IDApIHtcbiAgICAgICAgICByZXBsYWNlV2l0aFNpbXBsZVRleHQocHJldlNpYmxpbmcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkaWZmID0gcHJldk1hdGNoLmVuZCAtIHByZXZpb3VzVGV4dC5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmNhdFRleHQgPSB0ZXh0LnNsaWNlKDAsIGRpZmYpO1xuICAgICAgICAgICAgY29uc3QgbmV3VGV4dENvbnRlbnQgPSBwcmV2aW91c1RleHQgKyBjb25jYXRUZXh0O1xuICAgICAgICAgICAgcHJldlNpYmxpbmcuc2VsZWN0KCk7XG4gICAgICAgICAgICBwcmV2U2libGluZy5zZXRUZXh0Q29udGVudChuZXdUZXh0Q29udGVudCk7XG5cbiAgICAgICAgICAgIGlmIChkaWZmID09PSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nVGV4dCA9IHRleHQuc2xpY2UoZGlmZik7XG4gICAgICAgICAgICAgIG5vZGUuc2V0VGV4dENvbnRlbnQocmVtYWluaW5nVGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJldk1hdGNoID09PSBudWxsIHx8IHByZXZNYXRjaC5zdGFydCA8IHByZXZpb3VzVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuXG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbWF0Y2ggPSBnZXRNYXRjaCh0ZXh0KTtcbiAgICAgIGxldCBuZXh0VGV4dCA9IG1hdGNoID09PSBudWxsID8gJycgOiB0ZXh0LnNsaWNlKG1hdGNoLmVuZCk7XG4gICAgICB0ZXh0ID0gbmV4dFRleHQ7XG5cbiAgICAgIGlmIChuZXh0VGV4dCA9PT0gJycpIHtcbiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBjdXJyZW50Tm9kZS5nZXROZXh0U2libGluZygpO1xuXG4gICAgICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgICAgIG5leHRUZXh0ID0gY3VycmVudE5vZGUuZ2V0VGV4dENvbnRlbnQoKSArIG5leHRTaWJsaW5nLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgICAgY29uc3QgbmV4dE1hdGNoID0gZ2V0TWF0Y2gobmV4dFRleHQpO1xuXG4gICAgICAgICAgaWYgKG5leHRNYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlzVGFyZ2V0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgICAgICAgICAgcmVwbGFjZVdpdGhTaW1wbGVUZXh0KG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5leHRTaWJsaW5nLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0TWF0Y2guc3RhcnQgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5leHRNYXRjaCA9IGdldE1hdGNoKG5leHRUZXh0KTtcblxuICAgICAgICBpZiAobmV4dE1hdGNoICE9PSBudWxsICYmIG5leHRNYXRjaC5zdGFydCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2guc3RhcnQgPT09IDAgJiYgbGV4aWNhbC4kaXNUZXh0Tm9kZShwcmV2U2libGluZykgJiYgcHJldlNpYmxpbmcuaXNUZXh0RW50aXR5KCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBub2RlVG9SZXBsYWNlO1xuXG4gICAgICBpZiAobWF0Y2guc3RhcnQgPT09IDApIHtcbiAgICAgICAgW25vZGVUb1JlcGxhY2UsIGN1cnJlbnROb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChtYXRjaC5lbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWywgbm9kZVRvUmVwbGFjZSwgY3VycmVudE5vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXBsYWNlbWVudE5vZGUgPSBjcmVhdGVOb2RlKG5vZGVUb1JlcGxhY2UpO1xuICAgICAgcmVwbGFjZW1lbnROb2RlLnNldEZvcm1hdChub2RlVG9SZXBsYWNlLmdldEZvcm1hdCgpKTtcbiAgICAgIG5vZGVUb1JlcGxhY2UucmVwbGFjZShyZXBsYWNlbWVudE5vZGUpO1xuXG4gICAgICBpZiAoY3VycmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJldmVyc2VOb2RlVHJhbnNmb3JtID0gbm9kZSA9PiB7XG4gICAgY29uc3QgdGV4dCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBjb25zdCBtYXRjaCA9IGdldE1hdGNoKHRleHQpO1xuXG4gICAgaWYgKG1hdGNoID09PSBudWxsIHx8IG1hdGNoLnN0YXJ0ICE9PSAwKSB7XG4gICAgICByZXBsYWNlV2l0aFNpbXBsZVRleHQobm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRleHQubGVuZ3RoID4gbWF0Y2guZW5kKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgc3BsaXQgb3V0IHRoZSByZXN0IG9mIHRoZSB0ZXh0IGFzIHNpbXBsZSB0ZXh0XG4gICAgICBub2RlLnNwbGl0VGV4dChtYXRjaC5lbmQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKHByZXZTaWJsaW5nKSAmJiBwcmV2U2libGluZy5pc1RleHRFbnRpdHkoKSkge1xuICAgICAgcmVwbGFjZVdpdGhTaW1wbGVUZXh0KHByZXZTaWJsaW5nKTtcbiAgICAgIHJlcGxhY2VXaXRoU2ltcGxlVGV4dChub2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKG5leHRTaWJsaW5nKSAmJiBuZXh0U2libGluZy5pc1RleHRFbnRpdHkoKSkge1xuICAgICAgcmVwbGFjZVdpdGhTaW1wbGVUZXh0KG5leHRTaWJsaW5nKTsgLy8gVGhpcyBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY29udmVydGVkIGluIHRoZSBwcmV2aW91cyBibG9ja1xuXG4gICAgICBpZiAoaXNUYXJnZXROb2RlKG5vZGUpKSB7XG4gICAgICAgIHJlcGxhY2VXaXRoU2ltcGxlVGV4dChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVtb3ZlUGxhaW5UZXh0VHJhbnNmb3JtID0gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShsZXhpY2FsLlRleHROb2RlLCB0ZXh0Tm9kZVRyYW5zZm9ybSk7XG4gIGNvbnN0IHJlbW92ZVJldmVyc2VOb2RlVHJhbnNmb3JtID0gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybSh0YXJnZXROb2RlLCByZXZlcnNlTm9kZVRyYW5zZm9ybSk7XG4gIHJldHVybiBbcmVtb3ZlUGxhaW5UZXh0VHJhbnNmb3JtLCByZW1vdmVSZXZlcnNlTm9kZVRyYW5zZm9ybV07XG59XG5cbmV4cG9ydHMuJGNhblNob3dQbGFjZWhvbGRlciA9ICRjYW5TaG93UGxhY2Vob2xkZXI7XG5leHBvcnRzLiRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeSA9ICRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeTtcbmV4cG9ydHMuJGZpbmRUZXh0SW50ZXJzZWN0aW9uRnJvbUNoYXJhY3RlcnMgPSAkZmluZFRleHRJbnRlcnNlY3Rpb25Gcm9tQ2hhcmFjdGVycztcbmV4cG9ydHMuJGlzUm9vdFRleHRDb250ZW50RW1wdHkgPSAkaXNSb290VGV4dENvbnRlbnRFbXB0eTtcbmV4cG9ydHMuJGlzUm9vdFRleHRDb250ZW50RW1wdHlDdXJyeSA9ICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5Q3Vycnk7XG5leHBvcnRzLiRyb290VGV4dENvbnRlbnQgPSAkcm9vdFRleHRDb250ZW50O1xuZXhwb3J0cy5yZWdpc3RlckxleGljYWxUZXh0RW50aXR5ID0gcmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/text/LexicalText.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/text/LexicalText.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/text/LexicalText.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalText =  true ? __webpack_require__(/*! ./LexicalText.dev.js */ \"(ssr)/./node_modules/@lexical/text/LexicalText.dev.js\") : 0\nmodule.exports = LexicalText;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGV4dC9MZXhpY2FsVGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLG9CQUFvQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsbUZBQXNCLElBQUksQ0FBZ0M7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90ZXh0L0xleGljYWxUZXh0LmpzPzQ3YmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxUZXh0ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxUZXh0LmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsVGV4dC5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbFRleHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/text/LexicalText.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.dev.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar selection = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/utils */\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      const classesToAdd = className.split(' ').filter(n => n !== '');\n      element.classList.add(...classesToAdd);\n    }\n  });\n}\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\n\nfunction removeClassNamesFromElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\n\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\n\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n\n      if (done) {\n        return resolve(processed);\n      }\n\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n\n        handleNextFile();\n      });\n\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * {depth: number, node: LexicalNode} It will always return at least 1 node (the ending node) so long as it exists\n */\n\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n\n  return nodes;\n}\n\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n\n  return depth;\n}\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\n\n\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return null;\n}\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\n\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n\n  return blockNode;\n}\n\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the compenent it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguements\n * are considered to be the func argument and spread from there.\n * @param func - An array of functions meant to be executed by the returned function.\n * @returns the function which executes all the passed register command functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\n\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n\n    let parentNode = node;\n    let childNode = node;\n\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n\n    return null;\n  };\n\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match; // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\n\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = selection.$cloneWithProperties(node);\n\n    if (lexical.$isTextNode(clone)) {\n      clone.__text = node.__text;\n    }\n\n    nodeMap.set(key, clone);\n  }\n\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n\n  editor._dirtyType = FULL_RECONCILE;\n  const selection$1 = editorState._selection;\n  lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\n}\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\n\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection() || lexical.$getPreviousSelection();\n\n  if (lexical.$isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n\n      if (lexical.$isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n\n      const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = lexical.$getRoot();\n      root.append(node);\n    }\n\n    const paragraphNode = lexical.$createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n\n  return node.getLatest();\n}\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexcial element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexcial element with the previous node appended within (as a child, including its children).\n */\n\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\n\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n/**\n * @param x - The element being testing\n * @returns Returns true if x is an HTML element, false otherwise.\n */\n\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\nexports.$splitNode = lexical.$splitNode;\nexports.$dfs = $dfs;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.isHTMLAnchorElement = isHTMLAnchorElement;\nexports.isHTMLElement = isHTMLElement;\nexports.isMimeType = isMimeType;\nexports.mediaFileReader = mediaFileReader;\nexports.mergeRegister = mergeRegister;\nexports.objectKlassEquals = objectKlassEquals;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQyx1RkFBb0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLHdEQUFTOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGtDQUFrQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsa0NBQWtDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osMkJBQTJCO0FBQzNCLDhDQUE4QztBQUM5Qyw2QkFBNkI7QUFDN0IsZ0NBQWdDO0FBQ2hDLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLHFDQUFxQztBQUNyQyxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC91dGlscy9MZXhpY2FsVXRpbHMuZGV2LmpzPzY5ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzZWxlY3Rpb24gPSByZXF1aXJlKCdAbGV4aWNhbC9zZWxlY3Rpb24nKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xuXG4vKiogQG1vZHVsZSBAbGV4aWNhbC91dGlscyAqL1xuXG4vKipcbiAqIFRha2VzIGFuIEhUTUwgZWxlbWVudCBhbmQgYWRkcyB0aGUgY2xhc3NOYW1lcyBwYXNzZWQgd2l0aGluIGFuIGFycmF5LFxuICogaWdub3JpbmcgYW55IG5vbi1zdHJpbmcgdHlwZXMuIEEgc3BhY2UgY2FuIGJlIHVzZWQgdG8gYWRkIG11bHRpcGxlIGNsYXNzZXNcbiAqIGVnLiBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIFsnZWxlbWVudC1pbm5lciBhY3RpdmUnLCB0cnVlLCBudWxsXSlcbiAqIHdpbGwgYWRkIGJvdGggJ2VsZW1lbnQtaW5uZXInIGFuZCAnYWN0aXZlJyBhcyBjbGFzc2VzIHRvIHRoYXQgZWxlbWVudC5cbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGNsYXNzZXMgYXJlIGFkZGVkXG4gKiBAcGFyYW0gY2xhc3NOYW1lcyAtIEFuIGFycmF5IGRlZmluaW5nIHRoZSBjbGFzcyBuYW1lcyB0byBhZGQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCAuLi5jbGFzc05hbWVzKSB7XG4gIGNsYXNzTmFtZXMuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgY2xhc3Nlc1RvQWRkID0gY2xhc3NOYW1lLnNwbGl0KCcgJykuZmlsdGVyKG4gPT4gbiAhPT0gJycpO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXNUb0FkZCk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogVGFrZXMgYW4gSFRNTCBlbGVtZW50IGFuZCByZW1vdmVzIHRoZSBjbGFzc05hbWVzIHBhc3NlZCB3aXRoaW4gYW4gYXJyYXksXG4gKiBpZ25vcmluZyBhbnkgbm9uLXN0cmluZyB0eXBlcy4gQSBzcGFjZSBjYW4gYmUgdXNlZCB0byByZW1vdmUgbXVsdGlwbGUgY2xhc3Nlc1xuICogZWcuIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCBbJ2FjdGl2ZSBzbWFsbCcsIHRydWUsIG51bGxdKVxuICogd2lsbCByZW1vdmUgYm90aCB0aGUgJ2FjdGl2ZScgYW5kICdzbWFsbCcgY2xhc3NlcyBmcm9tIHRoYXQgZWxlbWVudC5cbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGNsYXNzZXMgYXJlIHJlbW92ZWRcbiAqIEBwYXJhbSBjbGFzc05hbWVzIC0gQW4gYXJyYXkgZGVmaW5pbmcgdGhlIGNsYXNzIG5hbWVzIHRvIHJlbW92ZSBmcm9tIHRoZSBlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGVsZW1lbnQsIC4uLmNsYXNzTmFtZXMpIHtcbiAgY2xhc3NOYW1lcy5mb3JFYWNoKGNsYXNzTmFtZSA9PiB7XG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lLnNwbGl0KCcgJykpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZmlsZSB0eXBlIG1hdGNoZXMgdGhlIHR5cGVzIHBhc3NlZCB3aXRoaW4gdGhlIGFjY2VwdGFibGVNaW1lVHlwZXMgYXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbiAqIFRoZSB0eXBlcyBwYXNzZWQgbXVzdCBiZSBzdHJpbmdzIGFuZCBhcmUgQ0FTRS1TRU5TSVRJVkUuXG4gKiBlZy4gaWYgZmlsZSBpcyBvZiB0eXBlICd0ZXh0JyBhbmQgYWNjZXB0YWJsZU1pbWVUeXBlcyA9IFsnVEVYVCcsICdJTUFHRSddIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBmYWxzZS5cbiAqIEBwYXJhbSBmaWxlIC0gVGhlIGZpbGUgeW91IHdhbnQgdG8gdHlwZSBjaGVjay5cbiAqIEBwYXJhbSBhY2NlcHRhYmxlTWltZVR5cGVzIC0gQW4gYXJyYXkgb2Ygc3RyaW5ncyBvZiB0eXBlcyB3aGljaCB0aGUgZmlsZSBpcyBjaGVja2VkIGFnYWluc3QuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBmaWxlIGlzIGFuIGFjY2VwdGFibGUgbWltZSB0eXBlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNNaW1lVHlwZShmaWxlLCBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gIGZvciAoY29uc3QgYWNjZXB0YWJsZVR5cGUgb2YgYWNjZXB0YWJsZU1pbWVUeXBlcykge1xuICAgIGlmIChmaWxlLnR5cGUuc3RhcnRzV2l0aChhY2NlcHRhYmxlVHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogTGV4aWNhbCBGaWxlIFJlYWRlciB3aXRoOlxuICogIDEuIE1JTUUgdHlwZSBzdXBwb3J0XG4gKiAgMi4gYmF0Y2hlZCByZXN1bHRzIChIaXN0b3J5UGx1Z2luIGNvbXBhdGliaWxpdHkpXG4gKiAgMy4gT3JkZXIgYXdhcmUgKHJlc3BlY3RzIHRoZSBvcmRlciB3aGVuIG11bHRpcGxlIEZpbGVzIGFyZSBwYXNzZWQpXG4gKlxuICogY29uc3QgZmlsZXNSZXN1bHQgPSBhd2FpdCBtZWRpYUZpbGVSZWFkZXIoZmlsZXMsIFsnaW1hZ2UvJ10pO1xuICogZmlsZXNSZXN1bHQuZm9yRWFjaChmaWxlID0+IGVkaXRvci5kaXNwYXRjaENvbW1hbmQoJ0lOU0VSVF9JTUFHRScsIHtcbiAqICAgc3JjOiBmaWxlLnJlc3VsdCxcbiAqIH0pKTtcbiAqL1xuXG5mdW5jdGlvbiBtZWRpYUZpbGVSZWFkZXIoZmlsZXMsIGFjY2VwdGFibGVNaW1lVHlwZXMpIHtcbiAgY29uc3QgZmlsZXNJdGVyYXRvciA9IGZpbGVzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBwcm9jZXNzZWQgPSBbXTtcblxuICAgIGNvbnN0IGhhbmRsZU5leHRGaWxlID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkb25lLFxuICAgICAgICB2YWx1ZTogZmlsZVxuICAgICAgfSA9IGZpbGVzSXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShwcm9jZXNzZWQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCByZWplY3QpO1xuICAgICAgZmlsZVJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBmaWxlUmVhZGVyLnJlc3VsdDtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwcm9jZXNzZWQucHVzaCh7XG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGVOZXh0RmlsZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc01pbWVUeXBlKGZpbGUsIGFjY2VwdGFibGVNaW1lVHlwZXMpKSB7XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gIH0pO1xufVxuLyoqXG4gKiBcIkRlcHRoLUZpcnN0IFNlYXJjaFwiIHN0YXJ0cyBhdCB0aGUgcm9vdC90b3Agbm9kZSBvZiBhIHRyZWUgYW5kIGdvZXMgYXMgZmFyIGFzIGl0IGNhbiBkb3duIGEgYnJhbmNoIGVuZFxuICogYmVmb3JlIGJhY2t0cmFja2luZyBhbmQgZmluZGluZyBhIG5ldyBwYXRoLiBDb25zaWRlciBzb2x2aW5nIGEgbWF6ZSBieSBodWdnaW5nIGVpdGhlciB3YWxsLCBtb3ZpbmcgZG93biBhXG4gKiBicmFuY2ggdW50aWwgeW91IGhpdCBhIGRlYWQtZW5kIChsZWFmKSBhbmQgYmFja3RyYWNraW5nIHRvIGZpbmQgdGhlIG5lYXJlc3QgYnJhbmNoaW5nIHBhdGggYW5kIHJlcGVhdC5cbiAqIEl0IHdpbGwgdGhlbiByZXR1cm4gYWxsIHRoZSBub2RlcyBmb3VuZCBpbiB0aGUgc2VhcmNoIGluIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gKiBAcGFyYW0gc3RhcnRpbmdOb2RlIC0gVGhlIG5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaCwgaWYgb21taXR0ZWQsIGl0IHdpbGwgc3RhcnQgYXQgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSBlbmRpbmdOb2RlIC0gVGhlIG5vZGUgdG8gZW5kIHRoZSBzZWFyY2gsIGlmIG9tbWl0dGVkLCBpdCB3aWxsIGZpbmQgYWxsIGRlc2NlbmRhbnRzIG9mIHRoZSBzdGFydGluZ05vZGUuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBvYmplY3RzIG9mIGFsbCB0aGUgbm9kZXMgZm91bmQgYnkgdGhlIHNlYXJjaCwgaW5jbHVkaW5nIHRoZWlyIGRlcHRoIGludG8gdGhlIHRyZWUuXG4gKiB7ZGVwdGg6IG51bWJlciwgbm9kZTogTGV4aWNhbE5vZGV9IEl0IHdpbGwgYWx3YXlzIHJldHVybiBhdCBsZWFzdCAxIG5vZGUgKHRoZSBlbmRpbmcgbm9kZSkgc28gbG9uZyBhcyBpdCBleGlzdHNcbiAqL1xuXG5mdW5jdGlvbiAkZGZzKHN0YXJ0aW5nTm9kZSwgZW5kaW5nTm9kZSkge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBjb25zdCBzdGFydCA9IChzdGFydGluZ05vZGUgfHwgbGV4aWNhbC4kZ2V0Um9vdCgpKS5nZXRMYXRlc3QoKTtcbiAgY29uc3QgZW5kID0gZW5kaW5nTm9kZSB8fCAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShzdGFydCkgPyBzdGFydC5nZXRMYXN0RGVzY2VuZGFudCgpIDogc3RhcnQpO1xuICBsZXQgbm9kZSA9IHN0YXJ0O1xuICBsZXQgZGVwdGggPSAkZ2V0RGVwdGgobm9kZSk7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgIW5vZGUuaXMoZW5kKSkge1xuICAgIG5vZGVzLnB1c2goe1xuICAgICAgZGVwdGgsXG4gICAgICBub2RlXG4gICAgfSk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmdldENoaWxkcmVuU2l6ZSgpID4gMCkge1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgZGVwdGgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmluZCBpbW1lZGlhdGUgc2libGluZyBvciBuZWFyZXN0IHBhcmVudCBzaWJsaW5nXG4gICAgICBsZXQgc2libGluZyA9IG51bGw7XG5cbiAgICAgIHdoaWxlIChzaWJsaW5nID09PSBudWxsICYmIG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgc2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgICBpZiAoc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZSA9IHNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobm9kZSAhPT0gbnVsbCAmJiBub2RlLmlzKGVuZCkpIHtcbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGRlcHRoLFxuICAgICAgbm9kZVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5mdW5jdGlvbiAkZ2V0RGVwdGgobm9kZSkge1xuICBsZXQgaW5uZXJOb2RlID0gbm9kZTtcbiAgbGV0IGRlcHRoID0gMDtcblxuICB3aGlsZSAoKGlubmVyTm9kZSA9IGlubmVyTm9kZS5nZXRQYXJlbnQoKSkgIT09IG51bGwpIHtcbiAgICBkZXB0aCsrO1xuICB9XG5cbiAgcmV0dXJuIGRlcHRoO1xufVxuLyoqXG4gKiBUYWtlcyBhIG5vZGUgYW5kIHRyYXZlcnNlcyB1cCBpdHMgYW5jZXN0b3JzICh0b3dhcmQgdGhlIHJvb3Qgbm9kZSlcbiAqIGluIG9yZGVyIHRvIGZpbmQgYSBzcGVjaWZpYyB0eXBlIG9mIG5vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIHRoZSBub2RlIHRvIGJlZ2luIHNlYXJjaGluZy5cbiAqIEBwYXJhbSBrbGFzcyAtIGFuIGluc3RhbmNlIG9mIHRoZSB0eXBlIG9mIG5vZGUgdG8gbG9vayBmb3IuXG4gKiBAcmV0dXJucyB0aGUgbm9kZSBvZiB0eXBlIGtsYXNzIHRoYXQgd2FzIHBhc3NlZCwgb3IgbnVsbCBpZiBub25lIGV4aXN0LlxuICovXG5cblxuZnVuY3Rpb24gJGdldE5lYXJlc3ROb2RlT2ZUeXBlKG5vZGUsIGtsYXNzKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuXG4gIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBrbGFzcykge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBub2RlIG9mIHRoZSBuZWFyZXN0IGFuY2VzdG9yLCBvdGhlcndpc2UgdGhyb3dzIGFuIGVycm9yLlxuICogQHBhcmFtIHN0YXJ0Tm9kZSAtIFRoZSBzdGFydGluZyBub2RlIG9mIHRoZSBzZWFyY2hcbiAqIEByZXR1cm5zIFRoZSBhbmNlc3RvciBub2RlIGZvdW5kXG4gKi9cblxuZnVuY3Rpb24gJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3coc3RhcnROb2RlKSB7XG4gIGNvbnN0IGJsb2NrTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnROb2RlLCBub2RlID0+IGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuaXNJbmxpbmUoKSk7XG5cbiAgaWYgKCFsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGJsb2NrTm9kZSkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSAke3N0YXJ0Tm9kZS5fX2tleX0gdG8gaGF2ZSBjbG9zZXN0IGJsb2NrIGVsZW1lbnQgbm9kZS5gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmxvY2tOb2RlO1xufVxuXG4vKipcbiAqIFN0YXJ0cyB3aXRoIGEgbm9kZSBhbmQgbW92ZXMgdXAgdGhlIHRyZWUgKHRvd2FyZCB0aGUgcm9vdCBub2RlKSB0byBmaW5kIGEgbWF0Y2hpbmcgbm9kZSBiYXNlZCBvblxuICogdGhlIHNlYXJjaCBwYXJhbWV0ZXJzIG9mIHRoZSBmaW5kRm4uIChDb25zaWRlciBKYXZhU2NyaXB0cycgLmZpbmQoKSBmdW5jdGlvbiB3aGVyZSBhIHRlc3RpbmcgZnVuY3Rpb24gbXVzdCBiZVxuICogcGFzc2VkIGFzIGFuIGFyZ3VtZW50LiBlZy4gaWYoIChub2RlKSA9PiBub2RlLl9fdHlwZSA9PT0gJ2RpdicpICkgcmV0dXJuIHRydWU7IG90aGVyd2lzZSByZXR1cm4gZmFsc2VcbiAqIEBwYXJhbSBzdGFydGluZ05vZGUgLSBUaGUgbm9kZSB3aGVyZSB0aGUgc2VhcmNoIHN0YXJ0cy5cbiAqIEBwYXJhbSBmaW5kRm4gLSBBIHRlc3RpbmcgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgbm9kZSBzYXRpc2ZpZXMgdGhlIHRlc3RpbmcgcGFyYW1ldGVycy5cbiAqIEByZXR1cm5zIEEgcGFyZW50IG5vZGUgdGhhdCBtYXRjaGVzIHRoZSBmaW5kRm4gcGFyYW1ldGVycywgb3IgbnVsbCBpZiBvbmUgd2Fzbid0IGZvdW5kLlxuICovXG5mdW5jdGlvbiAkZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0aW5nTm9kZSwgZmluZEZuKSB7XG4gIGxldCBjdXJyID0gc3RhcnRpbmdOb2RlO1xuXG4gIHdoaWxlIChjdXJyICE9PSBsZXhpY2FsLiRnZXRSb290KCkgJiYgY3VyciAhPSBudWxsKSB7XG4gICAgaWYgKGZpbmRGbihjdXJyKSkge1xuICAgICAgcmV0dXJuIGN1cnI7XG4gICAgfVxuXG4gICAgY3VyciA9IGN1cnIuZ2V0UGFyZW50KCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgYWxsIGZ1bmN0aW9ucyBwYXNzZWQgd2hlbiBjYWxsZWQuIEl0IGlzIGdlbmVyYWxseSB1c2VkXG4gKiB0byByZWdpc3RlciBtdWx0aXBsZSBsZXhpY2FsIGxpc3RlbmVycyBhbmQgdGhlbiB0ZWFyIHRoZW0gZG93biB3aXRoIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGwsIHN1Y2hcbiAqIGFzIFJlYWN0J3MgdXNlRWZmZWN0IGhvb2suXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKFxuICogICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoLi4ucmVnaXN0ZXJDb21tYW5kMSBsb2dpYyksXG4gKiAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZCguLi5yZWdpc3RlckNvbW1hbmQyIGxvZ2ljKSxcbiAqICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKC4uLnJlZ2lzdGVyQ29tbWFuZDMgbG9naWMpXG4gKiAgIClcbiAqIH0sIFtlZGl0b3JdKVxuICogYGBgXG4gKiBJbiB0aGlzIGNhc2UsIHVzZUVmZmVjdCBpcyByZXR1cm5pbmcgdGhlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IG1lcmdlUmVnaXN0ZXIgYXMgYSBjbGVhbnVwXG4gKiBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciBlaXRoZXIgdGhlIHVzZUVmZmVjdCBydW5zIGFnYWluIChkdWUgdG8gb25lIG9mIGl0cyBkZXBlbmRlbmNpZXNcbiAqIHVwZGF0aW5nKSBvciB0aGUgY29tcGVuZW50IGl0IHJlc2lkZXMgaW4gdW5tb3VudHMuXG4gKiBOb3RlIHRoZSBmdW5jdGlvbnMgZG9uJ3QgbmVjY2VzYXJpbHkgbmVlZCB0byBiZSBpbiBhbiBhcnJheSBhcyBhbGwgYXJndWVtZW50c1xuICogYXJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIGZ1bmMgYXJndW1lbnQgYW5kIHNwcmVhZCBmcm9tIHRoZXJlLlxuICogQHBhcmFtIGZ1bmMgLSBBbiBhcnJheSBvZiBmdW5jdGlvbnMgbWVhbnQgdG8gYmUgZXhlY3V0ZWQgYnkgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICogQHJldHVybnMgdGhlIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGFsbCB0aGUgcGFzc2VkIHJlZ2lzdGVyIGNvbW1hbmQgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZVJlZ2lzdGVyKC4uLmZ1bmMpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmdW5jLmZvckVhY2goZiA9PiBmKCkpO1xuICB9O1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXNvbHZlIG5lc3RlZCBlbGVtZW50IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgaW50byBhIHNpbmdsZSBub2RlIG9mIHRoYXQgdHlwZS5cbiAqIEl0IGlzIGdlbmVyYWxseSB1c2VkIGZvciBtYXJrcy9jb21tZW50aW5nXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yXG4gKiBAcGFyYW0gdGFyZ2V0Tm9kZSAtIFRoZSB0YXJnZXQgZm9yIHRoZSBuZXN0ZWQgZWxlbWVudCB0byBiZSBleHRyYWN0ZWQgZnJvbS5cbiAqIEBwYXJhbSBjbG9uZU5vZGUgLSBTZWUge0BsaW5rICRjcmVhdGVNYXJrTm9kZX1cbiAqIEBwYXJhbSBoYW5kbGVPdmVybGFwIC0gSGFuZGxlcyBhbnkgb3ZlcmxhcCBiZXR3ZWVuIHRoZSBub2RlIHRvIGV4dHJhY3QgYW5kIHRoZSB0YXJnZXROb2RlXG4gKiBAcmV0dXJucyBUaGUgbGV4aWNhbCBlZGl0b3JcbiAqL1xuXG5mdW5jdGlvbiByZWdpc3Rlck5lc3RlZEVsZW1lbnRSZXNvbHZlcihlZGl0b3IsIHRhcmdldE5vZGUsIGNsb25lTm9kZSwgaGFuZGxlT3ZlcmxhcCkge1xuICBjb25zdCAkaXNUYXJnZXROb2RlID0gbm9kZSA9PiB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiB0YXJnZXROb2RlO1xuICB9O1xuXG4gIGNvbnN0ICRmaW5kTWF0Y2ggPSBub2RlID0+IHtcbiAgICAvLyBGaXJzdCB2YWxpZGF0ZSB3ZSBkb24ndCBoYXZlIGFueSBjaGlsZHJlbiB0aGF0IGFyZSBvZiB0aGUgdGFyZ2V0LFxuICAgIC8vIGFzIHdlIG5lZWQgdG8gaGFuZGxlIHRoZW0gZmlyc3QuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoJGlzVGFyZ2V0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHBhcmVudE5vZGUgPSBub2RlO1xuICAgIGxldCBjaGlsZE5vZGUgPSBub2RlO1xuXG4gICAgd2hpbGUgKHBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkTm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5nZXRQYXJlbnQoKTtcblxuICAgICAgaWYgKCRpc1RhcmdldE5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGlsZDogY2hpbGROb2RlLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50Tm9kZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIGNvbnN0IGVsZW1lbnROb2RlVHJhbnNmb3JtID0gbm9kZSA9PiB7XG4gICAgY29uc3QgbWF0Y2ggPSAkZmluZE1hdGNoKG5vZGUpO1xuXG4gICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSBtYXRjaDsgLy8gU2ltcGxlIHBhdGgsIHdlIGNhbiBtb3ZlIGNoaWxkIG91dCBhbmQgc2libGluZ3MgaW50byBhIG5ldyBwYXJlbnQuXG5cbiAgICAgIGlmIChjaGlsZC5pcyhub2RlKSkge1xuICAgICAgICBoYW5kbGVPdmVybGFwKHBhcmVudCwgbm9kZSk7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5ncyA9IGNoaWxkLmdldE5leHRTaWJsaW5ncygpO1xuICAgICAgICBjb25zdCBuZXh0U2libGluZ3NMZW5ndGggPSBuZXh0U2libGluZ3MubGVuZ3RoO1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QWZ0ZXIoY2hpbGQpO1xuXG4gICAgICAgIGlmIChuZXh0U2libGluZ3NMZW5ndGggIT09IDApIHtcbiAgICAgICAgICBjb25zdCBuZXdQYXJlbnQgPSBjbG9uZU5vZGUocGFyZW50KTtcbiAgICAgICAgICBjaGlsZC5pbnNlcnRBZnRlcihuZXdQYXJlbnQpO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U2libGluZ3NMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3UGFyZW50LmFwcGVuZChuZXh0U2libGluZ3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcGFyZW50LmNhbkJlRW1wdHkoKSAmJiBwYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0odGFyZ2V0Tm9kZSwgZWxlbWVudE5vZGVUcmFuc2Zvcm0pO1xufVxuLyoqXG4gKiBDbG9uZXMgdGhlIGVkaXRvciBhbmQgbWFya3MgaXQgYXMgZGlydHkgdG8gYmUgcmVjb25jaWxlZC4gSWYgdGhlcmUgd2FzIGEgc2VsZWN0aW9uLFxuICogaXQgd291bGQgYmUgc2V0IGJhY2sgdG8gaXRzIHByZXZpb3VzIHN0YXRlLCBvciBudWxsIG90aGVyd2lzZS5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3JcbiAqIEBwYXJhbSBlZGl0b3JTdGF0ZSAtIFRoZSBlZGl0b3IncyBzdGF0ZVxuICovXG5cbmZ1bmN0aW9uICRyZXN0b3JlRWRpdG9yU3RhdGUoZWRpdG9yLCBlZGl0b3JTdGF0ZSkge1xuICBjb25zdCBGVUxMX1JFQ09OQ0lMRSA9IDI7XG4gIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGFjdGl2ZUVkaXRvclN0YXRlID0gZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGU7XG5cbiAgZm9yIChjb25zdCBba2V5LCBub2RlXSBvZiBlZGl0b3JTdGF0ZS5fbm9kZU1hcCkge1xuICAgIGNvbnN0IGNsb25lID0gc2VsZWN0aW9uLiRjbG9uZVdpdGhQcm9wZXJ0aWVzKG5vZGUpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoY2xvbmUpKSB7XG4gICAgICBjbG9uZS5fX3RleHQgPSBub2RlLl9fdGV4dDtcbiAgICB9XG5cbiAgICBub2RlTWFwLnNldChrZXksIGNsb25lKTtcbiAgfVxuXG4gIGlmIChhY3RpdmVFZGl0b3JTdGF0ZSkge1xuICAgIGFjdGl2ZUVkaXRvclN0YXRlLl9ub2RlTWFwID0gbm9kZU1hcDtcbiAgfVxuXG4gIGVkaXRvci5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gIGNvbnN0IHNlbGVjdGlvbiQxID0gZWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgbGV4aWNhbC4kc2V0U2VsZWN0aW9uKHNlbGVjdGlvbiQxID09PSBudWxsID8gbnVsbCA6IHNlbGVjdGlvbiQxLmNsb25lKCkpO1xufVxuLyoqXG4gKiBJZiB0aGUgc2VsZWN0ZWQgaW5zZXJ0aW9uIGFyZWEgaXMgdGhlIHJvb3Qvc2hhZG93IHJvb3Qgbm9kZSAoc2VlIHtAbGluayBsZXhpY2FsISRpc1Jvb3RPclNoYWRvd1Jvb3R9KSxcbiAqIHRoZSBub2RlIHdpbGwgYmUgYXBwZW5kZWQgdGhlcmUsIG90aGVyd2lzZSwgaXQgd2lsbCBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIGluc2VydGlvbiBhcmVhLlxuICogSWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uIHdoZXJlIHRoZSBub2RlIGlzIHRvIGJlIGluc2VydGVkLCBpdCB3aWxsIGJlIGFwcGVuZGVkIGFmdGVyIGFueSBjdXJyZW50IG5vZGVzXG4gKiB3aXRoaW4gdGhlIHRyZWUsIGFzIGEgY2hpbGQgb2YgdGhlIHJvb3Qgbm9kZS4gQSBwYXJhZ3JhcGggbm9kZSB3aWxsIHRoZW4gYmUgYWRkZWQgYWZ0ZXIgdGhlIGluc2VydGVkIG5vZGUgYW5kIHNlbGVjdGVkLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBpbnNlcnRlZFxuICogQHJldHVybnMgVGhlIG5vZGUgYWZ0ZXIgaXRzIGluc2VydGlvblxuICovXG5cbmZ1bmN0aW9uICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdChub2RlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpIHx8IGxleGljYWwuJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG5cbiAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNSb290T3JTaGFkb3dSb290KGZvY3VzTm9kZSkpIHtcbiAgICAgIGNvbnN0IGZvY3VzQ2hpbGQgPSBmb2N1c05vZGUuZ2V0Q2hpbGRBdEluZGV4KGZvY3VzT2Zmc2V0KTtcblxuICAgICAgaWYgKGZvY3VzQ2hpbGQgPT0gbnVsbCkge1xuICAgICAgICBmb2N1c05vZGUuYXBwZW5kKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9jdXNDaGlsZC5pbnNlcnRCZWZvcmUobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2VsZWN0TmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgc3BsaXROb2RlO1xuICAgICAgbGV0IHNwbGl0T2Zmc2V0O1xuXG4gICAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShmb2N1c05vZGUpKSB7XG4gICAgICAgIHNwbGl0Tm9kZSA9IGZvY3VzTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgIHNwbGl0T2Zmc2V0ID0gZm9jdXNOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG5cbiAgICAgICAgaWYgKGZvY3VzT2Zmc2V0ID4gMCkge1xuICAgICAgICAgIHNwbGl0T2Zmc2V0ICs9IDE7XG4gICAgICAgICAgZm9jdXNOb2RlLnNwbGl0VGV4dChmb2N1c09mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwbGl0Tm9kZSA9IGZvY3VzTm9kZTtcbiAgICAgICAgc3BsaXRPZmZzZXQgPSBmb2N1c09mZnNldDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgWywgcmlnaHRUcmVlXSA9IGxleGljYWwuJHNwbGl0Tm9kZShzcGxpdE5vZGUsIHNwbGl0T2Zmc2V0KTtcbiAgICAgIHJpZ2h0VHJlZS5pbnNlcnRCZWZvcmUobm9kZSk7XG4gICAgICByaWdodFRyZWUuc2VsZWN0U3RhcnQoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGxleGljYWwuJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXS5nZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCkuaW5zZXJ0QWZ0ZXIobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvb3QgPSBsZXhpY2FsLiRnZXRSb290KCk7XG4gICAgICByb290LmFwcGVuZChub2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhZ3JhcGhOb2RlID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIG5vZGUuaW5zZXJ0QWZ0ZXIocGFyYWdyYXBoTm9kZSk7XG4gICAgcGFyYWdyYXBoTm9kZS5zZWxlY3QoKTtcbiAgfVxuXG4gIHJldHVybiBub2RlLmdldExhdGVzdCgpO1xufVxuLyoqXG4gKiBXcmFwcyB0aGUgbm9kZSBpbnRvIGFub3RoZXIgbm9kZSBjcmVhdGVkIGZyb20gYSBjcmVhdGVFbGVtZW50Tm9kZSBmdW5jdGlvbiwgZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlXG4gKiBAcGFyYW0gbm9kZSAtIE5vZGUgdG8gYmUgd3JhcHBlZC5cbiAqIEBwYXJhbSBjcmVhdGVFbGVtZW50Tm9kZSAtIENyZWF0ZXMgYSBuZXcgbGV4Y2lhbCBlbGVtZW50IHRvIHdyYXAgdGhlIHRvLWJlLXdyYXBwZWQgbm9kZSBhbmQgcmV0dXJucyBpdC5cbiAqIEByZXR1cm5zIEEgbmV3IGxleGNpYWwgZWxlbWVudCB3aXRoIHRoZSBwcmV2aW91cyBub2RlIGFwcGVuZGVkIHdpdGhpbiAoYXMgYSBjaGlsZCwgaW5jbHVkaW5nIGl0cyBjaGlsZHJlbikuXG4gKi9cblxuZnVuY3Rpb24gJHdyYXBOb2RlSW5FbGVtZW50KG5vZGUsIGNyZWF0ZUVsZW1lbnROb2RlKSB7XG4gIGNvbnN0IGVsZW1lbnROb2RlID0gY3JlYXRlRWxlbWVudE5vZGUoKTtcbiAgbm9kZS5yZXBsYWNlKGVsZW1lbnROb2RlKTtcbiAgZWxlbWVudE5vZGUuYXBwZW5kKG5vZGUpO1xuICByZXR1cm4gZWxlbWVudE5vZGU7XG59XG4vKipcbiAqIEBwYXJhbSB4IC0gVGhlIGVsZW1lbnQgYmVpbmcgdGVzdGVkXG4gKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgeCBpcyBhbiBIVE1MIGFuY2hvciB0YWcsIGZhbHNlIG90aGVyd2lzZVxuICovXG5cbmZ1bmN0aW9uIGlzSFRNTEFuY2hvckVsZW1lbnQoeCkge1xuICByZXR1cm4gaXNIVE1MRWxlbWVudCh4KSAmJiB4LnRhZ05hbWUgPT09ICdBJztcbn1cbi8qKlxuICogQHBhcmFtIHggLSBUaGUgZWxlbWVudCBiZWluZyB0ZXN0aW5nXG4gKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgeCBpcyBhbiBIVE1MIGVsZW1lbnQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHgpIHtcbiAgLy8gQHRzLWlnbm9yZS1uZXh0LWxpbmUgLSBzdHJpY3QgY2hlY2sgb24gbm9kZVR5cGUgaGVyZSBzaG91bGQgZmlsdGVyIG91dCBub24tRWxlbWVudCBFdmVudFRhcmdldCBpbXBsZW1lbnRvcnNcbiAgcmV0dXJuIHgubm9kZVR5cGUgPT09IDE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbi8qKlxuICogQHBhcmFtIG9iamVjdCA9IFRoZSBpbnN0YW5jZSBvZiB0aGUgdHlwZVxuICogQHBhcmFtIG9iamVjdENsYXNzID0gVGhlIGNsYXNzIG9mIHRoZSB0eXBlXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBvYmplY3QgaXMgaGFzIHRoZSBzYW1lIEtsYXNzIG9mIHRoZSBvYmplY3RDbGFzcywgaWdub3JpbmcgdGhlIGRpZmZlcmVuY2UgYWNyb3NzIHdpbmRvdyAoZS5nLiBkaWZmZXJlbnQgaWZyYW1zKVxuICovXG5mdW5jdGlvbiBvYmplY3RLbGFzc0VxdWFscyhvYmplY3QsIG9iamVjdENsYXNzKSB7XG4gIHJldHVybiBvYmplY3QgIT09IG51bGwgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KS5jb25zdHJ1Y3Rvci5uYW1lID09PSBvYmplY3RDbGFzcy5uYW1lIDogZmFsc2U7XG59XG5cbmV4cG9ydHMuJHNwbGl0Tm9kZSA9IGxleGljYWwuJHNwbGl0Tm9kZTtcbmV4cG9ydHMuJGRmcyA9ICRkZnM7XG5leHBvcnRzLiRmaW5kTWF0Y2hpbmdQYXJlbnQgPSAkZmluZE1hdGNoaW5nUGFyZW50O1xuZXhwb3J0cy4kZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdyA9ICRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93O1xuZXhwb3J0cy4kZ2V0TmVhcmVzdE5vZGVPZlR5cGUgPSAkZ2V0TmVhcmVzdE5vZGVPZlR5cGU7XG5leHBvcnRzLiRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdCA9ICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdDtcbmV4cG9ydHMuJHJlc3RvcmVFZGl0b3JTdGF0ZSA9ICRyZXN0b3JlRWRpdG9yU3RhdGU7XG5leHBvcnRzLiR3cmFwTm9kZUluRWxlbWVudCA9ICR3cmFwTm9kZUluRWxlbWVudDtcbmV4cG9ydHMuYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCA9IGFkZENsYXNzTmFtZXNUb0VsZW1lbnQ7XG5leHBvcnRzLmlzSFRNTEFuY2hvckVsZW1lbnQgPSBpc0hUTUxBbmNob3JFbGVtZW50O1xuZXhwb3J0cy5pc0hUTUxFbGVtZW50ID0gaXNIVE1MRWxlbWVudDtcbmV4cG9ydHMuaXNNaW1lVHlwZSA9IGlzTWltZVR5cGU7XG5leHBvcnRzLm1lZGlhRmlsZVJlYWRlciA9IG1lZGlhRmlsZVJlYWRlcjtcbmV4cG9ydHMubWVyZ2VSZWdpc3RlciA9IG1lcmdlUmVnaXN0ZXI7XG5leHBvcnRzLm9iamVjdEtsYXNzRXF1YWxzID0gb2JqZWN0S2xhc3NFcXVhbHM7XG5leHBvcnRzLnJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyID0gcmVnaXN0ZXJOZXN0ZWRFbGVtZW50UmVzb2x2ZXI7XG5leHBvcnRzLnJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudCA9IHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/utils/LexicalUtils.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalUtils =  true ? __webpack_require__(/*! ./LexicalUtils.dev.js */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.js\") : 0\nmodule.exports = LexicalUtils;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1oscUJBQXFCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxzRkFBdUIsSUFBSSxDQUFpQztBQUNsSSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3V0aWxzL0xleGljYWxVdGlscy5qcz8zMmVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsVXRpbHMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFV0aWxzLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsVXRpbHMucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxVdGlsczsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\n");

/***/ })

};
;