"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical";
exports.ids = ["vendor-chunks/@lexical"];
exports.modules = {

/***/ "(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.dev.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar html = __webpack_require__(/*! @lexical/html */ \"(ssr)/./node_modules/@lexical/html/LexicalHtml.js\");\nvar selection = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $getHtmlContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n\n  return html.$generateHtmlFromNodes(editor, selection);\n} // TODO 0.6.0 Return a blank string instead\n// TODO 0.6.0 Rename to $getJSON\n\nfunction $getLexicalContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain');\n\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch {// Fail silently.\n    }\n  }\n\n  const htmlString = dataTransfer.getData('text/html');\n\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = html.$generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch {// Fail silently.\n    }\n  } // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n\n\n  const text = dataTransfer.getData('text/plain');\n\n  if (text != null) {\n    if (lexical.$isRangeSelection(selection)) {\n      const lines = text.split(/\\r?\\n/);\n      const linesLength = lines.length;\n\n      for (let i = 0; i < linesLength; i++) {\n        selection.insertText(lines[i]);\n\n        if (i < linesLength - 1) {\n          selection.insertParagraph();\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\n    return;\n  }\n\n  $basicInsertStrategy(nodes, selection);\n  return;\n}\n\nfunction $basicInsertStrategy(nodes, selection) {\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n  const topLevelBlocks = [];\n  let currentBlock = null;\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = lexical.$isLineBreakNode(node);\n\n    if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        topLevelBlocks.push(currentBlock); // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      topLevelBlocks.push(node);\n      currentBlock = null;\n    }\n  }\n\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(topLevelBlocks);\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n\n    anchorCell.append(...topLevelBlocks);\n  }\n}\n\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\n\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const newGridRowNode = newGridRows[newRowIdx];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n\n    newRowIdx++;\n  }\n\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n\n  const serializedChildren = serializedNode.children;\n\n  if (lexical.$isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n\n  return serializedNode;\n}\n\nfunction $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target); // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n\n  if (lexical.$isTextNode(target)) {\n    const text = target.__text; // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n\n  return shouldInclude;\n} // TODO why $ function with Editor instance?\n\n\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = lexical.$parseSerializedNode(serializedNode);\n\n    if (lexical.$isTextNode(node)) {\n      selection.$addNodeStyle(node);\n    }\n\n    nodes.push(node);\n  }\n\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null; // TODO custom selection\n// TODO potentially have a node customizable version for plain text\n\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n\n  const rootElement = editor.getRootElement();\n  const domSelection = document.getSelection();\n\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n\n  const element = document.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(document.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical.COPY_COMMAND, secondEvent => {\n      if (secondEvent instanceof ClipboardEvent) {\n        removeListener();\n\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      } // Block the entire copy flow while we wait for the next ClipboardEvent\n\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL); // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    document.execCommand('copy');\n    element.remove();\n  });\n} // TODO shouldn't pass editor (pass namespace directly)\n\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = window.getSelection();\n\n  if (!domSelection) {\n    return false;\n  }\n\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n\n  if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = lexical.$getSelection();\n\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\n\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\nexports.$getHtmlContent = $getHtmlContent;\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.$insertGeneratedNodes = $insertGeneratedNodes;\nexports.copyToClipboard = copyToClipboard;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY2xpcGJvYXJkL0xleGljYWxDbGlwYm9hcmQuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyx3RUFBZTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyx1RkFBb0I7QUFDNUMsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNwQyxjQUFjLG1CQUFPLENBQUMsd0RBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE9BQU87QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsVUFBVTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixVQUFVO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsNkJBQTZCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxLQUFLLHNDQUFzQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0Qyx5Q0FBeUM7QUFDekMsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQix1Q0FBdUM7QUFDdkMsc0NBQXNDO0FBQ3RDLDZCQUE2QjtBQUM3Qix1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jbGlwYm9hcmQvTGV4aWNhbENsaXBib2FyZC5kZXYuanM/NGJjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGh0bWwgPSByZXF1aXJlKCdAbGV4aWNhbC9odG1sJyk7XG52YXIgc2VsZWN0aW9uID0gcmVxdWlyZSgnQGxleGljYWwvc2VsZWN0aW9uJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uICRnZXRIdG1sQ29udGVudChlZGl0b3IpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKHNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHZhbGlkIExleGljYWxTZWxlY3Rpb25gKTtcbiAgICB9XG4gIH0gLy8gSWYgd2UgaGF2ZW4ndCBzZWxlY3RlZCBhbnl0aGluZ1xuXG5cbiAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCBzZWxlY3Rpb24uZ2V0Tm9kZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gaHRtbC4kZ2VuZXJhdGVIdG1sRnJvbU5vZGVzKGVkaXRvciwgc2VsZWN0aW9uKTtcbn0gLy8gVE9ETyAwLjYuMCBSZXR1cm4gYSBibGFuayBzdHJpbmcgaW5zdGVhZFxuLy8gVE9ETyAwLjYuMCBSZW5hbWUgdG8gJGdldEpTT05cblxuZnVuY3Rpb24gJGdldExleGljYWxDb250ZW50KGVkaXRvcikge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoc2VsZWN0aW9uID09IG51bGwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdmFsaWQgTGV4aWNhbFNlbGVjdGlvbmApO1xuICAgIH1cbiAgfSAvLyBJZiB3ZSBoYXZlbid0IHNlbGVjdGVkIGFueXRoaW5nXG5cblxuICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IHNlbGVjdGlvbi5nZXROb2RlcygpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2RlcyhlZGl0b3IsIHNlbGVjdGlvbikpO1xufVxuZnVuY3Rpb24gJGluc2VydERhdGFUcmFuc2ZlckZvclBsYWluVGV4dChkYXRhVHJhbnNmZXIsIHNlbGVjdGlvbikge1xuICBjb25zdCB0ZXh0ID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblxuICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgc2VsZWN0aW9uLmluc2VydFJhd1RleHQodGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dChkYXRhVHJhbnNmZXIsIHNlbGVjdGlvbiwgZWRpdG9yKSB7XG4gIGNvbnN0IGxleGljYWxTdHJpbmcgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgnYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvcicpO1xuXG4gIGlmIChsZXhpY2FsU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGxleGljYWxTdHJpbmcpO1xuXG4gICAgICBpZiAocGF5bG9hZC5uYW1lc3BhY2UgPT09IGVkaXRvci5fY29uZmlnLm5hbWVzcGFjZSAmJiBBcnJheS5pc0FycmF5KHBheWxvYWQubm9kZXMpKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gJGdlbmVyYXRlTm9kZXNGcm9tU2VyaWFsaXplZE5vZGVzKHBheWxvYWQubm9kZXMpO1xuICAgICAgICByZXR1cm4gJGluc2VydEdlbmVyYXRlZE5vZGVzKGVkaXRvciwgbm9kZXMsIHNlbGVjdGlvbik7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7Ly8gRmFpbCBzaWxlbnRseS5cbiAgICB9XG4gIH1cblxuICBjb25zdCBodG1sU3RyaW5nID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvaHRtbCcpO1xuXG4gIGlmIChodG1sU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgIGNvbnN0IGRvbSA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoaHRtbFN0cmluZywgJ3RleHQvaHRtbCcpO1xuICAgICAgY29uc3Qgbm9kZXMgPSBodG1sLiRnZW5lcmF0ZU5vZGVzRnJvbURPTShlZGl0b3IsIGRvbSk7XG4gICAgICByZXR1cm4gJGluc2VydEdlbmVyYXRlZE5vZGVzKGVkaXRvciwgbm9kZXMsIHNlbGVjdGlvbik7XG4gICAgfSBjYXRjaCB7Ly8gRmFpbCBzaWxlbnRseS5cbiAgICB9XG4gIH0gLy8gTXVsdGktbGluZSBwbGFpbiB0ZXh0IGluIHJpY2ggdGV4dCBtb2RlIHBhc3RlZCBhcyBzZXBhcmF0ZSBwYXJhZ3JhcGhzXG4gIC8vIGluc3RlYWQgb2Ygc2luZ2xlIHBhcmFncmFwaCB3aXRoIGxpbmVicmVha3MuXG5cblxuICBjb25zdCB0ZXh0ID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblxuICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHI/XFxuLyk7XG4gICAgICBjb25zdCBsaW5lc0xlbmd0aCA9IGxpbmVzLmxlbmd0aDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGVjdGlvbi5pbnNlcnRUZXh0KGxpbmVzW2ldKTtcblxuICAgICAgICBpZiAoaSA8IGxpbmVzTGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHNlbGVjdGlvbi5pbnNlcnRQYXJhZ3JhcGgoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dCh0ZXh0KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRpbnNlcnRHZW5lcmF0ZWROb2RlcyhlZGl0b3IsIG5vZGVzLCBzZWxlY3Rpb24pIHtcbiAgY29uc3QgaXNTZWxlY3Rpb25JbnNpZGVPZkdyaWQgPSBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZShuKSkgIT09IG51bGwgJiYgdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpLCBuID0+IGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkQ2VsbE5vZGUobikpICE9PSBudWxsO1xuXG4gIGlmIChpc1NlbGVjdGlvbkluc2lkZU9mR3JpZCAmJiBub2Rlcy5sZW5ndGggPT09IDEgJiYgbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWROb2RlKG5vZGVzWzBdKSkge1xuICAgICRtZXJnZUdyaWROb2Rlc1N0cmF0ZWd5KG5vZGVzLCBzZWxlY3Rpb24sIGZhbHNlLCBlZGl0b3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gICRiYXNpY0luc2VydFN0cmF0ZWd5KG5vZGVzLCBzZWxlY3Rpb24pO1xuICByZXR1cm47XG59XG5cbmZ1bmN0aW9uICRiYXNpY0luc2VydFN0cmF0ZWd5KG5vZGVzLCBzZWxlY3Rpb24pIHtcbiAgLy8gV3JhcCB0ZXh0IGFuZCBpbmxpbmUgbm9kZXMgaW4gcGFyYWdyYXBoIG5vZGVzIHNvIHdlIGhhdmUgYWxsIGJsb2NrcyBhdCB0aGUgdG9wLWxldmVsXG4gIGNvbnN0IHRvcExldmVsQmxvY2tzID0gW107XG4gIGxldCBjdXJyZW50QmxvY2sgPSBudWxsO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgY29uc3QgaXNMaW5lQnJlYWtOb2RlID0gbGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGUpO1xuXG4gICAgaWYgKGlzTGluZUJyZWFrTm9kZSB8fCBsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpIHx8IGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpIHx8IGxleGljYWwuJGlzVGV4dE5vZGUobm9kZSkgfHwgbm9kZS5pc1BhcmVudFJlcXVpcmVkKCkpIHtcbiAgICAgIGlmIChjdXJyZW50QmxvY2sgPT09IG51bGwpIHtcbiAgICAgICAgY3VycmVudEJsb2NrID0gbm9kZS5jcmVhdGVQYXJlbnRFbGVtZW50Tm9kZSgpO1xuICAgICAgICB0b3BMZXZlbEJsb2Nrcy5wdXNoKGN1cnJlbnRCbG9jayk7IC8vIEluIHRoZSBjYXNlIG9mIExpbmVCcmVha05vZGUsIHdlIGp1c3QgbmVlZCB0b1xuICAgICAgICAvLyBhZGQgYW4gZW1wdHkgUGFyYWdyYXBoTm9kZSB0byB0aGUgdG9wTGV2ZWxCbG9ja3MuXG5cbiAgICAgICAgaWYgKGlzTGluZUJyZWFrTm9kZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50QmxvY2sgIT09IG51bGwpIHtcbiAgICAgICAgY3VycmVudEJsb2NrLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdG9wTGV2ZWxCbG9ja3MucHVzaChub2RlKTtcbiAgICAgIGN1cnJlbnRCbG9jayA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHNlbGVjdGlvbi5pbnNlcnROb2Rlcyh0b3BMZXZlbEJsb2Nrcyk7XG4gIH0gZWxzZSBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIC8vIElmIHRoZXJlJ3MgYW4gYWN0aXZlIGdyaWQgc2VsZWN0aW9uIGFuZCBhIG5vbiBncmlkIGlzIHBhc3RlZCwgYWRkIHRvIHRoZSBhbmNob3IuXG4gICAgY29uc3QgYW5jaG9yQ2VsbCA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuXG4gICAgaWYgKCFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZENlbGxOb2RlKGFuY2hvckNlbGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBHcmlkIENlbGwgaW4gR3JpZCBTZWxlY3Rpb25gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhbmNob3JDZWxsLmFwcGVuZCguLi50b3BMZXZlbEJsb2Nrcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gJG1lcmdlR3JpZE5vZGVzU3RyYXRlZ3kobm9kZXMsIHNlbGVjdGlvbiwgaXNGcm9tTGV4aWNhbCwgZWRpdG9yKSB7XG4gIGlmIChub2Rlcy5sZW5ndGggIT09IDEgfHwgIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkTm9kZShub2Rlc1swXSkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgJG1lcmdlR3JpZE5vZGVzU3RyYXRlZ3k6IEV4cGVjdGVkIEdyaWQgaW5zZXJ0aW9uLmApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5ld0dyaWQgPSBub2Rlc1swXTtcbiAgY29uc3QgbmV3R3JpZFJvd3MgPSBuZXdHcmlkLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IG5ld0NvbHVtbkNvdW50ID0gbmV3R3JpZC5nZXRGaXJzdENoaWxkT3JUaHJvdygpLmdldENoaWxkcmVuU2l6ZSgpO1xuICBjb25zdCBuZXdSb3dDb3VudCA9IG5ld0dyaWQuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gIGNvbnN0IGdyaWRDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZShuKSk7XG4gIGNvbnN0IGdyaWRSb3dOb2RlID0gZ3JpZENlbGxOb2RlICYmIHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoZ3JpZENlbGxOb2RlLCBuID0+IGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkUm93Tm9kZShuKSk7XG4gIGNvbnN0IGdyaWROb2RlID0gZ3JpZFJvd05vZGUgJiYgdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChncmlkUm93Tm9kZSwgbiA9PiBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZE5vZGUobikpO1xuXG4gIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZShncmlkQ2VsbE5vZGUpIHx8ICFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFJvd05vZGUoZ3JpZFJvd05vZGUpIHx8ICFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZE5vZGUoZ3JpZE5vZGUpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYCRtZXJnZUdyaWROb2Rlc1N0cmF0ZWd5OiBFeHBlY3RlZCBzZWxlY3Rpb24gdG8gYmUgaW5zaWRlIG9mIGEgR3JpZC5gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdGFydFkgPSBncmlkUm93Tm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICBjb25zdCBzdG9wWSA9IE1hdGgubWluKGdyaWROb2RlLmdldENoaWxkcmVuU2l6ZSgpIC0gMSwgc3RhcnRZICsgbmV3Um93Q291bnQgLSAxKTtcbiAgY29uc3Qgc3RhcnRYID0gZ3JpZENlbGxOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gIGNvbnN0IHN0b3BYID0gTWF0aC5taW4oZ3JpZFJvd05vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgLSAxLCBzdGFydFggKyBuZXdDb2x1bW5Db3VudCAtIDEpO1xuICBjb25zdCBmcm9tWCA9IE1hdGgubWluKHN0YXJ0WCwgc3RvcFgpO1xuICBjb25zdCBmcm9tWSA9IE1hdGgubWluKHN0YXJ0WSwgc3RvcFkpO1xuICBjb25zdCB0b1ggPSBNYXRoLm1heChzdGFydFgsIHN0b3BYKTtcbiAgY29uc3QgdG9ZID0gTWF0aC5tYXgoc3RhcnRZLCBzdG9wWSk7XG4gIGNvbnN0IGdyaWRSb3dOb2RlcyA9IGdyaWROb2RlLmdldENoaWxkcmVuKCk7XG4gIGxldCBuZXdSb3dJZHggPSAwO1xuICBsZXQgbmV3QW5jaG9yQ2VsbEtleTtcbiAgbGV0IG5ld0ZvY3VzQ2VsbEtleTtcblxuICBmb3IgKGxldCByID0gZnJvbVk7IHIgPD0gdG9ZOyByKyspIHtcbiAgICBjb25zdCBjdXJyZW50R3JpZFJvd05vZGUgPSBncmlkUm93Tm9kZXNbcl07XG5cbiAgICBpZiAoIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkUm93Tm9kZShjdXJyZW50R3JpZFJvd05vZGUpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBnZXROb2RlczogZXhwZWN0ZWQgdG8gZmluZCBHcmlkUm93Tm9kZWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG5ld0dyaWRSb3dOb2RlID0gbmV3R3JpZFJvd3NbbmV3Um93SWR4XTtcblxuICAgIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlKG5ld0dyaWRSb3dOb2RlKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgZ2V0Tm9kZXM6IGV4cGVjdGVkIHRvIGZpbmQgR3JpZFJvd05vZGVgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBncmlkQ2VsbE5vZGVzID0gY3VycmVudEdyaWRSb3dOb2RlLmdldENoaWxkcmVuKCk7XG4gICAgY29uc3QgbmV3R3JpZENlbGxOb2RlcyA9IG5ld0dyaWRSb3dOb2RlLmdldENoaWxkcmVuKCk7XG4gICAgbGV0IG5ld0NvbHVtbklkeCA9IDA7XG5cbiAgICBmb3IgKGxldCBjID0gZnJvbVg7IGMgPD0gdG9YOyBjKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRHcmlkQ2VsbE5vZGUgPSBncmlkQ2VsbE5vZGVzW2NdO1xuXG4gICAgICBpZiAoIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkQ2VsbE5vZGUoY3VycmVudEdyaWRDZWxsTm9kZSkpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKGBnZXROb2RlczogZXhwZWN0ZWQgdG8gZmluZCBHcmlkQ2VsbE5vZGVgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdHcmlkQ2VsbE5vZGUgPSBuZXdHcmlkQ2VsbE5vZGVzW25ld0NvbHVtbklkeF07XG5cbiAgICAgIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZShuZXdHcmlkQ2VsbE5vZGUpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgZ2V0Tm9kZXM6IGV4cGVjdGVkIHRvIGZpbmQgR3JpZENlbGxOb2RlYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHIgPT09IGZyb21ZICYmIGMgPT09IGZyb21YKSB7XG4gICAgICAgIG5ld0FuY2hvckNlbGxLZXkgPSBjdXJyZW50R3JpZENlbGxOb2RlLmdldEtleSgpO1xuICAgICAgfSBlbHNlIGlmIChyID09PSB0b1kgJiYgYyA9PT0gdG9YKSB7XG4gICAgICAgIG5ld0ZvY3VzQ2VsbEtleSA9IGN1cnJlbnRHcmlkQ2VsbE5vZGUuZ2V0S2V5KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9yaWdpbmFsQ2hpbGRyZW4gPSBjdXJyZW50R3JpZENlbGxOb2RlLmdldENoaWxkcmVuKCk7XG4gICAgICBuZXdHcmlkQ2VsbE5vZGUuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgY3VycmVudEdyaWRDZWxsTm9kZS5hcHBlbmQoY2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRHcmlkQ2VsbE5vZGUuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvcmlnaW5hbENoaWxkcmVuLmZvckVhY2gobiA9PiBuLnJlbW92ZSgpKTtcbiAgICAgIG5ld0NvbHVtbklkeCsrO1xuICAgIH1cblxuICAgIG5ld1Jvd0lkeCsrO1xuICB9XG5cbiAgaWYgKG5ld0FuY2hvckNlbGxLZXkgJiYgbmV3Rm9jdXNDZWxsS2V5KSB7XG4gICAgY29uc3QgbmV3R3JpZFNlbGVjdGlvbiA9IGxleGljYWwuREVQUkVDQVRFRF8kY3JlYXRlR3JpZFNlbGVjdGlvbigpO1xuICAgIG5ld0dyaWRTZWxlY3Rpb24uc2V0KGdyaWROb2RlLmdldEtleSgpLCBuZXdBbmNob3JDZWxsS2V5LCBuZXdGb2N1c0NlbGxLZXkpO1xuICAgIGxleGljYWwuJHNldFNlbGVjdGlvbihuZXdHcmlkU2VsZWN0aW9uKTtcbiAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cG9ydE5vZGVUb0pTT04obm9kZSkge1xuICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IG5vZGUuZXhwb3J0SlNPTigpO1xuICBjb25zdCBub2RlQ2xhc3MgPSBub2RlLmNvbnN0cnVjdG9yOyAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gUmVwbGFjZSBDbGFzcyB1dGlsaXR5IHR5cGUgd2l0aCBJbnN0YW5jZVR5cGVcblxuICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSAhPT0gbm9kZUNsYXNzLmdldFR5cGUoKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsTm9kZTogTm9kZSAke25vZGVDbGFzcy5uYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgLmV4cG9ydEpTT04oKS5gKTtcbiAgICB9XG4gIH0gLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPIFJlcGxhY2UgQ2xhc3MgdXRpbGl0eSB0eXBlIHdpdGggSW5zdGFuY2VUeXBlXG5cblxuICBjb25zdCBzZXJpYWxpemVkQ2hpbGRyZW4gPSBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbjtcblxuICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzZXJpYWxpemVkQ2hpbGRyZW4pKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsTm9kZTogTm9kZSAke25vZGVDbGFzcy5uYW1lfSBpcyBhbiBlbGVtZW50IGJ1dCAuZXhwb3J0SlNPTigpIGRvZXMgbm90IGhhdmUgYSBjaGlsZHJlbiBhcnJheS5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VyaWFsaXplZE5vZGU7XG59XG5cbmZ1bmN0aW9uICRhcHBlbmROb2Rlc1RvSlNPTihlZGl0b3IsIHNlbGVjdGlvbiQxLCBjdXJyZW50Tm9kZSwgdGFyZ2V0QXJyYXkgPSBbXSkge1xuICBsZXQgc2hvdWxkSW5jbHVkZSA9IHNlbGVjdGlvbiQxICE9IG51bGwgPyBjdXJyZW50Tm9kZS5pc1NlbGVjdGVkKHNlbGVjdGlvbiQxKSA6IHRydWU7XG4gIGNvbnN0IHNob3VsZEV4Y2x1ZGUgPSBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBjdXJyZW50Tm9kZS5leGNsdWRlRnJvbUNvcHkoJ2h0bWwnKTtcbiAgbGV0IHRhcmdldCA9IGN1cnJlbnROb2RlO1xuXG4gIGlmIChzZWxlY3Rpb24kMSAhPT0gbnVsbCkge1xuICAgIGxldCBjbG9uZSA9IHNlbGVjdGlvbi4kY2xvbmVXaXRoUHJvcGVydGllcyhjdXJyZW50Tm9kZSk7XG4gICAgY2xvbmUgPSBsZXhpY2FsLiRpc1RleHROb2RlKGNsb25lKSAmJiBzZWxlY3Rpb24kMSAhPSBudWxsID8gc2VsZWN0aW9uLiRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50KHNlbGVjdGlvbiQxLCBjbG9uZSkgOiBjbG9uZTtcbiAgICB0YXJnZXQgPSBjbG9uZTtcbiAgfVxuXG4gIGNvbnN0IGNoaWxkcmVuID0gbGV4aWNhbC4kaXNFbGVtZW50Tm9kZSh0YXJnZXQpID8gdGFyZ2V0LmdldENoaWxkcmVuKCkgOiBbXTtcbiAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBleHBvcnROb2RlVG9KU09OKHRhcmdldCk7IC8vIFRPRE86IFRleHROb2RlIGNhbGxzIGdldFRleHRDb250ZW50KCkgKE5PVCBub2RlLl9fdGV4dCkgd2l0aGluIGl0J3MgZXhwb3J0SlNPTiBtZXRob2RcbiAgLy8gd2hpY2ggdXNlcyBnZXRMYXRlc3QoKSB0byBnZXQgdGhlIHRleHQgZnJvbSB0aGUgb3JpZ2luYWwgbm9kZSB3aXRoIHRoZSBzYW1lIGtleS5cbiAgLy8gVGhpcyBpcyBhIGRlZXBlciBpc3N1ZSB3aXRoIHRoZSB3b3JkIFwiY2xvbmVcIiBoZXJlLCBpdCdzIHN0aWxsIGEgcmVmZXJlbmNlIHRvIHRoZVxuICAvLyBzYW1lIG5vZGUgYXMgZmFyIGFzIHRoZSBMZXhpY2FsRWRpdG9yIGlzIGNvbmNlcm5lZCBzaW5jZSBpdCBzaGFyZXMgYSBrZXkuXG4gIC8vIFdlIG5lZWQgYSB3YXkgdG8gY3JlYXRlIGEgY2xvbmUgb2YgYSBOb2RlIGluIG1lbW9yeSB3aXRoIGl0J3Mgb3duIGtleSwgYnV0XG4gIC8vIHVudGlsIHRoZW4gdGhpcyBoYWNrIHdpbGwgd29yayBmb3IgdGhlIHNlbGVjdGVkIHRleHQgZXh0cmFjdCB1c2UgY2FzZS5cblxuICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZSh0YXJnZXQpKSB7XG4gICAgY29uc3QgdGV4dCA9IHRhcmdldC5fX3RleHQ7IC8vIElmIGFuIHVuY29sbGFwc2VkIHNlbGVjdGlvbiBlbmRzIG9yIHN0YXJ0cyBhdCB0aGUgZW5kIG9mIGEgbGluZSBvZiBzcGVjaWFsaXplZCxcbiAgICAvLyBUZXh0Tm9kZXMsIHN1Y2ggYXMgY29kZSB0b2tlbnMsIHdlIHdpbGwgZ2V0IGEgJ2JsYW5rJyBUZXh0Tm9kZSBoZXJlLCBpLmUuLCBvbmVcbiAgICAvLyB3aXRoIHRleHQgb2YgbGVuZ3RoIDAuIFdlIGRvbid0IHdhbnQgdGhpcywgaXQgbWFrZXMgYSBjb25mdXNpbmcgbWVzcy4gUmVzZXQhXG5cbiAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICBzZXJpYWxpemVkTm9kZS50ZXh0ID0gdGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkSW5jbHVkZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBzaG91bGRJbmNsdWRlQ2hpbGQgPSAkYXBwZW5kTm9kZXNUb0pTT04oZWRpdG9yLCBzZWxlY3Rpb24kMSwgY2hpbGROb2RlLCBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbik7XG5cbiAgICBpZiAoIXNob3VsZEluY2x1ZGUgJiYgbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgc2hvdWxkSW5jbHVkZUNoaWxkICYmIGN1cnJlbnROb2RlLmV4dHJhY3RXaXRoQ2hpbGQoY2hpbGROb2RlLCBzZWxlY3Rpb24kMSwgJ2Nsb25lJykpIHtcbiAgICAgIHNob3VsZEluY2x1ZGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzaG91bGRJbmNsdWRlICYmICFzaG91bGRFeGNsdWRlKSB7XG4gICAgdGFyZ2V0QXJyYXkucHVzaChzZXJpYWxpemVkTm9kZSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZXJpYWxpemVkTm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGROb2RlID0gc2VyaWFsaXplZE5vZGUuY2hpbGRyZW5baV07XG4gICAgICB0YXJnZXRBcnJheS5wdXNoKHNlcmlhbGl6ZWRDaGlsZE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzaG91bGRJbmNsdWRlO1xufSAvLyBUT0RPIHdoeSAkIGZ1bmN0aW9uIHdpdGggRWRpdG9yIGluc3RhbmNlP1xuXG5cbmZ1bmN0aW9uICRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2RlcyhlZGl0b3IsIHNlbGVjdGlvbikge1xuICBjb25zdCBub2RlcyA9IFtdO1xuICBjb25zdCByb290ID0gbGV4aWNhbC4kZ2V0Um9vdCgpO1xuICBjb25zdCB0b3BMZXZlbENoaWxkcmVuID0gcm9vdC5nZXRDaGlsZHJlbigpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9wTGV2ZWxDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvcExldmVsTm9kZSA9IHRvcExldmVsQ2hpbGRyZW5baV07XG4gICAgJGFwcGVuZE5vZGVzVG9KU09OKGVkaXRvciwgc2VsZWN0aW9uLCB0b3BMZXZlbE5vZGUsIG5vZGVzKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZXNwYWNlOiBlZGl0b3IuX2NvbmZpZy5uYW1lc3BhY2UsXG4gICAgbm9kZXNcbiAgfTtcbn1cbmZ1bmN0aW9uICRnZW5lcmF0ZU5vZGVzRnJvbVNlcmlhbGl6ZWROb2RlcyhzZXJpYWxpemVkTm9kZXMpIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcmlhbGl6ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplZE5vZGVzW2ldO1xuICAgIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRwYXJzZVNlcmlhbGl6ZWROb2RlKHNlcmlhbGl6ZWROb2RlKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICBzZWxlY3Rpb24uJGFkZE5vZGVTdHlsZShub2RlKTtcbiAgICB9XG5cbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVzO1xufVxuY29uc3QgRVZFTlRfTEFURU5DWSA9IDUwO1xubGV0IGNsaXBib2FyZEV2ZW50VGltZW91dCA9IG51bGw7IC8vIFRPRE8gY3VzdG9tIHNlbGVjdGlvblxuLy8gVE9ETyBwb3RlbnRpYWxseSBoYXZlIGEgbm9kZSBjdXN0b21pemFibGUgdmVyc2lvbiBmb3IgcGxhaW4gdGV4dFxuXG5hc3luYyBmdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQoZWRpdG9yLCBldmVudCkge1xuICBpZiAoY2xpcGJvYXJkRXZlbnRUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgLy8gUHJldmVudCB3ZWlyZCByYWNlIGNvbmRpdGlvbnMgdGhhdCBjYW4gaGFwcGVuIHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBydW4gbXVsdGlwbGUgdGltZXNcbiAgICAvLyBzeW5jaHJvbm91c2x5LiBJbiB0aGUgZnV0dXJlLCB3ZSBjYW4gZG8gYmV0dGVyLCB3ZSBjYW4gY2FuY2VsL292ZXJyaWRlIHRoZSBwcmV2aW91c2x5IHJ1bm5pbmcgam9iLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChldmVudCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZSgkY29weVRvQ2xpcGJvYXJkRXZlbnQoZWRpdG9yLCBldmVudCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAocm9vdEVsZW1lbnQgPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOiBmaXhlZDsgdG9wOiAtMTAwMHB4Oyc7XG4gIGVsZW1lbnQuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcjJykpO1xuICByb290RWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KGVsZW1lbnQsIDApO1xuICByYW5nZS5zZXRFbmQoZWxlbWVudCwgMSk7XG4gIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgZG9tU2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZW1vdmVMaXN0ZW5lciA9IGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5DT1BZX0NPTU1BTkQsIHNlY29uZEV2ZW50ID0+IHtcbiAgICAgIGlmIChzZWNvbmRFdmVudCBpbnN0YW5jZW9mIENsaXBib2FyZEV2ZW50KSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG5cbiAgICAgICAgaWYgKGNsaXBib2FyZEV2ZW50VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoY2xpcGJvYXJkRXZlbnRUaW1lb3V0KTtcbiAgICAgICAgICBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZSgkY29weVRvQ2xpcGJvYXJkRXZlbnQoZWRpdG9yLCBzZWNvbmRFdmVudCkpO1xuICAgICAgfSAvLyBCbG9jayB0aGUgZW50aXJlIGNvcHkgZmxvdyB3aGlsZSB3ZSB3YWl0IGZvciB0aGUgbmV4dCBDbGlwYm9hcmRFdmVudFxuXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCk7IC8vIElmIHRoZSBhYm92ZSBoYWNrIGV4ZWNDb21tYW5kIGhhY2sgd29ya3MsIHRoaXMgdGltZW91dCBjb2RlIHNob3VsZCBuZXZlciBmaXJlLiBPdGhlcndpc2UsXG4gICAgLy8gdGhlIGxpc3RlbmVyIHdpbGwgYmUgcXVpY2tseSBmcmVlZCBzbyB0aGF0IHRoZSB1c2VyIGNhbiByZXVzZSBpdCBhZ2FpblxuXG4gICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgIGNsaXBib2FyZEV2ZW50VGltZW91dCA9IG51bGw7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICB9LCBFVkVOVF9MQVRFTkNZKTtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gIH0pO1xufSAvLyBUT0RPIHNob3VsZG4ndCBwYXNzIGVkaXRvciAocGFzcyBuYW1lc3BhY2UgZGlyZWN0bHkpXG5cbmZ1bmN0aW9uICRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIGV2ZW50KSB7XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIWRvbVNlbGVjdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvckRPTSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICBjb25zdCBmb2N1c0RPTSA9IGRvbVNlbGVjdGlvbi5mb2N1c05vZGU7XG5cbiAgaWYgKGFuY2hvckRPTSAhPT0gbnVsbCAmJiBmb2N1c0RPTSAhPT0gbnVsbCAmJiAhbGV4aWNhbC5pc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmIChjbGlwYm9hcmREYXRhID09PSBudWxsIHx8IHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGh0bWxTdHJpbmcgPSAkZ2V0SHRtbENvbnRlbnQoZWRpdG9yKTtcbiAgY29uc3QgbGV4aWNhbFN0cmluZyA9ICRnZXRMZXhpY2FsQ29udGVudChlZGl0b3IpO1xuICBsZXQgcGxhaW5TdHJpbmcgPSAnJztcblxuICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgcGxhaW5TdHJpbmcgPSBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKTtcbiAgfVxuXG4gIGlmIChodG1sU3RyaW5nICE9PSBudWxsKSB7XG4gICAgY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L2h0bWwnLCBodG1sU3RyaW5nKTtcbiAgfVxuXG4gIGlmIChsZXhpY2FsU3RyaW5nICE9PSBudWxsKSB7XG4gICAgY2xpcGJvYXJkRGF0YS5zZXREYXRhKCdhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yJywgbGV4aWNhbFN0cmluZyk7XG4gIH1cblxuICBjbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCBwbGFpblN0cmluZyk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnRzLiRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2RlcyA9ICRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2RlcztcbmV4cG9ydHMuJGdlbmVyYXRlTm9kZXNGcm9tU2VyaWFsaXplZE5vZGVzID0gJGdlbmVyYXRlTm9kZXNGcm9tU2VyaWFsaXplZE5vZGVzO1xuZXhwb3J0cy4kZ2V0SHRtbENvbnRlbnQgPSAkZ2V0SHRtbENvbnRlbnQ7XG5leHBvcnRzLiRnZXRMZXhpY2FsQ29udGVudCA9ICRnZXRMZXhpY2FsQ29udGVudDtcbmV4cG9ydHMuJGluc2VydERhdGFUcmFuc2ZlckZvclBsYWluVGV4dCA9ICRpbnNlcnREYXRhVHJhbnNmZXJGb3JQbGFpblRleHQ7XG5leHBvcnRzLiRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dCA9ICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dDtcbmV4cG9ydHMuJGluc2VydEdlbmVyYXRlZE5vZGVzID0gJGluc2VydEdlbmVyYXRlZE5vZGVzO1xuZXhwb3J0cy5jb3B5VG9DbGlwYm9hcmQgPSBjb3B5VG9DbGlwYm9hcmQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalClipboard =  true ? __webpack_require__(/*! ./LexicalClipboard.dev.js */ \"(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.dev.js\") : 0\nmodule.exports = LexicalClipboard;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY2xpcGJvYXJkL0xleGljYWxDbGlwYm9hcmQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWix5QkFBeUIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLGtHQUEyQixJQUFJLENBQXFDO0FBQzlJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY2xpcGJvYXJkL0xleGljYWxDbGlwYm9hcmQuanM/OTk4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbENsaXBib2FyZCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsQ2xpcGJvYXJkLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsQ2xpcGJvYXJkLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsQ2xpcGJvYXJkOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/code/LexicalCode.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/code/LexicalCode.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar Prism = __webpack_require__(/*! prismjs */ \"(ssr)/./node_modules/prismjs/prism.js\");\n__webpack_require__(/*! prismjs/components/prism-clike */ \"(ssr)/./node_modules/prismjs/components/prism-clike.js\");\n__webpack_require__(/*! prismjs/components/prism-javascript */ \"(ssr)/./node_modules/prismjs/components/prism-javascript.js\");\n__webpack_require__(/*! prismjs/components/prism-markup */ \"(ssr)/./node_modules/prismjs/components/prism-markup.js\");\n__webpack_require__(/*! prismjs/components/prism-markdown */ \"(ssr)/./node_modules/prismjs/components/prism-markdown.js\");\n__webpack_require__(/*! prismjs/components/prism-c */ \"(ssr)/./node_modules/prismjs/components/prism-c.js\");\n__webpack_require__(/*! prismjs/components/prism-css */ \"(ssr)/./node_modules/prismjs/components/prism-css.js\");\n__webpack_require__(/*! prismjs/components/prism-objectivec */ \"(ssr)/./node_modules/prismjs/components/prism-objectivec.js\");\n__webpack_require__(/*! prismjs/components/prism-sql */ \"(ssr)/./node_modules/prismjs/components/prism-sql.js\");\n__webpack_require__(/*! prismjs/components/prism-python */ \"(ssr)/./node_modules/prismjs/components/prism-python.js\");\n__webpack_require__(/*! prismjs/components/prism-rust */ \"(ssr)/./node_modules/prismjs/components/prism-rust.js\");\n__webpack_require__(/*! prismjs/components/prism-swift */ \"(ssr)/./node_modules/prismjs/components/prism-swift.js\");\n__webpack_require__(/*! prismjs/components/prism-typescript */ \"(ssr)/./node_modules/prismjs/components/prism-typescript.js\");\n__webpack_require__(/*! prismjs/components/prism-java */ \"(ssr)/./node_modules/prismjs/components/prism-java.js\");\n__webpack_require__(/*! prismjs/components/prism-cpp */ \"(ssr)/./node_modules/prismjs/components/prism-cpp.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mapToPrismLanguage = language => {\n  // eslint-disable-next-line no-prototype-builtins\n  return language != null && Prism.languages.hasOwnProperty(language) ? language : undefined;\n};\n\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if (utils.isHTMLElement(child) && child.tagName === tagName) {\n      return true;\n    }\n\n    hasChildDOMNodeTag(child, tagName);\n  }\n\n  return false;\n}\n\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n/** @noInheritDoc */\n\nclass CodeNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'code';\n  }\n\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n\n  constructor(language, key) {\n    super(key);\n    this.__language = mapToPrismLanguage(language);\n  } // View\n\n\n  createDOM(config) {\n    const element = document.createElement('code');\n    utils.addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n    }\n\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: node => ({\n        conversion: convertDivElement,\n        priority: 1\n      }),\n      pre: node => ({\n        conversion: convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node; // domNode is a <table> since we matched it by nodeName\n\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: convertTableElement,\n            priority: 3\n          };\n        }\n\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n\n        if (isGitHubCodeCell(td)) {\n          return {\n            conversion: convertTableCellElement,\n            priority: 3\n          };\n        }\n\n        if (table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n\n        return null;\n      }\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createCodeNode(serializedNode.language);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      language: this.getLanguage(),\n      type: 'code',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = lexical.$createParagraphNode();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    } // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n\n\n    const anchor = selection.anchor.getNode();\n    const firstNode = getFirstCodeHighlightNodeOfLine(anchor);\n\n    if (firstNode != null) {\n      let leadingWhitespace = 0;\n      const firstNodeText = firstNode.getTextContent();\n\n      while (leadingWhitespace < firstNodeText.length && /[\\t ]/.test(firstNodeText[leadingWhitespace])) {\n        leadingWhitespace += 1;\n      }\n\n      if (leadingWhitespace > 0) {\n        const whitespace = firstNodeText.substring(0, leadingWhitespace);\n        const indentedChild = $createCodeHighlightNode(whitespace);\n        anchor.insertAfter(indentedChild);\n        selection.insertNodes([lexical.$createLineBreakNode()]);\n        indentedChild.select();\n        return indentedChild;\n      }\n    }\n\n    return null;\n  }\n\n  canInsertTab() {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return false;\n    }\n\n    return true;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = mapToPrismLanguage(language);\n  }\n\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n\n}\nfunction $createCodeNode(language) {\n  return lexical.$applyNodeReplacement(new CodeNode(language));\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\n\nfunction convertPreElement(domNode) {\n  return {\n    node: $createCodeNode(),\n    preformatted: true\n  };\n}\n\nfunction convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n\n  return {\n    after: childLexicalNodes => {\n      const domParent = domNode.parentNode;\n\n      if (domParent != null && domNode !== domParent.lastChild) {\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n\n      return childLexicalNodes;\n    },\n    node: isCode ? $createCodeNode() : null,\n    preformatted: isCode\n  };\n}\n\nfunction convertTableElement() {\n  return {\n    node: $createCodeNode(),\n    preformatted: true\n  };\n}\n\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\n\nfunction convertTableCellElement(domNode) {\n  // domNode is a <td> since we matched it by nodeName\n  const cell = domNode;\n  return {\n    after: childLexicalNodes => {\n      if (cell.parentNode && cell.parentNode.nextSibling) {\n        // Append newline between code lines\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n\n      return childLexicalNodes;\n    },\n    node: null\n  };\n}\n\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\n\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n\n    parent = parent.parentElement;\n  }\n\n  return false;\n}\n\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\n\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(Prism.languages).filter( // Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism.languages[language] !== 'function').sort();\n/** @noInheritDoc */\n\nclass CodeHighlightNode extends lexical.TextNode {\n  /** @internal */\n  constructor(text, highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n\n  static getType() {\n    return 'code-highlight';\n  }\n\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    utils.addClassNamesToElement(element, className);\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        utils.removeClassNamesFromElement(dom, prevClassName);\n      }\n\n      if (nextClassName) {\n        utils.addClassNamesToElement(dom, nextClassName);\n      }\n    }\n\n    return update;\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      highlightType: this.getHighlightType(),\n      type: 'code-highlight',\n      version: 1\n    };\n  } // Prevent formatting (bold, underline, etc)\n\n\n  setFormat(format) {\n    return this;\n  }\n\n  isParentRequired() {\n    return true;\n  }\n\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n\n}\n\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\n\nfunction $createCodeHighlightNode(text, highlightType) {\n  return lexical.$applyNodeReplacement(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction getFirstCodeHighlightNodeOfLine(anchor) {\n  let currentNode = null;\n  const previousSiblings = anchor.getPreviousSiblings();\n  previousSiblings.push(anchor);\n\n  while (previousSiblings.length > 0) {\n    const node = previousSiblings.pop();\n\n    if ($isCodeHighlightNode(node)) {\n      currentNode = node;\n    }\n\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n\n  return currentNode;\n}\nfunction getLastCodeHighlightNodeOfLine(anchor) {\n  let currentNode = null;\n  const nextSiblings = anchor.getNextSiblings();\n  nextSiblings.unshift(anchor);\n\n  while (nextSiblings.length > 0) {\n    const node = nextSiblings.shift();\n\n    if ($isCodeHighlightNode(node)) {\n      currentNode = node;\n    }\n\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n\n  return currentNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PrismTokenizer = {\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n\n  tokenize(code, language) {\n    return Prism.tokenize(code, Prism.languages[language || ''] || Prism.languages[this.defaultLanguage]);\n  }\n\n};\n\nfunction isSpaceOrTabChar(char) {\n  return char === ' ' || char === '\\t';\n}\n\nfunction findFirstNotSpaceOrTabCharAtText(text, isForward) {\n  const length = text.length;\n  let offset = -1;\n\n  if (isForward) {\n    for (let i = 0; i < length; i++) {\n      const char = text[i];\n\n      if (!isSpaceOrTabChar(char)) {\n        offset = i;\n        break;\n      }\n    }\n  } else {\n    for (let i = length - 1; i > -1; i--) {\n      const char = text[i];\n\n      if (!isSpaceOrTabChar(char)) {\n        offset = i;\n        break;\n      }\n    }\n  }\n\n  return offset;\n}\n\nfunction getStartOfCodeInLine(anchor) {\n  let currentNode = null;\n  let currentNodeOffset = -1;\n  const previousSiblings = anchor.getPreviousSiblings();\n  previousSiblings.push(anchor);\n\n  while (previousSiblings.length > 0) {\n    const node = previousSiblings.pop();\n\n    if ($isCodeHighlightNode(node)) {\n      const text = node.getTextContent();\n      const offset = findFirstNotSpaceOrTabCharAtText(text, true);\n\n      if (offset !== -1) {\n        currentNode = node;\n        currentNodeOffset = offset;\n      }\n    }\n\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n\n  if (currentNode === null) {\n    const nextSiblings = anchor.getNextSiblings();\n\n    while (nextSiblings.length > 0) {\n      const node = nextSiblings.shift();\n\n      if ($isCodeHighlightNode(node)) {\n        const text = node.getTextContent();\n        const offset = findFirstNotSpaceOrTabCharAtText(text, true);\n\n        if (offset !== -1) {\n          currentNode = node;\n          currentNodeOffset = offset;\n          break;\n        }\n      }\n\n      if (lexical.$isLineBreakNode(node)) {\n        break;\n      }\n    }\n  }\n\n  return {\n    node: currentNode,\n    offset: currentNodeOffset\n  };\n}\nfunction getEndOfCodeInLine(anchor) {\n  let currentNode = null;\n  let currentNodeOffset = -1;\n  const nextSiblings = anchor.getNextSiblings();\n  nextSiblings.unshift(anchor);\n\n  while (nextSiblings.length > 0) {\n    const node = nextSiblings.shift();\n\n    if ($isCodeHighlightNode(node)) {\n      const text = node.getTextContent();\n      const offset = findFirstNotSpaceOrTabCharAtText(text, false);\n\n      if (offset !== -1) {\n        currentNode = node;\n        currentNodeOffset = offset + 1;\n      }\n    }\n\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n\n  if (currentNode === null) {\n    const previousSiblings = anchor.getPreviousSiblings();\n\n    while (previousSiblings.length > 0) {\n      const node = previousSiblings.pop();\n\n      if ($isCodeHighlightNode(node)) {\n        const text = node.getTextContent();\n        const offset = findFirstNotSpaceOrTabCharAtText(text, false);\n\n        if (offset !== -1) {\n          currentNode = node;\n          currentNodeOffset = offset + 1;\n          break;\n        }\n      }\n\n      if (lexical.$isLineBreakNode(node)) {\n        break;\n      }\n    }\n  }\n\n  return {\n    node: currentNode,\n    offset: currentNodeOffset\n  };\n}\n\nfunction textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace(lexical.$createTextNode(node.__text));\n  }\n}\n\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n\n  if (codeElement === null) {\n    return;\n  }\n\n  const children = node.getChildren();\n  const childrenLength = children.length; // @ts-ignore: internal field\n\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  } // @ts-ignore:: internal field\n\n\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n\n  for (let i = 0; i < childrenLength; i++) {\n    if (lexical.$isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n\n  codeElement.setAttribute('data-gutter', gutter);\n} // Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\n\nconst nodesCurrentlyHighlighting = new Set();\n\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n\n  if (nodesCurrentlyHighlighting.has(nodeKey)) {\n    return;\n  }\n\n  nodesCurrentlyHighlighting.add(nodeKey); // When new code block inserted it might not have language selected\n\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  } // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual codehighlight node to be transformed again as it's already\n  // in its final state\n\n\n  editor.update(() => {\n    updateAndRetainSelection(nodeKey, () => {\n      const currentNode = lexical.$getNodeByKey(nodeKey);\n\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n\n      const code = currentNode.getTextContent();\n      const tokens = tokenizer.tokenize(code, currentNode.getLanguage() || tokenizer.defaultLanguage);\n      const highlightNodes = getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(nodeKey);\n    },\n    skipTransforms: true\n  });\n}\n\nfunction getHighlightNodes(tokens) {\n  const nodes = [];\n  tokens.forEach(token => {\n    if (typeof token === 'string') {\n      const partials = token.split('\\n');\n\n      for (let i = 0; i < partials.length; i++) {\n        const text = partials[i];\n\n        if (text.length) {\n          nodes.push($createCodeHighlightNode(text));\n        }\n\n        if (i < partials.length - 1) {\n          nodes.push(lexical.$createLineBreakNode());\n        }\n      }\n    } else {\n      const {\n        content\n      } = token;\n\n      if (typeof content === 'string') {\n        nodes.push($createCodeHighlightNode(content, token.type));\n      } else if (Array.isArray(content) && content.length === 1 && typeof content[0] === 'string') {\n        nodes.push($createCodeHighlightNode(content[0], token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...getHighlightNodes(content));\n      }\n    }\n  });\n  return nodes;\n} // Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\n\n\nfunction updateAndRetainSelection(nodeKey, updateFn) {\n  const node = lexical.$getNodeByKey(nodeKey);\n\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n\n  const selection = lexical.$getSelection(); // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n\n  if (!lexical.$isRangeSelection(selection)) {\n    updateFn();\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && lexical.$isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0; // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n\n  const hasChanges = updateFn();\n\n  if (!hasChanges) {\n    return;\n  } // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n\n\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  } // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n\n\n  node.getChildren().some(_node => {\n    const isText = lexical.$isTextNode(_node);\n\n    if (isText || lexical.$isLineBreakNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n\n        return true;\n      }\n\n      textOffset -= textContentSize;\n    }\n\n    return false;\n  });\n} // Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\n\n\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n\n    leadingMatch++;\n  }\n\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\n\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code higlight nodes and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  if ($isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB)) {\n    return nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType;\n  }\n\n  if (lexical.$isLineBreakNode(nodeA) && lexical.$isLineBreakNode(nodeB)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleMultilineIndent(type) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || selection.isCollapsed()) {\n    return false;\n  } // Only run multiline indent logic on selections exclusively composed of code highlights and linebreaks\n\n\n  const nodes = selection.getNodes();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {\n      return false;\n    }\n  }\n\n  const startOfLine = getFirstCodeHighlightNodeOfLine(nodes[0]);\n\n  if (startOfLine != null) {\n    doIndent(startOfLine, type);\n  }\n\n  for (let i = 1; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isLineBreakNode(nodes[i - 1]) && $isCodeHighlightNode(node)) {\n      doIndent(node, type);\n    }\n  }\n\n  return true;\n}\n\nfunction doIndent(node, type) {\n  const text = node.getTextContent();\n\n  if (type === lexical.INDENT_CONTENT_COMMAND) {\n    // If the codeblock node doesn't start with whitespace, we don't want to\n    // naively prepend a '\\t'; Prism will then mangle all of our nodes when\n    // it separates the whitespace from the first non-whitespace node. This\n    // will lead to selection bugs when indenting lines that previously\n    // didn't start with a whitespace character\n    if (text.length > 0 && /\\s/.test(text[0])) {\n      node.setTextContent('\\t' + text);\n    } else {\n      const indentNode = $createCodeHighlightNode('\\t');\n      node.insertBefore(indentNode);\n    }\n  } else {\n    if (text.indexOf('\\t') === 0) {\n      // Same as above - if we leave empty text nodes lying around, the resulting\n      // selection will be mangled\n      if (text.length === 1) {\n        node.remove();\n      } else {\n        node.setTextContent(text.substring(1));\n      }\n    }\n  }\n}\n\nfunction handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  } // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === lexical.KEY_ARROW_UP_COMMAND; // Ensure the selection is within the codeblock\n\n  if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {\n    return false;\n  }\n\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // sibling thats can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  const start = getFirstCodeHighlightNodeOfLine(anchorNode);\n  const end = getLastCodeHighlightNodeOfLine(focusNode);\n\n  if (start == null || end == null) {\n    return false;\n  }\n\n  const range = start.getNodesBetween(end);\n\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n\n    if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {\n      return false;\n    }\n  } // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n\n\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n\n  if (!lexical.$isLineBreakNode(linebreak)) {\n    return true;\n  }\n\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n\n  if (sibling == null) {\n    return true;\n  }\n\n  const maybeInsertionPoint = arrowIsUp ? getFirstCodeHighlightNodeOfLine(sibling) : getLastCodeHighlightNodeOfLine(sibling);\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n\n  if (type === lexical.KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\n\nfunction handleMoveTo(type, event) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === lexical.MOVE_TO_START;\n\n  if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {\n    return false;\n  }\n\n  let node;\n  let offset;\n\n  if (isMoveToStart) {\n    ({\n      node,\n      offset\n    } = getStartOfCodeInLine(focusNode));\n  } else {\n    ({\n      node,\n      offset\n    } = getEndOfCodeInLine(focusNode));\n  }\n\n  if (node !== null && offset !== -1) {\n    selection.setTextNodeRange(node, offset, node, offset);\n  }\n\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\n\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n\n  return utils.mergeRegister(editor.registerMutationListener(CodeNode, mutations => {\n    editor.update(() => {\n      for (const [key, type] of mutations) {\n        if (type !== 'destroyed') {\n          const node = lexical.$getNodeByKey(key);\n\n          if (node !== null) {\n            updateCodeGutter(node, editor);\n          }\n        }\n      }\n    });\n  }), editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(lexical.TextNode, node => textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => textNodeTransform(node, editor, tokenizer)), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.INDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.OUTDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_UP_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_DOWN_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_END, payload => handleMoveTo(lexical.MOVE_TO_END, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_START, payload => handleMoveTo(lexical.MOVE_TO_START, payload), lexical.COMMAND_PRIORITY_LOW));\n}\n\nexports.$createCodeHighlightNode = $createCodeHighlightNode;\nexports.$createCodeNode = $createCodeNode;\nexports.$isCodeHighlightNode = $isCodeHighlightNode;\nexports.$isCodeNode = $isCodeNode;\nexports.CODE_LANGUAGE_FRIENDLY_NAME_MAP = CODE_LANGUAGE_FRIENDLY_NAME_MAP;\nexports.CODE_LANGUAGE_MAP = CODE_LANGUAGE_MAP;\nexports.CodeHighlightNode = CodeHighlightNode;\nexports.CodeNode = CodeNode;\nexports.DEFAULT_CODE_LANGUAGE = DEFAULT_CODE_LANGUAGE;\nexports.PrismTokenizer = PrismTokenizer;\nexports.getCodeLanguages = getCodeLanguages;\nexports.getDefaultCodeLanguage = getDefaultCodeLanguage;\nexports.getEndOfCodeInLine = getEndOfCodeInLine;\nexports.getFirstCodeHighlightNodeOfLine = getFirstCodeHighlightNodeOfLine;\nexports.getLanguageFriendlyName = getLanguageFriendlyName;\nexports.getLastCodeHighlightNodeOfLine = getLastCodeHighlightNodeOfLine;\nexports.getStartOfCodeInLine = getStartOfCodeInLine;\nexports.normalizeCodeLang = normalizeCodeLang;\nexports.registerCodeHighlighting = registerCodeHighlighting;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY29kZS9MZXhpY2FsQ29kZS5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHNEQUFTO0FBQzdCLG1CQUFPLENBQUMsOEZBQWdDO0FBQ3hDLG1CQUFPLENBQUMsd0dBQXFDO0FBQzdDLG1CQUFPLENBQUMsZ0dBQWlDO0FBQ3pDLG1CQUFPLENBQUMsb0dBQW1DO0FBQzNDLG1CQUFPLENBQUMsc0ZBQTRCO0FBQ3BDLG1CQUFPLENBQUMsMEZBQThCO0FBQ3RDLG1CQUFPLENBQUMsd0dBQXFDO0FBQzdDLG1CQUFPLENBQUMsMEZBQThCO0FBQ3RDLG1CQUFPLENBQUMsZ0dBQWlDO0FBQ3pDLG1CQUFPLENBQUMsNEZBQStCO0FBQ3ZDLG1CQUFPLENBQUMsOEZBQWdDO0FBQ3hDLG1CQUFPLENBQUMsd0dBQXFDO0FBQzdDLG1CQUFPLENBQUMsNEZBQStCO0FBQ3ZDLG1CQUFPLENBQUMsMEZBQThCO0FBQ3RDLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLHdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNkJBQTZCLFFBQVE7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHFCQUFxQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7OztBQUdBO0FBQ0EsMkJBQTJCOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIsNEJBQTRCO0FBQzVCLG1CQUFtQjtBQUNuQix1Q0FBdUM7QUFDdkMseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QixnQkFBZ0I7QUFDaEIsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQix1Q0FBdUM7QUFDdkMsK0JBQStCO0FBQy9CLHNDQUFzQztBQUN0Qyw0QkFBNEI7QUFDNUIseUJBQXlCO0FBQ3pCLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2NvZGUvTGV4aWNhbENvZGUuZGV2LmpzPzA5ODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQcmlzbSA9IHJlcXVpcmUoJ3ByaXNtanMnKTtcbnJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jbGlrZScpO1xucmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWphdmFzY3JpcHQnKTtcbnJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1tYXJrdXAnKTtcbnJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1tYXJrZG93bicpO1xucmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWMnKTtcbnJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jc3MnKTtcbnJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1vYmplY3RpdmVjJyk7XG5yZXF1aXJlKCdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tc3FsJyk7XG5yZXF1aXJlKCdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tcHl0aG9uJyk7XG5yZXF1aXJlKCdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tcnVzdCcpO1xucmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXN3aWZ0Jyk7XG5yZXF1aXJlKCdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tdHlwZXNjcmlwdCcpO1xucmVxdWlyZSgncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWphdmEnKTtcbnJlcXVpcmUoJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jcHAnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBtYXBUb1ByaXNtTGFuZ3VhZ2UgPSBsYW5ndWFnZSA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgcmV0dXJuIGxhbmd1YWdlICE9IG51bGwgJiYgUHJpc20ubGFuZ3VhZ2VzLmhhc093blByb3BlcnR5KGxhbmd1YWdlKSA/IGxhbmd1YWdlIDogdW5kZWZpbmVkO1xufTtcblxuZnVuY3Rpb24gaGFzQ2hpbGRET01Ob2RlVGFnKG5vZGUsIHRhZ05hbWUpIHtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkTm9kZXMpIHtcbiAgICBpZiAodXRpbHMuaXNIVE1MRWxlbWVudChjaGlsZCkgJiYgY2hpbGQudGFnTmFtZSA9PT0gdGFnTmFtZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaGFzQ2hpbGRET01Ob2RlVGFnKGNoaWxkLCB0YWdOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgTEFOR1VBR0VfREFUQV9BVFRSSUJVVEUgPSAnZGF0YS1oaWdobGlnaHQtbGFuZ3VhZ2UnO1xuLyoqIEBub0luaGVyaXREb2MgKi9cblxuY2xhc3MgQ29kZU5vZGUgZXh0ZW5kcyBsZXhpY2FsLkVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2NvZGUnO1xuICB9XG5cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IENvZGVOb2RlKG5vZGUuX19sYW5ndWFnZSwgbm9kZS5fX2tleSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihsYW5ndWFnZSwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fbGFuZ3VhZ2UgPSBtYXBUb1ByaXNtTGFuZ3VhZ2UobGFuZ3VhZ2UpO1xuICB9IC8vIFZpZXdcblxuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29kZScpO1xuICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLmNvZGUpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgJ2ZhbHNlJyk7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSB0aGlzLmdldExhbmd1YWdlKCk7XG5cbiAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKExBTkdVQUdFX0RBVEFfQVRUUklCVVRFLCBsYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSB0aGlzLl9fbGFuZ3VhZ2U7XG4gICAgY29uc3QgcHJldkxhbmd1YWdlID0gcHJldk5vZGUuX19sYW5ndWFnZTtcblxuICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgaWYgKGxhbmd1YWdlICE9PSBwcmV2TGFuZ3VhZ2UpIHtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShMQU5HVUFHRV9EQVRBX0FUVFJJQlVURSwgbGFuZ3VhZ2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldkxhbmd1YWdlKSB7XG4gICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKExBTkdVQUdFX0RBVEFfQVRUUklCVVRFKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBUeXBpY2FsbHkgPHByZT4gaXMgdXNlZCBmb3IgY29kZSBibG9ja3MsIGFuZCA8Y29kZT4gZm9yIGlubGluZSBjb2RlIHN0eWxlc1xuICAgICAgLy8gYnV0IGlmIGl0J3MgYSBtdWx0aSBsaW5lIDxjb2RlPiB3ZSdsbCBjcmVhdGUgYSBibG9jay4gUGFzcyB0aHJvdWdoIHRvXG4gICAgICAvLyBpbmxpbmUgZm9ybWF0IGhhbmRsZWQgYnkgVGV4dE5vZGUgb3RoZXJ3aXNlLlxuICAgICAgY29kZTogbm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IGlzTXVsdGlMaW5lID0gbm9kZS50ZXh0Q29udGVudCAhPSBudWxsICYmICgvXFxyP1xcbi8udGVzdChub2RlLnRleHRDb250ZW50KSB8fCBoYXNDaGlsZERPTU5vZGVUYWcobm9kZSwgJ0JSJykpO1xuICAgICAgICByZXR1cm4gaXNNdWx0aUxpbmUgPyB7XG4gICAgICAgICAgY29udmVyc2lvbjogY29udmVydFByZUVsZW1lbnQsXG4gICAgICAgICAgcHJpb3JpdHk6IDFcbiAgICAgICAgfSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgZGl2OiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnREaXZFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMVxuICAgICAgfSksXG4gICAgICBwcmU6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFByZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHRhYmxlOiBub2RlID0+IHtcbiAgICAgICAgY29uc3QgdGFibGUgPSBub2RlOyAvLyBkb21Ob2RlIGlzIGEgPHRhYmxlPiBzaW5jZSB3ZSBtYXRjaGVkIGl0IGJ5IG5vZGVOYW1lXG5cbiAgICAgICAgaWYgKGlzR2l0SHViQ29kZVRhYmxlKHRhYmxlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGFibGVFbGVtZW50LFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgdGQ6IG5vZGUgPT4ge1xuICAgICAgICAvLyBlbGVtZW50IGlzIGEgPHRkPiBzaW5jZSB3ZSBtYXRjaGVkIGl0IGJ5IG5vZGVOYW1lXG4gICAgICAgIGNvbnN0IHRkID0gbm9kZTtcbiAgICAgICAgY29uc3QgdGFibGUgPSB0ZC5jbG9zZXN0KCd0YWJsZScpO1xuXG4gICAgICAgIGlmIChpc0dpdEh1YkNvZGVDZWxsKHRkKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGFibGVDZWxsRWxlbWVudCxcbiAgICAgICAgICAgIHByaW9yaXR5OiAzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YWJsZSAmJiBpc0dpdEh1YkNvZGVUYWJsZSh0YWJsZSkpIHtcbiAgICAgICAgICAvLyBSZXR1cm4gYSBuby1vcCBpZiBpdCdzIGEgdGFibGUgY2VsbCBpbiBhIGNvZGUgdGFibGUsIGJ1dCBub3QgYSBjb2RlIGxpbmUuXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGl0J2xsIGZhbGwgYmFjayB0byB0aGUgVFxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0Q29kZU5vb3AsXG4gICAgICAgICAgICBwcmlvcml0eTogM1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICB0cjogbm9kZSA9PiB7XG4gICAgICAgIC8vIGVsZW1lbnQgaXMgYSA8dHI+IHNpbmNlIHdlIG1hdGNoZWQgaXQgYnkgbm9kZU5hbWVcbiAgICAgICAgY29uc3QgdHIgPSBub2RlO1xuICAgICAgICBjb25zdCB0YWJsZSA9IHRyLmNsb3Nlc3QoJ3RhYmxlJyk7XG5cbiAgICAgICAgaWYgKHRhYmxlICYmIGlzR2l0SHViQ29kZVRhYmxlKHRhYmxlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0Q29kZU5vb3AsXG4gICAgICAgICAgICBwcmlvcml0eTogM1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZUNvZGVOb2RlKHNlcmlhbGl6ZWROb2RlLmxhbmd1YWdlKTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgbGFuZ3VhZ2U6IHRoaXMuZ2V0TGFuZ3VhZ2UoKSxcbiAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9IC8vIE11dGF0aW9uXG5cblxuICBpbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgICBpZiAoY2hpbGRyZW5MZW5ndGggPj0gMiAmJiBjaGlsZHJlbltjaGlsZHJlbkxlbmd0aCAtIDFdLmdldFRleHRDb250ZW50KCkgPT09ICdcXG4nICYmIGNoaWxkcmVuW2NoaWxkcmVuTGVuZ3RoIC0gMl0uZ2V0VGV4dENvbnRlbnQoKSA9PT0gJ1xcbicgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgc2VsZWN0aW9uLmFuY2hvci5rZXkgPT09IHRoaXMuX19rZXkgJiYgc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IGNoaWxkcmVuTGVuZ3RoKSB7XG4gICAgICBjaGlsZHJlbltjaGlsZHJlbkxlbmd0aCAtIDFdLnJlbW92ZSgpO1xuICAgICAgY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAyXS5yZW1vdmUoKTtcbiAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICB0aGlzLmluc2VydEFmdGVyKG5ld0VsZW1lbnQsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gICAgfSAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIHdpdGhpbiB0aGUgY29kZWJsb2NrLCBmaW5kIGFsbCBsZWFkaW5nIHRhYnMgYW5kXG4gICAgLy8gc3BhY2VzIG9mIHRoZSBjdXJyZW50IGxpbmUuIENyZWF0ZSBhIG5ldyBsaW5lIHRoYXQgaGFzIGFsbCB0aG9zZVxuICAgIC8vIHRhYnMgYW5kIHNwYWNlcywgc3VjaCB0aGF0IGxlYWRpbmcgaW5kZW50YXRpb24gaXMgcHJlc2VydmVkLlxuXG5cbiAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmaXJzdE5vZGUgPSBnZXRGaXJzdENvZGVIaWdobGlnaHROb2RlT2ZMaW5lKGFuY2hvcik7XG5cbiAgICBpZiAoZmlyc3ROb2RlICE9IG51bGwpIHtcbiAgICAgIGxldCBsZWFkaW5nV2hpdGVzcGFjZSA9IDA7XG4gICAgICBjb25zdCBmaXJzdE5vZGVUZXh0ID0gZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCk7XG5cbiAgICAgIHdoaWxlIChsZWFkaW5nV2hpdGVzcGFjZSA8IGZpcnN0Tm9kZVRleHQubGVuZ3RoICYmIC9bXFx0IF0vLnRlc3QoZmlyc3ROb2RlVGV4dFtsZWFkaW5nV2hpdGVzcGFjZV0pKSB7XG4gICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZWFkaW5nV2hpdGVzcGFjZSA+IDApIHtcbiAgICAgICAgY29uc3Qgd2hpdGVzcGFjZSA9IGZpcnN0Tm9kZVRleHQuc3Vic3RyaW5nKDAsIGxlYWRpbmdXaGl0ZXNwYWNlKTtcbiAgICAgICAgY29uc3QgaW5kZW50ZWRDaGlsZCA9ICRjcmVhdGVDb2RlSGlnaGxpZ2h0Tm9kZSh3aGl0ZXNwYWNlKTtcbiAgICAgICAgYW5jaG9yLmluc2VydEFmdGVyKGluZGVudGVkQ2hpbGQpO1xuICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0Tm9kZXMoW2xleGljYWwuJGNyZWF0ZUxpbmVCcmVha05vZGUoKV0pO1xuICAgICAgICBpbmRlbnRlZENoaWxkLnNlbGVjdCgpO1xuICAgICAgICByZXR1cm4gaW5kZW50ZWRDaGlsZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNhbkluc2VydFRhYigpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbGxhcHNlQXRTdGFydCgpIHtcbiAgICBjb25zdCBwYXJhZ3JhcGggPSBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBwYXJhZ3JhcGguYXBwZW5kKGNoaWxkKSk7XG4gICAgdGhpcy5yZXBsYWNlKHBhcmFncmFwaCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzZXRMYW5ndWFnZShsYW5ndWFnZSkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fbGFuZ3VhZ2UgPSBtYXBUb1ByaXNtTGFuZ3VhZ2UobGFuZ3VhZ2UpO1xuICB9XG5cbiAgZ2V0TGFuZ3VhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19sYW5ndWFnZTtcbiAgfVxuXG59XG5mdW5jdGlvbiAkY3JlYXRlQ29kZU5vZGUobGFuZ3VhZ2UpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBDb2RlTm9kZShsYW5ndWFnZSkpO1xufVxuZnVuY3Rpb24gJGlzQ29kZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIENvZGVOb2RlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UHJlRWxlbWVudChkb21Ob2RlKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUNvZGVOb2RlKCksXG4gICAgcHJlZm9ybWF0dGVkOiB0cnVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnREaXZFbGVtZW50KGRvbU5vZGUpIHtcbiAgLy8gZG9tTm9kZSBpcyBhIDxkaXY+IHNpbmNlIHdlIG1hdGNoZWQgaXQgYnkgbm9kZU5hbWVcbiAgY29uc3QgZGl2ID0gZG9tTm9kZTtcbiAgY29uc3QgaXNDb2RlID0gaXNDb2RlRWxlbWVudChkaXYpO1xuXG4gIGlmICghaXNDb2RlICYmICFpc0NvZGVDaGlsZEVsZW1lbnQoZGl2KSkge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6IGNoaWxkTGV4aWNhbE5vZGVzID0+IHtcbiAgICAgIGNvbnN0IGRvbVBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcblxuICAgICAgaWYgKGRvbVBhcmVudCAhPSBudWxsICYmIGRvbU5vZGUgIT09IGRvbVBhcmVudC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY2hpbGRMZXhpY2FsTm9kZXMucHVzaChsZXhpY2FsLiRjcmVhdGVMaW5lQnJlYWtOb2RlKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hpbGRMZXhpY2FsTm9kZXM7XG4gICAgfSxcbiAgICBub2RlOiBpc0NvZGUgPyAkY3JlYXRlQ29kZU5vZGUoKSA6IG51bGwsXG4gICAgcHJlZm9ybWF0dGVkOiBpc0NvZGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRhYmxlRWxlbWVudCgpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlQ29kZU5vZGUoKSxcbiAgICBwcmVmb3JtYXR0ZWQ6IHRydWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydENvZGVOb29wKCkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRhYmxlQ2VsbEVsZW1lbnQoZG9tTm9kZSkge1xuICAvLyBkb21Ob2RlIGlzIGEgPHRkPiBzaW5jZSB3ZSBtYXRjaGVkIGl0IGJ5IG5vZGVOYW1lXG4gIGNvbnN0IGNlbGwgPSBkb21Ob2RlO1xuICByZXR1cm4ge1xuICAgIGFmdGVyOiBjaGlsZExleGljYWxOb2RlcyA9PiB7XG4gICAgICBpZiAoY2VsbC5wYXJlbnROb2RlICYmIGNlbGwucGFyZW50Tm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAvLyBBcHBlbmQgbmV3bGluZSBiZXR3ZWVuIGNvZGUgbGluZXNcbiAgICAgICAgY2hpbGRMZXhpY2FsTm9kZXMucHVzaChsZXhpY2FsLiRjcmVhdGVMaW5lQnJlYWtOb2RlKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hpbGRMZXhpY2FsTm9kZXM7XG4gICAgfSxcbiAgICBub2RlOiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQ29kZUVsZW1lbnQoZGl2KSB7XG4gIHJldHVybiBkaXYuc3R5bGUuZm9udEZhbWlseS5tYXRjaCgnbW9ub3NwYWNlJykgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzQ29kZUNoaWxkRWxlbWVudChub2RlKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGlmIChpc0NvZGVFbGVtZW50KHBhcmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0dpdEh1YkNvZGVDZWxsKGNlbGwpIHtcbiAgcmV0dXJuIGNlbGwuY2xhc3NMaXN0LmNvbnRhaW5zKCdqcy1maWxlLWxpbmUnKTtcbn1cblxuZnVuY3Rpb24gaXNHaXRIdWJDb2RlVGFibGUodGFibGUpIHtcbiAgcmV0dXJuIHRhYmxlLmNsYXNzTGlzdC5jb250YWlucygnanMtZmlsZS1saW5lLWNvbnRhaW5lcicpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBERUZBVUxUX0NPREVfTEFOR1VBR0UgPSAnamF2YXNjcmlwdCc7XG5jb25zdCBDT0RFX0xBTkdVQUdFX0ZSSUVORExZX05BTUVfTUFQID0ge1xuICBjOiAnQycsXG4gIGNsaWtlOiAnQy1saWtlJyxcbiAgY3BwOiAnQysrJyxcbiAgY3NzOiAnQ1NTJyxcbiAgaHRtbDogJ0hUTUwnLFxuICBqYXZhOiAnSmF2YScsXG4gIGpzOiAnSmF2YVNjcmlwdCcsXG4gIG1hcmtkb3duOiAnTWFya2Rvd24nLFxuICBvYmpjOiAnT2JqZWN0aXZlLUMnLFxuICBwbGFpbjogJ1BsYWluIFRleHQnLFxuICBweTogJ1B5dGhvbicsXG4gIHJ1c3Q6ICdSdXN0JyxcbiAgc3FsOiAnU1FMJyxcbiAgc3dpZnQ6ICdTd2lmdCcsXG4gIHR5cGVzY3JpcHQ6ICdUeXBlU2NyaXB0JyxcbiAgeG1sOiAnWE1MJ1xufTtcbmNvbnN0IENPREVfTEFOR1VBR0VfTUFQID0ge1xuICBjcHA6ICdjcHAnLFxuICBqYXZhOiAnamF2YScsXG4gIGphdmFzY3JpcHQ6ICdqcycsXG4gIG1kOiAnbWFya2Rvd24nLFxuICBwbGFpbnRleHQ6ICdwbGFpbicsXG4gIHB5dGhvbjogJ3B5JyxcbiAgdGV4dDogJ3BsYWluJyxcbiAgdHM6ICd0eXBlc2NyaXB0J1xufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvZGVMYW5nKGxhbmcpIHtcbiAgcmV0dXJuIENPREVfTEFOR1VBR0VfTUFQW2xhbmddIHx8IGxhbmc7XG59XG5mdW5jdGlvbiBnZXRMYW5ndWFnZUZyaWVuZGx5TmFtZShsYW5nKSB7XG4gIGNvbnN0IF9sYW5nID0gbm9ybWFsaXplQ29kZUxhbmcobGFuZyk7XG5cbiAgcmV0dXJuIENPREVfTEFOR1VBR0VfRlJJRU5ETFlfTkFNRV9NQVBbX2xhbmddIHx8IF9sYW5nO1xufVxuY29uc3QgZ2V0RGVmYXVsdENvZGVMYW5ndWFnZSA9ICgpID0+IERFRkFVTFRfQ09ERV9MQU5HVUFHRTtcbmNvbnN0IGdldENvZGVMYW5ndWFnZXMgPSAoKSA9PiBPYmplY3Qua2V5cyhQcmlzbS5sYW5ndWFnZXMpLmZpbHRlciggLy8gUHJpc20gaGFzIHNldmVyYWwgbGFuZ3VhZ2UgaGVscGVycyBtaXhlZCBpbnRvIGxhbmd1YWdlcyBvYmplY3Rcbi8vIHNvIGZpbHRlcmluZyB0aGVtIG91dCBoZXJlIHRvIGdldCBsYW5ncyBsaXN0XG5sYW5ndWFnZSA9PiB0eXBlb2YgUHJpc20ubGFuZ3VhZ2VzW2xhbmd1YWdlXSAhPT0gJ2Z1bmN0aW9uJykuc29ydCgpO1xuLyoqIEBub0luaGVyaXREb2MgKi9cblxuY2xhc3MgQ29kZUhpZ2hsaWdodE5vZGUgZXh0ZW5kcyBsZXhpY2FsLlRleHROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3Rvcih0ZXh0LCBoaWdobGlnaHRUeXBlLCBrZXkpIHtcbiAgICBzdXBlcih0ZXh0LCBrZXkpO1xuICAgIHRoaXMuX19oaWdobGlnaHRUeXBlID0gaGlnaGxpZ2h0VHlwZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnY29kZS1oaWdobGlnaHQnO1xuICB9XG5cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IENvZGVIaWdobGlnaHROb2RlKG5vZGUuX190ZXh0LCBub2RlLl9faGlnaGxpZ2h0VHlwZSB8fCB1bmRlZmluZWQsIG5vZGUuX19rZXkpO1xuICB9XG5cbiAgZ2V0SGlnaGxpZ2h0VHlwZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2hpZ2hsaWdodFR5cGU7XG4gIH1cblxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHN1cGVyLmNyZWF0ZURPTShjb25maWcpO1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGdldEhpZ2hsaWdodFRoZW1lQ2xhc3MoY29uZmlnLnRoZW1lLCB0aGlzLl9faGlnaGxpZ2h0VHlwZSk7XG4gICAgdXRpbHMuYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHN1cGVyLnVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpO1xuICAgIGNvbnN0IHByZXZDbGFzc05hbWUgPSBnZXRIaWdobGlnaHRUaGVtZUNsYXNzKGNvbmZpZy50aGVtZSwgcHJldk5vZGUuX19oaWdobGlnaHRUeXBlKTtcbiAgICBjb25zdCBuZXh0Q2xhc3NOYW1lID0gZ2V0SGlnaGxpZ2h0VGhlbWVDbGFzcyhjb25maWcudGhlbWUsIHRoaXMuX19oaWdobGlnaHRUeXBlKTtcblxuICAgIGlmIChwcmV2Q2xhc3NOYW1lICE9PSBuZXh0Q2xhc3NOYW1lKSB7XG4gICAgICBpZiAocHJldkNsYXNzTmFtZSkge1xuICAgICAgICB1dGlscy5yZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCBwcmV2Q2xhc3NOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRDbGFzc05hbWUpIHtcbiAgICAgICAgdXRpbHMuYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChkb20sIG5leHRDbGFzc05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGU7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlQ29kZUhpZ2hsaWdodE5vZGUoc2VyaWFsaXplZE5vZGUudGV4dCwgc2VyaWFsaXplZE5vZGUuaGlnaGxpZ2h0VHlwZSk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldERldGFpbChzZXJpYWxpemVkTm9kZS5kZXRhaWwpO1xuICAgIG5vZGUuc2V0TW9kZShzZXJpYWxpemVkTm9kZS5tb2RlKTtcbiAgICBub2RlLnNldFN0eWxlKHNlcmlhbGl6ZWROb2RlLnN0eWxlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgaGlnaGxpZ2h0VHlwZTogdGhpcy5nZXRIaWdobGlnaHRUeXBlKCksXG4gICAgICB0eXBlOiAnY29kZS1oaWdobGlnaHQnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH0gLy8gUHJldmVudCBmb3JtYXR0aW5nIChib2xkLCB1bmRlcmxpbmUsIGV0YylcblxuXG4gIHNldEZvcm1hdChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlzUGFyZW50UmVxdWlyZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjcmVhdGVQYXJlbnRFbGVtZW50Tm9kZSgpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUNvZGVOb2RlKCk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBnZXRIaWdobGlnaHRUaGVtZUNsYXNzKHRoZW1lLCBoaWdobGlnaHRUeXBlKSB7XG4gIHJldHVybiBoaWdobGlnaHRUeXBlICYmIHRoZW1lICYmIHRoZW1lLmNvZGVIaWdobGlnaHQgJiYgdGhlbWUuY29kZUhpZ2hsaWdodFtoaWdobGlnaHRUeXBlXTtcbn1cblxuZnVuY3Rpb24gJGNyZWF0ZUNvZGVIaWdobGlnaHROb2RlKHRleHQsIGhpZ2hsaWdodFR5cGUpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBDb2RlSGlnaGxpZ2h0Tm9kZSh0ZXh0LCBoaWdobGlnaHRUeXBlKSk7XG59XG5mdW5jdGlvbiAkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgQ29kZUhpZ2hsaWdodE5vZGU7XG59XG5mdW5jdGlvbiBnZXRGaXJzdENvZGVIaWdobGlnaHROb2RlT2ZMaW5lKGFuY2hvcikge1xuICBsZXQgY3VycmVudE5vZGUgPSBudWxsO1xuICBjb25zdCBwcmV2aW91c1NpYmxpbmdzID0gYW5jaG9yLmdldFByZXZpb3VzU2libGluZ3MoKTtcbiAgcHJldmlvdXNTaWJsaW5ncy5wdXNoKGFuY2hvcik7XG5cbiAgd2hpbGUgKHByZXZpb3VzU2libGluZ3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IG5vZGUgPSBwcmV2aW91c1NpYmxpbmdzLnBvcCgpO1xuXG4gICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpKSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShub2RlKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnROb2RlO1xufVxuZnVuY3Rpb24gZ2V0TGFzdENvZGVIaWdobGlnaHROb2RlT2ZMaW5lKGFuY2hvcikge1xuICBsZXQgY3VycmVudE5vZGUgPSBudWxsO1xuICBjb25zdCBuZXh0U2libGluZ3MgPSBhbmNob3IuZ2V0TmV4dFNpYmxpbmdzKCk7XG4gIG5leHRTaWJsaW5ncy51bnNoaWZ0KGFuY2hvcik7XG5cbiAgd2hpbGUgKG5leHRTaWJsaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5leHRTaWJsaW5ncy5zaGlmdCgpO1xuXG4gICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpKSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShub2RlKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnROb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBQcmlzbVRva2VuaXplciA9IHtcbiAgZGVmYXVsdExhbmd1YWdlOiBERUZBVUxUX0NPREVfTEFOR1VBR0UsXG5cbiAgdG9rZW5pemUoY29kZSwgbGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4gUHJpc20udG9rZW5pemUoY29kZSwgUHJpc20ubGFuZ3VhZ2VzW2xhbmd1YWdlIHx8ICcnXSB8fCBQcmlzbS5sYW5ndWFnZXNbdGhpcy5kZWZhdWx0TGFuZ3VhZ2VdKTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBpc1NwYWNlT3JUYWJDaGFyKGNoYXIpIHtcbiAgcmV0dXJuIGNoYXIgPT09ICcgJyB8fCBjaGFyID09PSAnXFx0Jztcbn1cblxuZnVuY3Rpb24gZmluZEZpcnN0Tm90U3BhY2VPclRhYkNoYXJBdFRleHQodGV4dCwgaXNGb3J3YXJkKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRleHQubGVuZ3RoO1xuICBsZXQgb2Zmc2V0ID0gLTE7XG5cbiAgaWYgKGlzRm9yd2FyZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXIgPSB0ZXh0W2ldO1xuXG4gICAgICBpZiAoIWlzU3BhY2VPclRhYkNoYXIoY2hhcikpIHtcbiAgICAgICAgb2Zmc2V0ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID4gLTE7IGktLSkge1xuICAgICAgY29uc3QgY2hhciA9IHRleHRbaV07XG5cbiAgICAgIGlmICghaXNTcGFjZU9yVGFiQ2hhcihjaGFyKSkge1xuICAgICAgICBvZmZzZXQgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBnZXRTdGFydE9mQ29kZUluTGluZShhbmNob3IpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gbnVsbDtcbiAgbGV0IGN1cnJlbnROb2RlT2Zmc2V0ID0gLTE7XG4gIGNvbnN0IHByZXZpb3VzU2libGluZ3MgPSBhbmNob3IuZ2V0UHJldmlvdXNTaWJsaW5ncygpO1xuICBwcmV2aW91c1NpYmxpbmdzLnB1c2goYW5jaG9yKTtcblxuICB3aGlsZSAocHJldmlvdXNTaWJsaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgbm9kZSA9IHByZXZpb3VzU2libGluZ3MucG9wKCk7XG5cbiAgICBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBmaW5kRmlyc3ROb3RTcGFjZU9yVGFiQ2hhckF0VGV4dCh0ZXh0LCB0cnVlKTtcblxuICAgICAgaWYgKG9mZnNldCAhPT0gLTEpIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICBjdXJyZW50Tm9kZU9mZnNldCA9IG9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY3VycmVudE5vZGUgPT09IG51bGwpIHtcbiAgICBjb25zdCBuZXh0U2libGluZ3MgPSBhbmNob3IuZ2V0TmV4dFNpYmxpbmdzKCk7XG5cbiAgICB3aGlsZSAobmV4dFNpYmxpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBuZXh0U2libGluZ3Muc2hpZnQoKTtcblxuICAgICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGZpbmRGaXJzdE5vdFNwYWNlT3JUYWJDaGFyQXRUZXh0KHRleHQsIHRydWUpO1xuXG4gICAgICAgIGlmIChvZmZzZXQgIT09IC0xKSB7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICAgIGN1cnJlbnROb2RlT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUobm9kZSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlOiBjdXJyZW50Tm9kZSxcbiAgICBvZmZzZXQ6IGN1cnJlbnROb2RlT2Zmc2V0XG4gIH07XG59XG5mdW5jdGlvbiBnZXRFbmRPZkNvZGVJbkxpbmUoYW5jaG9yKSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IG51bGw7XG4gIGxldCBjdXJyZW50Tm9kZU9mZnNldCA9IC0xO1xuICBjb25zdCBuZXh0U2libGluZ3MgPSBhbmNob3IuZ2V0TmV4dFNpYmxpbmdzKCk7XG4gIG5leHRTaWJsaW5ncy51bnNoaWZ0KGFuY2hvcik7XG5cbiAgd2hpbGUgKG5leHRTaWJsaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5leHRTaWJsaW5ncy5zaGlmdCgpO1xuXG4gICAgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZmluZEZpcnN0Tm90U3BhY2VPclRhYkNoYXJBdFRleHQodGV4dCwgZmFsc2UpO1xuXG4gICAgICBpZiAob2Zmc2V0ICE9PSAtMSkge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgIGN1cnJlbnROb2RlT2Zmc2V0ID0gb2Zmc2V0ICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoY3VycmVudE5vZGUgPT09IG51bGwpIHtcbiAgICBjb25zdCBwcmV2aW91c1NpYmxpbmdzID0gYW5jaG9yLmdldFByZXZpb3VzU2libGluZ3MoKTtcblxuICAgIHdoaWxlIChwcmV2aW91c1NpYmxpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBwcmV2aW91c1NpYmxpbmdzLnBvcCgpO1xuXG4gICAgICBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZmluZEZpcnN0Tm90U3BhY2VPclRhYkNoYXJBdFRleHQodGV4dCwgZmFsc2UpO1xuXG4gICAgICAgIGlmIChvZmZzZXQgIT09IC0xKSB7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSBub2RlO1xuICAgICAgICAgIGN1cnJlbnROb2RlT2Zmc2V0ID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbm9kZTogY3VycmVudE5vZGUsXG4gICAgb2Zmc2V0OiBjdXJyZW50Tm9kZU9mZnNldFxuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0Tm9kZVRyYW5zZm9ybShub2RlLCBlZGl0b3IsIHRva2VuaXplcikge1xuICAvLyBTaW5jZSBDb2RlTm9kZSBoYXMgZmxhdCBjaGlsZHJlbiBzdHJ1Y3R1cmUgd2Ugb25seSBuZWVkIHRvIGNoZWNrXG4gIC8vIGlmIG5vZGUncyBwYXJlbnQgaXMgYSBjb2RlIG5vZGUgYW5kIHJ1biBoaWdobGlnaHRpbmcgaWYgc29cbiAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgaWYgKCRpc0NvZGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgY29kZU5vZGVUcmFuc2Zvcm0ocGFyZW50Tm9kZSwgZWRpdG9yLCB0b2tlbml6ZXIpO1xuICB9IGVsc2UgaWYgKCRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGUpKSB7XG4gICAgLy8gV2hlbiBjb2RlIGJsb2NrIGNvbnZlcnRlZCBpbnRvIHBhcmFncmFwaCBvciBvdGhlciBlbGVtZW50XG4gICAgLy8gY29kZSBoaWdobGlnaHQgbm9kZXMgY29udmVydGVkIGJhY2sgdG8gbm9ybWFsIHRleHRcbiAgICBub2RlLnJlcGxhY2UobGV4aWNhbC4kY3JlYXRlVGV4dE5vZGUobm9kZS5fX3RleHQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb2RlR3V0dGVyKG5vZGUsIGVkaXRvcikge1xuICBjb25zdCBjb2RlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkobm9kZS5nZXRLZXkoKSk7XG5cbiAgaWYgKGNvZGVFbGVtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoOyAvLyBAdHMtaWdub3JlOiBpbnRlcm5hbCBmaWVsZFxuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gY29kZUVsZW1lbnQuX19jYWNoZWRDaGlsZHJlbkxlbmd0aCkge1xuICAgIC8vIEF2b2lkIHVwZGF0aW5nIHRoZSBhdHRyaWJ1dGUgaWYgdGhlIGNoaWxkcmVuIGxlbmd0aCBoYXNuJ3QgY2hhbmdlZC5cbiAgICByZXR1cm47XG4gIH0gLy8gQHRzLWlnbm9yZTo6IGludGVybmFsIGZpZWxkXG5cblxuICBjb2RlRWxlbWVudC5fX2NhY2hlZENoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW5MZW5ndGg7XG4gIGxldCBndXR0ZXIgPSAnMSc7XG4gIGxldCBjb3VudCA9IDE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShjaGlsZHJlbltpXSkpIHtcbiAgICAgIGd1dHRlciArPSAnXFxuJyArICsrY291bnQ7XG4gICAgfVxuICB9XG5cbiAgY29kZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWd1dHRlcicsIGd1dHRlcik7XG59IC8vIFVzaW5nIGBza2lwVHJhbnNmb3Jtc2AgdG8gcHJldmVudCBleHRyYSB0cmFuc2Zvcm1zIHNpbmNlIHJlZm9ybWF0dGluZyB0aGUgY29kZVxuLy8gd2lsbCBub3QgYWZmZWN0IGNvZGUgYmxvY2sgY29udGVudCBpdHNlbGYuXG4vL1xuLy8gVXNpbmcgZXh0cmEgY2FjaGUgKGBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZ2ApIHNpbmNlIGJvdGggQ29kZU5vZGUgYW5kIENvZGVIaWdobGlnaHROb2RlXG4vLyB0cmFuc2Zvcm1zIG1pZ2h0IGJlIGNhbGxlZCBhdCB0aGUgc2FtZSB0aW1lIChlLmcuIG5ldyBDb2RlSGlnaGxpZ2h0IG5vZGUgaW5zZXJ0ZWQpIGFuZFxuLy8gaW4gYm90aCBjYXNlcyB3ZSdsbCByZXJ1biB3aG9sZSByZWZvcm1hdHRpbmcgb3ZlciBDb2RlTm9kZSwgd2hpY2ggaXMgcmVkdW5kYW50LlxuLy8gRXNwZWNpYWxseSB3aGVuIHBhc3RpbmcgY29kZSBpbnRvIENvZGVCbG9jay5cblxuXG5jb25zdCBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZyA9IG5ldyBTZXQoKTtcblxuZnVuY3Rpb24gY29kZU5vZGVUcmFuc2Zvcm0obm9kZSwgZWRpdG9yLCB0b2tlbml6ZXIpIHtcbiAgY29uc3Qgbm9kZUtleSA9IG5vZGUuZ2V0S2V5KCk7XG5cbiAgaWYgKG5vZGVzQ3VycmVudGx5SGlnaGxpZ2h0aW5nLmhhcyhub2RlS2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG5vZGVzQ3VycmVudGx5SGlnaGxpZ2h0aW5nLmFkZChub2RlS2V5KTsgLy8gV2hlbiBuZXcgY29kZSBibG9jayBpbnNlcnRlZCBpdCBtaWdodCBub3QgaGF2ZSBsYW5ndWFnZSBzZWxlY3RlZFxuXG4gIGlmIChub2RlLmdldExhbmd1YWdlKCkgPT09IHVuZGVmaW5lZCkge1xuICAgIG5vZGUuc2V0TGFuZ3VhZ2UodG9rZW5pemVyLmRlZmF1bHRMYW5ndWFnZSk7XG4gIH0gLy8gVXNpbmcgbmVzdGVkIHVwZGF0ZSBjYWxsIHRvIHBhc3MgYHNraXBUcmFuc2Zvcm1zYCBzaW5jZSB3ZSBkb24ndCB3YW50XG4gIC8vIGVhY2ggaW5kaXZpZHVhbCBjb2RlaGlnaGxpZ2h0IG5vZGUgdG8gYmUgdHJhbnNmb3JtZWQgYWdhaW4gYXMgaXQncyBhbHJlYWR5XG4gIC8vIGluIGl0cyBmaW5hbCBzdGF0ZVxuXG5cbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgdXBkYXRlQW5kUmV0YWluU2VsZWN0aW9uKG5vZGVLZXksICgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gbGV4aWNhbC4kZ2V0Tm9kZUJ5S2V5KG5vZGVLZXkpO1xuXG4gICAgICBpZiAoISRpc0NvZGVOb2RlKGN1cnJlbnROb2RlKSB8fCAhY3VycmVudE5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29kZSA9IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZXIudG9rZW5pemUoY29kZSwgY3VycmVudE5vZGUuZ2V0TGFuZ3VhZ2UoKSB8fCB0b2tlbml6ZXIuZGVmYXVsdExhbmd1YWdlKTtcbiAgICAgIGNvbnN0IGhpZ2hsaWdodE5vZGVzID0gZ2V0SGlnaGxpZ2h0Tm9kZXModG9rZW5zKTtcbiAgICAgIGNvbnN0IGRpZmZSYW5nZSA9IGdldERpZmZSYW5nZShjdXJyZW50Tm9kZS5nZXRDaGlsZHJlbigpLCBoaWdobGlnaHROb2Rlcyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgICBub2Rlc0ZvclJlcGxhY2VtZW50XG4gICAgICB9ID0gZGlmZlJhbmdlO1xuXG4gICAgICBpZiAoZnJvbSAhPT0gdG8gfHwgbm9kZXNGb3JSZXBsYWNlbWVudC5sZW5ndGgpIHtcbiAgICAgICAgbm9kZS5zcGxpY2UoZnJvbSwgdG8gLSBmcm9tLCBub2Rlc0ZvclJlcGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfSwge1xuICAgIG9uVXBkYXRlOiAoKSA9PiB7XG4gICAgICBub2Rlc0N1cnJlbnRseUhpZ2hsaWdodGluZy5kZWxldGUobm9kZUtleSk7XG4gICAgfSxcbiAgICBza2lwVHJhbnNmb3JtczogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SGlnaGxpZ2h0Tm9kZXModG9rZW5zKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgcGFydGlhbHMgPSB0b2tlbi5zcGxpdCgnXFxuJyk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGlhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IHBhcnRpYWxzW2ldO1xuXG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZUNvZGVIaWdobGlnaHROb2RlKHRleHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpIDwgcGFydGlhbHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG5vZGVzLnB1c2gobGV4aWNhbC4kY3JlYXRlTGluZUJyZWFrTm9kZSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRlbnRcbiAgICAgIH0gPSB0b2tlbjtcblxuICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVDb2RlSGlnaGxpZ2h0Tm9kZShjb250ZW50LCB0b2tlbi50eXBlKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkgJiYgY29udGVudC5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGNvbnRlbnRbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZUNvZGVIaWdobGlnaHROb2RlKGNvbnRlbnRbMF0sIHRva2VuLnR5cGUpKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb250ZW50KSkge1xuICAgICAgICBub2Rlcy5wdXNoKC4uLmdldEhpZ2hsaWdodE5vZGVzKGNvbnRlbnQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbm9kZXM7XG59IC8vIFdyYXBwaW5nIHVwZGF0ZSBmdW5jdGlvbiBpbnRvIHNlbGVjdGlvbiByZXRhaW5lciwgdGhhdCB0cmllcyB0byBrZWVwIGN1cnNvciBhdCB0aGUgc2FtZVxuLy8gcG9zaXRpb24gYXMgYmVmb3JlLlxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUFuZFJldGFpblNlbGVjdGlvbihub2RlS2V5LCB1cGRhdGVGbikge1xuICBjb25zdCBub2RlID0gbGV4aWNhbC4kZ2V0Tm9kZUJ5S2V5KG5vZGVLZXkpO1xuXG4gIGlmICghJGlzQ29kZU5vZGUobm9kZSkgfHwgIW5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7IC8vIElmIGl0J3Mgbm90IHJhbmdlIHNlbGVjdGlvbiAob3IgbnVsbCBzZWxlY3Rpb24pIHRoZXJlJ3Mgbm8gbmVlZCB0byBjaGFuZ2UgaXQsXG4gIC8vIGJ1dCB3ZSBjYW4gc3RpbGwgcnVuIGhpZ2hsaWdodGluZyBsb2dpY1xuXG4gIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgdXBkYXRlRm4oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBpc05ld0xpbmVBbmNob3IgPSBhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShub2RlLmdldENoaWxkQXRJbmRleChhbmNob3Iub2Zmc2V0IC0gMSkpO1xuICBsZXQgdGV4dE9mZnNldCA9IDA7IC8vIENhbGN1bGF0aW5nIHByZXZpb3VzIHRleHQgb2Zmc2V0IChhbGwgdGV4dCBub2RlIHByaW9yIHRvIGFuY2hvciArIGFuY2hvciBvd24gdGV4dCBvZmZzZXQpXG5cbiAgaWYgKCFpc05ld0xpbmVBbmNob3IpIHtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICB0ZXh0T2Zmc2V0ID0gYW5jaG9yT2Zmc2V0ICsgYW5jaG9yTm9kZS5nZXRQcmV2aW91c1NpYmxpbmdzKCkucmVkdWNlKChvZmZzZXQsIF9ub2RlKSA9PiB7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgX25vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgfSwgMCk7XG4gIH1cblxuICBjb25zdCBoYXNDaGFuZ2VzID0gdXBkYXRlRm4oKTtcblxuICBpZiAoIWhhc0NoYW5nZXMpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gTm9uLXRleHQgYW5jaG9ycyBvbmx5IGhhcHBlbiBmb3IgbGluZSBicmVha3MsIG90aGVyd2lzZVxuICAvLyBzZWxlY3Rpb24gd2lsbCBiZSB3aXRoaW4gdGV4dCBub2RlIChjb2RlIGhpZ2hsaWdodCBub2RlKVxuXG5cbiAgaWYgKGlzTmV3TGluZUFuY2hvcikge1xuICAgIGFuY2hvci5nZXROb2RlKCkuc2VsZWN0KGFuY2hvck9mZnNldCwgYW5jaG9yT2Zmc2V0KTtcbiAgICByZXR1cm47XG4gIH0gLy8gSWYgaXQgd2FzIG5vbi1lbGVtZW50IGFuY2hvciB0aGVuIHdlIHdhbGsgdGhyb3VnaCBjaGlsZCBub2Rlc1xuICAvLyBhbmQgbG9va2luZyBmb3IgYSBwb3NpdGlvbiBvZiBvcmlnaW5hbCB0ZXh0IG9mZnNldFxuXG5cbiAgbm9kZS5nZXRDaGlsZHJlbigpLnNvbWUoX25vZGUgPT4ge1xuICAgIGNvbnN0IGlzVGV4dCA9IGxleGljYWwuJGlzVGV4dE5vZGUoX25vZGUpO1xuXG4gICAgaWYgKGlzVGV4dCB8fCBsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUoX25vZGUpKSB7XG4gICAgICBjb25zdCB0ZXh0Q29udGVudFNpemUgPSBfbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcblxuICAgICAgaWYgKGlzVGV4dCAmJiB0ZXh0Q29udGVudFNpemUgPj0gdGV4dE9mZnNldCkge1xuICAgICAgICBfbm9kZS5zZWxlY3QodGV4dE9mZnNldCwgdGV4dE9mZnNldCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRleHRPZmZzZXQgLT0gdGV4dENvbnRlbnRTaXplO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59IC8vIEZpbmRzIG1pbmltYWwgZGlmZiByYW5nZSBiZXR3ZWVuIHR3byBub2RlcyBsaXN0cy4gSXQgcmV0dXJucyBmcm9tL3RvIHJhbmdlIGJvdW5kYXJpZXMgb2YgcHJldk5vZGVzXG4vLyB0aGF0IG5lZWRzIHRvIGJlIHJlcGxhY2VkIHdpdGggYG5vZGVzYCAoc3Vic2V0IG9mIG5leHROb2RlcykgdG8gbWFrZSBwcmV2Tm9kZXMgZXF1YWwgdG8gbmV4dE5vZGVzLlxuXG5cbmZ1bmN0aW9uIGdldERpZmZSYW5nZShwcmV2Tm9kZXMsIG5leHROb2Rlcykge1xuICBsZXQgbGVhZGluZ01hdGNoID0gMDtcblxuICB3aGlsZSAobGVhZGluZ01hdGNoIDwgcHJldk5vZGVzLmxlbmd0aCkge1xuICAgIGlmICghaXNFcXVhbChwcmV2Tm9kZXNbbGVhZGluZ01hdGNoXSwgbmV4dE5vZGVzW2xlYWRpbmdNYXRjaF0pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBsZWFkaW5nTWF0Y2grKztcbiAgfVxuXG4gIGNvbnN0IHByZXZOb2Rlc0xlbmd0aCA9IHByZXZOb2Rlcy5sZW5ndGg7XG4gIGNvbnN0IG5leHROb2Rlc0xlbmd0aCA9IG5leHROb2Rlcy5sZW5ndGg7XG4gIGNvbnN0IG1heFRyYWlsaW5nTWF0Y2ggPSBNYXRoLm1pbihwcmV2Tm9kZXNMZW5ndGgsIG5leHROb2Rlc0xlbmd0aCkgLSBsZWFkaW5nTWF0Y2g7XG4gIGxldCB0cmFpbGluZ01hdGNoID0gMDtcblxuICB3aGlsZSAodHJhaWxpbmdNYXRjaCA8IG1heFRyYWlsaW5nTWF0Y2gpIHtcbiAgICB0cmFpbGluZ01hdGNoKys7XG5cbiAgICBpZiAoIWlzRXF1YWwocHJldk5vZGVzW3ByZXZOb2Rlc0xlbmd0aCAtIHRyYWlsaW5nTWF0Y2hdLCBuZXh0Tm9kZXNbbmV4dE5vZGVzTGVuZ3RoIC0gdHJhaWxpbmdNYXRjaF0pKSB7XG4gICAgICB0cmFpbGluZ01hdGNoLS07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjb25zdCBmcm9tID0gbGVhZGluZ01hdGNoO1xuICBjb25zdCB0byA9IHByZXZOb2Rlc0xlbmd0aCAtIHRyYWlsaW5nTWF0Y2g7XG4gIGNvbnN0IG5vZGVzRm9yUmVwbGFjZW1lbnQgPSBuZXh0Tm9kZXMuc2xpY2UobGVhZGluZ01hdGNoLCBuZXh0Tm9kZXNMZW5ndGggLSB0cmFpbGluZ01hdGNoKTtcbiAgcmV0dXJuIHtcbiAgICBmcm9tLFxuICAgIG5vZGVzRm9yUmVwbGFjZW1lbnQsXG4gICAgdG9cbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNFcXVhbChub2RlQSwgbm9kZUIpIHtcbiAgLy8gT25seSBjaGVja2luZyBmb3IgY29kZSBoaWdsaWdodCBub2RlcyBhbmQgbGluZWJyZWFrcy4gSWYgaXQncyByZWd1bGFyIHRleHQgbm9kZVxuICAvLyByZXR1cm5pbmcgZmFsc2Ugc28gdGhhdCBpdCdzIHRyYW5zZm9ybWVkIGludG8gY29kZSBoaWdobGlnaHQgbm9kZVxuICBpZiAoJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZUEpICYmICRpc0NvZGVIaWdobGlnaHROb2RlKG5vZGVCKSkge1xuICAgIHJldHVybiBub2RlQS5fX3RleHQgPT09IG5vZGVCLl9fdGV4dCAmJiBub2RlQS5fX2hpZ2hsaWdodFR5cGUgPT09IG5vZGVCLl9faGlnaGxpZ2h0VHlwZTtcbiAgfVxuXG4gIGlmIChsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUobm9kZUEpICYmIGxleGljYWwuJGlzTGluZUJyZWFrTm9kZShub2RlQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTXVsdGlsaW5lSW5kZW50KHR5cGUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gT25seSBydW4gbXVsdGlsaW5lIGluZGVudCBsb2dpYyBvbiBzZWxlY3Rpb25zIGV4Y2x1c2l2ZWx5IGNvbXBvc2VkIG9mIGNvZGUgaGlnaGxpZ2h0cyBhbmQgbGluZWJyZWFrc1xuXG5cbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgaWYgKCEkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSAmJiAhbGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RhcnRPZkxpbmUgPSBnZXRGaXJzdENvZGVIaWdobGlnaHROb2RlT2ZMaW5lKG5vZGVzWzBdKTtcblxuICBpZiAoc3RhcnRPZkxpbmUgIT0gbnVsbCkge1xuICAgIGRvSW5kZW50KHN0YXJ0T2ZMaW5lLCB0eXBlKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAobGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGVzW2kgLSAxXSkgJiYgJGlzQ29kZUhpZ2hsaWdodE5vZGUobm9kZSkpIHtcbiAgICAgIGRvSW5kZW50KG5vZGUsIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBkb0luZGVudChub2RlLCB0eXBlKSB7XG4gIGNvbnN0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG5cbiAgaWYgKHR5cGUgPT09IGxleGljYWwuSU5ERU5UX0NPTlRFTlRfQ09NTUFORCkge1xuICAgIC8vIElmIHRoZSBjb2RlYmxvY2sgbm9kZSBkb2Vzbid0IHN0YXJ0IHdpdGggd2hpdGVzcGFjZSwgd2UgZG9uJ3Qgd2FudCB0b1xuICAgIC8vIG5haXZlbHkgcHJlcGVuZCBhICdcXHQnOyBQcmlzbSB3aWxsIHRoZW4gbWFuZ2xlIGFsbCBvZiBvdXIgbm9kZXMgd2hlblxuICAgIC8vIGl0IHNlcGFyYXRlcyB0aGUgd2hpdGVzcGFjZSBmcm9tIHRoZSBmaXJzdCBub24td2hpdGVzcGFjZSBub2RlLiBUaGlzXG4gICAgLy8gd2lsbCBsZWFkIHRvIHNlbGVjdGlvbiBidWdzIHdoZW4gaW5kZW50aW5nIGxpbmVzIHRoYXQgcHJldmlvdXNseVxuICAgIC8vIGRpZG4ndCBzdGFydCB3aXRoIGEgd2hpdGVzcGFjZSBjaGFyYWN0ZXJcbiAgICBpZiAodGV4dC5sZW5ndGggPiAwICYmIC9cXHMvLnRlc3QodGV4dFswXSkpIHtcbiAgICAgIG5vZGUuc2V0VGV4dENvbnRlbnQoJ1xcdCcgKyB0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5kZW50Tm9kZSA9ICRjcmVhdGVDb2RlSGlnaGxpZ2h0Tm9kZSgnXFx0Jyk7XG4gICAgICBub2RlLmluc2VydEJlZm9yZShpbmRlbnROb2RlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRleHQuaW5kZXhPZignXFx0JykgPT09IDApIHtcbiAgICAgIC8vIFNhbWUgYXMgYWJvdmUgLSBpZiB3ZSBsZWF2ZSBlbXB0eSB0ZXh0IG5vZGVzIGx5aW5nIGFyb3VuZCwgdGhlIHJlc3VsdGluZ1xuICAgICAgLy8gc2VsZWN0aW9uIHdpbGwgYmUgbWFuZ2xlZFxuICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldFRleHRDb250ZW50KHRleHQuc3Vic3RyaW5nKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlU2hpZnRMaW5lcyh0eXBlLCBldmVudCkge1xuICAvLyBXZSBvbmx5IGNhcmUgYWJvdXQgdGhlIGFsdCthcnJvdyBrZXlzXG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIEknbSBub3QgcXVpdGUgc3VyZSB3aHksIGJ1dCBpdCBzZWVtcyBsaWtlIGNhbGxpbmcgYW5jaG9yLmdldE5vZGUoKSBjb2xsYXBzZXMgdGhlIHNlbGVjdGlvbiBoZXJlXG4gIC8vIFNvIGZpcnN0LCBnZXQgdGhlIGFuY2hvciBhbmQgdGhlIGZvY3VzLCB0aGVuIGdldCB0aGVpciBub2Rlc1xuXG5cbiAgY29uc3Qge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICBjb25zdCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgYXJyb3dJc1VwID0gdHlwZSA9PT0gbGV4aWNhbC5LRVlfQVJST1dfVVBfQ09NTUFORDsgLy8gRW5zdXJlIHRoZSBzZWxlY3Rpb24gaXMgd2l0aGluIHRoZSBjb2RlYmxvY2tcblxuICBpZiAoISRpc0NvZGVIaWdobGlnaHROb2RlKGFuY2hvck5vZGUpIHx8ICEkaXNDb2RlSGlnaGxpZ2h0Tm9kZShmb2N1c05vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFldmVudC5hbHRLZXkpIHtcbiAgICAvLyBIYW5kbGUgbW92aW5nIHNlbGVjdGlvbiBvdXQgb2YgdGhlIGNvZGUgYmxvY2ssIGdpdmVuIHRoZXJlIGFyZSBub1xuICAgIC8vIHNpYmxpbmcgdGhhdHMgY2FuIG5hdGl2ZWx5IHRha2UgdGhlIHNlbGVjdGlvbi5cbiAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGNvbnN0IGNvZGVOb2RlID0gYW5jaG9yTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgICAgIGlmIChhcnJvd0lzVXAgJiYgYW5jaG9yT2Zmc2V0ID09PSAwICYmIGFuY2hvck5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29kZU5vZGVTaWJsaW5nID0gY29kZU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICAgICAgaWYgKGNvZGVOb2RlU2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvZGVOb2RlLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghYXJyb3dJc1VwICYmIGFuY2hvck9mZnNldCA9PT0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSAmJiBhbmNob3JOb2RlLmdldE5leHRTaWJsaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29kZU5vZGVTaWJsaW5nID0gY29kZU5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgICBpZiAoY29kZU5vZGVTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgY29kZU5vZGUuc2VsZWN0TmV4dCgpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBzdGFydCA9IGdldEZpcnN0Q29kZUhpZ2hsaWdodE5vZGVPZkxpbmUoYW5jaG9yTm9kZSk7XG4gIGNvbnN0IGVuZCA9IGdldExhc3RDb2RlSGlnaGxpZ2h0Tm9kZU9mTGluZShmb2N1c05vZGUpO1xuXG4gIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcmFuZ2UgPSBzdGFydC5nZXROb2Rlc0JldHdlZW4oZW5kKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IHJhbmdlW2ldO1xuXG4gICAgaWYgKCEkaXNDb2RlSGlnaGxpZ2h0Tm9kZShub2RlKSAmJiAhbGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIEFmdGVyIHRoaXMgcG9pbnQsIHdlIGtub3cgdGhlIHNlbGVjdGlvbiBpcyB3aXRoaW4gdGhlIGNvZGVibG9jay4gV2UgbWF5IG5vdCBiZSBhYmxlIHRvXG4gIC8vIGFjdHVhbGx5IG1vdmUgdGhlIGxpbmVzIGFyb3VuZCwgYnV0IHdlIHdhbnQgdG8gcmV0dXJuIHRydWUgZWl0aGVyIHdheSB0byBwcmV2ZW50XG4gIC8vIHRoZSBldmVudCdzIGRlZmF1bHQgYmVoYXZpb3JcblxuXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyByZXF1aXJlZCB0byBzdG9wIGN1cnNvciBtb3ZlbWVudCB1bmRlciBGaXJlZm94XG5cbiAgY29uc3QgbGluZWJyZWFrID0gYXJyb3dJc1VwID8gc3RhcnQuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBlbmQuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICBpZiAoIWxleGljYWwuJGlzTGluZUJyZWFrTm9kZShsaW5lYnJlYWspKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBzaWJsaW5nID0gYXJyb3dJc1VwID8gbGluZWJyZWFrLmdldFByZXZpb3VzU2libGluZygpIDogbGluZWJyZWFrLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgaWYgKHNpYmxpbmcgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgbWF5YmVJbnNlcnRpb25Qb2ludCA9IGFycm93SXNVcCA/IGdldEZpcnN0Q29kZUhpZ2hsaWdodE5vZGVPZkxpbmUoc2libGluZykgOiBnZXRMYXN0Q29kZUhpZ2hsaWdodE5vZGVPZkxpbmUoc2libGluZyk7XG4gIGxldCBpbnNlcnRpb25Qb2ludCA9IG1heWJlSW5zZXJ0aW9uUG9pbnQgIT0gbnVsbCA/IG1heWJlSW5zZXJ0aW9uUG9pbnQgOiBzaWJsaW5nO1xuICBsaW5lYnJlYWsucmVtb3ZlKCk7XG4gIHJhbmdlLmZvckVhY2gobm9kZSA9PiBub2RlLnJlbW92ZSgpKTtcblxuICBpZiAodHlwZSA9PT0gbGV4aWNhbC5LRVlfQVJST1dfVVBfQ09NTUFORCkge1xuICAgIHJhbmdlLmZvckVhY2gobm9kZSA9PiBpbnNlcnRpb25Qb2ludC5pbnNlcnRCZWZvcmUobm9kZSkpO1xuICAgIGluc2VydGlvblBvaW50Lmluc2VydEJlZm9yZShsaW5lYnJlYWspO1xuICB9IGVsc2Uge1xuICAgIGluc2VydGlvblBvaW50Lmluc2VydEFmdGVyKGxpbmVicmVhayk7XG4gICAgaW5zZXJ0aW9uUG9pbnQgPSBsaW5lYnJlYWs7XG4gICAgcmFuZ2UuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGluc2VydGlvblBvaW50Lmluc2VydEFmdGVyKG5vZGUpO1xuICAgICAgaW5zZXJ0aW9uUG9pbnQgPSBub2RlO1xuICAgIH0pO1xuICB9XG5cbiAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1vdmVUbyh0eXBlLCBldmVudCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgaXNNb3ZlVG9TdGFydCA9IHR5cGUgPT09IGxleGljYWwuTU9WRV9UT19TVEFSVDtcblxuICBpZiAoISRpc0NvZGVIaWdobGlnaHROb2RlKGFuY2hvck5vZGUpIHx8ICEkaXNDb2RlSGlnaGxpZ2h0Tm9kZShmb2N1c05vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbGV0IG5vZGU7XG4gIGxldCBvZmZzZXQ7XG5cbiAgaWYgKGlzTW92ZVRvU3RhcnQpIHtcbiAgICAoe1xuICAgICAgbm9kZSxcbiAgICAgIG9mZnNldFxuICAgIH0gPSBnZXRTdGFydE9mQ29kZUluTGluZShmb2N1c05vZGUpKTtcbiAgfSBlbHNlIHtcbiAgICAoe1xuICAgICAgbm9kZSxcbiAgICAgIG9mZnNldFxuICAgIH0gPSBnZXRFbmRPZkNvZGVJbkxpbmUoZm9jdXNOb2RlKSk7XG4gIH1cblxuICBpZiAobm9kZSAhPT0gbnVsbCAmJiBvZmZzZXQgIT09IC0xKSB7XG4gICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2Uobm9kZSwgb2Zmc2V0LCBub2RlLCBvZmZzZXQpO1xuICB9XG5cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckNvZGVIaWdobGlnaHRpbmcoZWRpdG9yLCB0b2tlbml6ZXIpIHtcbiAgaWYgKCFlZGl0b3IuaGFzTm9kZXMoW0NvZGVOb2RlLCBDb2RlSGlnaGxpZ2h0Tm9kZV0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlSGlnaGxpZ2h0UGx1Z2luOiBDb2RlTm9kZSBvciBDb2RlSGlnaGxpZ2h0Tm9kZSBub3QgcmVnaXN0ZXJlZCBvbiBlZGl0b3InKTtcbiAgfVxuXG4gIGlmICh0b2tlbml6ZXIgPT0gbnVsbCkge1xuICAgIHRva2VuaXplciA9IFByaXNtVG9rZW5pemVyO1xuICB9XG5cbiAgcmV0dXJuIHV0aWxzLm1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyTXV0YXRpb25MaXN0ZW5lcihDb2RlTm9kZSwgbXV0YXRpb25zID0+IHtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdHlwZV0gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlICE9PSAnZGVzdHJveWVkJykge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROb2RlQnlLZXkoa2V5KTtcblxuICAgICAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1cGRhdGVDb2RlR3V0dGVyKG5vZGUsIGVkaXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLCBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKENvZGVOb2RlLCBub2RlID0+IGNvZGVOb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0obGV4aWNhbC5UZXh0Tm9kZSwgbm9kZSA9PiB0ZXh0Tm9kZVRyYW5zZm9ybShub2RlLCBlZGl0b3IsIHRva2VuaXplcikpLCBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKENvZGVIaWdobGlnaHROb2RlLCBub2RlID0+IHRleHROb2RlVHJhbnNmb3JtKG5vZGUsIGVkaXRvciwgdG9rZW5pemVyKSksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5JTkRFTlRfQ09OVEVOVF9DT01NQU5ELCBwYXlsb2FkID0+IGhhbmRsZU11bHRpbGluZUluZGVudChsZXhpY2FsLklOREVOVF9DT05URU5UX0NPTU1BTkQpLCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLk9VVERFTlRfQ09OVEVOVF9DT01NQU5ELCBwYXlsb2FkID0+IGhhbmRsZU11bHRpbGluZUluZGVudChsZXhpY2FsLk9VVERFTlRfQ09OVEVOVF9DT01NQU5EKSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQVJST1dfVVBfQ09NTUFORCwgcGF5bG9hZCA9PiBoYW5kbGVTaGlmdExpbmVzKGxleGljYWwuS0VZX0FSUk9XX1VQX0NPTU1BTkQsIHBheWxvYWQpLCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9BUlJPV19ET1dOX0NPTU1BTkQsIHBheWxvYWQgPT4gaGFuZGxlU2hpZnRMaW5lcyhsZXhpY2FsLktFWV9BUlJPV19ET1dOX0NPTU1BTkQsIHBheWxvYWQpLCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLk1PVkVfVE9fRU5ELCBwYXlsb2FkID0+IGhhbmRsZU1vdmVUbyhsZXhpY2FsLk1PVkVfVE9fRU5ELCBwYXlsb2FkKSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5NT1ZFX1RPX1NUQVJULCBwYXlsb2FkID0+IGhhbmRsZU1vdmVUbyhsZXhpY2FsLk1PVkVfVE9fU1RBUlQsIHBheWxvYWQpLCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSk7XG59XG5cbmV4cG9ydHMuJGNyZWF0ZUNvZGVIaWdobGlnaHROb2RlID0gJGNyZWF0ZUNvZGVIaWdobGlnaHROb2RlO1xuZXhwb3J0cy4kY3JlYXRlQ29kZU5vZGUgPSAkY3JlYXRlQ29kZU5vZGU7XG5leHBvcnRzLiRpc0NvZGVIaWdobGlnaHROb2RlID0gJGlzQ29kZUhpZ2hsaWdodE5vZGU7XG5leHBvcnRzLiRpc0NvZGVOb2RlID0gJGlzQ29kZU5vZGU7XG5leHBvcnRzLkNPREVfTEFOR1VBR0VfRlJJRU5ETFlfTkFNRV9NQVAgPSBDT0RFX0xBTkdVQUdFX0ZSSUVORExZX05BTUVfTUFQO1xuZXhwb3J0cy5DT0RFX0xBTkdVQUdFX01BUCA9IENPREVfTEFOR1VBR0VfTUFQO1xuZXhwb3J0cy5Db2RlSGlnaGxpZ2h0Tm9kZSA9IENvZGVIaWdobGlnaHROb2RlO1xuZXhwb3J0cy5Db2RlTm9kZSA9IENvZGVOb2RlO1xuZXhwb3J0cy5ERUZBVUxUX0NPREVfTEFOR1VBR0UgPSBERUZBVUxUX0NPREVfTEFOR1VBR0U7XG5leHBvcnRzLlByaXNtVG9rZW5pemVyID0gUHJpc21Ub2tlbml6ZXI7XG5leHBvcnRzLmdldENvZGVMYW5ndWFnZXMgPSBnZXRDb2RlTGFuZ3VhZ2VzO1xuZXhwb3J0cy5nZXREZWZhdWx0Q29kZUxhbmd1YWdlID0gZ2V0RGVmYXVsdENvZGVMYW5ndWFnZTtcbmV4cG9ydHMuZ2V0RW5kT2ZDb2RlSW5MaW5lID0gZ2V0RW5kT2ZDb2RlSW5MaW5lO1xuZXhwb3J0cy5nZXRGaXJzdENvZGVIaWdobGlnaHROb2RlT2ZMaW5lID0gZ2V0Rmlyc3RDb2RlSGlnaGxpZ2h0Tm9kZU9mTGluZTtcbmV4cG9ydHMuZ2V0TGFuZ3VhZ2VGcmllbmRseU5hbWUgPSBnZXRMYW5ndWFnZUZyaWVuZGx5TmFtZTtcbmV4cG9ydHMuZ2V0TGFzdENvZGVIaWdobGlnaHROb2RlT2ZMaW5lID0gZ2V0TGFzdENvZGVIaWdobGlnaHROb2RlT2ZMaW5lO1xuZXhwb3J0cy5nZXRTdGFydE9mQ29kZUluTGluZSA9IGdldFN0YXJ0T2ZDb2RlSW5MaW5lO1xuZXhwb3J0cy5ub3JtYWxpemVDb2RlTGFuZyA9IG5vcm1hbGl6ZUNvZGVMYW5nO1xuZXhwb3J0cy5yZWdpc3RlckNvZGVIaWdobGlnaHRpbmcgPSByZWdpc3RlckNvZGVIaWdobGlnaHRpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/code/LexicalCode.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/code/LexicalCode.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/code/LexicalCode.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalCode =  true ? __webpack_require__(/*! ./LexicalCode.dev.js */ \"(ssr)/./node_modules/@lexical/code/LexicalCode.dev.js\") : 0\nmodule.exports = LexicalCode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY29kZS9MZXhpY2FsQ29kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLG9CQUFvQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsbUZBQXNCLElBQUksQ0FBZ0M7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jb2RlL0xleGljYWxDb2RlLmpzP2JmZGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxDb2RlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxDb2RlLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsQ29kZS5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbENvZGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/code/LexicalCode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lexical/dragon/LexicalDragon.dev.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/dragon */\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n\n    const rootElement = editor.getRootElement();\n\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n\n    const data = event.data;\n\n    if (typeof data === 'string') {\n      let parsedData;\n\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args; // TODO: we should probably handle formatCommand somehow?\n            editor.update(() => {\n              const selection = lexical.$getSelection();\n\n              if (lexical.$isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength; // If the offset is more than the end, make it the end\n\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n\n                if (lexical.$isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize(); // If the offset is more than the end, make it the end\n\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                } // block the chrome extension from handling this event\n\n\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\nexports.registerDragonSupport = registerDragonSupport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZHJhZ29uL0xleGljYWxEcmFnb24uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyx3REFBUzs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrR0FBa0c7QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7O0FBRWhGO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7O0FBR2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2RyYWdvbi9MZXhpY2FsRHJhZ29uLmRldi5qcz9lNGM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcblxuLyoqIEBtb2R1bGUgQGxleGljYWwvZHJhZ29uICovXG5mdW5jdGlvbiByZWdpc3RlckRyYWdvblN1cHBvcnQoZWRpdG9yKSB7XG4gIGNvbnN0IG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG5cbiAgY29uc3QgaGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICBpZiAoZXZlbnQub3JpZ2luICE9PSBvcmlnaW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuXG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHJvb3RFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgcGFyc2VkRGF0YTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcnNlZERhdGEgJiYgcGFyc2VkRGF0YS5wcm90b2NvbCA9PT0gJ251YW5yaWFfbWVzc2FnaW5nJyAmJiBwYXJzZWREYXRhLnR5cGUgPT09ICdyZXF1ZXN0Jykge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gcGFyc2VkRGF0YS5wYXlsb2FkO1xuXG4gICAgICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuZnVuY3Rpb25JZCA9PT0gJ21ha2VDaGFuZ2VzJykge1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBwYXlsb2FkLmFyZ3M7XG5cbiAgICAgICAgICBpZiAoYXJncykge1xuICAgICAgICAgICAgY29uc3QgW2VsZW1lbnRTdGFydCwgZWxlbWVudExlbmd0aCwgdGV4dCwgc2VsU3RhcnQsIHNlbExlbmd0aCwgZm9ybWF0Q29tbWFuZF0gPSBhcmdzOyAvLyBUT0RPOiB3ZSBzaG91bGQgcHJvYmFibHkgaGFuZGxlIGZvcm1hdENvbW1hbmQgc29tZWhvdz9cbiAgICAgICAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgICAgICAgICBsZXQgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgbGV0IHNldFNlbFN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgc2V0U2VsRW5kID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzZXQgaW5pdGlhbCBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50U3RhcnQgPj0gMCAmJiBlbGVtZW50TGVuZ3RoID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VsU3RhcnQgPSBlbGVtZW50U3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHNldFNlbEVuZCA9IGVsZW1lbnRTdGFydCArIGVsZW1lbnRMZW5ndGg7IC8vIElmIHRoZSBvZmZzZXQgaXMgbW9yZSB0aGFuIHRoZSBlbmQsIG1ha2UgaXQgdGhlIGVuZFxuXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKGFuY2hvck5vZGUsIHNldFNlbFN0YXJ0LCBhbmNob3JOb2RlLCBzZXRTZWxFbmQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZXRTZWxTdGFydCAhPT0gc2V0U2VsRW5kIHx8IHRleHQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dCh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgIGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzZXQgZmluYWwgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICBzZXRTZWxTdGFydCA9IHNlbFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgc2V0U2VsRW5kID0gc2VsU3RhcnQgKyBzZWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhbmNob3JOb2RlVGV4dExlbmd0aCA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7IC8vIElmIHRoZSBvZmZzZXQgaXMgbW9yZSB0aGFuIHRoZSBlbmQsIG1ha2UgaXQgdGhlIGVuZFxuXG4gICAgICAgICAgICAgICAgICBzZXRTZWxTdGFydCA9IHNldFNlbFN0YXJ0ID4gYW5jaG9yTm9kZVRleHRMZW5ndGggPyBhbmNob3JOb2RlVGV4dExlbmd0aCA6IHNldFNlbFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgc2V0U2VsRW5kID0gc2V0U2VsRW5kID4gYW5jaG9yTm9kZVRleHRMZW5ndGggPyBhbmNob3JOb2RlVGV4dExlbmd0aCA6IHNldFNlbEVuZDtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKGFuY2hvck5vZGUsIHNldFNlbFN0YXJ0LCBhbmNob3JOb2RlLCBzZXRTZWxFbmQpO1xuICAgICAgICAgICAgICAgIH0gLy8gYmxvY2sgdGhlIGNocm9tZSBleHRlbnNpb24gZnJvbSBoYW5kbGluZyB0aGlzIGV2ZW50XG5cblxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZXIsIHRydWUpO1xuICB9O1xufVxuXG5leHBvcnRzLnJlZ2lzdGVyRHJhZ29uU3VwcG9ydCA9IHJlZ2lzdGVyRHJhZ29uU3VwcG9ydDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/dragon/LexicalDragon.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/dragon/LexicalDragon.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalDragon =  true ? __webpack_require__(/*! ./LexicalDragon.dev.js */ \"(ssr)/./node_modules/@lexical/dragon/LexicalDragon.dev.js\") : 0\nmodule.exports = LexicalDragon;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZHJhZ29uL0xleGljYWxEcmFnb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWixzQkFBc0IsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLHlGQUF3QixJQUFJLENBQWtDO0FBQ3JJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZHJhZ29uL0xleGljYWxEcmFnb24uanM/NWRiNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbERyYWdvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsRHJhZ29uLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsRHJhZ29uLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsRHJhZ29uOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/dragon/LexicalDragon.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/file/LexicalFile.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/file/LexicalFile.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\nvar version = \"0.9.0\";\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction importFile(editor) {\n  readTextFileFromSystem(text => {\n    const json = JSON.parse(text);\n    const editorState = editor.parseEditorState(JSON.stringify(json.editorState));\n    editor.setEditorState(editorState);\n    editor.dispatchCommand(lexical.CLEAR_HISTORY_COMMAND, undefined);\n  });\n}\n\nfunction readTextFileFromSystem(callback) {\n  const input = document.createElement('input');\n  input.type = 'file';\n  input.accept = '.lexical';\n  input.addEventListener('change', event => {\n    const target = event.target;\n\n    if (target.files) {\n      const file = target.files[0];\n      const reader = new FileReader();\n      reader.readAsText(file, 'UTF-8');\n\n      reader.onload = readerEvent => {\n        if (readerEvent.target) {\n          const content = readerEvent.target.result;\n          callback(content);\n        }\n      };\n    }\n  });\n  input.click();\n}\n\nfunction exportFile(editor, config = Object.freeze({})) {\n  const now = new Date();\n  const editorState = editor.getEditorState();\n  const documentJSON = {\n    editorState: editorState,\n    lastSaved: now.getTime(),\n    source: config.source || 'Lexical',\n    version\n  };\n  const fileName = config.fileName || now.toISOString();\n  exportBlob(documentJSON, `${fileName}.lexical`);\n} // Adapted from https://stackoverflow.com/a/19328891/2013580\n\nfunction exportBlob(data, fileName) {\n  const a = document.createElement('a');\n  const body = document.body;\n\n  if (body === null) {\n    return;\n  }\n\n  body.appendChild(a);\n  a.style.display = 'none';\n  const json = JSON.stringify(data);\n  const blob = new Blob([json], {\n    type: 'octet/stream'\n  });\n  const url = window.URL.createObjectURL(blob);\n  a.href = url;\n  a.download = fileName;\n  a.click();\n  window.URL.revokeObjectURL(url);\n  a.remove();\n}\n\nexports.exportFile = exportFile;\nexports.importFile = importFile;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZmlsZS9MZXhpY2FsRmlsZS5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHdEQUFTOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkMsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2ZpbGUvTGV4aWNhbEZpbGUuZGV2LmpzP2Y2YzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xuXG52YXIgdmVyc2lvbiA9IFwiMC45LjBcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gaW1wb3J0RmlsZShlZGl0b3IpIHtcbiAgcmVhZFRleHRGaWxlRnJvbVN5c3RlbSh0ZXh0ID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICBjb25zdCBlZGl0b3JTdGF0ZSA9IGVkaXRvci5wYXJzZUVkaXRvclN0YXRlKEpTT04uc3RyaW5naWZ5KGpzb24uZWRpdG9yU3RhdGUpKTtcbiAgICBlZGl0b3Iuc2V0RWRpdG9yU3RhdGUoZWRpdG9yU3RhdGUpO1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5DTEVBUl9ISVNUT1JZX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWFkVGV4dEZpbGVGcm9tU3lzdGVtKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgaW5wdXQudHlwZSA9ICdmaWxlJztcbiAgaW5wdXQuYWNjZXB0ID0gJy5sZXhpY2FsJztcbiAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICAgIGlmICh0YXJnZXQuZmlsZXMpIHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0YXJnZXQuZmlsZXNbMF07XG4gICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSwgJ1VURi04Jyk7XG5cbiAgICAgIHJlYWRlci5vbmxvYWQgPSByZWFkZXJFdmVudCA9PiB7XG4gICAgICAgIGlmIChyZWFkZXJFdmVudC50YXJnZXQpIHtcbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gcmVhZGVyRXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICBjYWxsYmFjayhjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBpbnB1dC5jbGljaygpO1xufVxuXG5mdW5jdGlvbiBleHBvcnRGaWxlKGVkaXRvciwgY29uZmlnID0gT2JqZWN0LmZyZWV6ZSh7fSkpIHtcbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgZG9jdW1lbnRKU09OID0ge1xuICAgIGVkaXRvclN0YXRlOiBlZGl0b3JTdGF0ZSxcbiAgICBsYXN0U2F2ZWQ6IG5vdy5nZXRUaW1lKCksXG4gICAgc291cmNlOiBjb25maWcuc291cmNlIHx8ICdMZXhpY2FsJyxcbiAgICB2ZXJzaW9uXG4gIH07XG4gIGNvbnN0IGZpbGVOYW1lID0gY29uZmlnLmZpbGVOYW1lIHx8IG5vdy50b0lTT1N0cmluZygpO1xuICBleHBvcnRCbG9iKGRvY3VtZW50SlNPTiwgYCR7ZmlsZU5hbWV9LmxleGljYWxgKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xOTMyODg5MS8yMDEzNTgwXG5cbmZ1bmN0aW9uIGV4cG9ydEJsb2IoZGF0YSwgZmlsZU5hbWUpIHtcbiAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgY29uc3QgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cbiAgaWYgKGJvZHkgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBib2R5LmFwcGVuZENoaWxkKGEpO1xuICBhLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtqc29uXSwge1xuICAgIHR5cGU6ICdvY3RldC9zdHJlYW0nXG4gIH0pO1xuICBjb25zdCB1cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgYS5ocmVmID0gdXJsO1xuICBhLmRvd25sb2FkID0gZmlsZU5hbWU7XG4gIGEuY2xpY2soKTtcbiAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgYS5yZW1vdmUoKTtcbn1cblxuZXhwb3J0cy5leHBvcnRGaWxlID0gZXhwb3J0RmlsZTtcbmV4cG9ydHMuaW1wb3J0RmlsZSA9IGltcG9ydEZpbGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/file/LexicalFile.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/file/LexicalFile.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/file/LexicalFile.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalFile =  true ? __webpack_require__(/*! ./LexicalFile.dev.js */ \"(ssr)/./node_modules/@lexical/file/LexicalFile.dev.js\") : 0\nmodule.exports = LexicalFile;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZmlsZS9MZXhpY2FsRmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLG9CQUFvQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsbUZBQXNCLElBQUksQ0FBZ0M7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9maWxlL0xleGljYWxGaWxlLmpzP2EzOTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxGaWxlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxGaWxlLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsRmlsZS5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbEZpbGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/file/LexicalFile.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/hashtag/LexicalHashtag.dev.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/hashtag/LexicalHashtag.dev.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\n\nclass HashtagNode extends lexical.TextNode {\n  static getType() {\n    return 'hashtag';\n  }\n\n  static clone(node) {\n    return new HashtagNode(node.__text, node.__key);\n  }\n\n  constructor(text, key) {\n    super(text, key);\n  }\n\n  createDOM(config) {\n    const element = super.createDOM(config);\n    utils.addClassNamesToElement(element, config.theme.hashtag);\n    return element;\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createHashtagNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'hashtag'\n    };\n  }\n\n  canInsertTextBefore() {\n    return false;\n  }\n\n  isTextEntity() {\n    return true;\n  }\n\n}\nfunction $createHashtagNode(text = '') {\n  return lexical.$applyNodeReplacement(new HashtagNode(text));\n}\nfunction $isHashtagNode(node) {\n  return node instanceof HashtagNode;\n}\n\nexports.$createHashtagNode = $createHashtagNode;\nexports.$isHashtagNode = $isHashtagNode;\nexports.HashtagNode = HashtagNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaGFzaHRhZy9MZXhpY2FsSGFzaHRhZy5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNwQyxjQUFjLG1CQUFPLENBQUMsd0RBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QixtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9oYXNodGFnL0xleGljYWxIYXNodGFnLmRldi5qcz82OWM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5cbmNsYXNzIEhhc2h0YWdOb2RlIGV4dGVuZHMgbGV4aWNhbC5UZXh0Tm9kZSB7XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnaGFzaHRhZyc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgSGFzaHRhZ05vZGUobm9kZS5fX3RleHQsIG5vZGUuX19rZXkpO1xuICB9XG5cbiAgY29uc3RydWN0b3IodGV4dCwga2V5KSB7XG4gICAgc3VwZXIodGV4dCwga2V5KTtcbiAgfVxuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gc3VwZXIuY3JlYXRlRE9NKGNvbmZpZyk7XG4gICAgdXRpbHMuYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjb25maWcudGhlbWUuaGFzaHRhZyk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlSGFzaHRhZ05vZGUoc2VyaWFsaXplZE5vZGUudGV4dCk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldERldGFpbChzZXJpYWxpemVkTm9kZS5kZXRhaWwpO1xuICAgIG5vZGUuc2V0TW9kZShzZXJpYWxpemVkTm9kZS5tb2RlKTtcbiAgICBub2RlLnNldFN0eWxlKHNlcmlhbGl6ZWROb2RlLnN0eWxlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgdHlwZTogJ2hhc2h0YWcnXG4gICAgfTtcbiAgfVxuXG4gIGNhbkluc2VydFRleHRCZWZvcmUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNUZXh0RW50aXR5KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn1cbmZ1bmN0aW9uICRjcmVhdGVIYXNodGFnTm9kZSh0ZXh0ID0gJycpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBIYXNodGFnTm9kZSh0ZXh0KSk7XG59XG5mdW5jdGlvbiAkaXNIYXNodGFnTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgSGFzaHRhZ05vZGU7XG59XG5cbmV4cG9ydHMuJGNyZWF0ZUhhc2h0YWdOb2RlID0gJGNyZWF0ZUhhc2h0YWdOb2RlO1xuZXhwb3J0cy4kaXNIYXNodGFnTm9kZSA9ICRpc0hhc2h0YWdOb2RlO1xuZXhwb3J0cy5IYXNodGFnTm9kZSA9IEhhc2h0YWdOb2RlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/hashtag/LexicalHashtag.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/hashtag/LexicalHashtag.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lexical/hashtag/LexicalHashtag.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHashtag =  true ? __webpack_require__(/*! ./LexicalHashtag.dev.js */ \"(ssr)/./node_modules/@lexical/hashtag/LexicalHashtag.dev.js\") : 0\nmodule.exports = LexicalHashtag;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaGFzaHRhZy9MZXhpY2FsSGFzaHRhZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLHVCQUF1QixLQUFzQyxHQUFHLG1CQUFPLENBQUMsNEZBQXlCLElBQUksQ0FBbUM7QUFDeEkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9oYXNodGFnL0xleGljYWxIYXNodGFnLmpzPzU1ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxIYXNodGFnID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxIYXNodGFnLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsSGFzaHRhZy5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbEhhc2h0YWc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/hashtag/LexicalHashtag.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/history/LexicalHistory.dev.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/history */\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\n\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n\n    if (dirtyElement !== undefined && !lexical.$isRootNode(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n\n  return nodes;\n}\n\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n\n  if (!lexical.$isRangeSelection(nextSelection) || !lexical.$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  } // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n\n\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && lexical.$isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n\n    return OTHER;\n  }\n\n  const nextDirtyNode = dirtyNodes[0];\n\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n\n  if (!lexical.$isTextNode(prevDirtyNode) || !lexical.$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n\n  if (prevText === nextText) {\n    return OTHER;\n  }\n\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n\n  return OTHER;\n}\n\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n\n  const nextNode = nextEditorState._nodeMap.get(key);\n\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  let isDeletingLine = false;\n\n  if (lexical.$isRangeSelection(prevSelection) && lexical.$isRangeSelection(nextSelection)) {\n    isDeletingLine = prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  }\n\n  if (!isDeletingLine && lexical.$isTextNode(prevNode) && lexical.$isTextNode(nextNode)) {\n    return prevNode.__type === nextNode.__type && prevNode.__text === nextNode.__text && prevNode.__mode === nextNode.__mode && prevNode.__detail === nextNode.__detail && prevNode.__style === nextNode.__style && prevNode.__format === nextNode.__format && prevNode.__parent === nextNode.__parent;\n  }\n\n  return false;\n}\n\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now(); // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\n\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      } // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n\n\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n\n      return HISTORY_PUSH;\n    })();\n\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\n\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\n    }\n\n    const historyStateEntry = redoStack.pop();\n\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n    }\n\n    historyState.current = historyStateEntry || null;\n\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\n\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, true);\n    }\n\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\n    }\n\n    historyState.current = historyStateEntry || null;\n\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState.clone(historyStateEntry.undoSelection), {\n        tag: 'historic'\n      });\n    }\n  }\n}\n\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n      }\n\n      if (current !== null) {\n        undoStack.push({ ...current,\n          undoSelection: prevEditorState.read(lexical.$getSelection)\n        });\n        editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    } // Else we merge\n\n\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n\n  const unregisterCommandListener = utils.mergeRegister(editor.registerCommand(lexical.UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  const unregisterUpdateListener = editor.registerUpdateListener(applyChange);\n  return () => {\n    unregisterCommandListener();\n    unregisterUpdateListener();\n  };\n}\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\nexports.createEmptyHistoryState = createEmptyHistoryState;\nexports.registerHistory = registerHistory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaGlzdG9yeS9MZXhpY2FsSGlzdG9yeS5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNwQyxjQUFjLG1CQUFPLENBQUMsd0RBQVM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQix1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9oaXN0b3J5L0xleGljYWxIaXN0b3J5LmRldi5qcz9mMjIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG5cbi8qKiBAbW9kdWxlIEBsZXhpY2FsL2hpc3RvcnkgKi9cbmNvbnN0IEhJU1RPUllfTUVSR0UgPSAwO1xuY29uc3QgSElTVE9SWV9QVVNIID0gMTtcbmNvbnN0IERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEUgPSAyO1xuY29uc3QgT1RIRVIgPSAwO1xuY29uc3QgQ09NUE9TSU5HX0NIQVJBQ1RFUiA9IDE7XG5jb25zdCBJTlNFUlRfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTiA9IDI7XG5jb25zdCBERUxFVEVfQ0hBUkFDVEVSX0JFRk9SRV9TRUxFQ1RJT04gPSAzO1xuY29uc3QgREVMRVRFX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT04gPSA0O1xuXG5mdW5jdGlvbiBnZXREaXJ0eU5vZGVzKGVkaXRvclN0YXRlLCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cykge1xuICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IG5vZGVzID0gW107XG5cbiAgZm9yIChjb25zdCBkaXJ0eUxlYWZLZXkgb2YgZGlydHlMZWF2ZXMpIHtcbiAgICBjb25zdCBkaXJ0eUxlYWYgPSBub2RlTWFwLmdldChkaXJ0eUxlYWZLZXkpO1xuXG4gICAgaWYgKGRpcnR5TGVhZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBub2Rlcy5wdXNoKGRpcnR5TGVhZik7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBbZGlydHlFbGVtZW50S2V5LCBpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eV0gb2YgZGlydHlFbGVtZW50cykge1xuICAgIGlmICghaW50ZW50aW9uYWxseU1hcmtlZEFzRGlydHkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGRpcnR5RWxlbWVudCA9IG5vZGVNYXAuZ2V0KGRpcnR5RWxlbWVudEtleSk7XG5cbiAgICBpZiAoZGlydHlFbGVtZW50ICE9PSB1bmRlZmluZWQgJiYgIWxleGljYWwuJGlzUm9vdE5vZGUoZGlydHlFbGVtZW50KSkge1xuICAgICAgbm9kZXMucHVzaChkaXJ0eUVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn1cblxuZnVuY3Rpb24gZ2V0Q2hhbmdlVHlwZShwcmV2RWRpdG9yU3RhdGUsIG5leHRFZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXNTZXQsIGRpcnR5RWxlbWVudHNTZXQsIGlzQ29tcG9zaW5nKSB7XG4gIGlmIChwcmV2RWRpdG9yU3RhdGUgPT09IG51bGwgfHwgZGlydHlMZWF2ZXNTZXQuc2l6ZSA9PT0gMCAmJiBkaXJ0eUVsZW1lbnRzU2V0LnNpemUgPT09IDAgJiYgIWlzQ29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG5cbiAgY29uc3QgbmV4dFNlbGVjdGlvbiA9IG5leHRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBwcmV2U2VsZWN0aW9uID0gcHJldkVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG5cbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIENPTVBPU0lOR19DSEFSQUNURVI7XG4gIH1cblxuICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24obmV4dFNlbGVjdGlvbikgfHwgIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgfHwgIXByZXZTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCAhbmV4dFNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG5cbiAgY29uc3QgZGlydHlOb2RlcyA9IGdldERpcnR5Tm9kZXMobmV4dEVkaXRvclN0YXRlLCBkaXJ0eUxlYXZlc1NldCwgZGlydHlFbGVtZW50c1NldCk7XG5cbiAgaWYgKGRpcnR5Tm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9IC8vIENhdGNoaW5nIHRoZSBjYXNlIHdoZW4gaW5zZXJ0aW5nIG5ldyB0ZXh0IG5vZGUgaW50byBhbiBlbGVtZW50IChlLmcuIGZpcnN0IGNoYXIgaW4gcGFyYWdyYXBoL2xpc3QpLFxuICAvLyBvciBhZnRlciBleGlzdGluZyBub2RlLlxuXG5cbiAgaWYgKGRpcnR5Tm9kZXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG5leHROb2RlTWFwID0gbmV4dEVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICAgIGNvbnN0IG5leHRBbmNob3JOb2RlID0gbmV4dE5vZGVNYXAuZ2V0KG5leHRTZWxlY3Rpb24uYW5jaG9yLmtleSk7XG4gICAgY29uc3QgcHJldkFuY2hvck5vZGUgPSBuZXh0Tm9kZU1hcC5nZXQocHJldlNlbGVjdGlvbi5hbmNob3Iua2V5KTtcblxuICAgIGlmIChuZXh0QW5jaG9yTm9kZSAmJiBwcmV2QW5jaG9yTm9kZSAmJiAhcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwLmhhcyhuZXh0QW5jaG9yTm9kZS5fX2tleSkgJiYgbGV4aWNhbC4kaXNUZXh0Tm9kZShuZXh0QW5jaG9yTm9kZSkgJiYgbmV4dEFuY2hvck5vZGUuX190ZXh0Lmxlbmd0aCA9PT0gMSAmJiBuZXh0U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDEpIHtcbiAgICAgIHJldHVybiBJTlNFUlRfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTjtcbiAgICB9XG5cbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cblxuICBjb25zdCBuZXh0RGlydHlOb2RlID0gZGlydHlOb2Rlc1swXTtcblxuICBjb25zdCBwcmV2RGlydHlOb2RlID0gcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChuZXh0RGlydHlOb2RlLl9fa2V5KTtcblxuICBpZiAoIWxleGljYWwuJGlzVGV4dE5vZGUocHJldkRpcnR5Tm9kZSkgfHwgIWxleGljYWwuJGlzVGV4dE5vZGUobmV4dERpcnR5Tm9kZSkgfHwgcHJldkRpcnR5Tm9kZS5fX21vZGUgIT09IG5leHREaXJ0eU5vZGUuX19tb2RlKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG5cbiAgY29uc3QgcHJldlRleHQgPSBwcmV2RGlydHlOb2RlLl9fdGV4dDtcbiAgY29uc3QgbmV4dFRleHQgPSBuZXh0RGlydHlOb2RlLl9fdGV4dDtcblxuICBpZiAocHJldlRleHQgPT09IG5leHRUZXh0KSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG5cbiAgY29uc3QgbmV4dEFuY2hvciA9IG5leHRTZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBwcmV2QW5jaG9yID0gcHJldlNlbGVjdGlvbi5hbmNob3I7XG5cbiAgaWYgKG5leHRBbmNob3Iua2V5ICE9PSBwcmV2QW5jaG9yLmtleSB8fCBuZXh0QW5jaG9yLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuXG4gIGNvbnN0IG5leHRBbmNob3JPZmZzZXQgPSBuZXh0QW5jaG9yLm9mZnNldDtcbiAgY29uc3QgcHJldkFuY2hvck9mZnNldCA9IHByZXZBbmNob3Iub2Zmc2V0O1xuICBjb25zdCB0ZXh0RGlmZiA9IG5leHRUZXh0Lmxlbmd0aCAtIHByZXZUZXh0Lmxlbmd0aDtcblxuICBpZiAodGV4dERpZmYgPT09IDEgJiYgcHJldkFuY2hvck9mZnNldCA9PT0gbmV4dEFuY2hvck9mZnNldCAtIDEpIHtcbiAgICByZXR1cm4gSU5TRVJUX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT047XG4gIH1cblxuICBpZiAodGV4dERpZmYgPT09IC0xICYmIHByZXZBbmNob3JPZmZzZXQgPT09IG5leHRBbmNob3JPZmZzZXQgKyAxKSB7XG4gICAgcmV0dXJuIERFTEVURV9DSEFSQUNURVJfQkVGT1JFX1NFTEVDVElPTjtcbiAgfVxuXG4gIGlmICh0ZXh0RGlmZiA9PT0gLTEgJiYgcHJldkFuY2hvck9mZnNldCA9PT0gbmV4dEFuY2hvck9mZnNldCkge1xuICAgIHJldHVybiBERUxFVEVfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTjtcbiAgfVxuXG4gIHJldHVybiBPVEhFUjtcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZVVuY2hhbmdlZChrZXksIHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IHByZXZOb2RlID0gcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChrZXkpO1xuXG4gIGNvbnN0IG5leHROb2RlID0gbmV4dEVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChrZXkpO1xuXG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBwcmV2RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgY29uc3QgbmV4dFNlbGVjdGlvbiA9IG5leHRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBsZXQgaXNEZWxldGluZ0xpbmUgPSBmYWxzZTtcblxuICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKG5leHRTZWxlY3Rpb24pKSB7XG4gICAgaXNEZWxldGluZ0xpbmUgPSBwcmV2U2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgcHJldlNlbGVjdGlvbi5mb2N1cy50eXBlID09PSAnZWxlbWVudCcgJiYgbmV4dFNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ3RleHQnICYmIG5leHRTZWxlY3Rpb24uZm9jdXMudHlwZSA9PT0gJ3RleHQnO1xuICB9XG5cbiAgaWYgKCFpc0RlbGV0aW5nTGluZSAmJiBsZXhpY2FsLiRpc1RleHROb2RlKHByZXZOb2RlKSAmJiBsZXhpY2FsLiRpc1RleHROb2RlKG5leHROb2RlKSkge1xuICAgIHJldHVybiBwcmV2Tm9kZS5fX3R5cGUgPT09IG5leHROb2RlLl9fdHlwZSAmJiBwcmV2Tm9kZS5fX3RleHQgPT09IG5leHROb2RlLl9fdGV4dCAmJiBwcmV2Tm9kZS5fX21vZGUgPT09IG5leHROb2RlLl9fbW9kZSAmJiBwcmV2Tm9kZS5fX2RldGFpbCA9PT0gbmV4dE5vZGUuX19kZXRhaWwgJiYgcHJldk5vZGUuX19zdHlsZSA9PT0gbmV4dE5vZGUuX19zdHlsZSAmJiBwcmV2Tm9kZS5fX2Zvcm1hdCA9PT0gbmV4dE5vZGUuX19mb3JtYXQgJiYgcHJldk5vZGUuX19wYXJlbnQgPT09IG5leHROb2RlLl9fcGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNZXJnZUFjdGlvbkdldHRlcihlZGl0b3IsIGRlbGF5KSB7XG4gIGxldCBwcmV2Q2hhbmdlVGltZSA9IERhdGUubm93KCk7XG4gIGxldCBwcmV2Q2hhbmdlVHlwZSA9IE9USEVSO1xuICByZXR1cm4gKHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlLCBjdXJyZW50SGlzdG9yeUVudHJ5LCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cywgdGFncykgPT4ge1xuICAgIGNvbnN0IGNoYW5nZVRpbWUgPSBEYXRlLm5vdygpOyAvLyBJZiBhcHBseWluZyBjaGFuZ2VzIGZyb20gaGlzdG9yeSBzdGFjayB0aGVyZSdzIG5vIG5lZWRcbiAgICAvLyB0byBydW4gaGlzdG9yeSBsb2dpYyBhZ2FpbiwgYXMgaGlzdG9yeSBlbnRyaWVzIGFscmVhZHkgY2FsY3VsYXRlZFxuXG4gICAgaWYgKHRhZ3MuaGFzKCdoaXN0b3JpYycpKSB7XG4gICAgICBwcmV2Q2hhbmdlVHlwZSA9IE9USEVSO1xuICAgICAgcHJldkNoYW5nZVRpbWUgPSBjaGFuZ2VUaW1lO1xuICAgICAgcmV0dXJuIERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEU7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbmdlVHlwZSA9IGdldENoYW5nZVR5cGUocHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzLCBkaXJ0eUVsZW1lbnRzLCBlZGl0b3IuaXNDb21wb3NpbmcoKSk7XG5cbiAgICBjb25zdCBtZXJnZUFjdGlvbiA9ICgoKSA9PiB7XG4gICAgICBjb25zdCBpc1NhbWVFZGl0b3IgPSBjdXJyZW50SGlzdG9yeUVudHJ5ID09PSBudWxsIHx8IGN1cnJlbnRIaXN0b3J5RW50cnkuZWRpdG9yID09PSBlZGl0b3I7XG4gICAgICBjb25zdCBzaG91bGRQdXNoSGlzdG9yeSA9IHRhZ3MuaGFzKCdoaXN0b3J5LXB1c2gnKTtcbiAgICAgIGNvbnN0IHNob3VsZE1lcmdlSGlzdG9yeSA9ICFzaG91bGRQdXNoSGlzdG9yeSAmJiBpc1NhbWVFZGl0b3IgJiYgdGFncy5oYXMoJ2hpc3RvcnktbWVyZ2UnKTtcblxuICAgICAgaWYgKHNob3VsZE1lcmdlSGlzdG9yeSkge1xuICAgICAgICByZXR1cm4gSElTVE9SWV9NRVJHRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gSElTVE9SWV9QVVNIO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBuZXh0RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgICAgIGNvbnN0IGhhc0RpcnR5Tm9kZXMgPSBkaXJ0eUxlYXZlcy5zaXplID4gMCB8fCBkaXJ0eUVsZW1lbnRzLnNpemUgPiAwO1xuXG4gICAgICBpZiAoIWhhc0RpcnR5Tm9kZXMpIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBISVNUT1JZX01FUkdFO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRQdXNoSGlzdG9yeSA9PT0gZmFsc2UgJiYgY2hhbmdlVHlwZSAhPT0gT1RIRVIgJiYgY2hhbmdlVHlwZSA9PT0gcHJldkNoYW5nZVR5cGUgJiYgY2hhbmdlVGltZSA8IHByZXZDaGFuZ2VUaW1lICsgZGVsYXkgJiYgaXNTYW1lRWRpdG9yKSB7XG4gICAgICAgIHJldHVybiBISVNUT1JZX01FUkdFO1xuICAgICAgfSAvLyBBIHNpbmdsZSBub2RlIG1pZ2h0IGhhdmUgYmVlbiBtYXJrZWQgYXMgZGlydHksIGJ1dCBub3QgaGF2ZSBjaGFuZ2VkXG4gICAgICAvLyBkdWUgdG8gc29tZSBub2RlIHRyYW5zZm9ybSByZXZlcnRpbmcgdGhlIGNoYW5nZS5cblxuXG4gICAgICBpZiAoZGlydHlMZWF2ZXMuc2l6ZSA9PT0gMSkge1xuICAgICAgICBjb25zdCBkaXJ0eUxlYWZLZXkgPSBBcnJheS5mcm9tKGRpcnR5TGVhdmVzKVswXTtcblxuICAgICAgICBpZiAoaXNUZXh0Tm9kZVVuY2hhbmdlZChkaXJ0eUxlYWZLZXksIHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlKSkge1xuICAgICAgICAgIHJldHVybiBISVNUT1JZX01FUkdFO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBISVNUT1JZX1BVU0g7XG4gICAgfSkoKTtcblxuICAgIHByZXZDaGFuZ2VUaW1lID0gY2hhbmdlVGltZTtcbiAgICBwcmV2Q2hhbmdlVHlwZSA9IGNoYW5nZVR5cGU7XG4gICAgcmV0dXJuIG1lcmdlQWN0aW9uO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZWRvKGVkaXRvciwgaGlzdG9yeVN0YXRlKSB7XG4gIGNvbnN0IHJlZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2s7XG4gIGNvbnN0IHVuZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS51bmRvU3RhY2s7XG5cbiAgaWYgKHJlZG9TdGFjay5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBjdXJyZW50ID0gaGlzdG9yeVN0YXRlLmN1cnJlbnQ7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdW5kb1N0YWNrLnB1c2goY3VycmVudCk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuQ0FOX1VORE9fQ09NTUFORCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGlzdG9yeVN0YXRlRW50cnkgPSByZWRvU3RhY2sucG9wKCk7XG5cbiAgICBpZiAocmVkb1N0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLkNBTl9SRURPX0NPTU1BTkQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBoaXN0b3J5U3RhdGUuY3VycmVudCA9IGhpc3RvcnlTdGF0ZUVudHJ5IHx8IG51bGw7XG5cbiAgICBpZiAoaGlzdG9yeVN0YXRlRW50cnkpIHtcbiAgICAgIGhpc3RvcnlTdGF0ZUVudHJ5LmVkaXRvci5zZXRFZGl0b3JTdGF0ZShoaXN0b3J5U3RhdGVFbnRyeS5lZGl0b3JTdGF0ZSwge1xuICAgICAgICB0YWc6ICdoaXN0b3JpYydcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1bmRvKGVkaXRvciwgaGlzdG9yeVN0YXRlKSB7XG4gIGNvbnN0IHJlZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2s7XG4gIGNvbnN0IHVuZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS51bmRvU3RhY2s7XG4gIGNvbnN0IHVuZG9TdGFja0xlbmd0aCA9IHVuZG9TdGFjay5sZW5ndGg7XG5cbiAgaWYgKHVuZG9TdGFja0xlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBoaXN0b3J5U3RhdGUuY3VycmVudDtcbiAgICBjb25zdCBoaXN0b3J5U3RhdGVFbnRyeSA9IHVuZG9TdGFjay5wb3AoKTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICByZWRvU3RhY2sucHVzaChjdXJyZW50KTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5DQU5fUkVET19DT01NQU5ELCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAodW5kb1N0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLkNBTl9VTkRPX0NPTU1BTkQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBoaXN0b3J5U3RhdGUuY3VycmVudCA9IGhpc3RvcnlTdGF0ZUVudHJ5IHx8IG51bGw7XG5cbiAgICBpZiAoaGlzdG9yeVN0YXRlRW50cnkpIHtcbiAgICAgIGhpc3RvcnlTdGF0ZUVudHJ5LmVkaXRvci5zZXRFZGl0b3JTdGF0ZShoaXN0b3J5U3RhdGVFbnRyeS5lZGl0b3JTdGF0ZS5jbG9uZShoaXN0b3J5U3RhdGVFbnRyeS51bmRvU2VsZWN0aW9uKSwge1xuICAgICAgICB0YWc6ICdoaXN0b3JpYydcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhckhpc3RvcnkoaGlzdG9yeVN0YXRlKSB7XG4gIGhpc3RvcnlTdGF0ZS51bmRvU3RhY2sgPSBbXTtcbiAgaGlzdG9yeVN0YXRlLnJlZG9TdGFjayA9IFtdO1xuICBoaXN0b3J5U3RhdGUuY3VycmVudCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVySGlzdG9yeShlZGl0b3IsIGhpc3RvcnlTdGF0ZSwgZGVsYXkpIHtcbiAgY29uc3QgZ2V0TWVyZ2VBY3Rpb24gPSBjcmVhdGVNZXJnZUFjdGlvbkdldHRlcihlZGl0b3IsIGRlbGF5KTtcblxuICBjb25zdCBhcHBseUNoYW5nZSA9ICh7XG4gICAgZWRpdG9yU3RhdGUsXG4gICAgcHJldkVkaXRvclN0YXRlLFxuICAgIGRpcnR5TGVhdmVzLFxuICAgIGRpcnR5RWxlbWVudHMsXG4gICAgdGFnc1xuICB9KSA9PiB7XG4gICAgY29uc3QgY3VycmVudCA9IGhpc3RvcnlTdGF0ZS5jdXJyZW50O1xuICAgIGNvbnN0IHJlZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2s7XG4gICAgY29uc3QgdW5kb1N0YWNrID0gaGlzdG9yeVN0YXRlLnVuZG9TdGFjaztcbiAgICBjb25zdCBjdXJyZW50RWRpdG9yU3RhdGUgPSBjdXJyZW50ID09PSBudWxsID8gbnVsbCA6IGN1cnJlbnQuZWRpdG9yU3RhdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBlZGl0b3JTdGF0ZSA9PT0gY3VycmVudEVkaXRvclN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWVyZ2VBY3Rpb24gPSBnZXRNZXJnZUFjdGlvbihwcmV2RWRpdG9yU3RhdGUsIGVkaXRvclN0YXRlLCBjdXJyZW50LCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cywgdGFncyk7XG5cbiAgICBpZiAobWVyZ2VBY3Rpb24gPT09IEhJU1RPUllfUFVTSCkge1xuICAgICAgaWYgKHJlZG9TdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgICAgaGlzdG9yeVN0YXRlLnJlZG9TdGFjayA9IFtdO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuQ0FOX1JFRE9fQ09NTUFORCwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICB1bmRvU3RhY2sucHVzaCh7IC4uLmN1cnJlbnQsXG4gICAgICAgICAgdW5kb1NlbGVjdGlvbjogcHJldkVkaXRvclN0YXRlLnJlYWQobGV4aWNhbC4kZ2V0U2VsZWN0aW9uKVxuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLkNBTl9VTkRPX0NPTU1BTkQsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWVyZ2VBY3Rpb24gPT09IERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEVsc2Ugd2UgbWVyZ2VcblxuXG4gICAgaGlzdG9yeVN0YXRlLmN1cnJlbnQgPSB7XG4gICAgICBlZGl0b3IsXG4gICAgICBlZGl0b3JTdGF0ZVxuICAgIH07XG4gIH07XG5cbiAgY29uc3QgdW5yZWdpc3RlckNvbW1hbmRMaXN0ZW5lciA9IHV0aWxzLm1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLlVORE9fQ09NTUFORCwgKCkgPT4ge1xuICAgIHVuZG8oZWRpdG9yLCBoaXN0b3J5U3RhdGUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLlJFRE9fQ09NTUFORCwgKCkgPT4ge1xuICAgIHJlZG8oZWRpdG9yLCBoaXN0b3J5U3RhdGUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkNMRUFSX0VESVRPUl9DT01NQU5ELCAoKSA9PiB7XG4gICAgY2xlYXJIaXN0b3J5KGhpc3RvcnlTdGF0ZSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkNMRUFSX0hJU1RPUllfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNsZWFySGlzdG9yeShoaXN0b3J5U3RhdGUpO1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5DQU5fUkVET19DT01NQU5ELCBmYWxzZSk7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLkNBTl9VTkRPX0NPTU1BTkQsIGZhbHNlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKGFwcGx5Q2hhbmdlKSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lciA9IGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKGFwcGx5Q2hhbmdlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB1bnJlZ2lzdGVyQ29tbWFuZExpc3RlbmVyKCk7XG4gICAgdW5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKCk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBudWxsLFxuICAgIHJlZG9TdGFjazogW10sXG4gICAgdW5kb1N0YWNrOiBbXVxuICB9O1xufVxuXG5leHBvcnRzLmNyZWF0ZUVtcHR5SGlzdG9yeVN0YXRlID0gY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGU7XG5leHBvcnRzLnJlZ2lzdGVySGlzdG9yeSA9IHJlZ2lzdGVySGlzdG9yeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/history/LexicalHistory.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lexical/history/LexicalHistory.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHistory =  true ? __webpack_require__(/*! ./LexicalHistory.dev.js */ \"(ssr)/./node_modules/@lexical/history/LexicalHistory.dev.js\") : 0\nmodule.exports = LexicalHistory;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaGlzdG9yeS9MZXhpY2FsSGlzdG9yeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLHVCQUF1QixLQUFzQyxHQUFHLG1CQUFPLENBQUMsNEZBQXlCLElBQUksQ0FBbUM7QUFDeEkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9oaXN0b3J5L0xleGljYWxIaXN0b3J5LmpzPzU2NDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxIaXN0b3J5ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxIaXN0b3J5LmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsSGlzdG9yeS5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbEhpc3Rvcnk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/history/LexicalHistory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/html/LexicalHtml.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar selection = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/html */\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivilant library and pass in the document here.\n */\n\nfunction $generateNodesFromDOM(editor, dom) {\n  let lexicalNodes = [];\n  const elements = dom.body ? Array.from(dom.body.childNodes) : [];\n  const elementsLength = elements.length;\n\n  for (let i = 0; i < elementsLength; i++) {\n    const element = elements[i];\n\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n\n  return container.innerHTML;\n}\n\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const {\n    element,\n    after\n  } = target.exportDOM(editor);\n\n  if (!element) {\n    return false;\n  }\n\n  const fragment = new DocumentFragment();\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    element.append(fragment);\n    parentElement.append(element);\n\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n\n  return shouldInclude;\n}\n\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n\n  let currentConversion = null;\n\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\n\nconst IGNORE_TAGS = new Set(['STYLE']);\n\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode, preformatted = false) {\n  let lexicalNodes = [];\n\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node, undefined, preformatted) : null;\n  let postTransform = null;\n\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    currentLexicalNode = transformOutput.node;\n\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n\n      if (currentLexicalNode) {\n        lexicalNodes.push(currentLexicalNode);\n      }\n    }\n\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  } // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n\n\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode, preformatted || (transformOutput && transformOutput.preformatted) === true));\n  }\n\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n\n  return lexicalNodes;\n}\n\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaHRtbC9MZXhpY2FsSHRtbC5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsdUZBQW9CO0FBQzVDLGNBQWMsbUJBQU8sQ0FBQyx3REFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDZCQUE2QjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2h0bWwvTGV4aWNhbEh0bWwuZGV2LmpzP2ZlMzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzZWxlY3Rpb24gPSByZXF1aXJlKCdAbGV4aWNhbC9zZWxlY3Rpb24nKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xuXG4vKiogQG1vZHVsZSBAbGV4aWNhbC9odG1sICovXG4vKipcbiAqIEhvdyB5b3UgcGFyc2UgeW91ciBodG1sIHN0cmluZyB0byBnZXQgYSBkb2N1bWVudCBpcyBsZWZ0IHVwIHRvIHlvdS4gSW4gdGhlIGJyb3dzZXIgeW91IGNhbiB1c2UgdGhlIG5hdGl2ZVxuICogRE9NUGFyc2VyIEFQSSB0byBnZW5lcmF0ZSBhIGRvY3VtZW50IChzZWUgY2xpcGJvYXJkLnRzKSwgYnV0IHRvIHVzZSBpbiBhIGhlYWRsZXNzIGVudmlyb25tZW50IHlvdSBjYW4gdXNlIEpTRG9tXG4gKiBvciBhbiBlcXVpdmlsYW50IGxpYnJhcnkgYW5kIHBhc3MgaW4gdGhlIGRvY3VtZW50IGhlcmUuXG4gKi9cblxuZnVuY3Rpb24gJGdlbmVyYXRlTm9kZXNGcm9tRE9NKGVkaXRvciwgZG9tKSB7XG4gIGxldCBsZXhpY2FsTm9kZXMgPSBbXTtcbiAgY29uc3QgZWxlbWVudHMgPSBkb20uYm9keSA/IEFycmF5LmZyb20oZG9tLmJvZHkuY2hpbGROb2RlcykgOiBbXTtcbiAgY29uc3QgZWxlbWVudHNMZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuXG4gICAgaWYgKCFJR05PUkVfVEFHUy5oYXMoZWxlbWVudC5ub2RlTmFtZSkpIHtcbiAgICAgIGNvbnN0IGxleGljYWxOb2RlID0gJGNyZWF0ZU5vZGVzRnJvbURPTShlbGVtZW50LCBlZGl0b3IpO1xuXG4gICAgICBpZiAobGV4aWNhbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgbGV4aWNhbE5vZGVzID0gbGV4aWNhbE5vZGVzLmNvbmNhdChsZXhpY2FsTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxleGljYWxOb2Rlcztcbn1cbmZ1bmN0aW9uICRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHVzZSAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzIGluIGhlYWRsZXNzIG1vZGUgcGxlYXNlIGluaXRpYWxpemUgYSBoZWFkbGVzcyBicm93c2VyIGltcGxlbWVudGF0aW9uIHN1Y2ggYXMgSlNEb20gYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb25zdCByb290ID0gbGV4aWNhbC4kZ2V0Um9vdCgpO1xuICBjb25zdCB0b3BMZXZlbENoaWxkcmVuID0gcm9vdC5nZXRDaGlsZHJlbigpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9wTGV2ZWxDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvcExldmVsTm9kZSA9IHRvcExldmVsQ2hpbGRyZW5baV07XG4gICAgJGFwcGVuZE5vZGVzVG9IVE1MKGVkaXRvciwgdG9wTGV2ZWxOb2RlLCBjb250YWluZXIsIHNlbGVjdGlvbik7XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gJGFwcGVuZE5vZGVzVG9IVE1MKGVkaXRvciwgY3VycmVudE5vZGUsIHBhcmVudEVsZW1lbnQsIHNlbGVjdGlvbiQxID0gbnVsbCkge1xuICBsZXQgc2hvdWxkSW5jbHVkZSA9IHNlbGVjdGlvbiQxICE9IG51bGwgPyBjdXJyZW50Tm9kZS5pc1NlbGVjdGVkKCkgOiB0cnVlO1xuICBjb25zdCBzaG91bGRFeGNsdWRlID0gbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgY3VycmVudE5vZGUuZXhjbHVkZUZyb21Db3B5KCdodG1sJyk7XG4gIGxldCB0YXJnZXQgPSBjdXJyZW50Tm9kZTtcblxuICBpZiAoc2VsZWN0aW9uJDEgIT09IG51bGwpIHtcbiAgICBsZXQgY2xvbmUgPSBzZWxlY3Rpb24uJGNsb25lV2l0aFByb3BlcnRpZXMoY3VycmVudE5vZGUpO1xuICAgIGNsb25lID0gbGV4aWNhbC4kaXNUZXh0Tm9kZShjbG9uZSkgJiYgc2VsZWN0aW9uJDEgIT0gbnVsbCA/IHNlbGVjdGlvbi4kc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudChzZWxlY3Rpb24kMSwgY2xvbmUpIDogY2xvbmU7XG4gICAgdGFyZ2V0ID0gY2xvbmU7XG4gIH1cblxuICBjb25zdCBjaGlsZHJlbiA9IGxleGljYWwuJGlzRWxlbWVudE5vZGUodGFyZ2V0KSA/IHRhcmdldC5nZXRDaGlsZHJlbigpIDogW107XG4gIGNvbnN0IHtcbiAgICBlbGVtZW50LFxuICAgIGFmdGVyXG4gIH0gPSB0YXJnZXQuZXhwb3J0RE9NKGVkaXRvcik7XG5cbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgZnJhZ21lbnQgPSBuZXcgRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBzaG91bGRJbmNsdWRlQ2hpbGQgPSAkYXBwZW5kTm9kZXNUb0hUTUwoZWRpdG9yLCBjaGlsZE5vZGUsIGZyYWdtZW50LCBzZWxlY3Rpb24kMSk7XG5cbiAgICBpZiAoIXNob3VsZEluY2x1ZGUgJiYgbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgc2hvdWxkSW5jbHVkZUNoaWxkICYmIGN1cnJlbnROb2RlLmV4dHJhY3RXaXRoQ2hpbGQoY2hpbGROb2RlLCBzZWxlY3Rpb24kMSwgJ2h0bWwnKSkge1xuICAgICAgc2hvdWxkSW5jbHVkZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNob3VsZEluY2x1ZGUgJiYgIXNob3VsZEV4Y2x1ZGUpIHtcbiAgICBlbGVtZW50LmFwcGVuZChmcmFnbWVudCk7XG4gICAgcGFyZW50RWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG5cbiAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBhZnRlci5jYWxsKHRhcmdldCwgZWxlbWVudCk7XG4gICAgICBpZiAobmV3RWxlbWVudCkgZWxlbWVudC5yZXBsYWNlV2l0aChuZXdFbGVtZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50RWxlbWVudC5hcHBlbmQoZnJhZ21lbnQpO1xuICB9XG5cbiAgcmV0dXJuIHNob3VsZEluY2x1ZGU7XG59XG5cbmZ1bmN0aW9uIGdldENvbnZlcnNpb25GdW5jdGlvbihkb21Ob2RlLCBlZGl0b3IpIHtcbiAgY29uc3Qge1xuICAgIG5vZGVOYW1lXG4gIH0gPSBkb21Ob2RlO1xuXG4gIGNvbnN0IGNhY2hlZENvbnZlcnNpb25zID0gZWRpdG9yLl9odG1sQ29udmVyc2lvbnMuZ2V0KG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuXG4gIGxldCBjdXJyZW50Q29udmVyc2lvbiA9IG51bGw7XG5cbiAgaWYgKGNhY2hlZENvbnZlcnNpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IGNhY2hlZENvbnZlcnNpb24gb2YgY2FjaGVkQ29udmVyc2lvbnMpIHtcbiAgICAgIGNvbnN0IGRvbUNvbnZlcnNpb24gPSBjYWNoZWRDb252ZXJzaW9uKGRvbU5vZGUpO1xuXG4gICAgICBpZiAoZG9tQ29udmVyc2lvbiAhPT0gbnVsbCAmJiAoY3VycmVudENvbnZlcnNpb24gPT09IG51bGwgfHwgY3VycmVudENvbnZlcnNpb24ucHJpb3JpdHkgPCBkb21Db252ZXJzaW9uLnByaW9yaXR5KSkge1xuICAgICAgICBjdXJyZW50Q29udmVyc2lvbiA9IGRvbUNvbnZlcnNpb247XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRDb252ZXJzaW9uICE9PSBudWxsID8gY3VycmVudENvbnZlcnNpb24uY29udmVyc2lvbiA6IG51bGw7XG59XG5cbmNvbnN0IElHTk9SRV9UQUdTID0gbmV3IFNldChbJ1NUWUxFJ10pO1xuXG5mdW5jdGlvbiAkY3JlYXRlTm9kZXNGcm9tRE9NKG5vZGUsIGVkaXRvciwgZm9yQ2hpbGRNYXAgPSBuZXcgTWFwKCksIHBhcmVudExleGljYWxOb2RlLCBwcmVmb3JtYXR0ZWQgPSBmYWxzZSkge1xuICBsZXQgbGV4aWNhbE5vZGVzID0gW107XG5cbiAgaWYgKElHTk9SRV9UQUdTLmhhcyhub2RlLm5vZGVOYW1lKSkge1xuICAgIHJldHVybiBsZXhpY2FsTm9kZXM7XG4gIH1cblxuICBsZXQgY3VycmVudExleGljYWxOb2RlID0gbnVsbDtcbiAgY29uc3QgdHJhbnNmb3JtRnVuY3Rpb24gPSBnZXRDb252ZXJzaW9uRnVuY3Rpb24obm9kZSwgZWRpdG9yKTtcbiAgY29uc3QgdHJhbnNmb3JtT3V0cHV0ID0gdHJhbnNmb3JtRnVuY3Rpb24gPyB0cmFuc2Zvcm1GdW5jdGlvbihub2RlLCB1bmRlZmluZWQsIHByZWZvcm1hdHRlZCkgOiBudWxsO1xuICBsZXQgcG9zdFRyYW5zZm9ybSA9IG51bGw7XG5cbiAgaWYgKHRyYW5zZm9ybU91dHB1dCAhPT0gbnVsbCkge1xuICAgIHBvc3RUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1PdXRwdXQuYWZ0ZXI7XG4gICAgY3VycmVudExleGljYWxOb2RlID0gdHJhbnNmb3JtT3V0cHV0Lm5vZGU7XG5cbiAgICBpZiAoY3VycmVudExleGljYWxOb2RlICE9PSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IFssIGZvckNoaWxkRnVuY3Rpb25dIG9mIGZvckNoaWxkTWFwKSB7XG4gICAgICAgIGN1cnJlbnRMZXhpY2FsTm9kZSA9IGZvckNoaWxkRnVuY3Rpb24oY3VycmVudExleGljYWxOb2RlLCBwYXJlbnRMZXhpY2FsTm9kZSk7XG5cbiAgICAgICAgaWYgKCFjdXJyZW50TGV4aWNhbE5vZGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudExleGljYWxOb2RlKSB7XG4gICAgICAgIGxleGljYWxOb2Rlcy5wdXNoKGN1cnJlbnRMZXhpY2FsTm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybU91dHB1dC5mb3JDaGlsZCAhPSBudWxsKSB7XG4gICAgICBmb3JDaGlsZE1hcC5zZXQobm9kZS5ub2RlTmFtZSwgdHJhbnNmb3JtT3V0cHV0LmZvckNoaWxkKTtcbiAgICB9XG4gIH0gLy8gSWYgdGhlIERPTSBub2RlIGRvZXNuJ3QgaGF2ZSBhIHRyYW5zZm9ybWVyLCB3ZSBkb24ndCBrbm93IHdoYXRcbiAgLy8gdG8gZG8gd2l0aCBpdCBidXQgd2Ugc3RpbGwgbmVlZCB0byBwcm9jZXNzIGFueSBjaGlsZE5vZGVzLlxuXG5cbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gIGxldCBjaGlsZExleGljYWxOb2RlcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjaGlsZExleGljYWxOb2Rlcy5wdXNoKC4uLiRjcmVhdGVOb2Rlc0Zyb21ET00oY2hpbGRyZW5baV0sIGVkaXRvciwgbmV3IE1hcChmb3JDaGlsZE1hcCksIGN1cnJlbnRMZXhpY2FsTm9kZSwgcHJlZm9ybWF0dGVkIHx8ICh0cmFuc2Zvcm1PdXRwdXQgJiYgdHJhbnNmb3JtT3V0cHV0LnByZWZvcm1hdHRlZCkgPT09IHRydWUpKTtcbiAgfVxuXG4gIGlmIChwb3N0VHJhbnNmb3JtICE9IG51bGwpIHtcbiAgICBjaGlsZExleGljYWxOb2RlcyA9IHBvc3RUcmFuc2Zvcm0oY2hpbGRMZXhpY2FsTm9kZXMpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnRMZXhpY2FsTm9kZSA9PSBudWxsKSB7XG4gICAgLy8gSWYgaXQgaGFzbid0IGJlZW4gY29udmVydGVkIHRvIGEgTGV4aWNhbE5vZGUsIHdlIGhvaXN0IGl0cyBjaGlsZHJlblxuICAgIC8vIHVwIHRvIHRoZSBzYW1lIGxldmVsIGFzIGl0LlxuICAgIGxleGljYWxOb2RlcyA9IGxleGljYWxOb2Rlcy5jb25jYXQoY2hpbGRMZXhpY2FsTm9kZXMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGN1cnJlbnRMZXhpY2FsTm9kZSkpIHtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBFbGVtZW50Tm9kZSBhZnRlciBjb252ZXJzaW9uLFxuICAgICAgLy8gd2UgY2FuIGFwcGVuZCBhbGwgdGhlIGNoaWxkcmVuIHRvIGl0LlxuICAgICAgY3VycmVudExleGljYWxOb2RlLmFwcGVuZCguLi5jaGlsZExleGljYWxOb2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxleGljYWxOb2Rlcztcbn1cblxuZXhwb3J0cy4kZ2VuZXJhdGVIdG1sRnJvbU5vZGVzID0gJGdlbmVyYXRlSHRtbEZyb21Ob2RlcztcbmV4cG9ydHMuJGdlbmVyYXRlTm9kZXNGcm9tRE9NID0gJGdlbmVyYXRlTm9kZXNGcm9tRE9NO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/html/LexicalHtml.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/html/LexicalHtml.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHtml =  true ? __webpack_require__(/*! ./LexicalHtml.dev.js */ \"(ssr)/./node_modules/@lexical/html/LexicalHtml.dev.js\") : 0\nmodule.exports = LexicalHtml;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaHRtbC9MZXhpY2FsSHRtbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLG9CQUFvQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsbUZBQXNCLElBQUksQ0FBZ0M7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9odG1sL0xleGljYWxIdG1sLmpzPzRhYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxIdG1sID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxIdG1sLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsSHRtbC5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbEh0bWw7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/html/LexicalHtml.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/link/LexicalLink.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/link/LexicalLink.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/link */\n\n/** @noInheritDoc */\nclass LinkNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'link';\n  }\n\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target\n    }, node.__key);\n  }\n\n  constructor(url, attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n  }\n\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.__url;\n\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n\n    utils.addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n\n  updateDOM(prevNode, anchor, config) {\n    const url = this.__url;\n    const target = this.__target;\n    const rel = this.__rel;\n\n    if (url !== prevNode.__url) {\n      anchor.href = url;\n    }\n\n    if (target !== prevNode.__target) {\n      if (target) {\n        anchor.target = target;\n      } else {\n        anchor.removeAttribute('target');\n      }\n    }\n\n    if (rel !== prevNode.__rel) {\n      if (rel) {\n        anchor.rel = rel;\n      } else {\n        anchor.removeAttribute('rel');\n      }\n    }\n\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      type: 'link',\n      url: this.getURL(),\n      version: 1\n    };\n  }\n\n  getURL() {\n    return this.getLatest().__url;\n  }\n\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n  }\n\n  getTarget() {\n    return this.getLatest().__target;\n  }\n\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n  }\n\n  getRel() {\n    return this.getLatest().__rel;\n  }\n\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n  }\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createLinkNode(this.__url, {\n        rel: this.__rel,\n        target: this.__target\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n\n    return null;\n  }\n\n  canInsertTextBefore() {\n    return false;\n  }\n\n  canInsertTextAfter() {\n    return false;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  isInline() {\n    return true;\n  }\n\n  extractWithChild(child, selection, destination) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n\n}\n\nfunction convertAnchorElement(domNode) {\n  let node = null;\n\n  if (utils.isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n\n    if (content !== null && content !== '') {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target')\n      });\n    }\n  }\n\n  return {\n    node\n  };\n}\n\nfunction $createLinkNode(url, attributes) {\n  return lexical.$applyNodeReplacement(new LinkNode(url, attributes));\n}\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  static getType() {\n    return 'autolink';\n  }\n\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target\n    }, node.__key);\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createAutoLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'autolink',\n      version: 1\n    };\n  }\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n\n    if (lexical.$isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        rel: this._rel,\n        target: this.__target\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n\n    return null;\n  }\n\n}\nfunction $createAutoLinkNode(url, attributes) {\n  return lexical.$applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = lexical.createCommand('TOGGLE_LINK_COMMAND');\nfunction toggleLink(url, attributes = {}) {\n  const {\n    target\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noopener' : attributes.rel;\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n\n  const nodes = selection.extract();\n\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parent = node.getParent();\n\n      if ($isLinkNode(parent)) {\n        const children = parent.getChildren();\n\n        for (let i = 0; i < children.length; i++) {\n          parent.insertBefore(children[i]);\n        }\n\n        parent.remove();\n      }\n    });\n  } else {\n    // Add or merge LinkNodes\n    if (nodes.length === 1) {\n      const firstNode = nodes[0]; // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n\n      const linkNode = $isLinkNode(firstNode) ? firstNode : $getLinkAncestor(firstNode);\n\n      if (linkNode !== null) {\n        linkNode.setURL(url);\n\n        if (target !== undefined) {\n          linkNode.setTarget(target);\n        }\n\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n\n        return;\n      }\n    }\n\n    let prevParent = null;\n    let linkNode = null;\n    nodes.forEach(node => {\n      const parent = node.getParent();\n\n      if (parent === linkNode || parent === null || lexical.$isElementNode(node) && !node.isInline()) {\n        return;\n      }\n\n      if ($isLinkNode(parent)) {\n        linkNode = parent;\n        parent.setURL(url);\n\n        if (target !== undefined) {\n          parent.setTarget(target);\n        }\n\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n\n        return;\n      }\n\n      if (!parent.is(prevParent)) {\n        prevParent = parent;\n        linkNode = $createLinkNode(url, {\n          rel,\n          target\n        });\n\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode);\n          } else {\n            parent.insertAfter(linkNode);\n          }\n        } else {\n          node.insertBefore(linkNode);\n        }\n      }\n\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return;\n        }\n\n        if (linkNode !== null) {\n          const children = node.getChildren();\n\n          for (let i = 0; i < children.length; i++) {\n            linkNode.append(children[i]);\n          }\n        }\n\n        node.remove();\n        return;\n      }\n\n      if (linkNode !== null) {\n        linkNode.append(node);\n      }\n    });\n  }\n}\n\nfunction $getLinkAncestor(node) {\n  return $getAncestor(node, ancestor => $isLinkNode(ancestor));\n}\n\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n\n  while (parent !== null && (parent = parent.getParent()) !== null && !predicate(parent));\n\n  return parent;\n}\n\nexports.$createAutoLinkNode = $createAutoLinkNode;\nexports.$createLinkNode = $createLinkNode;\nexports.$isAutoLinkNode = $isAutoLinkNode;\nexports.$isLinkNode = $isLinkNode;\nexports.AutoLinkNode = AutoLinkNode;\nexports.LinkNode = LinkNode;\nexports.TOGGLE_LINK_COMMAND = TOGGLE_LINK_COMMAND;\nexports.toggleLink = toggleLink;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGluay9MZXhpY2FsTGluay5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNwQyxjQUFjLG1CQUFPLENBQUMsd0RBQVM7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEIsMkJBQTJCO0FBQzNCLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpbmsvTGV4aWNhbExpbmsuZGV2LmpzP2Q1ODUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcblxuLyoqIEBtb2R1bGUgQGxleGljYWwvbGluayAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgTGlua05vZGUgZXh0ZW5kcyBsZXhpY2FsLkVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnbGluayc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgTGlua05vZGUobm9kZS5fX3VybCwge1xuICAgICAgcmVsOiBub2RlLl9fcmVsLFxuICAgICAgdGFyZ2V0OiBub2RlLl9fdGFyZ2V0XG4gICAgfSwgbm9kZS5fX2tleSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih1cmwsIGF0dHJpYnV0ZXMgPSB7fSwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQgPSBudWxsLFxuICAgICAgcmVsID0gbnVsbFxuICAgIH0gPSBhdHRyaWJ1dGVzO1xuICAgIHRoaXMuX191cmwgPSB1cmw7XG4gICAgdGhpcy5fX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9fcmVsID0gcmVsO1xuICB9XG5cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgZWxlbWVudC5ocmVmID0gdGhpcy5fX3VybDtcblxuICAgIGlmICh0aGlzLl9fdGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnRhcmdldCA9IHRoaXMuX190YXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX19yZWwgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnQucmVsID0gdGhpcy5fX3JlbDtcbiAgICB9XG5cbiAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS5saW5rKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgYW5jaG9yLCBjb25maWcpIHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLl9fdXJsO1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX190YXJnZXQ7XG4gICAgY29uc3QgcmVsID0gdGhpcy5fX3JlbDtcblxuICAgIGlmICh1cmwgIT09IHByZXZOb2RlLl9fdXJsKSB7XG4gICAgICBhbmNob3IuaHJlZiA9IHVybDtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0ICE9PSBwcmV2Tm9kZS5fX3RhcmdldCkge1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBhbmNob3IudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5jaG9yLnJlbW92ZUF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbCAhPT0gcHJldk5vZGUuX19yZWwpIHtcbiAgICAgIGlmIChyZWwpIHtcbiAgICAgICAgYW5jaG9yLnJlbCA9IHJlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvci5yZW1vdmVBdHRyaWJ1dGUoJ3JlbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydEFuY2hvckVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAxXG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlTGlua05vZGUoc2VyaWFsaXplZE5vZGUudXJsLCB7XG4gICAgICByZWw6IHNlcmlhbGl6ZWROb2RlLnJlbCxcbiAgICAgIHRhcmdldDogc2VyaWFsaXplZE5vZGUudGFyZ2V0XG4gICAgfSk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldEluZGVudChzZXJpYWxpemVkTm9kZS5pbmRlbnQpO1xuICAgIG5vZGUuc2V0RGlyZWN0aW9uKHNlcmlhbGl6ZWROb2RlLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHJlbDogdGhpcy5nZXRSZWwoKSxcbiAgICAgIHRhcmdldDogdGhpcy5nZXRUYXJnZXQoKSxcbiAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgIHVybDogdGhpcy5nZXRVUkwoKSxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG5cbiAgZ2V0VVJMKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fdXJsO1xuICB9XG5cbiAgc2V0VVJMKHVybCkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fdXJsID0gdXJsO1xuICB9XG5cbiAgZ2V0VGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fdGFyZ2V0O1xuICB9XG5cbiAgc2V0VGFyZ2V0KHRhcmdldCkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fdGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG5cbiAgZ2V0UmVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fcmVsO1xuICB9XG5cbiAgc2V0UmVsKHJlbCkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fcmVsID0gcmVsO1xuICB9XG5cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5pbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24pO1xuXG4gICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUoZWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IGxpbmtOb2RlID0gJGNyZWF0ZUxpbmtOb2RlKHRoaXMuX191cmwsIHtcbiAgICAgICAgcmVsOiB0aGlzLl9fcmVsLFxuICAgICAgICB0YXJnZXQ6IHRoaXMuX190YXJnZXRcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5hcHBlbmQobGlua05vZGUpO1xuICAgICAgcmV0dXJuIGxpbmtOb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbiwgZGVzdGluYXRpb24pIHtcbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIHJldHVybiB0aGlzLmlzUGFyZW50T2YoYW5jaG9yTm9kZSkgJiYgdGhpcy5pc1BhcmVudE9mKGZvY3VzTm9kZSkgJiYgc2VsZWN0aW9uLmdldFRleHRDb250ZW50KCkubGVuZ3RoID4gMDtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRBbmNob3JFbGVtZW50KGRvbU5vZGUpIHtcbiAgbGV0IG5vZGUgPSBudWxsO1xuXG4gIGlmICh1dGlscy5pc0hUTUxBbmNob3JFbGVtZW50KGRvbU5vZGUpKSB7XG4gICAgY29uc3QgY29udGVudCA9IGRvbU5vZGUudGV4dENvbnRlbnQ7XG5cbiAgICBpZiAoY29udGVudCAhPT0gbnVsbCAmJiBjb250ZW50ICE9PSAnJykge1xuICAgICAgbm9kZSA9ICRjcmVhdGVMaW5rTm9kZShkb21Ob2RlLmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8ICcnLCB7XG4gICAgICAgIHJlbDogZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3JlbCcpLFxuICAgICAgICB0YXJnZXQ6IGRvbU5vZGUuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlXG4gIH07XG59XG5cbmZ1bmN0aW9uICRjcmVhdGVMaW5rTm9kZSh1cmwsIGF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBMaW5rTm9kZSh1cmwsIGF0dHJpYnV0ZXMpKTtcbn1cbmZ1bmN0aW9uICRpc0xpbmtOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaW5rTm9kZTtcbn1cbi8vIEN1c3RvbSBub2RlIHR5cGUgdG8gb3ZlcnJpZGUgYGNhbkluc2VydFRleHRBZnRlcmAgdGhhdCB3aWxsXG4vLyBhbGxvdyB0eXBpbmcgd2l0aGluIHRoZSBsaW5rXG5jbGFzcyBBdXRvTGlua05vZGUgZXh0ZW5kcyBMaW5rTm9kZSB7XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnYXV0b2xpbmsnO1xuICB9XG5cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IEF1dG9MaW5rTm9kZShub2RlLl9fdXJsLCB7XG4gICAgICByZWw6IG5vZGUuX19yZWwsXG4gICAgICB0YXJnZXQ6IG5vZGUuX190YXJnZXRcbiAgICB9LCBub2RlLl9fa2V5KTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVBdXRvTGlua05vZGUoc2VyaWFsaXplZE5vZGUudXJsLCB7XG4gICAgICByZWw6IHNlcmlhbGl6ZWROb2RlLnJlbCxcbiAgICAgIHRhcmdldDogc2VyaWFsaXplZE5vZGUudGFyZ2V0XG4gICAgfSk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldEluZGVudChzZXJpYWxpemVkTm9kZS5pbmRlbnQpO1xuICAgIG5vZGUuc2V0RGlyZWN0aW9uKHNlcmlhbGl6ZWROb2RlLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIC8vIFRPRE86IFNob3VsZCBsaW5rIG5vZGUgc2hvdWxkIGhhbmRsZSB0aGUgaW1wb3J0IG92ZXIgYXV0b2xpbms/XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHR5cGU6ICdhdXRvbGluaycsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIGluc2VydE5ld0FmdGVyKHNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBsaW5rTm9kZSA9ICRjcmVhdGVBdXRvTGlua05vZGUodGhpcy5fX3VybCwge1xuICAgICAgICByZWw6IHRoaXMuX3JlbCxcbiAgICAgICAgdGFyZ2V0OiB0aGlzLl9fdGFyZ2V0XG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuYXBwZW5kKGxpbmtOb2RlKTtcbiAgICAgIHJldHVybiBsaW5rTm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG59XG5mdW5jdGlvbiAkY3JlYXRlQXV0b0xpbmtOb2RlKHVybCwgYXR0cmlidXRlcykge1xuICByZXR1cm4gbGV4aWNhbC4kYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IEF1dG9MaW5rTm9kZSh1cmwsIGF0dHJpYnV0ZXMpKTtcbn1cbmZ1bmN0aW9uICRpc0F1dG9MaW5rTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgQXV0b0xpbmtOb2RlO1xufVxuY29uc3QgVE9HR0xFX0xJTktfQ09NTUFORCA9IGxleGljYWwuY3JlYXRlQ29tbWFuZCgnVE9HR0xFX0xJTktfQ09NTUFORCcpO1xuZnVuY3Rpb24gdG9nZ2xlTGluayh1cmwsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgdGFyZ2V0XG4gIH0gPSBhdHRyaWJ1dGVzO1xuICBjb25zdCByZWwgPSBhdHRyaWJ1dGVzLnJlbCA9PT0gdW5kZWZpbmVkID8gJ25vb3BlbmVyJyA6IGF0dHJpYnV0ZXMucmVsO1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmV4dHJhY3QoKTtcblxuICBpZiAodXJsID09PSBudWxsKSB7XG4gICAgLy8gUmVtb3ZlIExpbmtOb2Rlc1xuICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAoJGlzTGlua05vZGUocGFyZW50KSkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5nZXRDaGlsZHJlbigpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBZGQgb3IgbWVyZ2UgTGlua05vZGVzXG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgZmlyc3ROb2RlID0gbm9kZXNbMF07IC8vIGlmIHRoZSBmaXJzdCBub2RlIGlzIGEgTGlua05vZGUgb3IgaWYgaXRzXG4gICAgICAvLyBwYXJlbnQgaXMgYSBMaW5rTm9kZSwgd2UgdXBkYXRlIHRoZSBVUkwsIHRhcmdldCBhbmQgcmVsLlxuXG4gICAgICBjb25zdCBsaW5rTm9kZSA9ICRpc0xpbmtOb2RlKGZpcnN0Tm9kZSkgPyBmaXJzdE5vZGUgOiAkZ2V0TGlua0FuY2VzdG9yKGZpcnN0Tm9kZSk7XG5cbiAgICAgIGlmIChsaW5rTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBsaW5rTm9kZS5zZXRVUkwodXJsKTtcblxuICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsaW5rTm9kZS5zZXRUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWwgIT09IG51bGwpIHtcbiAgICAgICAgICBsaW5rTm9kZS5zZXRSZWwocmVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcHJldlBhcmVudCA9IG51bGw7XG4gICAgbGV0IGxpbmtOb2RlID0gbnVsbDtcbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcblxuICAgICAgaWYgKHBhcmVudCA9PT0gbGlua05vZGUgfHwgcGFyZW50ID09PSBudWxsIHx8IGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICgkaXNMaW5rTm9kZShwYXJlbnQpKSB7XG4gICAgICAgIGxpbmtOb2RlID0gcGFyZW50O1xuICAgICAgICBwYXJlbnQuc2V0VVJMKHVybCk7XG5cbiAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFyZW50LnNldFRhcmdldCh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbCAhPT0gbnVsbCkge1xuICAgICAgICAgIGxpbmtOb2RlLnNldFJlbChyZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBhcmVudC5pcyhwcmV2UGFyZW50KSkge1xuICAgICAgICBwcmV2UGFyZW50ID0gcGFyZW50O1xuICAgICAgICBsaW5rTm9kZSA9ICRjcmVhdGVMaW5rTm9kZSh1cmwsIHtcbiAgICAgICAgICByZWwsXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICgkaXNMaW5rTm9kZShwYXJlbnQpKSB7XG4gICAgICAgICAgaWYgKG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobGlua05vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QWZ0ZXIobGlua05vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmluc2VydEJlZm9yZShsaW5rTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCRpc0xpbmtOb2RlKG5vZGUpKSB7XG4gICAgICAgIGlmIChub2RlLmlzKGxpbmtOb2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW5rTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlua05vZGUuYXBwZW5kKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW5rTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBsaW5rTm9kZS5hcHBlbmQobm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gJGdldExpbmtBbmNlc3Rvcihub2RlKSB7XG4gIHJldHVybiAkZ2V0QW5jZXN0b3Iobm9kZSwgYW5jZXN0b3IgPT4gJGlzTGlua05vZGUoYW5jZXN0b3IpKTtcbn1cblxuZnVuY3Rpb24gJGdldEFuY2VzdG9yKG5vZGUsIHByZWRpY2F0ZSkge1xuICBsZXQgcGFyZW50ID0gbm9kZTtcblxuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIChwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCkpICE9PSBudWxsICYmICFwcmVkaWNhdGUocGFyZW50KSk7XG5cbiAgcmV0dXJuIHBhcmVudDtcbn1cblxuZXhwb3J0cy4kY3JlYXRlQXV0b0xpbmtOb2RlID0gJGNyZWF0ZUF1dG9MaW5rTm9kZTtcbmV4cG9ydHMuJGNyZWF0ZUxpbmtOb2RlID0gJGNyZWF0ZUxpbmtOb2RlO1xuZXhwb3J0cy4kaXNBdXRvTGlua05vZGUgPSAkaXNBdXRvTGlua05vZGU7XG5leHBvcnRzLiRpc0xpbmtOb2RlID0gJGlzTGlua05vZGU7XG5leHBvcnRzLkF1dG9MaW5rTm9kZSA9IEF1dG9MaW5rTm9kZTtcbmV4cG9ydHMuTGlua05vZGUgPSBMaW5rTm9kZTtcbmV4cG9ydHMuVE9HR0xFX0xJTktfQ09NTUFORCA9IFRPR0dMRV9MSU5LX0NPTU1BTkQ7XG5leHBvcnRzLnRvZ2dsZUxpbmsgPSB0b2dnbGVMaW5rO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/link/LexicalLink.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/link/LexicalLink.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/link/LexicalLink.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalLink =  true ? __webpack_require__(/*! ./LexicalLink.dev.js */ \"(ssr)/./node_modules/@lexical/link/LexicalLink.dev.js\") : 0\nmodule.exports = LexicalLink;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGluay9MZXhpY2FsTGluay5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLG9CQUFvQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsbUZBQXNCLElBQUksQ0FBZ0M7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9saW5rL0xleGljYWxMaW5rLmpzP2Y2OGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxMaW5rID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxMaW5rLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsTGluay5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbExpbms7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/link/LexicalLink.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/list/LexicalList.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/list/LexicalList.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n\n    return depth;\n  }\n\n  return depth;\n}\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n\n  let parent = list;\n\n  while (parent !== null) {\n    parent = parent.getParent();\n\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n\n  return list;\n}\n\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n\n  return listItemNodes;\n}\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n} // TODO: rewrite with $findMatchingParent or *nodeOfType\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n\n    emptyListPtr = parent;\n  }\n\n  emptyListPtr.remove();\n}\nfunction wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\nfunction $getListItemValue(listItem) {\n  const list = listItem.getParent();\n  let value = 1;\n\n  if (list != null) {\n    if (!$isListNode(list)) {\n      {\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\n      }\n    } else {\n      value = list.getStart();\n    }\n  }\n\n  const siblings = listItem.getPreviousSiblings();\n\n  for (let i = 0; i < siblings.length; i++) {\n    const sibling = siblings[i];\n\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n      value++;\n    }\n  }\n\n  return value;\n}\n\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n\n          if (lexical.$isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n\n        return;\n      } else {\n        const handled = new Set();\n\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\n            createListOrMerge(node, listType);\n            continue;\n          }\n\n          if (lexical.$isLeafNode(node)) {\n            let parent = node.getParent();\n\n            while (parent != null) {\n              const parentKey = parent.getKey();\n\n              if ($isListNode(parent)) {\n                if (!handled.has(parentKey)) {\n                  const newListNode = $createListNode(listType);\n                  append(newListNode, parent.getChildren());\n                  parent.replace(newListNode);\n                  updateChildrenListItemValue(newListNode);\n                  handled.add(parentKey);\n                }\n\n                break;\n              } else {\n                const nextParent = parent.getParent();\n\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                  handled.add(parentKey);\n                  createListOrMerge(parent, listType);\n                  break;\n                }\n\n                parent = nextParent;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\n\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove(); // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    updateChildrenListItemValue(list);\n    return list;\n  }\n}\n\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n\n  const toMerge = list2.getChildren();\n\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n    updateChildrenListItemValue(list1);\n  }\n\n  list2.remove();\n}\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isLeafNode(node)) {\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n\n        for (const listItemNode of listItems) {\n          const paragraph = lexical.$createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph; // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n\n          listItemNode.remove();\n        }\n\n        listNode.remove();\n      }\n    }\n  });\n}\nfunction updateChildrenListItemValue(list, children) {\n  const childrenOrExisting = children || list.getChildren();\n\n  if (childrenOrExisting !== undefined) {\n    for (let i = 0; i < childrenOrExisting.length; i++) {\n      const child = childrenOrExisting[i];\n\n      if ($isListItemNode(child)) {\n        const prevValue = child.getValue();\n        const nextValue = $getListItemValue(child);\n\n        if (prevValue !== nextValue) {\n          child.setValue(nextValue);\n        }\n      }\n    }\n  }\n}\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n\n  const parent = listItemNode.getParent(); // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling(); // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      updateChildrenListItemValue(innerList);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n\n      updateChildrenListItemValue(newList);\n    }\n  }\n\n  if ($isListNode(parent)) {\n    updateChildrenListItemValue(parent);\n  }\n}\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined; // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      } // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings()); // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem); // replace the grandparent list item (now between the siblings) with the outdented list item.\n\n      grandparentListItem.replace(listItemNode);\n    }\n\n    updateChildrenListItemValue(parentList);\n    updateChildrenListItemValue(greatGrandparentList);\n  }\n}\nfunction $handleListInsertParagraph() {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  } // Only run this code on empty list items\n\n\n  const anchor = selection.anchor.getNode();\n\n  if (!$isListItemNode(anchor) || anchor.getTextContent() !== '') {\n    return false;\n  }\n\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n\n  const grandparent = parent.getParent();\n  let replacementNode;\n\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\n    replacementNode = lexical.$createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n\n    if (lexical.$isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  } // Don't leave hanging nested empty lists\n\n\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'listitem';\n  }\n\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    } // @ts-expect-error - this is always HTMLListItemElement\n\n\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static transform() {\n    return node => {\n      const parent = node.getParent();\n\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = new ListItemNode(serializedNode.value, serializedNode.checked);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n\n    return this;\n  }\n\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) return replaceWithNode;\n\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n\n    if (includeChildren) {\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n\n    this.remove();\n\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n\n    return replaceWithNode;\n  }\n\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n\n    const siblings = this.getNextSiblings();\n\n    if ($isListItemNode(node)) {\n      const after = super.insertAfter(node, restoreSelection);\n      const afterListNode = node.getParentOrThrow();\n\n      if ($isListNode(afterListNode)) {\n        updateChildrenListItemValue(afterListNode);\n      }\n\n      return after;\n    } // Attempt to merge if the list is of the same type.\n\n\n    if ($isListNode(node) && node.getListType() === listNode.getListType()) {\n      let child = node;\n      const children = node.getChildren();\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        child = children[i];\n        this.insertAfter(child, restoreSelection);\n      }\n\n      return child;\n    } // Otherwise, split the list\n    // Split the lists and insert the node in between them\n\n\n    listNode.insertAfter(node, restoreSelection);\n\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n\n    return node;\n  }\n\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    } else if (nextSibling) {\n      const parent = nextSibling.getParent();\n\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n      }\n    }\n  }\n\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart(selection) {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove(); // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n\n    return true;\n  }\n\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return this.getLatest().__indent;\n    } // ListItemNode should always have a ListNode for a parent.\n\n\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n\n    return indentLevel;\n  }\n\n  setIndent(indent) {\n    let currentIndent = this.getIndent();\n\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n\n    return this;\n  }\n\n  insertBefore(nodeToInsert) {\n    if ($isListItemNode(nodeToInsert)) {\n      const parent = this.getParentOrThrow();\n\n      if ($isListNode(parent)) {\n        const siblings = this.getNextSiblings();\n        updateChildrenListItemValue(parent, siblings);\n      }\n    }\n\n    return super.insertBefore(nodeToInsert);\n  }\n\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n\n  canMergeWith(node) {\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\n  }\n\n  extractWithChild(child, selection) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n\n  isParentRequired() {\n    return true;\n  }\n\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n\n}\n\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n\n  if (listItemClassName !== undefined) {\n    const listItemClasses = listItemClassName.split(' ');\n    classesToAdd.push(...listItemClasses);\n  }\n\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\n\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\n\nfunction convertListItemElement(domNode) {\n  const checked = utils.isHTMLElement(domNode) && domNode.getAttribute('aria-checked') === 'true';\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\nfunction $createListItemNode(checked) {\n  return lexical.$applyNodeReplacement(new ListItemNode(undefined, checked));\n}\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'list';\n  }\n\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n\n  constructor(listType, start, key) {\n    super(key);\n\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n\n  getTag() {\n    return this.__tag;\n  }\n\n  getListType() {\n    return this.__listType;\n  }\n\n  getStart() {\n    return this.__start;\n  } // View\n\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    } // @ts-expect-error Internal field.\n\n\n    dom.__lexicalListType = this.__listType;\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if (lexical.$isElementNode(currentNode)) {\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n\n        super.append(listItemNode);\n      }\n    }\n\n    updateChildrenListItemValue(this);\n    return this;\n  }\n\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n\n}\n\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n\n    if (listLevelClassName !== undefined) {\n      const listItemClasses = listLevelClassName.split(' ');\n      classesToAdd.push(...listItemClasses);\n\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = nestedListClassName.split(' ');\n\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\n\n\nfunction normalizeChildren(nodes) {\n  const normalizedListItems = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push(wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push(wrapInListItem(node));\n    }\n  }\n\n  return normalizedListItems;\n}\n\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'ol') {\n    node = $createListNode('number');\n  } else if (nodeName === 'ul') {\n    if (utils.isHTMLElement(domNode) && domNode.getAttribute('__lexicallisttype') === 'check') {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n\n  return {\n    after: normalizeChildren,\n    node\n  };\n}\n\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\nfunction $createListNode(listType, start = 1) {\n  return lexical.$applyNodeReplacement(new ListNode(listType, start));\n}\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/** @module @lexical/list */\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = lexical.createCommand('REMOVE_LIST_COMMAND');\n\nexports.$createListItemNode = $createListItemNode;\nexports.$createListNode = $createListNode;\nexports.$getListDepth = $getListDepth;\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\nexports.$isListItemNode = $isListItemNode;\nexports.$isListNode = $isListNode;\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\nexports.ListItemNode = ListItemNode;\nexports.ListNode = ListNode;\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\nexports.insertList = insertList;\nexports.removeList = removeList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGlzdC9MZXhpY2FsTGlzdC5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLHFCQUFxQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLHdCQUF3QixrQkFBa0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixrQkFBa0I7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLFdBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixrQ0FBa0M7QUFDbEMsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQixpQ0FBaUM7QUFDakMsbUNBQW1DO0FBQ25DLHFDQUFxQztBQUNyQyxvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCLDJCQUEyQjtBQUMzQixrQkFBa0I7QUFDbEIsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGlzdC9MZXhpY2FsTGlzdC5kZXYuanM/NjkwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiAkZ2V0TGlzdERlcHRoKGxpc3ROb2RlKSB7XG4gIGxldCBkZXB0aCA9IDE7XG4gIGxldCBwYXJlbnQgPSBsaXN0Tm9kZS5nZXRQYXJlbnQoKTtcblxuICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKHBhcmVudCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudExpc3QgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG5cbiAgICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnRMaXN0KSkge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnRMaXN0LmdldFBhcmVudCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgQSBMaXN0SXRlbU5vZGUgbXVzdCBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZXB0aDtcbiAgfVxuXG4gIHJldHVybiBkZXB0aDtcbn1cbmZ1bmN0aW9uICRnZXRUb3BMaXN0Tm9kZShsaXN0SXRlbSkge1xuICBsZXQgbGlzdCA9IGxpc3RJdGVtLmdldFBhcmVudCgpO1xuXG4gIGlmICghJGlzTGlzdE5vZGUobGlzdCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgQSBMaXN0SXRlbU5vZGUgbXVzdCBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LmApO1xuICAgIH1cbiAgfVxuXG4gIGxldCBwYXJlbnQgPSBsaXN0O1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgbGlzdCA9IHBhcmVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn1cblxuZnVuY3Rpb24gJGdldEFsbExpc3RJdGVtcyhub2RlKSB7XG4gIGxldCBsaXN0SXRlbU5vZGVzID0gW107XG4gIGNvbnN0IGxpc3RDaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKS5maWx0ZXIoJGlzTGlzdEl0ZW1Ob2RlKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpc3RJdGVtTm9kZSA9IGxpc3RDaGlsZHJlbltpXTtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gbGlzdEl0ZW1Ob2RlLmdldEZpcnN0Q2hpbGQoKTtcblxuICAgIGlmICgkaXNMaXN0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgbGlzdEl0ZW1Ob2RlcyA9IGxpc3RJdGVtTm9kZXMuY29uY2F0KCRnZXRBbGxMaXN0SXRlbXMoZmlyc3RDaGlsZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0SXRlbU5vZGVzLnB1c2gobGlzdEl0ZW1Ob2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGlzdEl0ZW1Ob2Rlcztcbn1cbmZ1bmN0aW9uIGlzTmVzdGVkTGlzdE5vZGUobm9kZSkge1xuICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpICYmICRpc0xpc3ROb2RlKG5vZGUuZ2V0Rmlyc3RDaGlsZCgpKTtcbn0gLy8gVE9ETzogcmV3cml0ZSB3aXRoICRmaW5kTWF0Y2hpbmdQYXJlbnQgb3IgKm5vZGVPZlR5cGVcbmZ1bmN0aW9uICRyZW1vdmVIaWdoZXN0RW1wdHlMaXN0UGFyZW50KHN1Ymxpc3QpIHtcbiAgLy8gTm9kZXMgbWF5IGJlIHJlcGVhdGVkbHkgaW5kZW50ZWQsIHRvIGNyZWF0ZSBkZWVwbHkgbmVzdGVkIGxpc3RzIHRoYXQgZWFjaFxuICAvLyBjb250YWluIGp1c3Qgb25lIGJ1bGxldC5cbiAgLy8gT3VyIGdvYWwgaXMgdG8gcmVtb3ZlIHRoZXNlIChlbXB0eSkgZGVlcGx5IG5lc3RlZCBsaXN0cy4gVGhlIGVhc2llc3RcbiAgLy8gd2F5IHRvIGRvIHRoYXQgaXMgY3Jhd2wgYmFjayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGEgbm9kZSB0aGF0IGhhcyBzaWJsaW5nc1xuICAvLyAoZS5nLiBpcyBhY3R1YWxseSBwYXJ0IG9mIHRoZSBsaXN0IGNvbnRlbnRzKSBhbmQgZGVsZXRlIHRoYXQsIG9yIGRlbGV0ZVxuICAvLyB0aGUgcm9vdCBvZiB0aGUgbGlzdCAoaWYgbm8gbGlzdCBub2RlcyBoYXZlIHNpYmxpbmdzLilcbiAgbGV0IGVtcHR5TGlzdFB0ciA9IHN1Ymxpc3Q7XG5cbiAgd2hpbGUgKGVtcHR5TGlzdFB0ci5nZXROZXh0U2libGluZygpID09IG51bGwgJiYgZW1wdHlMaXN0UHRyLmdldFByZXZpb3VzU2libGluZygpID09IG51bGwpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBlbXB0eUxpc3RQdHIuZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAocGFyZW50ID09IG51bGwgfHwgISgkaXNMaXN0SXRlbU5vZGUoZW1wdHlMaXN0UHRyKSB8fCAkaXNMaXN0Tm9kZShlbXB0eUxpc3RQdHIpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgZW1wdHlMaXN0UHRyID0gcGFyZW50O1xuICB9XG5cbiAgZW1wdHlMaXN0UHRyLnJlbW92ZSgpO1xufVxuZnVuY3Rpb24gd3JhcEluTGlzdEl0ZW0obm9kZSkge1xuICBjb25zdCBsaXN0SXRlbVdyYXBwZXIgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gIHJldHVybiBsaXN0SXRlbVdyYXBwZXIuYXBwZW5kKG5vZGUpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uICRpc1NlbGVjdGluZ0VtcHR5TGlzdEl0ZW0oYW5jaG9yTm9kZSwgbm9kZXMpIHtcbiAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShhbmNob3JOb2RlKSAmJiAobm9kZXMubGVuZ3RoID09PSAwIHx8IG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBhbmNob3JOb2RlLmlzKG5vZGVzWzBdKSAmJiBhbmNob3JOb2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKTtcbn1cblxuZnVuY3Rpb24gJGdldExpc3RJdGVtVmFsdWUobGlzdEl0ZW0pIHtcbiAgY29uc3QgbGlzdCA9IGxpc3RJdGVtLmdldFBhcmVudCgpO1xuICBsZXQgdmFsdWUgPSAxO1xuXG4gIGlmIChsaXN0ICE9IG51bGwpIHtcbiAgICBpZiAoISRpc0xpc3ROb2RlKGxpc3QpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGAkZ2V0TGlzdEl0ZW1WYWx1ZTogbGlzdCBub2RlIGlzIG5vdCBwYXJlbnQgb2YgbGlzdCBpdGVtIG5vZGVgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBsaXN0LmdldFN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2libGluZ3MgPSBsaXN0SXRlbS5nZXRQcmV2aW91c1NpYmxpbmdzKCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWJsaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNpYmxpbmcgPSBzaWJsaW5nc1tpXTtcblxuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUoc2libGluZykgJiYgISRpc0xpc3ROb2RlKHNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpKSkge1xuICAgICAgdmFsdWUrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGluc2VydExpc3QoZWRpdG9yLCBsaXN0VHlwZSkge1xuICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGVQYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAoJGlzU2VsZWN0aW5nRW1wdHlMaXN0SXRlbShhbmNob3JOb2RlLCBub2RlcykpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG5cbiAgICAgICAgaWYgKGxleGljYWwuJGlzUm9vdE9yU2hhZG93Um9vdChhbmNob3JOb2RlUGFyZW50KSkge1xuICAgICAgICAgIGFuY2hvck5vZGUucmVwbGFjZShsaXN0KTtcbiAgICAgICAgICBjb25zdCBsaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcblxuICAgICAgICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICBsaXN0SXRlbS5zZXRGb3JtYXQoYW5jaG9yTm9kZS5nZXRGb3JtYXRUeXBlKCkpO1xuICAgICAgICAgICAgbGlzdEl0ZW0uc2V0SW5kZW50KGFuY2hvck5vZGUuZ2V0SW5kZW50KCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3QuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICAgICAgfSBlbHNlIGlmICgkaXNMaXN0SXRlbU5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgICBhcHBlbmQobGlzdCwgcGFyZW50LmdldENoaWxkcmVuKCkpO1xuICAgICAgICAgIHBhcmVudC5yZXBsYWNlKGxpc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaGFuZGxlZCA9IG5ldyBTZXQoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICAgICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0VtcHR5KCkgJiYgIWhhbmRsZWQuaGFzKG5vZGUuZ2V0S2V5KCkpKSB7XG4gICAgICAgICAgICBjcmVhdGVMaXN0T3JNZXJnZShub2RlLCBsaXN0VHlwZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGV4aWNhbC4kaXNMZWFmTm9kZShub2RlKSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJlbnRLZXkgPSBwYXJlbnQuZ2V0S2V5KCk7XG5cbiAgICAgICAgICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZWQuaGFzKHBhcmVudEtleSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xpc3ROb2RlID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICAgICAgICAgICAgICAgIGFwcGVuZChuZXdMaXN0Tm9kZSwgcGFyZW50LmdldENoaWxkcmVuKCkpO1xuICAgICAgICAgICAgICAgICAgcGFyZW50LnJlcGxhY2UobmV3TGlzdE5vZGUpO1xuICAgICAgICAgICAgICAgICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKG5ld0xpc3ROb2RlKTtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZWQuYWRkKHBhcmVudEtleSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChsZXhpY2FsLiRpc1Jvb3RPclNoYWRvd1Jvb3QobmV4dFBhcmVudCkgJiYgIWhhbmRsZWQuaGFzKHBhcmVudEtleSkpIHtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZWQuYWRkKHBhcmVudEtleSk7XG4gICAgICAgICAgICAgICAgICBjcmVhdGVMaXN0T3JNZXJnZShwYXJlbnQsIGxpc3RUeXBlKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5leHRQYXJlbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhcHBlbmQobm9kZSwgbm9kZXNUb0FwcGVuZCkge1xuICBub2RlLnNwbGljZShub2RlLmdldENoaWxkcmVuU2l6ZSgpLCAwLCBub2Rlc1RvQXBwZW5kKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlzdE9yTWVyZ2Uobm9kZSwgbGlzdFR5cGUpIHtcbiAgaWYgKCRpc0xpc3ROb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgY29uc3QgbGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gIGxpc3RJdGVtLnNldEZvcm1hdChub2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gIGxpc3RJdGVtLnNldEluZGVudChub2RlLmdldEluZGVudCgpKTtcbiAgYXBwZW5kKGxpc3RJdGVtLCBub2RlLmdldENoaWxkcmVuKCkpO1xuXG4gIGlmICgkaXNMaXN0Tm9kZShwcmV2aW91c1NpYmxpbmcpICYmIGxpc3RUeXBlID09PSBwcmV2aW91c1NpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgIHByZXZpb3VzU2libGluZy5hcHBlbmQobGlzdEl0ZW0pO1xuICAgIG5vZGUucmVtb3ZlKCk7IC8vIGlmIHRoZSBzYW1lIHR5cGUgb2YgbGlzdCBpcyBvbiBib3RoIHNpZGVzLCBtZXJnZSB0aGVtLlxuXG4gICAgaWYgKCRpc0xpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBsaXN0VHlwZSA9PT0gbmV4dFNpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgICAgYXBwZW5kKHByZXZpb3VzU2libGluZywgbmV4dFNpYmxpbmcuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICBuZXh0U2libGluZy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJldmlvdXNTaWJsaW5nO1xuICB9IGVsc2UgaWYgKCRpc0xpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBsaXN0VHlwZSA9PT0gbmV4dFNpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgIG5leHRTaWJsaW5nLmdldEZpcnN0Q2hpbGRPclRocm93KCkuaW5zZXJ0QmVmb3JlKGxpc3RJdGVtKTtcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIHJldHVybiBuZXh0U2libGluZztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICBsaXN0LmFwcGVuZChsaXN0SXRlbSk7XG4gICAgbm9kZS5yZXBsYWNlKGxpc3QpO1xuICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShsaXN0KTtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUxpc3RzKGxpc3QxLCBsaXN0Mikge1xuICBjb25zdCBsaXN0SXRlbTEgPSBsaXN0MS5nZXRMYXN0Q2hpbGQoKTtcbiAgY29uc3QgbGlzdEl0ZW0yID0gbGlzdDIuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gIGlmIChsaXN0SXRlbTEgJiYgbGlzdEl0ZW0yICYmIGlzTmVzdGVkTGlzdE5vZGUobGlzdEl0ZW0xKSAmJiBpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtMikpIHtcbiAgICBtZXJnZUxpc3RzKGxpc3RJdGVtMS5nZXRGaXJzdENoaWxkKCksIGxpc3RJdGVtMi5nZXRGaXJzdENoaWxkKCkpO1xuICAgIGxpc3RJdGVtMi5yZW1vdmUoKTtcbiAgfVxuXG4gIGNvbnN0IHRvTWVyZ2UgPSBsaXN0Mi5nZXRDaGlsZHJlbigpO1xuXG4gIGlmICh0b01lcmdlLmxlbmd0aCA+IDApIHtcbiAgICBsaXN0MS5hcHBlbmQoLi4udG9NZXJnZSk7XG4gICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKGxpc3QxKTtcbiAgfVxuXG4gIGxpc3QyLnJlbW92ZSgpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdChlZGl0b3IpIHtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBsaXN0Tm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuXG4gICAgICBpZiAoJGlzU2VsZWN0aW5nRW1wdHlMaXN0SXRlbShhbmNob3JOb2RlLCBub2RlcykpIHtcbiAgICAgICAgbGlzdE5vZGVzLmFkZCgkZ2V0VG9wTGlzdE5vZGUoYW5jaG9yTm9kZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgICAgIGlmIChsZXhpY2FsLiRpc0xlYWZOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0SXRlbU5vZGUgPSB1dGlscy4kZ2V0TmVhcmVzdE5vZGVPZlR5cGUobm9kZSwgTGlzdEl0ZW1Ob2RlKTtcblxuICAgICAgICAgICAgaWYgKGxpc3RJdGVtTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGxpc3ROb2Rlcy5hZGQoJGdldFRvcExpc3ROb2RlKGxpc3RJdGVtTm9kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGxpc3ROb2RlIG9mIGxpc3ROb2Rlcykge1xuICAgICAgICBsZXQgaW5zZXJ0aW9uUG9pbnQgPSBsaXN0Tm9kZTtcbiAgICAgICAgY29uc3QgbGlzdEl0ZW1zID0gJGdldEFsbExpc3RJdGVtcyhsaXN0Tm9kZSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBsaXN0SXRlbU5vZGUgb2YgbGlzdEl0ZW1zKSB7XG4gICAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICAgIGFwcGVuZChwYXJhZ3JhcGgsIGxpc3RJdGVtTm9kZS5nZXRDaGlsZHJlbigpKTtcbiAgICAgICAgICBpbnNlcnRpb25Qb2ludC5pbnNlcnRBZnRlcihwYXJhZ3JhcGgpO1xuICAgICAgICAgIGluc2VydGlvblBvaW50ID0gcGFyYWdyYXBoOyAvLyBXaGVuIHRoZSBhbmNob3IgYW5kIGZvY3VzIGZhbGwgb24gdGhlIHRleHROb2RlXG4gICAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgdGhlIHNlbGVjdGlvbiBiZWNhdXNlIHRoZSB0ZXh0Tm9kZSB3aWxsIGJlIGFwcGVuZGVkIHRvXG4gICAgICAgICAgLy8gdGhlIG5ld2x5IGdlbmVyYXRlZCBwYXJhZ3JhcGguXG4gICAgICAgICAgLy8gV2hlbiBzZWxlY3Rpb24gaXMgaW4gZW1wdHkgbmVzdGVkIGxpc3QgaXRlbSwgc2VsZWN0aW9uIGlzIGFjdHVhbGx5IG9uIHRoZSBsaXN0SXRlbU5vZGUuXG4gICAgICAgICAgLy8gV2hlbiB0aGUgY29ycmVzcG9uZGluZyBsaXN0SXRlbU5vZGUgaXMgZGVsZXRlZCBhbmQgcmVwbGFjZWQgYnkgdGhlIG5ld2x5IGdlbmVyYXRlZCBwYXJhZ3JhcGhcbiAgICAgICAgICAvLyB3ZSBzaG91bGQgbWFudWFsbHkgc2V0IHRoZSBzZWxlY3Rpb24ncyBmb2N1cyBhbmQgYW5jaG9yIHRvIHRoZSBuZXdseSBnZW5lcmF0ZWQgcGFyYWdyYXBoLlxuXG4gICAgICAgICAgaWYgKGxpc3RJdGVtTm9kZS5fX2tleSA9PT0gc2VsZWN0aW9uLmFuY2hvci5rZXkpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hbmNob3Iuc2V0KHBhcmFncmFwaC5nZXRLZXkoKSwgMCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGlzdEl0ZW1Ob2RlLl9fa2V5ID09PSBzZWxlY3Rpb24uZm9jdXMua2V5KSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXMuc2V0KHBhcmFncmFwaC5nZXRLZXkoKSwgMCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0SXRlbU5vZGUucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKGxpc3QsIGNoaWxkcmVuKSB7XG4gIGNvbnN0IGNoaWxkcmVuT3JFeGlzdGluZyA9IGNoaWxkcmVuIHx8IGxpc3QuZ2V0Q2hpbGRyZW4oKTtcblxuICBpZiAoY2hpbGRyZW5PckV4aXN0aW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuT3JFeGlzdGluZy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbk9yRXhpc3RpbmdbaV07XG5cbiAgICAgIGlmICgkaXNMaXN0SXRlbU5vZGUoY2hpbGQpKSB7XG4gICAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IGNoaWxkLmdldFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9ICRnZXRMaXN0SXRlbVZhbHVlKGNoaWxkKTtcblxuICAgICAgICBpZiAocHJldlZhbHVlICE9PSBuZXh0VmFsdWUpIHtcbiAgICAgICAgICBjaGlsZC5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkaGFuZGxlSW5kZW50KGxpc3RJdGVtTm9kZSkge1xuICAvLyBnbyB0aHJvdWdoIGVhY2ggbm9kZSBhbmQgZGVjaWRlIHdoZXJlIHRvIG1vdmUgaXQuXG4gIGNvbnN0IHJlbW92ZWQgPSBuZXcgU2V0KCk7XG5cbiAgaWYgKGlzTmVzdGVkTGlzdE5vZGUobGlzdEl0ZW1Ob2RlKSB8fCByZW1vdmVkLmhhcyhsaXN0SXRlbU5vZGUuZ2V0S2V5KCkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGFyZW50ID0gbGlzdEl0ZW1Ob2RlLmdldFBhcmVudCgpOyAvLyBXZSBjYW4gY2FzdCBib3RoIG9mIHRoZSBiZWxvdyBgaXNOZXN0ZWRMaXN0Tm9kZWAgb25seSByZXR1cm5zIGEgYm9vbGVhbiB0eXBlIGluc3RlYWQgb2YgYSB1c2VyLWRlZmluZWQgdHlwZSBndWFyZHNcblxuICBjb25zdCBuZXh0U2libGluZyA9IGxpc3RJdGVtTm9kZS5nZXROZXh0U2libGluZygpO1xuICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBsaXN0SXRlbU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7IC8vIGlmIHRoZXJlIGFyZSBuZXN0ZWQgbGlzdHMgb24gZWl0aGVyIHNpZGUsIG1lcmdlIHRoZW0gYWxsIHRvZ2V0aGVyLlxuXG4gIGlmIChpc05lc3RlZExpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBpc05lc3RlZExpc3ROb2RlKHByZXZpb3VzU2libGluZykpIHtcbiAgICBjb25zdCBpbm5lckxpc3QgPSBwcmV2aW91c1NpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgaWYgKCRpc0xpc3ROb2RlKGlubmVyTGlzdCkpIHtcbiAgICAgIGlubmVyTGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGNvbnN0IG5leHRJbm5lckxpc3QgPSBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICAgIGlmICgkaXNMaXN0Tm9kZShuZXh0SW5uZXJMaXN0KSkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5leHRJbm5lckxpc3QuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgYXBwZW5kKGlubmVyTGlzdCwgY2hpbGRyZW4pO1xuICAgICAgICBuZXh0U2libGluZy5yZW1vdmUoKTtcbiAgICAgICAgcmVtb3ZlZC5hZGQobmV4dFNpYmxpbmcuZ2V0S2V5KCkpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUoaW5uZXJMaXN0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAvLyBpZiB0aGUgTGlzdEl0ZW1Ob2RlIGlzIG5leHQgdG8gYSBuZXN0ZWQgTGlzdE5vZGUsIG1lcmdlIHRoZW1cbiAgICBjb25zdCBpbm5lckxpc3QgPSBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICBpZiAoJGlzTGlzdE5vZGUoaW5uZXJMaXN0KSkge1xuICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGlubmVyTGlzdC5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKGxpc3RJdGVtTm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShpbm5lckxpc3QpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc05lc3RlZExpc3ROb2RlKHByZXZpb3VzU2libGluZykpIHtcbiAgICBjb25zdCBpbm5lckxpc3QgPSBwcmV2aW91c1NpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgaWYgKCRpc0xpc3ROb2RlKGlubmVyTGlzdCkpIHtcbiAgICAgIGlubmVyTGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShpbm5lckxpc3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UsIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IG5lc3RlZCBMaXN0Tm9kZVxuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICBjb25zdCBuZXdMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgIGNvbnN0IG5ld0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUocGFyZW50LmdldExpc3RUeXBlKCkpO1xuICAgICAgbmV3TGlzdEl0ZW0uYXBwZW5kKG5ld0xpc3QpO1xuICAgICAgbmV3TGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcblxuICAgICAgaWYgKHByZXZpb3VzU2libGluZykge1xuICAgICAgICBwcmV2aW91c1NpYmxpbmcuaW5zZXJ0QWZ0ZXIobmV3TGlzdEl0ZW0pO1xuICAgICAgfSBlbHNlIGlmIChuZXh0U2libGluZykge1xuICAgICAgICBuZXh0U2libGluZy5pbnNlcnRCZWZvcmUobmV3TGlzdEl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50LmFwcGVuZChuZXdMaXN0SXRlbSk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShuZXdMaXN0KTtcbiAgICB9XG4gIH1cblxuICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShwYXJlbnQpO1xuICB9XG59XG5mdW5jdGlvbiAkaGFuZGxlT3V0ZGVudChsaXN0SXRlbU5vZGUpIHtcbiAgLy8gZ28gdGhyb3VnaCBlYWNoIG5vZGUgYW5kIGRlY2lkZSB3aGVyZSB0byBtb3ZlIGl0LlxuICBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbU5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGFyZW50TGlzdCA9IGxpc3RJdGVtTm9kZS5nZXRQYXJlbnQoKTtcbiAgY29uc3QgZ3JhbmRwYXJlbnRMaXN0SXRlbSA9IHBhcmVudExpc3QgPyBwYXJlbnRMaXN0LmdldFBhcmVudCgpIDogdW5kZWZpbmVkO1xuICBjb25zdCBncmVhdEdyYW5kcGFyZW50TGlzdCA9IGdyYW5kcGFyZW50TGlzdEl0ZW0gPyBncmFuZHBhcmVudExpc3RJdGVtLmdldFBhcmVudCgpIDogdW5kZWZpbmVkOyAvLyBJZiBpdCBkb2Vzbid0IGhhdmUgdGhlc2UgYW5jZXN0b3JzLCBpdCdzIG5vdCBpbmRlbnRlZC5cblxuICBpZiAoJGlzTGlzdE5vZGUoZ3JlYXRHcmFuZHBhcmVudExpc3QpICYmICRpc0xpc3RJdGVtTm9kZShncmFuZHBhcmVudExpc3RJdGVtKSAmJiAkaXNMaXN0Tm9kZShwYXJlbnRMaXN0KSkge1xuICAgIC8vIGlmIGl0J3MgdGhlIGZpcnN0IGNoaWxkIGluIGl0J3MgcGFyZW50IGxpc3QsIGluc2VydCBpdCBpbnRvIHRoZVxuICAgIC8vIGdyZWF0IGdyYW5kcGFyZW50IGxpc3QgYmVmb3JlIHRoZSBncmFuZHBhcmVudFxuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJlbnRMaXN0ID8gcGFyZW50TGlzdC5nZXRGaXJzdENoaWxkKCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGFzdENoaWxkID0gcGFyZW50TGlzdCA/IHBhcmVudExpc3QuZ2V0TGFzdENoaWxkKCkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAobGlzdEl0ZW1Ob2RlLmlzKGZpcnN0Q2hpbGQpKSB7XG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLmluc2VydEJlZm9yZShsaXN0SXRlbU5vZGUpO1xuXG4gICAgICBpZiAocGFyZW50TGlzdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5yZW1vdmUoKTtcbiAgICAgIH0gLy8gaWYgaXQncyB0aGUgbGFzdCBjaGlsZCBpbiBpdCdzIHBhcmVudCBsaXN0LCBpbnNlcnQgaXQgaW50byB0aGVcbiAgICAgIC8vIGdyZWF0IGdyYW5kcGFyZW50IGxpc3QgYWZ0ZXIgdGhlIGdyYW5kcGFyZW50LlxuXG4gICAgfSBlbHNlIGlmIChsaXN0SXRlbU5vZGUuaXMobGFzdENoaWxkKSkge1xuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5pbnNlcnRBZnRlcihsaXN0SXRlbU5vZGUpO1xuXG4gICAgICBpZiAocGFyZW50TGlzdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIHNwbGl0IHRoZSBzaWJsaW5ncyBpbnRvIHR3byBuZXcgbmVzdGVkIGxpc3RzXG4gICAgICBjb25zdCBsaXN0VHlwZSA9IHBhcmVudExpc3QuZ2V0TGlzdFR5cGUoKTtcbiAgICAgIGNvbnN0IHByZXZpb3VzU2libGluZ3NMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgIGNvbnN0IHByZXZpb3VzU2libGluZ3NMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICAgIHByZXZpb3VzU2libGluZ3NMaXN0SXRlbS5hcHBlbmQocHJldmlvdXNTaWJsaW5nc0xpc3QpO1xuICAgICAgbGlzdEl0ZW1Ob2RlLmdldFByZXZpb3VzU2libGluZ3MoKS5mb3JFYWNoKHNpYmxpbmcgPT4gcHJldmlvdXNTaWJsaW5nc0xpc3QuYXBwZW5kKHNpYmxpbmcpKTtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nc0xpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmdzTGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgICBuZXh0U2libGluZ3NMaXN0SXRlbS5hcHBlbmQobmV4dFNpYmxpbmdzTGlzdCk7XG4gICAgICBhcHBlbmQobmV4dFNpYmxpbmdzTGlzdCwgbGlzdEl0ZW1Ob2RlLmdldE5leHRTaWJsaW5ncygpKTsgLy8gcHV0IHRoZSBzaWJsaW5nIG5lc3RlZCBsaXN0cyBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgZ3JhbmRwYXJlbnQgbGlzdCBpdGVtIGluIHRoZSBncmVhdCBncmFuZHBhcmVudC5cblxuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5pbnNlcnRCZWZvcmUocHJldmlvdXNTaWJsaW5nc0xpc3RJdGVtKTtcbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QWZ0ZXIobmV4dFNpYmxpbmdzTGlzdEl0ZW0pOyAvLyByZXBsYWNlIHRoZSBncmFuZHBhcmVudCBsaXN0IGl0ZW0gKG5vdyBiZXR3ZWVuIHRoZSBzaWJsaW5ncykgd2l0aCB0aGUgb3V0ZGVudGVkIGxpc3QgaXRlbS5cblxuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5yZXBsYWNlKGxpc3RJdGVtTm9kZSk7XG4gICAgfVxuXG4gICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKHBhcmVudExpc3QpO1xuICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShncmVhdEdyYW5kcGFyZW50TGlzdCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRoYW5kbGVMaXN0SW5zZXJ0UGFyYWdyYXBoKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gT25seSBydW4gdGhpcyBjb2RlIG9uIGVtcHR5IGxpc3QgaXRlbXNcblxuXG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuXG4gIGlmICghJGlzTGlzdEl0ZW1Ob2RlKGFuY2hvcikgfHwgYW5jaG9yLmdldFRleHRDb250ZW50KCkgIT09ICcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgdG9wTGlzdE5vZGUgPSAkZ2V0VG9wTGlzdE5vZGUoYW5jaG9yKTtcbiAgY29uc3QgcGFyZW50ID0gYW5jaG9yLmdldFBhcmVudCgpO1xuXG4gIGlmICghJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgIHRocm93IEVycm9yKGBBIExpc3RJdGVtTm9kZSBtdXN0IGhhdmUgYSBMaXN0Tm9kZSBmb3IgYSBwYXJlbnQuYCk7XG4gIH1cblxuICBjb25zdCBncmFuZHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgbGV0IHJlcGxhY2VtZW50Tm9kZTtcblxuICBpZiAobGV4aWNhbC4kaXNSb290T3JTaGFkb3dSb290KGdyYW5kcGFyZW50KSkge1xuICAgIHJlcGxhY2VtZW50Tm9kZSA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICB0b3BMaXN0Tm9kZS5pbnNlcnRBZnRlcihyZXBsYWNlbWVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCRpc0xpc3RJdGVtTm9kZShncmFuZHBhcmVudCkpIHtcbiAgICByZXBsYWNlbWVudE5vZGUgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgZ3JhbmRwYXJlbnQuaW5zZXJ0QWZ0ZXIocmVwbGFjZW1lbnROb2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXBsYWNlbWVudE5vZGUuc2VsZWN0KCk7XG4gIGNvbnN0IG5leHRTaWJsaW5ncyA9IGFuY2hvci5nZXROZXh0U2libGluZ3MoKTtcblxuICBpZiAobmV4dFNpYmxpbmdzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBuZXdMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKHBhcmVudC5nZXRMaXN0VHlwZSgpKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1BhcmFncmFwaE5vZGUocmVwbGFjZW1lbnROb2RlKSkge1xuICAgICAgcmVwbGFjZW1lbnROb2RlLmluc2VydEFmdGVyKG5ld0xpc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXdMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgIG5ld0xpc3RJdGVtLmFwcGVuZChuZXdMaXN0KTtcbiAgICAgIHJlcGxhY2VtZW50Tm9kZS5pbnNlcnRBZnRlcihuZXdMaXN0SXRlbSk7XG4gICAgfVxuXG4gICAgbmV4dFNpYmxpbmdzLmZvckVhY2goc2libGluZyA9PiB7XG4gICAgICBzaWJsaW5nLnJlbW92ZSgpO1xuICAgICAgbmV3TGlzdC5hcHBlbmQoc2libGluZyk7XG4gICAgfSk7XG4gIH0gLy8gRG9uJ3QgbGVhdmUgaGFuZ2luZyBuZXN0ZWQgZW1wdHkgbGlzdHNcblxuXG4gICRyZW1vdmVIaWdoZXN0RW1wdHlMaXN0UGFyZW50KGFuY2hvcik7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBMaXN0SXRlbU5vZGUgZXh0ZW5kcyBsZXhpY2FsLkVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdsaXN0aXRlbSc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgTGlzdEl0ZW1Ob2RlKG5vZGUuX192YWx1ZSwgbm9kZS5fX2NoZWNrZWQsIG5vZGUuX19rZXkpO1xuICB9XG5cbiAgY29uc3RydWN0b3IodmFsdWUsIGNoZWNrZWQsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX3ZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IDEgOiB2YWx1ZTtcbiAgICB0aGlzLl9fY2hlY2tlZCA9IGNoZWNrZWQ7XG4gIH1cblxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcblxuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpICYmIHBhcmVudC5nZXRMaXN0VHlwZSgpID09PSAnY2hlY2snKSB7XG4gICAgICB1cGRhdGVMaXN0SXRlbUNoZWNrZWQoZWxlbWVudCwgdGhpcywgbnVsbCk7XG4gICAgfVxuXG4gICAgZWxlbWVudC52YWx1ZSA9IHRoaXMuX192YWx1ZTtcbiAgICAkc2V0TGlzdEl0ZW1UaGVtZUNsYXNzTmFtZXMoZWxlbWVudCwgY29uZmlnLnRoZW1lLCB0aGlzKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkgJiYgcGFyZW50LmdldExpc3RUeXBlKCkgPT09ICdjaGVjaycpIHtcbiAgICAgIHVwZGF0ZUxpc3RJdGVtQ2hlY2tlZChkb20sIHRoaXMsIHByZXZOb2RlKTtcbiAgICB9IC8vIEB0cy1leHBlY3QtZXJyb3IgLSB0aGlzIGlzIGFsd2F5cyBIVE1MTGlzdEl0ZW1FbGVtZW50XG5cblxuICAgIGRvbS52YWx1ZSA9IHRoaXMuX192YWx1ZTtcbiAgICAkc2V0TGlzdEl0ZW1UaGVtZUNsYXNzTmFtZXMoZG9tLCBjb25maWcudGhlbWUsIHRoaXMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyB0cmFuc2Zvcm0oKSB7XG4gICAgcmV0dXJuIG5vZGUgPT4ge1xuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcblxuICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKHBhcmVudCk7XG5cbiAgICAgICAgaWYgKHBhcmVudC5nZXRMaXN0VHlwZSgpICE9PSAnY2hlY2snICYmIG5vZGUuZ2V0Q2hlY2tlZCgpICE9IG51bGwpIHtcbiAgICAgICAgICBub2RlLnNldENoZWNrZWQodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaTogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0TGlzdEl0ZW1FbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gbmV3IExpc3RJdGVtTm9kZShzZXJpYWxpemVkTm9kZS52YWx1ZSwgc2VyaWFsaXplZE5vZGUuY2hlY2tlZCk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldEluZGVudChzZXJpYWxpemVkTm9kZS5pbmRlbnQpO1xuICAgIG5vZGUuc2V0RGlyZWN0aW9uKHNlcmlhbGl6ZWROb2RlLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGNoZWNrZWQ6IHRoaXMuZ2V0Q2hlY2tlZCgpLFxuICAgICAgdHlwZTogJ2xpc3RpdGVtJyxcbiAgICAgIHZhbHVlOiB0aGlzLmdldFZhbHVlKCksXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIGFwcGVuZCguLi5ub2Rlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgdGhpcy5jYW5NZXJnZVdpdGgobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuYXBwZW5kKC4uLmNoaWxkcmVuKTtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlcGxhY2UocmVwbGFjZVdpdGhOb2RlLCBpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKHJlcGxhY2VXaXRoTm9kZSkpIHtcbiAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKHJlcGxhY2VXaXRoTm9kZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRJbmRlbnQoMCk7XG4gICAgY29uc3QgbGlzdCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGlmICghJGlzTGlzdE5vZGUobGlzdCkpIHJldHVybiByZXBsYWNlV2l0aE5vZGU7XG5cbiAgICBpZiAobGlzdC5fX2ZpcnN0ID09PSB0aGlzLmdldEtleSgpKSB7XG4gICAgICBsaXN0Lmluc2VydEJlZm9yZShyZXBsYWNlV2l0aE5vZGUpO1xuICAgIH0gZWxzZSBpZiAobGlzdC5fX2xhc3QgPT09IHRoaXMuZ2V0S2V5KCkpIHtcbiAgICAgIGxpc3QuaW5zZXJ0QWZ0ZXIocmVwbGFjZVdpdGhOb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3BsaXQgdGhlIGxpc3RcbiAgICAgIGNvbnN0IG5ld0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdC5nZXRMaXN0VHlwZSgpKTtcbiAgICAgIGxldCBuZXh0U2libGluZyA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgd2hpbGUgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgIGNvbnN0IG5vZGVUb0FwcGVuZCA9IG5leHRTaWJsaW5nO1xuICAgICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIG5ld0xpc3QuYXBwZW5kKG5vZGVUb0FwcGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGxpc3QuaW5zZXJ0QWZ0ZXIocmVwbGFjZVdpdGhOb2RlKTtcbiAgICAgIHJlcGxhY2VXaXRoTm9kZS5pbnNlcnRBZnRlcihuZXdMaXN0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgICB0aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIHJlcGxhY2VXaXRoTm9kZS5hcHBlbmQoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmUoKTtcblxuICAgIGlmIChsaXN0LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBsaXN0LnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXBsYWNlV2l0aE5vZGU7XG4gIH1cblxuICBpbnNlcnRBZnRlcihub2RlLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGxpc3ROb2RlID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgICBpZiAoISRpc0xpc3ROb2RlKGxpc3ROb2RlKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0QWZ0ZXI6IGxpc3Qgbm9kZSBpcyBub3QgcGFyZW50IG9mIGxpc3QgaXRlbSBub2RlYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLmdldE5leHRTaWJsaW5ncygpO1xuXG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShub2RlKSkge1xuICAgICAgY29uc3QgYWZ0ZXIgPSBzdXBlci5pbnNlcnRBZnRlcihub2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICAgIGNvbnN0IGFmdGVyTGlzdE5vZGUgPSBub2RlLmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgICAgaWYgKCRpc0xpc3ROb2RlKGFmdGVyTGlzdE5vZGUpKSB7XG4gICAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShhZnRlckxpc3ROb2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFmdGVyO1xuICAgIH0gLy8gQXR0ZW1wdCB0byBtZXJnZSBpZiB0aGUgbGlzdCBpcyBvZiB0aGUgc2FtZSB0eXBlLlxuXG5cbiAgICBpZiAoJGlzTGlzdE5vZGUobm9kZSkgJiYgbm9kZS5nZXRMaXN0VHlwZSgpID09PSBsaXN0Tm9kZS5nZXRMaXN0VHlwZSgpKSB7XG4gICAgICBsZXQgY2hpbGQgPSBub2RlO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICB0aGlzLmluc2VydEFmdGVyKGNoaWxkLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0gLy8gT3RoZXJ3aXNlLCBzcGxpdCB0aGUgbGlzdFxuICAgIC8vIFNwbGl0IHRoZSBsaXN0cyBhbmQgaW5zZXJ0IHRoZSBub2RlIGluIGJldHdlZW4gdGhlbVxuXG5cbiAgICBsaXN0Tm9kZS5pbnNlcnRBZnRlcihub2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcblxuICAgIGlmIChzaWJsaW5ncy5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IG5ld0xpc3ROb2RlID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3ROb2RlLmdldExpc3RUeXBlKCkpO1xuICAgICAgc2libGluZ3MuZm9yRWFjaChzaWJsaW5nID0+IG5ld0xpc3ROb2RlLmFwcGVuZChzaWJsaW5nKSk7XG4gICAgICBub2RlLmluc2VydEFmdGVyKG5ld0xpc3ROb2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJlbW92ZShwcmVzZXJ2ZUVtcHR5UGFyZW50KSB7XG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSB0aGlzLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgIHN1cGVyLnJlbW92ZShwcmVzZXJ2ZUVtcHR5UGFyZW50KTtcblxuICAgIGlmIChwcmV2U2libGluZyAmJiBuZXh0U2libGluZyAmJiBpc05lc3RlZExpc3ROb2RlKHByZXZTaWJsaW5nKSAmJiBpc05lc3RlZExpc3ROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgbWVyZ2VMaXN0cyhwcmV2U2libGluZy5nZXRGaXJzdENoaWxkKCksIG5leHRTaWJsaW5nLmdldEZpcnN0Q2hpbGQoKSk7XG4gICAgICBuZXh0U2libGluZy5yZW1vdmUoKTtcbiAgICB9IGVsc2UgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBuZXh0U2libGluZy5nZXRQYXJlbnQoKTtcblxuICAgICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5zZXJ0TmV3QWZ0ZXIoXywgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBuZXdFbGVtZW50ID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSh0aGlzLl9fY2hlY2tlZCA9PSBudWxsID8gdW5kZWZpbmVkIDogZmFsc2UpO1xuICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobmV3RWxlbWVudCwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cblxuICBjb2xsYXBzZUF0U3RhcnQoc2VsZWN0aW9uKSB7XG4gICAgY29uc3QgcGFyYWdyYXBoID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gcGFyYWdyYXBoLmFwcGVuZChjaGlsZCkpO1xuICAgIGNvbnN0IGxpc3ROb2RlID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgY29uc3QgbGlzdE5vZGVQYXJlbnQgPSBsaXN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgY29uc3QgaXNJbmRlbnRlZCA9ICRpc0xpc3RJdGVtTm9kZShsaXN0Tm9kZVBhcmVudCk7XG5cbiAgICBpZiAobGlzdE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDEpIHtcbiAgICAgIGlmIChpc0luZGVudGVkKSB7XG4gICAgICAgIC8vIGlmIHRoZSBsaXN0IG5vZGUgaXMgbmVzdGVkLCB3ZSBqdXN0IHdhbnQgdG8gcmVtb3ZlIGl0LFxuICAgICAgICAvLyBlZmZlY3RpdmVseSB1bmluZGVudGluZyBpdC5cbiAgICAgICAgbGlzdE5vZGUucmVtb3ZlKCk7XG4gICAgICAgIGxpc3ROb2RlUGFyZW50LnNlbGVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdE5vZGUuaW5zZXJ0QmVmb3JlKHBhcmFncmFwaCk7XG4gICAgICAgIGxpc3ROb2RlLnJlbW92ZSgpOyAvLyBJZiB3ZSBoYXZlIHNlbGVjdGlvbiBvbiB0aGUgbGlzdCBpdGVtLCB3ZSdsbCBuZWVkIHRvIG1vdmUgaXRcbiAgICAgICAgLy8gdG8gdGhlIHBhcmFncmFwaFxuXG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICBjb25zdCBrZXkgPSBwYXJhZ3JhcGguZ2V0S2V5KCk7XG5cbiAgICAgICAgaWYgKGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLmdldE5vZGUoKS5pcyh0aGlzKSkge1xuICAgICAgICAgIGFuY2hvci5zZXQoa2V5LCBhbmNob3Iub2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvY3VzLnR5cGUgPT09ICdlbGVtZW50JyAmJiBmb2N1cy5nZXROb2RlKCkuaXModGhpcykpIHtcbiAgICAgICAgICBmb2N1cy5zZXQoa2V5LCBmb2N1cy5vZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdE5vZGUuaW5zZXJ0QmVmb3JlKHBhcmFncmFwaCk7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX192YWx1ZTtcbiAgfVxuXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fdmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldENoZWNrZWQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19jaGVja2VkO1xuICB9XG5cbiAgc2V0Q2hlY2tlZChjaGVja2VkKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fY2hlY2tlZCA9IGNoZWNrZWQ7XG4gIH1cblxuICB0b2dnbGVDaGVja2VkKCkge1xuICAgIHRoaXMuc2V0Q2hlY2tlZCghdGhpcy5fX2NoZWNrZWQpO1xuICB9XG5cbiAgZ2V0SW5kZW50KCkge1xuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwYXJlbnQsIHdlIGFyZSBsaWtlbHkgc2VyaWFsaXppbmdcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19pbmRlbnQ7XG4gICAgfSAvLyBMaXN0SXRlbU5vZGUgc2hvdWxkIGFsd2F5cyBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LlxuXG5cbiAgICBsZXQgbGlzdE5vZGVQYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGxldCBpbmRlbnRMZXZlbCA9IDA7XG5cbiAgICB3aGlsZSAoJGlzTGlzdEl0ZW1Ob2RlKGxpc3ROb2RlUGFyZW50KSkge1xuICAgICAgbGlzdE5vZGVQYXJlbnQgPSBsaXN0Tm9kZVBhcmVudC5nZXRQYXJlbnRPclRocm93KCkuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgaW5kZW50TGV2ZWwrKztcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZW50TGV2ZWw7XG4gIH1cblxuICBzZXRJbmRlbnQoaW5kZW50KSB7XG4gICAgbGV0IGN1cnJlbnRJbmRlbnQgPSB0aGlzLmdldEluZGVudCgpO1xuXG4gICAgd2hpbGUgKGN1cnJlbnRJbmRlbnQgIT09IGluZGVudCkge1xuICAgICAgaWYgKGN1cnJlbnRJbmRlbnQgPCBpbmRlbnQpIHtcbiAgICAgICAgJGhhbmRsZUluZGVudCh0aGlzKTtcbiAgICAgICAgY3VycmVudEluZGVudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGhhbmRsZU91dGRlbnQodGhpcyk7XG4gICAgICAgIGN1cnJlbnRJbmRlbnQtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGluc2VydEJlZm9yZShub2RlVG9JbnNlcnQpIHtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKG5vZGVUb0luc2VydCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gICAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IHRoaXMuZ2V0TmV4dFNpYmxpbmdzKCk7XG4gICAgICAgIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShwYXJlbnQsIHNpYmxpbmdzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuaW5zZXJ0QmVmb3JlKG5vZGVUb0luc2VydCk7XG4gIH1cblxuICBjYW5JbnNlcnRBZnRlcihub2RlKSB7XG4gICAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShub2RlKTtcbiAgfVxuXG4gIGNhblJlcGxhY2VXaXRoKHJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShyZXBsYWNlbWVudCk7XG4gIH1cblxuICBjYW5NZXJnZVdpdGgobm9kZSkge1xuICAgIHJldHVybiBsZXhpY2FsLiRpc1BhcmFncmFwaE5vZGUobm9kZSkgfHwgJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpO1xuICB9XG5cbiAgZXh0cmFjdFdpdGhDaGlsZChjaGlsZCwgc2VsZWN0aW9uKSB7XG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgICByZXR1cm4gdGhpcy5pc1BhcmVudE9mKGFuY2hvck5vZGUpICYmIHRoaXMuaXNQYXJlbnRPZihmb2N1c05vZGUpICYmIHRoaXMuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGggPT09IHNlbGVjdGlvbi5nZXRUZXh0Q29udGVudCgpLmxlbmd0aDtcbiAgfVxuXG4gIGlzUGFyZW50UmVxdWlyZWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjcmVhdGVQYXJlbnRFbGVtZW50Tm9kZSgpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUxpc3ROb2RlKCdidWxsZXQnKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uICRzZXRMaXN0SXRlbVRoZW1lQ2xhc3NOYW1lcyhkb20sIGVkaXRvclRoZW1lQ2xhc3Nlcywgbm9kZSkge1xuICBjb25zdCBjbGFzc2VzVG9BZGQgPSBbXTtcbiAgY29uc3QgY2xhc3Nlc1RvUmVtb3ZlID0gW107XG4gIGNvbnN0IGxpc3RUaGVtZSA9IGVkaXRvclRoZW1lQ2xhc3Nlcy5saXN0O1xuICBjb25zdCBsaXN0SXRlbUNsYXNzTmFtZSA9IGxpc3RUaGVtZSA/IGxpc3RUaGVtZS5saXN0aXRlbSA6IHVuZGVmaW5lZDtcbiAgbGV0IG5lc3RlZExpc3RJdGVtQ2xhc3NOYW1lO1xuXG4gIGlmIChsaXN0VGhlbWUgJiYgbGlzdFRoZW1lLm5lc3RlZCkge1xuICAgIG5lc3RlZExpc3RJdGVtQ2xhc3NOYW1lID0gbGlzdFRoZW1lLm5lc3RlZC5saXN0aXRlbTtcbiAgfVxuXG4gIGlmIChsaXN0SXRlbUNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbGlzdEl0ZW1DbGFzc2VzID0gbGlzdEl0ZW1DbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgICBjbGFzc2VzVG9BZGQucHVzaCguLi5saXN0SXRlbUNsYXNzZXMpO1xuICB9XG5cbiAgaWYgKGxpc3RUaGVtZSkge1xuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIGNvbnN0IGlzQ2hlY2tMaXN0ID0gJGlzTGlzdE5vZGUocGFyZW50Tm9kZSkgJiYgcGFyZW50Tm9kZS5nZXRMaXN0VHlwZSgpID09PSAnY2hlY2snO1xuICAgIGNvbnN0IGNoZWNrZWQgPSBub2RlLmdldENoZWNrZWQoKTtcblxuICAgIGlmICghaXNDaGVja0xpc3QgfHwgY2hlY2tlZCkge1xuICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2gobGlzdFRoZW1lLmxpc3RpdGVtVW5jaGVja2VkKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQ2hlY2tMaXN0IHx8ICFjaGVja2VkKSB7XG4gICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaChsaXN0VGhlbWUubGlzdGl0ZW1DaGVja2VkKTtcbiAgICB9XG5cbiAgICBpZiAoaXNDaGVja0xpc3QpIHtcbiAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKGNoZWNrZWQgPyBsaXN0VGhlbWUubGlzdGl0ZW1DaGVja2VkIDogbGlzdFRoZW1lLmxpc3RpdGVtVW5jaGVja2VkKTtcbiAgICB9XG4gIH1cblxuICBpZiAobmVzdGVkTGlzdEl0ZW1DbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG5lc3RlZExpc3RJdGVtQ2xhc3NlcyA9IG5lc3RlZExpc3RJdGVtQ2xhc3NOYW1lLnNwbGl0KCcgJyk7XG5cbiAgICBpZiAobm9kZS5nZXRDaGlsZHJlbigpLnNvbWUoY2hpbGQgPT4gJGlzTGlzdE5vZGUoY2hpbGQpKSkge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goLi4ubmVzdGVkTGlzdEl0ZW1DbGFzc2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2goLi4ubmVzdGVkTGlzdEl0ZW1DbGFzc2VzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY2xhc3Nlc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICB1dGlscy5yZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9SZW1vdmUpO1xuICB9XG5cbiAgaWYgKGNsYXNzZXNUb0FkZC5sZW5ndGggPiAwKSB7XG4gICAgdXRpbHMuYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChkb20sIC4uLmNsYXNzZXNUb0FkZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdEl0ZW1DaGVja2VkKGRvbSwgbGlzdEl0ZW1Ob2RlLCBwcmV2TGlzdEl0ZW1Ob2RlLCBsaXN0Tm9kZSkge1xuICAvLyBPbmx5IGFkZCBhdHRyaWJ1dGVzIGZvciBsZWFmIGxpc3QgaXRlbXNcbiAgaWYgKCRpc0xpc3ROb2RlKGxpc3RJdGVtTm9kZS5nZXRGaXJzdENoaWxkKCkpKSB7XG4gICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ3RhYkluZGV4Jyk7XG4gICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJyk7XG4gIH0gZWxzZSB7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgncm9sZScsICdjaGVja2JveCcpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgJy0xJyk7XG5cbiAgICBpZiAoIXByZXZMaXN0SXRlbU5vZGUgfHwgbGlzdEl0ZW1Ob2RlLl9fY2hlY2tlZCAhPT0gcHJldkxpc3RJdGVtTm9kZS5fX2NoZWNrZWQpIHtcbiAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsIGxpc3RJdGVtTm9kZS5nZXRDaGVja2VkKCkgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29udmVydExpc3RJdGVtRWxlbWVudChkb21Ob2RlKSB7XG4gIGNvbnN0IGNoZWNrZWQgPSB1dGlscy5pc0hUTUxFbGVtZW50KGRvbU5vZGUpICYmIGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnKSA9PT0gJ3RydWUnO1xuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVMaXN0SXRlbU5vZGUoY2hlY2tlZClcbiAgfTtcbn1cblxuZnVuY3Rpb24gJGNyZWF0ZUxpc3RJdGVtTm9kZShjaGVja2VkKSB7XG4gIHJldHVybiBsZXhpY2FsLiRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgTGlzdEl0ZW1Ob2RlKHVuZGVmaW5lZCwgY2hlY2tlZCkpO1xufVxuZnVuY3Rpb24gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaXN0SXRlbU5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpc3ROb2RlIGV4dGVuZHMgbGV4aWNhbC5FbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2xpc3QnO1xuICB9XG5cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICBjb25zdCBsaXN0VHlwZSA9IG5vZGUuX19saXN0VHlwZSB8fCBUQUdfVE9fTElTVF9UWVBFW25vZGUuX190YWddO1xuICAgIHJldHVybiBuZXcgTGlzdE5vZGUobGlzdFR5cGUsIG5vZGUuX19zdGFydCwgbm9kZS5fX2tleSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihsaXN0VHlwZSwgc3RhcnQsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG5cbiAgICBjb25zdCBfbGlzdFR5cGUgPSBUQUdfVE9fTElTVF9UWVBFW2xpc3RUeXBlXSB8fCBsaXN0VHlwZTtcblxuICAgIHRoaXMuX19saXN0VHlwZSA9IF9saXN0VHlwZTtcbiAgICB0aGlzLl9fdGFnID0gX2xpc3RUeXBlID09PSAnbnVtYmVyJyA/ICdvbCcgOiAndWwnO1xuICAgIHRoaXMuX19zdGFydCA9IHN0YXJ0O1xuICB9XG5cbiAgZ2V0VGFnKCkge1xuICAgIHJldHVybiB0aGlzLl9fdGFnO1xuICB9XG5cbiAgZ2V0TGlzdFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19saXN0VHlwZTtcbiAgfVxuXG4gIGdldFN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLl9fc3RhcnQ7XG4gIH0gLy8gVmlld1xuXG5cbiAgY3JlYXRlRE9NKGNvbmZpZywgX2VkaXRvcikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuX190YWc7XG4gICAgY29uc3QgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuXG4gICAgaWYgKHRoaXMuX19zdGFydCAhPT0gMSkge1xuICAgICAgZG9tLnNldEF0dHJpYnV0ZSgnc3RhcnQnLCBTdHJpbmcodGhpcy5fX3N0YXJ0KSk7XG4gICAgfSAvLyBAdHMtZXhwZWN0LWVycm9yIEludGVybmFsIGZpZWxkLlxuXG5cbiAgICBkb20uX19sZXhpY2FsTGlzdFR5cGUgPSB0aGlzLl9fbGlzdFR5cGU7XG4gICAgc2V0TGlzdFRoZW1lQ2xhc3NOYW1lcyhkb20sIGNvbmZpZy50aGVtZSwgdGhpcyk7XG4gICAgcmV0dXJuIGRvbTtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBpZiAocHJldk5vZGUuX190YWcgIT09IHRoaXMuX190YWcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHNldExpc3RUaGVtZUNsYXNzTmFtZXMoZG9tLCBjb25maWcudGhlbWUsIHRoaXMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9sOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRMaXN0Tm9kZSxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgdWw6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydExpc3ROb2RlLFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZUxpc3ROb2RlKHNlcmlhbGl6ZWROb2RlLmxpc3RUeXBlLCBzZXJpYWxpemVkTm9kZS5zdGFydCk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldEluZGVudChzZXJpYWxpemVkTm9kZS5pbmRlbnQpO1xuICAgIG5vZGUuc2V0RGlyZWN0aW9uKHNlcmlhbGl6ZWROb2RlLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXJ0ICE9PSAxKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdGFydCcsIFN0cmluZyh0aGlzLl9fc3RhcnQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX19saXN0VHlwZSA9PT0gJ2NoZWNrJykge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnX19sZXhpY2FsTGlzdFR5cGUnLCAnY2hlY2snKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGxpc3RUeXBlOiB0aGlzLmdldExpc3RUeXBlKCksXG4gICAgICBzdGFydDogdGhpcy5nZXRTdGFydCgpLFxuICAgICAgdGFnOiB0aGlzLmdldFRhZygpLFxuICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cblxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNhbkluZGVudCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBhcHBlbmQoLi4ubm9kZXNUb0FwcGVuZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNUb0FwcGVuZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBub2Rlc1RvQXBwZW5kW2ldO1xuXG4gICAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgICBzdXBlci5hcHBlbmQoY3VycmVudE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGlzdEl0ZW1Ob2RlID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuXG4gICAgICAgIGlmICgkaXNMaXN0Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBsaXN0SXRlbU5vZGUuYXBwZW5kKGN1cnJlbnROb2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gbGV4aWNhbC4kY3JlYXRlVGV4dE5vZGUoY3VycmVudE5vZGUuZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgICAgICAgbGlzdEl0ZW1Ob2RlLmFwcGVuZCh0ZXh0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdEl0ZW1Ob2RlLmFwcGVuZChjdXJyZW50Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkKSB7XG4gICAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShjaGlsZCk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBzZXRMaXN0VGhlbWVDbGFzc05hbWVzKGRvbSwgZWRpdG9yVGhlbWVDbGFzc2VzLCBub2RlKSB7XG4gIGNvbnN0IGNsYXNzZXNUb0FkZCA9IFtdO1xuICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBbXTtcbiAgY29uc3QgbGlzdFRoZW1lID0gZWRpdG9yVGhlbWVDbGFzc2VzLmxpc3Q7XG5cbiAgaWYgKGxpc3RUaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbGlzdExldmVsc0NsYXNzTmFtZXMgPSBsaXN0VGhlbWVbYCR7bm9kZS5fX3RhZ31EZXB0aGBdIHx8IFtdO1xuICAgIGNvbnN0IGxpc3REZXB0aCA9ICRnZXRMaXN0RGVwdGgobm9kZSkgLSAxO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRMaXN0RGVwdGggPSBsaXN0RGVwdGggJSBsaXN0TGV2ZWxzQ2xhc3NOYW1lcy5sZW5ndGg7XG4gICAgY29uc3QgbGlzdExldmVsQ2xhc3NOYW1lID0gbGlzdExldmVsc0NsYXNzTmFtZXNbbm9ybWFsaXplZExpc3REZXB0aF07XG4gICAgY29uc3QgbGlzdENsYXNzTmFtZSA9IGxpc3RUaGVtZVtub2RlLl9fdGFnXTtcbiAgICBsZXQgbmVzdGVkTGlzdENsYXNzTmFtZTtcbiAgICBjb25zdCBuZXN0ZWRMaXN0VGhlbWUgPSBsaXN0VGhlbWUubmVzdGVkO1xuXG4gICAgaWYgKG5lc3RlZExpc3RUaGVtZSAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZExpc3RUaGVtZS5saXN0KSB7XG4gICAgICBuZXN0ZWRMaXN0Q2xhc3NOYW1lID0gbmVzdGVkTGlzdFRoZW1lLmxpc3Q7XG4gICAgfVxuXG4gICAgaWYgKGxpc3RDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2gobGlzdENsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGxpc3RMZXZlbENsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBsaXN0SXRlbUNsYXNzZXMgPSBsaXN0TGV2ZWxDbGFzc05hbWUuc3BsaXQoJyAnKTtcbiAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLmxpc3RJdGVtQ2xhc3Nlcyk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdExldmVsc0NsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgIT09IG5vcm1hbGl6ZWRMaXN0RGVwdGgpIHtcbiAgICAgICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaChub2RlLl9fdGFnICsgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVzdGVkTGlzdENsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBuZXN0ZWRMaXN0SXRlbUNsYXNzZXMgPSBuZXN0ZWRMaXN0Q2xhc3NOYW1lLnNwbGl0KCcgJyk7XG5cbiAgICAgIGlmIChsaXN0RGVwdGggPiAxKSB7XG4gICAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLm5lc3RlZExpc3RJdGVtQ2xhc3Nlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjbGFzc2VzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgIHV0aWxzLnJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChkb20sIC4uLmNsYXNzZXNUb1JlbW92ZSk7XG4gIH1cblxuICBpZiAoY2xhc3Nlc1RvQWRkLmxlbmd0aCA+IDApIHtcbiAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgLi4uY2xhc3Nlc1RvQWRkKTtcbiAgfVxufVxuLypcbiAqIFRoaXMgZnVuY3Rpb24gbm9ybWFsaXplcyB0aGUgY2hpbGRyZW4gb2YgYSBMaXN0Tm9kZSBhZnRlciB0aGUgY29udmVyc2lvbiBmcm9tIEhUTUwsXG4gKiBlbnN1cmluZyB0aGF0IHRoZXkgYXJlIGFsbCBMaXN0SXRlbU5vZGVzIGFuZCBjb250YWluIGVpdGhlciBhIHNpbmdsZSBuZXN0ZWQgTGlzdE5vZGVcbiAqIG9yIHNvbWUgb3RoZXIgaW5saW5lIGNvbnRlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihub2Rlcykge1xuICBjb25zdCBub3JtYWxpemVkTGlzdEl0ZW1zID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgIG5vcm1hbGl6ZWRMaXN0SXRlbXMucHVzaChub2RlKTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuXG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICBpZiAoJGlzTGlzdE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkTGlzdEl0ZW1zLnB1c2god3JhcEluTGlzdEl0ZW0oY2hpbGQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVkTGlzdEl0ZW1zLnB1c2god3JhcEluTGlzdEl0ZW0obm9kZSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkTGlzdEl0ZW1zO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0TGlzdE5vZGUoZG9tTm9kZSkge1xuICBjb25zdCBub2RlTmFtZSA9IGRvbU5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbGV0IG5vZGUgPSBudWxsO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ29sJykge1xuICAgIG5vZGUgPSAkY3JlYXRlTGlzdE5vZGUoJ251bWJlcicpO1xuICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSAndWwnKSB7XG4gICAgaWYgKHV0aWxzLmlzSFRNTEVsZW1lbnQoZG9tTm9kZSkgJiYgZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ19fbGV4aWNhbGxpc3R0eXBlJykgPT09ICdjaGVjaycpIHtcbiAgICAgIG5vZGUgPSAkY3JlYXRlTGlzdE5vZGUoJ2NoZWNrJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSAkY3JlYXRlTGlzdE5vZGUoJ2J1bGxldCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6IG5vcm1hbGl6ZUNoaWxkcmVuLFxuICAgIG5vZGVcbiAgfTtcbn1cblxuY29uc3QgVEFHX1RPX0xJU1RfVFlQRSA9IHtcbiAgb2w6ICdudW1iZXInLFxuICB1bDogJ2J1bGxldCdcbn07XG5mdW5jdGlvbiAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUsIHN0YXJ0ID0gMSkge1xuICByZXR1cm4gbGV4aWNhbC4kYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IExpc3ROb2RlKGxpc3RUeXBlLCBzdGFydCkpO1xufVxuZnVuY3Rpb24gJGlzTGlzdE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIExpc3ROb2RlO1xufVxuXG4vKiogQG1vZHVsZSBAbGV4aWNhbC9saXN0ICovXG5jb25zdCBJTlNFUlRfVU5PUkRFUkVEX0xJU1RfQ09NTUFORCA9IGxleGljYWwuY3JlYXRlQ29tbWFuZCgnSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQnKTtcbmNvbnN0IElOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCA9IGxleGljYWwuY3JlYXRlQ29tbWFuZCgnSU5TRVJUX09SREVSRURfTElTVF9DT01NQU5EJyk7XG5jb25zdCBJTlNFUlRfQ0hFQ0tfTElTVF9DT01NQU5EID0gbGV4aWNhbC5jcmVhdGVDb21tYW5kKCdJTlNFUlRfQ0hFQ0tfTElTVF9DT01NQU5EJyk7XG5jb25zdCBSRU1PVkVfTElTVF9DT01NQU5EID0gbGV4aWNhbC5jcmVhdGVDb21tYW5kKCdSRU1PVkVfTElTVF9DT01NQU5EJyk7XG5cbmV4cG9ydHMuJGNyZWF0ZUxpc3RJdGVtTm9kZSA9ICRjcmVhdGVMaXN0SXRlbU5vZGU7XG5leHBvcnRzLiRjcmVhdGVMaXN0Tm9kZSA9ICRjcmVhdGVMaXN0Tm9kZTtcbmV4cG9ydHMuJGdldExpc3REZXB0aCA9ICRnZXRMaXN0RGVwdGg7XG5leHBvcnRzLiRoYW5kbGVMaXN0SW5zZXJ0UGFyYWdyYXBoID0gJGhhbmRsZUxpc3RJbnNlcnRQYXJhZ3JhcGg7XG5leHBvcnRzLiRpc0xpc3RJdGVtTm9kZSA9ICRpc0xpc3RJdGVtTm9kZTtcbmV4cG9ydHMuJGlzTGlzdE5vZGUgPSAkaXNMaXN0Tm9kZTtcbmV4cG9ydHMuSU5TRVJUX0NIRUNLX0xJU1RfQ09NTUFORCA9IElOU0VSVF9DSEVDS19MSVNUX0NPTU1BTkQ7XG5leHBvcnRzLklOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCA9IElOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORDtcbmV4cG9ydHMuSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQgPSBJTlNFUlRfVU5PUkRFUkVEX0xJU1RfQ09NTUFORDtcbmV4cG9ydHMuTGlzdEl0ZW1Ob2RlID0gTGlzdEl0ZW1Ob2RlO1xuZXhwb3J0cy5MaXN0Tm9kZSA9IExpc3ROb2RlO1xuZXhwb3J0cy5SRU1PVkVfTElTVF9DT01NQU5EID0gUkVNT1ZFX0xJU1RfQ09NTUFORDtcbmV4cG9ydHMuaW5zZXJ0TGlzdCA9IGluc2VydExpc3Q7XG5leHBvcnRzLnJlbW92ZUxpc3QgPSByZW1vdmVMaXN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/list/LexicalList.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/list/LexicalList.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/list/LexicalList.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalList =  true ? __webpack_require__(/*! ./LexicalList.dev.js */ \"(ssr)/./node_modules/@lexical/list/LexicalList.dev.js\") : 0\nmodule.exports = LexicalList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGlzdC9MZXhpY2FsTGlzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLG9CQUFvQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsbUZBQXNCLElBQUksQ0FBZ0M7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9saXN0L0xleGljYWxMaXN0LmpzPzJmYjQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxMaXN0ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxMaXN0LmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsTGlzdC5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbExpc3Q7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/list/LexicalList.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/mark/LexicalMark.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/mark/LexicalMark.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass MarkNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'mark';\n  }\n\n  static clone(node) {\n    return new MarkNode(Array.from(node.__ids), node.__key);\n  }\n\n  static importDOM() {\n    return null;\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createMarkNode(serializedNode.ids);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      ids: this.getIDs(),\n      type: 'mark',\n      version: 1\n    };\n  }\n\n  constructor(ids, key) {\n    super(key);\n    this.__ids = ids || [];\n  }\n\n  createDOM(config) {\n    const element = document.createElement('mark');\n    utils.addClassNamesToElement(element, config.theme.mark);\n\n    if (this.__ids.length > 1) {\n      utils.addClassNamesToElement(element, config.theme.markOverlap);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          utils.addClassNamesToElement(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        utils.removeClassNamesFromElement(element, overlapTheme);\n      }\n    }\n\n    return false;\n  }\n\n  hasID(id) {\n    const ids = this.getIDs();\n\n    for (let i = 0; i < ids.length; i++) {\n      if (id === ids[i]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  getIDs() {\n    const self = this.getLatest();\n    return $isMarkNode(self) ? self.__ids : [];\n  }\n\n  addID(id) {\n    const self = this.getWritable();\n\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n\n      for (let i = 0; i < ids.length; i++) {\n        // If we already have it, don't add again\n        if (id === ids[i]) return;\n      }\n\n      ids.push(id);\n    }\n  }\n\n  deleteID(id) {\n    const self = this.getWritable();\n\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n\n      for (let i = 0; i < ids.length; i++) {\n        if (id === ids[i]) {\n          ids.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n\n    if (lexical.$isElementNode(element)) {\n      const markNode = $createMarkNode(this.__ids);\n      element.append(markNode);\n      return markNode;\n    }\n\n    return null;\n  }\n\n  canInsertTextBefore() {\n    return false;\n  }\n\n  canInsertTextAfter() {\n    return false;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  isInline() {\n    return true;\n  }\n\n  extractWithChild(child, selection, destination) {\n    if (!lexical.$isRangeSelection(selection) || destination === 'html') {\n      return false;\n    }\n\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n\n}\nfunction $createMarkNode(ids) {\n  return lexical.$applyNodeReplacement(new MarkNode(ids));\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/** @module @lexical/mark */\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n\n    target = child;\n  }\n\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {\n  const nodes = selection.getNodes();\n  const anchorOffset = selection.anchor.offset;\n  const focusOffset = selection.focus.offset;\n  const nodesLength = nodes.length;\n  const startOffset = isBackward ? focusOffset : anchorOffset;\n  const endOffset = isBackward ? anchorOffset : focusOffset;\n  let currentNodeParent;\n  let lastCreatedMarkNode; // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n\n    const isFirstNode = i === 0;\n    const isLastNode = i === nodesLength - 1;\n    let targetNode = null;\n\n    if (lexical.$isTextNode(node)) {\n      // Case 1: The node is a text node and we can split it\n      const textContentSize = node.getTextContentSize();\n      const startTextOffset = isFirstNode ? startOffset : 0;\n      const endTextOffset = isLastNode ? endOffset : textContentSize;\n\n      if (startTextOffset === 0 && endTextOffset === 0) {\n        continue;\n      }\n\n      const splitNodes = node.splitText(startTextOffset, endTextOffset);\n      targetNode = splitNodes.length > 1 && (splitNodes.length === 3 || isFirstNode && !isLastNode || endTextOffset === textContentSize) ? splitNodes[1] : splitNodes[0];\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may utlimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n      continue;\n    } else if (lexical.$isElementNode(node) && node.isInline()) {\n      // Case 3: inline element nodes can be added in their entirety to the new\n      // mark\n      targetNode = node;\n    }\n\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n\n      const parentNode = targetNode.getParent();\n\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n\n      currentNodeParent = parentNode;\n\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        const createMarkNode = createNode || $createMarkNode;\n        lastCreatedMarkNode = createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      } // Add the target node to be wrapped in the latest created mark node\n\n\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if (lexical.$isTextNode(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n\n    currentNode = currentNode.getParent();\n  }\n\n  return null;\n}\n\nexports.$createMarkNode = $createMarkNode;\nexports.$getMarkIDs = $getMarkIDs;\nexports.$isMarkNode = $isMarkNode;\nexports.$unwrapMarkNode = $unwrapMarkNode;\nexports.$wrapSelectionInMarkNode = $wrapSelectionInMarkNode;\nexports.MarkNode = MarkNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFyay9MZXhpY2FsTWFyay5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLHVCQUF1QjtBQUN2QixnQ0FBZ0M7QUFDaEMsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFyay9MZXhpY2FsTWFyay5kZXYuanM/ODA4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBNYXJrTm9kZSBleHRlbmRzIGxleGljYWwuRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnbWFyayc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgTWFya05vZGUoQXJyYXkuZnJvbShub2RlLl9faWRzKSwgbm9kZS5fX2tleSk7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZU1hcmtOb2RlKHNlcmlhbGl6ZWROb2RlLmlkcyk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldEluZGVudChzZXJpYWxpemVkTm9kZS5pbmRlbnQpO1xuICAgIG5vZGUuc2V0RGlyZWN0aW9uKHNlcmlhbGl6ZWROb2RlLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGlkczogdGhpcy5nZXRJRHMoKSxcbiAgICAgIHR5cGU6ICdtYXJrJyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoaWRzLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX19pZHMgPSBpZHMgfHwgW107XG4gIH1cblxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21hcmsnKTtcbiAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS5tYXJrKTtcblxuICAgIGlmICh0aGlzLl9faWRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLm1hcmtPdmVybGFwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZWxlbWVudCwgY29uZmlnKSB7XG4gICAgY29uc3QgcHJldklEcyA9IHByZXZOb2RlLl9faWRzO1xuICAgIGNvbnN0IG5leHRJRHMgPSB0aGlzLl9faWRzO1xuICAgIGNvbnN0IHByZXZJRHNDb3VudCA9IHByZXZJRHMubGVuZ3RoO1xuICAgIGNvbnN0IG5leHRJRHNDb3VudCA9IG5leHRJRHMubGVuZ3RoO1xuICAgIGNvbnN0IG92ZXJsYXBUaGVtZSA9IGNvbmZpZy50aGVtZS5tYXJrT3ZlcmxhcDtcblxuICAgIGlmIChwcmV2SURzQ291bnQgIT09IG5leHRJRHNDb3VudCkge1xuICAgICAgaWYgKHByZXZJRHNDb3VudCA9PT0gMSkge1xuICAgICAgICBpZiAobmV4dElEc0NvdW50ID09PSAyKSB7XG4gICAgICAgICAgdXRpbHMuYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBvdmVybGFwVGhlbWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5leHRJRHNDb3VudCA9PT0gMSkge1xuICAgICAgICB1dGlscy5yZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZWxlbWVudCwgb3ZlcmxhcFRoZW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYXNJRChpZCkge1xuICAgIGNvbnN0IGlkcyA9IHRoaXMuZ2V0SURzKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlkID09PSBpZHNbaV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0SURzKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiAkaXNNYXJrTm9kZShzZWxmKSA/IHNlbGYuX19pZHMgOiBbXTtcbiAgfVxuXG4gIGFkZElEKGlkKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcblxuICAgIGlmICgkaXNNYXJrTm9kZShzZWxmKSkge1xuICAgICAgY29uc3QgaWRzID0gc2VsZi5fX2lkcztcbiAgICAgIHNlbGYuX19pZHMgPSBpZHM7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIElmIHdlIGFscmVhZHkgaGF2ZSBpdCwgZG9uJ3QgYWRkIGFnYWluXG4gICAgICAgIGlmIChpZCA9PT0gaWRzW2ldKSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlkcy5wdXNoKGlkKTtcbiAgICB9XG4gIH1cblxuICBkZWxldGVJRChpZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG5cbiAgICBpZiAoJGlzTWFya05vZGUoc2VsZikpIHtcbiAgICAgIGNvbnN0IGlkcyA9IHNlbGYuX19pZHM7XG4gICAgICBzZWxmLl9faWRzID0gaWRzO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaWQgPT09IGlkc1tpXSkge1xuICAgICAgICAgIGlkcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5pbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24pO1xuXG4gICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUoZWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IG1hcmtOb2RlID0gJGNyZWF0ZU1hcmtOb2RlKHRoaXMuX19pZHMpO1xuICAgICAgZWxlbWVudC5hcHBlbmQobWFya05vZGUpO1xuICAgICAgcmV0dXJuIG1hcmtOb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbiwgZGVzdGluYXRpb24pIHtcbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBkZXN0aW5hdGlvbiA9PT0gJ2h0bWwnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uTGVuZ3RoID0gaXNCYWNrd2FyZCA/IGFuY2hvci5vZmZzZXQgLSBmb2N1cy5vZmZzZXQgOiBmb2N1cy5vZmZzZXQgLSBhbmNob3Iub2Zmc2V0O1xuICAgIHJldHVybiB0aGlzLmlzUGFyZW50T2YoYW5jaG9yTm9kZSkgJiYgdGhpcy5pc1BhcmVudE9mKGZvY3VzTm9kZSkgJiYgdGhpcy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aCA9PT0gc2VsZWN0aW9uTGVuZ3RoO1xuICB9XG5cbiAgZXhjbHVkZUZyb21Db3B5KGRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uICE9PSAnY2xvbmUnO1xuICB9XG5cbn1cbmZ1bmN0aW9uICRjcmVhdGVNYXJrTm9kZShpZHMpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBNYXJrTm9kZShpZHMpKTtcbn1cbmZ1bmN0aW9uICRpc01hcmtOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBNYXJrTm9kZTtcbn1cblxuLyoqIEBtb2R1bGUgQGxleGljYWwvbWFyayAqL1xuZnVuY3Rpb24gJHVud3JhcE1hcmtOb2RlKG5vZGUpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gIGxldCB0YXJnZXQgPSBudWxsO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIoY2hpbGQpO1xuICAgIH1cblxuICAgIHRhcmdldCA9IGNoaWxkO1xuICB9XG5cbiAgbm9kZS5yZW1vdmUoKTtcbn1cbmZ1bmN0aW9uICR3cmFwU2VsZWN0aW9uSW5NYXJrTm9kZShzZWxlY3Rpb24sIGlzQmFja3dhcmQsIGlkLCBjcmVhdGVOb2RlKSB7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGNvbnN0IGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0O1xuICBjb25zdCBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1cy5vZmZzZXQ7XG4gIGNvbnN0IG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuICBjb25zdCBzdGFydE9mZnNldCA9IGlzQmFja3dhcmQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgY29uc3QgZW5kT2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICBsZXQgY3VycmVudE5vZGVQYXJlbnQ7XG4gIGxldCBsYXN0Q3JlYXRlZE1hcmtOb2RlOyAvLyBXZSBvbmx5IHdhbnQgd3JhcCBhZGphY2VudCB0ZXh0IG5vZGVzLCBsaW5lIGJyZWFrIG5vZGVzXG4gIC8vIGFuZCBpbmxpbmUgZWxlbWVudCBub2Rlcy4gRm9yIGRlY29yYXRvciBub2RlcyBhbmQgYmxvY2tcbiAgLy8gZWxlbWVudCBub2Rlcywgd2Ugc3RlcCBvdXQgb2YgdGhlaXIgYm91bmRhcnkgYW5kIHN0YXJ0XG4gIC8vIGFnYWluIGFmdGVyLCBpZiB0aGVyZSBhcmUgbW9yZSBub2Rlcy5cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShsYXN0Q3JlYXRlZE1hcmtOb2RlKSAmJiBsYXN0Q3JlYXRlZE1hcmtOb2RlLmlzUGFyZW50T2Yobm9kZSkpIHtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBjaGlsZCBvZiB0aGUgbGFzdCBjcmVhdGVkIG1hcmsgbm9kZSwgdGhlcmUgaXMgbm90aGluZyB0byBkbyBoZXJlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0ZpcnN0Tm9kZSA9IGkgPT09IDA7XG4gICAgY29uc3QgaXNMYXN0Tm9kZSA9IGkgPT09IG5vZGVzTGVuZ3RoIC0gMTtcbiAgICBsZXQgdGFyZ2V0Tm9kZSA9IG51bGw7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgLy8gQ2FzZSAxOiBUaGUgbm9kZSBpcyBhIHRleHQgbm9kZSBhbmQgd2UgY2FuIHNwbGl0IGl0XG4gICAgICBjb25zdCB0ZXh0Q29udGVudFNpemUgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgY29uc3Qgc3RhcnRUZXh0T2Zmc2V0ID0gaXNGaXJzdE5vZGUgPyBzdGFydE9mZnNldCA6IDA7XG4gICAgICBjb25zdCBlbmRUZXh0T2Zmc2V0ID0gaXNMYXN0Tm9kZSA/IGVuZE9mZnNldCA6IHRleHRDb250ZW50U2l6ZTtcblxuICAgICAgaWYgKHN0YXJ0VGV4dE9mZnNldCA9PT0gMCAmJiBlbmRUZXh0T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzcGxpdE5vZGVzID0gbm9kZS5zcGxpdFRleHQoc3RhcnRUZXh0T2Zmc2V0LCBlbmRUZXh0T2Zmc2V0KTtcbiAgICAgIHRhcmdldE5vZGUgPSBzcGxpdE5vZGVzLmxlbmd0aCA+IDEgJiYgKHNwbGl0Tm9kZXMubGVuZ3RoID09PSAzIHx8IGlzRmlyc3ROb2RlICYmICFpc0xhc3ROb2RlIHx8IGVuZFRleHRPZmZzZXQgPT09IHRleHRDb250ZW50U2l6ZSkgPyBzcGxpdE5vZGVzWzFdIDogc3BsaXROb2Rlc1swXTtcbiAgICB9IGVsc2UgaWYgKCRpc01hcmtOb2RlKG5vZGUpKSB7XG4gICAgICAvLyBDYXNlIDI6IHRoZSBub2RlIGlzIGEgbWFyayBub2RlIGFuZCB3ZSBjYW4gaWdub3JlIGl0IGFzIGEgdGFyZ2V0LFxuICAgICAgLy8gbW92aW5nIG9uIHRvIGl0cyBjaGlsZHJlbi4gTm90ZSB0aGF0IHdoZW4gd2UgbWFrZSBhIG1hcmsgaW5zaWRlXG4gICAgICAvLyBhbm90aGVyIG1hcmssIGl0IG1heSB1dGxpbWF0ZWx5IGJlIHVubmVzdGVkIGJ5IGEgY2FsbCB0b1xuICAgICAgLy8gYHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyPE1hcmtOb2RlPmAgc29tZXdoZXJlIGVsc2UgaW4gdGhlXG4gICAgICAvLyBjb2RlYmFzZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCkpIHtcbiAgICAgIC8vIENhc2UgMzogaW5saW5lIGVsZW1lbnQgbm9kZXMgY2FuIGJlIGFkZGVkIGluIHRoZWlyIGVudGlyZXR5IHRvIHRoZSBuZXdcbiAgICAgIC8vIG1hcmtcbiAgICAgIHRhcmdldE5vZGUgPSBub2RlO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXROb2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIGEgdGFyZ2V0IG5vZGUgZm9yIHdyYXBwaW5nIHdpdGggYSBtYXJrLCB3ZSBjYW4gcnVuXG4gICAgICAvLyB0aHJvdWdoIHNwZWNpYWwgY2FzZXMuXG4gICAgICBpZiAodGFyZ2V0Tm9kZSAmJiB0YXJnZXROb2RlLmlzKGN1cnJlbnROb2RlUGFyZW50KSkge1xuICAgICAgICAvLyBUaGUgY3VycmVudCBub2RlIGlzIGEgY2hpbGQgb2YgdGhlIHRhcmdldCBub2RlIHRvIGJlIHdyYXBwZWQsIHRoZXJlXG4gICAgICAgIC8vIGlzIG5vdGhpbmcgdG8gZG8gaGVyZS5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSB0YXJnZXROb2RlLmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAocGFyZW50Tm9kZSA9PSBudWxsIHx8ICFwYXJlbnROb2RlLmlzKGN1cnJlbnROb2RlUGFyZW50KSkge1xuICAgICAgICAvLyBJZiB0aGUgcGFyZW50IG5vZGUgaXMgbm90IHRoZSBjdXJyZW50IG5vZGUncyBwYXJlbnQgbm9kZSwgd2UgY2FuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBsYXN0IGNyZWF0ZWQgbWFyayBub2RlLlxuICAgICAgICBsYXN0Q3JlYXRlZE1hcmtOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50Tm9kZVBhcmVudCA9IHBhcmVudE5vZGU7XG5cbiAgICAgIGlmIChsYXN0Q3JlYXRlZE1hcmtOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNyZWF0ZWQgbWFyayBub2RlLCB3ZSBjYW4gbWFrZSBvbmVcbiAgICAgICAgY29uc3QgY3JlYXRlTWFya05vZGUgPSBjcmVhdGVOb2RlIHx8ICRjcmVhdGVNYXJrTm9kZTtcbiAgICAgICAgbGFzdENyZWF0ZWRNYXJrTm9kZSA9IGNyZWF0ZU1hcmtOb2RlKFtpZF0pO1xuICAgICAgICB0YXJnZXROb2RlLmluc2VydEJlZm9yZShsYXN0Q3JlYXRlZE1hcmtOb2RlKTtcbiAgICAgIH0gLy8gQWRkIHRoZSB0YXJnZXQgbm9kZSB0byBiZSB3cmFwcGVkIGluIHRoZSBsYXRlc3QgY3JlYXRlZCBtYXJrIG5vZGVcblxuXG4gICAgICBsYXN0Q3JlYXRlZE1hcmtOb2RlLmFwcGVuZCh0YXJnZXROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHRhcmdldCBub2RlIHRvIHdyYXAgd2UgY2FuIGNsZWFyIG91ciBzdGF0ZSBhbmRcbiAgICAgIC8vIGNvbnRpbnVlIG9uIHdpdGggdGhlIG5leHQgbm9kZVxuICAgICAgY3VycmVudE5vZGVQYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICBsYXN0Q3JlYXRlZE1hcmtOb2RlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJGdldE1hcmtJRHMobm9kZSwgb2Zmc2V0KSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG5cbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgaWYgKCRpc01hcmtOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlLmdldElEcygpO1xuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShjdXJyZW50Tm9kZSkgJiYgb2Zmc2V0ID09PSBjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBjdXJyZW50Tm9kZS5nZXROZXh0U2libGluZygpO1xuXG4gICAgICBpZiAoJGlzTWFya05vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgIHJldHVybiBuZXh0U2libGluZy5nZXRJRHMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmdldFBhcmVudCgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydHMuJGNyZWF0ZU1hcmtOb2RlID0gJGNyZWF0ZU1hcmtOb2RlO1xuZXhwb3J0cy4kZ2V0TWFya0lEcyA9ICRnZXRNYXJrSURzO1xuZXhwb3J0cy4kaXNNYXJrTm9kZSA9ICRpc01hcmtOb2RlO1xuZXhwb3J0cy4kdW53cmFwTWFya05vZGUgPSAkdW53cmFwTWFya05vZGU7XG5leHBvcnRzLiR3cmFwU2VsZWN0aW9uSW5NYXJrTm9kZSA9ICR3cmFwU2VsZWN0aW9uSW5NYXJrTm9kZTtcbmV4cG9ydHMuTWFya05vZGUgPSBNYXJrTm9kZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/mark/LexicalMark.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/mark/LexicalMark.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/mark/LexicalMark.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalMark =  true ? __webpack_require__(/*! ./LexicalMark.dev.js */ \"(ssr)/./node_modules/@lexical/mark/LexicalMark.dev.js\") : 0\nmodule.exports = LexicalMark;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFyay9MZXhpY2FsTWFyay5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLG9CQUFvQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsbUZBQXNCLElBQUksQ0FBZ0M7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9tYXJrL0xleGljYWxNYXJrLmpzPzhlMGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxNYXJrID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxNYXJrLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsTWFyay5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbE1hcms7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/mark/LexicalMark.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.dev.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/markdown/LexicalMarkdown.dev.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar code = __webpack_require__(/*! @lexical/code */ \"(ssr)/./node_modules/@lexical/code/LexicalCode.js\");\nvar list = __webpack_require__(/*! @lexical/list */ \"(ssr)/./node_modules/@lexical/list/LexicalList.js\");\nvar richText = __webpack_require__(/*! @lexical/rich-text */ \"(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar link = __webpack_require__(/*! @lexical/link */ \"(ssr)/./node_modules/@lexical/link/LexicalLink.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n\n  for (const item of list) {\n    const key = callback(item);\n\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createMarkdownExport(transformers) {\n  const byType = transformersByType(transformers); // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1);\n  return () => {\n    const output = [];\n    const children = lexical.$getRoot().getChildren();\n\n    for (const child of children) {\n      const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);\n\n      if (result != null) {\n        output.push(result);\n      }\n    }\n\n    return output.join('\\n\\n');\n  };\n}\n\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n\n    if (result != null) {\n      return result;\n    }\n  }\n\n  if (lexical.$isElementNode(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if (lexical.$isDecoratorNode(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\n\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers) {\n  const output = [];\n  const children = node.getChildren();\n\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));\n\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n\n    if (lexical.$isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if (lexical.$isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));\n    } else if (lexical.$isElementNode(child)) {\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));\n    } else if (lexical.$isDecoratorNode(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n\n  return output.join('');\n}\n\nfunction exportTextFormat(node, textContent, textTransformers) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // We instead want to trim the whitespace out, apply formatting, and then\n  // bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n  const frozenString = textContent.trim();\n  let output = frozenString;\n  const applied = new Set();\n\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format); // Prevent adding opening tag is already opened by the previous sibling\n\n      const previousNode = getTextSibling(node, true);\n\n      if (!hasFormat(previousNode, format)) {\n        output = tag + output;\n      } // Prevent adding closing tag if next sibling will do it\n\n\n      const nextNode = getTextSibling(node, false);\n\n      if (!hasFormat(nextNode, format)) {\n        output += tag;\n      }\n    }\n  } // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n\n\n  return textContent.replace(frozenString, output);\n} // Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\n\n\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  while (sibling) {\n    if (lexical.$isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n\n      if (lexical.$isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n\n    if (lexical.$isTextNode(sibling)) {\n      return sibling;\n    }\n\n    if (!lexical.$isElementNode(sibling)) {\n      return null;\n    }\n  }\n\n  return null;\n}\n\nfunction hasFormat(node, format) {\n  return lexical.$isTextNode(node) && node.hasFormat(format);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nconst CODE_BLOCK_REG_EXP = /^```(\\w{1,10})?\\s?$/;\nfunction createMarkdownImport(transformers) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return markdownString => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = lexical.$getRoot();\n    root.clear();\n\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i]; // Codeblocks are processed first as anything inside such block\n      // is ignored for further processing\n      // TODO:\n      // Abstract it to be dynamic as other transformers (add multiline match option)\n\n      const [codeBlockNode, shiftedIndex] = importCodeBlock(lines, i, root);\n\n      if (codeBlockNode != null) {\n        i = shiftedIndex;\n        continue;\n      }\n\n      importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);\n    } // Removing empty paragraphs as md does not really\n    // allow empty lines and uses them as dilimiter\n\n\n    const children = root.getChildren();\n\n    for (const child of children) {\n      if (isEmptyParagraph(child)) {\n        child.remove();\n      }\n    }\n\n    root.selectEnd();\n  };\n}\n\nfunction isEmptyParagraph(node) {\n  if (!lexical.$isParagraphNode(node)) {\n    return false;\n  }\n\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\n\nfunction importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {\n  const lineTextTrimmed = lineText.trim();\n  const textNode = lexical.$createTextNode(lineTextTrimmed);\n  const elementNode = lexical.$createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      replace(elementNode, [textNode], match, true);\n      break;\n    }\n  }\n\n  importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers); // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n\n  if (elementNode.isAttached() && lineTextTrimmed.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n\n    if (lexical.$isParagraphNode(previousNode) || richText.$isQuoteNode(previousNode) || list.$isListNode(previousNode)) {\n      let targetNode = previousNode;\n\n      if (list.$isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = utils.$findMatchingParent(lastDescendant, list.$isListItemNode);\n        }\n      }\n\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\n\nfunction importCodeBlock(lines, startLineIndex, rootNode) {\n  const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);\n\n  if (openMatch) {\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n\n    while (++endLineIndex < linesLength) {\n      const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);\n\n      if (closeMatch) {\n        const codeBlockNode = code.$createCodeNode(openMatch[1]);\n        const textNode = lexical.$createTextNode(lines.slice(startLineIndex + 1, endLineIndex).join('\\n'));\n        codeBlockNode.append(textNode);\n        rootNode.append(codeBlockNode);\n        return [codeBlockNode, endLineIndex];\n      }\n    }\n  }\n\n  return [null, startLineIndex];\n} // Processing text content and replaces text format tags.\n// It takes outermost tag match and its content, creates text node with\n// format based on tag and then recursively executed over node's content\n//\n// E.g. for \"*Hello **world**!*\" string it will create text node with\n// \"Hello **world**!\" content and italic format and run recursively over\n// its content to transform \"**world**\" part\n\n\nfunction importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n\n  if (!match) {\n    // Once text format processing is done run text match transformers, as it\n    // only can span within single text node (unline formats that can cover multiple nodes)\n    importTextMatchTransformers(textNode, textMatchTransformers);\n    return;\n  }\n\n  let currentNode, remainderNode, leadingNode; // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n\n  if (match[0] === textContent) {\n    currentNode = textNode;\n  } else {\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n\n    if (startIndex === 0) {\n      [currentNode, remainderNode] = textNode.splitText(endIndex);\n    } else {\n      [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n\n  currentNode.setTextContent(match[2]);\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!currentNode.hasFormat(format)) {\n        currentNode.toggleFormat(format);\n      }\n    }\n  } // Recursively run over inner text if it's not inline code\n\n\n  if (!currentNode.hasFormat('code')) {\n    importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);\n  } // Run over leading/remaining text if any\n\n\n  if (leadingNode) {\n    importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n\n  if (remainderNode) {\n    importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n}\n\nfunction importTextMatchTransformers(textNode_, textMatchTransformers) {\n  let textNode = textNode_;\n\n  mainLoop: while (textNode) {\n    for (const transformer of textMatchTransformers) {\n      const match = textNode.getTextContent().match(transformer.importRegExp);\n\n      if (!match) {\n        continue;\n      }\n\n      const startIndex = match.index || 0;\n      const endIndex = startIndex + match[0].length;\n      let replaceNode, leftTextNode, rightTextNode;\n\n      if (startIndex === 0) {\n        [replaceNode, textNode] = textNode.splitText(endIndex);\n      } else {\n        [leftTextNode, replaceNode, rightTextNode] = textNode.splitText(startIndex, endIndex);\n      }\n\n      if (leftTextNode) {\n        importTextMatchTransformers(leftTextNode, textMatchTransformers);\n      }\n\n      if (rightTextNode) {\n        textNode = rightTextNode;\n      }\n\n      transformer.replace(replaceNode, match);\n      continue mainLoop;\n    }\n\n    break;\n  }\n} // Finds first \"<tag>content<tag>\" match that is not nested into another tag\n\n\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n\n  if (openTagsMatch == null) {\n    return null;\n  }\n\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      } // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n\n\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n\n    if (IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\\\s])(.*?[^${tagRegExp}\\\\s])${tagRegExp}(?!${tagRegExp})`);\n    } else {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    }\n  }\n\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Reg exp to find opening tags\n    openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? '' : `${escapeRegExp}`) + '(' + openTagsRegExp.join('|') + ')', 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n\n  if (!lexical.$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n\n  const textContent = anchorNode.getTextContent(); // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n\n    if (match && match[0].length === anchorOffset) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      leadingNode.remove();\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      replace(parentNode, siblings, match, false);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n\n  if (transformers == null) {\n    return false;\n  } // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n\n\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n\n  for (const transformer of transformers) {\n    const match = textContent.match(transformer.regExp);\n\n    if (match === null) {\n      continue;\n    }\n\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n\n  return false;\n}\n\nfunction runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex]; // Quick check if we're possibly at the end of inline markdown style\n\n  const matchers = textFormatTransformers[closeChar];\n\n  if (!matchers) {\n    return false;\n  }\n\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1; // If tag is not single char check if rest of it matches with text content\n\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    } // Space before closing tag cancels inline markdown\n\n\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    } // Some tags can not be used within words, hence should have newline/space/punctuation after it\n\n\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag); // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n\n    let sibling = openNode;\n\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if (lexical.$isLineBreakNode(sibling)) {\n        break;\n      }\n\n      if (lexical.$isTextNode(sibling)) {\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    } // Opening tag is not found\n\n\n    if (openTagStartIndex < 0) {\n      continue;\n    } // No content between opening and closing tag\n\n\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    } // Checking longer tags for repeating chars (e.g. *** vs **)\n\n\n    const prevOpenNodeText = openNode.getTextContent();\n\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    } // Some tags can not be used within words, hence should have newline/space/punctuation before it\n\n\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    } // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n\n\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = lexical.$getSelection();\n    const nextSelection = lexical.$createRangeSelection();\n    lexical.$setSelection(nextSelection); // Adjust offset based on deleted chars\n\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text'); // Apply formatting to selected text\n\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    } // Collapse selection up to the focus point\n\n\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type); // Remove formatting from collapsed selection\n\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n\n    if (lexical.$isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) && // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n\n  return -1;\n}\n\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersIndex = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n\n  for (const transformer of transformers) {\n    const type = transformer.type;\n\n    if (type === 'element' || type === 'text-match') {\n      const dependencies = transformer.dependencies;\n\n      if (!editor.hasNodes(dependencies)) {\n        {\n          throw Error(`MarkdownShortcuts: missing dependency for transformer. Ensure node dependency is included in editor initial config.`);\n        }\n      }\n    }\n  }\n\n  const transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {\n      return;\n    }\n\n    runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);\n  };\n\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from undo/redo (as changes already calculated)\n    if (tags.has('historic')) {\n      return;\n    }\n\n    const selection = editorState.read(lexical.$getSelection);\n    const prevSelection = prevEditorState.read(lexical.$getSelection);\n\n    if (!lexical.$isRangeSelection(prevSelection) || !lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return;\n    }\n\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n\n    if (!lexical.$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset !== prevSelection.anchor.offset + 1) {\n      return;\n    }\n\n    editor.update(() => {\n      // Markdown is not available inside code\n      if (anchorNode.hasFormat('code')) {\n        return;\n      }\n\n      const parentNode = anchorNode.getParent();\n\n      if (parentNode === null || code.$isCodeNode(parentNode)) {\n        return;\n      }\n\n      transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst createBlockNode = createNode => {\n  return (parentNode, children, match) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  };\n}; // Amount of spaces that define indentation level\n// TODO: should be an option\n\n\nconst LIST_INDENT_SIZE = 4;\n\nconst listReplace = listType => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const listItem = list.$createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n\n    if (list.$isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list$1 = list.$createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list$1.append(listItem);\n      parentNode.replace(list$1);\n    }\n\n    listItem.append(...children);\n    listItem.select(0, 0);\n    const indent = Math.floor(match[1].length / LIST_INDENT_SIZE);\n\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\n\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n\n  for (const listItemNode of children) {\n    if (list.$isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n\n        if (list.$isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n\n  return output.join('\\n');\n};\n\nconst HEADING = {\n  dependencies: [richText.HeadingNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isHeadingNode(node)) {\n      return null;\n    }\n\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: /^(#{1,6})\\s/,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return richText.$createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [richText.QuoteNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isQuoteNode(node)) {\n      return null;\n    }\n\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n\n    return output.join('\\n');\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n\n      if (richText.$isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...children]);\n        previousNode.select(0, 0);\n        parentNode.remove();\n        return;\n      }\n    }\n\n    const node = richText.$createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [code.CodeNode],\n  export: node => {\n    if (!code.$isCodeNode(node)) {\n      return null;\n    }\n\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExp: /^```(\\w{1,10})?\\s/,\n  replace: createBlockNode(match => {\n    return code.$createCodeNode(match ? match[1] : undefined);\n  }),\n  type: 'element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(\\d{1,})\\.\\s/,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n}; // Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\n\nconst LINK = {\n  dependencies: [link.LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!link.$isLinkNode(node)) {\n      return null;\n    }\n\n    const linkContent = `[${node.getTextContent()}](${node.getURL()})`;\n    const firstChild = node.getFirstChild(); // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n\n    if (node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild)) {\n      return exportFormat(firstChild, linkContent);\n    } else {\n      return linkContent;\n    }\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\(([^()]+)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\(([^()]+)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl] = match;\n    const linkNode = link.$createLinkNode(linkUrl);\n    const linkTextNode = lexical.$createTextNode(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n  },\n  trigger: ')',\n  type: 'text-match'\n};\n\n/** @module @lexical/markdown */\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, CODE, UNORDERED_LIST, ORDERED_LIST]; // Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\n\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\n\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS) {\n  const importMarkdown = createMarkdownImport(transformers);\n  return importMarkdown(markdown);\n}\n\nfunction $convertToMarkdownString(transformers = TRANSFORMERS) {\n  const exportMarkdown = createMarkdownExport(transformers);\n  return exportMarkdown();\n}\n\nexports.$convertFromMarkdownString = $convertFromMarkdownString;\nexports.$convertToMarkdownString = $convertToMarkdownString;\nexports.BOLD_ITALIC_STAR = BOLD_ITALIC_STAR;\nexports.BOLD_ITALIC_UNDERSCORE = BOLD_ITALIC_UNDERSCORE;\nexports.BOLD_STAR = BOLD_STAR;\nexports.BOLD_UNDERSCORE = BOLD_UNDERSCORE;\nexports.CHECK_LIST = CHECK_LIST;\nexports.CODE = CODE;\nexports.ELEMENT_TRANSFORMERS = ELEMENT_TRANSFORMERS;\nexports.HEADING = HEADING;\nexports.HIGHLIGHT = HIGHLIGHT;\nexports.INLINE_CODE = INLINE_CODE;\nexports.ITALIC_STAR = ITALIC_STAR;\nexports.ITALIC_UNDERSCORE = ITALIC_UNDERSCORE;\nexports.LINK = LINK;\nexports.ORDERED_LIST = ORDERED_LIST;\nexports.QUOTE = QUOTE;\nexports.STRIKETHROUGH = STRIKETHROUGH;\nexports.TEXT_FORMAT_TRANSFORMERS = TEXT_FORMAT_TRANSFORMERS;\nexports.TEXT_MATCH_TRANSFORMERS = TEXT_MATCH_TRANSFORMERS;\nexports.TRANSFORMERS = TRANSFORMERS;\nexports.UNORDERED_LIST = UNORDERED_LIST;\nexports.registerMarkdownShortcuts = registerMarkdownShortcuts;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFya2Rvd24vTGV4aWNhbE1hcmtkb3duLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsd0RBQVM7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLHdFQUFlO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyx3RUFBZTtBQUNsQyxlQUFlLG1CQUFPLENBQUMsc0ZBQW9CO0FBQzNDLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLHdFQUFlOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7O0FBRUEsK0VBQStFOztBQUUvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDLG9DQUFvQyxLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQyxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEZBQThGO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxVQUFVLE9BQU8sVUFBVSxhQUFhLFVBQVUsT0FBTyxVQUFVLEtBQUssVUFBVTtBQUNuSSxNQUFNO0FBQ04seURBQXlELFVBQVUsS0FBSyxVQUFVLFNBQVMsVUFBVSxTQUFTLFVBQVUsV0FBVyxVQUFVLCtCQUErQixVQUFVLFdBQVcsVUFBVTtBQUMzTTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGFBQWE7QUFDOUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBLGlFQUFpRTs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTiw2R0FBNkc7O0FBRTdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QixnQkFBZ0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsNEJBQTRCLG1DQUFtQyxzQ0FBc0M7QUFDcko7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlLElBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQixLQUFLO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxxQkFBcUIsR0FBRztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLHNCQUFzQixJQUFJLGNBQWM7QUFDcEUsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDLGdDQUFnQztBQUNoQyx3QkFBd0I7QUFDeEIsOEJBQThCO0FBQzlCLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCLFlBQVk7QUFDWiw0QkFBNEI7QUFDNUIsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLHlCQUF5QjtBQUN6QixZQUFZO0FBQ1osb0JBQW9CO0FBQ3BCLGFBQWE7QUFDYixxQkFBcUI7QUFDckIsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL21hcmtkb3duL0xleGljYWxNYXJrZG93bi5kZXYuanM/YzZlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG52YXIgY29kZSA9IHJlcXVpcmUoJ0BsZXhpY2FsL2NvZGUnKTtcbnZhciBsaXN0ID0gcmVxdWlyZSgnQGxleGljYWwvbGlzdCcpO1xudmFyIHJpY2hUZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmljaC10ZXh0Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxpbmsgPSByZXF1aXJlKCdAbGV4aWNhbC9saW5rJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gaW5kZXhCeShsaXN0LCBjYWxsYmFjaykge1xuICBjb25zdCBpbmRleCA9IHt9O1xuXG4gIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0KSB7XG4gICAgY29uc3Qga2V5ID0gY2FsbGJhY2soaXRlbSk7XG5cbiAgICBpZiAoaW5kZXhba2V5XSkge1xuICAgICAgaW5kZXhba2V5XS5wdXNoKGl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleFtrZXldID0gW2l0ZW1dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyc0J5VHlwZSh0cmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgYnlUeXBlID0gaW5kZXhCeSh0cmFuc2Zvcm1lcnMsIHQgPT4gdC50eXBlKTtcbiAgcmV0dXJuIHtcbiAgICBlbGVtZW50OiBieVR5cGUuZWxlbWVudCB8fCBbXSxcbiAgICB0ZXh0Rm9ybWF0OiBieVR5cGVbJ3RleHQtZm9ybWF0J10gfHwgW10sXG4gICAgdGV4dE1hdGNoOiBieVR5cGVbJ3RleHQtbWF0Y2gnXSB8fCBbXVxuICB9O1xufVxuY29uc3QgUFVOQ1RVQVRJT05fT1JfU1BBQ0UgPSAvWyEtLzotQFstYHstflxcc10vO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBjcmVhdGVNYXJrZG93bkV4cG9ydCh0cmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgYnlUeXBlID0gdHJhbnNmb3JtZXJzQnlUeXBlKHRyYW5zZm9ybWVycyk7IC8vIEV4cG9ydCBvbmx5IHVzZXMgdGV4dCBmb3JtYXRzIHRoYXQgYXJlIHJlc3BvbnNpYmxlIGZvciBzaW5nbGUgZm9ybWF0XG4gIC8vIGUuZy4gaXQgd2lsbCBmaWx0ZXIgb3V0ICoqKiAoYm9sZCwgaXRhbGljKSBhbmQgaW5zdGVhZCB1c2Ugc2VwYXJhdGUgKiogYW5kICpcblxuICBjb25zdCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzID0gYnlUeXBlLnRleHRGb3JtYXQuZmlsdGVyKHRyYW5zZm9ybWVyID0+IHRyYW5zZm9ybWVyLmZvcm1hdC5sZW5ndGggPT09IDEpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbGV4aWNhbC4kZ2V0Um9vdCgpLmdldENoaWxkcmVuKCk7XG5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBleHBvcnRUb3BMZXZlbEVsZW1lbnRzKGNoaWxkLCBieVR5cGUuZWxlbWVudCwgdGV4dEZvcm1hdFRyYW5zZm9ybWVycywgYnlUeXBlLnRleHRNYXRjaCk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBvdXRwdXQucHVzaChyZXN1bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbignXFxuXFxuJyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cG9ydFRvcExldmVsRWxlbWVudHMobm9kZSwgZWxlbWVudFRyYW5zZm9ybWVycywgdGV4dFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpIHtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiBlbGVtZW50VHJhbnNmb3JtZXJzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNmb3JtZXIuZXhwb3J0KG5vZGUsIF9ub2RlID0+IGV4cG9ydENoaWxkcmVuKF9ub2RlLCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycykpO1xuXG4gICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIGV4cG9ydENoaWxkcmVuKG5vZGUsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKTtcbiAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cG9ydENoaWxkcmVuKG5vZGUsIHRleHRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcblxuICBtYWluTG9vcDogZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0cmFuc2Zvcm1lci5leHBvcnQoY2hpbGQsIHBhcmVudE5vZGUgPT4gZXhwb3J0Q2hpbGRyZW4ocGFyZW50Tm9kZSwgdGV4dFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpLCAodGV4dE5vZGUsIHRleHRDb250ZW50KSA9PiBleHBvcnRUZXh0Rm9ybWF0KHRleHROb2RlLCB0ZXh0Q29udGVudCwgdGV4dFRyYW5zZm9ybWVyc0luZGV4KSk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBvdXRwdXQucHVzaChyZXN1bHQpO1xuICAgICAgICBjb250aW51ZSBtYWluTG9vcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKGNoaWxkKSkge1xuICAgICAgb3V0cHV0LnB1c2goJ1xcbicpO1xuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGV4cG9ydFRleHRGb3JtYXQoY2hpbGQsIGNoaWxkLmdldFRleHRDb250ZW50KCksIHRleHRUcmFuc2Zvcm1lcnNJbmRleCkpO1xuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjaGlsZCkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGV4cG9ydENoaWxkcmVuKGNoaWxkLCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycykpO1xuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNEZWNvcmF0b3JOb2RlKGNoaWxkKSkge1xuICAgICAgb3V0cHV0LnB1c2goY2hpbGQuZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn1cblxuZnVuY3Rpb24gZXhwb3J0VGV4dEZvcm1hdChub2RlLCB0ZXh0Q29udGVudCwgdGV4dFRyYW5zZm9ybWVycykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhlIGNhc2Ugb2YgYSBzdHJpbmcgbG9va2luZyBsaWtlIHRoaXM6IFwiICAgZm9vICAgXCJcbiAgLy8gV2hlcmUgaXQgd291bGQgYmUgaW52YWxpZCBtYXJrZG93biB0byBnZW5lcmF0ZTogXCIqKiAgIGZvbyAgICoqXCJcbiAgLy8gV2UgaW5zdGVhZCB3YW50IHRvIHRyaW0gdGhlIHdoaXRlc3BhY2Ugb3V0LCBhcHBseSBmb3JtYXR0aW5nLCBhbmQgdGhlblxuICAvLyBicmluZyB0aGUgd2hpdGVzcGFjZSBiYWNrLiBTbyBvdXIgcmV0dXJuZWQgc3RyaW5nIGxvb2tzIGxpa2UgdGhpczogXCIgICAqKmZvbyoqICAgXCJcbiAgY29uc3QgZnJvemVuU3RyaW5nID0gdGV4dENvbnRlbnQudHJpbSgpO1xuICBsZXQgb3V0cHV0ID0gZnJvemVuU3RyaW5nO1xuICBjb25zdCBhcHBsaWVkID0gbmV3IFNldCgpO1xuXG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdGV4dFRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRyYW5zZm9ybWVyLmZvcm1hdFswXTtcbiAgICBjb25zdCB0YWcgPSB0cmFuc2Zvcm1lci50YWc7XG5cbiAgICBpZiAoaGFzRm9ybWF0KG5vZGUsIGZvcm1hdCkgJiYgIWFwcGxpZWQuaGFzKGZvcm1hdCkpIHtcbiAgICAgIC8vIE11bHRpcGxlIHRhZ3MgbWlnaHQgYmUgdXNlZCBmb3IgdGhlIHNhbWUgZm9ybWF0ICgqLCBfKVxuICAgICAgYXBwbGllZC5hZGQoZm9ybWF0KTsgLy8gUHJldmVudCBhZGRpbmcgb3BlbmluZyB0YWcgaXMgYWxyZWFkeSBvcGVuZWQgYnkgdGhlIHByZXZpb3VzIHNpYmxpbmdcblxuICAgICAgY29uc3QgcHJldmlvdXNOb2RlID0gZ2V0VGV4dFNpYmxpbmcobm9kZSwgdHJ1ZSk7XG5cbiAgICAgIGlmICghaGFzRm9ybWF0KHByZXZpb3VzTm9kZSwgZm9ybWF0KSkge1xuICAgICAgICBvdXRwdXQgPSB0YWcgKyBvdXRwdXQ7XG4gICAgICB9IC8vIFByZXZlbnQgYWRkaW5nIGNsb3NpbmcgdGFnIGlmIG5leHQgc2libGluZyB3aWxsIGRvIGl0XG5cblxuICAgICAgY29uc3QgbmV4dE5vZGUgPSBnZXRUZXh0U2libGluZyhub2RlLCBmYWxzZSk7XG5cbiAgICAgIGlmICghaGFzRm9ybWF0KG5leHROb2RlLCBmb3JtYXQpKSB7XG4gICAgICAgIG91dHB1dCArPSB0YWc7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlcGxhY2UgdHJpbW1lZCB2ZXJzaW9uIG9mIHRleHRDb250ZW50IGVuc3VyaW5nIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2UgaXMgbm90IG1vZGlmaWVkXG5cblxuICByZXR1cm4gdGV4dENvbnRlbnQucmVwbGFjZShmcm96ZW5TdHJpbmcsIG91dHB1dCk7XG59IC8vIEdldCBuZXh0IG9yIHByZXZpb3VzIHRleHQgc2libGluZyBhIHRleHQgbm9kZSwgaW5jbHVkaW5nIGNhc2VzXG4vLyB3aGVuIGl0J3MgYSBjaGlsZCBvZiBpbmxpbmUgZWxlbWVudCAoZS5nLiBsaW5rKVxuXG5cbmZ1bmN0aW9uIGdldFRleHRTaWJsaW5nKG5vZGUsIGJhY2t3YXJkKSB7XG4gIGxldCBzaWJsaW5nID0gYmFja3dhcmQgPyBub2RlLmdldFByZXZpb3VzU2libGluZygpIDogbm9kZS5nZXROZXh0U2libGluZygpO1xuXG4gIGlmICghc2libGluZykge1xuICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gICAgaWYgKHBhcmVudC5pc0lubGluZSgpKSB7XG4gICAgICBzaWJsaW5nID0gYmFja3dhcmQgPyBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBwYXJlbnQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoc2libGluZykge1xuICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKHNpYmxpbmcpKSB7XG4gICAgICBpZiAoIXNpYmxpbmcuaXNJbmxpbmUoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVzY2VuZGFudCA9IGJhY2t3YXJkID8gc2libGluZy5nZXRMYXN0RGVzY2VuZGFudCgpIDogc2libGluZy5nZXRGaXJzdERlc2NlbmRhbnQoKTtcblxuICAgICAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoZGVzY2VuZGFudCkpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NlbmRhbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWJsaW5nID0gYmFja3dhcmQgPyBzaWJsaW5nLmdldFByZXZpb3VzU2libGluZygpIDogc2libGluZy5nZXROZXh0U2libGluZygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKHNpYmxpbmcpKSB7XG4gICAgICByZXR1cm4gc2libGluZztcbiAgICB9XG5cbiAgICBpZiAoIWxleGljYWwuJGlzRWxlbWVudE5vZGUoc2libGluZykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBoYXNGb3JtYXQobm9kZSwgZm9ybWF0KSB7XG4gIHJldHVybiBsZXhpY2FsLiRpc1RleHROb2RlKG5vZGUpICYmIG5vZGUuaGFzRm9ybWF0KGZvcm1hdCk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgZG9jdW1lbnRNb2RlID0gQ0FOX1VTRV9ET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBudWxsO1xuQ0FOX1VTRV9ET00gJiYgL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5DQU5fVVNFX0RPTSAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5DQU5fVVNFX0RPTSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcbmNvbnN0IElTX1NBRkFSSSA9IENBTl9VU0VfRE9NICYmIC9WZXJzaW9uXFwvW1xcZC5dKy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgSVNfSU9TID0gQ0FOX1VTRV9ET00gJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTsgLy8gS2VlcCB0aGVzZSBpbiBjYXNlIHdlIG5lZWQgdG8gdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZS5cbi8vIGV4cG9ydCBjb25zdCBJU19XSU5ET1dTOiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG5jb25zdCBJU19DSFJPTUUgPSBDQU5fVVNFX0RPTSAmJiAvXig/PS4qQ2hyb21lKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gZXhwb3J0IGNvbnN0IGNhblVzZVRleHRJbnB1dEV2ZW50OiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbmNvbnN0IElTX0FQUExFX1dFQktJVCA9IENBTl9VU0VfRE9NICYmIC9BcHBsZVdlYktpdFxcL1tcXGQuXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIUlTX0NIUk9NRTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgTUFSS0RPV05fRU1QVFlfTElORV9SRUdfRVhQID0gL15cXHN7MCwzfSQvO1xuY29uc3QgQ09ERV9CTE9DS19SRUdfRVhQID0gL15gYGAoXFx3ezEsMTB9KT9cXHM/JC87XG5mdW5jdGlvbiBjcmVhdGVNYXJrZG93bkltcG9ydCh0cmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgYnlUeXBlID0gdHJhbnNmb3JtZXJzQnlUeXBlKHRyYW5zZm9ybWVycyk7XG4gIGNvbnN0IHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCA9IGNyZWF0ZVRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleChieVR5cGUudGV4dEZvcm1hdCk7XG4gIHJldHVybiBtYXJrZG93blN0cmluZyA9PiB7XG4gICAgY29uc3QgbGluZXMgPSBtYXJrZG93blN0cmluZy5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3QgbGluZXNMZW5ndGggPSBsaW5lcy5sZW5ndGg7XG4gICAgY29uc3Qgcm9vdCA9IGxleGljYWwuJGdldFJvb3QoKTtcbiAgICByb290LmNsZWFyKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmVUZXh0ID0gbGluZXNbaV07IC8vIENvZGVibG9ja3MgYXJlIHByb2Nlc3NlZCBmaXJzdCBhcyBhbnl0aGluZyBpbnNpZGUgc3VjaCBibG9ja1xuICAgICAgLy8gaXMgaWdub3JlZCBmb3IgZnVydGhlciBwcm9jZXNzaW5nXG4gICAgICAvLyBUT0RPOlxuICAgICAgLy8gQWJzdHJhY3QgaXQgdG8gYmUgZHluYW1pYyBhcyBvdGhlciB0cmFuc2Zvcm1lcnMgKGFkZCBtdWx0aWxpbmUgbWF0Y2ggb3B0aW9uKVxuXG4gICAgICBjb25zdCBbY29kZUJsb2NrTm9kZSwgc2hpZnRlZEluZGV4XSA9IGltcG9ydENvZGVCbG9jayhsaW5lcywgaSwgcm9vdCk7XG5cbiAgICAgIGlmIChjb2RlQmxvY2tOb2RlICE9IG51bGwpIHtcbiAgICAgICAgaSA9IHNoaWZ0ZWRJbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGltcG9ydEJsb2NrcyhsaW5lVGV4dCwgcm9vdCwgYnlUeXBlLmVsZW1lbnQsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCwgYnlUeXBlLnRleHRNYXRjaCk7XG4gICAgfSAvLyBSZW1vdmluZyBlbXB0eSBwYXJhZ3JhcGhzIGFzIG1kIGRvZXMgbm90IHJlYWxseVxuICAgIC8vIGFsbG93IGVtcHR5IGxpbmVzIGFuZCB1c2VzIHRoZW0gYXMgZGlsaW1pdGVyXG5cblxuICAgIGNvbnN0IGNoaWxkcmVuID0gcm9vdC5nZXRDaGlsZHJlbigpO1xuXG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKGlzRW1wdHlQYXJhZ3JhcGgoY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJvb3Quc2VsZWN0RW5kKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlQYXJhZ3JhcGgobm9kZSkge1xuICBpZiAoIWxleGljYWwuJGlzUGFyYWdyYXBoTm9kZShub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgcmV0dXJuIGZpcnN0Q2hpbGQgPT0gbnVsbCB8fCBub2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAxICYmIGxleGljYWwuJGlzVGV4dE5vZGUoZmlyc3RDaGlsZCkgJiYgTUFSS0RPV05fRU1QVFlfTElORV9SRUdfRVhQLnRlc3QoZmlyc3RDaGlsZC5nZXRUZXh0Q29udGVudCgpKTtcbn1cblxuZnVuY3Rpb24gaW1wb3J0QmxvY2tzKGxpbmVUZXh0LCByb290Tm9kZSwgZWxlbWVudFRyYW5zZm9ybWVycywgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgbGluZVRleHRUcmltbWVkID0gbGluZVRleHQudHJpbSgpO1xuICBjb25zdCB0ZXh0Tm9kZSA9IGxleGljYWwuJGNyZWF0ZVRleHROb2RlKGxpbmVUZXh0VHJpbW1lZCk7XG4gIGNvbnN0IGVsZW1lbnROb2RlID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICBlbGVtZW50Tm9kZS5hcHBlbmQodGV4dE5vZGUpO1xuICByb290Tm9kZS5hcHBlbmQoZWxlbWVudE5vZGUpO1xuXG4gIGZvciAoY29uc3Qge1xuICAgIHJlZ0V4cCxcbiAgICByZXBsYWNlXG4gIH0gb2YgZWxlbWVudFRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IG1hdGNoID0gbGluZVRleHQubWF0Y2gocmVnRXhwKTtcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgdGV4dE5vZGUuc2V0VGV4dENvbnRlbnQobGluZVRleHQuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKSk7XG4gICAgICByZXBsYWNlKGVsZW1lbnROb2RlLCBbdGV4dE5vZGVdLCBtYXRjaCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpbXBvcnRUZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKHRleHROb2RlLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7IC8vIElmIG5vIHRyYW5zZm9ybWVyIGZvdW5kIGFuZCB3ZSBsZWZ0IHdpdGggb3JpZ2luYWwgcGFyYWdyYXBoIG5vZGVcbiAgLy8gY2FuIGNoZWNrIGlmIGl0cyBjb250ZW50IGNhbiBiZSBhcHBlbmRlZCB0byB0aGUgcHJldmlvdXMgbm9kZVxuICAvLyBpZiBpdCdzIGEgcGFyYWdyYXBoLCBxdW90ZSBvciBsaXN0XG5cbiAgaWYgKGVsZW1lbnROb2RlLmlzQXR0YWNoZWQoKSAmJiBsaW5lVGV4dFRyaW1tZWQubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHByZXZpb3VzTm9kZSA9IGVsZW1lbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzUGFyYWdyYXBoTm9kZShwcmV2aW91c05vZGUpIHx8IHJpY2hUZXh0LiRpc1F1b3RlTm9kZShwcmV2aW91c05vZGUpIHx8IGxpc3QuJGlzTGlzdE5vZGUocHJldmlvdXNOb2RlKSkge1xuICAgICAgbGV0IHRhcmdldE5vZGUgPSBwcmV2aW91c05vZGU7XG5cbiAgICAgIGlmIChsaXN0LiRpc0xpc3ROb2RlKHByZXZpb3VzTm9kZSkpIHtcbiAgICAgICAgY29uc3QgbGFzdERlc2NlbmRhbnQgPSBwcmV2aW91c05vZGUuZ2V0TGFzdERlc2NlbmRhbnQoKTtcblxuICAgICAgICBpZiAobGFzdERlc2NlbmRhbnQgPT0gbnVsbCkge1xuICAgICAgICAgIHRhcmdldE5vZGUgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KGxhc3REZXNjZW5kYW50LCBsaXN0LiRpc0xpc3RJdGVtTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldE5vZGUgIT0gbnVsbCAmJiB0YXJnZXROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpID4gMCkge1xuICAgICAgICB0YXJnZXROb2RlLnNwbGljZSh0YXJnZXROb2RlLmdldENoaWxkcmVuU2l6ZSgpLCAwLCBbbGV4aWNhbC4kY3JlYXRlTGluZUJyZWFrTm9kZSgpLCAuLi5lbGVtZW50Tm9kZS5nZXRDaGlsZHJlbigpXSk7XG4gICAgICAgIGVsZW1lbnROb2RlLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbXBvcnRDb2RlQmxvY2sobGluZXMsIHN0YXJ0TGluZUluZGV4LCByb290Tm9kZSkge1xuICBjb25zdCBvcGVuTWF0Y2ggPSBsaW5lc1tzdGFydExpbmVJbmRleF0ubWF0Y2goQ09ERV9CTE9DS19SRUdfRVhQKTtcblxuICBpZiAob3Blbk1hdGNoKSB7XG4gICAgbGV0IGVuZExpbmVJbmRleCA9IHN0YXJ0TGluZUluZGV4O1xuICAgIGNvbnN0IGxpbmVzTGVuZ3RoID0gbGluZXMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsrZW5kTGluZUluZGV4IDwgbGluZXNMZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNsb3NlTWF0Y2ggPSBsaW5lc1tlbmRMaW5lSW5kZXhdLm1hdGNoKENPREVfQkxPQ0tfUkVHX0VYUCk7XG5cbiAgICAgIGlmIChjbG9zZU1hdGNoKSB7XG4gICAgICAgIGNvbnN0IGNvZGVCbG9ja05vZGUgPSBjb2RlLiRjcmVhdGVDb2RlTm9kZShvcGVuTWF0Y2hbMV0pO1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IGxleGljYWwuJGNyZWF0ZVRleHROb2RlKGxpbmVzLnNsaWNlKHN0YXJ0TGluZUluZGV4ICsgMSwgZW5kTGluZUluZGV4KS5qb2luKCdcXG4nKSk7XG4gICAgICAgIGNvZGVCbG9ja05vZGUuYXBwZW5kKHRleHROb2RlKTtcbiAgICAgICAgcm9vdE5vZGUuYXBwZW5kKGNvZGVCbG9ja05vZGUpO1xuICAgICAgICByZXR1cm4gW2NvZGVCbG9ja05vZGUsIGVuZExpbmVJbmRleF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtudWxsLCBzdGFydExpbmVJbmRleF07XG59IC8vIFByb2Nlc3NpbmcgdGV4dCBjb250ZW50IGFuZCByZXBsYWNlcyB0ZXh0IGZvcm1hdCB0YWdzLlxuLy8gSXQgdGFrZXMgb3V0ZXJtb3N0IHRhZyBtYXRjaCBhbmQgaXRzIGNvbnRlbnQsIGNyZWF0ZXMgdGV4dCBub2RlIHdpdGhcbi8vIGZvcm1hdCBiYXNlZCBvbiB0YWcgYW5kIHRoZW4gcmVjdXJzaXZlbHkgZXhlY3V0ZWQgb3ZlciBub2RlJ3MgY29udGVudFxuLy9cbi8vIEUuZy4gZm9yIFwiKkhlbGxvICoqd29ybGQqKiEqXCIgc3RyaW5nIGl0IHdpbGwgY3JlYXRlIHRleHQgbm9kZSB3aXRoXG4vLyBcIkhlbGxvICoqd29ybGQqKiFcIiBjb250ZW50IGFuZCBpdGFsaWMgZm9ybWF0IGFuZCBydW4gcmVjdXJzaXZlbHkgb3ZlclxuLy8gaXRzIGNvbnRlbnQgdG8gdHJhbnNmb3JtIFwiKip3b3JsZCoqXCIgcGFydFxuXG5cbmZ1bmN0aW9uIGltcG9ydFRleHRGb3JtYXRUcmFuc2Zvcm1lcnModGV4dE5vZGUsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IHRleHRDb250ZW50ID0gdGV4dE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgY29uc3QgbWF0Y2ggPSBmaW5kT3V0ZXJtb3N0TWF0Y2godGV4dENvbnRlbnQsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCk7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIC8vIE9uY2UgdGV4dCBmb3JtYXQgcHJvY2Vzc2luZyBpcyBkb25lIHJ1biB0ZXh0IG1hdGNoIHRyYW5zZm9ybWVycywgYXMgaXRcbiAgICAvLyBvbmx5IGNhbiBzcGFuIHdpdGhpbiBzaW5nbGUgdGV4dCBub2RlICh1bmxpbmUgZm9ybWF0cyB0aGF0IGNhbiBjb3ZlciBtdWx0aXBsZSBub2RlcylcbiAgICBpbXBvcnRUZXh0TWF0Y2hUcmFuc2Zvcm1lcnModGV4dE5vZGUsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGN1cnJlbnROb2RlLCByZW1haW5kZXJOb2RlLCBsZWFkaW5nTm9kZTsgLy8gSWYgbWF0Y2hpbmcgZnVsbCBjb250ZW50IHRoZXJlJ3Mgbm8gbmVlZCB0byBydW4gc3BsaXRUZXh0IGFuZCBjYW4gcmV1c2UgZXhpc3RpbmcgdGV4dE5vZGVcbiAgLy8gdG8gdXBkYXRlIGl0cyBjb250ZW50IGFuZCBhcHBseSBmb3JtYXQuIEUuZy4gZm9yICoqX0hlbGxvXyoqIHN0cmluZyBhZnRlciBhcHBseWluZyBib2xkXG4gIC8vIGZvcm1hdCAoKiopIGl0IHdpbGwgcmV1c2UgdGhlIHNhbWUgdGV4dCBub2RlIHRvIGFwcGx5IGl0YWxpYyAoXylcblxuICBpZiAobWF0Y2hbMF0gPT09IHRleHRDb250ZW50KSB7XG4gICAgY3VycmVudE5vZGUgPSB0ZXh0Tm9kZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gbWF0Y2guaW5kZXggfHwgMDtcbiAgICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG5cbiAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCkge1xuICAgICAgW2N1cnJlbnROb2RlLCByZW1haW5kZXJOb2RlXSA9IHRleHROb2RlLnNwbGl0VGV4dChlbmRJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFtsZWFkaW5nTm9kZSwgY3VycmVudE5vZGUsIHJlbWFpbmRlck5vZGVdID0gdGV4dE5vZGUuc3BsaXRUZXh0KHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICB9XG4gIH1cblxuICBjdXJyZW50Tm9kZS5zZXRUZXh0Q29udGVudChtYXRjaFsyXSk7XG4gIGNvbnN0IHRyYW5zZm9ybWVyID0gdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4LnRyYW5zZm9ybWVyc0J5VGFnW21hdGNoWzFdXTtcblxuICBpZiAodHJhbnNmb3JtZXIpIHtcbiAgICBmb3IgKGNvbnN0IGZvcm1hdCBvZiB0cmFuc2Zvcm1lci5mb3JtYXQpIHtcbiAgICAgIGlmICghY3VycmVudE5vZGUuaGFzRm9ybWF0KGZvcm1hdCkpIHtcbiAgICAgICAgY3VycmVudE5vZGUudG9nZ2xlRm9ybWF0KGZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlY3Vyc2l2ZWx5IHJ1biBvdmVyIGlubmVyIHRleHQgaWYgaXQncyBub3QgaW5saW5lIGNvZGVcblxuXG4gIGlmICghY3VycmVudE5vZGUuaGFzRm9ybWF0KCdjb2RlJykpIHtcbiAgICBpbXBvcnRUZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKGN1cnJlbnROb2RlLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7XG4gIH0gLy8gUnVuIG92ZXIgbGVhZGluZy9yZW1haW5pbmcgdGV4dCBpZiBhbnlcblxuXG4gIGlmIChsZWFkaW5nTm9kZSkge1xuICAgIGltcG9ydFRleHRGb3JtYXRUcmFuc2Zvcm1lcnMobGVhZGluZ05vZGUsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCwgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKTtcbiAgfVxuXG4gIGlmIChyZW1haW5kZXJOb2RlKSB7XG4gICAgaW1wb3J0VGV4dEZvcm1hdFRyYW5zZm9ybWVycyhyZW1haW5kZXJOb2RlLCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXgsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW1wb3J0VGV4dE1hdGNoVHJhbnNmb3JtZXJzKHRleHROb2RlXywgdGV4dE1hdGNoVHJhbnNmb3JtZXJzKSB7XG4gIGxldCB0ZXh0Tm9kZSA9IHRleHROb2RlXztcblxuICBtYWluTG9vcDogd2hpbGUgKHRleHROb2RlKSB7XG4gICAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnMpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gdGV4dE5vZGUuZ2V0VGV4dENvbnRlbnQoKS5tYXRjaCh0cmFuc2Zvcm1lci5pbXBvcnRSZWdFeHApO1xuXG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFydEluZGV4ID0gbWF0Y2guaW5kZXggfHwgMDtcbiAgICAgIGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIGxldCByZXBsYWNlTm9kZSwgbGVmdFRleHROb2RlLCByaWdodFRleHROb2RlO1xuXG4gICAgICBpZiAoc3RhcnRJbmRleCA9PT0gMCkge1xuICAgICAgICBbcmVwbGFjZU5vZGUsIHRleHROb2RlXSA9IHRleHROb2RlLnNwbGl0VGV4dChlbmRJbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbbGVmdFRleHROb2RlLCByZXBsYWNlTm9kZSwgcmlnaHRUZXh0Tm9kZV0gPSB0ZXh0Tm9kZS5zcGxpdFRleHQoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVmdFRleHROb2RlKSB7XG4gICAgICAgIGltcG9ydFRleHRNYXRjaFRyYW5zZm9ybWVycyhsZWZ0VGV4dE5vZGUsIHRleHRNYXRjaFRyYW5zZm9ybWVycyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyaWdodFRleHROb2RlKSB7XG4gICAgICAgIHRleHROb2RlID0gcmlnaHRUZXh0Tm9kZTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNmb3JtZXIucmVwbGFjZShyZXBsYWNlTm9kZSwgbWF0Y2gpO1xuICAgICAgY29udGludWUgbWFpbkxvb3A7XG4gICAgfVxuXG4gICAgYnJlYWs7XG4gIH1cbn0gLy8gRmluZHMgZmlyc3QgXCI8dGFnPmNvbnRlbnQ8dGFnPlwiIG1hdGNoIHRoYXQgaXMgbm90IG5lc3RlZCBpbnRvIGFub3RoZXIgdGFnXG5cblxuZnVuY3Rpb24gZmluZE91dGVybW9zdE1hdGNoKHRleHRDb250ZW50LCB0ZXh0VHJhbnNmb3JtZXJzSW5kZXgpIHtcbiAgY29uc3Qgb3BlblRhZ3NNYXRjaCA9IHRleHRDb250ZW50Lm1hdGNoKHRleHRUcmFuc2Zvcm1lcnNJbmRleC5vcGVuVGFnc1JlZ0V4cCk7XG5cbiAgaWYgKG9wZW5UYWdzTWF0Y2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZm9yIChjb25zdCBtYXRjaCBvZiBvcGVuVGFnc01hdGNoKSB7XG4gICAgLy8gT3BlbiB0YWdzIHJlZyBleHAgbWlnaHQgY2FwdHVyZSBsZWFkaW5nIHNwYWNlIHNvIHJlbW92aW5nIGl0XG4gICAgLy8gYmVmb3JlIHVzaW5nIG1hdGNoIHRvIGZpbmQgdHJhbnNmb3JtZXJcbiAgICBjb25zdCB0YWcgPSBtYXRjaC5yZXBsYWNlKC9eXFxzLywgJycpO1xuICAgIGNvbnN0IGZ1bGxNYXRjaFJlZ0V4cCA9IHRleHRUcmFuc2Zvcm1lcnNJbmRleC5mdWxsTWF0Y2hSZWdFeHBCeVRhZ1t0YWddO1xuXG4gICAgaWYgKGZ1bGxNYXRjaFJlZ0V4cCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBmdWxsTWF0Y2ggPSB0ZXh0Q29udGVudC5tYXRjaChmdWxsTWF0Y2hSZWdFeHApO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gdGV4dFRyYW5zZm9ybWVyc0luZGV4LnRyYW5zZm9ybWVyc0J5VGFnW3RhZ107XG5cbiAgICBpZiAoZnVsbE1hdGNoICE9IG51bGwgJiYgdHJhbnNmb3JtZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHRyYW5zZm9ybWVyLmludHJhd29yZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bGxNYXRjaDtcbiAgICAgIH0gLy8gRm9yIG5vbi1pbnRyYXdvcmQgdHJhbnNmb3JtZXJzIGNoZWNraW5nIGlmIGl0J3Mgd2l0aGluIGEgd29yZFxuICAgICAgLy8gb3Igc3Vycm91bmRlZCB3aXRoIHNwYWNlL3B1bmN0dWF0aW9uL25ld2xpbmVcblxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGluZGV4ID0gMFxuICAgICAgfSA9IGZ1bGxNYXRjaDtcbiAgICAgIGNvbnN0IGJlZm9yZUNoYXIgPSB0ZXh0Q29udGVudFtpbmRleCAtIDFdO1xuICAgICAgY29uc3QgYWZ0ZXJDaGFyID0gdGV4dENvbnRlbnRbaW5kZXggKyBmdWxsTWF0Y2hbMF0ubGVuZ3RoXTtcblxuICAgICAgaWYgKCghYmVmb3JlQ2hhciB8fCBQVU5DVFVBVElPTl9PUl9TUEFDRS50ZXN0KGJlZm9yZUNoYXIpKSAmJiAoIWFmdGVyQ2hhciB8fCBQVU5DVFVBVElPTl9PUl9TUEFDRS50ZXN0KGFmdGVyQ2hhcikpKSB7XG4gICAgICAgIHJldHVybiBmdWxsTWF0Y2g7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRGb3JtYXRUcmFuc2Zvcm1lcnNJbmRleCh0ZXh0VHJhbnNmb3JtZXJzKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVyc0J5VGFnID0ge307XG4gIGNvbnN0IGZ1bGxNYXRjaFJlZ0V4cEJ5VGFnID0ge307XG4gIGNvbnN0IG9wZW5UYWdzUmVnRXhwID0gW107XG4gIGNvbnN0IGVzY2FwZVJlZ0V4cCA9IGAoPzwhW1xcXFxcXFxcXSlgO1xuXG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdGV4dFRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIHRhZ1xuICAgIH0gPSB0cmFuc2Zvcm1lcjtcbiAgICB0cmFuc2Zvcm1lcnNCeVRhZ1t0YWddID0gdHJhbnNmb3JtZXI7XG4gICAgY29uc3QgdGFnUmVnRXhwID0gdGFnLnJlcGxhY2UoLyhcXCp8XFxefFxcKykvZywgJ1xcXFwkMScpO1xuICAgIG9wZW5UYWdzUmVnRXhwLnB1c2godGFnUmVnRXhwKTtcblxuICAgIGlmIChJU19TQUZBUkkgfHwgSVNfSU9TIHx8IElTX0FQUExFX1dFQktJVCkge1xuICAgICAgZnVsbE1hdGNoUmVnRXhwQnlUYWdbdGFnXSA9IG5ldyBSZWdFeHAoYCgke3RhZ1JlZ0V4cH0pKD8hWyR7dGFnUmVnRXhwfVxcXFxzXSkoLio/W14ke3RhZ1JlZ0V4cH1cXFxcc10pJHt0YWdSZWdFeHB9KD8hJHt0YWdSZWdFeHB9KWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdWxsTWF0Y2hSZWdFeHBCeVRhZ1t0YWddID0gbmV3IFJlZ0V4cChgKD88IVtcXFxcXFxcXCR7dGFnUmVnRXhwfV0pKCR7dGFnUmVnRXhwfSkoKFxcXFxcXFxcJHt0YWdSZWdFeHB9KT8uKj9bXiR7dGFnUmVnRXhwfVxcXFxzXShcXFxcXFxcXCR7dGFnUmVnRXhwfSk/KSgoPzwhXFxcXFxcXFwpfCg/PD1cXFxcXFxcXFxcXFxcXFxcKSkoJHt0YWdSZWdFeHB9KSg/IVtcXFxcXFxcXCR7dGFnUmVnRXhwfV0pYCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBSZWcgZXhwIHRvIGZpbmQgb3BlbiB0YWcgKyBjb250ZW50ICsgY2xvc2UgdGFnXG4gICAgZnVsbE1hdGNoUmVnRXhwQnlUYWcsXG4gICAgLy8gUmVnIGV4cCB0byBmaW5kIG9wZW5pbmcgdGFnc1xuICAgIG9wZW5UYWdzUmVnRXhwOiBuZXcgUmVnRXhwKChJU19TQUZBUkkgfHwgSVNfSU9TIHx8IElTX0FQUExFX1dFQktJVCA/ICcnIDogYCR7ZXNjYXBlUmVnRXhwfWApICsgJygnICsgb3BlblRhZ3NSZWdFeHAuam9pbignfCcpICsgJyknLCAnZycpLFxuICAgIHRyYW5zZm9ybWVyc0J5VGFnXG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcnVuRWxlbWVudFRyYW5zZm9ybWVycyhwYXJlbnROb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGVsZW1lbnRUcmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgZ3JhbmRQYXJlbnROb2RlID0gcGFyZW50Tm9kZS5nZXRQYXJlbnQoKTtcblxuICBpZiAoIWxleGljYWwuJGlzUm9vdE9yU2hhZG93Um9vdChncmFuZFBhcmVudE5vZGUpIHx8IHBhcmVudE5vZGUuZ2V0Rmlyc3RDaGlsZCgpICE9PSBhbmNob3JOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgdGV4dENvbnRlbnQgPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCk7IC8vIENoZWNraW5nIGZvciBhbmNob3JPZmZzZXQgcG9zaXRpb24gdG8gcHJldmVudCBhbnkgY2hlY2tzIGZvciBjYXNlcyB3aGVuIGNhcmV0IGlzIHRvbyBmYXJcbiAgLy8gZnJvbSBhIGxpbmUgc3RhcnQgdG8gYmUgYSBwYXJ0IG9mIGJsb2NrLWxldmVsIG1hcmtkb3duIHRyaWdnZXIuXG4gIC8vXG4gIC8vIFRPRE86XG4gIC8vIENhbiBoYXZlIGEgcXVpY2sgY2hlY2sgaWYgY2FyZXQgaXMgY2xvc2UgZW5vdWdoIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZyAoZS5nLiBvZmZzZXQgbGVzcyB0aGFuIDEwLTIwKVxuICAvLyBzaW5jZSBvdGhlcndpc2UgaXQgd29uJ3QgYmUgYSBtYXJrZG93biBzaG9ydGN1dCwgYnV0IHRhYmxlcyBhcmUgZXhjZXB0aW9uXG5cbiAgaWYgKHRleHRDb250ZW50W2FuY2hvck9mZnNldCAtIDFdICE9PSAnICcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IHtcbiAgICByZWdFeHAsXG4gICAgcmVwbGFjZVxuICB9IG9mIGVsZW1lbnRUcmFuc2Zvcm1lcnMpIHtcbiAgICBjb25zdCBtYXRjaCA9IHRleHRDb250ZW50Lm1hdGNoKHJlZ0V4cCk7XG5cbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMF0ubGVuZ3RoID09PSBhbmNob3JPZmZzZXQpIHtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5ncyA9IGFuY2hvck5vZGUuZ2V0TmV4dFNpYmxpbmdzKCk7XG4gICAgICBjb25zdCBbbGVhZGluZ05vZGUsIHJlbWFpbmRlck5vZGVdID0gYW5jaG9yTm9kZS5zcGxpdFRleHQoYW5jaG9yT2Zmc2V0KTtcbiAgICAgIGxlYWRpbmdOb2RlLnJlbW92ZSgpO1xuICAgICAgY29uc3Qgc2libGluZ3MgPSByZW1haW5kZXJOb2RlID8gW3JlbWFpbmRlck5vZGUsIC4uLm5leHRTaWJsaW5nc10gOiBuZXh0U2libGluZ3M7XG4gICAgICByZXBsYWNlKHBhcmVudE5vZGUsIHNpYmxpbmdzLCBtYXRjaCwgZmFsc2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBydW5UZXh0TWF0Y2hUcmFuc2Zvcm1lcnMoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCB0cmFuc2Zvcm1lcnNCeVRyaWdnZXIpIHtcbiAgbGV0IHRleHRDb250ZW50ID0gYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICBjb25zdCBsYXN0Q2hhciA9IHRleHRDb250ZW50W2FuY2hvck9mZnNldCAtIDFdO1xuICBjb25zdCB0cmFuc2Zvcm1lcnMgPSB0cmFuc2Zvcm1lcnNCeVRyaWdnZXJbbGFzdENoYXJdO1xuXG4gIGlmICh0cmFuc2Zvcm1lcnMgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJZiB0eXBpbmcgaW4gdGhlIG1pZGRsZSBvZiBjb250ZW50LCByZW1vdmUgdGhlIHRhaWwgdG8gZG9cbiAgLy8gcmVnIGV4cCBtYXRjaCB1cCB0byBhIHN0cmluZyBlbmQgKGNhcmV0IHBvc2l0aW9uKVxuXG5cbiAgaWYgKGFuY2hvck9mZnNldCA8IHRleHRDb250ZW50Lmxlbmd0aCkge1xuICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgYW5jaG9yT2Zmc2V0KTtcbiAgfVxuXG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB0ZXh0Q29udGVudC5tYXRjaCh0cmFuc2Zvcm1lci5yZWdFeHApO1xuXG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydEluZGV4ID0gbWF0Y2guaW5kZXggfHwgMDtcbiAgICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgbGV0IHJlcGxhY2VOb2RlO1xuXG4gICAgaWYgKHN0YXJ0SW5kZXggPT09IDApIHtcbiAgICAgIFtyZXBsYWNlTm9kZV0gPSBhbmNob3JOb2RlLnNwbGl0VGV4dChlbmRJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFssIHJlcGxhY2VOb2RlXSA9IGFuY2hvck5vZGUuc3BsaXRUZXh0KHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICB9XG5cbiAgICByZXBsYWNlTm9kZS5zZWxlY3ROZXh0KDAsIDApO1xuICAgIHRyYW5zZm9ybWVyLnJlcGxhY2UocmVwbGFjZU5vZGUsIG1hdGNoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcnVuVGV4dEZvcm1hdFRyYW5zZm9ybWVycyhhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIHRleHRGb3JtYXRUcmFuc2Zvcm1lcnMpIHtcbiAgY29uc3QgdGV4dENvbnRlbnQgPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IGNsb3NlVGFnRW5kSW5kZXggPSBhbmNob3JPZmZzZXQgLSAxO1xuICBjb25zdCBjbG9zZUNoYXIgPSB0ZXh0Q29udGVudFtjbG9zZVRhZ0VuZEluZGV4XTsgLy8gUXVpY2sgY2hlY2sgaWYgd2UncmUgcG9zc2libHkgYXQgdGhlIGVuZCBvZiBpbmxpbmUgbWFya2Rvd24gc3R5bGVcblxuICBjb25zdCBtYXRjaGVycyA9IHRleHRGb3JtYXRUcmFuc2Zvcm1lcnNbY2xvc2VDaGFyXTtcblxuICBpZiAoIW1hdGNoZXJzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChjb25zdCBtYXRjaGVyIG9mIG1hdGNoZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFnXG4gICAgfSA9IG1hdGNoZXI7XG4gICAgY29uc3QgdGFnTGVuZ3RoID0gdGFnLmxlbmd0aDtcbiAgICBjb25zdCBjbG9zZVRhZ1N0YXJ0SW5kZXggPSBjbG9zZVRhZ0VuZEluZGV4IC0gdGFnTGVuZ3RoICsgMTsgLy8gSWYgdGFnIGlzIG5vdCBzaW5nbGUgY2hhciBjaGVjayBpZiByZXN0IG9mIGl0IG1hdGNoZXMgd2l0aCB0ZXh0IGNvbnRlbnRcblxuICAgIGlmICh0YWdMZW5ndGggPiAxKSB7XG4gICAgICBpZiAoIWlzRXF1YWxTdWJTdHJpbmcodGV4dENvbnRlbnQsIGNsb3NlVGFnU3RhcnRJbmRleCwgdGFnLCAwLCB0YWdMZW5ndGgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gLy8gU3BhY2UgYmVmb3JlIGNsb3NpbmcgdGFnIGNhbmNlbHMgaW5saW5lIG1hcmtkb3duXG5cblxuICAgIGlmICh0ZXh0Q29udGVudFtjbG9zZVRhZ1N0YXJ0SW5kZXggLSAxXSA9PT0gJyAnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIFNvbWUgdGFncyBjYW4gbm90IGJlIHVzZWQgd2l0aGluIHdvcmRzLCBoZW5jZSBzaG91bGQgaGF2ZSBuZXdsaW5lL3NwYWNlL3B1bmN0dWF0aW9uIGFmdGVyIGl0XG5cblxuICAgIGNvbnN0IGFmdGVyQ2xvc2VUYWdDaGFyID0gdGV4dENvbnRlbnRbY2xvc2VUYWdFbmRJbmRleCArIDFdO1xuXG4gICAgaWYgKG1hdGNoZXIuaW50cmF3b3JkID09PSBmYWxzZSAmJiBhZnRlckNsb3NlVGFnQ2hhciAmJiAhUFVOQ1RVQVRJT05fT1JfU1BBQ0UudGVzdChhZnRlckNsb3NlVGFnQ2hhcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGNsb3NlTm9kZSA9IGFuY2hvck5vZGU7XG4gICAgbGV0IG9wZW5Ob2RlID0gY2xvc2VOb2RlO1xuICAgIGxldCBvcGVuVGFnU3RhcnRJbmRleCA9IGdldE9wZW5UYWdTdGFydEluZGV4KHRleHRDb250ZW50LCBjbG9zZVRhZ1N0YXJ0SW5kZXgsIHRhZyk7IC8vIEdvIHRocm91Z2ggdGV4dCBub2RlIHNpYmxpbmdzIGFuZCBzZWFyY2ggZm9yIG9wZW5pbmcgdGFnXG4gICAgLy8gaWYgaGF2ZW4ndCBmb3VuZCBpdCB3aXRoaW4gdGhlIHNhbWUgdGV4dCBub2RlIGFzIGNsb3NpbmcgdGFnXG5cbiAgICBsZXQgc2libGluZyA9IG9wZW5Ob2RlO1xuXG4gICAgd2hpbGUgKG9wZW5UYWdTdGFydEluZGV4IDwgMCAmJiAoc2libGluZyA9IHNpYmxpbmcuZ2V0UHJldmlvdXNTaWJsaW5nKCkpKSB7XG4gICAgICBpZiAobGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKHNpYmxpbmcpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShzaWJsaW5nKSkge1xuICAgICAgICBjb25zdCBzaWJsaW5nVGV4dENvbnRlbnQgPSBzaWJsaW5nLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgIG9wZW5Ob2RlID0gc2libGluZztcbiAgICAgICAgb3BlblRhZ1N0YXJ0SW5kZXggPSBnZXRPcGVuVGFnU3RhcnRJbmRleChzaWJsaW5nVGV4dENvbnRlbnQsIHNpYmxpbmdUZXh0Q29udGVudC5sZW5ndGgsIHRhZyk7XG4gICAgICB9XG4gICAgfSAvLyBPcGVuaW5nIHRhZyBpcyBub3QgZm91bmRcblxuXG4gICAgaWYgKG9wZW5UYWdTdGFydEluZGV4IDwgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBObyBjb250ZW50IGJldHdlZW4gb3BlbmluZyBhbmQgY2xvc2luZyB0YWdcblxuXG4gICAgaWYgKG9wZW5Ob2RlID09PSBjbG9zZU5vZGUgJiYgb3BlblRhZ1N0YXJ0SW5kZXggKyB0YWdMZW5ndGggPT09IGNsb3NlVGFnU3RhcnRJbmRleCkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBDaGVja2luZyBsb25nZXIgdGFncyBmb3IgcmVwZWF0aW5nIGNoYXJzIChlLmcuICoqKiB2cyAqKilcblxuXG4gICAgY29uc3QgcHJldk9wZW5Ob2RlVGV4dCA9IG9wZW5Ob2RlLmdldFRleHRDb250ZW50KCk7XG5cbiAgICBpZiAob3BlblRhZ1N0YXJ0SW5kZXggPiAwICYmIHByZXZPcGVuTm9kZVRleHRbb3BlblRhZ1N0YXJ0SW5kZXggLSAxXSA9PT0gY2xvc2VDaGFyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIFNvbWUgdGFncyBjYW4gbm90IGJlIHVzZWQgd2l0aGluIHdvcmRzLCBoZW5jZSBzaG91bGQgaGF2ZSBuZXdsaW5lL3NwYWNlL3B1bmN0dWF0aW9uIGJlZm9yZSBpdFxuXG5cbiAgICBjb25zdCBiZWZvcmVPcGVuVGFnQ2hhciA9IHByZXZPcGVuTm9kZVRleHRbb3BlblRhZ1N0YXJ0SW5kZXggLSAxXTtcblxuICAgIGlmIChtYXRjaGVyLmludHJhd29yZCA9PT0gZmFsc2UgJiYgYmVmb3JlT3BlblRhZ0NoYXIgJiYgIVBVTkNUVUFUSU9OX09SX1NQQUNFLnRlc3QoYmVmb3JlT3BlblRhZ0NoYXIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIENsZWFuIHRleHQgZnJvbSBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgKHN0YXJ0aW5nIGZyb20gY2xvc2luZyB0YWdcbiAgICAvLyB0byBwcmV2ZW50IGFueSBvZmZzZXQgc2hpZnRzIGlmIHdlIHN0YXJ0IGZyb20gb3BlbmluZyBvbmUpXG5cblxuICAgIGNvbnN0IHByZXZDbG9zZU5vZGVUZXh0ID0gY2xvc2VOb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgY29uc3QgY2xvc2VOb2RlVGV4dCA9IHByZXZDbG9zZU5vZGVUZXh0LnNsaWNlKDAsIGNsb3NlVGFnU3RhcnRJbmRleCkgKyBwcmV2Q2xvc2VOb2RlVGV4dC5zbGljZShjbG9zZVRhZ0VuZEluZGV4ICsgMSk7XG4gICAgY2xvc2VOb2RlLnNldFRleHRDb250ZW50KGNsb3NlTm9kZVRleHQpO1xuICAgIGNvbnN0IG9wZW5Ob2RlVGV4dCA9IG9wZW5Ob2RlID09PSBjbG9zZU5vZGUgPyBjbG9zZU5vZGVUZXh0IDogcHJldk9wZW5Ob2RlVGV4dDtcbiAgICBvcGVuTm9kZS5zZXRUZXh0Q29udGVudChvcGVuTm9kZVRleHQuc2xpY2UoMCwgb3BlblRhZ1N0YXJ0SW5kZXgpICsgb3Blbk5vZGVUZXh0LnNsaWNlKG9wZW5UYWdTdGFydEluZGV4ICsgdGFnTGVuZ3RoKSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3QgbmV4dFNlbGVjdGlvbiA9IGxleGljYWwuJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCk7XG4gICAgbGV4aWNhbC4kc2V0U2VsZWN0aW9uKG5leHRTZWxlY3Rpb24pOyAvLyBBZGp1c3Qgb2Zmc2V0IGJhc2VkIG9uIGRlbGV0ZWQgY2hhcnNcblxuICAgIGNvbnN0IG5ld09mZnNldCA9IGNsb3NlVGFnRW5kSW5kZXggLSB0YWdMZW5ndGggKiAob3Blbk5vZGUgPT09IGNsb3NlTm9kZSA/IDIgOiAxKSArIDE7XG4gICAgbmV4dFNlbGVjdGlvbi5hbmNob3Iuc2V0KG9wZW5Ob2RlLl9fa2V5LCBvcGVuVGFnU3RhcnRJbmRleCwgJ3RleHQnKTtcbiAgICBuZXh0U2VsZWN0aW9uLmZvY3VzLnNldChjbG9zZU5vZGUuX19rZXksIG5ld09mZnNldCwgJ3RleHQnKTsgLy8gQXBwbHkgZm9ybWF0dGluZyB0byBzZWxlY3RlZCB0ZXh0XG5cbiAgICBmb3IgKGNvbnN0IGZvcm1hdCBvZiBtYXRjaGVyLmZvcm1hdCkge1xuICAgICAgaWYgKCFuZXh0U2VsZWN0aW9uLmhhc0Zvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIG5leHRTZWxlY3Rpb24uZm9ybWF0VGV4dChmb3JtYXQpO1xuICAgICAgfVxuICAgIH0gLy8gQ29sbGFwc2Ugc2VsZWN0aW9uIHVwIHRvIHRoZSBmb2N1cyBwb2ludFxuXG5cbiAgICBuZXh0U2VsZWN0aW9uLmFuY2hvci5zZXQobmV4dFNlbGVjdGlvbi5mb2N1cy5rZXksIG5leHRTZWxlY3Rpb24uZm9jdXMub2Zmc2V0LCBuZXh0U2VsZWN0aW9uLmZvY3VzLnR5cGUpOyAvLyBSZW1vdmUgZm9ybWF0dGluZyBmcm9tIGNvbGxhcHNlZCBzZWxlY3Rpb25cblxuICAgIGZvciAoY29uc3QgZm9ybWF0IG9mIG1hdGNoZXIuZm9ybWF0KSB7XG4gICAgICBpZiAobmV4dFNlbGVjdGlvbi5oYXNGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgICBuZXh0U2VsZWN0aW9uLnRvZ2dsZUZvcm1hdChmb3JtYXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIG5leHRTZWxlY3Rpb24uZm9ybWF0ID0gc2VsZWN0aW9uLmZvcm1hdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0T3BlblRhZ1N0YXJ0SW5kZXgoc3RyaW5nLCBtYXhJbmRleCwgdGFnKSB7XG4gIGNvbnN0IHRhZ0xlbmd0aCA9IHRhZy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IG1heEluZGV4OyBpID49IHRhZ0xlbmd0aDsgaS0tKSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IGkgLSB0YWdMZW5ndGg7XG5cbiAgICBpZiAoaXNFcXVhbFN1YlN0cmluZyhzdHJpbmcsIHN0YXJ0SW5kZXgsIHRhZywgMCwgdGFnTGVuZ3RoKSAmJiAvLyBTcGFjZSBhZnRlciBvcGVuaW5nIHRhZyBjYW5jZWxzIHRyYW5zZm9ybWF0aW9uXG4gICAgc3RyaW5nW3N0YXJ0SW5kZXggKyB0YWdMZW5ndGhdICE9PSAnICcpIHtcbiAgICAgIHJldHVybiBzdGFydEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gaXNFcXVhbFN1YlN0cmluZyhzdHJpbmdBLCBhU3RhcnQsIHN0cmluZ0IsIGJTdGFydCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyaW5nQVthU3RhcnQgKyBpXSAhPT0gc3RyaW5nQltiU3RhcnQgKyBpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWdpc3Rlck1hcmtkb3duU2hvcnRjdXRzKGVkaXRvciwgdHJhbnNmb3JtZXJzID0gVFJBTlNGT1JNRVJTKSB7XG4gIGNvbnN0IGJ5VHlwZSA9IHRyYW5zZm9ybWVyc0J5VHlwZSh0cmFuc2Zvcm1lcnMpO1xuICBjb25zdCB0ZXh0Rm9ybWF0VHJhbnNmb3JtZXJzSW5kZXggPSBpbmRleEJ5KGJ5VHlwZS50ZXh0Rm9ybWF0LCAoe1xuICAgIHRhZ1xuICB9KSA9PiB0YWdbdGFnLmxlbmd0aCAtIDFdKTtcbiAgY29uc3QgdGV4dE1hdGNoVHJhbnNmb3JtZXJzSW5kZXggPSBpbmRleEJ5KGJ5VHlwZS50ZXh0TWF0Y2gsICh7XG4gICAgdHJpZ2dlclxuICB9KSA9PiB0cmlnZ2VyKTtcblxuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xuICAgIGNvbnN0IHR5cGUgPSB0cmFuc2Zvcm1lci50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdlbGVtZW50JyB8fCB0eXBlID09PSAndGV4dC1tYXRjaCcpIHtcbiAgICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHRyYW5zZm9ybWVyLmRlcGVuZGVuY2llcztcblxuICAgICAgaWYgKCFlZGl0b3IuaGFzTm9kZXMoZGVwZW5kZW5jaWVzKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYE1hcmtkb3duU2hvcnRjdXRzOiBtaXNzaW5nIGRlcGVuZGVuY3kgZm9yIHRyYW5zZm9ybWVyLiBFbnN1cmUgbm9kZSBkZXBlbmRlbmN5IGlzIGluY2x1ZGVkIGluIGVkaXRvciBpbml0aWFsIGNvbmZpZy5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRyYW5zZm9ybSA9IChwYXJlbnROb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpID0+IHtcbiAgICBpZiAocnVuRWxlbWVudFRyYW5zZm9ybWVycyhwYXJlbnROb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGJ5VHlwZS5lbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChydW5UZXh0TWF0Y2hUcmFuc2Zvcm1lcnMoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCB0ZXh0TWF0Y2hUcmFuc2Zvcm1lcnNJbmRleCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBydW5UZXh0Rm9ybWF0VHJhbnNmb3JtZXJzKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgdGV4dEZvcm1hdFRyYW5zZm9ybWVyc0luZGV4KTtcbiAgfTtcblxuICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHtcbiAgICB0YWdzLFxuICAgIGRpcnR5TGVhdmVzLFxuICAgIGVkaXRvclN0YXRlLFxuICAgIHByZXZFZGl0b3JTdGF0ZVxuICB9KSA9PiB7XG4gICAgLy8gSWdub3JlIHVwZGF0ZXMgZnJvbSB1bmRvL3JlZG8gKGFzIGNoYW5nZXMgYWxyZWFkeSBjYWxjdWxhdGVkKVxuICAgIGlmICh0YWdzLmhhcygnaGlzdG9yaWMnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvclN0YXRlLnJlYWQobGV4aWNhbC4kZ2V0U2VsZWN0aW9uKTtcbiAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gcHJldkVkaXRvclN0YXRlLnJlYWQobGV4aWNhbC4kZ2V0U2VsZWN0aW9uKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSB8fCAhbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuY2hvcktleSA9IHNlbGVjdGlvbi5hbmNob3Iua2V5O1xuICAgIGNvbnN0IGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0O1xuXG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChhbmNob3JLZXkpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1RleHROb2RlKGFuY2hvck5vZGUpIHx8ICFkaXJ0eUxlYXZlcy5oYXMoYW5jaG9yS2V5KSB8fCBhbmNob3JPZmZzZXQgIT09IDEgJiYgYW5jaG9yT2Zmc2V0ICE9PSBwcmV2U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgKyAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAvLyBNYXJrZG93biBpcyBub3QgYXZhaWxhYmxlIGluc2lkZSBjb2RlXG4gICAgICBpZiAoYW5jaG9yTm9kZS5oYXNGb3JtYXQoJ2NvZGUnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBhbmNob3JOb2RlLmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gbnVsbCB8fCBjb2RlLiRpc0NvZGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdHJhbnNmb3JtKHBhcmVudE5vZGUsIGFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgY3JlYXRlQmxvY2tOb2RlID0gY3JlYXRlTm9kZSA9PiB7XG4gIHJldHVybiAocGFyZW50Tm9kZSwgY2hpbGRyZW4sIG1hdGNoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGNyZWF0ZU5vZGUobWF0Y2gpO1xuICAgIG5vZGUuYXBwZW5kKC4uLmNoaWxkcmVuKTtcbiAgICBwYXJlbnROb2RlLnJlcGxhY2Uobm9kZSk7XG4gICAgbm9kZS5zZWxlY3QoMCwgMCk7XG4gIH07XG59OyAvLyBBbW91bnQgb2Ygc3BhY2VzIHRoYXQgZGVmaW5lIGluZGVudGF0aW9uIGxldmVsXG4vLyBUT0RPOiBzaG91bGQgYmUgYW4gb3B0aW9uXG5cblxuY29uc3QgTElTVF9JTkRFTlRfU0laRSA9IDQ7XG5cbmNvbnN0IGxpc3RSZXBsYWNlID0gbGlzdFR5cGUgPT4ge1xuICByZXR1cm4gKHBhcmVudE5vZGUsIGNoaWxkcmVuLCBtYXRjaCkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzTm9kZSA9IHBhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgY29uc3QgbGlzdEl0ZW0gPSBsaXN0LiRjcmVhdGVMaXN0SXRlbU5vZGUobGlzdFR5cGUgPT09ICdjaGVjaycgPyBtYXRjaFszXSA9PT0gJ3gnIDogdW5kZWZpbmVkKTtcblxuICAgIGlmIChsaXN0LiRpc0xpc3ROb2RlKHByZXZpb3VzTm9kZSkgJiYgcHJldmlvdXNOb2RlLmdldExpc3RUeXBlKCkgPT09IGxpc3RUeXBlKSB7XG4gICAgICBwcmV2aW91c05vZGUuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICAgIHBhcmVudE5vZGUucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxpc3QkMSA9IGxpc3QuJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlLCBsaXN0VHlwZSA9PT0gJ251bWJlcicgPyBOdW1iZXIobWF0Y2hbMl0pIDogdW5kZWZpbmVkKTtcbiAgICAgIGxpc3QkMS5hcHBlbmQobGlzdEl0ZW0pO1xuICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlKGxpc3QkMSk7XG4gICAgfVxuXG4gICAgbGlzdEl0ZW0uYXBwZW5kKC4uLmNoaWxkcmVuKTtcbiAgICBsaXN0SXRlbS5zZWxlY3QoMCwgMCk7XG4gICAgY29uc3QgaW5kZW50ID0gTWF0aC5mbG9vcihtYXRjaFsxXS5sZW5ndGggLyBMSVNUX0lOREVOVF9TSVpFKTtcblxuICAgIGlmIChpbmRlbnQpIHtcbiAgICAgIGxpc3RJdGVtLnNldEluZGVudChpbmRlbnQpO1xuICAgIH1cbiAgfTtcbn07XG5cbmNvbnN0IGxpc3RFeHBvcnQgPSAobGlzdE5vZGUsIGV4cG9ydENoaWxkcmVuLCBkZXB0aCkgPT4ge1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgY29uc3QgY2hpbGRyZW4gPSBsaXN0Tm9kZS5nZXRDaGlsZHJlbigpO1xuICBsZXQgaW5kZXggPSAwO1xuXG4gIGZvciAoY29uc3QgbGlzdEl0ZW1Ob2RlIG9mIGNoaWxkcmVuKSB7XG4gICAgaWYgKGxpc3QuJGlzTGlzdEl0ZW1Ob2RlKGxpc3RJdGVtTm9kZSkpIHtcbiAgICAgIGlmIChsaXN0SXRlbU5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDEpIHtcbiAgICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGxpc3RJdGVtTm9kZS5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICAgICAgaWYgKGxpc3QuJGlzTGlzdE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChsaXN0RXhwb3J0KGZpcnN0Q2hpbGQsIGV4cG9ydENoaWxkcmVuLCBkZXB0aCArIDEpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRlbnQgPSAnICcucmVwZWF0KGRlcHRoICogTElTVF9JTkRFTlRfU0laRSk7XG4gICAgICBjb25zdCBsaXN0VHlwZSA9IGxpc3ROb2RlLmdldExpc3RUeXBlKCk7XG4gICAgICBjb25zdCBwcmVmaXggPSBsaXN0VHlwZSA9PT0gJ251bWJlcicgPyBgJHtsaXN0Tm9kZS5nZXRTdGFydCgpICsgaW5kZXh9LiBgIDogbGlzdFR5cGUgPT09ICdjaGVjaycgPyBgLSBbJHtsaXN0SXRlbU5vZGUuZ2V0Q2hlY2tlZCgpID8gJ3gnIDogJyAnfV0gYCA6ICctICc7XG4gICAgICBvdXRwdXQucHVzaChpbmRlbnQgKyBwcmVmaXggKyBleHBvcnRDaGlsZHJlbihsaXN0SXRlbU5vZGUpKTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dC5qb2luKCdcXG4nKTtcbn07XG5cbmNvbnN0IEhFQURJTkcgPSB7XG4gIGRlcGVuZGVuY2llczogW3JpY2hUZXh0LkhlYWRpbmdOb2RlXSxcbiAgZXhwb3J0OiAobm9kZSwgZXhwb3J0Q2hpbGRyZW4pID0+IHtcbiAgICBpZiAoIXJpY2hUZXh0LiRpc0hlYWRpbmdOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBsZXZlbCA9IE51bWJlcihub2RlLmdldFRhZygpLnNsaWNlKDEpKTtcbiAgICByZXR1cm4gJyMnLnJlcGVhdChsZXZlbCkgKyAnICcgKyBleHBvcnRDaGlsZHJlbihub2RlKTtcbiAgfSxcbiAgcmVnRXhwOiAvXigjezEsNn0pXFxzLyxcbiAgcmVwbGFjZTogY3JlYXRlQmxvY2tOb2RlKG1hdGNoID0+IHtcbiAgICBjb25zdCB0YWcgPSAnaCcgKyBtYXRjaFsxXS5sZW5ndGg7XG4gICAgcmV0dXJuIHJpY2hUZXh0LiRjcmVhdGVIZWFkaW5nTm9kZSh0YWcpO1xuICB9KSxcbiAgdHlwZTogJ2VsZW1lbnQnXG59O1xuY29uc3QgUVVPVEUgPSB7XG4gIGRlcGVuZGVuY2llczogW3JpY2hUZXh0LlF1b3RlTm9kZV0sXG4gIGV4cG9ydDogKG5vZGUsIGV4cG9ydENoaWxkcmVuKSA9PiB7XG4gICAgaWYgKCFyaWNoVGV4dC4kaXNRdW90ZU5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGxpbmVzID0gZXhwb3J0Q2hpbGRyZW4obm9kZSkuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBvdXRwdXQucHVzaCgnPiAnICsgbGluZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCdcXG4nKTtcbiAgfSxcbiAgcmVnRXhwOiAvXj5cXHMvLFxuICByZXBsYWNlOiAocGFyZW50Tm9kZSwgY2hpbGRyZW4sIF9tYXRjaCwgaXNJbXBvcnQpID0+IHtcbiAgICBpZiAoaXNJbXBvcnQpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzTm9kZSA9IHBhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICAgIGlmIChyaWNoVGV4dC4kaXNRdW90ZU5vZGUocHJldmlvdXNOb2RlKSkge1xuICAgICAgICBwcmV2aW91c05vZGUuc3BsaWNlKHByZXZpb3VzTm9kZS5nZXRDaGlsZHJlblNpemUoKSwgMCwgW2xleGljYWwuJGNyZWF0ZUxpbmVCcmVha05vZGUoKSwgLi4uY2hpbGRyZW5dKTtcbiAgICAgICAgcHJldmlvdXNOb2RlLnNlbGVjdCgwLCAwKTtcbiAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSByaWNoVGV4dC4kY3JlYXRlUXVvdGVOb2RlKCk7XG4gICAgbm9kZS5hcHBlbmQoLi4uY2hpbGRyZW4pO1xuICAgIHBhcmVudE5vZGUucmVwbGFjZShub2RlKTtcbiAgICBub2RlLnNlbGVjdCgwLCAwKTtcbiAgfSxcbiAgdHlwZTogJ2VsZW1lbnQnXG59O1xuY29uc3QgQ09ERSA9IHtcbiAgZGVwZW5kZW5jaWVzOiBbY29kZS5Db2RlTm9kZV0sXG4gIGV4cG9ydDogbm9kZSA9PiB7XG4gICAgaWYgKCFjb2RlLiRpc0NvZGVOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0Q29udGVudCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICByZXR1cm4gJ2BgYCcgKyAobm9kZS5nZXRMYW5ndWFnZSgpIHx8ICcnKSArICh0ZXh0Q29udGVudCA/ICdcXG4nICsgdGV4dENvbnRlbnQgOiAnJykgKyAnXFxuJyArICdgYGAnO1xuICB9LFxuICByZWdFeHA6IC9eYGBgKFxcd3sxLDEwfSk/XFxzLyxcbiAgcmVwbGFjZTogY3JlYXRlQmxvY2tOb2RlKG1hdGNoID0+IHtcbiAgICByZXR1cm4gY29kZS4kY3JlYXRlQ29kZU5vZGUobWF0Y2ggPyBtYXRjaFsxXSA6IHVuZGVmaW5lZCk7XG4gIH0pLFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBVTk9SREVSRURfTElTVCA9IHtcbiAgZGVwZW5kZW5jaWVzOiBbbGlzdC5MaXN0Tm9kZSwgbGlzdC5MaXN0SXRlbU5vZGVdLFxuICBleHBvcnQ6IChub2RlLCBleHBvcnRDaGlsZHJlbikgPT4ge1xuICAgIHJldHVybiBsaXN0LiRpc0xpc3ROb2RlKG5vZGUpID8gbGlzdEV4cG9ydChub2RlLCBleHBvcnRDaGlsZHJlbiwgMCkgOiBudWxsO1xuICB9LFxuICByZWdFeHA6IC9eKFxccyopWy0qK11cXHMvLFxuICByZXBsYWNlOiBsaXN0UmVwbGFjZSgnYnVsbGV0JyksXG4gIHR5cGU6ICdlbGVtZW50J1xufTtcbmNvbnN0IENIRUNLX0xJU1QgPSB7XG4gIGRlcGVuZGVuY2llczogW2xpc3QuTGlzdE5vZGUsIGxpc3QuTGlzdEl0ZW1Ob2RlXSxcbiAgZXhwb3J0OiAobm9kZSwgZXhwb3J0Q2hpbGRyZW4pID0+IHtcbiAgICByZXR1cm4gbGlzdC4kaXNMaXN0Tm9kZShub2RlKSA/IGxpc3RFeHBvcnQobm9kZSwgZXhwb3J0Q2hpbGRyZW4sIDApIDogbnVsbDtcbiAgfSxcbiAgcmVnRXhwOiAvXihcXHMqKSg/Oi1cXHMpP1xccz8oXFxbKFxcc3x4KT9cXF0pXFxzL2ksXG4gIHJlcGxhY2U6IGxpc3RSZXBsYWNlKCdjaGVjaycpLFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBPUkRFUkVEX0xJU1QgPSB7XG4gIGRlcGVuZGVuY2llczogW2xpc3QuTGlzdE5vZGUsIGxpc3QuTGlzdEl0ZW1Ob2RlXSxcbiAgZXhwb3J0OiAobm9kZSwgZXhwb3J0Q2hpbGRyZW4pID0+IHtcbiAgICByZXR1cm4gbGlzdC4kaXNMaXN0Tm9kZShub2RlKSA/IGxpc3RFeHBvcnQobm9kZSwgZXhwb3J0Q2hpbGRyZW4sIDApIDogbnVsbDtcbiAgfSxcbiAgcmVnRXhwOiAvXihcXHMqKShcXGR7MSx9KVxcLlxccy8sXG4gIHJlcGxhY2U6IGxpc3RSZXBsYWNlKCdudW1iZXInKSxcbiAgdHlwZTogJ2VsZW1lbnQnXG59O1xuY29uc3QgSU5MSU5FX0NPREUgPSB7XG4gIGZvcm1hdDogWydjb2RlJ10sXG4gIHRhZzogJ2AnLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuY29uc3QgSElHSExJR0hUID0ge1xuICBmb3JtYXQ6IFsnaGlnaGxpZ2h0J10sXG4gIHRhZzogJz09JyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTtcbmNvbnN0IEJPTERfSVRBTElDX1NUQVIgPSB7XG4gIGZvcm1hdDogWydib2xkJywgJ2l0YWxpYyddLFxuICB0YWc6ICcqKionLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuY29uc3QgQk9MRF9JVEFMSUNfVU5ERVJTQ09SRSA9IHtcbiAgZm9ybWF0OiBbJ2JvbGQnLCAnaXRhbGljJ10sXG4gIGludHJhd29yZDogZmFsc2UsXG4gIHRhZzogJ19fXycsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBCT0xEX1NUQVIgPSB7XG4gIGZvcm1hdDogWydib2xkJ10sXG4gIHRhZzogJyoqJyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTtcbmNvbnN0IEJPTERfVU5ERVJTQ09SRSA9IHtcbiAgZm9ybWF0OiBbJ2JvbGQnXSxcbiAgaW50cmF3b3JkOiBmYWxzZSxcbiAgdGFnOiAnX18nLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuY29uc3QgU1RSSUtFVEhST1VHSCA9IHtcbiAgZm9ybWF0OiBbJ3N0cmlrZXRocm91Z2gnXSxcbiAgdGFnOiAnfn4nLFxuICB0eXBlOiAndGV4dC1mb3JtYXQnXG59O1xuY29uc3QgSVRBTElDX1NUQVIgPSB7XG4gIGZvcm1hdDogWydpdGFsaWMnXSxcbiAgdGFnOiAnKicsXG4gIHR5cGU6ICd0ZXh0LWZvcm1hdCdcbn07XG5jb25zdCBJVEFMSUNfVU5ERVJTQ09SRSA9IHtcbiAgZm9ybWF0OiBbJ2l0YWxpYyddLFxuICBpbnRyYXdvcmQ6IGZhbHNlLFxuICB0YWc6ICdfJyxcbiAgdHlwZTogJ3RleHQtZm9ybWF0J1xufTsgLy8gT3JkZXIgb2YgdGV4dCB0cmFuc2Zvcm1lcnMgbWF0dGVyczpcbi8vXG4vLyAtIGNvZGUgc2hvdWxkIGdvIGZpcnN0IGFzIGl0IHByZXZlbnRzIGFueSB0cmFuc2Zvcm1hdGlvbnMgaW5zaWRlXG4vLyAtIHRoZW4gbG9uZ2VyIHRhZ3MgbWF0Y2ggKGUuZy4gKiogb3IgX18gc2hvdWxkIGdvIGJlZm9yZSAqIG9yIF8pXG5cbmNvbnN0IExJTksgPSB7XG4gIGRlcGVuZGVuY2llczogW2xpbmsuTGlua05vZGVdLFxuICBleHBvcnQ6IChub2RlLCBleHBvcnRDaGlsZHJlbiwgZXhwb3J0Rm9ybWF0KSA9PiB7XG4gICAgaWYgKCFsaW5rLiRpc0xpbmtOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBsaW5rQ29udGVudCA9IGBbJHtub2RlLmdldFRleHRDb250ZW50KCl9XSgke25vZGUuZ2V0VVJMKCl9KWA7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpOyAvLyBBZGQgdGV4dCBzdHlsZXMgb25seSBpZiBsaW5rIGhhcyBzaW5nbGUgdGV4dCBub2RlIGluc2lkZS4gSWYgaXQncyBtb3JlXG4gICAgLy8gdGhlbiBvbmUgd2UgaWdub3JlIGl0IGFzIG1hcmtkb3duIGRvZXMgbm90IHN1cHBvcnQgbmVzdGVkIHN0eWxlcyBmb3IgbGlua3NcblxuICAgIGlmIChub2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAxICYmIGxleGljYWwuJGlzVGV4dE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgIHJldHVybiBleHBvcnRGb3JtYXQoZmlyc3RDaGlsZCwgbGlua0NvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbGlua0NvbnRlbnQ7XG4gICAgfVxuICB9LFxuICBpbXBvcnRSZWdFeHA6IC8oPzpcXFsoW15bXSspXFxdKSg/OlxcKChbXigpXSspXFwpKS8sXG4gIHJlZ0V4cDogLyg/OlxcWyhbXltdKylcXF0pKD86XFwoKFteKCldKylcXCkpJC8sXG4gIHJlcGxhY2U6ICh0ZXh0Tm9kZSwgbWF0Y2gpID0+IHtcbiAgICBjb25zdCBbLCBsaW5rVGV4dCwgbGlua1VybF0gPSBtYXRjaDtcbiAgICBjb25zdCBsaW5rTm9kZSA9IGxpbmsuJGNyZWF0ZUxpbmtOb2RlKGxpbmtVcmwpO1xuICAgIGNvbnN0IGxpbmtUZXh0Tm9kZSA9IGxleGljYWwuJGNyZWF0ZVRleHROb2RlKGxpbmtUZXh0KTtcbiAgICBsaW5rVGV4dE5vZGUuc2V0Rm9ybWF0KHRleHROb2RlLmdldEZvcm1hdCgpKTtcbiAgICBsaW5rTm9kZS5hcHBlbmQobGlua1RleHROb2RlKTtcbiAgICB0ZXh0Tm9kZS5yZXBsYWNlKGxpbmtOb2RlKTtcbiAgfSxcbiAgdHJpZ2dlcjogJyknLFxuICB0eXBlOiAndGV4dC1tYXRjaCdcbn07XG5cbi8qKiBAbW9kdWxlIEBsZXhpY2FsL21hcmtkb3duICovXG5jb25zdCBFTEVNRU5UX1RSQU5TRk9STUVSUyA9IFtIRUFESU5HLCBRVU9URSwgQ09ERSwgVU5PUkRFUkVEX0xJU1QsIE9SREVSRURfTElTVF07IC8vIE9yZGVyIG9mIHRleHQgZm9ybWF0IHRyYW5zZm9ybWVycyBtYXR0ZXJzOlxuLy9cbi8vIC0gY29kZSBzaG91bGQgZ28gZmlyc3QgYXMgaXQgcHJldmVudHMgYW55IHRyYW5zZm9ybWF0aW9ucyBpbnNpZGVcbi8vIC0gdGhlbiBsb25nZXIgdGFncyBtYXRjaCAoZS5nLiAqKiBvciBfXyBzaG91bGQgZ28gYmVmb3JlICogb3IgXylcblxuY29uc3QgVEVYVF9GT1JNQVRfVFJBTlNGT1JNRVJTID0gW0lOTElORV9DT0RFLCBCT0xEX0lUQUxJQ19TVEFSLCBCT0xEX0lUQUxJQ19VTkRFUlNDT1JFLCBCT0xEX1NUQVIsIEJPTERfVU5ERVJTQ09SRSwgSElHSExJR0hULCBJVEFMSUNfU1RBUiwgSVRBTElDX1VOREVSU0NPUkUsIFNUUklLRVRIUk9VR0hdO1xuY29uc3QgVEVYVF9NQVRDSF9UUkFOU0ZPUk1FUlMgPSBbTElOS107XG5jb25zdCBUUkFOU0ZPUk1FUlMgPSBbLi4uRUxFTUVOVF9UUkFOU0ZPUk1FUlMsIC4uLlRFWFRfRk9STUFUX1RSQU5TRk9STUVSUywgLi4uVEVYVF9NQVRDSF9UUkFOU0ZPUk1FUlNdO1xuXG5mdW5jdGlvbiAkY29udmVydEZyb21NYXJrZG93blN0cmluZyhtYXJrZG93biwgdHJhbnNmb3JtZXJzID0gVFJBTlNGT1JNRVJTKSB7XG4gIGNvbnN0IGltcG9ydE1hcmtkb3duID0gY3JlYXRlTWFya2Rvd25JbXBvcnQodHJhbnNmb3JtZXJzKTtcbiAgcmV0dXJuIGltcG9ydE1hcmtkb3duKG1hcmtkb3duKTtcbn1cblxuZnVuY3Rpb24gJGNvbnZlcnRUb01hcmtkb3duU3RyaW5nKHRyYW5zZm9ybWVycyA9IFRSQU5TRk9STUVSUykge1xuICBjb25zdCBleHBvcnRNYXJrZG93biA9IGNyZWF0ZU1hcmtkb3duRXhwb3J0KHRyYW5zZm9ybWVycyk7XG4gIHJldHVybiBleHBvcnRNYXJrZG93bigpO1xufVxuXG5leHBvcnRzLiRjb252ZXJ0RnJvbU1hcmtkb3duU3RyaW5nID0gJGNvbnZlcnRGcm9tTWFya2Rvd25TdHJpbmc7XG5leHBvcnRzLiRjb252ZXJ0VG9NYXJrZG93blN0cmluZyA9ICRjb252ZXJ0VG9NYXJrZG93blN0cmluZztcbmV4cG9ydHMuQk9MRF9JVEFMSUNfU1RBUiA9IEJPTERfSVRBTElDX1NUQVI7XG5leHBvcnRzLkJPTERfSVRBTElDX1VOREVSU0NPUkUgPSBCT0xEX0lUQUxJQ19VTkRFUlNDT1JFO1xuZXhwb3J0cy5CT0xEX1NUQVIgPSBCT0xEX1NUQVI7XG5leHBvcnRzLkJPTERfVU5ERVJTQ09SRSA9IEJPTERfVU5ERVJTQ09SRTtcbmV4cG9ydHMuQ0hFQ0tfTElTVCA9IENIRUNLX0xJU1Q7XG5leHBvcnRzLkNPREUgPSBDT0RFO1xuZXhwb3J0cy5FTEVNRU5UX1RSQU5TRk9STUVSUyA9IEVMRU1FTlRfVFJBTlNGT1JNRVJTO1xuZXhwb3J0cy5IRUFESU5HID0gSEVBRElORztcbmV4cG9ydHMuSElHSExJR0hUID0gSElHSExJR0hUO1xuZXhwb3J0cy5JTkxJTkVfQ09ERSA9IElOTElORV9DT0RFO1xuZXhwb3J0cy5JVEFMSUNfU1RBUiA9IElUQUxJQ19TVEFSO1xuZXhwb3J0cy5JVEFMSUNfVU5ERVJTQ09SRSA9IElUQUxJQ19VTkRFUlNDT1JFO1xuZXhwb3J0cy5MSU5LID0gTElOSztcbmV4cG9ydHMuT1JERVJFRF9MSVNUID0gT1JERVJFRF9MSVNUO1xuZXhwb3J0cy5RVU9URSA9IFFVT1RFO1xuZXhwb3J0cy5TVFJJS0VUSFJPVUdIID0gU1RSSUtFVEhST1VHSDtcbmV4cG9ydHMuVEVYVF9GT1JNQVRfVFJBTlNGT1JNRVJTID0gVEVYVF9GT1JNQVRfVFJBTlNGT1JNRVJTO1xuZXhwb3J0cy5URVhUX01BVENIX1RSQU5TRk9STUVSUyA9IFRFWFRfTUFUQ0hfVFJBTlNGT1JNRVJTO1xuZXhwb3J0cy5UUkFOU0ZPUk1FUlMgPSBUUkFOU0ZPUk1FUlM7XG5leHBvcnRzLlVOT1JERVJFRF9MSVNUID0gVU5PUkRFUkVEX0xJU1Q7XG5leHBvcnRzLnJlZ2lzdGVyTWFya2Rvd25TaG9ydGN1dHMgPSByZWdpc3Rlck1hcmtkb3duU2hvcnRjdXRzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lexical/markdown/LexicalMarkdown.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalMarkdown =  true ? __webpack_require__(/*! ./LexicalMarkdown.dev.js */ \"(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.dev.js\") : 0\nmodule.exports = LexicalMarkdown;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFya2Rvd24vTGV4aWNhbE1hcmtkb3duLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osd0JBQXdCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQywrRkFBMEIsSUFBSSxDQUFvQztBQUMzSSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL21hcmtkb3duL0xleGljYWxNYXJrZG93bi5qcz82YzZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsTWFya2Rvd24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbE1hcmtkb3duLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsTWFya2Rvd24ucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxNYXJrZG93bjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/offset/LexicalOffset.dev.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lexical/offset/LexicalOffset.dev.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/offset */\nclass OffsetView {\n  constructor(offsetMap, firstNode, blockOffsetSize = 1) {\n    this._offsetMap = offsetMap;\n    this._firstNode = firstNode;\n    this._blockOffsetSize = blockOffsetSize;\n  }\n\n  createSelectionFromOffsets(originalStart, originalEnd, diffOffsetView) {\n    const firstNode = this._firstNode;\n\n    if (firstNode === null) {\n      return null;\n    }\n\n    let start = originalStart;\n    let end = originalEnd;\n    let startOffsetNode = $searchForNodeWithOffset(firstNode, start, this._blockOffsetSize);\n    let endOffsetNode = $searchForNodeWithOffset(firstNode, end, this._blockOffsetSize);\n\n    if (diffOffsetView !== undefined) {\n      start = $getAdjustedOffsetFromDiff(start, startOffsetNode, diffOffsetView, this, this._blockOffsetSize);\n      startOffsetNode = $searchForNodeWithOffset(firstNode, start, this._blockOffsetSize);\n      end = $getAdjustedOffsetFromDiff(end, endOffsetNode, diffOffsetView, this, this._blockOffsetSize);\n      endOffsetNode = $searchForNodeWithOffset(firstNode, end, this._blockOffsetSize);\n    }\n\n    if (startOffsetNode === null || endOffsetNode === null) {\n      return null;\n    }\n\n    let startKey = startOffsetNode.key;\n    let endKey = endOffsetNode.key;\n    const startNode = lexical.$getNodeByKey(startKey);\n    const endNode = lexical.$getNodeByKey(endKey);\n\n    if (startNode === null || endNode === null) {\n      return null;\n    }\n\n    let startOffset = 0;\n    let endOffset = 0;\n    let startType = 'element';\n    let endType = 'element';\n\n    if (startOffsetNode.type === 'text') {\n      startOffset = start - startOffsetNode.start;\n      startType = 'text'; // If we are at the edge of a text node and we\n      // don't have a collapsed selection, then let's\n      // try and correct the offset node.\n\n      const sibling = startNode.getNextSibling();\n\n      if (start !== end && startOffset === startNode.getTextContentSize() && lexical.$isTextNode(sibling)) {\n        startOffset = 0;\n        startKey = sibling.__key;\n      }\n    } else if (startOffsetNode.type === 'inline') {\n      startKey = startNode.getParentOrThrow().getKey();\n      startOffset = end > startOffsetNode.start ? startOffsetNode.end : startOffsetNode.start;\n    }\n\n    if (endOffsetNode.type === 'text') {\n      endOffset = end - endOffsetNode.start;\n      endType = 'text';\n    } else if (endOffsetNode.type === 'inline') {\n      endKey = endNode.getParentOrThrow().getKey();\n      endOffset = end > endOffsetNode.start ? endOffsetNode.end : endOffsetNode.start;\n    }\n\n    const selection = lexical.$createRangeSelection();\n\n    if (selection === null) {\n      return null;\n    }\n\n    selection.anchor.set(startKey, startOffset, startType);\n    selection.focus.set(endKey, endOffset, endType);\n    return selection;\n  }\n\n  getOffsetsFromSelection(selection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const offsetMap = this._offsetMap;\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    let start = -1;\n    let end = -1;\n\n    if (anchor.type === 'text') {\n      const offsetNode = offsetMap.get(anchor.key);\n\n      if (offsetNode !== undefined) {\n        start = offsetNode.start + anchorOffset;\n      }\n    } else {\n      const node = anchor.getNode().getDescendantByIndex(anchorOffset);\n\n      if (node !== null) {\n        const offsetNode = offsetMap.get(node.getKey());\n\n        if (offsetNode !== undefined) {\n          const isAtEnd = node.getIndexWithinParent() !== anchorOffset;\n          start = isAtEnd ? offsetNode.end : offsetNode.start;\n        }\n      }\n    }\n\n    if (focus.type === 'text') {\n      const offsetNode = offsetMap.get(focus.key);\n\n      if (offsetNode !== undefined) {\n        end = offsetNode.start + focus.offset;\n      }\n    } else {\n      const node = focus.getNode().getDescendantByIndex(focusOffset);\n\n      if (node !== null) {\n        const offsetNode = offsetMap.get(node.getKey());\n\n        if (offsetNode !== undefined) {\n          const isAtEnd = node.getIndexWithinParent() !== focusOffset;\n          end = isAtEnd ? offsetNode.end : offsetNode.start;\n        }\n      }\n    }\n\n    return [start, end];\n  }\n\n}\n\nfunction $getAdjustedOffsetFromDiff(offset, offsetNode, prevOffsetView, offsetView, blockOffsetSize) {\n  const prevOffsetMap = prevOffsetView._offsetMap;\n  const offsetMap = offsetView._offsetMap;\n  const visited = new Set();\n  let adjustedOffset = offset;\n  let currentNode = offsetNode;\n\n  while (currentNode !== null) {\n    const key = currentNode.key;\n    const prevNode = prevOffsetMap.get(key);\n    const diff = currentNode.end - currentNode.start;\n    visited.add(key);\n\n    if (prevNode === undefined) {\n      adjustedOffset += diff;\n    } else {\n      const prevDiff = prevNode.end - prevNode.start;\n\n      if (prevDiff !== diff) {\n        adjustedOffset += diff - prevDiff;\n      }\n    }\n\n    const sibling = currentNode.prev;\n\n    if (sibling !== null) {\n      currentNode = sibling;\n      continue;\n    }\n\n    let parent = currentNode.parent;\n\n    while (parent !== null) {\n      let parentSibling = parent.prev;\n\n      if (parentSibling !== null) {\n        const parentSiblingKey = parentSibling.key;\n        const prevParentSibling = prevOffsetMap.get(parentSiblingKey);\n        const parentDiff = parentSibling.end - parentSibling.start;\n        visited.add(parentSiblingKey);\n\n        if (prevParentSibling === undefined) {\n          adjustedOffset += parentDiff;\n        } else {\n          const prevParentDiff = prevParentSibling.end - prevParentSibling.start;\n\n          if (prevParentDiff !== parentDiff) {\n            adjustedOffset += parentDiff - prevParentDiff;\n          }\n        }\n\n        parentSibling = parentSibling.prev;\n      }\n\n      parent = parent.parent;\n    }\n\n    break;\n  } // Now traverse through the old offsets nodes and find any nodes we missed\n  // above, because they were not in the latest offset node view (they have been\n  // deleted).\n\n\n  const prevFirstNode = prevOffsetView._firstNode;\n\n  if (prevFirstNode !== null) {\n    currentNode = $searchForNodeWithOffset(prevFirstNode, offset, blockOffsetSize);\n    let alreadyVisitedParentOfCurrentNode = false;\n\n    while (currentNode !== null) {\n      if (!visited.has(currentNode.key)) {\n        alreadyVisitedParentOfCurrentNode = true;\n        break;\n      }\n\n      currentNode = currentNode.parent;\n    }\n\n    if (!alreadyVisitedParentOfCurrentNode) {\n      while (currentNode !== null) {\n        const key = currentNode.key;\n\n        if (!visited.has(key)) {\n          const node = offsetMap.get(key);\n          const prevDiff = currentNode.end - currentNode.start;\n\n          if (node === undefined) {\n            adjustedOffset -= prevDiff;\n          } else {\n            const diff = node.end - node.start;\n\n            if (prevDiff !== diff) {\n              adjustedOffset += diff - prevDiff;\n            }\n          }\n        }\n\n        currentNode = currentNode.prev;\n      }\n    }\n  }\n\n  return adjustedOffset;\n}\n\nfunction $searchForNodeWithOffset(firstNode, offset, blockOffsetSize) {\n  let currentNode = firstNode;\n\n  while (currentNode !== null) {\n    const end = currentNode.end + (currentNode.type !== 'element' || blockOffsetSize === 0 ? 1 : 0);\n\n    if (offset < end) {\n      const child = currentNode.child;\n\n      if (child !== null) {\n        currentNode = child;\n        continue;\n      }\n\n      return currentNode;\n    }\n\n    const sibling = currentNode.next;\n\n    if (sibling === null) {\n      break;\n    }\n\n    currentNode = sibling;\n  }\n\n  return null;\n}\n\nfunction $createInternalOffsetNode(child, type, start, end, key, parent) {\n  return {\n    child,\n    end,\n    key,\n    next: null,\n    parent,\n    prev: null,\n    start,\n    type\n  };\n}\n\nfunction $createOffsetNode(state, key, parent, nodeMap, offsetMap, blockOffsetSize) {\n  const node = nodeMap.get(key);\n\n  if (node === undefined) {\n    {\n      throw Error(`createOffsetModel: could not find node by key`);\n    }\n  }\n\n  const start = state.offset;\n\n  if (lexical.$isElementNode(node)) {\n    const childKeys = createChildrenArray(node, nodeMap);\n    const blockIsEmpty = childKeys.length === 0;\n    const child = blockIsEmpty ? null : $createOffsetChild(state, childKeys, null, nodeMap, offsetMap, blockOffsetSize); // If the prev node was not a block or the block is empty, we should\n    // account for the user being able to selection the block (due to the \\n).\n\n    if (!state.prevIsBlock || blockIsEmpty) {\n      state.prevIsBlock = true;\n      state.offset += blockOffsetSize;\n    }\n\n    const offsetNode = $createInternalOffsetNode(child, 'element', start, start, key, parent);\n\n    if (child !== null) {\n      child.parent = offsetNode;\n    }\n\n    const end = state.offset;\n    offsetNode.end = end;\n    offsetMap.set(key, offsetNode);\n    return offsetNode;\n  }\n\n  state.prevIsBlock = false;\n  const isText = lexical.$isTextNode(node);\n  const length = isText ? node.__text.length : 1;\n  const end = state.offset += length;\n  const offsetNode = $createInternalOffsetNode(null, isText ? 'text' : 'inline', start, end, key, parent);\n  offsetMap.set(key, offsetNode);\n  return offsetNode;\n}\n\nfunction $createOffsetChild(state, children, parent, nodeMap, offsetMap, blockOffsetSize) {\n  let firstNode = null;\n  let currentNode = null;\n  const childrenLength = children.length;\n\n  for (let i = 0; i < childrenLength; i++) {\n    const childKey = children[i];\n    const offsetNode = $createOffsetNode(state, childKey, parent, nodeMap, offsetMap, blockOffsetSize);\n\n    if (currentNode === null) {\n      firstNode = offsetNode;\n    } else {\n      offsetNode.prev = currentNode;\n      currentNode.next = offsetNode;\n    }\n\n    currentNode = offsetNode;\n  }\n\n  return firstNode;\n}\n\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n\n  while (nodeKey !== null) {\n    const node = nodeMap === null ? lexical.$getNodeByKey(nodeKey) : nodeMap.get(nodeKey);\n\n    if (node === null || node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n\n  return children;\n}\nfunction $createOffsetView(editor, blockOffsetSize = 1, editorState) {\n  const targetEditorState = editorState || editor._pendingEditorState || editor._editorState;\n  const nodeMap = targetEditorState._nodeMap;\n  const root = nodeMap.get('root');\n  const offsetMap = new Map();\n  const state = {\n    offset: 0,\n    prevIsBlock: false\n  };\n  const node = $createOffsetChild(state, createChildrenArray(root, nodeMap), null, nodeMap, offsetMap, blockOffsetSize);\n  return new OffsetView(offsetMap, node, blockOffsetSize);\n}\n\nexports.$createOffsetView = $createOffsetView;\nexports.OffsetView = OffsetView;\nexports.createChildrenArray = createChildrenArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvb2Zmc2V0L0xleGljYWxPZmZzZXQuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyx3REFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlIQUF5SDtBQUN6SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIsa0JBQWtCO0FBQ2xCLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL29mZnNldC9MZXhpY2FsT2Zmc2V0LmRldi5qcz84ODFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcblxuLyoqIEBtb2R1bGUgQGxleGljYWwvb2Zmc2V0ICovXG5jbGFzcyBPZmZzZXRWaWV3IHtcbiAgY29uc3RydWN0b3Iob2Zmc2V0TWFwLCBmaXJzdE5vZGUsIGJsb2NrT2Zmc2V0U2l6ZSA9IDEpIHtcbiAgICB0aGlzLl9vZmZzZXRNYXAgPSBvZmZzZXRNYXA7XG4gICAgdGhpcy5fZmlyc3ROb2RlID0gZmlyc3ROb2RlO1xuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0U2l6ZSA9IGJsb2NrT2Zmc2V0U2l6ZTtcbiAgfVxuXG4gIGNyZWF0ZVNlbGVjdGlvbkZyb21PZmZzZXRzKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kLCBkaWZmT2Zmc2V0Vmlldykge1xuICAgIGNvbnN0IGZpcnN0Tm9kZSA9IHRoaXMuX2ZpcnN0Tm9kZTtcblxuICAgIGlmIChmaXJzdE5vZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBzdGFydCA9IG9yaWdpbmFsU3RhcnQ7XG4gICAgbGV0IGVuZCA9IG9yaWdpbmFsRW5kO1xuICAgIGxldCBzdGFydE9mZnNldE5vZGUgPSAkc2VhcmNoRm9yTm9kZVdpdGhPZmZzZXQoZmlyc3ROb2RlLCBzdGFydCwgdGhpcy5fYmxvY2tPZmZzZXRTaXplKTtcbiAgICBsZXQgZW5kT2Zmc2V0Tm9kZSA9ICRzZWFyY2hGb3JOb2RlV2l0aE9mZnNldChmaXJzdE5vZGUsIGVuZCwgdGhpcy5fYmxvY2tPZmZzZXRTaXplKTtcblxuICAgIGlmIChkaWZmT2Zmc2V0VmlldyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGFydCA9ICRnZXRBZGp1c3RlZE9mZnNldEZyb21EaWZmKHN0YXJ0LCBzdGFydE9mZnNldE5vZGUsIGRpZmZPZmZzZXRWaWV3LCB0aGlzLCB0aGlzLl9ibG9ja09mZnNldFNpemUpO1xuICAgICAgc3RhcnRPZmZzZXROb2RlID0gJHNlYXJjaEZvck5vZGVXaXRoT2Zmc2V0KGZpcnN0Tm9kZSwgc3RhcnQsIHRoaXMuX2Jsb2NrT2Zmc2V0U2l6ZSk7XG4gICAgICBlbmQgPSAkZ2V0QWRqdXN0ZWRPZmZzZXRGcm9tRGlmZihlbmQsIGVuZE9mZnNldE5vZGUsIGRpZmZPZmZzZXRWaWV3LCB0aGlzLCB0aGlzLl9ibG9ja09mZnNldFNpemUpO1xuICAgICAgZW5kT2Zmc2V0Tm9kZSA9ICRzZWFyY2hGb3JOb2RlV2l0aE9mZnNldChmaXJzdE5vZGUsIGVuZCwgdGhpcy5fYmxvY2tPZmZzZXRTaXplKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRPZmZzZXROb2RlID09PSBudWxsIHx8IGVuZE9mZnNldE5vZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCBzdGFydEtleSA9IHN0YXJ0T2Zmc2V0Tm9kZS5rZXk7XG4gICAgbGV0IGVuZEtleSA9IGVuZE9mZnNldE5vZGUua2V5O1xuICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleShzdGFydEtleSk7XG4gICAgY29uc3QgZW5kTm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleShlbmRLZXkpO1xuXG4gICAgaWYgKHN0YXJ0Tm9kZSA9PT0gbnVsbCB8fCBlbmROb2RlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgc3RhcnRPZmZzZXQgPSAwO1xuICAgIGxldCBlbmRPZmZzZXQgPSAwO1xuICAgIGxldCBzdGFydFR5cGUgPSAnZWxlbWVudCc7XG4gICAgbGV0IGVuZFR5cGUgPSAnZWxlbWVudCc7XG5cbiAgICBpZiAoc3RhcnRPZmZzZXROb2RlLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgc3RhcnRPZmZzZXQgPSBzdGFydCAtIHN0YXJ0T2Zmc2V0Tm9kZS5zdGFydDtcbiAgICAgIHN0YXJ0VHlwZSA9ICd0ZXh0JzsgLy8gSWYgd2UgYXJlIGF0IHRoZSBlZGdlIG9mIGEgdGV4dCBub2RlIGFuZCB3ZVxuICAgICAgLy8gZG9uJ3QgaGF2ZSBhIGNvbGxhcHNlZCBzZWxlY3Rpb24sIHRoZW4gbGV0J3NcbiAgICAgIC8vIHRyeSBhbmQgY29ycmVjdCB0aGUgb2Zmc2V0IG5vZGUuXG5cbiAgICAgIGNvbnN0IHNpYmxpbmcgPSBzdGFydE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgaWYgKHN0YXJ0ICE9PSBlbmQgJiYgc3RhcnRPZmZzZXQgPT09IHN0YXJ0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSAmJiBsZXhpY2FsLiRpc1RleHROb2RlKHNpYmxpbmcpKSB7XG4gICAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgICAgc3RhcnRLZXkgPSBzaWJsaW5nLl9fa2V5O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RhcnRPZmZzZXROb2RlLnR5cGUgPT09ICdpbmxpbmUnKSB7XG4gICAgICBzdGFydEtleSA9IHN0YXJ0Tm9kZS5nZXRQYXJlbnRPclRocm93KCkuZ2V0S2V5KCk7XG4gICAgICBzdGFydE9mZnNldCA9IGVuZCA+IHN0YXJ0T2Zmc2V0Tm9kZS5zdGFydCA/IHN0YXJ0T2Zmc2V0Tm9kZS5lbmQgOiBzdGFydE9mZnNldE5vZGUuc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKGVuZE9mZnNldE5vZGUudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBlbmRPZmZzZXQgPSBlbmQgLSBlbmRPZmZzZXROb2RlLnN0YXJ0O1xuICAgICAgZW5kVHlwZSA9ICd0ZXh0JztcbiAgICB9IGVsc2UgaWYgKGVuZE9mZnNldE5vZGUudHlwZSA9PT0gJ2lubGluZScpIHtcbiAgICAgIGVuZEtleSA9IGVuZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLmdldEtleSgpO1xuICAgICAgZW5kT2Zmc2V0ID0gZW5kID4gZW5kT2Zmc2V0Tm9kZS5zdGFydCA/IGVuZE9mZnNldE5vZGUuZW5kIDogZW5kT2Zmc2V0Tm9kZS5zdGFydDtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRjcmVhdGVSYW5nZVNlbGVjdGlvbigpO1xuXG4gICAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uLmFuY2hvci5zZXQoc3RhcnRLZXksIHN0YXJ0T2Zmc2V0LCBzdGFydFR5cGUpO1xuICAgIHNlbGVjdGlvbi5mb2N1cy5zZXQoZW5kS2V5LCBlbmRPZmZzZXQsIGVuZFR5cGUpO1xuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cblxuICBnZXRPZmZzZXRzRnJvbVNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgIGNvbnN0IG9mZnNldE1hcCA9IHRoaXMuX29mZnNldE1hcDtcbiAgICBjb25zdCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICAgIGxldCBzdGFydCA9IC0xO1xuICAgIGxldCBlbmQgPSAtMTtcblxuICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBjb25zdCBvZmZzZXROb2RlID0gb2Zmc2V0TWFwLmdldChhbmNob3Iua2V5KTtcblxuICAgICAgaWYgKG9mZnNldE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdGFydCA9IG9mZnNldE5vZGUuc3RhcnQgKyBhbmNob3JPZmZzZXQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpLmdldERlc2NlbmRhbnRCeUluZGV4KGFuY2hvck9mZnNldCk7XG5cbiAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldE5vZGUgPSBvZmZzZXRNYXAuZ2V0KG5vZGUuZ2V0S2V5KCkpO1xuXG4gICAgICAgIGlmIChvZmZzZXROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zdCBpc0F0RW5kID0gbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICE9PSBhbmNob3JPZmZzZXQ7XG4gICAgICAgICAgc3RhcnQgPSBpc0F0RW5kID8gb2Zmc2V0Tm9kZS5lbmQgOiBvZmZzZXROb2RlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZvY3VzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgY29uc3Qgb2Zmc2V0Tm9kZSA9IG9mZnNldE1hcC5nZXQoZm9jdXMua2V5KTtcblxuICAgICAgaWYgKG9mZnNldE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBvZmZzZXROb2RlLnN0YXJ0ICsgZm9jdXMub2Zmc2V0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub2RlID0gZm9jdXMuZ2V0Tm9kZSgpLmdldERlc2NlbmRhbnRCeUluZGV4KGZvY3VzT2Zmc2V0KTtcblxuICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0Tm9kZSA9IG9mZnNldE1hcC5nZXQobm9kZS5nZXRLZXkoKSk7XG5cbiAgICAgICAgaWYgKG9mZnNldE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IGlzQXRFbmQgPSBub2RlLmdldEluZGV4V2l0aGluUGFyZW50KCkgIT09IGZvY3VzT2Zmc2V0O1xuICAgICAgICAgIGVuZCA9IGlzQXRFbmQgPyBvZmZzZXROb2RlLmVuZCA6IG9mZnNldE5vZGUuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3N0YXJ0LCBlbmRdO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gJGdldEFkanVzdGVkT2Zmc2V0RnJvbURpZmYob2Zmc2V0LCBvZmZzZXROb2RlLCBwcmV2T2Zmc2V0Vmlldywgb2Zmc2V0VmlldywgYmxvY2tPZmZzZXRTaXplKSB7XG4gIGNvbnN0IHByZXZPZmZzZXRNYXAgPSBwcmV2T2Zmc2V0Vmlldy5fb2Zmc2V0TWFwO1xuICBjb25zdCBvZmZzZXRNYXAgPSBvZmZzZXRWaWV3Ll9vZmZzZXRNYXA7XG4gIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIGxldCBhZGp1c3RlZE9mZnNldCA9IG9mZnNldDtcbiAgbGV0IGN1cnJlbnROb2RlID0gb2Zmc2V0Tm9kZTtcblxuICB3aGlsZSAoY3VycmVudE5vZGUgIT09IG51bGwpIHtcbiAgICBjb25zdCBrZXkgPSBjdXJyZW50Tm9kZS5rZXk7XG4gICAgY29uc3QgcHJldk5vZGUgPSBwcmV2T2Zmc2V0TWFwLmdldChrZXkpO1xuICAgIGNvbnN0IGRpZmYgPSBjdXJyZW50Tm9kZS5lbmQgLSBjdXJyZW50Tm9kZS5zdGFydDtcbiAgICB2aXNpdGVkLmFkZChrZXkpO1xuXG4gICAgaWYgKHByZXZOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFkanVzdGVkT2Zmc2V0ICs9IGRpZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZEaWZmID0gcHJldk5vZGUuZW5kIC0gcHJldk5vZGUuc3RhcnQ7XG5cbiAgICAgIGlmIChwcmV2RGlmZiAhPT0gZGlmZikge1xuICAgICAgICBhZGp1c3RlZE9mZnNldCArPSBkaWZmIC0gcHJldkRpZmY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2libGluZyA9IGN1cnJlbnROb2RlLnByZXY7XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgY3VycmVudE5vZGUgPSBzaWJsaW5nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbGV0IHBhcmVudCA9IGN1cnJlbnROb2RlLnBhcmVudDtcblxuICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIGxldCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LnByZXY7XG5cbiAgICAgIGlmIChwYXJlbnRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudFNpYmxpbmdLZXkgPSBwYXJlbnRTaWJsaW5nLmtleTtcbiAgICAgICAgY29uc3QgcHJldlBhcmVudFNpYmxpbmcgPSBwcmV2T2Zmc2V0TWFwLmdldChwYXJlbnRTaWJsaW5nS2V5KTtcbiAgICAgICAgY29uc3QgcGFyZW50RGlmZiA9IHBhcmVudFNpYmxpbmcuZW5kIC0gcGFyZW50U2libGluZy5zdGFydDtcbiAgICAgICAgdmlzaXRlZC5hZGQocGFyZW50U2libGluZ0tleSk7XG5cbiAgICAgICAgaWYgKHByZXZQYXJlbnRTaWJsaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGp1c3RlZE9mZnNldCArPSBwYXJlbnREaWZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHByZXZQYXJlbnREaWZmID0gcHJldlBhcmVudFNpYmxpbmcuZW5kIC0gcHJldlBhcmVudFNpYmxpbmcuc3RhcnQ7XG5cbiAgICAgICAgICBpZiAocHJldlBhcmVudERpZmYgIT09IHBhcmVudERpZmYpIHtcbiAgICAgICAgICAgIGFkanVzdGVkT2Zmc2V0ICs9IHBhcmVudERpZmYgLSBwcmV2UGFyZW50RGlmZjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRTaWJsaW5nID0gcGFyZW50U2libGluZy5wcmV2O1xuICAgICAgfVxuXG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIGJyZWFrO1xuICB9IC8vIE5vdyB0cmF2ZXJzZSB0aHJvdWdoIHRoZSBvbGQgb2Zmc2V0cyBub2RlcyBhbmQgZmluZCBhbnkgbm9kZXMgd2UgbWlzc2VkXG4gIC8vIGFib3ZlLCBiZWNhdXNlIHRoZXkgd2VyZSBub3QgaW4gdGhlIGxhdGVzdCBvZmZzZXQgbm9kZSB2aWV3ICh0aGV5IGhhdmUgYmVlblxuICAvLyBkZWxldGVkKS5cblxuXG4gIGNvbnN0IHByZXZGaXJzdE5vZGUgPSBwcmV2T2Zmc2V0Vmlldy5fZmlyc3ROb2RlO1xuXG4gIGlmIChwcmV2Rmlyc3ROb2RlICE9PSBudWxsKSB7XG4gICAgY3VycmVudE5vZGUgPSAkc2VhcmNoRm9yTm9kZVdpdGhPZmZzZXQocHJldkZpcnN0Tm9kZSwgb2Zmc2V0LCBibG9ja09mZnNldFNpemUpO1xuICAgIGxldCBhbHJlYWR5VmlzaXRlZFBhcmVudE9mQ3VycmVudE5vZGUgPSBmYWxzZTtcblxuICAgIHdoaWxlIChjdXJyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhjdXJyZW50Tm9kZS5rZXkpKSB7XG4gICAgICAgIGFscmVhZHlWaXNpdGVkUGFyZW50T2ZDdXJyZW50Tm9kZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAoIWFscmVhZHlWaXNpdGVkUGFyZW50T2ZDdXJyZW50Tm9kZSkge1xuICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGN1cnJlbnROb2RlLmtleTtcblxuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKGtleSkpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gb2Zmc2V0TWFwLmdldChrZXkpO1xuICAgICAgICAgIGNvbnN0IHByZXZEaWZmID0gY3VycmVudE5vZGUuZW5kIC0gY3VycmVudE5vZGUuc3RhcnQ7XG5cbiAgICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhZGp1c3RlZE9mZnNldCAtPSBwcmV2RGlmZjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IG5vZGUuZW5kIC0gbm9kZS5zdGFydDtcblxuICAgICAgICAgICAgaWYgKHByZXZEaWZmICE9PSBkaWZmKSB7XG4gICAgICAgICAgICAgIGFkanVzdGVkT2Zmc2V0ICs9IGRpZmYgLSBwcmV2RGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnByZXY7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFkanVzdGVkT2Zmc2V0O1xufVxuXG5mdW5jdGlvbiAkc2VhcmNoRm9yTm9kZVdpdGhPZmZzZXQoZmlyc3ROb2RlLCBvZmZzZXQsIGJsb2NrT2Zmc2V0U2l6ZSkge1xuICBsZXQgY3VycmVudE5vZGUgPSBmaXJzdE5vZGU7XG5cbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgY29uc3QgZW5kID0gY3VycmVudE5vZGUuZW5kICsgKGN1cnJlbnROb2RlLnR5cGUgIT09ICdlbGVtZW50JyB8fCBibG9ja09mZnNldFNpemUgPT09IDAgPyAxIDogMCk7XG5cbiAgICBpZiAob2Zmc2V0IDwgZW5kKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGN1cnJlbnROb2RlLmNoaWxkO1xuXG4gICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9XG5cbiAgICBjb25zdCBzaWJsaW5nID0gY3VycmVudE5vZGUubmV4dDtcblxuICAgIGlmIChzaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjdXJyZW50Tm9kZSA9IHNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gJGNyZWF0ZUludGVybmFsT2Zmc2V0Tm9kZShjaGlsZCwgdHlwZSwgc3RhcnQsIGVuZCwga2V5LCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBjaGlsZCxcbiAgICBlbmQsXG4gICAga2V5LFxuICAgIG5leHQ6IG51bGwsXG4gICAgcGFyZW50LFxuICAgIHByZXY6IG51bGwsXG4gICAgc3RhcnQsXG4gICAgdHlwZVxuICB9O1xufVxuXG5mdW5jdGlvbiAkY3JlYXRlT2Zmc2V0Tm9kZShzdGF0ZSwga2V5LCBwYXJlbnQsIG5vZGVNYXAsIG9mZnNldE1hcCwgYmxvY2tPZmZzZXRTaXplKSB7XG4gIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChrZXkpO1xuXG4gIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgY3JlYXRlT2Zmc2V0TW9kZWw6IGNvdWxkIG5vdCBmaW5kIG5vZGUgYnkga2V5YCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RhcnQgPSBzdGF0ZS5vZmZzZXQ7XG5cbiAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBjaGlsZEtleXMgPSBjcmVhdGVDaGlsZHJlbkFycmF5KG5vZGUsIG5vZGVNYXApO1xuICAgIGNvbnN0IGJsb2NrSXNFbXB0eSA9IGNoaWxkS2V5cy5sZW5ndGggPT09IDA7XG4gICAgY29uc3QgY2hpbGQgPSBibG9ja0lzRW1wdHkgPyBudWxsIDogJGNyZWF0ZU9mZnNldENoaWxkKHN0YXRlLCBjaGlsZEtleXMsIG51bGwsIG5vZGVNYXAsIG9mZnNldE1hcCwgYmxvY2tPZmZzZXRTaXplKTsgLy8gSWYgdGhlIHByZXYgbm9kZSB3YXMgbm90IGEgYmxvY2sgb3IgdGhlIGJsb2NrIGlzIGVtcHR5LCB3ZSBzaG91bGRcbiAgICAvLyBhY2NvdW50IGZvciB0aGUgdXNlciBiZWluZyBhYmxlIHRvIHNlbGVjdGlvbiB0aGUgYmxvY2sgKGR1ZSB0byB0aGUgXFxuKS5cblxuICAgIGlmICghc3RhdGUucHJldklzQmxvY2sgfHwgYmxvY2tJc0VtcHR5KSB7XG4gICAgICBzdGF0ZS5wcmV2SXNCbG9jayA9IHRydWU7XG4gICAgICBzdGF0ZS5vZmZzZXQgKz0gYmxvY2tPZmZzZXRTaXplO1xuICAgIH1cblxuICAgIGNvbnN0IG9mZnNldE5vZGUgPSAkY3JlYXRlSW50ZXJuYWxPZmZzZXROb2RlKGNoaWxkLCAnZWxlbWVudCcsIHN0YXJ0LCBzdGFydCwga2V5LCBwYXJlbnQpO1xuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBjaGlsZC5wYXJlbnQgPSBvZmZzZXROb2RlO1xuICAgIH1cblxuICAgIGNvbnN0IGVuZCA9IHN0YXRlLm9mZnNldDtcbiAgICBvZmZzZXROb2RlLmVuZCA9IGVuZDtcbiAgICBvZmZzZXRNYXAuc2V0KGtleSwgb2Zmc2V0Tm9kZSk7XG4gICAgcmV0dXJuIG9mZnNldE5vZGU7XG4gIH1cblxuICBzdGF0ZS5wcmV2SXNCbG9jayA9IGZhbHNlO1xuICBjb25zdCBpc1RleHQgPSBsZXhpY2FsLiRpc1RleHROb2RlKG5vZGUpO1xuICBjb25zdCBsZW5ndGggPSBpc1RleHQgPyBub2RlLl9fdGV4dC5sZW5ndGggOiAxO1xuICBjb25zdCBlbmQgPSBzdGF0ZS5vZmZzZXQgKz0gbGVuZ3RoO1xuICBjb25zdCBvZmZzZXROb2RlID0gJGNyZWF0ZUludGVybmFsT2Zmc2V0Tm9kZShudWxsLCBpc1RleHQgPyAndGV4dCcgOiAnaW5saW5lJywgc3RhcnQsIGVuZCwga2V5LCBwYXJlbnQpO1xuICBvZmZzZXRNYXAuc2V0KGtleSwgb2Zmc2V0Tm9kZSk7XG4gIHJldHVybiBvZmZzZXROb2RlO1xufVxuXG5mdW5jdGlvbiAkY3JlYXRlT2Zmc2V0Q2hpbGQoc3RhdGUsIGNoaWxkcmVuLCBwYXJlbnQsIG5vZGVNYXAsIG9mZnNldE1hcCwgYmxvY2tPZmZzZXRTaXplKSB7XG4gIGxldCBmaXJzdE5vZGUgPSBudWxsO1xuICBsZXQgY3VycmVudE5vZGUgPSBudWxsO1xuICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZEtleSA9IGNoaWxkcmVuW2ldO1xuICAgIGNvbnN0IG9mZnNldE5vZGUgPSAkY3JlYXRlT2Zmc2V0Tm9kZShzdGF0ZSwgY2hpbGRLZXksIHBhcmVudCwgbm9kZU1hcCwgb2Zmc2V0TWFwLCBibG9ja09mZnNldFNpemUpO1xuXG4gICAgaWYgKGN1cnJlbnROb2RlID09PSBudWxsKSB7XG4gICAgICBmaXJzdE5vZGUgPSBvZmZzZXROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXROb2RlLnByZXYgPSBjdXJyZW50Tm9kZTtcbiAgICAgIGN1cnJlbnROb2RlLm5leHQgPSBvZmZzZXROb2RlO1xuICAgIH1cblxuICAgIGN1cnJlbnROb2RlID0gb2Zmc2V0Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBmaXJzdE5vZGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuQXJyYXkoZWxlbWVudCwgbm9kZU1hcCkge1xuICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICBsZXQgbm9kZUtleSA9IGVsZW1lbnQuX19maXJzdDtcblxuICB3aGlsZSAobm9kZUtleSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwID09PSBudWxsID8gbGV4aWNhbC4kZ2V0Tm9kZUJ5S2V5KG5vZGVLZXkpIDogbm9kZU1hcC5nZXQobm9kZUtleSk7XG5cbiAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYGNyZWF0ZUNoaWxkcmVuQXJyYXk6IG5vZGUgZG9lcyBub3QgZXhpc3QgaW4gbm9kZU1hcGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkcmVuLnB1c2gobm9kZUtleSk7XG4gICAgbm9kZUtleSA9IG5vZGUuX19uZXh0O1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuZnVuY3Rpb24gJGNyZWF0ZU9mZnNldFZpZXcoZWRpdG9yLCBibG9ja09mZnNldFNpemUgPSAxLCBlZGl0b3JTdGF0ZSkge1xuICBjb25zdCB0YXJnZXRFZGl0b3JTdGF0ZSA9IGVkaXRvclN0YXRlIHx8IGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlIHx8IGVkaXRvci5fZWRpdG9yU3RhdGU7XG4gIGNvbnN0IG5vZGVNYXAgPSB0YXJnZXRFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgY29uc3Qgcm9vdCA9IG5vZGVNYXAuZ2V0KCdyb290Jyk7XG4gIGNvbnN0IG9mZnNldE1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgb2Zmc2V0OiAwLFxuICAgIHByZXZJc0Jsb2NrOiBmYWxzZVxuICB9O1xuICBjb25zdCBub2RlID0gJGNyZWF0ZU9mZnNldENoaWxkKHN0YXRlLCBjcmVhdGVDaGlsZHJlbkFycmF5KHJvb3QsIG5vZGVNYXApLCBudWxsLCBub2RlTWFwLCBvZmZzZXRNYXAsIGJsb2NrT2Zmc2V0U2l6ZSk7XG4gIHJldHVybiBuZXcgT2Zmc2V0VmlldyhvZmZzZXRNYXAsIG5vZGUsIGJsb2NrT2Zmc2V0U2l6ZSk7XG59XG5cbmV4cG9ydHMuJGNyZWF0ZU9mZnNldFZpZXcgPSAkY3JlYXRlT2Zmc2V0VmlldztcbmV4cG9ydHMuT2Zmc2V0VmlldyA9IE9mZnNldFZpZXc7XG5leHBvcnRzLmNyZWF0ZUNoaWxkcmVuQXJyYXkgPSBjcmVhdGVDaGlsZHJlbkFycmF5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/offset/LexicalOffset.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/offset/LexicalOffset.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/offset/LexicalOffset.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalOffset =  true ? __webpack_require__(/*! ./LexicalOffset.dev.js */ \"(ssr)/./node_modules/@lexical/offset/LexicalOffset.dev.js\") : 0\nmodule.exports = LexicalOffset;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvb2Zmc2V0L0xleGljYWxPZmZzZXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWixzQkFBc0IsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLHlGQUF3QixJQUFJLENBQWtDO0FBQ3JJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvb2Zmc2V0L0xleGljYWxPZmZzZXQuanM/OTA0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbE9mZnNldCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsT2Zmc2V0LmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsT2Zmc2V0LnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsT2Zmc2V0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/offset/LexicalOffset.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/overflow/LexicalOverflow.dev.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/overflow/LexicalOverflow.dev.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/overflow */\n\n/** @noInheritDoc */\nclass OverflowNode extends lexical.ElementNode {\n  static getType() {\n    return 'overflow';\n  }\n\n  static clone(node) {\n    return new OverflowNode(node.__key);\n  }\n\n  static importJSON(serializedNode) {\n    return $createOverflowNode();\n  }\n\n  static importDOM() {\n    return null;\n  }\n\n  constructor(key) {\n    super(key);\n    this.__type = 'overflow';\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'overflow'\n    };\n  }\n\n  createDOM(config) {\n    const div = document.createElement('span');\n    const className = config.theme.characterLimit;\n\n    if (typeof className === 'string') {\n      div.className = className;\n    }\n\n    return div;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const parent = this.getParentOrThrow();\n    return parent.insertNewAfter(selection, restoreSelection);\n  }\n\n  excludeFromCopy() {\n    return true;\n  }\n\n}\nfunction $createOverflowNode() {\n  return lexical.$applyNodeReplacement(new OverflowNode());\n}\nfunction $isOverflowNode(node) {\n  return node instanceof OverflowNode;\n}\n\nexports.$createOverflowNode = $createOverflowNode;\nexports.$isOverflowNode = $isOverflowNode;\nexports.OverflowNode = OverflowNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvb3ZlcmZsb3cvTGV4aWNhbE92ZXJmbG93LmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsd0RBQVM7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQix1QkFBdUI7QUFDdkIsb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvb3ZlcmZsb3cvTGV4aWNhbE92ZXJmbG93LmRldi5qcz8xYTA2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcblxuLyoqIEBtb2R1bGUgQGxleGljYWwvb3ZlcmZsb3cgKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIE92ZXJmbG93Tm9kZSBleHRlbmRzIGxleGljYWwuRWxlbWVudE5vZGUge1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ292ZXJmbG93JztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBPdmVyZmxvd05vZGUobm9kZS5fX2tleSk7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlT3ZlcmZsb3dOb2RlKCk7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fdHlwZSA9ICdvdmVyZmxvdyc7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHR5cGU6ICdvdmVyZmxvdydcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBjb25maWcudGhlbWUuY2hhcmFjdGVyTGltaXQ7XG5cbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRpdi5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIHJldHVybiBwYXJlbnQuaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgfVxuXG4gIGV4Y2x1ZGVGcm9tQ29weSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG59XG5mdW5jdGlvbiAkY3JlYXRlT3ZlcmZsb3dOb2RlKCkge1xuICByZXR1cm4gbGV4aWNhbC4kYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IE92ZXJmbG93Tm9kZSgpKTtcbn1cbmZ1bmN0aW9uICRpc092ZXJmbG93Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3ZlcmZsb3dOb2RlO1xufVxuXG5leHBvcnRzLiRjcmVhdGVPdmVyZmxvd05vZGUgPSAkY3JlYXRlT3ZlcmZsb3dOb2RlO1xuZXhwb3J0cy4kaXNPdmVyZmxvd05vZGUgPSAkaXNPdmVyZmxvd05vZGU7XG5leHBvcnRzLk92ZXJmbG93Tm9kZSA9IE92ZXJmbG93Tm9kZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/overflow/LexicalOverflow.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/overflow/LexicalOverflow.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lexical/overflow/LexicalOverflow.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalOverflow =  true ? __webpack_require__(/*! ./LexicalOverflow.dev.js */ \"(ssr)/./node_modules/@lexical/overflow/LexicalOverflow.dev.js\") : 0\nmodule.exports = LexicalOverflow;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvb3ZlcmZsb3cvTGV4aWNhbE92ZXJmbG93LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osd0JBQXdCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQywrRkFBMEIsSUFBSSxDQUFvQztBQUMzSSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL292ZXJmbG93L0xleGljYWxPdmVyZmxvdy5qcz9lYzM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsT3ZlcmZsb3cgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbE92ZXJmbG93LmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsT3ZlcmZsb3cucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxPdmVyZmxvdzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/overflow/LexicalOverflow.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/plain-text/LexicalPlainText.dev.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/plain-text/LexicalPlainText.dev.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar clipboard = __webpack_require__(/*! @lexical/clipboard */ \"(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.js\");\nvar selection = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/** @module @lexical/plain-text */\n\nfunction onCopyForPlainText(event, editor) {\n  editor.update(() => {\n    const clipboardData = event instanceof KeyboardEvent ? null : event.clipboardData;\n    const selection = lexical.$getSelection();\n\n    if (selection !== null && clipboardData != null) {\n      event.preventDefault();\n      const htmlString = clipboard.$getHtmlContent(editor);\n\n      if (htmlString !== null) {\n        clipboardData.setData('text/html', htmlString);\n      }\n\n      clipboardData.setData('text/plain', selection.getTextContent());\n    }\n  });\n}\n\nfunction onPasteForPlainText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;\n\n    if (clipboardData != null && lexical.$isRangeSelection(selection)) {\n      clipboard.$insertDataTransferForPlainText(clipboardData, selection);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\n\nfunction onCutForPlainText(event, editor) {\n  onCopyForPlainText(event, editor);\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      selection.removeText();\n    }\n  });\n}\n\nfunction registerPlainText(editor) {\n  const removeListener = utils.mergeRegister(editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    if (typeof eventOrText === 'string') {\n      selection.insertText(eventOrText);\n    } else {\n      const dataTransfer = eventOrText.dataTransfer;\n\n      if (dataTransfer != null) {\n        clipboard.$insertDataTransferForPlainText(dataTransfer, selection);\n      } else {\n        const data = eventOrText.data;\n\n        if (data) {\n          selection.insertText(data);\n        }\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.removeText();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertLineBreak();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, payload => {\n    const selection$1 = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    const event = payload;\n    const isHoldingShift = event.shiftKey;\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, true);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, payload => {\n    const selection$1 = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    const event = payload;\n    const isHoldingShift = event.shiftKey;\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, false);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n\n      event.preventDefault();\n    }\n\n    return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    onCopyForPlainText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    onCutForPlainText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    onPasteForPlainText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    } // TODO: Make drag and drop work at some point.\n\n\n    event.preventDefault();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    } // TODO: Make drag and drop work at some point.\n\n\n    event.preventDefault();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\nexports.registerPlainText = registerPlainText;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcGxhaW4tdGV4dC9MZXhpY2FsUGxhaW5UZXh0LmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQyx1RkFBb0I7QUFDNUMsZ0JBQWdCLG1CQUFPLENBQUMsdUZBQW9CO0FBQzVDLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLHdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRzs7QUFFQSwrRUFBK0U7O0FBRS9FOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3BsYWluLXRleHQvTGV4aWNhbFBsYWluVGV4dC5kZXYuanM/MGFjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGNsaXBib2FyZCA9IHJlcXVpcmUoJ0BsZXhpY2FsL2NsaXBib2FyZCcpO1xudmFyIHNlbGVjdGlvbiA9IHJlcXVpcmUoJ0BsZXhpY2FsL3NlbGVjdGlvbicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQGxleGljYWwvdXRpbHMnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IGRvY3VtZW50TW9kZSA9IENBTl9VU0VfRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogbnVsbDtcbkNBTl9VU0VfRE9NICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuQ0FOX1VTRV9ET00gJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3gpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgQ0FOX1VTRV9CRUZPUkVfSU5QVVQgPSBDQU5fVVNFX0RPTSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcbmNvbnN0IElTX1NBRkFSSSA9IENBTl9VU0VfRE9NICYmIC9WZXJzaW9uXFwvW1xcZC5dKy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgSVNfSU9TID0gQ0FOX1VTRV9ET00gJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTsgLy8gS2VlcCB0aGVzZSBpbiBjYXNlIHdlIG5lZWQgdG8gdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZS5cbi8vIGV4cG9ydCBjb25zdCBJU19XSU5ET1dTOiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG5jb25zdCBJU19DSFJPTUUgPSBDQU5fVVNFX0RPTSAmJiAvXig/PS4qQ2hyb21lKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gZXhwb3J0IGNvbnN0IGNhblVzZVRleHRJbnB1dEV2ZW50OiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbmNvbnN0IElTX0FQUExFX1dFQktJVCA9IENBTl9VU0VfRE9NICYmIC9BcHBsZVdlYktpdFxcL1tcXGQuXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIUlTX0NIUk9NRTtcblxuLyoqIEBtb2R1bGUgQGxleGljYWwvcGxhaW4tdGV4dCAqL1xuXG5mdW5jdGlvbiBvbkNvcHlGb3JQbGFpblRleHQoZXZlbnQsIGVkaXRvcikge1xuICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICBjb25zdCBjbGlwYm9hcmREYXRhID0gZXZlbnQgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50ID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsICYmIGNsaXBib2FyZERhdGEgIT0gbnVsbCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGh0bWxTdHJpbmcgPSBjbGlwYm9hcmQuJGdldEh0bWxDb250ZW50KGVkaXRvcik7XG5cbiAgICAgIGlmIChodG1sU3RyaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9odG1sJywgaHRtbFN0cmluZyk7XG4gICAgICB9XG5cbiAgICAgIGNsaXBib2FyZERhdGEuc2V0RGF0YSgndGV4dC9wbGFpbicsIHNlbGVjdGlvbi5nZXRUZXh0Q29udGVudCgpKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvblBhc3RlRm9yUGxhaW5UZXh0KGV2ZW50LCBlZGl0b3IpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG4gICAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGV2ZW50IGluc3RhbmNlb2YgSW5wdXRFdmVudCB8fCBldmVudCBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQgPyBudWxsIDogZXZlbnQuY2xpcGJvYXJkRGF0YTtcblxuICAgIGlmIChjbGlwYm9hcmREYXRhICE9IG51bGwgJiYgbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjbGlwYm9hcmQuJGluc2VydERhdGFUcmFuc2ZlckZvclBsYWluVGV4dChjbGlwYm9hcmREYXRhLCBzZWxlY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIHRhZzogJ3Bhc3RlJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25DdXRGb3JQbGFpblRleHQoZXZlbnQsIGVkaXRvcikge1xuICBvbkNvcHlGb3JQbGFpblRleHQoZXZlbnQsIGVkaXRvcik7XG4gIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgc2VsZWN0aW9uLnJlbW92ZVRleHQoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlclBsYWluVGV4dChlZGl0b3IpIHtcbiAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSB1dGlscy5tZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5ERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIGlzQmFja3dhcmQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3Rpb24uZGVsZXRlQ2hhcmFjdGVyKGlzQmFja3dhcmQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkRFTEVURV9XT1JEX0NPTU1BTkQsIGlzQmFja3dhcmQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3Rpb24uZGVsZXRlV29yZChpc0JhY2t3YXJkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5ERUxFVEVfTElORV9DT01NQU5ELCBpc0JhY2t3YXJkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uLmRlbGV0ZUxpbmUoaXNCYWNrd2FyZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBldmVudE9yVGV4dCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZXZlbnRPclRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZWxlY3Rpb24uaW5zZXJ0VGV4dChldmVudE9yVGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRhdGFUcmFuc2ZlciA9IGV2ZW50T3JUZXh0LmRhdGFUcmFuc2ZlcjtcblxuICAgICAgaWYgKGRhdGFUcmFuc2ZlciAhPSBudWxsKSB7XG4gICAgICAgIGNsaXBib2FyZC4kaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUGxhaW5UZXh0KGRhdGFUcmFuc2Zlciwgc2VsZWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBldmVudE9yVGV4dC5kYXRhO1xuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmluc2VydFRleHQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5SRU1PVkVfVEVYVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNlbGVjdGlvbi5yZW1vdmVUZXh0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgc2VsZWN0U3RhcnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3Rpb24uaW5zZXJ0TGluZUJyZWFrKHNlbGVjdFN0YXJ0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5JTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uLmluc2VydExpbmVCcmVhaygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9BUlJPV19MRUZUX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiQxID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uJDEpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnQgPSBwYXlsb2FkO1xuICAgIGNvbnN0IGlzSG9sZGluZ1NoaWZ0ID0gZXZlbnQuc2hpZnRLZXk7XG5cbiAgICBpZiAoc2VsZWN0aW9uLiRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24oc2VsZWN0aW9uJDEsIHRydWUpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc2VsZWN0aW9uLiRtb3ZlQ2hhcmFjdGVyKHNlbGVjdGlvbiQxLCBpc0hvbGRpbmdTaGlmdCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiQxID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uJDEpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnQgPSBwYXlsb2FkO1xuICAgIGNvbnN0IGlzSG9sZGluZ1NoaWZ0ID0gZXZlbnQuc2hpZnRLZXk7XG5cbiAgICBpZiAoc2VsZWN0aW9uLiRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24oc2VsZWN0aW9uJDEsIGZhbHNlKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNlbGVjdGlvbi4kbW92ZUNoYXJhY3RlcihzZWxlY3Rpb24kMSwgaXNIb2xkaW5nU2hpZnQsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQkFDS1NQQUNFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLkRFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgdHJ1ZSk7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0RFTEVURV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5ERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIGZhbHNlKTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfRU5URVJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYmVmb3JlaW5wdXQsIHRoZW4gd2UgY2FuIGF2b2lkIGJsb2NraW5nXG4gICAgICAvLyB0aGUgZGVmYXVsdCBiZWhhdmlvci4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGlPUyBjYW5cbiAgICAgIC8vIGludGVyY2VwdCB0aGF0IHdlJ3JlIGFjdHVhbGx5IGluc2VydGluZyBhIHBhcmFncmFwaCxcbiAgICAgIC8vIGFuZCBhdXRvY29tcGxldGUsIGF1dG9jYXBpdGFsaXplIGV0YyB3b3JrIGFzIGludGVuZGVkLlxuICAgICAgLy8gVGhpcyBjYW4gYWxzbyBjYXVzZSBhIHN0cmFuZ2UgcGVyZm9ybWFuY2UgaXNzdWUgaW5cbiAgICAgIC8vIFNhZmFyaSwgd2hlcmUgdGhlcmUgaXMgYSBub3RpY2VhYmxlIHBhdXNlIGR1ZSB0b1xuICAgICAgLy8gcHJldmVudGluZyB0aGUga2V5IGRvd24gb2YgZW50ZXIuXG4gICAgICBpZiAoKElTX0lPUyB8fCBJU19TQUZBUkkgfHwgSVNfQVBQTEVfV0VCS0lUKSAmJiBDQU5fVVNFX0JFRk9SRV9JTlBVVCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5JTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBmYWxzZSk7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuQ09QWV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9uQ29weUZvclBsYWluVGV4dChldmVudCwgZWRpdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5DVVRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBvbkN1dEZvclBsYWluVGV4dChldmVudCwgZWRpdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5QQVNURV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9uUGFzdGVGb3JQbGFpblRleHQoZXZlbnQsIGVkaXRvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuRFJPUF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gVE9ETzogTWFrZSBkcmFnIGFuZCBkcm9wIHdvcmsgYXQgc29tZSBwb2ludC5cblxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5EUkFHU1RBUlRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFRPRE86IE1ha2UgZHJhZyBhbmQgZHJvcCB3b3JrIGF0IHNvbWUgcG9pbnQuXG5cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpKTtcbiAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xufVxuXG5leHBvcnRzLnJlZ2lzdGVyUGxhaW5UZXh0ID0gcmVnaXN0ZXJQbGFpblRleHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/plain-text/LexicalPlainText.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/plain-text/LexicalPlainText.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/plain-text/LexicalPlainText.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalPlainText =  true ? __webpack_require__(/*! ./LexicalPlainText.dev.js */ \"(ssr)/./node_modules/@lexical/plain-text/LexicalPlainText.dev.js\") : 0\nmodule.exports = LexicalPlainText;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcGxhaW4tdGV4dC9MZXhpY2FsUGxhaW5UZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1oseUJBQXlCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxtR0FBMkIsSUFBSSxDQUFxQztBQUM5SSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3BsYWluLXRleHQvTGV4aWNhbFBsYWluVGV4dC5qcz9jNTcyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsUGxhaW5UZXh0ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxQbGFpblRleHQuZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxQbGFpblRleHQucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxQbGFpblRleHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/plain-text/LexicalPlainText.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction AutoFocusPlugin({\n  defaultSelection\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    editor.focus(() => {\n      // If we try and move selection to the same point with setBaseAndExtent, it won't\n      // trigger a re-focus on the element. So in the case this occurs, we'll need to correct it.\n      // Normally this is fine, Selection API !== Focus API, but fore the intents of the naming\n      // of this plugin, which should preserve focus too.\n      const activeElement = document.activeElement;\n      const rootElement = editor.getRootElement();\n\n      if (rootElement !== null && (activeElement === null || !rootElement.contains(activeElement))) {\n        // Note: preventScroll won't work in Webkit.\n        rootElement.focus({\n          preventScroll: true\n        });\n      }\n    }, {\n      defaultSelection\n    });\n  }, [defaultSelection, editor]);\n  return null;\n}\n\nexports.AutoFocusPlugin = AutoFocusPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEF1dG9Gb2N1c1BsdWdpbi5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsNEdBQXVDO0FBQzVFLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQSx1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQXV0b0ZvY3VzUGx1Z2luLmRldi5qcz8xZTIyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIEF1dG9Gb2N1c1BsdWdpbih7XG4gIGRlZmF1bHRTZWxlY3Rpb25cbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBlZGl0b3IuZm9jdXMoKCkgPT4ge1xuICAgICAgLy8gSWYgd2UgdHJ5IGFuZCBtb3ZlIHNlbGVjdGlvbiB0byB0aGUgc2FtZSBwb2ludCB3aXRoIHNldEJhc2VBbmRFeHRlbnQsIGl0IHdvbid0XG4gICAgICAvLyB0cmlnZ2VyIGEgcmUtZm9jdXMgb24gdGhlIGVsZW1lbnQuIFNvIGluIHRoZSBjYXNlIHRoaXMgb2NjdXJzLCB3ZSdsbCBuZWVkIHRvIGNvcnJlY3QgaXQuXG4gICAgICAvLyBOb3JtYWxseSB0aGlzIGlzIGZpbmUsIFNlbGVjdGlvbiBBUEkgIT09IEZvY3VzIEFQSSwgYnV0IGZvcmUgdGhlIGludGVudHMgb2YgdGhlIG5hbWluZ1xuICAgICAgLy8gb2YgdGhpcyBwbHVnaW4sIHdoaWNoIHNob3VsZCBwcmVzZXJ2ZSBmb2N1cyB0b28uXG4gICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG5cbiAgICAgIGlmIChyb290RWxlbWVudCAhPT0gbnVsbCAmJiAoYWN0aXZlRWxlbWVudCA9PT0gbnVsbCB8fCAhcm9vdEVsZW1lbnQuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpKSB7XG4gICAgICAgIC8vIE5vdGU6IHByZXZlbnRTY3JvbGwgd29uJ3Qgd29yayBpbiBXZWJraXQuXG4gICAgICAgIHJvb3RFbGVtZW50LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGRlZmF1bHRTZWxlY3Rpb25cbiAgICB9KTtcbiAgfSwgW2RlZmF1bHRTZWxlY3Rpb24sIGVkaXRvcl0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5BdXRvRm9jdXNQbHVnaW4gPSBBdXRvRm9jdXNQbHVnaW47XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalAutoFocusPlugin.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalAutoFocusPlugin =  true ? __webpack_require__(/*! ./LexicalAutoFocusPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.dev.js\") : 0\nmodule.exports = LexicalAutoFocusPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEF1dG9Gb2N1c1BsdWdpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLCtCQUErQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsMEdBQWlDLElBQUksQ0FBMkM7QUFDaEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQXV0b0ZvY3VzUGx1Z2luLmpzPzVmMDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxBdXRvRm9jdXNQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbEF1dG9Gb2N1c1BsdWdpbi5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbEF1dG9Gb2N1c1BsdWdpbi5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbEF1dG9Gb2N1c1BsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalAutoFocusPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalBlockWithAlignableContents.dev.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalBlockWithAlignableContents.dev.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar LexicalDecoratorBlockNode = __webpack_require__(/*! @lexical/react/LexicalDecoratorBlockNode */ \"(ssr)/./node_modules/@lexical/react/LexicalDecoratorBlockNode.js\");\nvar useLexicalNodeSelection = __webpack_require__(/*! @lexical/react/useLexicalNodeSelection */ \"(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction BlockWithAlignableContents({\n  children,\n  format,\n  nodeKey,\n  className\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection.useLexicalNodeSelection(nodeKey);\n  const ref = React.useRef(null);\n  const onDelete = React.useCallback(event => {\n    if (isSelected && lexical.$isNodeSelection(lexical.$getSelection())) {\n      event.preventDefault();\n      editor.update(() => {\n        const node = lexical.$getNodeByKey(nodeKey);\n        if (node === null) return;\n        lexical.$setSelection(node.selectPrevious());\n\n        if (lexical.$isDecoratorNode(node)) {\n          node.remove();\n        }\n      });\n    }\n\n    return false;\n  }, [editor, isSelected, nodeKey]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, formatType => {\n      if (isSelected) {\n        const selection = lexical.$getSelection();\n\n        if (lexical.$isNodeSelection(selection)) {\n          const node = lexical.$getNodeByKey(nodeKey);\n\n          if (LexicalDecoratorBlockNode.$isDecoratorBlockNode(node)) {\n            node.setFormat(formatType);\n          }\n        } else if (lexical.$isRangeSelection(selection)) {\n          const nodes = selection.getNodes();\n\n          for (const node of nodes) {\n            if (LexicalDecoratorBlockNode.$isDecoratorBlockNode(node)) {\n              node.setFormat(formatType);\n            } else {\n              const element = utils.$getNearestBlockElementAncestorOrThrow(node);\n              element.setFormat(formatType);\n            }\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.CLICK_COMMAND, event => {\n      if (event.target === ref.current) {\n        event.preventDefault();\n\n        if (!event.shiftKey) {\n          clearSelection();\n        }\n\n        setSelected(!isSelected);\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_DELETE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW));\n  }, [clearSelection, editor, isSelected, nodeKey, onDelete, setSelected]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: [className.base, isSelected ? className.focus : null].filter(Boolean).join(' '),\n    ref: ref,\n    style: {\n      textAlign: format ? format : undefined\n    }\n  }, children);\n}\n\nexports.BlockWithAlignableContents = BlockWithAlignableContents;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEJsb2NrV2l0aEFsaWduYWJsZUNvbnRlbnRzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsZ0NBQWdDLG1CQUFPLENBQUMsa0hBQTBDO0FBQ2xGLDhCQUE4QixtQkFBTyxDQUFDLDhHQUF3QztBQUM5RSxZQUFZLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyx3REFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQmxvY2tXaXRoQWxpZ25hYmxlQ29udGVudHMuZGV2LmpzP2I0OTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIExleGljYWxEZWNvcmF0b3JCbG9ja05vZGUgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsRGVjb3JhdG9yQmxvY2tOb2RlJyk7XG52YXIgdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24gPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsTm9kZVNlbGVjdGlvbicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQGxleGljYWwvdXRpbHMnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gQmxvY2tXaXRoQWxpZ25hYmxlQ29udGVudHMoe1xuICBjaGlsZHJlbixcbiAgZm9ybWF0LFxuICBub2RlS2V5LFxuICBjbGFzc05hbWVcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgW2lzU2VsZWN0ZWQsIHNldFNlbGVjdGVkLCBjbGVhclNlbGVjdGlvbl0gPSB1c2VMZXhpY2FsTm9kZVNlbGVjdGlvbi51c2VMZXhpY2FsTm9kZVNlbGVjdGlvbihub2RlS2V5KTtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBvbkRlbGV0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICBpZiAoaXNTZWxlY3RlZCAmJiBsZXhpY2FsLiRpc05vZGVTZWxlY3Rpb24obGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCkpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROb2RlQnlLZXkobm9kZUtleSk7XG4gICAgICAgIGlmIChub2RlID09PSBudWxsKSByZXR1cm47XG4gICAgICAgIGxleGljYWwuJHNldFNlbGVjdGlvbihub2RlLnNlbGVjdFByZXZpb3VzKCkpO1xuXG4gICAgICAgIGlmIChsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUobm9kZSkpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIFtlZGl0b3IsIGlzU2VsZWN0ZWQsIG5vZGVLZXldKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gdXRpbHMubWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuRk9STUFUX0VMRU1FTlRfQ09NTUFORCwgZm9ybWF0VHlwZSA9PiB7XG4gICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICBpZiAobGV4aWNhbC4kaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbGV4aWNhbC4kZ2V0Tm9kZUJ5S2V5KG5vZGVLZXkpO1xuXG4gICAgICAgICAgaWYgKExleGljYWxEZWNvcmF0b3JCbG9ja05vZGUuJGlzRGVjb3JhdG9yQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBub2RlLnNldEZvcm1hdChmb3JtYXRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcblxuICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgaWYgKExleGljYWxEZWNvcmF0b3JCbG9ja05vZGUuJGlzRGVjb3JhdG9yQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICAgIG5vZGUuc2V0Rm9ybWF0KGZvcm1hdFR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHV0aWxzLiRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93KG5vZGUpO1xuICAgICAgICAgICAgICBlbGVtZW50LnNldEZvcm1hdChmb3JtYXRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuQ0xJQ0tfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gcmVmLmN1cnJlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFNlbGVjdGVkKCFpc1NlbGVjdGVkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9ERUxFVEVfQ09NTUFORCwgb25EZWxldGUsIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCBvbkRlbGV0ZSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVykpO1xuICB9LCBbY2xlYXJTZWxlY3Rpb24sIGVkaXRvciwgaXNTZWxlY3RlZCwgbm9kZUtleSwgb25EZWxldGUsIHNldFNlbGVjdGVkXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBbY2xhc3NOYW1lLmJhc2UsIGlzU2VsZWN0ZWQgPyBjbGFzc05hbWUuZm9jdXMgOiBudWxsXS5maWx0ZXIoQm9vbGVhbikuam9pbignICcpLFxuICAgIHJlZjogcmVmLFxuICAgIHN0eWxlOiB7XG4gICAgICB0ZXh0QWxpZ246IGZvcm1hdCA/IGZvcm1hdCA6IHVuZGVmaW5lZFxuICAgIH1cbiAgfSwgY2hpbGRyZW4pO1xufVxuXG5leHBvcnRzLkJsb2NrV2l0aEFsaWduYWJsZUNvbnRlbnRzID0gQmxvY2tXaXRoQWxpZ25hYmxlQ29udGVudHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalBlockWithAlignableContents.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalBlockWithAlignableContents.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalBlockWithAlignableContents.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalBlockWithAlignableContents =  true ? __webpack_require__(/*! ./LexicalBlockWithAlignableContents.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalBlockWithAlignableContents.dev.js\") : 0\nmodule.exports = LexicalBlockWithAlignableContents;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEJsb2NrV2l0aEFsaWduYWJsZUNvbnRlbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osMENBQTBDLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxnSUFBNEMsSUFBSSxDQUFzRDtBQUNqTSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxCbG9ja1dpdGhBbGlnbmFibGVDb250ZW50cy5qcz83ZDY0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsQmxvY2tXaXRoQWxpZ25hYmxlQ29udGVudHMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbEJsb2NrV2l0aEFsaWduYWJsZUNvbnRlbnRzLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsQmxvY2tXaXRoQWxpZ25hYmxlQ29udGVudHMucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxCbG9ja1dpdGhBbGlnbmFibGVDb250ZW50czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalBlockWithAlignableContents.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalCharacterLimitPlugin.dev.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalCharacterLimitPlugin.dev.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar overflow = __webpack_require__(/*! @lexical/overflow */ \"(ssr)/./node_modules/@lexical/overflow/LexicalOverflow.js\");\nvar text = __webpack_require__(/*! @lexical/text */ \"(ssr)/./node_modules/@lexical/text/LexicalText.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useCharacterLimit(editor, maxCharacters, optional = Object.freeze({})) {\n  const {\n    strlen = input => input.length,\n    // UTF-16\n    remainingCharacters = () => {\n      return;\n    }\n  } = optional;\n  React.useEffect(() => {\n    if (!editor.hasNodes([overflow.OverflowNode])) {\n      {\n        throw Error(`useCharacterLimit: OverflowNode not registered on editor`);\n      }\n    }\n  }, [editor]);\n  React.useEffect(() => {\n    let text$1 = editor.getEditorState().read(text.$rootTextContent);\n    let lastComputedTextLength = 0;\n    return utils.mergeRegister(editor.registerTextContentListener(currentText => {\n      text$1 = currentText;\n    }), editor.registerUpdateListener(({\n      dirtyLeaves\n    }) => {\n      const isComposing = editor.isComposing();\n      const hasDirtyLeaves = dirtyLeaves.size > 0;\n\n      if (isComposing || !hasDirtyLeaves) {\n        return;\n      }\n\n      const textLength = strlen(text$1);\n      const textLengthAboveThreshold = textLength > maxCharacters || lastComputedTextLength !== null && lastComputedTextLength > maxCharacters;\n      const diff = maxCharacters - textLength;\n      remainingCharacters(diff);\n\n      if (lastComputedTextLength === null || textLengthAboveThreshold) {\n        const offset = findOffset(text$1, maxCharacters, strlen);\n        editor.update(() => {\n          $wrapOverflowedNodes(offset);\n        }, {\n          tag: 'history-merge'\n        });\n      }\n\n      lastComputedTextLength = textLength;\n    }));\n  }, [editor, maxCharacters, remainingCharacters, strlen]);\n}\n\nfunction findOffset(text, maxCharacters, strlen) {\n  // @ts-ignore This is due to be added in a later version of TS\n  const Segmenter = Intl.Segmenter;\n  let offsetUtf16 = 0;\n  let offset = 0;\n\n  if (typeof Segmenter === 'function') {\n    const segmenter = new Segmenter();\n    const graphemes = segmenter.segment(text);\n\n    for (const {\n      segment: grapheme\n    } of graphemes) {\n      const nextOffset = offset + strlen(grapheme);\n\n      if (nextOffset > maxCharacters) {\n        break;\n      }\n\n      offset = nextOffset;\n      offsetUtf16 += grapheme.length;\n    }\n  } else {\n    const codepoints = Array.from(text);\n    const codepointsLength = codepoints.length;\n\n    for (let i = 0; i < codepointsLength; i++) {\n      const codepoint = codepoints[i];\n      const nextOffset = offset + strlen(codepoint);\n\n      if (nextOffset > maxCharacters) {\n        break;\n      }\n\n      offset = nextOffset;\n      offsetUtf16 += codepoint.length;\n    }\n  }\n\n  return offsetUtf16;\n}\n\nfunction $wrapOverflowedNodes(offset) {\n  const dfsNodes = utils.$dfs();\n  const dfsNodesLength = dfsNodes.length;\n  let accumulatedLength = 0;\n\n  for (let i = 0; i < dfsNodesLength; i += 1) {\n    const {\n      node\n    } = dfsNodes[i];\n\n    if (overflow.$isOverflowNode(node)) {\n      const previousLength = accumulatedLength;\n      const nextLength = accumulatedLength + node.getTextContentSize();\n\n      if (nextLength <= offset) {\n        const parent = node.getParent();\n        const previousSibling = node.getPreviousSibling();\n        const nextSibling = node.getNextSibling();\n        $unwrapNode(node);\n        const selection = lexical.$getSelection(); // Restore selection when the overflow children are removed\n\n        if (lexical.$isRangeSelection(selection) && (!selection.anchor.getNode().isAttached() || !selection.focus.getNode().isAttached())) {\n          if (lexical.$isTextNode(previousSibling)) {\n            previousSibling.select();\n          } else if (lexical.$isTextNode(nextSibling)) {\n            nextSibling.select();\n          } else if (parent !== null) {\n            parent.select();\n          }\n        }\n      } else if (previousLength < offset) {\n        const descendant = node.getFirstDescendant();\n        const descendantLength = descendant !== null ? descendant.getTextContentSize() : 0;\n        const previousPlusDescendantLength = previousLength + descendantLength; // For simple text we can redimension the overflow into a smaller and more accurate\n        // container\n\n        const firstDescendantIsSimpleText = lexical.$isTextNode(descendant) && descendant.isSimpleText();\n        const firstDescendantDoesNotOverflow = previousPlusDescendantLength <= offset;\n\n        if (firstDescendantIsSimpleText || firstDescendantDoesNotOverflow) {\n          $unwrapNode(node);\n        }\n      }\n    } else if (lexical.$isLeafNode(node)) {\n      const previousAccumulatedLength = accumulatedLength;\n      accumulatedLength += node.getTextContentSize();\n\n      if (accumulatedLength > offset && !overflow.$isOverflowNode(node.getParent())) {\n        const previousSelection = lexical.$getSelection();\n        let overflowNode; // For simple text we can improve the limit accuracy by splitting the TextNode\n        // on the split point\n\n        if (previousAccumulatedLength < offset && lexical.$isTextNode(node) && node.isSimpleText()) {\n          const [, overflowedText] = node.splitText(offset - previousAccumulatedLength);\n          overflowNode = $wrapNode(overflowedText);\n        } else {\n          overflowNode = $wrapNode(node);\n        }\n\n        if (previousSelection !== null) {\n          lexical.$setSelection(previousSelection);\n        }\n\n        mergePrevious(overflowNode);\n      }\n    }\n  }\n}\n\nfunction $wrapNode(node) {\n  const overflowNode = overflow.$createOverflowNode();\n  node.insertBefore(overflowNode);\n  overflowNode.append(node);\n  return overflowNode;\n}\n\nfunction $unwrapNode(node) {\n  const children = node.getChildren();\n  const childrenLength = children.length;\n\n  for (let i = 0; i < childrenLength; i++) {\n    node.insertBefore(children[i]);\n  }\n\n  node.remove();\n  return childrenLength > 0 ? children[childrenLength - 1] : null;\n}\n\nfunction mergePrevious(overflowNode) {\n  const previousNode = overflowNode.getPreviousSibling();\n\n  if (!overflow.$isOverflowNode(previousNode)) {\n    return;\n  }\n\n  const firstChild = overflowNode.getFirstChild();\n  const previousNodeChildren = previousNode.getChildren();\n  const previousNodeChildrenLength = previousNodeChildren.length;\n\n  if (firstChild === null) {\n    overflowNode.append(...previousNodeChildren);\n  } else {\n    for (let i = 0; i < previousNodeChildrenLength; i++) {\n      firstChild.insertBefore(previousNodeChildren[i]);\n    }\n  }\n\n  const selection = lexical.$getSelection();\n\n  if (lexical.$isRangeSelection(selection)) {\n    const anchor = selection.anchor;\n    const anchorNode = anchor.getNode();\n    const focus = selection.focus;\n    const focusNode = anchor.getNode();\n\n    if (anchorNode.is(previousNode)) {\n      anchor.set(overflowNode.getKey(), anchor.offset, 'element');\n    } else if (anchorNode.is(overflowNode)) {\n      anchor.set(overflowNode.getKey(), previousNodeChildrenLength + anchor.offset, 'element');\n    }\n\n    if (focusNode.is(previousNode)) {\n      focus.set(overflowNode.getKey(), focus.offset, 'element');\n    } else if (focusNode.is(overflowNode)) {\n      focus.set(overflowNode.getKey(), previousNodeChildrenLength + focus.offset, 'element');\n    }\n  }\n\n  previousNode.remove();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CHARACTER_LIMIT = 5;\nlet textEncoderInstance = null;\n\nfunction textEncoder() {\n  if (window.TextEncoder === undefined) {\n    return null;\n  }\n\n  if (textEncoderInstance === null) {\n    textEncoderInstance = new window.TextEncoder();\n  }\n\n  return textEncoderInstance;\n}\n\nfunction utf8Length(text) {\n  const currentTextEncoder = textEncoder();\n\n  if (currentTextEncoder === null) {\n    // http://stackoverflow.com/a/5515960/210370\n    const m = encodeURIComponent(text).match(/%[89ABab]/g);\n    return text.length + (m ? m.length : 0);\n  }\n\n  return currentTextEncoder.encode(text).length;\n}\n\nfunction CharacterLimitPlugin({\n  charset = 'UTF-16',\n  maxLength = CHARACTER_LIMIT\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [remainingCharacters, setRemainingCharacters] = React.useState(maxLength);\n  const characterLimitProps = React.useMemo(() => ({\n    remainingCharacters: setRemainingCharacters,\n    strlen: text => {\n      if (charset === 'UTF-8') {\n        return utf8Length(text);\n      } else if (charset === 'UTF-16') {\n        return text.length;\n      } else {\n        throw new Error('Unrecognized charset');\n      }\n    }\n  }), [charset]);\n  useCharacterLimit(editor, maxLength, characterLimitProps);\n  return /*#__PURE__*/React.createElement(\"span\", {\n    className: `characters-limit ${remainingCharacters < 0 ? 'characters-limit-exceeded' : ''}`\n  }, remainingCharacters);\n}\n\nexports.CharacterLimitPlugin = CharacterLimitPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENoYXJhY3RlckxpbWl0UGx1Z2luLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsWUFBWSxtQkFBTyxDQUFDLHdHQUFPO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxvRkFBbUI7QUFDMUMsV0FBVyxtQkFBTyxDQUFDLHdFQUFlO0FBQ2xDLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLHdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1DQUFtQywyREFBMkQ7QUFDOUYsR0FBRztBQUNIOztBQUVBLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDaGFyYWN0ZXJMaW1pdFBsdWdpbi5kZXYuanM/NmFkZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIG92ZXJmbG93ID0gcmVxdWlyZSgnQGxleGljYWwvb3ZlcmZsb3cnKTtcbnZhciB0ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvdGV4dCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQGxleGljYWwvdXRpbHMnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiB1c2VDaGFyYWN0ZXJMaW1pdChlZGl0b3IsIG1heENoYXJhY3RlcnMsIG9wdGlvbmFsID0gT2JqZWN0LmZyZWV6ZSh7fSkpIHtcbiAgY29uc3Qge1xuICAgIHN0cmxlbiA9IGlucHV0ID0+IGlucHV0Lmxlbmd0aCxcbiAgICAvLyBVVEYtMTZcbiAgICByZW1haW5pbmdDaGFyYWN0ZXJzID0gKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSA9IG9wdGlvbmFsO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZWRpdG9yLmhhc05vZGVzKFtvdmVyZmxvdy5PdmVyZmxvd05vZGVdKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgdXNlQ2hhcmFjdGVyTGltaXQ6IE92ZXJmbG93Tm9kZSBub3QgcmVnaXN0ZXJlZCBvbiBlZGl0b3JgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlZGl0b3JdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgdGV4dCQxID0gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCh0ZXh0LiRyb290VGV4dENvbnRlbnQpO1xuICAgIGxldCBsYXN0Q29tcHV0ZWRUZXh0TGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdXRpbHMubWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJUZXh0Q29udGVudExpc3RlbmVyKGN1cnJlbnRUZXh0ID0+IHtcbiAgICAgIHRleHQkMSA9IGN1cnJlbnRUZXh0O1xuICAgIH0pLCBlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoe1xuICAgICAgZGlydHlMZWF2ZXNcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBpc0NvbXBvc2luZyA9IGVkaXRvci5pc0NvbXBvc2luZygpO1xuICAgICAgY29uc3QgaGFzRGlydHlMZWF2ZXMgPSBkaXJ0eUxlYXZlcy5zaXplID4gMDtcblxuICAgICAgaWYgKGlzQ29tcG9zaW5nIHx8ICFoYXNEaXJ0eUxlYXZlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRleHRMZW5ndGggPSBzdHJsZW4odGV4dCQxKTtcbiAgICAgIGNvbnN0IHRleHRMZW5ndGhBYm92ZVRocmVzaG9sZCA9IHRleHRMZW5ndGggPiBtYXhDaGFyYWN0ZXJzIHx8IGxhc3RDb21wdXRlZFRleHRMZW5ndGggIT09IG51bGwgJiYgbGFzdENvbXB1dGVkVGV4dExlbmd0aCA+IG1heENoYXJhY3RlcnM7XG4gICAgICBjb25zdCBkaWZmID0gbWF4Q2hhcmFjdGVycyAtIHRleHRMZW5ndGg7XG4gICAgICByZW1haW5pbmdDaGFyYWN0ZXJzKGRpZmYpO1xuXG4gICAgICBpZiAobGFzdENvbXB1dGVkVGV4dExlbmd0aCA9PT0gbnVsbCB8fCB0ZXh0TGVuZ3RoQWJvdmVUaHJlc2hvbGQpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZmluZE9mZnNldCh0ZXh0JDEsIG1heENoYXJhY3RlcnMsIHN0cmxlbik7XG4gICAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICR3cmFwT3ZlcmZsb3dlZE5vZGVzKG9mZnNldCk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0YWc6ICdoaXN0b3J5LW1lcmdlJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgbGFzdENvbXB1dGVkVGV4dExlbmd0aCA9IHRleHRMZW5ndGg7XG4gICAgfSkpO1xuICB9LCBbZWRpdG9yLCBtYXhDaGFyYWN0ZXJzLCByZW1haW5pbmdDaGFyYWN0ZXJzLCBzdHJsZW5dKTtcbn1cblxuZnVuY3Rpb24gZmluZE9mZnNldCh0ZXh0LCBtYXhDaGFyYWN0ZXJzLCBzdHJsZW4pIHtcbiAgLy8gQHRzLWlnbm9yZSBUaGlzIGlzIGR1ZSB0byBiZSBhZGRlZCBpbiBhIGxhdGVyIHZlcnNpb24gb2YgVFNcbiAgY29uc3QgU2VnbWVudGVyID0gSW50bC5TZWdtZW50ZXI7XG4gIGxldCBvZmZzZXRVdGYxNiA9IDA7XG4gIGxldCBvZmZzZXQgPSAwO1xuXG4gIGlmICh0eXBlb2YgU2VnbWVudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3Qgc2VnbWVudGVyID0gbmV3IFNlZ21lbnRlcigpO1xuICAgIGNvbnN0IGdyYXBoZW1lcyA9IHNlZ21lbnRlci5zZWdtZW50KHRleHQpO1xuXG4gICAgZm9yIChjb25zdCB7XG4gICAgICBzZWdtZW50OiBncmFwaGVtZVxuICAgIH0gb2YgZ3JhcGhlbWVzKSB7XG4gICAgICBjb25zdCBuZXh0T2Zmc2V0ID0gb2Zmc2V0ICsgc3RybGVuKGdyYXBoZW1lKTtcblxuICAgICAgaWYgKG5leHRPZmZzZXQgPiBtYXhDaGFyYWN0ZXJzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQgPSBuZXh0T2Zmc2V0O1xuICAgICAgb2Zmc2V0VXRmMTYgKz0gZ3JhcGhlbWUubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb2RlcG9pbnRzID0gQXJyYXkuZnJvbSh0ZXh0KTtcbiAgICBjb25zdCBjb2RlcG9pbnRzTGVuZ3RoID0gY29kZXBvaW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVwb2ludHNMZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY29kZXBvaW50ID0gY29kZXBvaW50c1tpXTtcbiAgICAgIGNvbnN0IG5leHRPZmZzZXQgPSBvZmZzZXQgKyBzdHJsZW4oY29kZXBvaW50KTtcblxuICAgICAgaWYgKG5leHRPZmZzZXQgPiBtYXhDaGFyYWN0ZXJzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQgPSBuZXh0T2Zmc2V0O1xuICAgICAgb2Zmc2V0VXRmMTYgKz0gY29kZXBvaW50Lmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0VXRmMTY7XG59XG5cbmZ1bmN0aW9uICR3cmFwT3ZlcmZsb3dlZE5vZGVzKG9mZnNldCkge1xuICBjb25zdCBkZnNOb2RlcyA9IHV0aWxzLiRkZnMoKTtcbiAgY29uc3QgZGZzTm9kZXNMZW5ndGggPSBkZnNOb2Rlcy5sZW5ndGg7XG4gIGxldCBhY2N1bXVsYXRlZExlbmd0aCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZnNOb2Rlc0xlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3Qge1xuICAgICAgbm9kZVxuICAgIH0gPSBkZnNOb2Rlc1tpXTtcblxuICAgIGlmIChvdmVyZmxvdy4kaXNPdmVyZmxvd05vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzTGVuZ3RoID0gYWNjdW11bGF0ZWRMZW5ndGg7XG4gICAgICBjb25zdCBuZXh0TGVuZ3RoID0gYWNjdW11bGF0ZWRMZW5ndGggKyBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuXG4gICAgICBpZiAobmV4dExlbmd0aCA8PSBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgICR1bndyYXBOb2RlKG5vZGUpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTsgLy8gUmVzdG9yZSBzZWxlY3Rpb24gd2hlbiB0aGUgb3ZlcmZsb3cgY2hpbGRyZW4gYXJlIHJlbW92ZWRcblxuICAgICAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmICghc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkuaXNBdHRhY2hlZCgpIHx8ICFzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpLmlzQXR0YWNoZWQoKSkpIHtcbiAgICAgICAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShwcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICAgICAgICBwcmV2aW91c1NpYmxpbmcuc2VsZWN0KCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgICAgICAgbmV4dFNpYmxpbmcuc2VsZWN0KCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmVudC5zZWxlY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNMZW5ndGggPCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgZGVzY2VuZGFudCA9IG5vZGUuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gICAgICAgIGNvbnN0IGRlc2NlbmRhbnRMZW5ndGggPSBkZXNjZW5kYW50ICE9PSBudWxsID8gZGVzY2VuZGFudC5nZXRUZXh0Q29udGVudFNpemUoKSA6IDA7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzUGx1c0Rlc2NlbmRhbnRMZW5ndGggPSBwcmV2aW91c0xlbmd0aCArIGRlc2NlbmRhbnRMZW5ndGg7IC8vIEZvciBzaW1wbGUgdGV4dCB3ZSBjYW4gcmVkaW1lbnNpb24gdGhlIG92ZXJmbG93IGludG8gYSBzbWFsbGVyIGFuZCBtb3JlIGFjY3VyYXRlXG4gICAgICAgIC8vIGNvbnRhaW5lclxuXG4gICAgICAgIGNvbnN0IGZpcnN0RGVzY2VuZGFudElzU2ltcGxlVGV4dCA9IGxleGljYWwuJGlzVGV4dE5vZGUoZGVzY2VuZGFudCkgJiYgZGVzY2VuZGFudC5pc1NpbXBsZVRleHQoKTtcbiAgICAgICAgY29uc3QgZmlyc3REZXNjZW5kYW50RG9lc05vdE92ZXJmbG93ID0gcHJldmlvdXNQbHVzRGVzY2VuZGFudExlbmd0aCA8PSBvZmZzZXQ7XG5cbiAgICAgICAgaWYgKGZpcnN0RGVzY2VuZGFudElzU2ltcGxlVGV4dCB8fCBmaXJzdERlc2NlbmRhbnREb2VzTm90T3ZlcmZsb3cpIHtcbiAgICAgICAgICAkdW53cmFwTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNMZWFmTm9kZShub2RlKSkge1xuICAgICAgY29uc3QgcHJldmlvdXNBY2N1bXVsYXRlZExlbmd0aCA9IGFjY3VtdWxhdGVkTGVuZ3RoO1xuICAgICAgYWNjdW11bGF0ZWRMZW5ndGggKz0gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcblxuICAgICAgaWYgKGFjY3VtdWxhdGVkTGVuZ3RoID4gb2Zmc2V0ICYmICFvdmVyZmxvdy4kaXNPdmVyZmxvd05vZGUobm9kZS5nZXRQYXJlbnQoKSkpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNTZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IG92ZXJmbG93Tm9kZTsgLy8gRm9yIHNpbXBsZSB0ZXh0IHdlIGNhbiBpbXByb3ZlIHRoZSBsaW1pdCBhY2N1cmFjeSBieSBzcGxpdHRpbmcgdGhlIFRleHROb2RlXG4gICAgICAgIC8vIG9uIHRoZSBzcGxpdCBwb2ludFxuXG4gICAgICAgIGlmIChwcmV2aW91c0FjY3VtdWxhdGVkTGVuZ3RoIDwgb2Zmc2V0ICYmIGxleGljYWwuJGlzVGV4dE5vZGUobm9kZSkgJiYgbm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgICAgIGNvbnN0IFssIG92ZXJmbG93ZWRUZXh0XSA9IG5vZGUuc3BsaXRUZXh0KG9mZnNldCAtIHByZXZpb3VzQWNjdW11bGF0ZWRMZW5ndGgpO1xuICAgICAgICAgIG92ZXJmbG93Tm9kZSA9ICR3cmFwTm9kZShvdmVyZmxvd2VkVGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3ZlcmZsb3dOb2RlID0gJHdyYXBOb2RlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZpb3VzU2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgbGV4aWNhbC4kc2V0U2VsZWN0aW9uKHByZXZpb3VzU2VsZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1lcmdlUHJldmlvdXMob3ZlcmZsb3dOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gJHdyYXBOb2RlKG5vZGUpIHtcbiAgY29uc3Qgb3ZlcmZsb3dOb2RlID0gb3ZlcmZsb3cuJGNyZWF0ZU92ZXJmbG93Tm9kZSgpO1xuICBub2RlLmluc2VydEJlZm9yZShvdmVyZmxvd05vZGUpO1xuICBvdmVyZmxvd05vZGUuYXBwZW5kKG5vZGUpO1xuICByZXR1cm4gb3ZlcmZsb3dOb2RlO1xufVxuXG5mdW5jdGlvbiAkdW53cmFwTm9kZShub2RlKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICBub2RlLmluc2VydEJlZm9yZShjaGlsZHJlbltpXSk7XG4gIH1cblxuICBub2RlLnJlbW92ZSgpO1xuICByZXR1cm4gY2hpbGRyZW5MZW5ndGggPiAwID8gY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJldmlvdXMob3ZlcmZsb3dOb2RlKSB7XG4gIGNvbnN0IHByZXZpb3VzTm9kZSA9IG92ZXJmbG93Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICBpZiAoIW92ZXJmbG93LiRpc092ZXJmbG93Tm9kZShwcmV2aW91c05vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZmlyc3RDaGlsZCA9IG92ZXJmbG93Tm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gIGNvbnN0IHByZXZpb3VzTm9kZUNoaWxkcmVuID0gcHJldmlvdXNOb2RlLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IHByZXZpb3VzTm9kZUNoaWxkcmVuTGVuZ3RoID0gcHJldmlvdXNOb2RlQ2hpbGRyZW4ubGVuZ3RoO1xuXG4gIGlmIChmaXJzdENoaWxkID09PSBudWxsKSB7XG4gICAgb3ZlcmZsb3dOb2RlLmFwcGVuZCguLi5wcmV2aW91c05vZGVDaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2aW91c05vZGVDaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShwcmV2aW91c05vZGVDaGlsZHJlbltpXSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcblxuICAgIGlmIChhbmNob3JOb2RlLmlzKHByZXZpb3VzTm9kZSkpIHtcbiAgICAgIGFuY2hvci5zZXQob3ZlcmZsb3dOb2RlLmdldEtleSgpLCBhbmNob3Iub2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgIH0gZWxzZSBpZiAoYW5jaG9yTm9kZS5pcyhvdmVyZmxvd05vZGUpKSB7XG4gICAgICBhbmNob3Iuc2V0KG92ZXJmbG93Tm9kZS5nZXRLZXkoKSwgcHJldmlvdXNOb2RlQ2hpbGRyZW5MZW5ndGggKyBhbmNob3Iub2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb2N1c05vZGUuaXMocHJldmlvdXNOb2RlKSkge1xuICAgICAgZm9jdXMuc2V0KG92ZXJmbG93Tm9kZS5nZXRLZXkoKSwgZm9jdXMub2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgIH0gZWxzZSBpZiAoZm9jdXNOb2RlLmlzKG92ZXJmbG93Tm9kZSkpIHtcbiAgICAgIGZvY3VzLnNldChvdmVyZmxvd05vZGUuZ2V0S2V5KCksIHByZXZpb3VzTm9kZUNoaWxkcmVuTGVuZ3RoICsgZm9jdXMub2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIHByZXZpb3VzTm9kZS5yZW1vdmUoKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ0hBUkFDVEVSX0xJTUlUID0gNTtcbmxldCB0ZXh0RW5jb2Rlckluc3RhbmNlID0gbnVsbDtcblxuZnVuY3Rpb24gdGV4dEVuY29kZXIoKSB7XG4gIGlmICh3aW5kb3cuVGV4dEVuY29kZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHRleHRFbmNvZGVySW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICB0ZXh0RW5jb2Rlckluc3RhbmNlID0gbmV3IHdpbmRvdy5UZXh0RW5jb2RlcigpO1xuICB9XG5cbiAgcmV0dXJuIHRleHRFbmNvZGVySW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHV0ZjhMZW5ndGgodGV4dCkge1xuICBjb25zdCBjdXJyZW50VGV4dEVuY29kZXIgPSB0ZXh0RW5jb2RlcigpO1xuXG4gIGlmIChjdXJyZW50VGV4dEVuY29kZXIgPT09IG51bGwpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NTE1OTYwLzIxMDM3MFxuICAgIGNvbnN0IG0gPSBlbmNvZGVVUklDb21wb25lbnQodGV4dCkubWF0Y2goLyVbODlBQmFiXS9nKTtcbiAgICByZXR1cm4gdGV4dC5sZW5ndGggKyAobSA/IG0ubGVuZ3RoIDogMCk7XG4gIH1cblxuICByZXR1cm4gY3VycmVudFRleHRFbmNvZGVyLmVuY29kZSh0ZXh0KS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIENoYXJhY3RlckxpbWl0UGx1Z2luKHtcbiAgY2hhcnNldCA9ICdVVEYtMTYnLFxuICBtYXhMZW5ndGggPSBDSEFSQUNURVJfTElNSVRcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgW3JlbWFpbmluZ0NoYXJhY3RlcnMsIHNldFJlbWFpbmluZ0NoYXJhY3RlcnNdID0gUmVhY3QudXNlU3RhdGUobWF4TGVuZ3RoKTtcbiAgY29uc3QgY2hhcmFjdGVyTGltaXRQcm9wcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByZW1haW5pbmdDaGFyYWN0ZXJzOiBzZXRSZW1haW5pbmdDaGFyYWN0ZXJzLFxuICAgIHN0cmxlbjogdGV4dCA9PiB7XG4gICAgICBpZiAoY2hhcnNldCA9PT0gJ1VURi04Jykge1xuICAgICAgICByZXR1cm4gdXRmOExlbmd0aCh0ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhcnNldCA9PT0gJ1VURi0xNicpIHtcbiAgICAgICAgcmV0dXJuIHRleHQubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgY2hhcnNldCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIFtjaGFyc2V0XSk7XG4gIHVzZUNoYXJhY3RlckxpbWl0KGVkaXRvciwgbWF4TGVuZ3RoLCBjaGFyYWN0ZXJMaW1pdFByb3BzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgY2xhc3NOYW1lOiBgY2hhcmFjdGVycy1saW1pdCAke3JlbWFpbmluZ0NoYXJhY3RlcnMgPCAwID8gJ2NoYXJhY3RlcnMtbGltaXQtZXhjZWVkZWQnIDogJyd9YFxuICB9LCByZW1haW5pbmdDaGFyYWN0ZXJzKTtcbn1cblxuZXhwb3J0cy5DaGFyYWN0ZXJMaW1pdFBsdWdpbiA9IENoYXJhY3RlckxpbWl0UGx1Z2luO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalCharacterLimitPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalCharacterLimitPlugin.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalCharacterLimitPlugin.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalCharacterLimitPlugin =  true ? __webpack_require__(/*! ./LexicalCharacterLimitPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalCharacterLimitPlugin.dev.js\") : 0\nmodule.exports = LexicalCharacterLimitPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENoYXJhY3RlckxpbWl0UGx1Z2luLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osb0NBQW9DLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxvSEFBc0MsSUFBSSxDQUFnRDtBQUMvSyIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDaGFyYWN0ZXJMaW1pdFBsdWdpbi5qcz85NTY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsQ2hhcmFjdGVyTGltaXRQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbENoYXJhY3RlckxpbWl0UGx1Z2luLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsQ2hhcmFjdGVyTGltaXRQbHVnaW4ucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxDaGFyYWN0ZXJMaW1pdFBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalCharacterLimitPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalCheckListPlugin.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalCheckListPlugin.dev.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar list = __webpack_require__(/*! @lexical/list */ \"(ssr)/./node_modules/@lexical/list/LexicalList.js\");\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction CheckListPlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(list.INSERT_CHECK_LIST_COMMAND, () => {\n      list.insertList(editor, 'check');\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => {\n      return handleArrownUpOrDown(event, editor, false);\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => {\n      return handleArrownUpOrDown(event, editor, true);\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, event => {\n      const activeItem = getActiveCheckListItem();\n\n      if (activeItem != null) {\n        const rootElement = editor.getRootElement();\n\n        if (rootElement != null) {\n          rootElement.focus();\n        }\n\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_SPACE_COMMAND, event => {\n      const activeItem = getActiveCheckListItem();\n\n      if (activeItem != null && editor.isEditable()) {\n        editor.update(() => {\n          const listItemNode = lexical.$getNearestNodeFromDOMNode(activeItem);\n\n          if (list.$isListItemNode(listItemNode)) {\n            event.preventDefault();\n            listItemNode.toggleChecked();\n          }\n        });\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => {\n      return editor.getEditorState().read(() => {\n        const selection = lexical.$getSelection();\n\n        if (lexical.$isRangeSelection(selection) && selection.isCollapsed()) {\n          const {\n            anchor\n          } = selection;\n          const isElement = anchor.type === 'element';\n\n          if (isElement || anchor.offset === 0) {\n            const anchorNode = anchor.getNode();\n            const elementNode = utils.$findMatchingParent(anchorNode, node => lexical.$isElementNode(node) && !node.isInline());\n\n            if (list.$isListItemNode(elementNode)) {\n              const parent = elementNode.getParent();\n\n              if (list.$isListNode(parent) && parent.getListType() === 'check' && (isElement || elementNode.getFirstDescendant() === anchorNode)) {\n                const domNode = editor.getElementByKey(elementNode.__key);\n\n                if (domNode != null && document.activeElement !== domNode) {\n                  domNode.focus();\n                  event.preventDefault();\n                  return true;\n                }\n              }\n            }\n          }\n        }\n\n        return false;\n      });\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerRootListener((rootElement, prevElement) => {\n      if (rootElement !== null) {\n        rootElement.addEventListener('click', handleClick);\n        rootElement.addEventListener('pointerdown', handlePointerDown);\n      }\n\n      if (prevElement !== null) {\n        prevElement.removeEventListener('click', handleClick);\n        prevElement.removeEventListener('pointerdown', handlePointerDown);\n      }\n    }));\n  });\n  return null;\n}\n\nfunction handleCheckItemEvent(event, callback) {\n  const target = event.target;\n\n  if (target === null || !utils.isHTMLElement(target)) {\n    return;\n  } // Ignore clicks on LI that have nested lists\n\n\n  const firstChild = target.firstChild;\n\n  if (firstChild != null && utils.isHTMLElement(firstChild) && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')) {\n    return;\n  }\n\n  const parentNode = target.parentNode; // @ts-ignore internal field\n\n  if (!parentNode || parentNode.__lexicalListType !== 'check') {\n    return;\n  }\n\n  const pageX = event.pageX;\n  const rect = target.getBoundingClientRect();\n\n  if (target.dir === 'rtl' ? pageX < rect.right && pageX > rect.right - 20 : pageX > rect.left && pageX < rect.left + 20) {\n    callback();\n  }\n}\n\nfunction handleClick(event) {\n  handleCheckItemEvent(event, () => {\n    const domNode = event.target;\n    const editor = findEditor(domNode);\n\n    if (editor != null && editor.isEditable()) {\n      editor.update(() => {\n        if (event.target) {\n          const node = lexical.$getNearestNodeFromDOMNode(domNode);\n\n          if (list.$isListItemNode(node)) {\n            domNode.focus();\n            node.toggleChecked();\n          }\n        }\n      });\n    }\n  });\n}\n\nfunction handlePointerDown(event) {\n  handleCheckItemEvent(event, () => {\n    // Prevents caret moving when clicking on check mark\n    event.preventDefault();\n  });\n}\n\nfunction findEditor(target) {\n  let node = target;\n\n  while (node) {\n    // @ts-ignore internal field\n    if (node.__lexicalEditor) {\n      // @ts-ignore internal field\n      return node.__lexicalEditor;\n    }\n\n    node = node.parentNode;\n  }\n\n  return null;\n}\n\nfunction getActiveCheckListItem() {\n  const activeElement = document.activeElement;\n  return activeElement != null && activeElement.tagName === 'LI' && activeElement.parentNode != null && // @ts-ignore internal field\n  activeElement.parentNode.__lexicalListType === 'check' ? activeElement : null;\n}\n\nfunction findCheckListItemSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  let parent = node; // Going up in a tree to get non-null sibling\n\n  while (sibling == null && list.$isListItemNode(parent)) {\n    // Get li -> parent ul/ol -> parent li\n    parent = parent.getParentOrThrow().getParent();\n\n    if (parent != null) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  } // Going down in a tree to get first non-nested list item\n\n\n  while (list.$isListItemNode(sibling)) {\n    const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();\n\n    if (!list.$isListNode(firstChild)) {\n      return sibling;\n    }\n\n    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();\n  }\n\n  return null;\n}\n\nfunction handleArrownUpOrDown(event, editor, backward) {\n  const activeItem = getActiveCheckListItem();\n\n  if (activeItem != null) {\n    editor.update(() => {\n      const listItem = lexical.$getNearestNodeFromDOMNode(activeItem);\n\n      if (!list.$isListItemNode(listItem)) {\n        return;\n      }\n\n      const nextListItem = findCheckListItemSibling(listItem, backward);\n\n      if (nextListItem != null) {\n        nextListItem.selectStart();\n        const dom = editor.getElementByKey(nextListItem.__key);\n\n        if (dom != null) {\n          event.preventDefault();\n          setTimeout(() => {\n            dom.focus();\n          }, 0);\n        }\n      }\n    });\n  }\n\n  return false;\n}\n\nexports.CheckListPlugin = CheckListPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENoZWNrTGlzdFBsdWdpbi5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLHdFQUFlO0FBQ2xDLDZCQUE2QixtQkFBTyxDQUFDLDRHQUF1QztBQUM1RSxZQUFZLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyx3REFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ2hlY2tMaXN0UGx1Z2luLmRldi5qcz9kOGI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGlzdCA9IHJlcXVpcmUoJ0BsZXhpY2FsL2xpc3QnKTtcbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQGxleGljYWwvdXRpbHMnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gQ2hlY2tMaXN0UGx1Z2luKCkge1xuICBjb25zdCBbZWRpdG9yXSA9IExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICByZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiB1dGlscy5tZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGlzdC5JTlNFUlRfQ0hFQ0tfTElTVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgICBsaXN0Lmluc2VydExpc3QoZWRpdG9yLCAnY2hlY2snKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgICAgcmV0dXJuIGhhbmRsZUFycm93blVwT3JEb3duKGV2ZW50LCBlZGl0b3IsIGZhbHNlKTtcbiAgICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9BUlJPV19VUF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgICByZXR1cm4gaGFuZGxlQXJyb3duVXBPckRvd24oZXZlbnQsIGVkaXRvciwgdHJ1ZSk7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfRVNDQVBFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZUl0ZW0gPSBnZXRBY3RpdmVDaGVja0xpc3RJdGVtKCk7XG5cbiAgICAgIGlmIChhY3RpdmVJdGVtICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcblxuICAgICAgICBpZiAocm9vdEVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHJvb3RFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX1NQQUNFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZUl0ZW0gPSBnZXRBY3RpdmVDaGVja0xpc3RJdGVtKCk7XG5cbiAgICAgIGlmIChhY3RpdmVJdGVtICE9IG51bGwgJiYgZWRpdG9yLmlzRWRpdGFibGUoKSkge1xuICAgICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBsaXN0SXRlbU5vZGUgPSBsZXhpY2FsLiRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGFjdGl2ZUl0ZW0pO1xuXG4gICAgICAgICAgaWYgKGxpc3QuJGlzTGlzdEl0ZW1Ob2RlKGxpc3RJdGVtTm9kZSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBsaXN0SXRlbU5vZGUudG9nZ2xlQ2hlY2tlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQVJST1dfTEVGVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgICByZXR1cm4gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBhbmNob3JcbiAgICAgICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgIGNvbnN0IGlzRWxlbWVudCA9IGFuY2hvci50eXBlID09PSAnZWxlbWVudCc7XG5cbiAgICAgICAgICBpZiAoaXNFbGVtZW50IHx8IGFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvck5vZGUsIG5vZGUgPT4gbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhbm9kZS5pc0lubGluZSgpKTtcblxuICAgICAgICAgICAgaWYgKGxpc3QuJGlzTGlzdEl0ZW1Ob2RlKGVsZW1lbnROb2RlKSkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50Tm9kZS5nZXRQYXJlbnQoKTtcblxuICAgICAgICAgICAgICBpZiAobGlzdC4kaXNMaXN0Tm9kZShwYXJlbnQpICYmIHBhcmVudC5nZXRMaXN0VHlwZSgpID09PSAnY2hlY2snICYmIChpc0VsZW1lbnQgfHwgZWxlbWVudE5vZGUuZ2V0Rmlyc3REZXNjZW5kYW50KCkgPT09IGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9tTm9kZSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZWxlbWVudE5vZGUuX19rZXkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRvbU5vZGUgIT0gbnVsbCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICBkb21Ob2RlLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlclJvb3RMaXN0ZW5lcigocm9vdEVsZW1lbnQsIHByZXZFbGVtZW50KSA9PiB7XG4gICAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgcm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldkVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgcHJldkVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICAgIHByZXZFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVDaGVja0l0ZW1FdmVudChldmVudCwgY2FsbGJhY2spIHtcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG4gIGlmICh0YXJnZXQgPT09IG51bGwgfHwgIXV0aWxzLmlzSFRNTEVsZW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBJZ25vcmUgY2xpY2tzIG9uIExJIHRoYXQgaGF2ZSBuZXN0ZWQgbGlzdHNcblxuXG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSB0YXJnZXQuZmlyc3RDaGlsZDtcblxuICBpZiAoZmlyc3RDaGlsZCAhPSBudWxsICYmIHV0aWxzLmlzSFRNTEVsZW1lbnQoZmlyc3RDaGlsZCkgJiYgKGZpcnN0Q2hpbGQudGFnTmFtZSA9PT0gJ1VMJyB8fCBmaXJzdENoaWxkLnRhZ05hbWUgPT09ICdPTCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGFyZW50Tm9kZSA9IHRhcmdldC5wYXJlbnROb2RlOyAvLyBAdHMtaWdub3JlIGludGVybmFsIGZpZWxkXG5cbiAgaWYgKCFwYXJlbnROb2RlIHx8IHBhcmVudE5vZGUuX19sZXhpY2FsTGlzdFR5cGUgIT09ICdjaGVjaycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBwYWdlWCA9IGV2ZW50LnBhZ2VYO1xuICBjb25zdCByZWN0ID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gIGlmICh0YXJnZXQuZGlyID09PSAncnRsJyA/IHBhZ2VYIDwgcmVjdC5yaWdodCAmJiBwYWdlWCA+IHJlY3QucmlnaHQgLSAyMCA6IHBhZ2VYID4gcmVjdC5sZWZ0ICYmIHBhZ2VYIDwgcmVjdC5sZWZ0ICsgMjApIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gIGhhbmRsZUNoZWNrSXRlbUV2ZW50KGV2ZW50LCAoKSA9PiB7XG4gICAgY29uc3QgZG9tTm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICBjb25zdCBlZGl0b3IgPSBmaW5kRWRpdG9yKGRvbU5vZGUpO1xuXG4gICAgaWYgKGVkaXRvciAhPSBudWxsICYmIGVkaXRvci5pc0VkaXRhYmxlKCkpIHtcbiAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IGxleGljYWwuJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZG9tTm9kZSk7XG5cbiAgICAgICAgICBpZiAobGlzdC4kaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGRvbU5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgIG5vZGUudG9nZ2xlQ2hlY2tlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgaGFuZGxlQ2hlY2tJdGVtRXZlbnQoZXZlbnQsICgpID0+IHtcbiAgICAvLyBQcmV2ZW50cyBjYXJldCBtb3Zpbmcgd2hlbiBjbGlja2luZyBvbiBjaGVjayBtYXJrXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRFZGl0b3IodGFyZ2V0KSB7XG4gIGxldCBub2RlID0gdGFyZ2V0O1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCBmaWVsZFxuICAgIGlmIChub2RlLl9fbGV4aWNhbEVkaXRvcikge1xuICAgICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCBmaWVsZFxuICAgICAgcmV0dXJuIG5vZGUuX19sZXhpY2FsRWRpdG9yO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlQ2hlY2tMaXN0SXRlbSgpIHtcbiAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIHJldHVybiBhY3RpdmVFbGVtZW50ICE9IG51bGwgJiYgYWN0aXZlRWxlbWVudC50YWdOYW1lID09PSAnTEknICYmIGFjdGl2ZUVsZW1lbnQucGFyZW50Tm9kZSAhPSBudWxsICYmIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgZmllbGRcbiAgYWN0aXZlRWxlbWVudC5wYXJlbnROb2RlLl9fbGV4aWNhbExpc3RUeXBlID09PSAnY2hlY2snID8gYWN0aXZlRWxlbWVudCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDaGVja0xpc3RJdGVtU2libGluZyhub2RlLCBiYWNrd2FyZCkge1xuICBsZXQgc2libGluZyA9IGJhY2t3YXJkID8gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgbGV0IHBhcmVudCA9IG5vZGU7IC8vIEdvaW5nIHVwIGluIGEgdHJlZSB0byBnZXQgbm9uLW51bGwgc2libGluZ1xuXG4gIHdoaWxlIChzaWJsaW5nID09IG51bGwgJiYgbGlzdC4kaXNMaXN0SXRlbU5vZGUocGFyZW50KSkge1xuICAgIC8vIEdldCBsaSAtPiBwYXJlbnQgdWwvb2wgLT4gcGFyZW50IGxpXG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudE9yVGhyb3coKS5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgc2libGluZyA9IGJhY2t3YXJkID8gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpIDogcGFyZW50LmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuICB9IC8vIEdvaW5nIGRvd24gaW4gYSB0cmVlIHRvIGdldCBmaXJzdCBub24tbmVzdGVkIGxpc3QgaXRlbVxuXG5cbiAgd2hpbGUgKGxpc3QuJGlzTGlzdEl0ZW1Ob2RlKHNpYmxpbmcpKSB7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IGJhY2t3YXJkID8gc2libGluZy5nZXRMYXN0Q2hpbGQoKSA6IHNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgaWYgKCFsaXN0LiRpc0xpc3ROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gc2libGluZztcbiAgICB9XG5cbiAgICBzaWJsaW5nID0gYmFja3dhcmQgPyBmaXJzdENoaWxkLmdldExhc3RDaGlsZCgpIDogZmlyc3RDaGlsZC5nZXRGaXJzdENoaWxkKCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQXJyb3duVXBPckRvd24oZXZlbnQsIGVkaXRvciwgYmFja3dhcmQpIHtcbiAgY29uc3QgYWN0aXZlSXRlbSA9IGdldEFjdGl2ZUNoZWNrTGlzdEl0ZW0oKTtcblxuICBpZiAoYWN0aXZlSXRlbSAhPSBudWxsKSB7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCBsaXN0SXRlbSA9IGxleGljYWwuJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoYWN0aXZlSXRlbSk7XG5cbiAgICAgIGlmICghbGlzdC4kaXNMaXN0SXRlbU5vZGUobGlzdEl0ZW0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV4dExpc3RJdGVtID0gZmluZENoZWNrTGlzdEl0ZW1TaWJsaW5nKGxpc3RJdGVtLCBiYWNrd2FyZCk7XG5cbiAgICAgIGlmIChuZXh0TGlzdEl0ZW0gIT0gbnVsbCkge1xuICAgICAgICBuZXh0TGlzdEl0ZW0uc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShuZXh0TGlzdEl0ZW0uX19rZXkpO1xuXG4gICAgICAgIGlmIChkb20gIT0gbnVsbCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkb20uZm9jdXMoKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnRzLkNoZWNrTGlzdFBsdWdpbiA9IENoZWNrTGlzdFBsdWdpbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalCheckListPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalCheckListPlugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalCheckListPlugin.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalCheckListPlugin =  true ? __webpack_require__(/*! ./LexicalCheckListPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalCheckListPlugin.dev.js\") : 0\nmodule.exports = LexicalCheckListPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENoZWNrTGlzdFBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLCtCQUErQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsMEdBQWlDLElBQUksQ0FBMkM7QUFDaEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ2hlY2tMaXN0UGx1Z2luLmpzPzE0NTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxDaGVja0xpc3RQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbENoZWNrTGlzdFBsdWdpbi5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbENoZWNrTGlzdFBsdWdpbi5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbENoZWNrTGlzdFBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalCheckListPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalClearEditorPlugin.dev.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalClearEditorPlugin.dev.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? react.useLayoutEffect : react.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction ClearEditorPlugin({\n  onClear\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useLayoutEffect(() => {\n    return editor.registerCommand(lexical.CLEAR_EDITOR_COMMAND, payload => {\n      editor.update(() => {\n        if (onClear == null) {\n          const root = lexical.$getRoot();\n          const selection = lexical.$getSelection();\n          const paragraph = lexical.$createParagraphNode();\n          root.clear();\n          root.append(paragraph);\n\n          if (selection !== null) {\n            paragraph.select();\n          }\n        } else {\n          onClear();\n        }\n      });\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR);\n  }, [editor, onClear]);\n  return null;\n}\n\nexports.ClearEditorPlugin = ClearEditorPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENsZWFyRWRpdG9yUGx1Z2luLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDbGVhckVkaXRvclBsdWdpbi5kZXYuanM/ZDRjMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgdXNlTGF5b3V0RWZmZWN0SW1wbCA9IENBTl9VU0VfRE9NID8gcmVhY3QudXNlTGF5b3V0RWZmZWN0IDogcmVhY3QudXNlRWZmZWN0O1xudmFyIHVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdEltcGw7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIENsZWFyRWRpdG9yUGx1Z2luKHtcbiAgb25DbGVhclxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuQ0xFQVJfRURJVE9SX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGlmIChvbkNsZWFyID09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCByb290ID0gbGV4aWNhbC4kZ2V0Um9vdCgpO1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuICAgICAgICAgIGNvbnN0IHBhcmFncmFwaCA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgICByb290LmNsZWFyKCk7XG4gICAgICAgICAgcm9vdC5hcHBlbmQocGFyYWdyYXBoKTtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmFncmFwaC5zZWxlY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb25DbGVhcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpO1xuICB9LCBbZWRpdG9yLCBvbkNsZWFyXSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLkNsZWFyRWRpdG9yUGx1Z2luID0gQ2xlYXJFZGl0b3JQbHVnaW47XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalClearEditorPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalClearEditorPlugin.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalClearEditorPlugin.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalClearEditorPlugin =  true ? __webpack_require__(/*! ./LexicalClearEditorPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalClearEditorPlugin.dev.js\") : 0\nmodule.exports = LexicalClearEditorPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENsZWFyRWRpdG9yUGx1Z2luLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osaUNBQWlDLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyw4R0FBbUMsSUFBSSxDQUE2QztBQUN0SyIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDbGVhckVkaXRvclBsdWdpbi5qcz81YTA0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsQ2xlYXJFZGl0b3JQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbENsZWFyRWRpdG9yUGx1Z2luLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsQ2xlYXJFZGl0b3JQbHVnaW4ucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxDbGVhckVkaXRvclBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalClearEditorPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.dev.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalCollaborationContext.dev.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst entries = [['Cat', 'rgb(125, 50, 0)'], ['Dog', 'rgb(100, 0, 0)'], ['Rabbit', 'rgb(150, 0, 0)'], ['Frog', 'rgb(200, 0, 0)'], ['Fox', 'rgb(200, 75, 0)'], ['Hedgehog', 'rgb(0, 75, 0)'], ['Pigeon', 'rgb(0, 125, 0)'], ['Squirrel', 'rgb(75, 100, 0)'], ['Bear', 'rgb(125, 100, 0)'], ['Tiger', 'rgb(0, 0, 150)'], ['Leopard', 'rgb(0, 0, 200)'], ['Zebra', 'rgb(0, 0, 250)'], ['Wolf', 'rgb(0, 100, 150)'], ['Owl', 'rgb(0, 100, 100)'], ['Gull', 'rgb(100, 0, 100)'], ['Squid', 'rgb(150, 0, 150)']];\nconst randomEntry = entries[Math.floor(Math.random() * entries.length)];\nconst CollaborationContext = /*#__PURE__*/react.createContext({\n  clientID: 0,\n  color: randomEntry[1],\n  isCollabActive: false,\n  name: randomEntry[0],\n  yjsDocMap: new Map()\n});\nfunction useCollaborationContext(username, color) {\n  const collabContext = react.useContext(CollaborationContext);\n\n  if (username != null) {\n    collabContext.name = username;\n  }\n\n  if (color != null) {\n    collabContext.color = color;\n  }\n\n  return collabContext;\n}\n\nexports.CollaborationContext = CollaborationContext;\nexports.useCollaborationContext = useCollaborationContext;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbGxhYm9yYXRpb25Db250ZXh0LmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbGxhYm9yYXRpb25Db250ZXh0LmRldi5qcz80NzBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBlbnRyaWVzID0gW1snQ2F0JywgJ3JnYigxMjUsIDUwLCAwKSddLCBbJ0RvZycsICdyZ2IoMTAwLCAwLCAwKSddLCBbJ1JhYmJpdCcsICdyZ2IoMTUwLCAwLCAwKSddLCBbJ0Zyb2cnLCAncmdiKDIwMCwgMCwgMCknXSwgWydGb3gnLCAncmdiKDIwMCwgNzUsIDApJ10sIFsnSGVkZ2Vob2cnLCAncmdiKDAsIDc1LCAwKSddLCBbJ1BpZ2VvbicsICdyZ2IoMCwgMTI1LCAwKSddLCBbJ1NxdWlycmVsJywgJ3JnYig3NSwgMTAwLCAwKSddLCBbJ0JlYXInLCAncmdiKDEyNSwgMTAwLCAwKSddLCBbJ1RpZ2VyJywgJ3JnYigwLCAwLCAxNTApJ10sIFsnTGVvcGFyZCcsICdyZ2IoMCwgMCwgMjAwKSddLCBbJ1plYnJhJywgJ3JnYigwLCAwLCAyNTApJ10sIFsnV29sZicsICdyZ2IoMCwgMTAwLCAxNTApJ10sIFsnT3dsJywgJ3JnYigwLCAxMDAsIDEwMCknXSwgWydHdWxsJywgJ3JnYigxMDAsIDAsIDEwMCknXSwgWydTcXVpZCcsICdyZ2IoMTUwLCAwLCAxNTApJ11dO1xuY29uc3QgcmFuZG9tRW50cnkgPSBlbnRyaWVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGVudHJpZXMubGVuZ3RoKV07XG5jb25zdCBDb2xsYWJvcmF0aW9uQ29udGV4dCA9IC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgY2xpZW50SUQ6IDAsXG4gIGNvbG9yOiByYW5kb21FbnRyeVsxXSxcbiAgaXNDb2xsYWJBY3RpdmU6IGZhbHNlLFxuICBuYW1lOiByYW5kb21FbnRyeVswXSxcbiAgeWpzRG9jTWFwOiBuZXcgTWFwKClcbn0pO1xuZnVuY3Rpb24gdXNlQ29sbGFib3JhdGlvbkNvbnRleHQodXNlcm5hbWUsIGNvbG9yKSB7XG4gIGNvbnN0IGNvbGxhYkNvbnRleHQgPSByZWFjdC51c2VDb250ZXh0KENvbGxhYm9yYXRpb25Db250ZXh0KTtcblxuICBpZiAodXNlcm5hbWUgIT0gbnVsbCkge1xuICAgIGNvbGxhYkNvbnRleHQubmFtZSA9IHVzZXJuYW1lO1xuICB9XG5cbiAgaWYgKGNvbG9yICE9IG51bGwpIHtcbiAgICBjb2xsYWJDb250ZXh0LmNvbG9yID0gY29sb3I7XG4gIH1cblxuICByZXR1cm4gY29sbGFiQ29udGV4dDtcbn1cblxuZXhwb3J0cy5Db2xsYWJvcmF0aW9uQ29udGV4dCA9IENvbGxhYm9yYXRpb25Db250ZXh0O1xuZXhwb3J0cy51c2VDb2xsYWJvcmF0aW9uQ29udGV4dCA9IHVzZUNvbGxhYm9yYXRpb25Db250ZXh0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalCollaborationContext.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalCollaborationContext =  true ? __webpack_require__(/*! ./LexicalCollaborationContext.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.dev.js\") : 0\nmodule.exports = LexicalCollaborationContext;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbGxhYm9yYXRpb25Db250ZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osb0NBQW9DLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxvSEFBc0MsSUFBSSxDQUFnRDtBQUMvSyIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb2xsYWJvcmF0aW9uQ29udGV4dC5qcz9jMWViIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsQ29sbGFib3JhdGlvbkNvbnRleHQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbENvbGxhYm9yYXRpb25Db250ZXh0LmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsQ29sbGFib3JhdGlvbkNvbnRleHQucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxDb2xsYWJvcmF0aW9uQ29udGV4dDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalComposer.dev.js":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposer.dev.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst HISTORY_MERGE_OPTIONS = {\n  tag: 'history-merge'\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = React.useMemo(() => {\n    const {\n      theme,\n      namespace,\n      editor__DEPRECATED: initialEditor,\n      nodes,\n      onError,\n      editorState: initialEditorState\n    } = initialConfig;\n    const context = LexicalComposerContext.createLexicalComposerContext(null, theme);\n    let editor = initialEditor || null;\n\n    if (editor === null) {\n      const newEditor = lexical.createEditor({\n        editable: false,\n        namespace,\n        nodes,\n        onError: error => onError(error, newEditor),\n        theme\n      });\n      initializeEditor(newEditor, initialEditorState);\n      editor = newEditor;\n    }\n\n    return [editor, context];\n  }, // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffect(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true); // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/React.createElement(LexicalComposerContext.LexicalComposerContext.Provider, {\n    value: composerContext\n  }, children);\n}\n\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = lexical.$getRoot();\n\n      if (root.isEmpty()) {\n        const paragraph = lexical.$createParagraphNode();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n\n        if (lexical.$getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n\n      case 'function':\n        {\n          editor.update(() => {\n            const root = lexical.$getRoot();\n\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\n\nexports.LexicalComposer = LexicalComposer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyLmRldi5qcz84OTI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCB1c2VMYXlvdXRFZmZlY3RJbXBsID0gQ0FOX1VTRV9ET00gPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG52YXIgdXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0SW1wbDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgSElTVE9SWV9NRVJHRV9PUFRJT05TID0ge1xuICB0YWc6ICdoaXN0b3J5LW1lcmdlJ1xufTtcbmZ1bmN0aW9uIExleGljYWxDb21wb3Nlcih7XG4gIGluaXRpYWxDb25maWcsXG4gIGNoaWxkcmVuXG59KSB7XG4gIGNvbnN0IGNvbXBvc2VyQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHRoZW1lLFxuICAgICAgbmFtZXNwYWNlLFxuICAgICAgZWRpdG9yX19ERVBSRUNBVEVEOiBpbml0aWFsRWRpdG9yLFxuICAgICAgbm9kZXMsXG4gICAgICBvbkVycm9yLFxuICAgICAgZWRpdG9yU3RhdGU6IGluaXRpYWxFZGl0b3JTdGF0ZVxuICAgIH0gPSBpbml0aWFsQ29uZmlnO1xuICAgIGNvbnN0IGNvbnRleHQgPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LmNyZWF0ZUxleGljYWxDb21wb3NlckNvbnRleHQobnVsbCwgdGhlbWUpO1xuICAgIGxldCBlZGl0b3IgPSBpbml0aWFsRWRpdG9yIHx8IG51bGw7XG5cbiAgICBpZiAoZWRpdG9yID09PSBudWxsKSB7XG4gICAgICBjb25zdCBuZXdFZGl0b3IgPSBsZXhpY2FsLmNyZWF0ZUVkaXRvcih7XG4gICAgICAgIGVkaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBub2RlcyxcbiAgICAgICAgb25FcnJvcjogZXJyb3IgPT4gb25FcnJvcihlcnJvciwgbmV3RWRpdG9yKSxcbiAgICAgICAgdGhlbWVcbiAgICAgIH0pO1xuICAgICAgaW5pdGlhbGl6ZUVkaXRvcihuZXdFZGl0b3IsIGluaXRpYWxFZGl0b3JTdGF0ZSk7XG4gICAgICBlZGl0b3IgPSBuZXdFZGl0b3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtlZGl0b3IsIGNvbnRleHRdO1xuICB9LCAvLyBXZSBvbmx5IGRvIHRoaXMgZm9yIGluaXRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbXSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaXNFZGl0YWJsZSA9IGluaXRpYWxDb25maWcuZWRpdGFibGU7XG4gICAgY29uc3QgW2VkaXRvcl0gPSBjb21wb3NlckNvbnRleHQ7XG4gICAgZWRpdG9yLnNldEVkaXRhYmxlKGlzRWRpdGFibGUgIT09IHVuZGVmaW5lZCA/IGlzRWRpdGFibGUgOiB0cnVlKTsgLy8gV2Ugb25seSBkbyB0aGlzIGZvciBpbml0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMZXhpY2FsQ29tcG9zZXJDb250ZXh0LkxleGljYWxDb21wb3NlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29tcG9zZXJDb250ZXh0XG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUVkaXRvcihlZGl0b3IsIGluaXRpYWxFZGl0b3JTdGF0ZSkge1xuICBpZiAoaW5pdGlhbEVkaXRvclN0YXRlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGluaXRpYWxFZGl0b3JTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCByb290ID0gbGV4aWNhbC4kZ2V0Um9vdCgpO1xuXG4gICAgICBpZiAocm9vdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICByb290LmFwcGVuZChwYXJhZ3JhcGgpO1xuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gQ0FOX1VTRV9ET00gPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IDogbnVsbDtcblxuICAgICAgICBpZiAobGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCkgIT09IG51bGwgfHwgYWN0aXZlRWxlbWVudCAhPT0gbnVsbCAmJiBhY3RpdmVFbGVtZW50ID09PSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKSkge1xuICAgICAgICAgIHBhcmFncmFwaC5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIEhJU1RPUllfTUVSR0VfT1BUSU9OUyk7XG4gIH0gZWxzZSBpZiAoaW5pdGlhbEVkaXRvclN0YXRlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgaW5pdGlhbEVkaXRvclN0YXRlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkRWRpdG9yU3RhdGUgPSBlZGl0b3IucGFyc2VFZGl0b3JTdGF0ZShpbml0aWFsRWRpdG9yU3RhdGUpO1xuICAgICAgICAgIGVkaXRvci5zZXRFZGl0b3JTdGF0ZShwYXJzZWRFZGl0b3JTdGF0ZSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICB7XG4gICAgICAgICAgZWRpdG9yLnNldEVkaXRvclN0YXRlKGluaXRpYWxFZGl0b3JTdGF0ZSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBsZXhpY2FsLiRnZXRSb290KCk7XG5cbiAgICAgICAgICAgIGlmIChyb290LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICBpbml0aWFsRWRpdG9yU3RhdGUoZWRpdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBISVNUT1JZX01FUkdFX09QVElPTlMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuTGV4aWNhbENvbXBvc2VyID0gTGV4aWNhbENvbXBvc2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalComposer.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalComposer.js":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposer.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalComposer =  true ? __webpack_require__(/*! ./LexicalComposer.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalComposer.dev.js\") : 0\nmodule.exports = LexicalComposer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osd0JBQXdCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyw0RkFBMEIsSUFBSSxDQUFvQztBQUMzSSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3Nlci5qcz8xMjVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsQ29tcG9zZXIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbENvbXBvc2VyLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsQ29tcG9zZXIucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxDb21wb3NlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalComposer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposerContext.dev.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst LexicalComposerContext = /*#__PURE__*/react.createContext(null);\nfunction createLexicalComposerContext(parent, theme) {\n  let parentContext = null;\n\n  if (parent != null) {\n    parentContext = parent[1];\n  }\n\n  function getTheme() {\n    if (theme != null) {\n      return theme;\n    }\n\n    return parentContext != null ? parentContext.getTheme() : null;\n  }\n\n  return {\n    getTheme\n  };\n}\nfunction useLexicalComposerContext() {\n  const composerContext = react.useContext(LexicalComposerContext);\n\n  if (composerContext == null) {\n    {\n      throw Error(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);\n    }\n  }\n\n  return composerContext;\n}\n\nexports.LexicalComposerContext = LexicalComposerContext;\nexports.createLexicalComposerContext = createLexicalComposerContext;\nexports.useLexicalComposerContext = useLexicalComposerContext;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dC5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QixvQ0FBb0M7QUFDcEMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dC5kZXYuanM/YjhjMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gY3JlYXRlTGV4aWNhbENvbXBvc2VyQ29udGV4dChwYXJlbnQsIHRoZW1lKSB7XG4gIGxldCBwYXJlbnRDb250ZXh0ID0gbnVsbDtcblxuICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICBwYXJlbnRDb250ZXh0ID0gcGFyZW50WzFdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VGhlbWUoKSB7XG4gICAgaWYgKHRoZW1lICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGVtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50Q29udGV4dCAhPSBudWxsID8gcGFyZW50Q29udGV4dC5nZXRUaGVtZSgpIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0VGhlbWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKSB7XG4gIGNvbnN0IGNvbXBvc2VyQ29udGV4dCA9IHJlYWN0LnVzZUNvbnRleHQoTGV4aWNhbENvbXBvc2VyQ29udGV4dCk7XG5cbiAgaWYgKGNvbXBvc2VyQ29udGV4dCA9PSBudWxsKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dDogY2Fubm90IGZpbmQgYSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0YCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbXBvc2VyQ29udGV4dDtcbn1cblxuZXhwb3J0cy5MZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dDtcbmV4cG9ydHMuY3JlYXRlTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IGNyZWF0ZUxleGljYWxDb21wb3NlckNvbnRleHQ7XG5leHBvcnRzLnVzZUxleGljYWxDb21wb3NlckNvbnRleHQgPSB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposerContext.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalComposerContext =  true ? __webpack_require__(/*! ./LexicalComposerContext.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.dev.js\") : 0\nmodule.exports = LexicalComposerContext;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLCtCQUErQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsMEdBQWlDLElBQUksQ0FBMkM7QUFDaEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0LmpzPzUxZGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxDb21wb3NlckNvbnRleHQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbENvbXBvc2VyQ29udGV4dC5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbENvbXBvc2VyQ29udGV4dC5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalContentEditable.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalContentEditable.dev.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction ContentEditable({\n  ariaActiveDescendant,\n  ariaAutoComplete,\n  ariaControls,\n  ariaDescribedBy,\n  ariaExpanded,\n  ariaLabel,\n  ariaLabelledBy,\n  ariaMultiline,\n  ariaOwns,\n  ariaRequired,\n  autoCapitalize,\n  className,\n  id,\n  role = 'textbox',\n  spellCheck = true,\n  style,\n  tabIndex,\n  'data-testid': testid\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isEditable, setEditable] = React.useState(false);\n  const ref = React.useCallback(rootElement => {\n    editor.setRootElement(rootElement);\n  }, [editor]);\n  useLayoutEffect(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    \"aria-activedescendant\": !isEditable ? undefined : ariaActiveDescendant,\n    \"aria-autocomplete\": !isEditable ? 'none' : ariaAutoComplete,\n    \"aria-controls\": !isEditable ? undefined : ariaControls,\n    \"aria-describedby\": ariaDescribedBy,\n    \"aria-expanded\": !isEditable ? undefined : role === 'combobox' ? !!ariaExpanded : undefined,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-multiline\": ariaMultiline,\n    \"aria-owns\": !isEditable ? undefined : ariaOwns,\n    \"aria-required\": ariaRequired,\n    autoCapitalize: autoCapitalize,\n    className: className,\n    contentEditable: isEditable,\n    \"data-testid\": testid,\n    id: id,\n    ref: ref,\n    role: !isEditable ? undefined : role,\n    spellCheck: spellCheck,\n    style: style,\n    tabIndex: tabIndex\n  });\n}\n\nexports.ContentEditable = ContentEditable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsNEdBQXVDO0FBQzVFLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb250ZW50RWRpdGFibGUuZGV2LmpzPzY5MjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCB1c2VMYXlvdXRFZmZlY3RJbXBsID0gQ0FOX1VTRV9ET00gPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG52YXIgdXNlTGF5b3V0RWZmZWN0ID0gdXNlTGF5b3V0RWZmZWN0SW1wbDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gQ29udGVudEVkaXRhYmxlKHtcbiAgYXJpYUFjdGl2ZURlc2NlbmRhbnQsXG4gIGFyaWFBdXRvQ29tcGxldGUsXG4gIGFyaWFDb250cm9scyxcbiAgYXJpYURlc2NyaWJlZEJ5LFxuICBhcmlhRXhwYW5kZWQsXG4gIGFyaWFMYWJlbCxcbiAgYXJpYUxhYmVsbGVkQnksXG4gIGFyaWFNdWx0aWxpbmUsXG4gIGFyaWFPd25zLFxuICBhcmlhUmVxdWlyZWQsXG4gIGF1dG9DYXBpdGFsaXplLFxuICBjbGFzc05hbWUsXG4gIGlkLFxuICByb2xlID0gJ3RleHRib3gnLFxuICBzcGVsbENoZWNrID0gdHJ1ZSxcbiAgc3R5bGUsXG4gIHRhYkluZGV4LFxuICAnZGF0YS10ZXN0aWQnOiB0ZXN0aWRcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgW2lzRWRpdGFibGUsIHNldEVkaXRhYmxlXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlQ2FsbGJhY2socm9vdEVsZW1lbnQgPT4ge1xuICAgIGVkaXRvci5zZXRSb290RWxlbWVudChyb290RWxlbWVudCk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBzZXRFZGl0YWJsZShlZGl0b3IuaXNFZGl0YWJsZSgpKTtcbiAgICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyRWRpdGFibGVMaXN0ZW5lcihjdXJyZW50SXNFZGl0YWJsZSA9PiB7XG4gICAgICBzZXRFZGl0YWJsZShjdXJyZW50SXNFZGl0YWJsZSk7XG4gICAgfSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiAhaXNFZGl0YWJsZSA/IHVuZGVmaW5lZCA6IGFyaWFBY3RpdmVEZXNjZW5kYW50LFxuICAgIFwiYXJpYS1hdXRvY29tcGxldGVcIjogIWlzRWRpdGFibGUgPyAnbm9uZScgOiBhcmlhQXV0b0NvbXBsZXRlLFxuICAgIFwiYXJpYS1jb250cm9sc1wiOiAhaXNFZGl0YWJsZSA/IHVuZGVmaW5lZCA6IGFyaWFDb250cm9scyxcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZEJ5LFxuICAgIFwiYXJpYS1leHBhbmRlZFwiOiAhaXNFZGl0YWJsZSA/IHVuZGVmaW5lZCA6IHJvbGUgPT09ICdjb21ib2JveCcgPyAhIWFyaWFFeHBhbmRlZCA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsLFxuICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFyaWFMYWJlbGxlZEJ5LFxuICAgIFwiYXJpYS1tdWx0aWxpbmVcIjogYXJpYU11bHRpbGluZSxcbiAgICBcImFyaWEtb3duc1wiOiAhaXNFZGl0YWJsZSA/IHVuZGVmaW5lZCA6IGFyaWFPd25zLFxuICAgIFwiYXJpYS1yZXF1aXJlZFwiOiBhcmlhUmVxdWlyZWQsXG4gICAgYXV0b0NhcGl0YWxpemU6IGF1dG9DYXBpdGFsaXplLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogaXNFZGl0YWJsZSxcbiAgICBcImRhdGEtdGVzdGlkXCI6IHRlc3RpZCxcbiAgICBpZDogaWQsXG4gICAgcmVmOiByZWYsXG4gICAgcm9sZTogIWlzRWRpdGFibGUgPyB1bmRlZmluZWQgOiByb2xlLFxuICAgIHNwZWxsQ2hlY2s6IHNwZWxsQ2hlY2ssXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIHRhYkluZGV4OiB0YWJJbmRleFxuICB9KTtcbn1cblxuZXhwb3J0cy5Db250ZW50RWRpdGFibGUgPSBDb250ZW50RWRpdGFibGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalContentEditable.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalContentEditable.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalContentEditable.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalContentEditable =  true ? __webpack_require__(/*! ./LexicalContentEditable.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalContentEditable.dev.js\") : 0\nmodule.exports = LexicalContentEditable;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLCtCQUErQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsMEdBQWlDLElBQUksQ0FBMkM7QUFDaEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29udGVudEVkaXRhYmxlLmpzP2JiZjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxDb250ZW50RWRpdGFibGUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbENvbnRlbnRFZGl0YWJsZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalContentEditable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalDecoratorBlockNode.dev.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalDecoratorBlockNode.dev.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DecoratorBlockNode extends lexical.DecoratorNode {\n  constructor(format, key) {\n    super(key);\n    this.__format = format || '';\n  }\n\n  exportJSON() {\n    return {\n      format: this.__format || '',\n      type: 'decorator-block',\n      version: 1\n    };\n  }\n\n  createDOM() {\n    return document.createElement('div');\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = format;\n  }\n\n}\nfunction $isDecoratorBlockNode(node) {\n  return node instanceof DecoratorBlockNode;\n}\n\nexports.$isDecoratorBlockNode = $isDecoratorBlockNode;\nexports.DecoratorBlockNode = DecoratorBlockNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbERlY29yYXRvckJsb2NrTm9kZS5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0IsMEJBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbERlY29yYXRvckJsb2NrTm9kZS5kZXYuanM/MzgyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNsYXNzIERlY29yYXRvckJsb2NrTm9kZSBleHRlbmRzIGxleGljYWwuRGVjb3JhdG9yTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGZvcm1hdCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiB0aGlzLl9fZm9ybWF0IHx8ICcnLFxuICAgICAgdHlwZTogJ2RlY29yYXRvci1ibG9jaycsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZURPTSgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIH1cblxuICB1cGRhdGVET00oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc2V0Rm9ybWF0KGZvcm1hdCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2Zvcm1hdCA9IGZvcm1hdDtcbiAgfVxuXG59XG5mdW5jdGlvbiAkaXNEZWNvcmF0b3JCbG9ja05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIERlY29yYXRvckJsb2NrTm9kZTtcbn1cblxuZXhwb3J0cy4kaXNEZWNvcmF0b3JCbG9ja05vZGUgPSAkaXNEZWNvcmF0b3JCbG9ja05vZGU7XG5leHBvcnRzLkRlY29yYXRvckJsb2NrTm9kZSA9IERlY29yYXRvckJsb2NrTm9kZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalDecoratorBlockNode.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalDecoratorBlockNode.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalDecoratorBlockNode.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalDecoratorBlockNode =  true ? __webpack_require__(/*! ./LexicalDecoratorBlockNode.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalDecoratorBlockNode.dev.js\") : 0\nmodule.exports = LexicalDecoratorBlockNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbERlY29yYXRvckJsb2NrTm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLGtDQUFrQyxLQUFzQyxHQUFHLG1CQUFPLENBQUMsZ0hBQW9DLElBQUksQ0FBOEM7QUFDeksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsRGVjb3JhdG9yQmxvY2tOb2RlLmpzPzUyY2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxEZWNvcmF0b3JCbG9ja05vZGUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbERlY29yYXRvckJsb2NrTm9kZS5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbERlY29yYXRvckJsb2NrTm9kZS5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbERlY29yYXRvckJsb2NrTm9kZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalDecoratorBlockNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalErrorBoundary.dev.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n\nvar changedArray = function changedArray(a, b) {\n  if (a === void 0) {\n    a = [];\n  }\n\n  if (b === void 0) {\n    b = [];\n  }\n\n  return a.length !== b.length || a.some(function (item, index) {\n    return !Object.is(item, b[index]);\n  });\n};\n\nvar initialState = {\n  error: null\n};\n\nvar ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n    _this.state = initialState;\n\n    _this.resetErrorBoundary = function () {\n      var _this$props;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n      _this.reset();\n    };\n\n    return _this;\n  }\n\n  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  };\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.reset = function reset() {\n    this.setState(initialState);\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n\n    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var error = this.state.error;\n    var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n    // happens to *also* be in the resetKeys array, we'd end up resetting\n    // the error boundary immediately. This would likely trigger a second\n    // error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call\n    // of cDU after the error is set\n\n    if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onResetKe, _this$props3;\n\n      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n      this.reset();\n    }\n  };\n\n  _proto.render = function render() {\n    var error = this.state.error;\n    var _this$props4 = this.props,\n        fallbackRender = _this$props4.fallbackRender,\n        FallbackComponent = _this$props4.FallbackComponent,\n        fallback = _this$props4.fallback;\n\n    if (error !== null) {\n      var _props = {\n        error: error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n\n      if ( /*#__PURE__*/React.isValidElement(fallback)) {\n        return fallback;\n      } else if (typeof fallbackRender === 'function') {\n        return fallbackRender(_props);\n      } else if (FallbackComponent) {\n        return /*#__PURE__*/React.createElement(FallbackComponent, _props);\n      } else {\n        throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n      }\n    }\n\n    return this.props.children;\n  };\n\n  return ErrorBoundary;\n}(React.Component);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction LexicalErrorBoundary({\n  children,\n  onError\n}) {\n  return /*#__PURE__*/React.createElement(ErrorBoundary, {\n    fallback: /*#__PURE__*/React.createElement(\"div\", {\n      style: {\n        border: '1px solid #f00',\n        color: '#f00',\n        padding: '8px'\n      }\n    }, \"An error was thrown.\"),\n    onError: onError\n  }, children);\n}\n\nmodule.exports = LexicalErrorBoundary;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEVycm9yQm91bmRhcnkuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZFQUE2RSxlQUFlO0FBQzVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxFcnJvckJvdW5kYXJ5LmRldi5qcz9hZWI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxudmFyIGNoYW5nZWRBcnJheSA9IGZ1bmN0aW9uIGNoYW5nZWRBcnJheShhLCBiKSB7XG4gIGlmIChhID09PSB2b2lkIDApIHtcbiAgICBhID0gW107XG4gIH1cblxuICBpZiAoYiA9PT0gdm9pZCAwKSB7XG4gICAgYiA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGEubGVuZ3RoICE9PSBiLmxlbmd0aCB8fCBhLnNvbWUoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuICFPYmplY3QuaXMoaXRlbSwgYltpbmRleF0pO1xuICB9KTtcbn07XG5cbnZhciBpbml0aWFsU3RhdGUgPSB7XG4gIGVycm9yOiBudWxsXG59O1xuXG52YXIgRXJyb3JCb3VuZGFyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShFcnJvckJvdW5kYXJ5LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBFcnJvckJvdW5kYXJ5KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBfYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoX2FyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXG4gICAgX3RoaXMucmVzZXRFcnJvckJvdW5kYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5wcm9wcy5vblJlc2V0ID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcykub25SZXNldC5hcHBseShfdGhpcyRwcm9wcywgYXJncyk7XG5cbiAgICAgIF90aGlzLnJlc2V0KCk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEVycm9yQm91bmRhcnkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBlcnJvclxuICAgIH07XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IEVycm9yQm91bmRhcnkucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuc2V0U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkQ2F0Y2ggPSBmdW5jdGlvbiBjb21wb25lbnREaWRDYXRjaChlcnJvciwgaW5mbykge1xuICAgIHZhciBfdGhpcyRwcm9wcyRvbkVycm9yLCBfdGhpcyRwcm9wczI7XG5cbiAgICAoX3RoaXMkcHJvcHMkb25FcnJvciA9IChfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzKS5vbkVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkb25FcnJvci5jYWxsKF90aGlzJHByb3BzMiwgZXJyb3IsIGluZm8pO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgIHZhciByZXNldEtleXMgPSB0aGlzLnByb3BzLnJlc2V0S2V5czsgLy8gVGhlcmUncyBhbiBlZGdlIGNhc2Ugd2hlcmUgaWYgdGhlIHRoaW5nIHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvclxuICAgIC8vIGhhcHBlbnMgdG8gKmFsc28qIGJlIGluIHRoZSByZXNldEtleXMgYXJyYXksIHdlJ2QgZW5kIHVwIHJlc2V0dGluZ1xuICAgIC8vIHRoZSBlcnJvciBib3VuZGFyeSBpbW1lZGlhdGVseS4gVGhpcyB3b3VsZCBsaWtlbHkgdHJpZ2dlciBhIHNlY29uZFxuICAgIC8vIGVycm9yIHRvIGJlIHRocm93bi5cbiAgICAvLyBTbyB3ZSBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGUgcmVzZXRLZXlzIG9uIHRoZSBmaXJzdCBjYWxsXG4gICAgLy8gb2YgY0RVIGFmdGVyIHRoZSBlcnJvciBpcyBzZXRcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCAmJiBwcmV2U3RhdGUuZXJyb3IgIT09IG51bGwgJiYgY2hhbmdlZEFycmF5KHByZXZQcm9wcy5yZXNldEtleXMsIHJlc2V0S2V5cykpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRvblJlc2V0S2UsIF90aGlzJHByb3BzMztcblxuICAgICAgKF90aGlzJHByb3BzJG9uUmVzZXRLZSA9IChfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzKS5vblJlc2V0S2V5c0NoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHByb3BzJG9uUmVzZXRLZS5jYWxsKF90aGlzJHByb3BzMywgcHJldlByb3BzLnJlc2V0S2V5cywgcmVzZXRLZXlzKTtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICBmYWxsYmFja1JlbmRlciA9IF90aGlzJHByb3BzNC5mYWxsYmFja1JlbmRlcixcbiAgICAgICAgRmFsbGJhY2tDb21wb25lbnQgPSBfdGhpcyRwcm9wczQuRmFsbGJhY2tDb21wb25lbnQsXG4gICAgICAgIGZhbGxiYWNrID0gX3RoaXMkcHJvcHM0LmZhbGxiYWNrO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICB2YXIgX3Byb3BzID0ge1xuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIHJlc2V0RXJyb3JCb3VuZGFyeTogdGhpcy5yZXNldEVycm9yQm91bmRhcnlcbiAgICAgIH07XG5cbiAgICAgIGlmICggLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGZhbGxiYWNrKSkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmYWxsYmFja1JlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tSZW5kZXIoX3Byb3BzKTtcbiAgICAgIH0gZWxzZSBpZiAoRmFsbGJhY2tDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZhbGxiYWNrQ29tcG9uZW50LCBfcHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWFjdC1lcnJvci1ib3VuZGFyeSByZXF1aXJlcyBlaXRoZXIgYSBmYWxsYmFjaywgZmFsbGJhY2tSZW5kZXIsIG9yIEZhbGxiYWNrQ29tcG9uZW50IHByb3AnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfTtcblxuICByZXR1cm4gRXJyb3JCb3VuZGFyeTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gTGV4aWNhbEVycm9yQm91bmRhcnkoe1xuICBjaGlsZHJlbixcbiAgb25FcnJvclxufSkge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeSwge1xuICAgIGZhbGxiYWNrOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBib3JkZXI6ICcxcHggc29saWQgI2YwMCcsXG4gICAgICAgIGNvbG9yOiAnI2YwMCcsXG4gICAgICAgIHBhZGRpbmc6ICc4cHgnXG4gICAgICB9XG4gICAgfSwgXCJBbiBlcnJvciB3YXMgdGhyb3duLlwiKSxcbiAgICBvbkVycm9yOiBvbkVycm9yXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsRXJyb3JCb3VuZGFyeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalErrorBoundary.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalErrorBoundary =  true ? __webpack_require__(/*! ./LexicalErrorBoundary.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.dev.js\") : 0\nmodule.exports = LexicalErrorBoundary;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEVycm9yQm91bmRhcnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWiw2QkFBNkIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLHNHQUErQixJQUFJLENBQXlDO0FBQzFKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEVycm9yQm91bmRhcnkuanM/Y2YyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbEVycm9yQm91bmRhcnkgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbEVycm9yQm91bmRhcnkuZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxFcnJvckJvdW5kYXJ5LnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsRXJyb3JCb3VuZGFyeTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalErrorBoundary.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHashtagPlugin.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHashtagPlugin.dev.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar hashtag = __webpack_require__(/*! @lexical/hashtag */ \"(ssr)/./node_modules/@lexical/hashtag/LexicalHashtag.js\");\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar useLexicalTextEntity = __webpack_require__(/*! @lexical/react/useLexicalTextEntity */ \"(ssr)/./node_modules/@lexical/react/useLexicalTextEntity.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getHashtagRegexStringChars() {\n  // Latin accented characters\n  // Excludes 0xd7 from the range\n  // (the multiplication sign, confusable with \"x\").\n  // Also excludes 0xf7, the division sign\n  const latinAccents = '\\xc0-\\xd6' + '\\xd8-\\xf6' + '\\xf8-\\xff' + '\\u0100-\\u024f' + '\\u0253-\\u0254' + '\\u0256-\\u0257' + '\\u0259' + '\\u025b' + '\\u0263' + '\\u0268' + '\\u026f' + '\\u0272' + '\\u0289' + '\\u028b' + '\\u02bb' + '\\u0300-\\u036f' + '\\u1e00-\\u1eff'; // Cyrillic (Russian, Ukrainian, etc.)\n\n  const nonLatinChars = '\\u0400-\\u04ff' + // Cyrillic\n  '\\u0500-\\u0527' + // Cyrillic Supplement\n  '\\u2de0-\\u2dff' + // Cyrillic Extended A\n  '\\ua640-\\ua69f' + // Cyrillic Extended B\n  '\\u0591-\\u05bf' + // Hebrew\n  '\\u05c1-\\u05c2' + '\\u05c4-\\u05c5' + '\\u05c7' + '\\u05d0-\\u05ea' + '\\u05f0-\\u05f4' + '\\ufb12-\\ufb28' + // Hebrew Presentation Forms\n  '\\ufb2a-\\ufb36' + '\\ufb38-\\ufb3c' + '\\ufb3e' + '\\ufb40-\\ufb41' + '\\ufb43-\\ufb44' + '\\ufb46-\\ufb4f' + '\\u0610-\\u061a' + // Arabic\n  '\\u0620-\\u065f' + '\\u066e-\\u06d3' + '\\u06d5-\\u06dc' + '\\u06de-\\u06e8' + '\\u06ea-\\u06ef' + '\\u06fa-\\u06fc' + '\\u06ff' + '\\u0750-\\u077f' + // Arabic Supplement\n  '\\u08a0' + // Arabic Extended A\n  '\\u08a2-\\u08ac' + '\\u08e4-\\u08fe' + '\\ufb50-\\ufbb1' + // Arabic Pres. Forms A\n  '\\ufbd3-\\ufd3d' + '\\ufd50-\\ufd8f' + '\\ufd92-\\ufdc7' + '\\ufdf0-\\ufdfb' + '\\ufe70-\\ufe74' + // Arabic Pres. Forms B\n  '\\ufe76-\\ufefc' + '\\u200c-\\u200c' + // Zero-Width Non-Joiner\n  '\\u0e01-\\u0e3a' + // Thai\n  '\\u0e40-\\u0e4e' + // Hangul (Korean)\n  '\\u1100-\\u11ff' + // Hangul Jamo\n  '\\u3130-\\u3185' + // Hangul Compatibility Jamo\n  '\\uA960-\\uA97F' + // Hangul Jamo Extended-A\n  '\\uAC00-\\uD7AF' + // Hangul Syllables\n  '\\uD7B0-\\uD7FF' + // Hangul Jamo Extended-B\n  '\\uFFA1-\\uFFDC'; // Half-width Hangul\n\n  const charCode = String.fromCharCode;\n  const cjkChars = '\\u30A1-\\u30FA\\u30FC-\\u30FE' + // Katakana (full-width)\n  '\\uFF66-\\uFF9F' + // Katakana (half-width)\n  '\\uFF10-\\uFF19\\uFF21-\\uFF3A' + '\\uFF41-\\uFF5A' + // Latin (full-width)\n  '\\u3041-\\u3096\\u3099-\\u309E' + // Hiragana\n  '\\u3400-\\u4DBF' + // Kanji (CJK Extension A)\n  '\\u4E00-\\u9FFF' + // Kanji (Unified)\n  // Disabled as it breaks the Regex.\n  // charCode(0x20000) + '-' + charCode(0x2A6DF) + // Kanji (CJK Extension B)\n  charCode(0x2a700) + '-' + charCode(0x2b73f) + // Kanji (CJK Extension C)\n  charCode(0x2b740) + '-' + charCode(0x2b81f) + // Kanji (CJK Extension D)\n  charCode(0x2f800) + '-' + charCode(0x2fa1f) + '\\u3003\\u3005\\u303B'; // Kanji (CJK supplement)\n\n  const otherChars = latinAccents + nonLatinChars + cjkChars; // equivalent of \\p{L}\n\n  const unicodeLetters = '\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u0241\\u0250-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EE\\u037A\\u0386' + '\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03D0-\\u03F5\\u03F7-\\u0481' + '\\u048A-\\u04CE\\u04D0-\\u04F9\\u0500-\\u050F\\u0531-\\u0556\\u0559\\u0561-\\u0587' + '\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0621-\\u063A\\u0640-\\u064A\\u066E-\\u066F' + '\\u0671-\\u06D3\\u06D5\\u06E5-\\u06E6\\u06EE-\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710' + '\\u0712-\\u072F\\u074D-\\u076D\\u0780-\\u07A5\\u07B1\\u0904-\\u0939\\u093D\\u0950' + '\\u0958-\\u0961\\u097D\\u0985-\\u098C\\u098F-\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0' + '\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC-\\u09DD\\u09DF-\\u09E1\\u09F0-\\u09F1' + '\\u0A05-\\u0A0A\\u0A0F-\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32-\\u0A33' + '\\u0A35-\\u0A36\\u0A38-\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D' + '\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2-\\u0AB3\\u0AB5-\\u0AB9\\u0ABD' + '\\u0AD0\\u0AE0-\\u0AE1\\u0B05-\\u0B0C\\u0B0F-\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30' + '\\u0B32-\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C-\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83' + '\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99-\\u0B9A\\u0B9C\\u0B9E-\\u0B9F' + '\\u0BA3-\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0C05-\\u0C0C\\u0C0E-\\u0C10' + '\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C60-\\u0C61\\u0C85-\\u0C8C' + '\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE' + '\\u0CE0-\\u0CE1\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39' + '\\u0D60-\\u0D61\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6' + '\\u0E01-\\u0E30\\u0E32-\\u0E33\\u0E40-\\u0E46\\u0E81-\\u0E82\\u0E84\\u0E87-\\u0E88' + '\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7' + '\\u0EAA-\\u0EAB\\u0EAD-\\u0EB0\\u0EB2-\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6' + '\\u0EDC-\\u0EDD\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6A\\u0F88-\\u0F8B\\u1000-\\u1021' + '\\u1023-\\u1027\\u1029-\\u102A\\u1050-\\u1055\\u10A0-\\u10C5\\u10D0-\\u10FA\\u10FC' + '\\u1100-\\u1159\\u115F-\\u11A2\\u11A8-\\u11F9\\u1200-\\u1248\\u124A-\\u124D' + '\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0' + '\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310' + '\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C' + '\\u166F-\\u1676\\u1681-\\u169A\\u16A0-\\u16EA\\u1700-\\u170C\\u170E-\\u1711' + '\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7' + '\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974' + '\\u1980-\\u19A9\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1D00-\\u1DBF\\u1E00-\\u1E9B' + '\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D' + '\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC' + '\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC' + '\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u2094\\u2102\\u2107' + '\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D' + '\\u212F-\\u2131\\u2133-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u2C00-\\u2C2E' + '\\u2C30-\\u2C5E\\u2C80-\\u2CE4\\u2D00-\\u2D25\\u2D30-\\u2D65\\u2D6F\\u2D80-\\u2D96' + '\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6' + '\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3006\\u3031-\\u3035' + '\\u303B-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF' + '\\u3105-\\u312C\\u3131-\\u318E\\u31A0-\\u31B7\\u31F0-\\u31FF\\u3400-\\u4DB5' + '\\u4E00-\\u9FBB\\uA000-\\uA48C\\uA800-\\uA801\\uA803-\\uA805\\uA807-\\uA80A' + '\\uA80C-\\uA822\\uAC00-\\uD7A3\\uF900-\\uFA2D\\uFA30-\\uFA6A\\uFA70-\\uFAD9' + '\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C' + '\\uFB3E\\uFB40-\\uFB41\\uFB43-\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F' + '\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A' + '\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7' + '\\uFFDA-\\uFFDC'; // equivalent of \\p{Mn}\\p{Mc}\n\n  const unicodeAccents = '\\u0300-\\u036F\\u0483-\\u0486\\u0591-\\u05B9\\u05BB-\\u05BD\\u05BF' + '\\u05C1-\\u05C2\\u05C4-\\u05C5\\u05C7\\u0610-\\u0615\\u064B-\\u065E\\u0670' + '\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7-\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A' + '\\u07A6-\\u07B0\\u0901-\\u0903\\u093C\\u093E-\\u094D\\u0951-\\u0954\\u0962-\\u0963' + '\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7-\\u09C8\\u09CB-\\u09CD\\u09D7' + '\\u09E2-\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47-\\u0A48\\u0A4B-\\u0A4D' + '\\u0A70-\\u0A71\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD' + '\\u0AE2-\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B43\\u0B47-\\u0B48\\u0B4B-\\u0B4D' + '\\u0B56-\\u0B57\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7' + '\\u0C01-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55-\\u0C56' + '\\u0C82-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5-\\u0CD6' + '\\u0D02-\\u0D03\\u0D3E-\\u0D43\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D82-\\u0D83' + '\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2-\\u0DF3\\u0E31\\u0E34-\\u0E3A' + '\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB-\\u0EBC\\u0EC8-\\u0ECD\\u0F18-\\u0F19' + '\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F3F\\u0F71-\\u0F84\\u0F86-\\u0F87\\u0F90-\\u0F97' + '\\u0F99-\\u0FBC\\u0FC6\\u102C-\\u1032\\u1036-\\u1039\\u1056-\\u1059\\u135F' + '\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17B6-\\u17D3\\u17DD' + '\\u180B-\\u180D\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u19B0-\\u19C0\\u19C8-\\u19C9' + '\\u1A17-\\u1A1B\\u1DC0-\\u1DC3\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20EB\\u302A-\\u302F' + '\\u3099-\\u309A\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uFB1E\\uFE00-\\uFE0F' + '\\uFE20-\\uFE23'; // equivalent of \\p{Dn}\n\n  const unicodeDigits = '\\u0030-\\u0039\\u0660-\\u0669\\u06F0-\\u06F9\\u0966-\\u096F\\u09E6-\\u09EF' + '\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F' + '\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29' + '\\u1040-\\u1049\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9' + '\\uFF10-\\uFF19'; // An alpha char is a unicode chars including unicode marks or\n  // letter or char in otherChars range\n\n  const alpha = unicodeLetters + unicodeAccents + otherChars; // A numeric character is any with the number digit property, or\n  // underscore. These characters can be included in hashtags, but a hashtag\n  // cannot have only these characters.\n\n  const numeric = unicodeDigits + '_'; // Alphanumeric char is any alpha char or a unicode char with decimal\n  // number property \\p{Nd}\n\n  const alphanumeric = alpha + numeric;\n  const hashChars = '#\\\\uFF03'; // normal '#' or full-width '#'\n\n  return {\n    alpha,\n    alphanumeric,\n    hashChars\n  };\n}\n\nfunction getHashtagRegexString() {\n  const {\n    alpha,\n    alphanumeric,\n    hashChars\n  } = getHashtagRegexStringChars();\n  const hashtagAlpha = '[' + alpha + ']';\n  const hashtagAlphanumeric = '[' + alphanumeric + ']';\n  const hashtagBoundary = '^|$|[^&/' + alphanumeric + ']';\n  const hashCharList = '[' + hashChars + ']'; // A hashtag contains characters, numbers and underscores,\n  // but not all numbers.\n\n  const hashtag = '(' + hashtagBoundary + ')(' + hashCharList + ')(' + hashtagAlphanumeric + '*' + hashtagAlpha + hashtagAlphanumeric + '*)';\n  return hashtag;\n}\n\nconst REGEX = new RegExp(getHashtagRegexString(), 'i');\nfunction HashtagPlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    if (!editor.hasNodes([hashtag.HashtagNode])) {\n      throw new Error('HashtagPlugin: HashtagNode not registered on editor');\n    }\n  }, [editor]);\n  const createHashtagNode = react.useCallback(textNode => {\n    return hashtag.$createHashtagNode(textNode.getTextContent());\n  }, []);\n  const getHashtagMatch = react.useCallback(text => {\n    const matchArr = REGEX.exec(text);\n\n    if (matchArr === null) {\n      return null;\n    }\n\n    const hashtagLength = matchArr[3].length + 1;\n    const startOffset = matchArr.index + matchArr[1].length;\n    const endOffset = startOffset + hashtagLength;\n    return {\n      end: endOffset,\n      start: startOffset\n    };\n  }, []);\n  useLexicalTextEntity.useLexicalTextEntity(getHashtagMatch, hashtag.HashtagNode, createHashtagNode);\n  return null;\n}\n\nexports.HashtagPlugin = HashtagPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhhc2h0YWdQbHVnaW4uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxpRkFBa0I7QUFDeEMsNkJBQTZCLG1CQUFPLENBQUMsNEdBQXVDO0FBQzVFLDJCQUEyQixtQkFBTyxDQUFDLHdHQUFxQztBQUN4RSxZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2UEFBNlA7O0FBRTdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFOztBQUV0RSw4REFBOEQsb0JBQW9COztBQUVsRixtbUhBQW1tSCxvQkFBb0IsR0FBRyxHQUFHOztBQUU3bkgsaStDQUFpK0Msb0JBQW9COztBQUVyL0MsaVVBQWlVO0FBQ2pVOztBQUVBLDhEQUE4RDtBQUM5RDtBQUNBOztBQUVBLHVDQUF1QztBQUN2Qyx3QkFBd0I7O0FBRXhCO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxIYXNodGFnUGx1Z2luLmRldi5qcz8wYjcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzaHRhZyA9IHJlcXVpcmUoJ0BsZXhpY2FsL2hhc2h0YWcnKTtcbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIHVzZUxleGljYWxUZXh0RW50aXR5ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbFRleHRFbnRpdHknKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gZ2V0SGFzaHRhZ1JlZ2V4U3RyaW5nQ2hhcnMoKSB7XG4gIC8vIExhdGluIGFjY2VudGVkIGNoYXJhY3RlcnNcbiAgLy8gRXhjbHVkZXMgMHhkNyBmcm9tIHRoZSByYW5nZVxuICAvLyAodGhlIG11bHRpcGxpY2F0aW9uIHNpZ24sIGNvbmZ1c2FibGUgd2l0aCBcInhcIikuXG4gIC8vIEFsc28gZXhjbHVkZXMgMHhmNywgdGhlIGRpdmlzaW9uIHNpZ25cbiAgY29uc3QgbGF0aW5BY2NlbnRzID0gJ1xceGMwLVxceGQ2JyArICdcXHhkOC1cXHhmNicgKyAnXFx4ZjgtXFx4ZmYnICsgJ1xcdTAxMDAtXFx1MDI0ZicgKyAnXFx1MDI1My1cXHUwMjU0JyArICdcXHUwMjU2LVxcdTAyNTcnICsgJ1xcdTAyNTknICsgJ1xcdTAyNWInICsgJ1xcdTAyNjMnICsgJ1xcdTAyNjgnICsgJ1xcdTAyNmYnICsgJ1xcdTAyNzInICsgJ1xcdTAyODknICsgJ1xcdTAyOGInICsgJ1xcdTAyYmInICsgJ1xcdTAzMDAtXFx1MDM2ZicgKyAnXFx1MWUwMC1cXHUxZWZmJzsgLy8gQ3lyaWxsaWMgKFJ1c3NpYW4sIFVrcmFpbmlhbiwgZXRjLilcblxuICBjb25zdCBub25MYXRpbkNoYXJzID0gJ1xcdTA0MDAtXFx1MDRmZicgKyAvLyBDeXJpbGxpY1xuICAnXFx1MDUwMC1cXHUwNTI3JyArIC8vIEN5cmlsbGljIFN1cHBsZW1lbnRcbiAgJ1xcdTJkZTAtXFx1MmRmZicgKyAvLyBDeXJpbGxpYyBFeHRlbmRlZCBBXG4gICdcXHVhNjQwLVxcdWE2OWYnICsgLy8gQ3lyaWxsaWMgRXh0ZW5kZWQgQlxuICAnXFx1MDU5MS1cXHUwNWJmJyArIC8vIEhlYnJld1xuICAnXFx1MDVjMS1cXHUwNWMyJyArICdcXHUwNWM0LVxcdTA1YzUnICsgJ1xcdTA1YzcnICsgJ1xcdTA1ZDAtXFx1MDVlYScgKyAnXFx1MDVmMC1cXHUwNWY0JyArICdcXHVmYjEyLVxcdWZiMjgnICsgLy8gSGVicmV3IFByZXNlbnRhdGlvbiBGb3Jtc1xuICAnXFx1ZmIyYS1cXHVmYjM2JyArICdcXHVmYjM4LVxcdWZiM2MnICsgJ1xcdWZiM2UnICsgJ1xcdWZiNDAtXFx1ZmI0MScgKyAnXFx1ZmI0My1cXHVmYjQ0JyArICdcXHVmYjQ2LVxcdWZiNGYnICsgJ1xcdTA2MTAtXFx1MDYxYScgKyAvLyBBcmFiaWNcbiAgJ1xcdTA2MjAtXFx1MDY1ZicgKyAnXFx1MDY2ZS1cXHUwNmQzJyArICdcXHUwNmQ1LVxcdTA2ZGMnICsgJ1xcdTA2ZGUtXFx1MDZlOCcgKyAnXFx1MDZlYS1cXHUwNmVmJyArICdcXHUwNmZhLVxcdTA2ZmMnICsgJ1xcdTA2ZmYnICsgJ1xcdTA3NTAtXFx1MDc3ZicgKyAvLyBBcmFiaWMgU3VwcGxlbWVudFxuICAnXFx1MDhhMCcgKyAvLyBBcmFiaWMgRXh0ZW5kZWQgQVxuICAnXFx1MDhhMi1cXHUwOGFjJyArICdcXHUwOGU0LVxcdTA4ZmUnICsgJ1xcdWZiNTAtXFx1ZmJiMScgKyAvLyBBcmFiaWMgUHJlcy4gRm9ybXMgQVxuICAnXFx1ZmJkMy1cXHVmZDNkJyArICdcXHVmZDUwLVxcdWZkOGYnICsgJ1xcdWZkOTItXFx1ZmRjNycgKyAnXFx1ZmRmMC1cXHVmZGZiJyArICdcXHVmZTcwLVxcdWZlNzQnICsgLy8gQXJhYmljIFByZXMuIEZvcm1zIEJcbiAgJ1xcdWZlNzYtXFx1ZmVmYycgKyAnXFx1MjAwYy1cXHUyMDBjJyArIC8vIFplcm8tV2lkdGggTm9uLUpvaW5lclxuICAnXFx1MGUwMS1cXHUwZTNhJyArIC8vIFRoYWlcbiAgJ1xcdTBlNDAtXFx1MGU0ZScgKyAvLyBIYW5ndWwgKEtvcmVhbilcbiAgJ1xcdTExMDAtXFx1MTFmZicgKyAvLyBIYW5ndWwgSmFtb1xuICAnXFx1MzEzMC1cXHUzMTg1JyArIC8vIEhhbmd1bCBDb21wYXRpYmlsaXR5IEphbW9cbiAgJ1xcdUE5NjAtXFx1QTk3RicgKyAvLyBIYW5ndWwgSmFtbyBFeHRlbmRlZC1BXG4gICdcXHVBQzAwLVxcdUQ3QUYnICsgLy8gSGFuZ3VsIFN5bGxhYmxlc1xuICAnXFx1RDdCMC1cXHVEN0ZGJyArIC8vIEhhbmd1bCBKYW1vIEV4dGVuZGVkLUJcbiAgJ1xcdUZGQTEtXFx1RkZEQyc7IC8vIEhhbGYtd2lkdGggSGFuZ3VsXG5cbiAgY29uc3QgY2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICBjb25zdCBjamtDaGFycyA9ICdcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkUnICsgLy8gS2F0YWthbmEgKGZ1bGwtd2lkdGgpXG4gICdcXHVGRjY2LVxcdUZGOUYnICsgLy8gS2F0YWthbmEgKGhhbGYtd2lkdGgpXG4gICdcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0EnICsgJ1xcdUZGNDEtXFx1RkY1QScgKyAvLyBMYXRpbiAoZnVsbC13aWR0aClcbiAgJ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTktXFx1MzA5RScgKyAvLyBIaXJhZ2FuYVxuICAnXFx1MzQwMC1cXHU0REJGJyArIC8vIEthbmppIChDSksgRXh0ZW5zaW9uIEEpXG4gICdcXHU0RTAwLVxcdTlGRkYnICsgLy8gS2FuamkgKFVuaWZpZWQpXG4gIC8vIERpc2FibGVkIGFzIGl0IGJyZWFrcyB0aGUgUmVnZXguXG4gIC8vIGNoYXJDb2RlKDB4MjAwMDApICsgJy0nICsgY2hhckNvZGUoMHgyQTZERikgKyAvLyBLYW5qaSAoQ0pLIEV4dGVuc2lvbiBCKVxuICBjaGFyQ29kZSgweDJhNzAwKSArICctJyArIGNoYXJDb2RlKDB4MmI3M2YpICsgLy8gS2FuamkgKENKSyBFeHRlbnNpb24gQylcbiAgY2hhckNvZGUoMHgyYjc0MCkgKyAnLScgKyBjaGFyQ29kZSgweDJiODFmKSArIC8vIEthbmppIChDSksgRXh0ZW5zaW9uIEQpXG4gIGNoYXJDb2RlKDB4MmY4MDApICsgJy0nICsgY2hhckNvZGUoMHgyZmExZikgKyAnXFx1MzAwM1xcdTMwMDVcXHUzMDNCJzsgLy8gS2FuamkgKENKSyBzdXBwbGVtZW50KVxuXG4gIGNvbnN0IG90aGVyQ2hhcnMgPSBsYXRpbkFjY2VudHMgKyBub25MYXRpbkNoYXJzICsgY2prQ2hhcnM7IC8vIGVxdWl2YWxlbnQgb2YgXFxwe0x9XG5cbiAgY29uc3QgdW5pY29kZUxldHRlcnMgPSAnXFx1MDA0MS1cXHUwMDVBXFx1MDA2MS1cXHUwMDdBXFx1MDBBQVxcdTAwQjVcXHUwMEJBXFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2JyArICdcXHUwMEY4LVxcdTAyNDFcXHUwMjUwLVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVFXFx1MDM3QVxcdTAzODYnICsgJ1xcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzQ0VcXHUwM0QwLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODEnICsgJ1xcdTA0OEEtXFx1MDRDRVxcdTA0RDAtXFx1MDRGOVxcdTA1MDAtXFx1MDUwRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODcnICsgJ1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjEtXFx1MDYzQVxcdTA2NDAtXFx1MDY0QVxcdTA2NkUtXFx1MDY2RicgKyAnXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTUtXFx1MDZFNlxcdTA2RUUtXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwJyArICdcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3NkRcXHUwNzgwLVxcdTA3QTVcXHUwN0IxXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTAnICsgJ1xcdTA5NTgtXFx1MDk2MVxcdTA5N0RcXHUwOTg1LVxcdTA5OENcXHUwOThGLVxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjAnICsgJ1xcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5REMtXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjAtXFx1MDlGMScgKyAnXFx1MEEwNS1cXHUwQTBBXFx1MEEwRi1cXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMi1cXHUwQTMzJyArICdcXHUwQTM1LVxcdTBBMzZcXHUwQTM4LVxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEJyArICdcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyLVxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEJyArICdcXHUwQUQwXFx1MEFFMC1cXHUwQUUxXFx1MEIwNS1cXHUwQjBDXFx1MEIwRi1cXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwJyArICdcXHUwQjMyLVxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Qy1cXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODMnICsgJ1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTktXFx1MEI5QVxcdTBCOUNcXHUwQjlFLVxcdTBCOUYnICsgJ1xcdTBCQTMtXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMCcgKyAnXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzMzXFx1MEMzNS1cXHUwQzM5XFx1MEM2MC1cXHUwQzYxXFx1MEM4NS1cXHUwQzhDJyArICdcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERScgKyAnXFx1MENFMC1cXHUwQ0UxXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDI4XFx1MEQyQS1cXHUwRDM5JyArICdcXHUwRDYwLVxcdTBENjFcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2JyArICdcXHUwRTAxLVxcdTBFMzBcXHUwRTMyLVxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxLVxcdTBFODJcXHUwRTg0XFx1MEU4Ny1cXHUwRTg4JyArICdcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3JyArICdcXHUwRUFBLVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyLVxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNicgKyAnXFx1MEVEQy1cXHUwRUREXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2QVxcdTBGODgtXFx1MEY4QlxcdTEwMDAtXFx1MTAyMScgKyAnXFx1MTAyMy1cXHUxMDI3XFx1MTAyOS1cXHUxMDJBXFx1MTA1MC1cXHUxMDU1XFx1MTBBMC1cXHUxMEM1XFx1MTBEMC1cXHUxMEZBXFx1MTBGQycgKyAnXFx1MTEwMC1cXHUxMTU5XFx1MTE1Ri1cXHUxMUEyXFx1MTFBOC1cXHUxMUY5XFx1MTIwMC1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREJyArICdcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwJyArICdcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwJyArICdcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkMnICsgJ1xcdTE2NkYtXFx1MTY3NlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMScgKyAnXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdENycgKyAnXFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE5MDAtXFx1MTkxQ1xcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NCcgKyAnXFx1MTk4MC1cXHUxOUE5XFx1MTlDMS1cXHUxOUM3XFx1MUEwMC1cXHUxQTE2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRTlCJyArICdcXHUxRUEwLVxcdTFFRjlcXHUxRjAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNEQnICsgJ1xcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQycgKyAnXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQycgKyAnXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOTRcXHUyMTAyXFx1MjEwNycgKyAnXFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRCcgKyAnXFx1MjEyRi1cXHUyMTMxXFx1MjEzMy1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MkMwMC1cXHUyQzJFJyArICdcXHUyQzMwLVxcdTJDNUVcXHUyQzgwLVxcdTJDRTRcXHUyRDAwLVxcdTJEMjVcXHUyRDMwLVxcdTJENjVcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2JyArICdcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzYnICsgJ1xcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTMwMDUtXFx1MzAwNlxcdTMwMzEtXFx1MzAzNScgKyAnXFx1MzAzQi1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGJyArICdcXHUzMTA1LVxcdTMxMkNcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQjdcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjUnICsgJ1xcdTRFMDAtXFx1OUZCQlxcdUEwMDAtXFx1QTQ4Q1xcdUE4MDAtXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQScgKyAnXFx1QTgwQy1cXHVBODIyXFx1QUMwMC1cXHVEN0EzXFx1RjkwMC1cXHVGQTJEXFx1RkEzMC1cXHVGQTZBXFx1RkE3MC1cXHVGQUQ5JyArICdcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDJyArICdcXHVGQjNFXFx1RkI0MC1cXHVGQjQxXFx1RkI0My1cXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGJyArICdcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0EnICsgJ1xcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZENycgKyAnXFx1RkZEQS1cXHVGRkRDJzsgLy8gZXF1aXZhbGVudCBvZiBcXHB7TW59XFxwe01jfVxuXG4gIGNvbnN0IHVuaWNvZGVBY2NlbnRzID0gJ1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4NlxcdTA1OTEtXFx1MDVCOVxcdTA1QkItXFx1MDVCRFxcdTA1QkYnICsgJ1xcdTA1QzEtXFx1MDVDMlxcdTA1QzQtXFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MTVcXHUwNjRCLVxcdTA2NUVcXHUwNjcwJyArICdcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3LVxcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBJyArICdcXHUwN0E2LVxcdTA3QjBcXHUwOTAxLVxcdTA5MDNcXHUwOTNDXFx1MDkzRS1cXHUwOTREXFx1MDk1MS1cXHUwOTU0XFx1MDk2Mi1cXHUwOTYzJyArICdcXHUwOTgxLVxcdTA5ODNcXHUwOUJDXFx1MDlCRS1cXHUwOUM0XFx1MDlDNy1cXHUwOUM4XFx1MDlDQi1cXHUwOUNEXFx1MDlENycgKyAnXFx1MDlFMi1cXHUwOUUzXFx1MEEwMS1cXHUwQTAzXFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDctXFx1MEE0OFxcdTBBNEItXFx1MEE0RCcgKyAnXFx1MEE3MC1cXHUwQTcxXFx1MEE4MS1cXHUwQTgzXFx1MEFCQ1xcdTBBQkUtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRCcgKyAnXFx1MEFFMi1cXHUwQUUzXFx1MEIwMS1cXHUwQjAzXFx1MEIzQ1xcdTBCM0UtXFx1MEI0M1xcdTBCNDctXFx1MEI0OFxcdTBCNEItXFx1MEI0RCcgKyAnXFx1MEI1Ni1cXHUwQjU3XFx1MEI4MlxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDcnICsgJ1xcdTBDMDEtXFx1MEMwM1xcdTBDM0UtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTUtXFx1MEM1NicgKyAnXFx1MEM4Mi1cXHUwQzgzXFx1MENCQ1xcdTBDQkUtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDUtXFx1MENENicgKyAnXFx1MEQwMi1cXHUwRDAzXFx1MEQzRS1cXHUwRDQzXFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDREXFx1MEQ1N1xcdTBEODItXFx1MEQ4MycgKyAnXFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREYyLVxcdTBERjNcXHUwRTMxXFx1MEUzNC1cXHUwRTNBJyArICdcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEYxOC1cXHUwRjE5JyArICdcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGM0ZcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGODdcXHUwRjkwLVxcdTBGOTcnICsgJ1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJDLVxcdTEwMzJcXHUxMDM2LVxcdTEwMzlcXHUxMDU2LVxcdTEwNTlcXHUxMzVGJyArICdcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyLVxcdTE3NTNcXHUxNzcyLVxcdTE3NzNcXHUxN0I2LVxcdTE3RDNcXHUxN0REJyArICdcXHUxODBCLVxcdTE4MERcXHUxOEE5XFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTlCMC1cXHUxOUMwXFx1MTlDOC1cXHUxOUM5JyArICdcXHUxQTE3LVxcdTFBMUJcXHUxREMwLVxcdTFEQzNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEVCXFx1MzAyQS1cXHUzMDJGJyArICdcXHUzMDk5LVxcdTMwOUFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODIzLVxcdUE4MjdcXHVGQjFFXFx1RkUwMC1cXHVGRTBGJyArICdcXHVGRTIwLVxcdUZFMjMnOyAvLyBlcXVpdmFsZW50IG9mIFxccHtEbn1cblxuICBjb25zdCB1bmljb2RlRGlnaXRzID0gJ1xcdTAwMzAtXFx1MDAzOVxcdTA2NjAtXFx1MDY2OVxcdTA2RjAtXFx1MDZGOVxcdTA5NjYtXFx1MDk2RlxcdTA5RTYtXFx1MDlFRicgKyAnXFx1MEE2Ni1cXHUwQTZGXFx1MEFFNi1cXHUwQUVGXFx1MEI2Ni1cXHUwQjZGXFx1MEJFNi1cXHUwQkVGXFx1MEM2Ni1cXHUwQzZGJyArICdcXHUwQ0U2LVxcdTBDRUZcXHUwRDY2LVxcdTBENkZcXHUwRTUwLVxcdTBFNTlcXHUwRUQwLVxcdTBFRDlcXHUwRjIwLVxcdTBGMjknICsgJ1xcdTEwNDAtXFx1MTA0OVxcdTE3RTAtXFx1MTdFOVxcdTE4MTAtXFx1MTgxOVxcdTE5NDYtXFx1MTk0RlxcdTE5RDAtXFx1MTlEOScgKyAnXFx1RkYxMC1cXHVGRjE5JzsgLy8gQW4gYWxwaGEgY2hhciBpcyBhIHVuaWNvZGUgY2hhcnMgaW5jbHVkaW5nIHVuaWNvZGUgbWFya3Mgb3JcbiAgLy8gbGV0dGVyIG9yIGNoYXIgaW4gb3RoZXJDaGFycyByYW5nZVxuXG4gIGNvbnN0IGFscGhhID0gdW5pY29kZUxldHRlcnMgKyB1bmljb2RlQWNjZW50cyArIG90aGVyQ2hhcnM7IC8vIEEgbnVtZXJpYyBjaGFyYWN0ZXIgaXMgYW55IHdpdGggdGhlIG51bWJlciBkaWdpdCBwcm9wZXJ0eSwgb3JcbiAgLy8gdW5kZXJzY29yZS4gVGhlc2UgY2hhcmFjdGVycyBjYW4gYmUgaW5jbHVkZWQgaW4gaGFzaHRhZ3MsIGJ1dCBhIGhhc2h0YWdcbiAgLy8gY2Fubm90IGhhdmUgb25seSB0aGVzZSBjaGFyYWN0ZXJzLlxuXG4gIGNvbnN0IG51bWVyaWMgPSB1bmljb2RlRGlnaXRzICsgJ18nOyAvLyBBbHBoYW51bWVyaWMgY2hhciBpcyBhbnkgYWxwaGEgY2hhciBvciBhIHVuaWNvZGUgY2hhciB3aXRoIGRlY2ltYWxcbiAgLy8gbnVtYmVyIHByb3BlcnR5IFxccHtOZH1cblxuICBjb25zdCBhbHBoYW51bWVyaWMgPSBhbHBoYSArIG51bWVyaWM7XG4gIGNvbnN0IGhhc2hDaGFycyA9ICcjXFxcXHVGRjAzJzsgLy8gbm9ybWFsICcjJyBvciBmdWxsLXdpZHRoICcjJ1xuXG4gIHJldHVybiB7XG4gICAgYWxwaGEsXG4gICAgYWxwaGFudW1lcmljLFxuICAgIGhhc2hDaGFyc1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRIYXNodGFnUmVnZXhTdHJpbmcoKSB7XG4gIGNvbnN0IHtcbiAgICBhbHBoYSxcbiAgICBhbHBoYW51bWVyaWMsXG4gICAgaGFzaENoYXJzXG4gIH0gPSBnZXRIYXNodGFnUmVnZXhTdHJpbmdDaGFycygpO1xuICBjb25zdCBoYXNodGFnQWxwaGEgPSAnWycgKyBhbHBoYSArICddJztcbiAgY29uc3QgaGFzaHRhZ0FscGhhbnVtZXJpYyA9ICdbJyArIGFscGhhbnVtZXJpYyArICddJztcbiAgY29uc3QgaGFzaHRhZ0JvdW5kYXJ5ID0gJ158JHxbXiYvJyArIGFscGhhbnVtZXJpYyArICddJztcbiAgY29uc3QgaGFzaENoYXJMaXN0ID0gJ1snICsgaGFzaENoYXJzICsgJ10nOyAvLyBBIGhhc2h0YWcgY29udGFpbnMgY2hhcmFjdGVycywgbnVtYmVycyBhbmQgdW5kZXJzY29yZXMsXG4gIC8vIGJ1dCBub3QgYWxsIG51bWJlcnMuXG5cbiAgY29uc3QgaGFzaHRhZyA9ICcoJyArIGhhc2h0YWdCb3VuZGFyeSArICcpKCcgKyBoYXNoQ2hhckxpc3QgKyAnKSgnICsgaGFzaHRhZ0FscGhhbnVtZXJpYyArICcqJyArIGhhc2h0YWdBbHBoYSArIGhhc2h0YWdBbHBoYW51bWVyaWMgKyAnKiknO1xuICByZXR1cm4gaGFzaHRhZztcbn1cblxuY29uc3QgUkVHRVggPSBuZXcgUmVnRXhwKGdldEhhc2h0YWdSZWdleFN0cmluZygpLCAnaScpO1xuZnVuY3Rpb24gSGFzaHRhZ1BsdWdpbigpIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVkaXRvci5oYXNOb2RlcyhbaGFzaHRhZy5IYXNodGFnTm9kZV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2h0YWdQbHVnaW46IEhhc2h0YWdOb2RlIG5vdCByZWdpc3RlcmVkIG9uIGVkaXRvcicpO1xuICAgIH1cbiAgfSwgW2VkaXRvcl0pO1xuICBjb25zdCBjcmVhdGVIYXNodGFnTm9kZSA9IHJlYWN0LnVzZUNhbGxiYWNrKHRleHROb2RlID0+IHtcbiAgICByZXR1cm4gaGFzaHRhZy4kY3JlYXRlSGFzaHRhZ05vZGUodGV4dE5vZGUuZ2V0VGV4dENvbnRlbnQoKSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgZ2V0SGFzaHRhZ01hdGNoID0gcmVhY3QudXNlQ2FsbGJhY2sodGV4dCA9PiB7XG4gICAgY29uc3QgbWF0Y2hBcnIgPSBSRUdFWC5leGVjKHRleHQpO1xuXG4gICAgaWYgKG1hdGNoQXJyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNodGFnTGVuZ3RoID0gbWF0Y2hBcnJbM10ubGVuZ3RoICsgMTtcbiAgICBjb25zdCBzdGFydE9mZnNldCA9IG1hdGNoQXJyLmluZGV4ICsgbWF0Y2hBcnJbMV0ubGVuZ3RoO1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgaGFzaHRhZ0xlbmd0aDtcbiAgICByZXR1cm4ge1xuICAgICAgZW5kOiBlbmRPZmZzZXQsXG4gICAgICBzdGFydDogc3RhcnRPZmZzZXRcbiAgICB9O1xuICB9LCBbXSk7XG4gIHVzZUxleGljYWxUZXh0RW50aXR5LnVzZUxleGljYWxUZXh0RW50aXR5KGdldEhhc2h0YWdNYXRjaCwgaGFzaHRhZy5IYXNodGFnTm9kZSwgY3JlYXRlSGFzaHRhZ05vZGUpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5IYXNodGFnUGx1Z2luID0gSGFzaHRhZ1BsdWdpbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHashtagPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHashtagPlugin.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHashtagPlugin.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHashtagPlugin =  true ? __webpack_require__(/*! ./LexicalHashtagPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalHashtagPlugin.dev.js\") : 0\nmodule.exports = LexicalHashtagPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhhc2h0YWdQbHVnaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWiw2QkFBNkIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLHNHQUErQixJQUFJLENBQXlDO0FBQzFKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhhc2h0YWdQbHVnaW4uanM/MmU3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbEhhc2h0YWdQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbEhhc2h0YWdQbHVnaW4uZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxIYXNodGFnUGx1Z2luLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsSGFzaHRhZ1BsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHashtagPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar history = __webpack_require__(/*! @lexical/history */ \"(ssr)/./node_modules/@lexical/history/LexicalHistory.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useHistory(editor, externalHistoryState, delay = 1000) {\n  const historyState = react.useMemo(() => externalHistoryState || history.createEmptyHistoryState(), [externalHistoryState]);\n  react.useEffect(() => {\n    return history.registerHistory(editor, historyState, delay);\n  }, [delay, editor, historyState]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction HistoryPlugin({\n  externalHistoryState\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useHistory(editor, externalHistoryState);\n  return null;\n}\n\nexports.createEmptyHistoryState = history.createEmptyHistoryState;\nexports.HistoryPlugin = HistoryPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhpc3RvcnlQbHVnaW4uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLDRHQUF1QztBQUM1RSxjQUFjLG1CQUFPLENBQUMsaUZBQWtCO0FBQ3hDLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxIaXN0b3J5UGx1Z2luLmRldi5qcz80ZjNlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciBoaXN0b3J5ID0gcmVxdWlyZSgnQGxleGljYWwvaGlzdG9yeScpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlSGlzdG9yeShlZGl0b3IsIGV4dGVybmFsSGlzdG9yeVN0YXRlLCBkZWxheSA9IDEwMDApIHtcbiAgY29uc3QgaGlzdG9yeVN0YXRlID0gcmVhY3QudXNlTWVtbygoKSA9PiBleHRlcm5hbEhpc3RvcnlTdGF0ZSB8fCBoaXN0b3J5LmNyZWF0ZUVtcHR5SGlzdG9yeVN0YXRlKCksIFtleHRlcm5hbEhpc3RvcnlTdGF0ZV0pO1xuICByZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBoaXN0b3J5LnJlZ2lzdGVySGlzdG9yeShlZGl0b3IsIGhpc3RvcnlTdGF0ZSwgZGVsYXkpO1xuICB9LCBbZGVsYXksIGVkaXRvciwgaGlzdG9yeVN0YXRlXSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIEhpc3RvcnlQbHVnaW4oe1xuICBleHRlcm5hbEhpc3RvcnlTdGF0ZVxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICB1c2VIaXN0b3J5KGVkaXRvciwgZXh0ZXJuYWxIaXN0b3J5U3RhdGUpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5jcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSA9IGhpc3RvcnkuY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGU7XG5leHBvcnRzLkhpc3RvcnlQbHVnaW4gPSBIaXN0b3J5UGx1Z2luO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHistoryPlugin.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHistoryPlugin =  true ? __webpack_require__(/*! ./LexicalHistoryPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.dev.js\") : 0\nmodule.exports = LexicalHistoryPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhpc3RvcnlQbHVnaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWiw2QkFBNkIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLHNHQUErQixJQUFJLENBQXlDO0FBQzFKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhpc3RvcnlQbHVnaW4uanM/NWM3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbEhpc3RvcnlQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbEhpc3RvcnlQbHVnaW4uZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxIaXN0b3J5UGx1Z2luLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsSGlzdG9yeVBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHistoryPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar useLexicalNodeSelection = __webpack_require__(/*! @lexical/react/useLexicalNodeSelection */ \"(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst INSERT_HORIZONTAL_RULE_COMMAND = lexical.createCommand('INSERT_HORIZONTAL_RULE_COMMAND');\n\nfunction HorizontalRuleComponent({\n  nodeKey\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection.useLexicalNodeSelection(nodeKey);\n  const onDelete = React.useCallback(payload => {\n    if (isSelected && lexical.$isNodeSelection(lexical.$getSelection())) {\n      const event = payload;\n      event.preventDefault();\n      const node = lexical.$getNodeByKey(nodeKey);\n\n      if ($isHorizontalRuleNode(node)) {\n        node.remove();\n      }\n\n      setSelected(false);\n    }\n\n    return false;\n  }, [isSelected, nodeKey, setSelected]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, event => {\n      const hrElem = editor.getElementByKey(nodeKey);\n\n      if (event.target === hrElem) {\n        if (!event.shiftKey) {\n          clearSelection();\n        }\n\n        setSelected(!isSelected);\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_DELETE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW));\n  }, [clearSelection, editor, isSelected, nodeKey, onDelete, setSelected]);\n  React.useEffect(() => {\n    const hrElem = editor.getElementByKey(nodeKey);\n\n    if (hrElem !== null) {\n      hrElem.className = isSelected ? 'selected' : '';\n    }\n  }, [editor, isSelected, nodeKey]);\n  return null;\n}\n\nclass HorizontalRuleNode extends lexical.DecoratorNode {\n  static getType() {\n    return 'horizontalrule';\n  }\n\n  static clone(node) {\n    return new HorizontalRuleNode(node.__key);\n  }\n\n  static importJSON(serializedNode) {\n    return $createHorizontalRuleNode();\n  }\n\n  static importDOM() {\n    return {\n      hr: () => ({\n        conversion: convertHorizontalRuleElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportJSON() {\n    return {\n      type: 'horizontalrule',\n      version: 1\n    };\n  }\n\n  exportDOM() {\n    return {\n      element: document.createElement('hr')\n    };\n  }\n\n  createDOM() {\n    return document.createElement('hr');\n  }\n\n  getTextContent() {\n    return '\\n';\n  }\n\n  isInline() {\n    return false;\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  decorate() {\n    return /*#__PURE__*/React.createElement(HorizontalRuleComponent, {\n      nodeKey: this.__key\n    });\n  }\n\n}\n\nfunction convertHorizontalRuleElement() {\n  return {\n    node: $createHorizontalRuleNode()\n  };\n}\n\nfunction $createHorizontalRuleNode() {\n  return lexical.$applyNodeReplacement(new HorizontalRuleNode());\n}\nfunction $isHorizontalRuleNode(node) {\n  return node instanceof HorizontalRuleNode;\n}\n\nexports.$createHorizontalRuleNode = $createHorizontalRuleNode;\nexports.$isHorizontalRuleNode = $isHorizontalRuleNode;\nexports.HorizontalRuleNode = HorizontalRuleNode;\nexports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZS5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsNEdBQXVDO0FBQzVFLDhCQUE4QixtQkFBTyxDQUFDLDhHQUF3QztBQUM5RSxZQUFZLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyx3REFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZS5kZXYuanM/YWRmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24gPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsTm9kZVNlbGVjdGlvbicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnQGxleGljYWwvdXRpbHMnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgSU5TRVJUX0hPUklaT05UQUxfUlVMRV9DT01NQU5EID0gbGV4aWNhbC5jcmVhdGVDb21tYW5kKCdJTlNFUlRfSE9SSVpPTlRBTF9SVUxFX0NPTU1BTkQnKTtcblxuZnVuY3Rpb24gSG9yaXpvbnRhbFJ1bGVDb21wb25lbnQoe1xuICBub2RlS2V5XG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IFtpc1NlbGVjdGVkLCBzZXRTZWxlY3RlZCwgY2xlYXJTZWxlY3Rpb25dID0gdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24udXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24obm9kZUtleSk7XG4gIGNvbnN0IG9uRGVsZXRlID0gUmVhY3QudXNlQ2FsbGJhY2socGF5bG9hZCA9PiB7XG4gICAgaWYgKGlzU2VsZWN0ZWQgJiYgbGV4aWNhbC4kaXNOb2RlU2VsZWN0aW9uKGxleGljYWwuJGdldFNlbGVjdGlvbigpKSkge1xuICAgICAgY29uc3QgZXZlbnQgPSBwYXlsb2FkO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROb2RlQnlLZXkobm9kZUtleSk7XG5cbiAgICAgIGlmICgkaXNIb3Jpem9udGFsUnVsZU5vZGUobm9kZSkpIHtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgc2V0U2VsZWN0ZWQoZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgW2lzU2VsZWN0ZWQsIG5vZGVLZXksIHNldFNlbGVjdGVkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHV0aWxzLm1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkNMSUNLX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGhyRWxlbSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkobm9kZUtleSk7XG5cbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGhyRWxlbSkge1xuICAgICAgICBpZiAoIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFNlbGVjdGVkKCFpc1NlbGVjdGVkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9ERUxFVEVfQ09NTUFORCwgb25EZWxldGUsIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCBvbkRlbGV0ZSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVykpO1xuICB9LCBbY2xlYXJTZWxlY3Rpb24sIGVkaXRvciwgaXNTZWxlY3RlZCwgbm9kZUtleSwgb25EZWxldGUsIHNldFNlbGVjdGVkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaHJFbGVtID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShub2RlS2V5KTtcblxuICAgIGlmIChockVsZW0gIT09IG51bGwpIHtcbiAgICAgIGhyRWxlbS5jbGFzc05hbWUgPSBpc1NlbGVjdGVkID8gJ3NlbGVjdGVkJyA6ICcnO1xuICAgIH1cbiAgfSwgW2VkaXRvciwgaXNTZWxlY3RlZCwgbm9kZUtleV0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuY2xhc3MgSG9yaXpvbnRhbFJ1bGVOb2RlIGV4dGVuZHMgbGV4aWNhbC5EZWNvcmF0b3JOb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdob3Jpem9udGFscnVsZSc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgSG9yaXpvbnRhbFJ1bGVOb2RlKG5vZGUuX19rZXkpO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUhvcml6b250YWxSdWxlTm9kZSgpO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaHI6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRIb3Jpem9udGFsUnVsZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnaG9yaXpvbnRhbHJ1bGUnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cblxuICBleHBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2hyJylcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlRE9NKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdocicpO1xuICB9XG5cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgcmV0dXJuICdcXG4nO1xuICB9XG5cbiAgaXNJbmxpbmUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdXBkYXRlRE9NKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGRlY29yYXRlKCkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChIb3Jpem9udGFsUnVsZUNvbXBvbmVudCwge1xuICAgICAgbm9kZUtleTogdGhpcy5fX2tleVxuICAgIH0pO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gY29udmVydEhvcml6b250YWxSdWxlRWxlbWVudCgpIHtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlSG9yaXpvbnRhbFJ1bGVOb2RlKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gJGNyZWF0ZUhvcml6b250YWxSdWxlTm9kZSgpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBIb3Jpem9udGFsUnVsZU5vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNIb3Jpem9udGFsUnVsZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEhvcml6b250YWxSdWxlTm9kZTtcbn1cblxuZXhwb3J0cy4kY3JlYXRlSG9yaXpvbnRhbFJ1bGVOb2RlID0gJGNyZWF0ZUhvcml6b250YWxSdWxlTm9kZTtcbmV4cG9ydHMuJGlzSG9yaXpvbnRhbFJ1bGVOb2RlID0gJGlzSG9yaXpvbnRhbFJ1bGVOb2RlO1xuZXhwb3J0cy5Ib3Jpem9udGFsUnVsZU5vZGUgPSBIb3Jpem9udGFsUnVsZU5vZGU7XG5leHBvcnRzLklOU0VSVF9IT1JJWk9OVEFMX1JVTEVfQ09NTUFORCA9IElOU0VSVF9IT1JJWk9OVEFMX1JVTEVfQ09NTUFORDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHorizontalRuleNode.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHorizontalRuleNode =  true ? __webpack_require__(/*! ./LexicalHorizontalRuleNode.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js\") : 0\nmodule.exports = LexicalHorizontalRuleNode;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLGtDQUFrQyxLQUFzQyxHQUFHLG1CQUFPLENBQUMsZ0hBQW9DLElBQUksQ0FBOEM7QUFDeksiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsSG9yaXpvbnRhbFJ1bGVOb2RlLmpzPzU4OTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxIb3Jpem9udGFsUnVsZU5vZGUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZS5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZS5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHorizontalRulePlugin.dev.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHorizontalRulePlugin.dev.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar LexicalHorizontalRuleNode = __webpack_require__(/*! @lexical/react/LexicalHorizontalRuleNode */ \"(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction HorizontalRulePlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    return editor.registerCommand(LexicalHorizontalRuleNode.INSERT_HORIZONTAL_RULE_COMMAND, type => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.$isRangeSelection(selection)) {\n        return false;\n      }\n\n      const focusNode = selection.focus.getNode();\n\n      if (focusNode !== null) {\n        const horizontalRuleNode = LexicalHorizontalRuleNode.$createHorizontalRuleNode();\n        utils.$insertNodeToNearestRoot(horizontalRuleNode);\n      }\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR);\n  }, [editor]);\n  return null;\n}\n\nexports.HorizontalRulePlugin = HorizontalRulePlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhvcml6b250YWxSdWxlUGx1Z2luLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsZ0NBQWdDLG1CQUFPLENBQUMsa0hBQTBDO0FBQ2xGLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQSw0QkFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsSG9yaXpvbnRhbFJ1bGVQbHVnaW4uZGV2LmpzP2Q3NWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIExleGljYWxIb3Jpem9udGFsUnVsZU5vZGUgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsSG9yaXpvbnRhbFJ1bGVOb2RlJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG52YXIgcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBIb3Jpem9udGFsUnVsZVBsdWdpbigpIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChMZXhpY2FsSG9yaXpvbnRhbFJ1bGVOb2RlLklOU0VSVF9IT1JJWk9OVEFMX1JVTEVfQ09NTUFORCwgdHlwZSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuXG4gICAgICBpZiAoZm9jdXNOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGhvcml6b250YWxSdWxlTm9kZSA9IExleGljYWxIb3Jpem9udGFsUnVsZU5vZGUuJGNyZWF0ZUhvcml6b250YWxSdWxlTm9kZSgpO1xuICAgICAgICB1dGlscy4kaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3QoaG9yaXpvbnRhbFJ1bGVOb2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUik7XG4gIH0sIFtlZGl0b3JdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydHMuSG9yaXpvbnRhbFJ1bGVQbHVnaW4gPSBIb3Jpem9udGFsUnVsZVBsdWdpbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHorizontalRulePlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalHorizontalRulePlugin.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHorizontalRulePlugin.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalHorizontalRulePlugin =  true ? __webpack_require__(/*! ./LexicalHorizontalRulePlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalHorizontalRulePlugin.dev.js\") : 0\nmodule.exports = LexicalHorizontalRulePlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhvcml6b250YWxSdWxlUGx1Z2luLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osb0NBQW9DLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxvSEFBc0MsSUFBSSxDQUFnRDtBQUMvSyIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxIb3Jpem9udGFsUnVsZVBsdWdpbi5qcz8xOWZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsSG9yaXpvbnRhbFJ1bGVQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbEhvcml6b250YWxSdWxlUGx1Z2luLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsSG9yaXpvbnRhbFJ1bGVQbHVnaW4ucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxIb3Jpem9udGFsUnVsZVBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalHorizontalRulePlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalLinkPlugin.dev.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalLinkPlugin.dev.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar link = __webpack_require__(/*! @lexical/link */ \"(ssr)/./node_modules/@lexical/link/LexicalLink.js\");\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction LinkPlugin({\n  validateUrl\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    if (!editor.hasNodes([link.LinkNode])) {\n      throw new Error('LinkPlugin: LinkNode not registered on editor');\n    }\n\n    return utils.mergeRegister(editor.registerCommand(link.TOGGLE_LINK_COMMAND, payload => {\n      if (payload === null) {\n        link.toggleLink(payload);\n        return true;\n      } else if (typeof payload === 'string') {\n        if (validateUrl === undefined || validateUrl(payload)) {\n          link.toggleLink(payload);\n          return true;\n        }\n\n        return false;\n      } else {\n        const {\n          url,\n          target,\n          rel\n        } = payload;\n        link.toggleLink(url, {\n          rel,\n          target\n        });\n        return true;\n      }\n    }, lexical.COMMAND_PRIORITY_LOW), validateUrl !== undefined ? editor.registerCommand(lexical.PASTE_COMMAND, event => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.$isRangeSelection(selection) || selection.isCollapsed() || !(event instanceof ClipboardEvent) || event.clipboardData == null) {\n        return false;\n      }\n\n      const clipboardText = event.clipboardData.getData('text');\n\n      if (!validateUrl(clipboardText)) {\n        return false;\n      } // If we select nodes that are elements then avoid applying the link.\n\n\n      if (!selection.getNodes().some(node => lexical.$isElementNode(node))) {\n        editor.dispatchCommand(link.TOGGLE_LINK_COMMAND, clipboardText);\n        event.preventDefault();\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW) : () => {// Don't paste arbritrary text as a link when there's no validate function\n    });\n  }, [editor, validateUrl]);\n  return null;\n}\n\nexports.LinkPlugin = LinkPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpbmtQbHVnaW4uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyx3RUFBZTtBQUNsQyw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNwQyxjQUFjLG1CQUFPLENBQUMsd0RBQVM7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLHlDQUF5QztBQUM5QyxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUEsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpbmtQbHVnaW4uZGV2LmpzP2VmMjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsaW5rID0gcmVxdWlyZSgnQGxleGljYWwvbGluaycpO1xudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG52YXIgcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBMaW5rUGx1Z2luKHtcbiAgdmFsaWRhdGVVcmxcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVkaXRvci5oYXNOb2RlcyhbbGluay5MaW5rTm9kZV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpbmtQbHVnaW46IExpbmtOb2RlIG5vdCByZWdpc3RlcmVkIG9uIGVkaXRvcicpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGlscy5tZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGluay5UT0dHTEVfTElOS19DT01NQU5ELCBwYXlsb2FkID0+IHtcbiAgICAgIGlmIChwYXlsb2FkID09PSBudWxsKSB7XG4gICAgICAgIGxpbmsudG9nZ2xlTGluayhwYXlsb2FkKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodmFsaWRhdGVVcmwgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0ZVVybChwYXlsb2FkKSkge1xuICAgICAgICAgIGxpbmsudG9nZ2xlTGluayhwYXlsb2FkKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHJlbFxuICAgICAgICB9ID0gcGF5bG9hZDtcbiAgICAgICAgbGluay50b2dnbGVMaW5rKHVybCwge1xuICAgICAgICAgIHJlbCxcbiAgICAgICAgICB0YXJnZXRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpLCB2YWxpZGF0ZVVybCAhPT0gdW5kZWZpbmVkID8gZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLlBBU1RFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCAhKGV2ZW50IGluc3RhbmNlb2YgQ2xpcGJvYXJkRXZlbnQpIHx8IGV2ZW50LmNsaXBib2FyZERhdGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNsaXBib2FyZFRleHQgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQnKTtcblxuICAgICAgaWYgKCF2YWxpZGF0ZVVybChjbGlwYm9hcmRUZXh0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIElmIHdlIHNlbGVjdCBub2RlcyB0aGF0IGFyZSBlbGVtZW50cyB0aGVuIGF2b2lkIGFwcGx5aW5nIHRoZSBsaW5rLlxuXG5cbiAgICAgIGlmICghc2VsZWN0aW9uLmdldE5vZGVzKCkuc29tZShub2RlID0+IGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkpKSB7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGluay5UT0dHTEVfTElOS19DT01NQU5ELCBjbGlwYm9hcmRUZXh0KTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSA6ICgpID0+IHsvLyBEb24ndCBwYXN0ZSBhcmJyaXRyYXJ5IHRleHQgYXMgYSBsaW5rIHdoZW4gdGhlcmUncyBubyB2YWxpZGF0ZSBmdW5jdGlvblxuICAgIH0pO1xuICB9LCBbZWRpdG9yLCB2YWxpZGF0ZVVybF0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5MaW5rUGx1Z2luID0gTGlua1BsdWdpbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalLinkPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalLinkPlugin.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalLinkPlugin.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalLinkPlugin =  true ? __webpack_require__(/*! ./LexicalLinkPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalLinkPlugin.dev.js\") : 0\nmodule.exports = LexicalLinkPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpbmtQbHVnaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWiwwQkFBMEIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLGdHQUE0QixJQUFJLENBQXNDO0FBQ2pKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpbmtQbHVnaW4uanM/MDMxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbExpbmtQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbExpbmtQbHVnaW4uZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxMaW5rUGx1Z2luLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsTGlua1BsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalLinkPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalListPlugin.dev.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalListPlugin.dev.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar list = __webpack_require__(/*! @lexical/list */ \"(ssr)/./node_modules/@lexical/list/LexicalList.js\");\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useList(editor) {\n  react.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(list.INSERT_ORDERED_LIST_COMMAND, () => {\n      list.insertList(editor, 'number');\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(list.INSERT_UNORDERED_LIST_COMMAND, () => {\n      list.insertList(editor, 'bullet');\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(list.REMOVE_LIST_COMMAND, () => {\n      list.removeList(editor);\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n      const hasHandledInsertParagraph = list.$handleListInsertParagraph();\n\n      if (hasHandledInsertParagraph) {\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW));\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction ListPlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    if (!editor.hasNodes([list.ListNode, list.ListItemNode])) {\n      throw new Error('ListPlugin: ListNode and/or ListItemNode not registered on editor');\n    }\n  }, [editor]);\n  useList(editor);\n  return null;\n}\n\nexports.ListPlugin = ListPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpc3RQbHVnaW4uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyx3RUFBZTtBQUNsQyw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsWUFBWSxtQkFBTyxDQUFDLHdHQUFPO0FBQzNCLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLHdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxMaXN0UGx1Z2luLmRldi5qcz9mNDU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGlzdCA9IHJlcXVpcmUoJ0BsZXhpY2FsL2xpc3QnKTtcbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlTGlzdChlZGl0b3IpIHtcbiAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gdXRpbHMubWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxpc3QuSU5TRVJUX09SREVSRURfTElTVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgICBsaXN0Lmluc2VydExpc3QoZWRpdG9yLCAnbnVtYmVyJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsaXN0LklOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgICBsaXN0Lmluc2VydExpc3QoZWRpdG9yLCAnYnVsbGV0Jyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsaXN0LlJFTU9WRV9MSVNUX0NPTU1BTkQsICgpID0+IHtcbiAgICAgIGxpc3QucmVtb3ZlTGlzdChlZGl0b3IpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5JTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsICgpID0+IHtcbiAgICAgIGNvbnN0IGhhc0hhbmRsZWRJbnNlcnRQYXJhZ3JhcGggPSBsaXN0LiRoYW5kbGVMaXN0SW5zZXJ0UGFyYWdyYXBoKCk7XG5cbiAgICAgIGlmIChoYXNIYW5kbGVkSW5zZXJ0UGFyYWdyYXBoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVykpO1xuICB9LCBbZWRpdG9yXSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIExpc3RQbHVnaW4oKSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIHJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlZGl0b3IuaGFzTm9kZXMoW2xpc3QuTGlzdE5vZGUsIGxpc3QuTGlzdEl0ZW1Ob2RlXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTGlzdFBsdWdpbjogTGlzdE5vZGUgYW5kL29yIExpc3RJdGVtTm9kZSBub3QgcmVnaXN0ZXJlZCBvbiBlZGl0b3InKTtcbiAgICB9XG4gIH0sIFtlZGl0b3JdKTtcbiAgdXNlTGlzdChlZGl0b3IpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5MaXN0UGx1Z2luID0gTGlzdFBsdWdpbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalListPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalListPlugin.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalListPlugin.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalListPlugin =  true ? __webpack_require__(/*! ./LexicalListPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalListPlugin.dev.js\") : 0\nmodule.exports = LexicalListPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpc3RQbHVnaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWiwwQkFBMEIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLGdHQUE0QixJQUFJLENBQXNDO0FBQ2pKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbExpc3RQbHVnaW4uanM/NGExMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbExpc3RQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbExpc3RQbHVnaW4uZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxMaXN0UGx1Z2luLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsTGlzdFBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalListPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar markdown = __webpack_require__(/*! @lexical/markdown */ \"(ssr)/./node_modules/@lexical/markdown/LexicalMarkdown.js\");\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar LexicalHorizontalRuleNode = __webpack_require__(/*! @lexical/react/LexicalHorizontalRuleNode */ \"(ssr)/./node_modules/@lexical/react/LexicalHorizontalRuleNode.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst HR = {\n  dependencies: [LexicalHorizontalRuleNode.HorizontalRuleNode],\n  export: node => {\n    return LexicalHorizontalRuleNode.$isHorizontalRuleNode(node) ? '***' : null;\n  },\n  regExp: /^(---|\\*\\*\\*|___)\\s?$/,\n  replace: (parentNode, _1, _2, isImport) => {\n    const line = LexicalHorizontalRuleNode.$createHorizontalRuleNode(); // TODO: Get rid of isImport flag\n\n    if (isImport || parentNode.getNextSibling() != null) {\n      parentNode.replace(line);\n    } else {\n      parentNode.insertBefore(line);\n    }\n\n    line.selectNext();\n  },\n  type: 'element'\n};\nconst DEFAULT_TRANSFORMERS = [HR, ...markdown.TRANSFORMERS];\nfunction MarkdownShortcutPlugin({\n  transformers = DEFAULT_TRANSFORMERS\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    return markdown.registerMarkdownShortcuts(editor, transformers);\n  }, [editor, transformers]);\n  return null;\n}\n\nexports.DEFAULT_TRANSFORMERS = DEFAULT_TRANSFORMERS;\nexports.MarkdownShortcutPlugin = MarkdownShortcutPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE1hcmtkb3duU2hvcnRjdXRQbHVnaW4uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxvRkFBbUI7QUFDMUMsNkJBQTZCLG1CQUFPLENBQUMsNEdBQXVDO0FBQzVFLGdDQUFnQyxtQkFBTyxDQUFDLGtIQUEwQztBQUNsRixZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdFQUF3RTs7QUFFeEU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCLDhCQUE4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxNYXJrZG93blNob3J0Y3V0UGx1Z2luLmRldi5qcz9lNTJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFya2Rvd24gPSByZXF1aXJlKCdAbGV4aWNhbC9tYXJrZG93bicpO1xudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZSA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxIb3Jpem9udGFsUnVsZU5vZGUnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IEhSID0ge1xuICBkZXBlbmRlbmNpZXM6IFtMZXhpY2FsSG9yaXpvbnRhbFJ1bGVOb2RlLkhvcml6b250YWxSdWxlTm9kZV0sXG4gIGV4cG9ydDogbm9kZSA9PiB7XG4gICAgcmV0dXJuIExleGljYWxIb3Jpem9udGFsUnVsZU5vZGUuJGlzSG9yaXpvbnRhbFJ1bGVOb2RlKG5vZGUpID8gJyoqKicgOiBudWxsO1xuICB9LFxuICByZWdFeHA6IC9eKC0tLXxcXCpcXCpcXCp8X19fKVxccz8kLyxcbiAgcmVwbGFjZTogKHBhcmVudE5vZGUsIF8xLCBfMiwgaXNJbXBvcnQpID0+IHtcbiAgICBjb25zdCBsaW5lID0gTGV4aWNhbEhvcml6b250YWxSdWxlTm9kZS4kY3JlYXRlSG9yaXpvbnRhbFJ1bGVOb2RlKCk7IC8vIFRPRE86IEdldCByaWQgb2YgaXNJbXBvcnQgZmxhZ1xuXG4gICAgaWYgKGlzSW1wb3J0IHx8IHBhcmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKSAhPSBudWxsKSB7XG4gICAgICBwYXJlbnROb2RlLnJlcGxhY2UobGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGxpbmUpO1xuICAgIH1cblxuICAgIGxpbmUuc2VsZWN0TmV4dCgpO1xuICB9LFxuICB0eXBlOiAnZWxlbWVudCdcbn07XG5jb25zdCBERUZBVUxUX1RSQU5TRk9STUVSUyA9IFtIUiwgLi4ubWFya2Rvd24uVFJBTlNGT1JNRVJTXTtcbmZ1bmN0aW9uIE1hcmtkb3duU2hvcnRjdXRQbHVnaW4oe1xuICB0cmFuc2Zvcm1lcnMgPSBERUZBVUxUX1RSQU5TRk9STUVSU1xufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICByZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBtYXJrZG93bi5yZWdpc3Rlck1hcmtkb3duU2hvcnRjdXRzKGVkaXRvciwgdHJhbnNmb3JtZXJzKTtcbiAgfSwgW2VkaXRvciwgdHJhbnNmb3JtZXJzXSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLkRFRkFVTFRfVFJBTlNGT1JNRVJTID0gREVGQVVMVF9UUkFOU0ZPUk1FUlM7XG5leHBvcnRzLk1hcmtkb3duU2hvcnRjdXRQbHVnaW4gPSBNYXJrZG93blNob3J0Y3V0UGx1Z2luO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalMarkdownShortcutPlugin =  true ? __webpack_require__(/*! ./LexicalMarkdownShortcutPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.dev.js\") : 0\nmodule.exports = LexicalMarkdownShortcutPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE1hcmtkb3duU2hvcnRjdXRQbHVnaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWixzQ0FBc0MsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLHdIQUF3QyxJQUFJLENBQWtEO0FBQ3JMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE1hcmtkb3duU2hvcnRjdXRQbHVnaW4uanM/OTYyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbE1hcmtkb3duU2hvcnRjdXRQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbE1hcmtkb3duU2hvcnRjdXRQbHVnaW4uZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxNYXJrZG93blNob3J0Y3V0UGx1Z2luLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsTWFya2Rvd25TaG9ydGN1dFBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalMarkdownShortcutPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalNestedComposer.dev.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalNestedComposer.dev.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalCollaborationContext = __webpack_require__(/*! @lexical/react/LexicalCollaborationContext */ \"(ssr)/./node_modules/@lexical/react/LexicalCollaborationContext.js\");\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction LexicalNestedComposer({\n  initialEditor,\n  children,\n  initialNodes,\n  initialTheme,\n  skipCollabChecks\n}) {\n  const wasCollabPreviouslyReadyRef = React.useRef(false);\n  const parentContext = React.useContext(LexicalComposerContext.LexicalComposerContext);\n\n  if (parentContext == null) {\n    {\n      throw Error(`Unexpected parent context null on a nested composer`);\n    }\n  }\n\n  const [parentEditor, {\n    getTheme: getParentTheme\n  }] = parentContext;\n  const composerContext = React.useMemo(() => {\n    const composerTheme = initialTheme || getParentTheme() || undefined;\n    const context = LexicalComposerContext.createLexicalComposerContext(parentContext, composerTheme);\n\n    if (composerTheme !== undefined) {\n      initialEditor._config.theme = composerTheme;\n    }\n\n    initialEditor._parentEditor = parentEditor;\n\n    if (!initialNodes) {\n      const parentNodes = initialEditor._nodes = new Map(parentEditor._nodes);\n\n      for (const [type, entry] of parentNodes) {\n        initialEditor._nodes.set(type, {\n          klass: entry.klass,\n          replace: entry.replace,\n          replaceWithKlass: entry.replaceWithKlass,\n          transforms: new Set()\n        });\n      }\n    } else {\n      for (const klass of initialNodes) {\n        const type = klass.getType();\n\n        initialEditor._nodes.set(type, {\n          klass,\n          replace: null,\n          replaceWithKlass: null,\n          transforms: new Set()\n        });\n      }\n    }\n\n    initialEditor._config.namespace = parentEditor._config.namespace;\n    initialEditor._editable = parentEditor._editable;\n    return [initialEditor, context];\n  }, // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []); // If collaboration is enabled, make sure we don't render the children until the collaboration subdocument is ready.\n\n  const {\n    isCollabActive,\n    yjsDocMap\n  } = LexicalCollaborationContext.useCollaborationContext();\n  const isCollabReady = skipCollabChecks || wasCollabPreviouslyReadyRef.current || yjsDocMap.has(initialEditor.getKey());\n  React.useEffect(() => {\n    if (isCollabReady) {\n      wasCollabPreviouslyReadyRef.current = true;\n    }\n  }, [isCollabReady]); // Update `isEditable` state of nested editor in response to the same change on parent editor.\n\n  React.useEffect(() => {\n    return parentEditor.registerEditableListener(editable => {\n      initialEditor.setEditable(editable);\n    });\n  }, [initialEditor, parentEditor]);\n  return /*#__PURE__*/React.createElement(LexicalComposerContext.LexicalComposerContext.Provider, {\n    value: composerContext\n  }, !isCollabActive || isCollabReady ? children : null);\n}\n\nexports.LexicalNestedComposer = LexicalNestedComposer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE5lc3RlZENvbXBvc2VyLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixrQ0FBa0MsbUJBQU8sQ0FBQyxzSEFBNEM7QUFDdEYsNkJBQTZCLG1CQUFPLENBQUMsNEdBQXVDO0FBQzVFLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQkFBb0I7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsTmVzdGVkQ29tcG9zZXIuZGV2LmpzP2Y5ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMZXhpY2FsQ29sbGFib3JhdGlvbkNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29sbGFib3JhdGlvbkNvbnRleHQnKTtcbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gTGV4aWNhbE5lc3RlZENvbXBvc2VyKHtcbiAgaW5pdGlhbEVkaXRvcixcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxOb2RlcyxcbiAgaW5pdGlhbFRoZW1lLFxuICBza2lwQ29sbGFiQ2hlY2tzXG59KSB7XG4gIGNvbnN0IHdhc0NvbGxhYlByZXZpb3VzbHlSZWFkeVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHBhcmVudENvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KExleGljYWxDb21wb3NlckNvbnRleHQuTGV4aWNhbENvbXBvc2VyQ29udGV4dCk7XG5cbiAgaWYgKHBhcmVudENvbnRleHQgPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBVbmV4cGVjdGVkIHBhcmVudCBjb250ZXh0IG51bGwgb24gYSBuZXN0ZWQgY29tcG9zZXJgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBbcGFyZW50RWRpdG9yLCB7XG4gICAgZ2V0VGhlbWU6IGdldFBhcmVudFRoZW1lXG4gIH1dID0gcGFyZW50Q29udGV4dDtcbiAgY29uc3QgY29tcG9zZXJDb250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgY29tcG9zZXJUaGVtZSA9IGluaXRpYWxUaGVtZSB8fCBnZXRQYXJlbnRUaGVtZSgpIHx8IHVuZGVmaW5lZDtcbiAgICBjb25zdCBjb250ZXh0ID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC5jcmVhdGVMZXhpY2FsQ29tcG9zZXJDb250ZXh0KHBhcmVudENvbnRleHQsIGNvbXBvc2VyVGhlbWUpO1xuXG4gICAgaWYgKGNvbXBvc2VyVGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5pdGlhbEVkaXRvci5fY29uZmlnLnRoZW1lID0gY29tcG9zZXJUaGVtZTtcbiAgICB9XG5cbiAgICBpbml0aWFsRWRpdG9yLl9wYXJlbnRFZGl0b3IgPSBwYXJlbnRFZGl0b3I7XG5cbiAgICBpZiAoIWluaXRpYWxOb2Rlcykge1xuICAgICAgY29uc3QgcGFyZW50Tm9kZXMgPSBpbml0aWFsRWRpdG9yLl9ub2RlcyA9IG5ldyBNYXAocGFyZW50RWRpdG9yLl9ub2Rlcyk7XG5cbiAgICAgIGZvciAoY29uc3QgW3R5cGUsIGVudHJ5XSBvZiBwYXJlbnROb2Rlcykge1xuICAgICAgICBpbml0aWFsRWRpdG9yLl9ub2Rlcy5zZXQodHlwZSwge1xuICAgICAgICAgIGtsYXNzOiBlbnRyeS5rbGFzcyxcbiAgICAgICAgICByZXBsYWNlOiBlbnRyeS5yZXBsYWNlLFxuICAgICAgICAgIHJlcGxhY2VXaXRoS2xhc3M6IGVudHJ5LnJlcGxhY2VXaXRoS2xhc3MsXG4gICAgICAgICAgdHJhbnNmb3JtczogbmV3IFNldCgpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGtsYXNzIG9mIGluaXRpYWxOb2Rlcykge1xuICAgICAgICBjb25zdCB0eXBlID0ga2xhc3MuZ2V0VHlwZSgpO1xuXG4gICAgICAgIGluaXRpYWxFZGl0b3IuX25vZGVzLnNldCh0eXBlLCB7XG4gICAgICAgICAga2xhc3MsXG4gICAgICAgICAgcmVwbGFjZTogbnVsbCxcbiAgICAgICAgICByZXBsYWNlV2l0aEtsYXNzOiBudWxsLFxuICAgICAgICAgIHRyYW5zZm9ybXM6IG5ldyBTZXQoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0aWFsRWRpdG9yLl9jb25maWcubmFtZXNwYWNlID0gcGFyZW50RWRpdG9yLl9jb25maWcubmFtZXNwYWNlO1xuICAgIGluaXRpYWxFZGl0b3IuX2VkaXRhYmxlID0gcGFyZW50RWRpdG9yLl9lZGl0YWJsZTtcbiAgICByZXR1cm4gW2luaXRpYWxFZGl0b3IsIGNvbnRleHRdO1xuICB9LCAvLyBXZSBvbmx5IGRvIHRoaXMgZm9yIGluaXRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbXSk7IC8vIElmIGNvbGxhYm9yYXRpb24gaXMgZW5hYmxlZCwgbWFrZSBzdXJlIHdlIGRvbid0IHJlbmRlciB0aGUgY2hpbGRyZW4gdW50aWwgdGhlIGNvbGxhYm9yYXRpb24gc3ViZG9jdW1lbnQgaXMgcmVhZHkuXG5cbiAgY29uc3Qge1xuICAgIGlzQ29sbGFiQWN0aXZlLFxuICAgIHlqc0RvY01hcFxuICB9ID0gTGV4aWNhbENvbGxhYm9yYXRpb25Db250ZXh0LnVzZUNvbGxhYm9yYXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IGlzQ29sbGFiUmVhZHkgPSBza2lwQ29sbGFiQ2hlY2tzIHx8IHdhc0NvbGxhYlByZXZpb3VzbHlSZWFkeVJlZi5jdXJyZW50IHx8IHlqc0RvY01hcC5oYXMoaW5pdGlhbEVkaXRvci5nZXRLZXkoKSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzQ29sbGFiUmVhZHkpIHtcbiAgICAgIHdhc0NvbGxhYlByZXZpb3VzbHlSZWFkeVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtpc0NvbGxhYlJlYWR5XSk7IC8vIFVwZGF0ZSBgaXNFZGl0YWJsZWAgc3RhdGUgb2YgbmVzdGVkIGVkaXRvciBpbiByZXNwb25zZSB0byB0aGUgc2FtZSBjaGFuZ2Ugb24gcGFyZW50IGVkaXRvci5cblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBwYXJlbnRFZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKGVkaXRhYmxlID0+IHtcbiAgICAgIGluaXRpYWxFZGl0b3Iuc2V0RWRpdGFibGUoZWRpdGFibGUpO1xuICAgIH0pO1xuICB9LCBbaW5pdGlhbEVkaXRvciwgcGFyZW50RWRpdG9yXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMZXhpY2FsQ29tcG9zZXJDb250ZXh0LkxleGljYWxDb21wb3NlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29tcG9zZXJDb250ZXh0XG4gIH0sICFpc0NvbGxhYkFjdGl2ZSB8fCBpc0NvbGxhYlJlYWR5ID8gY2hpbGRyZW4gOiBudWxsKTtcbn1cblxuZXhwb3J0cy5MZXhpY2FsTmVzdGVkQ29tcG9zZXIgPSBMZXhpY2FsTmVzdGVkQ29tcG9zZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalNestedComposer.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalNestedComposer.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalNestedComposer.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalNestedComposer =  true ? __webpack_require__(/*! ./LexicalNestedComposer.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalNestedComposer.dev.js\") : 0\nmodule.exports = LexicalNestedComposer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE5lc3RlZENvbXBvc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osOEJBQThCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyx3R0FBZ0MsSUFBSSxDQUEwQztBQUM3SiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxOZXN0ZWRDb21wb3Nlci5qcz8yNDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsTmVzdGVkQ29tcG9zZXIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbE5lc3RlZENvbXBvc2VyLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsTmVzdGVkQ29tcG9zZXIucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxOZXN0ZWRDb21wb3NlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalNestedComposer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalPlainTextPlugin.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalPlainTextPlugin.dev.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar useLexicalEditable = __webpack_require__(/*! @lexical/react/useLexicalEditable */ \"(ssr)/./node_modules/@lexical/react/useLexicalEditable.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar text = __webpack_require__(/*! @lexical/text */ \"(ssr)/./node_modules/@lexical/text/LexicalText.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar reactDom = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar dragon = __webpack_require__(/*! @lexical/dragon */ \"(ssr)/./node_modules/@lexical/dragon/LexicalDragon.js\");\nvar plainText = __webpack_require__(/*! @lexical/plain-text */ \"(ssr)/./node_modules/@lexical/plain-text/LexicalPlainText.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read(text.$canShowPlaceholderCurry(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\n\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = React.useState(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffect(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n\n    resetCanShowPlaceholder();\n    return utils.mergeRegister(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useDecorators(editor, ErrorBoundary) {\n  const [decorators, setDecorators] = React.useState(() => editor.getDecorators()); // Subscribe to changes\n\n  useLayoutEffect(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      reactDom.flushSync(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]);\n  React.useEffect(() => {\n    // If the content editable mounts before the subscription is added, then\n    // nothing will be rendered on initial pass. We can get around that by\n    // ensuring that we set the value.\n    setDecorators(editor.getDecorators());\n  }, [editor]); // Return decorators defined as React Portals\n\n  return React.useMemo(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = /*#__PURE__*/React.createElement(ErrorBoundary, {\n        onError: e => editor._onError(e)\n      }, /*#__PURE__*/React.createElement(React.Suspense, {\n        fallback: null\n      }, decorators[nodeKey]));\n      const element = editor.getElementByKey(nodeKey);\n\n      if (element !== null) {\n        decoratedPortals.push( /*#__PURE__*/reactDom.createPortal(reactDecorator, element));\n      }\n    }\n\n    return decoratedPortals;\n  }, [ErrorBoundary, decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction usePlainTextSetup(editor) {\n  useLayoutEffect(() => {\n    return utils.mergeRegister(plainText.registerPlainText(editor), dragon.registerDragonSupport(editor)); // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction PlainTextPlugin({\n  contentEditable,\n  placeholder,\n  ErrorBoundary\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const decorators = useDecorators(editor, ErrorBoundary);\n  usePlainTextSetup(editor);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, contentEditable, /*#__PURE__*/React.createElement(Placeholder, {\n    content: placeholder\n  }), decorators);\n}\n\nfunction Placeholder({\n  content\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const editable = useLexicalEditable();\n\n  if (!showPlaceholder) {\n    return null;\n  }\n\n  if (typeof content === 'function') {\n    return content(editable);\n  } else {\n    return content;\n  }\n}\n\nexports.PlainTextPlugin = PlainTextPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFBsYWluVGV4dFBsdWdpbi5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsNEdBQXVDO0FBQzVFLHlCQUF5QixtQkFBTyxDQUFDLG9HQUFtQztBQUNwRSxZQUFZLG1CQUFPLENBQUMsd0dBQU87QUFDM0IsV0FBVyxtQkFBTyxDQUFDLHdFQUFlO0FBQ2xDLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7QUFDcEMsZUFBZSxtQkFBTyxDQUFDLGdIQUFXO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMseUZBQXFCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjs7QUFFcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhOztBQUVoQjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFBsYWluVGV4dFBsdWdpbi5kZXYuanM/ZDE5OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgdXNlTGV4aWNhbEVkaXRhYmxlID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIHRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC90ZXh0Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIHJlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG52YXIgZHJhZ29uID0gcmVxdWlyZSgnQGxleGljYWwvZHJhZ29uJyk7XG52YXIgcGxhaW5UZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcGxhaW4tdGV4dCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IHVzZUxheW91dEVmZmVjdEltcGwgPSBDQU5fVVNFX0RPTSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbnZhciB1c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3RJbXBsO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKSB7XG4gIGNvbnN0IGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXIgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKHRleHQuJGNhblNob3dQbGFjZWhvbGRlckN1cnJ5KGVkaXRvci5pc0NvbXBvc2luZygpKSk7XG4gIHJldHVybiBjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyO1xufVxuXG5mdW5jdGlvbiB1c2VDYW5TaG93UGxhY2Vob2xkZXIoZWRpdG9yKSB7XG4gIGNvbnN0IFtjYW5TaG93UGxhY2Vob2xkZXIsIHNldENhblNob3dQbGFjZWhvbGRlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjYW5TaG93UGxhY2Vob2xkZXJGcm9tQ3VycmVudEVkaXRvclN0YXRlKGVkaXRvcikpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCkge1xuICAgICAgY29uc3QgY3VycmVudENhblNob3dQbGFjZWhvbGRlciA9IGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKTtcbiAgICAgIHNldENhblNob3dQbGFjZWhvbGRlcihjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyKTtcbiAgICB9XG5cbiAgICByZXNldENhblNob3dQbGFjZWhvbGRlcigpO1xuICAgIHJldHVybiB1dGlscy5tZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCk7XG4gICAgfSksIGVkaXRvci5yZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgcmVzZXRDYW5TaG93UGxhY2Vob2xkZXIoKTtcbiAgICB9KSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgcmV0dXJuIGNhblNob3dQbGFjZWhvbGRlcjtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlRGVjb3JhdG9ycyhlZGl0b3IsIEVycm9yQm91bmRhcnkpIHtcbiAgY29uc3QgW2RlY29yYXRvcnMsIHNldERlY29yYXRvcnNdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gZWRpdG9yLmdldERlY29yYXRvcnMoKSk7IC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzXG5cbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyRGVjb3JhdG9yTGlzdGVuZXIobmV4dERlY29yYXRvcnMgPT4ge1xuICAgICAgcmVhY3REb20uZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgc2V0RGVjb3JhdG9ycyhuZXh0RGVjb3JhdG9ycyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgW2VkaXRvcl0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElmIHRoZSBjb250ZW50IGVkaXRhYmxlIG1vdW50cyBiZWZvcmUgdGhlIHN1YnNjcmlwdGlvbiBpcyBhZGRlZCwgdGhlblxuICAgIC8vIG5vdGhpbmcgd2lsbCBiZSByZW5kZXJlZCBvbiBpbml0aWFsIHBhc3MuIFdlIGNhbiBnZXQgYXJvdW5kIHRoYXQgYnlcbiAgICAvLyBlbnN1cmluZyB0aGF0IHdlIHNldCB0aGUgdmFsdWUuXG4gICAgc2V0RGVjb3JhdG9ycyhlZGl0b3IuZ2V0RGVjb3JhdG9ycygpKTtcbiAgfSwgW2VkaXRvcl0pOyAvLyBSZXR1cm4gZGVjb3JhdG9ycyBkZWZpbmVkIGFzIFJlYWN0IFBvcnRhbHNcblxuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgZGVjb3JhdGVkUG9ydGFscyA9IFtdO1xuICAgIGNvbnN0IGRlY29yYXRvcktleXMgPSBPYmplY3Qua2V5cyhkZWNvcmF0b3JzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb3JhdG9yS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZUtleSA9IGRlY29yYXRvcktleXNbaV07XG4gICAgICBjb25zdCByZWFjdERlY29yYXRvciA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIHtcbiAgICAgICAgb25FcnJvcjogZSA9PiBlZGl0b3IuX29uRXJyb3IoZSlcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LlN1c3BlbnNlLCB7XG4gICAgICAgIGZhbGxiYWNrOiBudWxsXG4gICAgICB9LCBkZWNvcmF0b3JzW25vZGVLZXldKSk7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShub2RlS2V5KTtcblxuICAgICAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgZGVjb3JhdGVkUG9ydGFscy5wdXNoKCAvKiNfX1BVUkVfXyovcmVhY3REb20uY3JlYXRlUG9ydGFsKHJlYWN0RGVjb3JhdG9yLCBlbGVtZW50KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY29yYXRlZFBvcnRhbHM7XG4gIH0sIFtFcnJvckJvdW5kYXJ5LCBkZWNvcmF0b3JzLCBlZGl0b3JdKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlUGxhaW5UZXh0U2V0dXAoZWRpdG9yKSB7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHV0aWxzLm1lcmdlUmVnaXN0ZXIocGxhaW5UZXh0LnJlZ2lzdGVyUGxhaW5UZXh0KGVkaXRvciksIGRyYWdvbi5yZWdpc3RlckRyYWdvblN1cHBvcnQoZWRpdG9yKSk7IC8vIFdlIG9ubHkgZG8gdGhpcyBmb3IgaW5pdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2VkaXRvcl0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBQbGFpblRleHRQbHVnaW4oe1xuICBjb250ZW50RWRpdGFibGUsXG4gIHBsYWNlaG9sZGVyLFxuICBFcnJvckJvdW5kYXJ5XG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IGRlY29yYXRvcnMgPSB1c2VEZWNvcmF0b3JzKGVkaXRvciwgRXJyb3JCb3VuZGFyeSk7XG4gIHVzZVBsYWluVGV4dFNldHVwKGVkaXRvcik7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY29udGVudEVkaXRhYmxlLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQbGFjZWhvbGRlciwge1xuICAgIGNvbnRlbnQ6IHBsYWNlaG9sZGVyXG4gIH0pLCBkZWNvcmF0b3JzKTtcbn1cblxuZnVuY3Rpb24gUGxhY2Vob2xkZXIoe1xuICBjb250ZW50XG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IHNob3dQbGFjZWhvbGRlciA9IHVzZUNhblNob3dQbGFjZWhvbGRlcihlZGl0b3IpO1xuICBjb25zdCBlZGl0YWJsZSA9IHVzZUxleGljYWxFZGl0YWJsZSgpO1xuXG4gIGlmICghc2hvd1BsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY29udGVudChlZGl0YWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbn1cblxuZXhwb3J0cy5QbGFpblRleHRQbHVnaW4gPSBQbGFpblRleHRQbHVnaW47XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalPlainTextPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalPlainTextPlugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalPlainTextPlugin.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalPlainTextPlugin =  true ? __webpack_require__(/*! ./LexicalPlainTextPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalPlainTextPlugin.dev.js\") : 0\nmodule.exports = LexicalPlainTextPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFBsYWluVGV4dFBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLCtCQUErQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsMEdBQWlDLElBQUksQ0FBMkM7QUFDaEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsUGxhaW5UZXh0UGx1Z2luLmpzPzYzOTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxQbGFpblRleHRQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFBsYWluVGV4dFBsdWdpbi5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbFBsYWluVGV4dFBsdWdpbi5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbFBsYWluVGV4dFBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalPlainTextPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar useLexicalEditable = __webpack_require__(/*! @lexical/react/useLexicalEditable */ \"(ssr)/./node_modules/@lexical/react/useLexicalEditable.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar text = __webpack_require__(/*! @lexical/text */ \"(ssr)/./node_modules/@lexical/text/LexicalText.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar reactDom = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar dragon = __webpack_require__(/*! @lexical/dragon */ \"(ssr)/./node_modules/@lexical/dragon/LexicalDragon.js\");\nvar richText = __webpack_require__(/*! @lexical/rich-text */ \"(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read(text.$canShowPlaceholderCurry(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\n\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = React.useState(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffect(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n\n    resetCanShowPlaceholder();\n    return utils.mergeRegister(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useDecorators(editor, ErrorBoundary) {\n  const [decorators, setDecorators] = React.useState(() => editor.getDecorators()); // Subscribe to changes\n\n  useLayoutEffect(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      reactDom.flushSync(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]);\n  React.useEffect(() => {\n    // If the content editable mounts before the subscription is added, then\n    // nothing will be rendered on initial pass. We can get around that by\n    // ensuring that we set the value.\n    setDecorators(editor.getDecorators());\n  }, [editor]); // Return decorators defined as React Portals\n\n  return React.useMemo(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = /*#__PURE__*/React.createElement(ErrorBoundary, {\n        onError: e => editor._onError(e)\n      }, /*#__PURE__*/React.createElement(React.Suspense, {\n        fallback: null\n      }, decorators[nodeKey]));\n      const element = editor.getElementByKey(nodeKey);\n\n      if (element !== null) {\n        decoratedPortals.push( /*#__PURE__*/reactDom.createPortal(reactDecorator, element));\n      }\n    }\n\n    return decoratedPortals;\n  }, [ErrorBoundary, decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useRichTextSetup(editor) {\n  useLayoutEffect(() => {\n    return utils.mergeRegister(richText.registerRichText(editor), dragon.registerDragonSupport(editor)); // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction RichTextPlugin({\n  contentEditable,\n  placeholder,\n  ErrorBoundary\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const decorators = useDecorators(editor, ErrorBoundary);\n  useRichTextSetup(editor);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, contentEditable, /*#__PURE__*/React.createElement(Placeholder, {\n    content: placeholder\n  }), decorators);\n}\n\nfunction Placeholder({\n  content\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const editable = useLexicalEditable();\n\n  if (!showPlaceholder) {\n    return null;\n  }\n\n  if (typeof content === 'function') {\n    return content(editable);\n  } else {\n    return content;\n  }\n}\n\nexports.RichTextPlugin = RichTextPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFJpY2hUZXh0UGx1Z2luLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUseUJBQXlCLG1CQUFPLENBQUMsb0dBQW1DO0FBQ3BFLFlBQVksbUJBQU8sQ0FBQyx3R0FBTztBQUMzQixXQUFXLG1CQUFPLENBQUMsd0VBQWU7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNwQyxlQUFlLG1CQUFPLENBQUMsZ0hBQVc7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLDhFQUFpQjtBQUN0QyxlQUFlLG1CQUFPLENBQUMsc0ZBQW9COztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjs7QUFFcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxhQUFhOztBQUVoQjtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFJpY2hUZXh0UGx1Z2luLmRldi5qcz85N2UzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciB1c2VMZXhpY2FsRWRpdGFibGUgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsRWRpdGFibGUnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgdGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3RleHQnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG52YXIgcmVhY3REb20gPSByZXF1aXJlKCdyZWFjdC1kb20nKTtcbnZhciBkcmFnb24gPSByZXF1aXJlKCdAbGV4aWNhbC9kcmFnb24nKTtcbnZhciByaWNoVGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JpY2gtdGV4dCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IHVzZUxheW91dEVmZmVjdEltcGwgPSBDQU5fVVNFX0RPTSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbnZhciB1c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3RJbXBsO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKSB7XG4gIGNvbnN0IGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXIgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKHRleHQuJGNhblNob3dQbGFjZWhvbGRlckN1cnJ5KGVkaXRvci5pc0NvbXBvc2luZygpKSk7XG4gIHJldHVybiBjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyO1xufVxuXG5mdW5jdGlvbiB1c2VDYW5TaG93UGxhY2Vob2xkZXIoZWRpdG9yKSB7XG4gIGNvbnN0IFtjYW5TaG93UGxhY2Vob2xkZXIsIHNldENhblNob3dQbGFjZWhvbGRlcl0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjYW5TaG93UGxhY2Vob2xkZXJGcm9tQ3VycmVudEVkaXRvclN0YXRlKGVkaXRvcikpO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCkge1xuICAgICAgY29uc3QgY3VycmVudENhblNob3dQbGFjZWhvbGRlciA9IGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKTtcbiAgICAgIHNldENhblNob3dQbGFjZWhvbGRlcihjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyKTtcbiAgICB9XG5cbiAgICByZXNldENhblNob3dQbGFjZWhvbGRlcigpO1xuICAgIHJldHVybiB1dGlscy5tZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCk7XG4gICAgfSksIGVkaXRvci5yZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgcmVzZXRDYW5TaG93UGxhY2Vob2xkZXIoKTtcbiAgICB9KSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgcmV0dXJuIGNhblNob3dQbGFjZWhvbGRlcjtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlRGVjb3JhdG9ycyhlZGl0b3IsIEVycm9yQm91bmRhcnkpIHtcbiAgY29uc3QgW2RlY29yYXRvcnMsIHNldERlY29yYXRvcnNdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gZWRpdG9yLmdldERlY29yYXRvcnMoKSk7IC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzXG5cbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyRGVjb3JhdG9yTGlzdGVuZXIobmV4dERlY29yYXRvcnMgPT4ge1xuICAgICAgcmVhY3REb20uZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgc2V0RGVjb3JhdG9ycyhuZXh0RGVjb3JhdG9ycyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgW2VkaXRvcl0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElmIHRoZSBjb250ZW50IGVkaXRhYmxlIG1vdW50cyBiZWZvcmUgdGhlIHN1YnNjcmlwdGlvbiBpcyBhZGRlZCwgdGhlblxuICAgIC8vIG5vdGhpbmcgd2lsbCBiZSByZW5kZXJlZCBvbiBpbml0aWFsIHBhc3MuIFdlIGNhbiBnZXQgYXJvdW5kIHRoYXQgYnlcbiAgICAvLyBlbnN1cmluZyB0aGF0IHdlIHNldCB0aGUgdmFsdWUuXG4gICAgc2V0RGVjb3JhdG9ycyhlZGl0b3IuZ2V0RGVjb3JhdG9ycygpKTtcbiAgfSwgW2VkaXRvcl0pOyAvLyBSZXR1cm4gZGVjb3JhdG9ycyBkZWZpbmVkIGFzIFJlYWN0IFBvcnRhbHNcblxuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgZGVjb3JhdGVkUG9ydGFscyA9IFtdO1xuICAgIGNvbnN0IGRlY29yYXRvcktleXMgPSBPYmplY3Qua2V5cyhkZWNvcmF0b3JzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb3JhdG9yS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZUtleSA9IGRlY29yYXRvcktleXNbaV07XG4gICAgICBjb25zdCByZWFjdERlY29yYXRvciA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIHtcbiAgICAgICAgb25FcnJvcjogZSA9PiBlZGl0b3IuX29uRXJyb3IoZSlcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LlN1c3BlbnNlLCB7XG4gICAgICAgIGZhbGxiYWNrOiBudWxsXG4gICAgICB9LCBkZWNvcmF0b3JzW25vZGVLZXldKSk7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShub2RlS2V5KTtcblxuICAgICAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgZGVjb3JhdGVkUG9ydGFscy5wdXNoKCAvKiNfX1BVUkVfXyovcmVhY3REb20uY3JlYXRlUG9ydGFsKHJlYWN0RGVjb3JhdG9yLCBlbGVtZW50KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlY29yYXRlZFBvcnRhbHM7XG4gIH0sIFtFcnJvckJvdW5kYXJ5LCBkZWNvcmF0b3JzLCBlZGl0b3JdKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlUmljaFRleHRTZXR1cChlZGl0b3IpIHtcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gdXRpbHMubWVyZ2VSZWdpc3RlcihyaWNoVGV4dC5yZWdpc3RlclJpY2hUZXh0KGVkaXRvciksIGRyYWdvbi5yZWdpc3RlckRyYWdvblN1cHBvcnQoZWRpdG9yKSk7IC8vIFdlIG9ubHkgZG8gdGhpcyBmb3IgaW5pdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2VkaXRvcl0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBSaWNoVGV4dFBsdWdpbih7XG4gIGNvbnRlbnRFZGl0YWJsZSxcbiAgcGxhY2Vob2xkZXIsXG4gIEVycm9yQm91bmRhcnlcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgZGVjb3JhdG9ycyA9IHVzZURlY29yYXRvcnMoZWRpdG9yLCBFcnJvckJvdW5kYXJ5KTtcbiAgdXNlUmljaFRleHRTZXR1cChlZGl0b3IpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNvbnRlbnRFZGl0YWJsZSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUGxhY2Vob2xkZXIsIHtcbiAgICBjb250ZW50OiBwbGFjZWhvbGRlclxuICB9KSwgZGVjb3JhdG9ycyk7XG59XG5cbmZ1bmN0aW9uIFBsYWNlaG9sZGVyKHtcbiAgY29udGVudFxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICBjb25zdCBzaG93UGxhY2Vob2xkZXIgPSB1c2VDYW5TaG93UGxhY2Vob2xkZXIoZWRpdG9yKTtcbiAgY29uc3QgZWRpdGFibGUgPSB1c2VMZXhpY2FsRWRpdGFibGUoKTtcblxuICBpZiAoIXNob3dQbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQoZWRpdGFibGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG59XG5cbmV4cG9ydHMuUmljaFRleHRQbHVnaW4gPSBSaWNoVGV4dFBsdWdpbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalRichTextPlugin.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalRichTextPlugin.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalRichTextPlugin =  true ? __webpack_require__(/*! ./LexicalRichTextPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalRichTextPlugin.dev.js\") : 0\nmodule.exports = LexicalRichTextPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFJpY2hUZXh0UGx1Z2luLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osOEJBQThCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyx3R0FBZ0MsSUFBSSxDQUEwQztBQUM3SiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxSaWNoVGV4dFBsdWdpbi5qcz8zMzZjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsUmljaFRleHRQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFJpY2hUZXh0UGx1Z2luLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsUmljaFRleHRQbHVnaW4ucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxSaWNoVGV4dFBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalRichTextPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalTabIndentationPlugin.dev.js":
/*!************************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTabIndentationPlugin.dev.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * This plugin adds the ability to indent content using the tab key. Generally, we don't\n * recommend using this plugin as it could negatively affect acessibility for keyboard\n * users, causing focus to become trapped within the editor.\n */\n\nfunction TabIndentationPlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    return editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.$isRangeSelection(selection)) {\n        return false;\n      }\n\n      event.preventDefault();\n      return editor.dispatchCommand(event.shiftKey ? lexical.OUTDENT_CONTENT_COMMAND : lexical.INDENT_CONTENT_COMMAND, undefined);\n    }, lexical.COMMAND_PRIORITY_EDITOR);\n  });\n  return null;\n}\n\nexports.TabIndentationPlugin = TabIndentationPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFRhYkluZGVudGF0aW9uUGx1Z2luLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUEsNEJBQTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFRhYkluZGVudGF0aW9uUGx1Z2luLmRldi5qcz85ZWUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuLyoqXG4gKiBUaGlzIHBsdWdpbiBhZGRzIHRoZSBhYmlsaXR5IHRvIGluZGVudCBjb250ZW50IHVzaW5nIHRoZSB0YWIga2V5LiBHZW5lcmFsbHksIHdlIGRvbid0XG4gKiByZWNvbW1lbmQgdXNpbmcgdGhpcyBwbHVnaW4gYXMgaXQgY291bGQgbmVnYXRpdmVseSBhZmZlY3QgYWNlc3NpYmlsaXR5IGZvciBrZXlib2FyZFxuICogdXNlcnMsIGNhdXNpbmcgZm9jdXMgdG8gYmVjb21lIHRyYXBwZWQgd2l0aGluIHRoZSBlZGl0b3IuXG4gKi9cblxuZnVuY3Rpb24gVGFiSW5kZW50YXRpb25QbHVnaW4oKSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIHJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfVEFCX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChldmVudC5zaGlmdEtleSA/IGxleGljYWwuT1VUREVOVF9DT05URU5UX0NPTU1BTkQgOiBsZXhpY2FsLklOREVOVF9DT05URU5UX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUik7XG4gIH0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5UYWJJbmRlbnRhdGlvblBsdWdpbiA9IFRhYkluZGVudGF0aW9uUGx1Z2luO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalTabIndentationPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalTabIndentationPlugin.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTabIndentationPlugin.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalTabIndentationPlugin =  true ? __webpack_require__(/*! ./LexicalTabIndentationPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalTabIndentationPlugin.dev.js\") : 0\nmodule.exports = LexicalTabIndentationPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFRhYkluZGVudGF0aW9uUGx1Z2luLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osb0NBQW9DLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxvSEFBc0MsSUFBSSxDQUFnRDtBQUMvSyIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxUYWJJbmRlbnRhdGlvblBsdWdpbi5qcz9lOTAzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsVGFiSW5kZW50YXRpb25QbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFRhYkluZGVudGF0aW9uUGx1Z2luLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsVGFiSW5kZW50YXRpb25QbHVnaW4ucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxUYWJJbmRlbnRhdGlvblBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalTabIndentationPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalTableOfContents.dev.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTableOfContents.dev.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar richText = __webpack_require__(/*! @lexical/rich-text */ \"(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction toEntry(heading) {\n  return [heading.getKey(), heading.getTextContent(), heading.getTag()];\n}\n\nfunction $insertHeadingIntoTableOfContents(prevHeading, newHeading, currentTableOfContents) {\n  if (newHeading === null) {\n    return currentTableOfContents;\n  }\n\n  const newEntry = toEntry(newHeading);\n  let newTableOfContents = [];\n\n  if (prevHeading === null) {\n    newTableOfContents = [newEntry, ...currentTableOfContents];\n  } else {\n    for (let i = 0; i < currentTableOfContents.length; i++) {\n      const key = currentTableOfContents[i][0];\n      newTableOfContents.push(currentTableOfContents[i]);\n\n      if (key === prevHeading.getKey() && key !== newHeading.getKey()) {\n        newTableOfContents.push(newEntry);\n      }\n    }\n  }\n\n  return newTableOfContents;\n}\n\nfunction $deleteHeadingFromTableOfContents(key, currentTableOfContents) {\n  const newTableOfContents = [];\n\n  for (const heading of currentTableOfContents) {\n    if (heading[0] !== key) {\n      newTableOfContents.push(heading);\n    }\n  }\n\n  return newTableOfContents;\n}\n\nfunction $updateHeadingInTableOfContents(heading, currentTableOfContents) {\n  const newTableOfContents = [];\n\n  for (const oldHeading of currentTableOfContents) {\n    if (oldHeading[0] === heading.getKey()) {\n      newTableOfContents.push(toEntry(heading));\n    } else {\n      newTableOfContents.push(oldHeading);\n    }\n  }\n\n  return newTableOfContents;\n}\n/**\n * Returns the updated table of contents, placing the given `heading` before the given `prevHeading`. If `prevHeading`\n * is undefined, `heading` is placed at the start of table of contents\n */\n\n\nfunction $updateHeadingPosition(prevHeading, heading, currentTableOfContents) {\n  const newTableOfContents = [];\n  const newEntry = toEntry(heading);\n\n  if (!prevHeading) {\n    newTableOfContents.push(newEntry);\n  }\n\n  for (const oldHeading of currentTableOfContents) {\n    if (oldHeading[0] === heading.getKey()) {\n      continue;\n    }\n\n    newTableOfContents.push(oldHeading);\n\n    if (prevHeading && oldHeading[0] === prevHeading.getKey()) {\n      newTableOfContents.push(newEntry);\n    }\n  }\n\n  return newTableOfContents;\n}\n\nfunction LexicalTableOfContentsPlugin({\n  children\n}) {\n  const [tableOfContents, setTableOfContents] = react.useState([]);\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    // Set table of contents initial state\n    let currentTableOfContents = [];\n    editor.getEditorState().read(() => {\n      const root = lexical.$getRoot();\n      const rootChildren = root.getChildren();\n\n      for (const child of rootChildren) {\n        if (richText.$isHeadingNode(child)) {\n          currentTableOfContents.push([child.getKey(), child.getTextContent(), child.getTag()]);\n        }\n      }\n\n      setTableOfContents(currentTableOfContents);\n    }); // Listen to updates to heading mutations and update state\n\n    const removeHeaderMutationListener = editor.registerMutationListener(richText.HeadingNode, mutatedNodes => {\n      editor.getEditorState().read(() => {\n        for (const [nodeKey, mutation] of mutatedNodes) {\n          if (mutation === 'created') {\n            const newHeading = lexical.$getNodeByKey(nodeKey);\n\n            if (newHeading !== null) {\n              let prevHeading = newHeading.getPreviousSibling();\n\n              while (prevHeading !== null && !richText.$isHeadingNode(prevHeading)) {\n                prevHeading = prevHeading.getPreviousSibling();\n              }\n\n              currentTableOfContents = $insertHeadingIntoTableOfContents(prevHeading, newHeading, currentTableOfContents);\n            }\n          } else if (mutation === 'destroyed') {\n            currentTableOfContents = $deleteHeadingFromTableOfContents(nodeKey, currentTableOfContents);\n          } else if (mutation === 'updated') {\n            const newHeading = lexical.$getNodeByKey(nodeKey);\n\n            if (newHeading !== null) {\n              let prevHeading = newHeading.getPreviousSibling();\n\n              while (prevHeading !== null && !richText.$isHeadingNode(prevHeading)) {\n                prevHeading = prevHeading.getPreviousSibling();\n              }\n\n              currentTableOfContents = $updateHeadingPosition(prevHeading, newHeading, currentTableOfContents);\n            }\n          }\n        }\n\n        setTableOfContents(currentTableOfContents);\n      });\n    }); // Listen to text node mutation updates\n\n    const removeTextNodeMutationListener = editor.registerMutationListener(lexical.TextNode, mutatedNodes => {\n      editor.getEditorState().read(() => {\n        for (const [nodeKey, mutation] of mutatedNodes) {\n          if (mutation === 'updated') {\n            const currNode = lexical.$getNodeByKey(nodeKey);\n\n            if (currNode !== null) {\n              const parentNode = currNode.getParentOrThrow();\n\n              if (richText.$isHeadingNode(parentNode)) {\n                currentTableOfContents = $updateHeadingInTableOfContents(parentNode, currentTableOfContents);\n                setTableOfContents(currentTableOfContents);\n              }\n            }\n          }\n        }\n      });\n    });\n    return () => {\n      removeHeaderMutationListener();\n      removeTextNodeMutationListener();\n    };\n  }, [editor]);\n  return children(tableOfContents, editor);\n}\n\nmodule.exports = LexicalTableOfContentsPlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFRhYmxlT2ZDb250ZW50cy5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsNEdBQXVDO0FBQzVFLGVBQWUsbUJBQU8sQ0FBQyxzRkFBb0I7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixvQkFBb0IsbUNBQW1DO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxUYWJsZU9mQ29udGVudHMuZGV2LmpzP2I4MmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIHJpY2hUZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmljaC10ZXh0Jyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gdG9FbnRyeShoZWFkaW5nKSB7XG4gIHJldHVybiBbaGVhZGluZy5nZXRLZXkoKSwgaGVhZGluZy5nZXRUZXh0Q29udGVudCgpLCBoZWFkaW5nLmdldFRhZygpXTtcbn1cblxuZnVuY3Rpb24gJGluc2VydEhlYWRpbmdJbnRvVGFibGVPZkNvbnRlbnRzKHByZXZIZWFkaW5nLCBuZXdIZWFkaW5nLCBjdXJyZW50VGFibGVPZkNvbnRlbnRzKSB7XG4gIGlmIChuZXdIZWFkaW5nID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRUYWJsZU9mQ29udGVudHM7XG4gIH1cblxuICBjb25zdCBuZXdFbnRyeSA9IHRvRW50cnkobmV3SGVhZGluZyk7XG4gIGxldCBuZXdUYWJsZU9mQ29udGVudHMgPSBbXTtcblxuICBpZiAocHJldkhlYWRpbmcgPT09IG51bGwpIHtcbiAgICBuZXdUYWJsZU9mQ29udGVudHMgPSBbbmV3RW50cnksIC4uLmN1cnJlbnRUYWJsZU9mQ29udGVudHNdO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudFRhYmxlT2ZDb250ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gY3VycmVudFRhYmxlT2ZDb250ZW50c1tpXVswXTtcbiAgICAgIG5ld1RhYmxlT2ZDb250ZW50cy5wdXNoKGN1cnJlbnRUYWJsZU9mQ29udGVudHNbaV0pO1xuXG4gICAgICBpZiAoa2V5ID09PSBwcmV2SGVhZGluZy5nZXRLZXkoKSAmJiBrZXkgIT09IG5ld0hlYWRpbmcuZ2V0S2V5KCkpIHtcbiAgICAgICAgbmV3VGFibGVPZkNvbnRlbnRzLnB1c2gobmV3RW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdUYWJsZU9mQ29udGVudHM7XG59XG5cbmZ1bmN0aW9uICRkZWxldGVIZWFkaW5nRnJvbVRhYmxlT2ZDb250ZW50cyhrZXksIGN1cnJlbnRUYWJsZU9mQ29udGVudHMpIHtcbiAgY29uc3QgbmV3VGFibGVPZkNvbnRlbnRzID0gW107XG5cbiAgZm9yIChjb25zdCBoZWFkaW5nIG9mIGN1cnJlbnRUYWJsZU9mQ29udGVudHMpIHtcbiAgICBpZiAoaGVhZGluZ1swXSAhPT0ga2V5KSB7XG4gICAgICBuZXdUYWJsZU9mQ29udGVudHMucHVzaChoZWFkaW5nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VGFibGVPZkNvbnRlbnRzO1xufVxuXG5mdW5jdGlvbiAkdXBkYXRlSGVhZGluZ0luVGFibGVPZkNvbnRlbnRzKGhlYWRpbmcsIGN1cnJlbnRUYWJsZU9mQ29udGVudHMpIHtcbiAgY29uc3QgbmV3VGFibGVPZkNvbnRlbnRzID0gW107XG5cbiAgZm9yIChjb25zdCBvbGRIZWFkaW5nIG9mIGN1cnJlbnRUYWJsZU9mQ29udGVudHMpIHtcbiAgICBpZiAob2xkSGVhZGluZ1swXSA9PT0gaGVhZGluZy5nZXRLZXkoKSkge1xuICAgICAgbmV3VGFibGVPZkNvbnRlbnRzLnB1c2godG9FbnRyeShoZWFkaW5nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1RhYmxlT2ZDb250ZW50cy5wdXNoKG9sZEhlYWRpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdUYWJsZU9mQ29udGVudHM7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHVwZGF0ZWQgdGFibGUgb2YgY29udGVudHMsIHBsYWNpbmcgdGhlIGdpdmVuIGBoZWFkaW5nYCBiZWZvcmUgdGhlIGdpdmVuIGBwcmV2SGVhZGluZ2AuIElmIGBwcmV2SGVhZGluZ2BcbiAqIGlzIHVuZGVmaW5lZCwgYGhlYWRpbmdgIGlzIHBsYWNlZCBhdCB0aGUgc3RhcnQgb2YgdGFibGUgb2YgY29udGVudHNcbiAqL1xuXG5cbmZ1bmN0aW9uICR1cGRhdGVIZWFkaW5nUG9zaXRpb24ocHJldkhlYWRpbmcsIGhlYWRpbmcsIGN1cnJlbnRUYWJsZU9mQ29udGVudHMpIHtcbiAgY29uc3QgbmV3VGFibGVPZkNvbnRlbnRzID0gW107XG4gIGNvbnN0IG5ld0VudHJ5ID0gdG9FbnRyeShoZWFkaW5nKTtcblxuICBpZiAoIXByZXZIZWFkaW5nKSB7XG4gICAgbmV3VGFibGVPZkNvbnRlbnRzLnB1c2gobmV3RW50cnkpO1xuICB9XG5cbiAgZm9yIChjb25zdCBvbGRIZWFkaW5nIG9mIGN1cnJlbnRUYWJsZU9mQ29udGVudHMpIHtcbiAgICBpZiAob2xkSGVhZGluZ1swXSA9PT0gaGVhZGluZy5nZXRLZXkoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgbmV3VGFibGVPZkNvbnRlbnRzLnB1c2gob2xkSGVhZGluZyk7XG5cbiAgICBpZiAocHJldkhlYWRpbmcgJiYgb2xkSGVhZGluZ1swXSA9PT0gcHJldkhlYWRpbmcuZ2V0S2V5KCkpIHtcbiAgICAgIG5ld1RhYmxlT2ZDb250ZW50cy5wdXNoKG5ld0VudHJ5KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VGFibGVPZkNvbnRlbnRzO1xufVxuXG5mdW5jdGlvbiBMZXhpY2FsVGFibGVPZkNvbnRlbnRzUGx1Z2luKHtcbiAgY2hpbGRyZW5cbn0pIHtcbiAgY29uc3QgW3RhYmxlT2ZDb250ZW50cywgc2V0VGFibGVPZkNvbnRlbnRzXSA9IHJlYWN0LnVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTZXQgdGFibGUgb2YgY29udGVudHMgaW5pdGlhbCBzdGF0ZVxuICAgIGxldCBjdXJyZW50VGFibGVPZkNvbnRlbnRzID0gW107XG4gICAgZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgICBjb25zdCByb290ID0gbGV4aWNhbC4kZ2V0Um9vdCgpO1xuICAgICAgY29uc3Qgcm9vdENoaWxkcmVuID0gcm9vdC5nZXRDaGlsZHJlbigpO1xuXG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHJvb3RDaGlsZHJlbikge1xuICAgICAgICBpZiAocmljaFRleHQuJGlzSGVhZGluZ05vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgY3VycmVudFRhYmxlT2ZDb250ZW50cy5wdXNoKFtjaGlsZC5nZXRLZXkoKSwgY2hpbGQuZ2V0VGV4dENvbnRlbnQoKSwgY2hpbGQuZ2V0VGFnKCldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRUYWJsZU9mQ29udGVudHMoY3VycmVudFRhYmxlT2ZDb250ZW50cyk7XG4gICAgfSk7IC8vIExpc3RlbiB0byB1cGRhdGVzIHRvIGhlYWRpbmcgbXV0YXRpb25zIGFuZCB1cGRhdGUgc3RhdGVcblxuICAgIGNvbnN0IHJlbW92ZUhlYWRlck11dGF0aW9uTGlzdGVuZXIgPSBlZGl0b3IucmVnaXN0ZXJNdXRhdGlvbkxpc3RlbmVyKHJpY2hUZXh0LkhlYWRpbmdOb2RlLCBtdXRhdGVkTm9kZXMgPT4ge1xuICAgICAgZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgW25vZGVLZXksIG11dGF0aW9uXSBvZiBtdXRhdGVkTm9kZXMpIHtcbiAgICAgICAgICBpZiAobXV0YXRpb24gPT09ICdjcmVhdGVkJykge1xuICAgICAgICAgICAgY29uc3QgbmV3SGVhZGluZyA9IGxleGljYWwuJGdldE5vZGVCeUtleShub2RlS2V5KTtcblxuICAgICAgICAgICAgaWYgKG5ld0hlYWRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgbGV0IHByZXZIZWFkaW5nID0gbmV3SGVhZGluZy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgICAgICAgICAgICB3aGlsZSAocHJldkhlYWRpbmcgIT09IG51bGwgJiYgIXJpY2hUZXh0LiRpc0hlYWRpbmdOb2RlKHByZXZIZWFkaW5nKSkge1xuICAgICAgICAgICAgICAgIHByZXZIZWFkaW5nID0gcHJldkhlYWRpbmcuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjdXJyZW50VGFibGVPZkNvbnRlbnRzID0gJGluc2VydEhlYWRpbmdJbnRvVGFibGVPZkNvbnRlbnRzKHByZXZIZWFkaW5nLCBuZXdIZWFkaW5nLCBjdXJyZW50VGFibGVPZkNvbnRlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG11dGF0aW9uID09PSAnZGVzdHJveWVkJykge1xuICAgICAgICAgICAgY3VycmVudFRhYmxlT2ZDb250ZW50cyA9ICRkZWxldGVIZWFkaW5nRnJvbVRhYmxlT2ZDb250ZW50cyhub2RlS2V5LCBjdXJyZW50VGFibGVPZkNvbnRlbnRzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG11dGF0aW9uID09PSAndXBkYXRlZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hlYWRpbmcgPSBsZXhpY2FsLiRnZXROb2RlQnlLZXkobm9kZUtleSk7XG5cbiAgICAgICAgICAgIGlmIChuZXdIZWFkaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGxldCBwcmV2SGVhZGluZyA9IG5ld0hlYWRpbmcuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKHByZXZIZWFkaW5nICE9PSBudWxsICYmICFyaWNoVGV4dC4kaXNIZWFkaW5nTm9kZShwcmV2SGVhZGluZykpIHtcbiAgICAgICAgICAgICAgICBwcmV2SGVhZGluZyA9IHByZXZIZWFkaW5nLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY3VycmVudFRhYmxlT2ZDb250ZW50cyA9ICR1cGRhdGVIZWFkaW5nUG9zaXRpb24ocHJldkhlYWRpbmcsIG5ld0hlYWRpbmcsIGN1cnJlbnRUYWJsZU9mQ29udGVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldFRhYmxlT2ZDb250ZW50cyhjdXJyZW50VGFibGVPZkNvbnRlbnRzKTtcbiAgICAgIH0pO1xuICAgIH0pOyAvLyBMaXN0ZW4gdG8gdGV4dCBub2RlIG11dGF0aW9uIHVwZGF0ZXNcblxuICAgIGNvbnN0IHJlbW92ZVRleHROb2RlTXV0YXRpb25MaXN0ZW5lciA9IGVkaXRvci5yZWdpc3Rlck11dGF0aW9uTGlzdGVuZXIobGV4aWNhbC5UZXh0Tm9kZSwgbXV0YXRlZE5vZGVzID0+IHtcbiAgICAgIGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtub2RlS2V5LCBtdXRhdGlvbl0gb2YgbXV0YXRlZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKG11dGF0aW9uID09PSAndXBkYXRlZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJOb2RlID0gbGV4aWNhbC4kZ2V0Tm9kZUJ5S2V5KG5vZGVLZXkpO1xuXG4gICAgICAgICAgICBpZiAoY3Vyck5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGN1cnJOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgICAgICAgICAgICBpZiAocmljaFRleHQuJGlzSGVhZGluZ05vZGUocGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFibGVPZkNvbnRlbnRzID0gJHVwZGF0ZUhlYWRpbmdJblRhYmxlT2ZDb250ZW50cyhwYXJlbnROb2RlLCBjdXJyZW50VGFibGVPZkNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICBzZXRUYWJsZU9mQ29udGVudHMoY3VycmVudFRhYmxlT2ZDb250ZW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZW1vdmVIZWFkZXJNdXRhdGlvbkxpc3RlbmVyKCk7XG4gICAgICByZW1vdmVUZXh0Tm9kZU11dGF0aW9uTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9LCBbZWRpdG9yXSk7XG4gIHJldHVybiBjaGlsZHJlbih0YWJsZU9mQ29udGVudHMsIGVkaXRvcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbFRhYmxlT2ZDb250ZW50c1BsdWdpbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalTableOfContents.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalTableOfContents.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTableOfContents.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalTableOfContents =  true ? __webpack_require__(/*! ./LexicalTableOfContents.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalTableOfContents.dev.js\") : 0\nmodule.exports = LexicalTableOfContents;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFRhYmxlT2ZDb250ZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLCtCQUErQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsMEdBQWlDLElBQUksQ0FBMkM7QUFDaEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsVGFibGVPZkNvbnRlbnRzLmpzP2E0MzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxUYWJsZU9mQ29udGVudHMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFRhYmxlT2ZDb250ZW50cy5kZXYuanMnKSA6IHJlcXVpcmUoJy4vTGV4aWNhbFRhYmxlT2ZDb250ZW50cy5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbFRhYmxlT2ZDb250ZW50czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalTableOfContents.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalTablePlugin.dev.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTablePlugin.dev.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar table = __webpack_require__(/*! @lexical/table */ \"(ssr)/./node_modules/@lexical/table/LexicalTable.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction TablePlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    if (!editor.hasNodes([table.TableNode, table.TableCellNode, table.TableRowNode])) {\n      {\n        throw Error(`TablePlugin: TableNode, TableCellNode or TableRowNode not registered on editor`);\n      }\n    }\n\n    return editor.registerCommand(table.INSERT_TABLE_COMMAND, ({\n      columns,\n      rows,\n      includeHeaders\n    }) => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.$isRangeSelection(selection)) {\n        return true;\n      }\n\n      const focus = selection.focus;\n      const focusNode = focus.getNode();\n\n      if (focusNode !== null) {\n        const tableNode = table.$createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);\n\n        if (lexical.$isRootOrShadowRoot(focusNode)) {\n          const target = focusNode.getChildAtIndex(focus.offset);\n\n          if (target !== null) {\n            target.insertBefore(tableNode);\n          } else {\n            focusNode.append(tableNode);\n          }\n\n          tableNode.insertBefore(lexical.$createParagraphNode());\n        } else {\n          const topLevelNode = focusNode.getTopLevelElementOrThrow();\n          topLevelNode.insertAfter(tableNode);\n        }\n\n        tableNode.insertAfter(lexical.$createParagraphNode());\n        const firstCell = tableNode.getFirstChildOrThrow().getFirstChildOrThrow();\n        firstCell.select();\n      }\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR);\n  }, [editor]);\n  react.useEffect(() => {\n    const tableSelections = new Map();\n\n    const initializeTableNode = tableNode => {\n      const nodeKey = tableNode.getKey();\n      const tableElement = editor.getElementByKey(nodeKey);\n\n      if (tableElement && !tableSelections.has(nodeKey)) {\n        const tableSelection = table.applyTableHandlers(tableNode, tableElement, editor);\n        tableSelections.set(nodeKey, tableSelection);\n      }\n    }; // Plugins might be loaded _after_ initial content is set, hence existing table nodes\n    // won't be initialized from mutation[create] listener. Instead doing it here,\n\n\n    editor.getEditorState().read(() => {\n      const tableNodes = lexical.$nodesOfType(table.TableNode);\n\n      for (const tableNode of tableNodes) {\n        if (table.$isTableNode(tableNode)) {\n          initializeTableNode(tableNode);\n        }\n      }\n    });\n    const unregisterMutationListener = editor.registerMutationListener(table.TableNode, nodeMutations => {\n      for (const [nodeKey, mutation] of nodeMutations) {\n        if (mutation === 'created') {\n          editor.getEditorState().read(() => {\n            const tableNode = lexical.$getNodeByKey(nodeKey);\n\n            if (table.$isTableNode(tableNode)) {\n              initializeTableNode(tableNode);\n            }\n          });\n        } else if (mutation === 'destroyed') {\n          const tableSelection = tableSelections.get(nodeKey);\n\n          if (tableSelection !== undefined) {\n            tableSelection.removeListeners();\n            tableSelections.delete(nodeKey);\n          }\n        }\n      }\n    });\n    return () => {\n      unregisterMutationListener(); // Hook might be called multiple times so cleaning up tables listeners as well,\n      // as it'll be reinitialized during recurring call\n\n      for (const [, tableSelection] of tableSelections) {\n        tableSelection.removeListeners();\n      }\n    };\n  }, [editor]);\n  return null;\n}\n\nexports.TablePlugin = TablePlugin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFRhYmxlUGx1Z2luLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNwQyxjQUFjLG1CQUFPLENBQUMsd0RBQVM7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxUYWJsZVBsdWdpbi5kZXYuanM/YThkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgdGFibGUgPSByZXF1aXJlKCdAbGV4aWNhbC90YWJsZScpO1xudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG52YXIgcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBUYWJsZVBsdWdpbigpIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVkaXRvci5oYXNOb2RlcyhbdGFibGUuVGFibGVOb2RlLCB0YWJsZS5UYWJsZUNlbGxOb2RlLCB0YWJsZS5UYWJsZVJvd05vZGVdKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgVGFibGVQbHVnaW46IFRhYmxlTm9kZSwgVGFibGVDZWxsTm9kZSBvciBUYWJsZVJvd05vZGUgbm90IHJlZ2lzdGVyZWQgb24gZWRpdG9yYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlckNvbW1hbmQodGFibGUuSU5TRVJUX1RBQkxFX0NPTU1BTkQsICh7XG4gICAgICBjb2x1bW5zLFxuICAgICAgcm93cyxcbiAgICAgIGluY2x1ZGVIZWFkZXJzXG4gICAgfSkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcblxuICAgICAgaWYgKGZvY3VzTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB0YWJsZU5vZGUgPSB0YWJsZS4kY3JlYXRlVGFibGVOb2RlV2l0aERpbWVuc2lvbnMoTnVtYmVyKHJvd3MpLCBOdW1iZXIoY29sdW1ucyksIGluY2x1ZGVIZWFkZXJzKTtcblxuICAgICAgICBpZiAobGV4aWNhbC4kaXNSb290T3JTaGFkb3dSb290KGZvY3VzTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBmb2N1c05vZGUuZ2V0Q2hpbGRBdEluZGV4KGZvY3VzLm9mZnNldCk7XG5cbiAgICAgICAgICBpZiAodGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHRhYmxlTm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvY3VzTm9kZS5hcHBlbmQodGFibGVOb2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YWJsZU5vZGUuaW5zZXJ0QmVmb3JlKGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdG9wTGV2ZWxOb2RlID0gZm9jdXNOb2RlLmdldFRvcExldmVsRWxlbWVudE9yVGhyb3coKTtcbiAgICAgICAgICB0b3BMZXZlbE5vZGUuaW5zZXJ0QWZ0ZXIodGFibGVOb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlTm9kZS5pbnNlcnRBZnRlcihsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICAgICAgICBjb25zdCBmaXJzdENlbGwgPSB0YWJsZU5vZGUuZ2V0Rmlyc3RDaGlsZE9yVGhyb3coKS5nZXRGaXJzdENoaWxkT3JUaHJvdygpO1xuICAgICAgICBmaXJzdENlbGwuc2VsZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpO1xuICB9LCBbZWRpdG9yXSk7XG4gIHJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdGFibGVTZWxlY3Rpb25zID0gbmV3IE1hcCgpO1xuXG4gICAgY29uc3QgaW5pdGlhbGl6ZVRhYmxlTm9kZSA9IHRhYmxlTm9kZSA9PiB7XG4gICAgICBjb25zdCBub2RlS2V5ID0gdGFibGVOb2RlLmdldEtleSgpO1xuICAgICAgY29uc3QgdGFibGVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShub2RlS2V5KTtcblxuICAgICAgaWYgKHRhYmxlRWxlbWVudCAmJiAhdGFibGVTZWxlY3Rpb25zLmhhcyhub2RlS2V5KSkge1xuICAgICAgICBjb25zdCB0YWJsZVNlbGVjdGlvbiA9IHRhYmxlLmFwcGx5VGFibGVIYW5kbGVycyh0YWJsZU5vZGUsIHRhYmxlRWxlbWVudCwgZWRpdG9yKTtcbiAgICAgICAgdGFibGVTZWxlY3Rpb25zLnNldChub2RlS2V5LCB0YWJsZVNlbGVjdGlvbik7XG4gICAgICB9XG4gICAgfTsgLy8gUGx1Z2lucyBtaWdodCBiZSBsb2FkZWQgX2FmdGVyXyBpbml0aWFsIGNvbnRlbnQgaXMgc2V0LCBoZW5jZSBleGlzdGluZyB0YWJsZSBub2Rlc1xuICAgIC8vIHdvbid0IGJlIGluaXRpYWxpemVkIGZyb20gbXV0YXRpb25bY3JlYXRlXSBsaXN0ZW5lci4gSW5zdGVhZCBkb2luZyBpdCBoZXJlLFxuXG5cbiAgICBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlTm9kZXMgPSBsZXhpY2FsLiRub2Rlc09mVHlwZSh0YWJsZS5UYWJsZU5vZGUpO1xuXG4gICAgICBmb3IgKGNvbnN0IHRhYmxlTm9kZSBvZiB0YWJsZU5vZGVzKSB7XG4gICAgICAgIGlmICh0YWJsZS4kaXNUYWJsZU5vZGUodGFibGVOb2RlKSkge1xuICAgICAgICAgIGluaXRpYWxpemVUYWJsZU5vZGUodGFibGVOb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHVucmVnaXN0ZXJNdXRhdGlvbkxpc3RlbmVyID0gZWRpdG9yLnJlZ2lzdGVyTXV0YXRpb25MaXN0ZW5lcih0YWJsZS5UYWJsZU5vZGUsIG5vZGVNdXRhdGlvbnMgPT4ge1xuICAgICAgZm9yIChjb25zdCBbbm9kZUtleSwgbXV0YXRpb25dIG9mIG5vZGVNdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKG11dGF0aW9uID09PSAnY3JlYXRlZCcpIHtcbiAgICAgICAgICBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlTm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleShub2RlS2V5KTtcblxuICAgICAgICAgICAgaWYgKHRhYmxlLiRpc1RhYmxlTm9kZSh0YWJsZU5vZGUpKSB7XG4gICAgICAgICAgICAgIGluaXRpYWxpemVUYWJsZU5vZGUodGFibGVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChtdXRhdGlvbiA9PT0gJ2Rlc3Ryb3llZCcpIHtcbiAgICAgICAgICBjb25zdCB0YWJsZVNlbGVjdGlvbiA9IHRhYmxlU2VsZWN0aW9ucy5nZXQobm9kZUtleSk7XG5cbiAgICAgICAgICBpZiAodGFibGVTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFibGVTZWxlY3Rpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0YWJsZVNlbGVjdGlvbnMuZGVsZXRlKG5vZGVLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyTXV0YXRpb25MaXN0ZW5lcigpOyAvLyBIb29rIG1pZ2h0IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBzbyBjbGVhbmluZyB1cCB0YWJsZXMgbGlzdGVuZXJzIGFzIHdlbGwsXG4gICAgICAvLyBhcyBpdCdsbCBiZSByZWluaXRpYWxpemVkIGR1cmluZyByZWN1cnJpbmcgY2FsbFxuXG4gICAgICBmb3IgKGNvbnN0IFssIHRhYmxlU2VsZWN0aW9uXSBvZiB0YWJsZVNlbGVjdGlvbnMpIHtcbiAgICAgICAgdGFibGVTZWxlY3Rpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VkaXRvcl0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0cy5UYWJsZVBsdWdpbiA9IFRhYmxlUGx1Z2luO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalTablePlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalTablePlugin.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTablePlugin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalTablePlugin =  true ? __webpack_require__(/*! ./LexicalTablePlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalTablePlugin.dev.js\") : 0\nmodule.exports = LexicalTablePlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFRhYmxlUGx1Z2luLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osMkJBQTJCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxrR0FBNkIsSUFBSSxDQUF1QztBQUNwSiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxUYWJsZVBsdWdpbi5qcz8zYWEzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsVGFibGVQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFRhYmxlUGx1Z2luLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsVGFibGVQbHVnaW4ucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxUYWJsZVBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalTablePlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalTreeView.dev.js":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTreeView.dev.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar link = __webpack_require__(/*! @lexical/link */ \"(ssr)/./node_modules/@lexical/link/LexicalLink.js\");\nvar mark = __webpack_require__(/*! @lexical/mark */ \"(ssr)/./node_modules/@lexical/mark/LexicalMark.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({\n  '\\t': '\\\\t',\n  '\\n': '\\\\n'\n});\nconst NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join('|'), 'g');\nconst SYMBOLS = Object.freeze({\n  ancestorHasNextSibling: '|',\n  ancestorIsLastChild: ' ',\n  hasNextSibling: '',\n  isLastChild: '',\n  selectedChar: '^',\n  selectedLine: '>'\n});\nfunction TreeView({\n  timeTravelButtonClassName,\n  timeTravelPanelSliderClassName,\n  timeTravelPanelButtonClassName,\n  viewClassName,\n  timeTravelPanelClassName,\n  editor\n}) {\n  const [timeStampedEditorStates, setTimeStampedEditorStates] = React.useState([]);\n  const [content, setContent] = React.useState('');\n  const [timeTravelEnabled, setTimeTravelEnabled] = React.useState(false);\n  const playingIndexRef = React.useRef(0);\n  const treeElementRef = React.useRef(null);\n  const inputRef = React.useRef(null);\n  const [isPlaying, setIsPlaying] = React.useState(false);\n  const [isLimited, setIsLimited] = React.useState(false);\n  const [showLimited, setShowLimited] = React.useState(false);\n  const lastEditorStateRef = React.useRef(null);\n  const commandsLog = useLexicalCommandsLog(editor);\n  const generateTree = React.useCallback(editorState => {\n    const treeText = generateContent(editor.getEditorState(), editor._config, commandsLog, editor._compositionKey, editor._editable);\n    setContent(treeText);\n\n    if (!timeTravelEnabled) {\n      setTimeStampedEditorStates(currentEditorStates => [...currentEditorStates, [Date.now(), editorState]]);\n    }\n  }, [commandsLog, editor, timeTravelEnabled]);\n  React.useEffect(() => {\n    const editorState = editor.getEditorState();\n\n    if (!showLimited && editorState._nodeMap.size > 1000) {\n      setContent(generateContent(editorState, editor._config, commandsLog, editor._compositionKey, editor._editable));\n    }\n  }, [commandsLog, editor, showLimited]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerUpdateListener(({\n      editorState\n    }) => {\n      if (!showLimited && editorState._nodeMap.size > 1000) {\n        lastEditorStateRef.current = editorState;\n        setIsLimited(true);\n\n        if (!showLimited) {\n          return;\n        }\n      }\n\n      generateTree(editorState);\n    }), editor.registerEditableListener(() => {\n      const treeText = generateContent(editor.getEditorState(), editor._config, commandsLog, editor._compositionKey, editor._editable);\n      setContent(treeText);\n    }));\n  }, [commandsLog, editor, isLimited, generateTree, showLimited]);\n  const totalEditorStates = timeStampedEditorStates.length;\n  React.useEffect(() => {\n    if (isPlaying) {\n      let timeoutId;\n\n      const play = () => {\n        const currentIndex = playingIndexRef.current;\n\n        if (currentIndex === totalEditorStates - 1) {\n          setIsPlaying(false);\n          return;\n        }\n\n        const currentTime = timeStampedEditorStates[currentIndex][0];\n        const nextTime = timeStampedEditorStates[currentIndex + 1][0];\n        const timeDiff = nextTime - currentTime;\n        timeoutId = setTimeout(() => {\n          playingIndexRef.current++;\n          const index = playingIndexRef.current;\n          const input = inputRef.current;\n\n          if (input !== null) {\n            input.value = String(index);\n          }\n\n          editor.setEditorState(timeStampedEditorStates[index][1]);\n          play();\n        }, timeDiff);\n      };\n\n      play();\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    }\n  }, [timeStampedEditorStates, isPlaying, editor, totalEditorStates]);\n  React.useEffect(() => {\n    const element = treeElementRef.current;\n\n    if (element !== null) {\n      // @ts-ignore Internal field\n      element.__lexicalEditor = editor;\n      return () => {\n        // @ts-ignore Internal field\n        element.__lexicalEditor = null;\n      };\n    }\n  }, [editor]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: viewClassName\n  }, !showLimited && isLimited ? /*#__PURE__*/React.createElement(\"div\", {\n    style: {\n      padding: 20\n    }\n  }, /*#__PURE__*/React.createElement(\"span\", {\n    style: {\n      marginRight: 20\n    }\n  }, \"Detected large EditorState, this can impact debugging performance.\"), /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => {\n      setShowLimited(true);\n      const editorState = lastEditorStateRef.current;\n\n      if (editorState !== null) {\n        lastEditorStateRef.current = null;\n        generateTree(editorState);\n      }\n    },\n    style: {\n      background: 'transparent',\n      border: '1px solid white',\n      color: 'white',\n      cursor: 'pointer',\n      padding: 5\n    }\n  }, \"Show full tree\")) : null, !timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2 && /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => {\n      const rootElement = editor.getRootElement();\n\n      if (rootElement !== null) {\n        rootElement.contentEditable = 'false';\n        playingIndexRef.current = totalEditorStates - 1;\n        setTimeTravelEnabled(true);\n      }\n    },\n    className: timeTravelButtonClassName,\n    type: \"button\"\n  }, \"Time Travel\"), (showLimited || !isLimited) && /*#__PURE__*/React.createElement(\"pre\", {\n    ref: treeElementRef\n  }, content), timeTravelEnabled && (showLimited || !isLimited) && /*#__PURE__*/React.createElement(\"div\", {\n    className: timeTravelPanelClassName\n  }, /*#__PURE__*/React.createElement(\"button\", {\n    className: timeTravelPanelButtonClassName,\n    onClick: () => {\n      if (playingIndexRef.current === totalEditorStates - 1) {\n        playingIndexRef.current = 1;\n      }\n\n      setIsPlaying(!isPlaying);\n    },\n    type: \"button\"\n  }, isPlaying ? 'Pause' : 'Play'), /*#__PURE__*/React.createElement(\"input\", {\n    className: timeTravelPanelSliderClassName,\n    ref: inputRef,\n    onChange: event => {\n      const editorStateIndex = Number(event.target.value);\n      const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];\n\n      if (timeStampedEditorState) {\n        playingIndexRef.current = editorStateIndex;\n        editor.setEditorState(timeStampedEditorState[1]);\n      }\n    },\n    type: \"range\",\n    min: \"1\",\n    max: totalEditorStates - 1\n  }), /*#__PURE__*/React.createElement(\"button\", {\n    className: timeTravelPanelButtonClassName,\n    onClick: () => {\n      const rootElement = editor.getRootElement();\n\n      if (rootElement !== null) {\n        rootElement.contentEditable = 'true';\n        const index = timeStampedEditorStates.length - 1;\n        const timeStampedEditorState = timeStampedEditorStates[index];\n        editor.setEditorState(timeStampedEditorState[1]);\n        const input = inputRef.current;\n\n        if (input !== null) {\n          input.value = String(index);\n        }\n\n        setTimeTravelEnabled(false);\n        setIsPlaying(false);\n      }\n    },\n    type: \"button\"\n  }, \"Exit\")));\n}\n\nfunction useLexicalCommandsLog(editor) {\n  const [loggedCommands, setLoggedCommands] = React.useState([]);\n  React.useEffect(() => {\n    const unregisterCommandListeners = new Set();\n\n    for (const [command] of editor._commands) {\n      unregisterCommandListeners.add(editor.registerCommand(command, payload => {\n        setLoggedCommands(state => {\n          const newState = [...state];\n          newState.push({\n            payload,\n            type: command.type ? command.type : 'UNKNOWN'\n          });\n\n          if (newState.length > 10) {\n            newState.shift();\n          }\n\n          return newState;\n        });\n        return false;\n      }, lexical.COMMAND_PRIORITY_HIGH));\n    }\n\n    return () => unregisterCommandListeners.forEach(unregister => unregister());\n  }, [editor]);\n  return React.useMemo(() => loggedCommands, [loggedCommands]);\n}\n\nfunction printRangeSelection(selection) {\n  let res = '';\n  const formatText = printFormatProperties(selection);\n  res += `: range ${formatText !== '' ? `{ ${formatText} }` : ''} ${selection.style !== '' ? `{ style: ${selection.style} } ` : ''}`;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  res += `\\n   anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? 'null' : anchorOffset}, type: ${anchor.type} }`;\n  res += `\\n   focus { key: ${focus.key}, offset: ${focusOffset === null ? 'null' : focusOffset}, type: ${focus.type} }`;\n  return res;\n}\n\nfunction printNodeSelection(selection) {\n  return `: node\\n   [${Array.from(selection._nodes).join(', ')}]`;\n}\n\nfunction printGridSelection(selection) {\n  return `: grid\\n   { grid: ${selection.gridKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;\n}\n\nfunction generateContent(editorState, editorConfig, commandsLog, compositionKey, editable) {\n  let res = ' root\\n';\n  const selectionString = editorState.read(() => {\n    const selection = lexical.$getSelection();\n    visitTree(lexical.$getRoot(), (node, indent) => {\n      const nodeKey = node.getKey();\n      const nodeKeyDisplay = `(${nodeKey})`;\n      const typeDisplay = node.getType() || '';\n      const isSelected = node.isSelected();\n      const idsDisplay = mark.$isMarkNode(node) ? ` id: [ ${node.getIDs().join(', ')} ] ` : '';\n      res += `${isSelected ? SYMBOLS.selectedLine : ' '} ${indent.join(' ')} ${nodeKeyDisplay} ${typeDisplay} ${idsDisplay} ${printNode(node)}\\n`;\n      res += printSelectedCharsLine({\n        indent,\n        isSelected,\n        node,\n        nodeKeyDisplay,\n        selection,\n        typeDisplay\n      });\n    });\n    return selection === null ? ': null' : lexical.$isRangeSelection(selection) ? printRangeSelection(selection) : lexical.DEPRECATED_$isGridSelection(selection) ? printGridSelection(selection) : printNodeSelection(selection);\n  });\n  res += '\\n selection' + selectionString;\n  res += '\\n\\n commands:';\n\n  if (commandsLog.length) {\n    for (const {\n      type,\n      payload\n    } of commandsLog) {\n      res += `\\n   { type: ${type}, payload: ${payload instanceof Event ? payload.constructor.name : payload} }`;\n    }\n  } else {\n    res += '\\n   None dispatched.';\n  }\n\n  res += '\\n\\n editor:';\n  res += `\\n   namespace ${editorConfig.namespace}`;\n\n  if (compositionKey !== null) {\n    res += `\\n   compositionKey ${compositionKey}`;\n  }\n\n  res += `\\n   editable ${String(editable)}`;\n  return res;\n}\n\nfunction visitTree(currentNode, visitor, indent = []) {\n  const childNodes = currentNode.getChildren();\n  const childNodesLength = childNodes.length;\n  childNodes.forEach((childNode, i) => {\n    visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));\n\n    if (lexical.$isElementNode(childNode)) {\n      visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));\n    }\n  });\n}\n\nfunction normalize(text) {\n  return Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, [key, value]) => acc.replace(new RegExp(key, 'g'), String(value)), text);\n} // TODO Pass via props to allow customizability\n\n\nfunction printNode(node) {\n  if (lexical.$isTextNode(node)) {\n    const text = node.getTextContent();\n    const title = text.length === 0 ? '(empty)' : `\"${normalize(text)}\"`;\n    const properties = printAllTextNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if (link.$isLinkNode(node)) {\n    const link = node.getURL();\n    const title = link.length === 0 ? '(empty)' : `\"${normalize(link)}\"`;\n    const properties = printAllLinkNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else {\n    return '';\n  }\n}\n\nconst FORMAT_PREDICATES = [node => node.hasFormat('bold') && 'Bold', node => node.hasFormat('code') && 'Code', node => node.hasFormat('italic') && 'Italic', node => node.hasFormat('strikethrough') && 'Strikethrough', node => node.hasFormat('subscript') && 'Subscript', node => node.hasFormat('superscript') && 'Superscript', node => node.hasFormat('underline') && 'Underline'];\nconst DETAIL_PREDICATES = [node => node.isDirectionless() && 'Directionless', node => node.isUnmergeable() && 'Unmergeable'];\nconst MODE_PREDICATES = [node => node.isToken() && 'Token', node => node.isSegmented() && 'Segmented'];\n\nfunction printAllTextNodeProperties(node) {\n  return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node)].filter(Boolean).join(', ');\n}\n\nfunction printAllLinkNodeProperties(node) {\n  return [printTargetProperties(node), printRelProperties(node)].filter(Boolean).join(', ');\n}\n\nfunction printDetailProperties(nodeOrSelection) {\n  let str = DETAIL_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n\n  if (str !== '') {\n    str = 'detail: ' + str;\n  }\n\n  return str;\n}\n\nfunction printModeProperties(nodeOrSelection) {\n  let str = MODE_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n\n  if (str !== '') {\n    str = 'mode: ' + str;\n  }\n\n  return str;\n}\n\nfunction printFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n\n  return str;\n}\n\nfunction printTargetProperties(node) {\n  let str = node.getTarget(); // TODO Fix nullish on LinkNode\n\n  if (str != null) {\n    str = 'target: ' + str;\n  }\n\n  return str;\n}\n\nfunction printRelProperties(node) {\n  let str = node.getRel(); // TODO Fix nullish on LinkNode\n\n  if (str != null) {\n    str = 'rel: ' + str;\n  }\n\n  return str;\n}\n\nfunction printSelectedCharsLine({\n  indent,\n  isSelected,\n  node,\n  nodeKeyDisplay,\n  selection,\n  typeDisplay\n}) {\n  // No selection or node is not selected.\n  if (!lexical.$isTextNode(node) || !lexical.$isRangeSelection(selection) || !isSelected || lexical.$isElementNode(node)) {\n    return '';\n  } // No selected characters.\n\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n\n  if (node.getTextContent() === '' || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {\n    return '';\n  }\n\n  const [start, end] = $getSelectionStartEnd(node, selection);\n\n  if (start === end) {\n    return '';\n  }\n\n  const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;\n  const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];\n  const unselectedChars = Array(start + 1).fill(' ');\n  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);\n  const paddingLength = typeDisplay.length + 3; // 2 for the spaces around + 1 for the double quote.\n\n  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(' ');\n  return [SYMBOLS.selectedLine, indentionChars.join(' '), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join('')].join(' ') + '\\n';\n}\n\nfunction $getSelectionStartEnd(node, selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const textContent = node.getTextContent();\n  const textLength = textContent.length;\n  let start = -1;\n  let end = -1; // Only one node is being selected.\n\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n\n    if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {\n      [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];\n    } else if (node === anchorNode) {\n      [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];\n    } else if (node === focusNode) {\n      [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];\n    } else {\n      // Node is within selection but not the anchor nor focus.\n      [start, end] = [0, textLength];\n    }\n  } // Account for non-single width characters.\n\n\n  const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];\n}\n\nexports.TreeView = TreeView;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFRyZWVWaWV3LmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsd0VBQWU7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLHdFQUFlO0FBQ2xDLFlBQVksbUJBQU8sQ0FBQywyRUFBZ0I7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLHdEQUFTO0FBQy9CLFlBQVksbUJBQU8sQ0FBQyx3R0FBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QixFQUFFLGFBQWEsUUFBUSxFQUFFLDRCQUE0QixTQUFTLG1CQUFtQixPQUFPO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sV0FBVyxZQUFZLDhDQUE4QyxVQUFVLGNBQWM7QUFDN0gsd0JBQXdCLE9BQU8sVUFBVSxZQUFZLDRDQUE0QyxVQUFVLGFBQWE7QUFDeEg7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qix3Q0FBd0M7QUFDakU7O0FBRUE7QUFDQSx3QkFBd0IsUUFBUSxrQkFBa0IsZ0JBQWdCLHFCQUFxQixlQUFlLHNCQUFzQjtBQUM1SDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0EsNERBQTRELDBCQUEwQjtBQUN0RixnQkFBZ0IseUNBQXlDLEVBQUUsa0JBQWtCLEVBQUUsZ0JBQWdCLEVBQUUsYUFBYSxFQUFFLFlBQVksRUFBRSxnQkFBZ0I7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLFFBQVEsS0FBSyxhQUFhLGdFQUFnRTtBQUNoSDtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHVCQUF1Qjs7QUFFbkQ7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDs7QUFFQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQSxnREFBZ0QsRUFBRSxhQUFhO0FBQy9ELElBQUk7QUFDSjtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQSxnREFBZ0QsRUFBRSxhQUFhO0FBQy9ELElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxUcmVlVmlldy5kZXYuanM/ZWMyNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGxpbmsgPSByZXF1aXJlKCdAbGV4aWNhbC9saW5rJyk7XG52YXIgbWFyayA9IHJlcXVpcmUoJ0BsZXhpY2FsL21hcmsnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVQTEFDRU1FTlQgPSBPYmplY3QuZnJlZXplKHtcbiAgJ1xcdCc6ICdcXFxcdCcsXG4gICdcXG4nOiAnXFxcXG4nXG59KTtcbmNvbnN0IE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVHRVggPSBuZXcgUmVnRXhwKE9iamVjdC5rZXlzKE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVQTEFDRU1FTlQpLmpvaW4oJ3wnKSwgJ2cnKTtcbmNvbnN0IFNZTUJPTFMgPSBPYmplY3QuZnJlZXplKHtcbiAgYW5jZXN0b3JIYXNOZXh0U2libGluZzogJ3wnLFxuICBhbmNlc3RvcklzTGFzdENoaWxkOiAnICcsXG4gIGhhc05leHRTaWJsaW5nOiAn4pScJyxcbiAgaXNMYXN0Q2hpbGQ6ICfilJQnLFxuICBzZWxlY3RlZENoYXI6ICdeJyxcbiAgc2VsZWN0ZWRMaW5lOiAnPidcbn0pO1xuZnVuY3Rpb24gVHJlZVZpZXcoe1xuICB0aW1lVHJhdmVsQnV0dG9uQ2xhc3NOYW1lLFxuICB0aW1lVHJhdmVsUGFuZWxTbGlkZXJDbGFzc05hbWUsXG4gIHRpbWVUcmF2ZWxQYW5lbEJ1dHRvbkNsYXNzTmFtZSxcbiAgdmlld0NsYXNzTmFtZSxcbiAgdGltZVRyYXZlbFBhbmVsQ2xhc3NOYW1lLFxuICBlZGl0b3Jcbn0pIHtcbiAgY29uc3QgW3RpbWVTdGFtcGVkRWRpdG9yU3RhdGVzLCBzZXRUaW1lU3RhbXBlZEVkaXRvclN0YXRlc10gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtjb250ZW50LCBzZXRDb250ZW50XSA9IFJlYWN0LnVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3RpbWVUcmF2ZWxFbmFibGVkLCBzZXRUaW1lVHJhdmVsRW5hYmxlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHBsYXlpbmdJbmRleFJlZiA9IFJlYWN0LnVzZVJlZigwKTtcbiAgY29uc3QgdHJlZUVsZW1lbnRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGlucHV0UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBbaXNQbGF5aW5nLCBzZXRJc1BsYXlpbmddID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNMaW1pdGVkLCBzZXRJc0xpbWl0ZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd0xpbWl0ZWQsIHNldFNob3dMaW1pdGVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgbGFzdEVkaXRvclN0YXRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBjb21tYW5kc0xvZyA9IHVzZUxleGljYWxDb21tYW5kc0xvZyhlZGl0b3IpO1xuICBjb25zdCBnZW5lcmF0ZVRyZWUgPSBSZWFjdC51c2VDYWxsYmFjayhlZGl0b3JTdGF0ZSA9PiB7XG4gICAgY29uc3QgdHJlZVRleHQgPSBnZW5lcmF0ZUNvbnRlbnQoZWRpdG9yLmdldEVkaXRvclN0YXRlKCksIGVkaXRvci5fY29uZmlnLCBjb21tYW5kc0xvZywgZWRpdG9yLl9jb21wb3NpdGlvbktleSwgZWRpdG9yLl9lZGl0YWJsZSk7XG4gICAgc2V0Q29udGVudCh0cmVlVGV4dCk7XG5cbiAgICBpZiAoIXRpbWVUcmF2ZWxFbmFibGVkKSB7XG4gICAgICBzZXRUaW1lU3RhbXBlZEVkaXRvclN0YXRlcyhjdXJyZW50RWRpdG9yU3RhdGVzID0+IFsuLi5jdXJyZW50RWRpdG9yU3RhdGVzLCBbRGF0ZS5ub3coKSwgZWRpdG9yU3RhdGVdXSk7XG4gICAgfVxuICB9LCBbY29tbWFuZHNMb2csIGVkaXRvciwgdGltZVRyYXZlbEVuYWJsZWRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBlZGl0b3JTdGF0ZSA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpO1xuXG4gICAgaWYgKCFzaG93TGltaXRlZCAmJiBlZGl0b3JTdGF0ZS5fbm9kZU1hcC5zaXplID4gMTAwMCkge1xuICAgICAgc2V0Q29udGVudChnZW5lcmF0ZUNvbnRlbnQoZWRpdG9yU3RhdGUsIGVkaXRvci5fY29uZmlnLCBjb21tYW5kc0xvZywgZWRpdG9yLl9jb21wb3NpdGlvbktleSwgZWRpdG9yLl9lZGl0YWJsZSkpO1xuICAgIH1cbiAgfSwgW2NvbW1hbmRzTG9nLCBlZGl0b3IsIHNob3dMaW1pdGVkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHV0aWxzLm1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHtcbiAgICAgIGVkaXRvclN0YXRlXG4gICAgfSkgPT4ge1xuICAgICAgaWYgKCFzaG93TGltaXRlZCAmJiBlZGl0b3JTdGF0ZS5fbm9kZU1hcC5zaXplID4gMTAwMCkge1xuICAgICAgICBsYXN0RWRpdG9yU3RhdGVSZWYuY3VycmVudCA9IGVkaXRvclN0YXRlO1xuICAgICAgICBzZXRJc0xpbWl0ZWQodHJ1ZSk7XG5cbiAgICAgICAgaWYgKCFzaG93TGltaXRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBnZW5lcmF0ZVRyZWUoZWRpdG9yU3RhdGUpO1xuICAgIH0pLCBlZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIGNvbnN0IHRyZWVUZXh0ID0gZ2VuZXJhdGVDb250ZW50KGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLCBlZGl0b3IuX2NvbmZpZywgY29tbWFuZHNMb2csIGVkaXRvci5fY29tcG9zaXRpb25LZXksIGVkaXRvci5fZWRpdGFibGUpO1xuICAgICAgc2V0Q29udGVudCh0cmVlVGV4dCk7XG4gICAgfSkpO1xuICB9LCBbY29tbWFuZHNMb2csIGVkaXRvciwgaXNMaW1pdGVkLCBnZW5lcmF0ZVRyZWUsIHNob3dMaW1pdGVkXSk7XG4gIGNvbnN0IHRvdGFsRWRpdG9yU3RhdGVzID0gdGltZVN0YW1wZWRFZGl0b3JTdGF0ZXMubGVuZ3RoO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc1BsYXlpbmcpIHtcbiAgICAgIGxldCB0aW1lb3V0SWQ7XG5cbiAgICAgIGNvbnN0IHBsYXkgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHBsYXlpbmdJbmRleFJlZi5jdXJyZW50O1xuXG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IHRvdGFsRWRpdG9yU3RhdGVzIC0gMSkge1xuICAgICAgICAgIHNldElzUGxheWluZyhmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB0aW1lU3RhbXBlZEVkaXRvclN0YXRlc1tjdXJyZW50SW5kZXhdWzBdO1xuICAgICAgICBjb25zdCBuZXh0VGltZSA9IHRpbWVTdGFtcGVkRWRpdG9yU3RhdGVzW2N1cnJlbnRJbmRleCArIDFdWzBdO1xuICAgICAgICBjb25zdCB0aW1lRGlmZiA9IG5leHRUaW1lIC0gY3VycmVudFRpbWU7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHBsYXlpbmdJbmRleFJlZi5jdXJyZW50Kys7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBwbGF5aW5nSW5kZXhSZWYuY3VycmVudDtcbiAgICAgICAgICBjb25zdCBpbnB1dCA9IGlucHV0UmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgICBpZiAoaW5wdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gU3RyaW5nKGluZGV4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlZGl0b3Iuc2V0RWRpdG9yU3RhdGUodGltZVN0YW1wZWRFZGl0b3JTdGF0ZXNbaW5kZXhdWzFdKTtcbiAgICAgICAgICBwbGF5KCk7XG4gICAgICAgIH0sIHRpbWVEaWZmKTtcbiAgICAgIH07XG5cbiAgICAgIHBsYXkoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFt0aW1lU3RhbXBlZEVkaXRvclN0YXRlcywgaXNQbGF5aW5nLCBlZGl0b3IsIHRvdGFsRWRpdG9yU3RhdGVzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRyZWVFbGVtZW50UmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gQHRzLWlnbm9yZSBJbnRlcm5hbCBmaWVsZFxuICAgICAgZWxlbWVudC5fX2xleGljYWxFZGl0b3IgPSBlZGl0b3I7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAvLyBAdHMtaWdub3JlIEludGVybmFsIGZpZWxkXG4gICAgICAgIGVsZW1lbnQuX19sZXhpY2FsRWRpdG9yID0gbnVsbDtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZWRpdG9yXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiB2aWV3Q2xhc3NOYW1lXG4gIH0sICFzaG93TGltaXRlZCAmJiBpc0xpbWl0ZWQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmc6IDIwXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBtYXJnaW5SaWdodDogMjBcbiAgICB9XG4gIH0sIFwiRGV0ZWN0ZWQgbGFyZ2UgRWRpdG9yU3RhdGUsIHRoaXMgY2FuIGltcGFjdCBkZWJ1Z2dpbmcgcGVyZm9ybWFuY2UuXCIpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgc2V0U2hvd0xpbWl0ZWQodHJ1ZSk7XG4gICAgICBjb25zdCBlZGl0b3JTdGF0ZSA9IGxhc3RFZGl0b3JTdGF0ZVJlZi5jdXJyZW50O1xuXG4gICAgICBpZiAoZWRpdG9yU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgbGFzdEVkaXRvclN0YXRlUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBnZW5lcmF0ZVRyZWUoZWRpdG9yU3RhdGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsXG4gICAgICBib3JkZXI6ICcxcHggc29saWQgd2hpdGUnLFxuICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgIHBhZGRpbmc6IDVcbiAgICB9XG4gIH0sIFwiU2hvdyBmdWxsIHRyZWVcIikpIDogbnVsbCwgIXRpbWVUcmF2ZWxFbmFibGVkICYmIChzaG93TGltaXRlZCB8fCAhaXNMaW1pdGVkKSAmJiB0b3RhbEVkaXRvclN0YXRlcyA+IDIgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG5cbiAgICAgIGlmIChyb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICByb290RWxlbWVudC5jb250ZW50RWRpdGFibGUgPSAnZmFsc2UnO1xuICAgICAgICBwbGF5aW5nSW5kZXhSZWYuY3VycmVudCA9IHRvdGFsRWRpdG9yU3RhdGVzIC0gMTtcbiAgICAgICAgc2V0VGltZVRyYXZlbEVuYWJsZWQodHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGFzc05hbWU6IHRpbWVUcmF2ZWxCdXR0b25DbGFzc05hbWUsXG4gICAgdHlwZTogXCJidXR0b25cIlxuICB9LCBcIlRpbWUgVHJhdmVsXCIpLCAoc2hvd0xpbWl0ZWQgfHwgIWlzTGltaXRlZCkgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwge1xuICAgIHJlZjogdHJlZUVsZW1lbnRSZWZcbiAgfSwgY29udGVudCksIHRpbWVUcmF2ZWxFbmFibGVkICYmIChzaG93TGltaXRlZCB8fCAhaXNMaW1pdGVkKSAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiB0aW1lVHJhdmVsUGFuZWxDbGFzc05hbWVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIGNsYXNzTmFtZTogdGltZVRyYXZlbFBhbmVsQnV0dG9uQ2xhc3NOYW1lLFxuICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgIGlmIChwbGF5aW5nSW5kZXhSZWYuY3VycmVudCA9PT0gdG90YWxFZGl0b3JTdGF0ZXMgLSAxKSB7XG4gICAgICAgIHBsYXlpbmdJbmRleFJlZi5jdXJyZW50ID0gMTtcbiAgICAgIH1cblxuICAgICAgc2V0SXNQbGF5aW5nKCFpc1BsYXlpbmcpO1xuICAgIH0sXG4gICAgdHlwZTogXCJidXR0b25cIlxuICB9LCBpc1BsYXlpbmcgPyAnUGF1c2UnIDogJ1BsYXknKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7XG4gICAgY2xhc3NOYW1lOiB0aW1lVHJhdmVsUGFuZWxTbGlkZXJDbGFzc05hbWUsXG4gICAgcmVmOiBpbnB1dFJlZixcbiAgICBvbkNoYW5nZTogZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZWRpdG9yU3RhdGVJbmRleCA9IE51bWJlcihldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgY29uc3QgdGltZVN0YW1wZWRFZGl0b3JTdGF0ZSA9IHRpbWVTdGFtcGVkRWRpdG9yU3RhdGVzW2VkaXRvclN0YXRlSW5kZXhdO1xuXG4gICAgICBpZiAodGltZVN0YW1wZWRFZGl0b3JTdGF0ZSkge1xuICAgICAgICBwbGF5aW5nSW5kZXhSZWYuY3VycmVudCA9IGVkaXRvclN0YXRlSW5kZXg7XG4gICAgICAgIGVkaXRvci5zZXRFZGl0b3JTdGF0ZSh0aW1lU3RhbXBlZEVkaXRvclN0YXRlWzFdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICBtaW46IFwiMVwiLFxuICAgIG1heDogdG90YWxFZGl0b3JTdGF0ZXMgLSAxXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAgY2xhc3NOYW1lOiB0aW1lVHJhdmVsUGFuZWxCdXR0b25DbGFzc05hbWUsXG4gICAgb25DbGljazogKCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcblxuICAgICAgaWYgKHJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHJvb3RFbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9ICd0cnVlJztcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aW1lU3RhbXBlZEVkaXRvclN0YXRlcy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCB0aW1lU3RhbXBlZEVkaXRvclN0YXRlID0gdGltZVN0YW1wZWRFZGl0b3JTdGF0ZXNbaW5kZXhdO1xuICAgICAgICBlZGl0b3Iuc2V0RWRpdG9yU3RhdGUodGltZVN0YW1wZWRFZGl0b3JTdGF0ZVsxXSk7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRSZWYuY3VycmVudDtcblxuICAgICAgICBpZiAoaW5wdXQgIT09IG51bGwpIHtcbiAgICAgICAgICBpbnB1dC52YWx1ZSA9IFN0cmluZyhpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lVHJhdmVsRW5hYmxlZChmYWxzZSk7XG4gICAgICAgIHNldElzUGxheWluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0eXBlOiBcImJ1dHRvblwiXG4gIH0sIFwiRXhpdFwiKSkpO1xufVxuXG5mdW5jdGlvbiB1c2VMZXhpY2FsQ29tbWFuZHNMb2coZWRpdG9yKSB7XG4gIGNvbnN0IFtsb2dnZWRDb21tYW5kcywgc2V0TG9nZ2VkQ29tbWFuZHNdID0gUmVhY3QudXNlU3RhdGUoW10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHVucmVnaXN0ZXJDb21tYW5kTGlzdGVuZXJzID0gbmV3IFNldCgpO1xuXG4gICAgZm9yIChjb25zdCBbY29tbWFuZF0gb2YgZWRpdG9yLl9jb21tYW5kcykge1xuICAgICAgdW5yZWdpc3RlckNvbW1hbmRMaXN0ZW5lcnMuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoY29tbWFuZCwgcGF5bG9hZCA9PiB7XG4gICAgICAgIHNldExvZ2dlZENvbW1hbmRzKHN0YXRlID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IFsuLi5zdGF0ZV07XG4gICAgICAgICAgbmV3U3RhdGUucHVzaCh7XG4gICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgdHlwZTogY29tbWFuZC50eXBlID8gY29tbWFuZC50eXBlIDogJ1VOS05PV04nXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAobmV3U3RhdGUubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgIG5ld1N0YXRlLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4gdW5yZWdpc3RlckNvbW1hbmRMaXN0ZW5lcnMuZm9yRWFjaCh1bnJlZ2lzdGVyID0+IHVucmVnaXN0ZXIoKSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gbG9nZ2VkQ29tbWFuZHMsIFtsb2dnZWRDb21tYW5kc10pO1xufVxuXG5mdW5jdGlvbiBwcmludFJhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICBsZXQgcmVzID0gJyc7XG4gIGNvbnN0IGZvcm1hdFRleHQgPSBwcmludEZvcm1hdFByb3BlcnRpZXMoc2VsZWN0aW9uKTtcbiAgcmVzICs9IGA6IHJhbmdlICR7Zm9ybWF0VGV4dCAhPT0gJycgPyBgeyAke2Zvcm1hdFRleHR9IH1gIDogJyd9ICR7c2VsZWN0aW9uLnN0eWxlICE9PSAnJyA/IGB7IHN0eWxlOiAke3NlbGVjdGlvbi5zdHlsZX0gfSBgIDogJyd9YDtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICByZXMgKz0gYFxcbiAg4pScIGFuY2hvciB7IGtleTogJHthbmNob3Iua2V5fSwgb2Zmc2V0OiAke2FuY2hvck9mZnNldCA9PT0gbnVsbCA/ICdudWxsJyA6IGFuY2hvck9mZnNldH0sIHR5cGU6ICR7YW5jaG9yLnR5cGV9IH1gO1xuICByZXMgKz0gYFxcbiAg4pSUIGZvY3VzIHsga2V5OiAke2ZvY3VzLmtleX0sIG9mZnNldDogJHtmb2N1c09mZnNldCA9PT0gbnVsbCA/ICdudWxsJyA6IGZvY3VzT2Zmc2V0fSwgdHlwZTogJHtmb2N1cy50eXBlfSB9YDtcbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcHJpbnROb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICByZXR1cm4gYDogbm9kZVxcbiAg4pSUIFske0FycmF5LmZyb20oc2VsZWN0aW9uLl9ub2Rlcykuam9pbignLCAnKX1dYDtcbn1cblxuZnVuY3Rpb24gcHJpbnRHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICByZXR1cm4gYDogZ3JpZFxcbiAg4pSUIHsgZ3JpZDogJHtzZWxlY3Rpb24uZ3JpZEtleX0sIGFuY2hvckNlbGw6ICR7c2VsZWN0aW9uLmFuY2hvci5rZXl9LCBmb2N1c0NlbGw6ICR7c2VsZWN0aW9uLmZvY3VzLmtleX0gfWA7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudChlZGl0b3JTdGF0ZSwgZWRpdG9yQ29uZmlnLCBjb21tYW5kc0xvZywgY29tcG9zaXRpb25LZXksIGVkaXRhYmxlKSB7XG4gIGxldCByZXMgPSAnIHJvb3RcXG4nO1xuICBjb25zdCBzZWxlY3Rpb25TdHJpbmcgPSBlZGl0b3JTdGF0ZS5yZWFkKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcbiAgICB2aXNpdFRyZWUobGV4aWNhbC4kZ2V0Um9vdCgpLCAobm9kZSwgaW5kZW50KSA9PiB7XG4gICAgICBjb25zdCBub2RlS2V5ID0gbm9kZS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IG5vZGVLZXlEaXNwbGF5ID0gYCgke25vZGVLZXl9KWA7XG4gICAgICBjb25zdCB0eXBlRGlzcGxheSA9IG5vZGUuZ2V0VHlwZSgpIHx8ICcnO1xuICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IG5vZGUuaXNTZWxlY3RlZCgpO1xuICAgICAgY29uc3QgaWRzRGlzcGxheSA9IG1hcmsuJGlzTWFya05vZGUobm9kZSkgPyBgIGlkOiBbICR7bm9kZS5nZXRJRHMoKS5qb2luKCcsICcpfSBdIGAgOiAnJztcbiAgICAgIHJlcyArPSBgJHtpc1NlbGVjdGVkID8gU1lNQk9MUy5zZWxlY3RlZExpbmUgOiAnICd9ICR7aW5kZW50LmpvaW4oJyAnKX0gJHtub2RlS2V5RGlzcGxheX0gJHt0eXBlRGlzcGxheX0gJHtpZHNEaXNwbGF5fSAke3ByaW50Tm9kZShub2RlKX1cXG5gO1xuICAgICAgcmVzICs9IHByaW50U2VsZWN0ZWRDaGFyc0xpbmUoe1xuICAgICAgICBpbmRlbnQsXG4gICAgICAgIGlzU2VsZWN0ZWQsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGVLZXlEaXNwbGF5LFxuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIHR5cGVEaXNwbGF5XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZWN0aW9uID09PSBudWxsID8gJzogbnVsbCcgOiBsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgPyBwcmludFJhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgOiBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pID8gcHJpbnRHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikgOiBwcmludE5vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgfSk7XG4gIHJlcyArPSAnXFxuIHNlbGVjdGlvbicgKyBzZWxlY3Rpb25TdHJpbmc7XG4gIHJlcyArPSAnXFxuXFxuIGNvbW1hbmRzOic7XG5cbiAgaWYgKGNvbW1hbmRzTG9nLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHBheWxvYWRcbiAgICB9IG9mIGNvbW1hbmRzTG9nKSB7XG4gICAgICByZXMgKz0gYFxcbiAg4pSUIHsgdHlwZTogJHt0eXBlfSwgcGF5bG9hZDogJHtwYXlsb2FkIGluc3RhbmNlb2YgRXZlbnQgPyBwYXlsb2FkLmNvbnN0cnVjdG9yLm5hbWUgOiBwYXlsb2FkfSB9YDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzICs9ICdcXG4gIOKUlCBOb25lIGRpc3BhdGNoZWQuJztcbiAgfVxuXG4gIHJlcyArPSAnXFxuXFxuIGVkaXRvcjonO1xuICByZXMgKz0gYFxcbiAg4pSUIG5hbWVzcGFjZSAke2VkaXRvckNvbmZpZy5uYW1lc3BhY2V9YDtcblxuICBpZiAoY29tcG9zaXRpb25LZXkgIT09IG51bGwpIHtcbiAgICByZXMgKz0gYFxcbiAg4pSUIGNvbXBvc2l0aW9uS2V5ICR7Y29tcG9zaXRpb25LZXl9YDtcbiAgfVxuXG4gIHJlcyArPSBgXFxuICDilJQgZWRpdGFibGUgJHtTdHJpbmcoZWRpdGFibGUpfWA7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHZpc2l0VHJlZShjdXJyZW50Tm9kZSwgdmlzaXRvciwgaW5kZW50ID0gW10pIHtcbiAgY29uc3QgY2hpbGROb2RlcyA9IGN1cnJlbnROb2RlLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aDtcbiAgY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUsIGkpID0+IHtcbiAgICB2aXNpdG9yKGNoaWxkTm9kZSwgaW5kZW50LmNvbmNhdChpID09PSBjaGlsZE5vZGVzTGVuZ3RoIC0gMSA/IFNZTUJPTFMuaXNMYXN0Q2hpbGQgOiBTWU1CT0xTLmhhc05leHRTaWJsaW5nKSk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjaGlsZE5vZGUpKSB7XG4gICAgICB2aXNpdFRyZWUoY2hpbGROb2RlLCB2aXNpdG9yLCBpbmRlbnQuY29uY2F0KGkgPT09IGNoaWxkTm9kZXNMZW5ndGggLSAxID8gU1lNQk9MUy5hbmNlc3RvcklzTGFzdENoaWxkIDogU1lNQk9MUy5hbmNlc3Rvckhhc05leHRTaWJsaW5nKSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplKHRleHQpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVQTEFDRU1FTlQpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IGFjYy5yZXBsYWNlKG5ldyBSZWdFeHAoa2V5LCAnZycpLCBTdHJpbmcodmFsdWUpKSwgdGV4dCk7XG59IC8vIFRPRE8gUGFzcyB2aWEgcHJvcHMgdG8gYWxsb3cgY3VzdG9taXphYmlsaXR5XG5cblxuZnVuY3Rpb24gcHJpbnROb2RlKG5vZGUpIHtcbiAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IHRpdGxlID0gdGV4dC5sZW5ndGggPT09IDAgPyAnKGVtcHR5KScgOiBgXCIke25vcm1hbGl6ZSh0ZXh0KX1cImA7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IHByaW50QWxsVGV4dE5vZGVQcm9wZXJ0aWVzKG5vZGUpO1xuICAgIHJldHVybiBbdGl0bGUsIHByb3BlcnRpZXMubGVuZ3RoICE9PSAwID8gYHsgJHtwcm9wZXJ0aWVzfSB9YCA6IG51bGxdLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJykudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxpbmsuJGlzTGlua05vZGUobm9kZSkpIHtcbiAgICBjb25zdCBsaW5rID0gbm9kZS5nZXRVUkwoKTtcbiAgICBjb25zdCB0aXRsZSA9IGxpbmsubGVuZ3RoID09PSAwID8gJyhlbXB0eSknIDogYFwiJHtub3JtYWxpemUobGluayl9XCJgO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBwcmludEFsbExpbmtOb2RlUHJvcGVydGllcyhub2RlKTtcbiAgICByZXR1cm4gW3RpdGxlLCBwcm9wZXJ0aWVzLmxlbmd0aCAhPT0gMCA/IGB7ICR7cHJvcGVydGllc30gfWAgOiBudWxsXS5maWx0ZXIoQm9vbGVhbikuam9pbignICcpLnRyaW0oKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuY29uc3QgRk9STUFUX1BSRURJQ0FURVMgPSBbbm9kZSA9PiBub2RlLmhhc0Zvcm1hdCgnYm9sZCcpICYmICdCb2xkJywgbm9kZSA9PiBub2RlLmhhc0Zvcm1hdCgnY29kZScpICYmICdDb2RlJywgbm9kZSA9PiBub2RlLmhhc0Zvcm1hdCgnaXRhbGljJykgJiYgJ0l0YWxpYycsIG5vZGUgPT4gbm9kZS5oYXNGb3JtYXQoJ3N0cmlrZXRocm91Z2gnKSAmJiAnU3RyaWtldGhyb3VnaCcsIG5vZGUgPT4gbm9kZS5oYXNGb3JtYXQoJ3N1YnNjcmlwdCcpICYmICdTdWJzY3JpcHQnLCBub2RlID0+IG5vZGUuaGFzRm9ybWF0KCdzdXBlcnNjcmlwdCcpICYmICdTdXBlcnNjcmlwdCcsIG5vZGUgPT4gbm9kZS5oYXNGb3JtYXQoJ3VuZGVybGluZScpICYmICdVbmRlcmxpbmUnXTtcbmNvbnN0IERFVEFJTF9QUkVESUNBVEVTID0gW25vZGUgPT4gbm9kZS5pc0RpcmVjdGlvbmxlc3MoKSAmJiAnRGlyZWN0aW9ubGVzcycsIG5vZGUgPT4gbm9kZS5pc1VubWVyZ2VhYmxlKCkgJiYgJ1VubWVyZ2VhYmxlJ107XG5jb25zdCBNT0RFX1BSRURJQ0FURVMgPSBbbm9kZSA9PiBub2RlLmlzVG9rZW4oKSAmJiAnVG9rZW4nLCBub2RlID0+IG5vZGUuaXNTZWdtZW50ZWQoKSAmJiAnU2VnbWVudGVkJ107XG5cbmZ1bmN0aW9uIHByaW50QWxsVGV4dE5vZGVQcm9wZXJ0aWVzKG5vZGUpIHtcbiAgcmV0dXJuIFtwcmludEZvcm1hdFByb3BlcnRpZXMobm9kZSksIHByaW50RGV0YWlsUHJvcGVydGllcyhub2RlKSwgcHJpbnRNb2RlUHJvcGVydGllcyhub2RlKV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJyk7XG59XG5cbmZ1bmN0aW9uIHByaW50QWxsTGlua05vZGVQcm9wZXJ0aWVzKG5vZGUpIHtcbiAgcmV0dXJuIFtwcmludFRhcmdldFByb3BlcnRpZXMobm9kZSksIHByaW50UmVsUHJvcGVydGllcyhub2RlKV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJyk7XG59XG5cbmZ1bmN0aW9uIHByaW50RGV0YWlsUHJvcGVydGllcyhub2RlT3JTZWxlY3Rpb24pIHtcbiAgbGV0IHN0ciA9IERFVEFJTF9QUkVESUNBVEVTLm1hcChwcmVkaWNhdGUgPT4gcHJlZGljYXRlKG5vZGVPclNlbGVjdGlvbikpLmZpbHRlcihCb29sZWFuKS5qb2luKCcsICcpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHN0ciAhPT0gJycpIHtcbiAgICBzdHIgPSAnZGV0YWlsOiAnICsgc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gcHJpbnRNb2RlUHJvcGVydGllcyhub2RlT3JTZWxlY3Rpb24pIHtcbiAgbGV0IHN0ciA9IE1PREVfUFJFRElDQVRFUy5tYXAocHJlZGljYXRlID0+IHByZWRpY2F0ZShub2RlT3JTZWxlY3Rpb24pKS5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuXG4gIGlmIChzdHIgIT09ICcnKSB7XG4gICAgc3RyID0gJ21vZGU6ICcgKyBzdHI7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBwcmludEZvcm1hdFByb3BlcnRpZXMobm9kZU9yU2VsZWN0aW9uKSB7XG4gIGxldCBzdHIgPSBGT1JNQVRfUFJFRElDQVRFUy5tYXAocHJlZGljYXRlID0+IHByZWRpY2F0ZShub2RlT3JTZWxlY3Rpb24pKS5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuXG4gIGlmIChzdHIgIT09ICcnKSB7XG4gICAgc3RyID0gJ2Zvcm1hdDogJyArIHN0cjtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHByaW50VGFyZ2V0UHJvcGVydGllcyhub2RlKSB7XG4gIGxldCBzdHIgPSBub2RlLmdldFRhcmdldCgpOyAvLyBUT0RPIEZpeCBudWxsaXNoIG9uIExpbmtOb2RlXG5cbiAgaWYgKHN0ciAhPSBudWxsKSB7XG4gICAgc3RyID0gJ3RhcmdldDogJyArIHN0cjtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHByaW50UmVsUHJvcGVydGllcyhub2RlKSB7XG4gIGxldCBzdHIgPSBub2RlLmdldFJlbCgpOyAvLyBUT0RPIEZpeCBudWxsaXNoIG9uIExpbmtOb2RlXG5cbiAgaWYgKHN0ciAhPSBudWxsKSB7XG4gICAgc3RyID0gJ3JlbDogJyArIHN0cjtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHByaW50U2VsZWN0ZWRDaGFyc0xpbmUoe1xuICBpbmRlbnQsXG4gIGlzU2VsZWN0ZWQsXG4gIG5vZGUsXG4gIG5vZGVLZXlEaXNwbGF5LFxuICBzZWxlY3Rpb24sXG4gIHR5cGVEaXNwbGF5XG59KSB7XG4gIC8vIE5vIHNlbGVjdGlvbiBvciBub2RlIGlzIG5vdCBzZWxlY3RlZC5cbiAgaWYgKCFsZXhpY2FsLiRpc1RleHROb2RlKG5vZGUpIHx8ICFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgIWlzU2VsZWN0ZWQgfHwgbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIHJldHVybiAnJztcbiAgfSAvLyBObyBzZWxlY3RlZCBjaGFyYWN0ZXJzLlxuXG5cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG5cbiAgaWYgKG5vZGUuZ2V0VGV4dENvbnRlbnQoKSA9PT0gJycgfHwgYW5jaG9yLmdldE5vZGUoKSA9PT0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKSAmJiBhbmNob3Iub2Zmc2V0ID09PSBmb2N1cy5vZmZzZXQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBjb25zdCBbc3RhcnQsIGVuZF0gPSAkZ2V0U2VsZWN0aW9uU3RhcnRFbmQobm9kZSwgc2VsZWN0aW9uKTtcblxuICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdGlvbkxhc3RJbmRlbnQgPSBpbmRlbnRbaW5kZW50Lmxlbmd0aCAtIDFdID09PSBTWU1CT0xTLmhhc05leHRTaWJsaW5nID8gU1lNQk9MUy5hbmNlc3Rvckhhc05leHRTaWJsaW5nIDogU1lNQk9MUy5hbmNlc3RvcklzTGFzdENoaWxkO1xuICBjb25zdCBpbmRlbnRpb25DaGFycyA9IFsuLi5pbmRlbnQuc2xpY2UoMCwgaW5kZW50Lmxlbmd0aCAtIDEpLCBzZWxlY3Rpb25MYXN0SW5kZW50XTtcbiAgY29uc3QgdW5zZWxlY3RlZENoYXJzID0gQXJyYXkoc3RhcnQgKyAxKS5maWxsKCcgJyk7XG4gIGNvbnN0IHNlbGVjdGVkQ2hhcnMgPSBBcnJheShlbmQgLSBzdGFydCkuZmlsbChTWU1CT0xTLnNlbGVjdGVkQ2hhcik7XG4gIGNvbnN0IHBhZGRpbmdMZW5ndGggPSB0eXBlRGlzcGxheS5sZW5ndGggKyAzOyAvLyAyIGZvciB0aGUgc3BhY2VzIGFyb3VuZCArIDEgZm9yIHRoZSBkb3VibGUgcXVvdGUuXG5cbiAgY29uc3Qgbm9kZVByaW50U3BhY2VzID0gQXJyYXkobm9kZUtleURpc3BsYXkubGVuZ3RoICsgcGFkZGluZ0xlbmd0aCkuZmlsbCgnICcpO1xuICByZXR1cm4gW1NZTUJPTFMuc2VsZWN0ZWRMaW5lLCBpbmRlbnRpb25DaGFycy5qb2luKCcgJyksIFsuLi5ub2RlUHJpbnRTcGFjZXMsIC4uLnVuc2VsZWN0ZWRDaGFycywgLi4uc2VsZWN0ZWRDaGFyc10uam9pbignJyldLmpvaW4oJyAnKSArICdcXG4nO1xufVxuXG5mdW5jdGlvbiAkZ2V0U2VsZWN0aW9uU3RhcnRFbmQobm9kZSwgc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCB0ZXh0Q29udGVudCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgY29uc3QgdGV4dExlbmd0aCA9IHRleHRDb250ZW50Lmxlbmd0aDtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBlbmQgPSAtMTsgLy8gT25seSBvbmUgbm9kZSBpcyBiZWluZyBzZWxlY3RlZC5cblxuICBpZiAoYW5jaG9yLnR5cGUgPT09ICd0ZXh0JyAmJiBmb2N1cy50eXBlID09PSAndGV4dCcpIHtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG5cbiAgICBpZiAoYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIG5vZGUgPT09IGFuY2hvck5vZGUgJiYgYW5jaG9yLm9mZnNldCAhPT0gZm9jdXMub2Zmc2V0KSB7XG4gICAgICBbc3RhcnQsIGVuZF0gPSBhbmNob3Iub2Zmc2V0IDwgZm9jdXMub2Zmc2V0ID8gW2FuY2hvci5vZmZzZXQsIGZvY3VzLm9mZnNldF0gOiBbZm9jdXMub2Zmc2V0LCBhbmNob3Iub2Zmc2V0XTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUpIHtcbiAgICAgIFtzdGFydCwgZW5kXSA9IGFuY2hvck5vZGUuaXNCZWZvcmUoZm9jdXNOb2RlKSA/IFthbmNob3Iub2Zmc2V0LCB0ZXh0TGVuZ3RoXSA6IFswLCBhbmNob3Iub2Zmc2V0XTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgPT09IGZvY3VzTm9kZSkge1xuICAgICAgW3N0YXJ0LCBlbmRdID0gZm9jdXNOb2RlLmlzQmVmb3JlKGFuY2hvck5vZGUpID8gW2ZvY3VzLm9mZnNldCwgdGV4dExlbmd0aF0gOiBbMCwgZm9jdXMub2Zmc2V0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9kZSBpcyB3aXRoaW4gc2VsZWN0aW9uIGJ1dCBub3QgdGhlIGFuY2hvciBub3IgZm9jdXMuXG4gICAgICBbc3RhcnQsIGVuZF0gPSBbMCwgdGV4dExlbmd0aF07XG4gICAgfVxuICB9IC8vIEFjY291bnQgZm9yIG5vbi1zaW5nbGUgd2lkdGggY2hhcmFjdGVycy5cblxuXG4gIGNvbnN0IG51bU5vblNpbmdsZVdpZHRoQ2hhckJlZm9yZVNlbGVjdGlvbiA9ICh0ZXh0Q29udGVudC5zbGljZSgwLCBzdGFydCkubWF0Y2goTk9OX1NJTkdMRV9XSURUSF9DSEFSU19SRUdFWCkgfHwgW10pLmxlbmd0aDtcbiAgY29uc3QgbnVtTm9uU2luZ2xlV2lkdGhDaGFySW5TZWxlY3Rpb24gPSAodGV4dENvbnRlbnQuc2xpY2Uoc3RhcnQsIGVuZCkubWF0Y2goTk9OX1NJTkdMRV9XSURUSF9DSEFSU19SRUdFWCkgfHwgW10pLmxlbmd0aDtcbiAgcmV0dXJuIFtzdGFydCArIG51bU5vblNpbmdsZVdpZHRoQ2hhckJlZm9yZVNlbGVjdGlvbiwgZW5kICsgbnVtTm9uU2luZ2xlV2lkdGhDaGFyQmVmb3JlU2VsZWN0aW9uICsgbnVtTm9uU2luZ2xlV2lkdGhDaGFySW5TZWxlY3Rpb25dO1xufVxuXG5leHBvcnRzLlRyZWVWaWV3ID0gVHJlZVZpZXc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalTreeView.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalTreeView.js":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTreeView.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalTreeView =  true ? __webpack_require__(/*! ./LexicalTreeView.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalTreeView.dev.js\") : 0\nmodule.exports = LexicalTreeView;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFRyZWVWaWV3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osd0JBQXdCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyw0RkFBMEIsSUFBSSxDQUFvQztBQUMzSSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxUcmVlVmlldy5qcz80OGE0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsVHJlZVZpZXcgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFRyZWVWaWV3LmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsVHJlZVZpZXcucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxUcmVlVmlldzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalTreeView.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalTypeaheadMenuPlugin.dev.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTypeaheadMenuPlugin.dev.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PUNCTUATION = '\\\\.,\\\\+\\\\*\\\\?\\\\$\\\\@\\\\|#{}\\\\(\\\\)\\\\^\\\\-\\\\[\\\\]\\\\\\\\/!%\\'\"~=<>_:;';\nclass TypeaheadOption {\n  constructor(key) {\n    this.key = key;\n    this.ref = {\n      current: null\n    };\n    this.setRefElement = this.setRefElement.bind(this);\n  }\n\n  setRefElement(element) {\n    this.ref = {\n      current: element\n    };\n  }\n\n}\n\nconst scrollIntoViewIfNeeded = target => {\n  const container = document.getElementById('typeahead-menu');\n  if (!container) return;\n  const typeaheadContainerNode = container.querySelector('.typeahead-popover');\n  if (!typeaheadContainerNode) return;\n  const typeaheadRect = typeaheadContainerNode.getBoundingClientRect();\n\n  if (typeaheadRect.top + typeaheadRect.height > window.innerHeight) {\n    typeaheadContainerNode.scrollIntoView({\n      block: 'center'\n    });\n  }\n\n  if (typeaheadRect.top < 0) {\n    typeaheadContainerNode.scrollIntoView({\n      block: 'center'\n    });\n  }\n\n  target.scrollIntoView({\n    block: 'nearest'\n  });\n};\n\nfunction getTextUpToAnchor(selection) {\n  const anchor = selection.anchor;\n\n  if (anchor.type !== 'text') {\n    return null;\n  }\n\n  const anchorNode = anchor.getNode();\n\n  if (!anchorNode.isSimpleText()) {\n    return null;\n  }\n\n  const anchorOffset = anchor.offset;\n  return anchorNode.getTextContent().slice(0, anchorOffset);\n}\n\nfunction tryToPositionRange(leadOffset, range) {\n  const domSelection = window.getSelection();\n\n  if (domSelection === null || !domSelection.isCollapsed) {\n    return false;\n  }\n\n  const anchorNode = domSelection.anchorNode;\n  const startOffset = leadOffset;\n  const endOffset = domSelection.anchorOffset;\n\n  if (anchorNode == null || endOffset == null) {\n    return false;\n  }\n\n  try {\n    range.setStart(anchorNode, startOffset);\n    range.setEnd(anchorNode, endOffset);\n  } catch (error) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getQueryTextForSearch(editor) {\n  let text = null;\n  editor.getEditorState().read(() => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return;\n    }\n\n    text = getTextUpToAnchor(selection);\n  });\n  return text;\n}\n/**\n * Walk backwards along user input and forward through entity title to try\n * and replace more of the user's text with entity.\n */\n\n\nfunction getFullMatchOffset(documentText, entryText, offset) {\n  let triggerOffset = offset;\n\n  for (let i = triggerOffset; i <= entryText.length; i++) {\n    if (documentText.substr(-i) === entryText.substr(0, i)) {\n      triggerOffset = i;\n    }\n  }\n\n  return triggerOffset;\n}\n/**\n * Split Lexical TextNode and return a new TextNode only containing matched text.\n * Common use cases include: removing the node, replacing with a new node.\n */\n\n\nfunction splitNodeContainingQuery(editor, match) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return null;\n  }\n\n  const anchor = selection.anchor;\n\n  if (anchor.type !== 'text') {\n    return null;\n  }\n\n  const anchorNode = anchor.getNode();\n\n  if (!anchorNode.isSimpleText()) {\n    return null;\n  }\n\n  const selectionOffset = anchor.offset;\n  const textContent = anchorNode.getTextContent().slice(0, selectionOffset);\n  const characterOffset = match.replaceableString.length;\n  const queryOffset = getFullMatchOffset(textContent, match.matchingString, characterOffset);\n  const startOffset = selectionOffset - queryOffset;\n\n  if (startOffset < 0) {\n    return null;\n  }\n\n  let newNode;\n\n  if (startOffset === 0) {\n    [newNode] = anchorNode.splitText(selectionOffset);\n  } else {\n    [, newNode] = anchorNode.splitText(startOffset, selectionOffset);\n  }\n\n  return newNode;\n}\n\nfunction isSelectionOnEntityBoundary(editor, offset) {\n  if (offset !== 0) {\n    return false;\n  }\n\n  return editor.getEditorState().read(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const prevSibling = anchorNode.getPreviousSibling();\n      return lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity();\n    }\n\n    return false;\n  });\n}\n\nfunction startTransition(callback) {\n  if (React.startTransition) {\n    React.startTransition(callback);\n  } else {\n    callback();\n  }\n} // Got from https://stackoverflow.com/a/42543908/2013580\n\n\nfunction getScrollParent(element, includeHidden) {\n  let style = getComputedStyle(element);\n  const excludeStaticParent = style.position === 'absolute';\n  const overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/;\n\n  if (style.position === 'fixed') {\n    return document.body;\n  }\n\n  for (let parent = element; parent = parent.parentElement;) {\n    style = getComputedStyle(parent);\n\n    if (excludeStaticParent && style.position === 'static') {\n      continue;\n    }\n\n    if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)) {\n      return parent;\n    }\n  }\n\n  return document.body;\n}\n\nfunction isTriggerVisibleInNearestScrollContainer(targetElement, containerElement) {\n  const tRect = targetElement.getBoundingClientRect();\n  const cRect = containerElement.getBoundingClientRect();\n  return tRect.top > cRect.top && tRect.top < cRect.bottom;\n} // Reposition the menu on scroll, window resize, and element resize.\n\n\nfunction useDynamicPositioning(resolution, targetElement, onReposition, onVisibilityChange) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  React.useEffect(() => {\n    if (targetElement != null && resolution != null) {\n      const rootElement = editor.getRootElement();\n      const rootScrollParent = rootElement != null ? getScrollParent(rootElement, false) : document.body;\n      let ticking = false;\n      let previousIsInView = isTriggerVisibleInNearestScrollContainer(targetElement, rootScrollParent);\n\n      const handleScroll = function () {\n        if (!ticking) {\n          window.requestAnimationFrame(function () {\n            onReposition();\n            ticking = false;\n          });\n          ticking = true;\n        }\n\n        const isInView = isTriggerVisibleInNearestScrollContainer(targetElement, rootScrollParent);\n\n        if (isInView !== previousIsInView) {\n          previousIsInView = isInView;\n\n          if (onVisibilityChange != null) {\n            onVisibilityChange(isInView);\n          }\n        }\n      };\n\n      const resizeObserver = new ResizeObserver(onReposition);\n      window.addEventListener('resize', onReposition);\n      document.addEventListener('scroll', handleScroll, {\n        capture: true,\n        passive: true\n      });\n      resizeObserver.observe(targetElement);\n      return () => {\n        resizeObserver.unobserve(targetElement);\n        window.removeEventListener('resize', onReposition);\n        document.removeEventListener('scroll', handleScroll);\n      };\n    }\n  }, [targetElement, editor, onVisibilityChange, onReposition, resolution]);\n}\nconst SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND = lexical.createCommand('SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND');\n\nfunction LexicalPopoverMenu({\n  close,\n  editor,\n  anchorElementRef,\n  resolution,\n  options,\n  menuRenderFn,\n  onSelectOption\n}) {\n  const [selectedIndex, setHighlightedIndex] = React.useState(null);\n  React.useEffect(() => {\n    setHighlightedIndex(0);\n  }, [resolution.match.matchingString]);\n  const selectOptionAndCleanUp = React.useCallback(selectedEntry => {\n    editor.update(() => {\n      const textNodeContainingQuery = splitNodeContainingQuery(editor, resolution.match);\n      onSelectOption(selectedEntry, textNodeContainingQuery, close, resolution.match.matchingString);\n    });\n  }, [close, editor, resolution.match, onSelectOption]);\n  const updateSelectedIndex = React.useCallback(index => {\n    const rootElem = editor.getRootElement();\n\n    if (rootElem !== null) {\n      rootElem.setAttribute('aria-activedescendant', 'typeahead-item-' + index);\n      setHighlightedIndex(index);\n    }\n  }, [editor]);\n  React.useEffect(() => {\n    return () => {\n      const rootElem = editor.getRootElement();\n\n      if (rootElem !== null) {\n        rootElem.removeAttribute('aria-activedescendant');\n      }\n    };\n  }, [editor]);\n  useLayoutEffect(() => {\n    if (options === null) {\n      setHighlightedIndex(null);\n    } else if (selectedIndex === null) {\n      updateSelectedIndex(0);\n    }\n  }, [options, selectedIndex, updateSelectedIndex]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND, ({\n      option\n    }) => {\n      if (option.ref && option.ref.current != null) {\n        scrollIntoViewIfNeeded(option.ref.current);\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW));\n  }, [editor, updateSelectedIndex]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, payload => {\n      const event = payload;\n\n      if (options !== null && options.length && selectedIndex !== null) {\n        const newSelectedIndex = selectedIndex !== options.length - 1 ? selectedIndex + 1 : 0;\n        updateSelectedIndex(newSelectedIndex);\n        const option = options[newSelectedIndex];\n\n        if (option.ref != null && option.ref.current) {\n          editor.dispatchCommand(SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND, {\n            index: newSelectedIndex,\n            option\n          });\n        }\n\n        event.preventDefault();\n        event.stopImmediatePropagation();\n      }\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, payload => {\n      const event = payload;\n\n      if (options !== null && options.length && selectedIndex !== null) {\n        const newSelectedIndex = selectedIndex !== 0 ? selectedIndex - 1 : options.length - 1;\n        updateSelectedIndex(newSelectedIndex);\n        const option = options[newSelectedIndex];\n\n        if (option.ref != null && option.ref.current) {\n          scrollIntoViewIfNeeded(option.ref.current);\n        }\n\n        event.preventDefault();\n        event.stopImmediatePropagation();\n      }\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, payload => {\n      const event = payload;\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      close();\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_TAB_COMMAND, payload => {\n      const event = payload;\n\n      if (options === null || selectedIndex === null || options[selectedIndex] == null) {\n        return false;\n      }\n\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      selectOptionAndCleanUp(options[selectedIndex]);\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {\n      if (options === null || selectedIndex === null || options[selectedIndex] == null) {\n        return false;\n      }\n\n      if (event !== null) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n      }\n\n      selectOptionAndCleanUp(options[selectedIndex]);\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW));\n  }, [selectOptionAndCleanUp, close, editor, options, selectedIndex, updateSelectedIndex]);\n  const listItemProps = React.useMemo(() => ({\n    options,\n    selectOptionAndCleanUp,\n    selectedIndex,\n    setHighlightedIndex\n  }), [selectOptionAndCleanUp, selectedIndex, options]);\n  return menuRenderFn(anchorElementRef, listItemProps, resolution.match.matchingString);\n}\n\nfunction useBasicTypeaheadTriggerMatch(trigger, {\n  minLength = 1,\n  maxLength = 75\n}) {\n  return React.useCallback(text => {\n    const validChars = '[^' + trigger + PUNCTUATION + '\\\\s]';\n    const TypeaheadTriggerRegex = new RegExp('(^|\\\\s|\\\\()(' + '[' + trigger + ']' + '((?:' + validChars + '){0,' + maxLength + '})' + ')$');\n    const match = TypeaheadTriggerRegex.exec(text);\n\n    if (match !== null) {\n      const maybeLeadingWhitespace = match[1];\n      const matchingString = match[3];\n\n      if (matchingString.length >= minLength) {\n        return {\n          leadOffset: match.index + maybeLeadingWhitespace.length,\n          matchingString,\n          replaceableString: match[2]\n        };\n      }\n    }\n\n    return null;\n  }, [maxLength, minLength, trigger]);\n}\n\nfunction useMenuAnchorRef(resolution, setResolution, className) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const anchorElementRef = React.useRef(document.createElement('div'));\n  const positionMenu = React.useCallback(() => {\n    const rootElement = editor.getRootElement();\n    const containerDiv = anchorElementRef.current;\n\n    if (rootElement !== null && resolution !== null) {\n      const {\n        left,\n        top,\n        width,\n        height\n      } = resolution.getRect();\n      containerDiv.style.top = `${top + window.pageYOffset}px`;\n      containerDiv.style.left = `${left + window.pageXOffset}px`;\n      containerDiv.style.height = `${height}px`;\n      containerDiv.style.width = `${width}px`;\n\n      if (!containerDiv.isConnected) {\n        if (className != null) {\n          containerDiv.className = className;\n        }\n\n        containerDiv.setAttribute('aria-label', 'Typeahead menu');\n        containerDiv.setAttribute('id', 'typeahead-menu');\n        containerDiv.setAttribute('role', 'listbox');\n        containerDiv.style.display = 'block';\n        containerDiv.style.position = 'absolute';\n        document.body.append(containerDiv);\n      }\n\n      anchorElementRef.current = containerDiv;\n      rootElement.setAttribute('aria-controls', 'typeahead-menu');\n    }\n  }, [editor, resolution, className]);\n  React.useEffect(() => {\n    const rootElement = editor.getRootElement();\n\n    if (resolution !== null) {\n      positionMenu();\n      return () => {\n        if (rootElement !== null) {\n          rootElement.removeAttribute('aria-controls');\n        }\n\n        const containerDiv = anchorElementRef.current;\n\n        if (containerDiv !== null && containerDiv.isConnected) {\n          containerDiv.remove();\n        }\n      };\n    }\n  }, [editor, positionMenu, resolution]);\n  const onVisibilityChange = React.useCallback(isInView => {\n    if (resolution !== null) {\n      if (!isInView) {\n        setResolution(null);\n      }\n    }\n  }, [resolution, setResolution]);\n  useDynamicPositioning(resolution, anchorElementRef.current, positionMenu, onVisibilityChange);\n  return anchorElementRef;\n}\n\nfunction LexicalTypeaheadMenuPlugin({\n  options,\n  onQueryChange,\n  onSelectOption,\n  onOpen,\n  onClose,\n  menuRenderFn,\n  triggerFn,\n  anchorClassName\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [resolution, setResolution] = React.useState(null);\n  const anchorElementRef = useMenuAnchorRef(resolution, setResolution, anchorClassName);\n  const closeTypeahead = React.useCallback(() => {\n    setResolution(null);\n\n    if (onClose != null && resolution !== null) {\n      onClose();\n    }\n  }, [onClose, resolution]);\n  const openTypeahead = React.useCallback(res => {\n    setResolution(res);\n\n    if (onOpen != null && resolution === null) {\n      onOpen(res);\n    }\n  }, [onOpen, resolution]);\n  React.useEffect(() => {\n    const updateListener = () => {\n      editor.getEditorState().read(() => {\n        const range = document.createRange();\n        const selection = lexical.$getSelection();\n        const text = getQueryTextForSearch(editor);\n\n        if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed() || text === null || range === null) {\n          closeTypeahead();\n          return;\n        }\n\n        const match = triggerFn(text, editor);\n        onQueryChange(match ? match.matchingString : null);\n\n        if (match !== null && !isSelectionOnEntityBoundary(editor, match.leadOffset)) {\n          const isRangePositioned = tryToPositionRange(match.leadOffset, range);\n\n          if (isRangePositioned !== null) {\n            startTransition(() => openTypeahead({\n              getRect: () => range.getBoundingClientRect(),\n              match\n            }));\n            return;\n          }\n        }\n\n        closeTypeahead();\n      });\n    };\n\n    const removeUpdateListener = editor.registerUpdateListener(updateListener);\n    return () => {\n      removeUpdateListener();\n    };\n  }, [editor, triggerFn, onQueryChange, resolution, closeTypeahead, openTypeahead]);\n  return resolution === null || editor === null ? null : /*#__PURE__*/React.createElement(LexicalPopoverMenu, {\n    close: closeTypeahead,\n    resolution: resolution,\n    editor: editor,\n    anchorElementRef: anchorElementRef,\n    options: options,\n    menuRenderFn: menuRenderFn,\n    onSelectOption: onSelectOption\n  });\n}\nfunction LexicalNodeMenuPlugin({\n  options,\n  nodeKey,\n  onClose,\n  onOpen,\n  onSelectOption,\n  menuRenderFn,\n  anchorClassName\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [resolution, setResolution] = React.useState(null);\n  const anchorElementRef = useMenuAnchorRef(resolution, setResolution, anchorClassName);\n  const closeNodeMenu = React.useCallback(() => {\n    setResolution(null);\n\n    if (onClose != null && resolution !== null) {\n      onClose();\n    }\n  }, [onClose, resolution]);\n  const openNodeMenu = React.useCallback(res => {\n    setResolution(res);\n\n    if (onOpen != null && resolution === null) {\n      onOpen(res);\n    }\n  }, [onOpen, resolution]);\n  const positionOrCloseMenu = React.useCallback(() => {\n    if (nodeKey) {\n      editor.update(() => {\n        const node = lexical.$getNodeByKey(nodeKey);\n        const domElement = editor.getElementByKey(nodeKey);\n\n        if (node != null && domElement != null) {\n          const text = node.getTextContent();\n\n          if (resolution == null || resolution.match.matchingString !== text) {\n            startTransition(() => openNodeMenu({\n              getRect: () => domElement.getBoundingClientRect(),\n              match: {\n                leadOffset: text.length,\n                matchingString: text,\n                replaceableString: text\n              }\n            }));\n          }\n        }\n      });\n    } else if (nodeKey == null && resolution != null) {\n      closeNodeMenu();\n    }\n  }, [closeNodeMenu, editor, nodeKey, openNodeMenu, resolution]);\n  React.useEffect(() => {\n    positionOrCloseMenu();\n  }, [positionOrCloseMenu, nodeKey]);\n  React.useEffect(() => {\n    if (nodeKey != null) {\n      return editor.registerUpdateListener(({\n        dirtyElements\n      }) => {\n        if (dirtyElements.get(nodeKey)) {\n          positionOrCloseMenu();\n        }\n      });\n    }\n  }, [editor, positionOrCloseMenu, nodeKey]);\n  return resolution === null || editor === null ? null : /*#__PURE__*/React.createElement(LexicalPopoverMenu, {\n    close: closeNodeMenu,\n    resolution: resolution,\n    editor: editor,\n    anchorElementRef: anchorElementRef,\n    options: options,\n    menuRenderFn: menuRenderFn,\n    onSelectOption: onSelectOption\n  });\n}\n\nexports.LexicalNodeMenuPlugin = LexicalNodeMenuPlugin;\nexports.LexicalTypeaheadMenuPlugin = LexicalTypeaheadMenuPlugin;\nexports.PUNCTUATION = PUNCTUATION;\nexports.SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND = SCROLL_TYPEAHEAD_OPTION_INTO_VIEW_COMMAND;\nexports.TypeaheadOption = TypeaheadOption;\nexports.getScrollParent = getScrollParent;\nexports.useBasicTypeaheadTriggerMatch = useBasicTypeaheadTriggerMatch;\nexports.useDynamicPositioning = useDynamicPositioning;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFR5cGVhaGVhZE1lbnVQbHVnaW4uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLDRHQUF1QztBQUM1RSxZQUFZLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyx3REFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1DQUFtQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLDhCQUE4Qix1QkFBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qiw4QkFBOEI7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsNkdBQTZHLG9CQUFvQjtBQUNqSTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtDQUFrQyx5QkFBeUI7QUFDM0QsbUNBQW1DLDBCQUEwQjtBQUM3RCxxQ0FBcUMsT0FBTztBQUM1QyxvQ0FBb0MsTUFBTTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLDZCQUE2QjtBQUM3QixrQ0FBa0M7QUFDbEMsbUJBQW1CO0FBQ25CLGlEQUFpRDtBQUNqRCx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHFDQUFxQztBQUNyQyw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsVHlwZWFoZWFkTWVudVBsdWdpbi5kZXYuanM/ZGQ1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIExleGljYWxDb21wb3NlckNvbnRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIGxleGljYWwgPSByZXF1aXJlKCdsZXhpY2FsJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IHVzZUxheW91dEVmZmVjdEltcGwgPSBDQU5fVVNFX0RPTSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbnZhciB1c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3RJbXBsO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBQVU5DVFVBVElPTiA9ICdcXFxcLixcXFxcK1xcXFwqXFxcXD9cXFxcJFxcXFxAXFxcXHwje31cXFxcKFxcXFwpXFxcXF5cXFxcLVxcXFxbXFxcXF1cXFxcXFxcXC8hJVxcJ1wifj08Pl86Oyc7XG5jbGFzcyBUeXBlYWhlYWRPcHRpb24ge1xuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuc2V0UmVmRWxlbWVudCA9IHRoaXMuc2V0UmVmRWxlbWVudC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgc2V0UmVmRWxlbWVudChlbGVtZW50KSB7XG4gICAgdGhpcy5yZWYgPSB7XG4gICAgICBjdXJyZW50OiBlbGVtZW50XG4gICAgfTtcbiAgfVxuXG59XG5cbmNvbnN0IHNjcm9sbEludG9WaWV3SWZOZWVkZWQgPSB0YXJnZXQgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHlwZWFoZWFkLW1lbnUnKTtcbiAgaWYgKCFjb250YWluZXIpIHJldHVybjtcbiAgY29uc3QgdHlwZWFoZWFkQ29udGFpbmVyTm9kZSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcudHlwZWFoZWFkLXBvcG92ZXInKTtcbiAgaWYgKCF0eXBlYWhlYWRDb250YWluZXJOb2RlKSByZXR1cm47XG4gIGNvbnN0IHR5cGVhaGVhZFJlY3QgPSB0eXBlYWhlYWRDb250YWluZXJOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gIGlmICh0eXBlYWhlYWRSZWN0LnRvcCArIHR5cGVhaGVhZFJlY3QuaGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgdHlwZWFoZWFkQ29udGFpbmVyTm9kZS5zY3JvbGxJbnRvVmlldyh7XG4gICAgICBibG9jazogJ2NlbnRlcidcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0eXBlYWhlYWRSZWN0LnRvcCA8IDApIHtcbiAgICB0eXBlYWhlYWRDb250YWluZXJOb2RlLnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiAnY2VudGVyJ1xuICAgIH0pO1xuICB9XG5cbiAgdGFyZ2V0LnNjcm9sbEludG9WaWV3KHtcbiAgICBibG9jazogJ25lYXJlc3QnXG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZ2V0VGV4dFVwVG9BbmNob3Ioc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG5cbiAgaWYgKGFuY2hvci50eXBlICE9PSAndGV4dCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuXG4gIGlmICghYW5jaG9yTm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgcmV0dXJuIGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnQoKS5zbGljZSgwLCBhbmNob3JPZmZzZXQpO1xufVxuXG5mdW5jdGlvbiB0cnlUb1Bvc2l0aW9uUmFuZ2UobGVhZE9mZnNldCwgcmFuZ2UpIHtcbiAgY29uc3QgZG9tU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmIChkb21TZWxlY3Rpb24gPT09IG51bGwgfHwgIWRvbVNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgY29uc3Qgc3RhcnRPZmZzZXQgPSBsZWFkT2Zmc2V0O1xuICBjb25zdCBlbmRPZmZzZXQgPSBkb21TZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuXG4gIGlmIChhbmNob3JOb2RlID09IG51bGwgfHwgZW5kT2Zmc2V0ID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0cnkge1xuICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvck5vZGUsIHN0YXJ0T2Zmc2V0KTtcbiAgICByYW5nZS5zZXRFbmQoYW5jaG9yTm9kZSwgZW5kT2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0UXVlcnlUZXh0Rm9yU2VhcmNoKGVkaXRvcikge1xuICBsZXQgdGV4dCA9IG51bGw7XG4gIGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0ZXh0ID0gZ2V0VGV4dFVwVG9BbmNob3Ioc2VsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiB0ZXh0O1xufVxuLyoqXG4gKiBXYWxrIGJhY2t3YXJkcyBhbG9uZyB1c2VyIGlucHV0IGFuZCBmb3J3YXJkIHRocm91Z2ggZW50aXR5IHRpdGxlIHRvIHRyeVxuICogYW5kIHJlcGxhY2UgbW9yZSBvZiB0aGUgdXNlcidzIHRleHQgd2l0aCBlbnRpdHkuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRGdWxsTWF0Y2hPZmZzZXQoZG9jdW1lbnRUZXh0LCBlbnRyeVRleHQsIG9mZnNldCkge1xuICBsZXQgdHJpZ2dlck9mZnNldCA9IG9mZnNldDtcblxuICBmb3IgKGxldCBpID0gdHJpZ2dlck9mZnNldDsgaSA8PSBlbnRyeVRleHQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZG9jdW1lbnRUZXh0LnN1YnN0cigtaSkgPT09IGVudHJ5VGV4dC5zdWJzdHIoMCwgaSkpIHtcbiAgICAgIHRyaWdnZXJPZmZzZXQgPSBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cmlnZ2VyT2Zmc2V0O1xufVxuLyoqXG4gKiBTcGxpdCBMZXhpY2FsIFRleHROb2RlIGFuZCByZXR1cm4gYSBuZXcgVGV4dE5vZGUgb25seSBjb250YWluaW5nIG1hdGNoZWQgdGV4dC5cbiAqIENvbW1vbiB1c2UgY2FzZXMgaW5jbHVkZTogcmVtb3ZpbmcgdGhlIG5vZGUsIHJlcGxhY2luZyB3aXRoIGEgbmV3IG5vZGUuXG4gKi9cblxuXG5mdW5jdGlvbiBzcGxpdE5vZGVDb250YWluaW5nUXVlcnkoZWRpdG9yLCBtYXRjaCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG5cbiAgaWYgKGFuY2hvci50eXBlICE9PSAndGV4dCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuXG4gIGlmICghYW5jaG9yTm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3Qgc2VsZWN0aW9uT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgdGV4dENvbnRlbnQgPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCkuc2xpY2UoMCwgc2VsZWN0aW9uT2Zmc2V0KTtcbiAgY29uc3QgY2hhcmFjdGVyT2Zmc2V0ID0gbWF0Y2gucmVwbGFjZWFibGVTdHJpbmcubGVuZ3RoO1xuICBjb25zdCBxdWVyeU9mZnNldCA9IGdldEZ1bGxNYXRjaE9mZnNldCh0ZXh0Q29udGVudCwgbWF0Y2gubWF0Y2hpbmdTdHJpbmcsIGNoYXJhY3Rlck9mZnNldCk7XG4gIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gc2VsZWN0aW9uT2Zmc2V0IC0gcXVlcnlPZmZzZXQ7XG5cbiAgaWYgKHN0YXJ0T2Zmc2V0IDwgMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IG5ld05vZGU7XG5cbiAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAwKSB7XG4gICAgW25ld05vZGVdID0gYW5jaG9yTm9kZS5zcGxpdFRleHQoc2VsZWN0aW9uT2Zmc2V0KTtcbiAgfSBlbHNlIHtcbiAgICBbLCBuZXdOb2RlXSA9IGFuY2hvck5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBzZWxlY3Rpb25PZmZzZXQpO1xuICB9XG5cbiAgcmV0dXJuIG5ld05vZGU7XG59XG5cbmZ1bmN0aW9uIGlzU2VsZWN0aW9uT25FbnRpdHlCb3VuZGFyeShlZGl0b3IsIG9mZnNldCkge1xuICBpZiAob2Zmc2V0ICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgcHJldlNpYmxpbmcgPSBhbmNob3JOb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgcmV0dXJuIGxleGljYWwuJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpICYmIHByZXZTaWJsaW5nLmlzVGV4dEVudGl0eSgpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihjYWxsYmFjaykge1xuICBpZiAoUmVhY3Quc3RhcnRUcmFuc2l0aW9uKSB7XG4gICAgUmVhY3Quc3RhcnRUcmFuc2l0aW9uKGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59IC8vIEdvdCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MjU0MzkwOC8yMDEzNTgwXG5cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQsIGluY2x1ZGVIaWRkZW4pIHtcbiAgbGV0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgY29uc3QgZXhjbHVkZVN0YXRpY1BhcmVudCA9IHN0eWxlLnBvc2l0aW9uID09PSAnYWJzb2x1dGUnO1xuICBjb25zdCBvdmVyZmxvd1JlZ2V4ID0gaW5jbHVkZUhpZGRlbiA/IC8oYXV0b3xzY3JvbGx8aGlkZGVuKS8gOiAvKGF1dG98c2Nyb2xsKS87XG5cbiAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBmb3IgKGxldCBwYXJlbnQgPSBlbGVtZW50OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDspIHtcbiAgICBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocGFyZW50KTtcblxuICAgIGlmIChleGNsdWRlU3RhdGljUGFyZW50ICYmIHN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG92ZXJmbG93UmVnZXgudGVzdChzdHlsZS5vdmVyZmxvdyArIHN0eWxlLm92ZXJmbG93WSArIHN0eWxlLm92ZXJmbG93WCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG59XG5cbmZ1bmN0aW9uIGlzVHJpZ2dlclZpc2libGVJbk5lYXJlc3RTY3JvbGxDb250YWluZXIodGFyZ2V0RWxlbWVudCwgY29udGFpbmVyRWxlbWVudCkge1xuICBjb25zdCB0UmVjdCA9IHRhcmdldEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNSZWN0ID0gY29udGFpbmVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHRSZWN0LnRvcCA+IGNSZWN0LnRvcCAmJiB0UmVjdC50b3AgPCBjUmVjdC5ib3R0b207XG59IC8vIFJlcG9zaXRpb24gdGhlIG1lbnUgb24gc2Nyb2xsLCB3aW5kb3cgcmVzaXplLCBhbmQgZWxlbWVudCByZXNpemUuXG5cblxuZnVuY3Rpb24gdXNlRHluYW1pY1Bvc2l0aW9uaW5nKHJlc29sdXRpb24sIHRhcmdldEVsZW1lbnQsIG9uUmVwb3NpdGlvbiwgb25WaXNpYmlsaXR5Q2hhbmdlKSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRhcmdldEVsZW1lbnQgIT0gbnVsbCAmJiByZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgICBjb25zdCByb290U2Nyb2xsUGFyZW50ID0gcm9vdEVsZW1lbnQgIT0gbnVsbCA/IGdldFNjcm9sbFBhcmVudChyb290RWxlbWVudCwgZmFsc2UpIDogZG9jdW1lbnQuYm9keTtcbiAgICAgIGxldCB0aWNraW5nID0gZmFsc2U7XG4gICAgICBsZXQgcHJldmlvdXNJc0luVmlldyA9IGlzVHJpZ2dlclZpc2libGVJbk5lYXJlc3RTY3JvbGxDb250YWluZXIodGFyZ2V0RWxlbWVudCwgcm9vdFNjcm9sbFBhcmVudCk7XG5cbiAgICAgIGNvbnN0IGhhbmRsZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aWNraW5nKSB7XG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvblJlcG9zaXRpb24oKTtcbiAgICAgICAgICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aWNraW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzSW5WaWV3ID0gaXNUcmlnZ2VyVmlzaWJsZUluTmVhcmVzdFNjcm9sbENvbnRhaW5lcih0YXJnZXRFbGVtZW50LCByb290U2Nyb2xsUGFyZW50KTtcblxuICAgICAgICBpZiAoaXNJblZpZXcgIT09IHByZXZpb3VzSXNJblZpZXcpIHtcbiAgICAgICAgICBwcmV2aW91c0lzSW5WaWV3ID0gaXNJblZpZXc7XG5cbiAgICAgICAgICBpZiAob25WaXNpYmlsaXR5Q2hhbmdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9uVmlzaWJpbGl0eUNoYW5nZShpc0luVmlldyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihvblJlcG9zaXRpb24pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVwb3NpdGlvbik7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGwsIHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHRhcmdldEVsZW1lbnQpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRhcmdldEVsZW1lbnQpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXBvc2l0aW9uKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbdGFyZ2V0RWxlbWVudCwgZWRpdG9yLCBvblZpc2liaWxpdHlDaGFuZ2UsIG9uUmVwb3NpdGlvbiwgcmVzb2x1dGlvbl0pO1xufVxuY29uc3QgU0NST0xMX1RZUEVBSEVBRF9PUFRJT05fSU5UT19WSUVXX0NPTU1BTkQgPSBsZXhpY2FsLmNyZWF0ZUNvbW1hbmQoJ1NDUk9MTF9UWVBFQUhFQURfT1BUSU9OX0lOVE9fVklFV19DT01NQU5EJyk7XG5cbmZ1bmN0aW9uIExleGljYWxQb3BvdmVyTWVudSh7XG4gIGNsb3NlLFxuICBlZGl0b3IsXG4gIGFuY2hvckVsZW1lbnRSZWYsXG4gIHJlc29sdXRpb24sXG4gIG9wdGlvbnMsXG4gIG1lbnVSZW5kZXJGbixcbiAgb25TZWxlY3RPcHRpb25cbn0pIHtcbiAgY29uc3QgW3NlbGVjdGVkSW5kZXgsIHNldEhpZ2hsaWdodGVkSW5kZXhdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SGlnaGxpZ2h0ZWRJbmRleCgwKTtcbiAgfSwgW3Jlc29sdXRpb24ubWF0Y2gubWF0Y2hpbmdTdHJpbmddKTtcbiAgY29uc3Qgc2VsZWN0T3B0aW9uQW5kQ2xlYW5VcCA9IFJlYWN0LnVzZUNhbGxiYWNrKHNlbGVjdGVkRW50cnkgPT4ge1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgdGV4dE5vZGVDb250YWluaW5nUXVlcnkgPSBzcGxpdE5vZGVDb250YWluaW5nUXVlcnkoZWRpdG9yLCByZXNvbHV0aW9uLm1hdGNoKTtcbiAgICAgIG9uU2VsZWN0T3B0aW9uKHNlbGVjdGVkRW50cnksIHRleHROb2RlQ29udGFpbmluZ1F1ZXJ5LCBjbG9zZSwgcmVzb2x1dGlvbi5tYXRjaC5tYXRjaGluZ1N0cmluZyk7XG4gICAgfSk7XG4gIH0sIFtjbG9zZSwgZWRpdG9yLCByZXNvbHV0aW9uLm1hdGNoLCBvblNlbGVjdE9wdGlvbl0pO1xuICBjb25zdCB1cGRhdGVTZWxlY3RlZEluZGV4ID0gUmVhY3QudXNlQ2FsbGJhY2soaW5kZXggPT4ge1xuICAgIGNvbnN0IHJvb3RFbGVtID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG5cbiAgICBpZiAocm9vdEVsZW0gIT09IG51bGwpIHtcbiAgICAgIHJvb3RFbGVtLnNldEF0dHJpYnV0ZSgnYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgJ3R5cGVhaGVhZC1pdGVtLScgKyBpbmRleCk7XG4gICAgICBzZXRIaWdobGlnaHRlZEluZGV4KGluZGV4KTtcbiAgICB9XG4gIH0sIFtlZGl0b3JdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdEVsZW0gPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcblxuICAgICAgaWYgKHJvb3RFbGVtICE9PSBudWxsKSB7XG4gICAgICAgIHJvb3RFbGVtLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VkaXRvcl0pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChvcHRpb25zID09PSBudWxsKSB7XG4gICAgICBzZXRIaWdobGlnaHRlZEluZGV4KG51bGwpO1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRJbmRleCA9PT0gbnVsbCkge1xuICAgICAgdXBkYXRlU2VsZWN0ZWRJbmRleCgwKTtcbiAgICB9XG4gIH0sIFtvcHRpb25zLCBzZWxlY3RlZEluZGV4LCB1cGRhdGVTZWxlY3RlZEluZGV4XSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHV0aWxzLm1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChTQ1JPTExfVFlQRUFIRUFEX09QVElPTl9JTlRPX1ZJRVdfQ09NTUFORCwgKHtcbiAgICAgIG9wdGlvblxuICAgIH0pID0+IHtcbiAgICAgIGlmIChvcHRpb24ucmVmICYmIG9wdGlvbi5yZWYuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgIHNjcm9sbEludG9WaWV3SWZOZWVkZWQob3B0aW9uLnJlZi5jdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSk7XG4gIH0sIFtlZGl0b3IsIHVwZGF0ZVNlbGVjdGVkSW5kZXhdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gdXRpbHMubWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgICBjb25zdCBldmVudCA9IHBheWxvYWQ7XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMubGVuZ3RoICYmIHNlbGVjdGVkSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbmV3U2VsZWN0ZWRJbmRleCA9IHNlbGVjdGVkSW5kZXggIT09IG9wdGlvbnMubGVuZ3RoIC0gMSA/IHNlbGVjdGVkSW5kZXggKyAxIDogMDtcbiAgICAgICAgdXBkYXRlU2VsZWN0ZWRJbmRleChuZXdTZWxlY3RlZEluZGV4KTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gb3B0aW9uc1tuZXdTZWxlY3RlZEluZGV4XTtcblxuICAgICAgICBpZiAob3B0aW9uLnJlZiAhPSBudWxsICYmIG9wdGlvbi5yZWYuY3VycmVudCkge1xuICAgICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0NST0xMX1RZUEVBSEVBRF9PUFRJT05fSU5UT19WSUVXX0NPTU1BTkQsIHtcbiAgICAgICAgICAgIGluZGV4OiBuZXdTZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgb3B0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQVJST1dfVVBfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgICBjb25zdCBldmVudCA9IHBheWxvYWQ7XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMubGVuZ3RoICYmIHNlbGVjdGVkSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgbmV3U2VsZWN0ZWRJbmRleCA9IHNlbGVjdGVkSW5kZXggIT09IDAgPyBzZWxlY3RlZEluZGV4IC0gMSA6IG9wdGlvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgdXBkYXRlU2VsZWN0ZWRJbmRleChuZXdTZWxlY3RlZEluZGV4KTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gb3B0aW9uc1tuZXdTZWxlY3RlZEluZGV4XTtcblxuICAgICAgICBpZiAob3B0aW9uLnJlZiAhPSBudWxsICYmIG9wdGlvbi5yZWYuY3VycmVudCkge1xuICAgICAgICAgIHNjcm9sbEludG9WaWV3SWZOZWVkZWQob3B0aW9uLnJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9FU0NBUEVfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgICBjb25zdCBldmVudCA9IHBheWxvYWQ7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICBjbG9zZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfVEFCX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgICAgY29uc3QgZXZlbnQgPSBwYXlsb2FkO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBzZWxlY3RlZEluZGV4ID09PSBudWxsIHx8IG9wdGlvbnNbc2VsZWN0ZWRJbmRleF0gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIHNlbGVjdE9wdGlvbkFuZENsZWFuVXAob3B0aW9uc1tzZWxlY3RlZEluZGV4XSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9FTlRFUl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBzZWxlY3RlZEluZGV4ID09PSBudWxsIHx8IG9wdGlvbnNbc2VsZWN0ZWRJbmRleF0gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudCAhPT0gbnVsbCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0T3B0aW9uQW5kQ2xlYW5VcChvcHRpb25zW3NlbGVjdGVkSW5kZXhdKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9MT1cpKTtcbiAgfSwgW3NlbGVjdE9wdGlvbkFuZENsZWFuVXAsIGNsb3NlLCBlZGl0b3IsIG9wdGlvbnMsIHNlbGVjdGVkSW5kZXgsIHVwZGF0ZVNlbGVjdGVkSW5kZXhdKTtcbiAgY29uc3QgbGlzdEl0ZW1Qcm9wcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBvcHRpb25zLFxuICAgIHNlbGVjdE9wdGlvbkFuZENsZWFuVXAsXG4gICAgc2VsZWN0ZWRJbmRleCxcbiAgICBzZXRIaWdobGlnaHRlZEluZGV4XG4gIH0pLCBbc2VsZWN0T3B0aW9uQW5kQ2xlYW5VcCwgc2VsZWN0ZWRJbmRleCwgb3B0aW9uc10pO1xuICByZXR1cm4gbWVudVJlbmRlckZuKGFuY2hvckVsZW1lbnRSZWYsIGxpc3RJdGVtUHJvcHMsIHJlc29sdXRpb24ubWF0Y2gubWF0Y2hpbmdTdHJpbmcpO1xufVxuXG5mdW5jdGlvbiB1c2VCYXNpY1R5cGVhaGVhZFRyaWdnZXJNYXRjaCh0cmlnZ2VyLCB7XG4gIG1pbkxlbmd0aCA9IDEsXG4gIG1heExlbmd0aCA9IDc1XG59KSB7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayh0ZXh0ID0+IHtcbiAgICBjb25zdCB2YWxpZENoYXJzID0gJ1teJyArIHRyaWdnZXIgKyBQVU5DVFVBVElPTiArICdcXFxcc10nO1xuICAgIGNvbnN0IFR5cGVhaGVhZFRyaWdnZXJSZWdleCA9IG5ldyBSZWdFeHAoJyhefFxcXFxzfFxcXFwoKSgnICsgJ1snICsgdHJpZ2dlciArICddJyArICcoKD86JyArIHZhbGlkQ2hhcnMgKyAnKXswLCcgKyBtYXhMZW5ndGggKyAnfSknICsgJykkJyk7XG4gICAgY29uc3QgbWF0Y2ggPSBUeXBlYWhlYWRUcmlnZ2VyUmVnZXguZXhlYyh0ZXh0KTtcblxuICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgbWF5YmVMZWFkaW5nV2hpdGVzcGFjZSA9IG1hdGNoWzFdO1xuICAgICAgY29uc3QgbWF0Y2hpbmdTdHJpbmcgPSBtYXRjaFszXTtcblxuICAgICAgaWYgKG1hdGNoaW5nU3RyaW5nLmxlbmd0aCA+PSBtaW5MZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWFkT2Zmc2V0OiBtYXRjaC5pbmRleCArIG1heWJlTGVhZGluZ1doaXRlc3BhY2UubGVuZ3RoLFxuICAgICAgICAgIG1hdGNoaW5nU3RyaW5nLFxuICAgICAgICAgIHJlcGxhY2VhYmxlU3RyaW5nOiBtYXRjaFsyXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LCBbbWF4TGVuZ3RoLCBtaW5MZW5ndGgsIHRyaWdnZXJdKTtcbn1cblxuZnVuY3Rpb24gdXNlTWVudUFuY2hvclJlZihyZXNvbHV0aW9uLCBzZXRSZXNvbHV0aW9uLCBjbGFzc05hbWUpIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgYW5jaG9yRWxlbWVudFJlZiA9IFJlYWN0LnVzZVJlZihkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gIGNvbnN0IHBvc2l0aW9uTWVudSA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgIGNvbnN0IGNvbnRhaW5lckRpdiA9IGFuY2hvckVsZW1lbnRSZWYuY3VycmVudDtcblxuICAgIGlmIChyb290RWxlbWVudCAhPT0gbnVsbCAmJiByZXNvbHV0aW9uICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxlZnQsXG4gICAgICAgIHRvcCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHJlc29sdXRpb24uZ2V0UmVjdCgpO1xuICAgICAgY29udGFpbmVyRGl2LnN0eWxlLnRvcCA9IGAke3RvcCArIHdpbmRvdy5wYWdlWU9mZnNldH1weGA7XG4gICAgICBjb250YWluZXJEaXYuc3R5bGUubGVmdCA9IGAke2xlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXR9cHhgO1xuICAgICAgY29udGFpbmVyRGl2LnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgICBjb250YWluZXJEaXYuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG5cbiAgICAgIGlmICghY29udGFpbmVyRGl2LmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIGlmIChjbGFzc05hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRhaW5lckRpdi5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb250YWluZXJEaXYuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ1R5cGVhaGVhZCBtZW51Jyk7XG4gICAgICAgIGNvbnRhaW5lckRpdi5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3R5cGVhaGVhZC1tZW51Jyk7XG4gICAgICAgIGNvbnRhaW5lckRpdi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnbGlzdGJveCcpO1xuICAgICAgICBjb250YWluZXJEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIGNvbnRhaW5lckRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGNvbnRhaW5lckRpdik7XG4gICAgICB9XG5cbiAgICAgIGFuY2hvckVsZW1lbnRSZWYuY3VycmVudCA9IGNvbnRhaW5lckRpdjtcbiAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycsICd0eXBlYWhlYWQtbWVudScpO1xuICAgIH1cbiAgfSwgW2VkaXRvciwgcmVzb2x1dGlvbiwgY2xhc3NOYW1lXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcblxuICAgIGlmIChyZXNvbHV0aW9uICE9PSBudWxsKSB7XG4gICAgICBwb3NpdGlvbk1lbnUoKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChyb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGFpbmVyRGl2ID0gYW5jaG9yRWxlbWVudFJlZi5jdXJyZW50O1xuXG4gICAgICAgIGlmIChjb250YWluZXJEaXYgIT09IG51bGwgJiYgY29udGFpbmVyRGl2LmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgY29udGFpbmVyRGl2LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2VkaXRvciwgcG9zaXRpb25NZW51LCByZXNvbHV0aW9uXSk7XG4gIGNvbnN0IG9uVmlzaWJpbGl0eUNoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGlzSW5WaWV3ID0+IHtcbiAgICBpZiAocmVzb2x1dGlvbiAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFpc0luVmlldykge1xuICAgICAgICBzZXRSZXNvbHV0aW9uKG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW3Jlc29sdXRpb24sIHNldFJlc29sdXRpb25dKTtcbiAgdXNlRHluYW1pY1Bvc2l0aW9uaW5nKHJlc29sdXRpb24sIGFuY2hvckVsZW1lbnRSZWYuY3VycmVudCwgcG9zaXRpb25NZW51LCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICByZXR1cm4gYW5jaG9yRWxlbWVudFJlZjtcbn1cblxuZnVuY3Rpb24gTGV4aWNhbFR5cGVhaGVhZE1lbnVQbHVnaW4oe1xuICBvcHRpb25zLFxuICBvblF1ZXJ5Q2hhbmdlLFxuICBvblNlbGVjdE9wdGlvbixcbiAgb25PcGVuLFxuICBvbkNsb3NlLFxuICBtZW51UmVuZGVyRm4sXG4gIHRyaWdnZXJGbixcbiAgYW5jaG9yQ2xhc3NOYW1lXG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IFtyZXNvbHV0aW9uLCBzZXRSZXNvbHV0aW9uXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBhbmNob3JFbGVtZW50UmVmID0gdXNlTWVudUFuY2hvclJlZihyZXNvbHV0aW9uLCBzZXRSZXNvbHV0aW9uLCBhbmNob3JDbGFzc05hbWUpO1xuICBjb25zdCBjbG9zZVR5cGVhaGVhZCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRSZXNvbHV0aW9uKG51bGwpO1xuXG4gICAgaWYgKG9uQ2xvc2UgIT0gbnVsbCAmJiByZXNvbHV0aW9uICE9PSBudWxsKSB7XG4gICAgICBvbkNsb3NlKCk7XG4gICAgfVxuICB9LCBbb25DbG9zZSwgcmVzb2x1dGlvbl0pO1xuICBjb25zdCBvcGVuVHlwZWFoZWFkID0gUmVhY3QudXNlQ2FsbGJhY2socmVzID0+IHtcbiAgICBzZXRSZXNvbHV0aW9uKHJlcyk7XG5cbiAgICBpZiAob25PcGVuICE9IG51bGwgJiYgcmVzb2x1dGlvbiA9PT0gbnVsbCkge1xuICAgICAgb25PcGVuKHJlcyk7XG4gICAgfVxuICB9LCBbb25PcGVuLCByZXNvbHV0aW9uXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdXBkYXRlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGdldFF1ZXJ5VGV4dEZvclNlYXJjaChlZGl0b3IpO1xuXG4gICAgICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCB0ZXh0ID09PSBudWxsIHx8IHJhbmdlID09PSBudWxsKSB7XG4gICAgICAgICAgY2xvc2VUeXBlYWhlYWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtYXRjaCA9IHRyaWdnZXJGbih0ZXh0LCBlZGl0b3IpO1xuICAgICAgICBvblF1ZXJ5Q2hhbmdlKG1hdGNoID8gbWF0Y2gubWF0Y2hpbmdTdHJpbmcgOiBudWxsKTtcblxuICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgIWlzU2VsZWN0aW9uT25FbnRpdHlCb3VuZGFyeShlZGl0b3IsIG1hdGNoLmxlYWRPZmZzZXQpKSB7XG4gICAgICAgICAgY29uc3QgaXNSYW5nZVBvc2l0aW9uZWQgPSB0cnlUb1Bvc2l0aW9uUmFuZ2UobWF0Y2gubGVhZE9mZnNldCwgcmFuZ2UpO1xuXG4gICAgICAgICAgaWYgKGlzUmFuZ2VQb3NpdGlvbmVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4gb3BlblR5cGVhaGVhZCh7XG4gICAgICAgICAgICAgIGdldFJlY3Q6ICgpID0+IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICBtYXRjaFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNsb3NlVHlwZWFoZWFkKCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY29uc3QgcmVtb3ZlVXBkYXRlTGlzdGVuZXIgPSBlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcih1cGRhdGVMaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlbW92ZVVwZGF0ZUxpc3RlbmVyKCk7XG4gICAgfTtcbiAgfSwgW2VkaXRvciwgdHJpZ2dlckZuLCBvblF1ZXJ5Q2hhbmdlLCByZXNvbHV0aW9uLCBjbG9zZVR5cGVhaGVhZCwgb3BlblR5cGVhaGVhZF0pO1xuICByZXR1cm4gcmVzb2x1dGlvbiA9PT0gbnVsbCB8fCBlZGl0b3IgPT09IG51bGwgPyBudWxsIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGV4aWNhbFBvcG92ZXJNZW51LCB7XG4gICAgY2xvc2U6IGNsb3NlVHlwZWFoZWFkLFxuICAgIHJlc29sdXRpb246IHJlc29sdXRpb24sXG4gICAgZWRpdG9yOiBlZGl0b3IsXG4gICAgYW5jaG9yRWxlbWVudFJlZjogYW5jaG9yRWxlbWVudFJlZixcbiAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgIG1lbnVSZW5kZXJGbjogbWVudVJlbmRlckZuLFxuICAgIG9uU2VsZWN0T3B0aW9uOiBvblNlbGVjdE9wdGlvblxuICB9KTtcbn1cbmZ1bmN0aW9uIExleGljYWxOb2RlTWVudVBsdWdpbih7XG4gIG9wdGlvbnMsXG4gIG5vZGVLZXksXG4gIG9uQ2xvc2UsXG4gIG9uT3BlbixcbiAgb25TZWxlY3RPcHRpb24sXG4gIG1lbnVSZW5kZXJGbixcbiAgYW5jaG9yQ2xhc3NOYW1lXG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gTGV4aWNhbENvbXBvc2VyQ29udGV4dC51c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IFtyZXNvbHV0aW9uLCBzZXRSZXNvbHV0aW9uXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBhbmNob3JFbGVtZW50UmVmID0gdXNlTWVudUFuY2hvclJlZihyZXNvbHV0aW9uLCBzZXRSZXNvbHV0aW9uLCBhbmNob3JDbGFzc05hbWUpO1xuICBjb25zdCBjbG9zZU5vZGVNZW51ID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldFJlc29sdXRpb24obnVsbCk7XG5cbiAgICBpZiAob25DbG9zZSAhPSBudWxsICYmIHJlc29sdXRpb24gIT09IG51bGwpIHtcbiAgICAgIG9uQ2xvc2UoKTtcbiAgICB9XG4gIH0sIFtvbkNsb3NlLCByZXNvbHV0aW9uXSk7XG4gIGNvbnN0IG9wZW5Ob2RlTWVudSA9IFJlYWN0LnVzZUNhbGxiYWNrKHJlcyA9PiB7XG4gICAgc2V0UmVzb2x1dGlvbihyZXMpO1xuXG4gICAgaWYgKG9uT3BlbiAhPSBudWxsICYmIHJlc29sdXRpb24gPT09IG51bGwpIHtcbiAgICAgIG9uT3BlbihyZXMpO1xuICAgIH1cbiAgfSwgW29uT3BlbiwgcmVzb2x1dGlvbl0pO1xuICBjb25zdCBwb3NpdGlvbk9yQ2xvc2VNZW51ID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChub2RlS2V5KSB7XG4gICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleShub2RlS2V5KTtcbiAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkobm9kZUtleSk7XG5cbiAgICAgICAgaWYgKG5vZGUgIT0gbnVsbCAmJiBkb21FbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuXG4gICAgICAgICAgaWYgKHJlc29sdXRpb24gPT0gbnVsbCB8fCByZXNvbHV0aW9uLm1hdGNoLm1hdGNoaW5nU3RyaW5nICE9PSB0ZXh0KSB7XG4gICAgICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4gb3Blbk5vZGVNZW51KHtcbiAgICAgICAgICAgICAgZ2V0UmVjdDogKCkgPT4gZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgbWF0Y2g6IHtcbiAgICAgICAgICAgICAgICBsZWFkT2Zmc2V0OiB0ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtYXRjaGluZ1N0cmluZzogdGV4dCxcbiAgICAgICAgICAgICAgICByZXBsYWNlYWJsZVN0cmluZzogdGV4dFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG5vZGVLZXkgPT0gbnVsbCAmJiByZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgIGNsb3NlTm9kZU1lbnUoKTtcbiAgICB9XG4gIH0sIFtjbG9zZU5vZGVNZW51LCBlZGl0b3IsIG5vZGVLZXksIG9wZW5Ob2RlTWVudSwgcmVzb2x1dGlvbl0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHBvc2l0aW9uT3JDbG9zZU1lbnUoKTtcbiAgfSwgW3Bvc2l0aW9uT3JDbG9zZU1lbnUsIG5vZGVLZXldKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobm9kZUtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHtcbiAgICAgICAgZGlydHlFbGVtZW50c1xuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoZGlydHlFbGVtZW50cy5nZXQobm9kZUtleSkpIHtcbiAgICAgICAgICBwb3NpdGlvbk9yQ2xvc2VNZW51KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2VkaXRvciwgcG9zaXRpb25PckNsb3NlTWVudSwgbm9kZUtleV0pO1xuICByZXR1cm4gcmVzb2x1dGlvbiA9PT0gbnVsbCB8fCBlZGl0b3IgPT09IG51bGwgPyBudWxsIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGV4aWNhbFBvcG92ZXJNZW51LCB7XG4gICAgY2xvc2U6IGNsb3NlTm9kZU1lbnUsXG4gICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbixcbiAgICBlZGl0b3I6IGVkaXRvcixcbiAgICBhbmNob3JFbGVtZW50UmVmOiBhbmNob3JFbGVtZW50UmVmLFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgbWVudVJlbmRlckZuOiBtZW51UmVuZGVyRm4sXG4gICAgb25TZWxlY3RPcHRpb246IG9uU2VsZWN0T3B0aW9uXG4gIH0pO1xufVxuXG5leHBvcnRzLkxleGljYWxOb2RlTWVudVBsdWdpbiA9IExleGljYWxOb2RlTWVudVBsdWdpbjtcbmV4cG9ydHMuTGV4aWNhbFR5cGVhaGVhZE1lbnVQbHVnaW4gPSBMZXhpY2FsVHlwZWFoZWFkTWVudVBsdWdpbjtcbmV4cG9ydHMuUFVOQ1RVQVRJT04gPSBQVU5DVFVBVElPTjtcbmV4cG9ydHMuU0NST0xMX1RZUEVBSEVBRF9PUFRJT05fSU5UT19WSUVXX0NPTU1BTkQgPSBTQ1JPTExfVFlQRUFIRUFEX09QVElPTl9JTlRPX1ZJRVdfQ09NTUFORDtcbmV4cG9ydHMuVHlwZWFoZWFkT3B0aW9uID0gVHlwZWFoZWFkT3B0aW9uO1xuZXhwb3J0cy5nZXRTY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQ7XG5leHBvcnRzLnVzZUJhc2ljVHlwZWFoZWFkVHJpZ2dlck1hdGNoID0gdXNlQmFzaWNUeXBlYWhlYWRUcmlnZ2VyTWF0Y2g7XG5leHBvcnRzLnVzZUR5bmFtaWNQb3NpdGlvbmluZyA9IHVzZUR5bmFtaWNQb3NpdGlvbmluZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalTypeaheadMenuPlugin.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/LexicalTypeaheadMenuPlugin.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalTypeaheadMenuPlugin.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalTypeaheadMenuPlugin =  true ? __webpack_require__(/*! ./LexicalTypeaheadMenuPlugin.dev.js */ \"(ssr)/./node_modules/@lexical/react/LexicalTypeaheadMenuPlugin.dev.js\") : 0\nmodule.exports = LexicalTypeaheadMenuPlugin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFR5cGVhaGVhZE1lbnVQbHVnaW4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWixtQ0FBbUMsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLGtIQUFxQyxJQUFJLENBQStDO0FBQzVLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFR5cGVhaGVhZE1lbnVQbHVnaW4uanM/ZjNhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbFR5cGVhaGVhZE1lbnVQbHVnaW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFR5cGVhaGVhZE1lbnVQbHVnaW4uZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxUeXBlYWhlYWRNZW51UGx1Z2luLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsVHlwZWFoZWFkTWVudVBsdWdpbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/LexicalTypeaheadMenuPlugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalEditable.dev.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? react.useLayoutEffect : react.useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Shortcut to Lexical subscriptions when values are used for render.\n */\nfunction useLexicalSubscription(subscription) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const initializedSubscription = react.useMemo(() => subscription(editor), [editor, subscription]);\n  const valueRef = react.useRef(initializedSubscription.initialValueFn());\n  const [value, setValue] = react.useState(valueRef.current);\n  useLayoutEffect(() => {\n    const {\n      initialValueFn,\n      subscribe\n    } = initializedSubscription;\n    const currentValue = initialValueFn();\n\n    if (valueRef.current !== currentValue) {\n      valueRef.current = currentValue;\n      setValue(currentValue);\n    }\n\n    return subscribe(newValue => {\n      valueRef.current = newValue;\n      setValue(newValue);\n    });\n  }, [initializedSubscription, subscription]);\n  return value;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction subscription(editor) {\n  return {\n    initialValueFn: () => editor.isEditable(),\n    subscribe: callback => {\n      return editor.registerEditableListener(callback);\n    }\n  };\n}\n\nfunction useLexicalEditable() {\n  return useLexicalSubscription(subscription);\n}\n\nmodule.exports = useLexicalEditable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYiw2QkFBNkIsbUJBQU8sQ0FBQyw0R0FBdUM7QUFDNUUsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlLmRldi5qcz9mNTFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgdXNlTGF5b3V0RWZmZWN0SW1wbCA9IENBTl9VU0VfRE9NID8gcmVhY3QudXNlTGF5b3V0RWZmZWN0IDogcmVhY3QudXNlRWZmZWN0O1xudmFyIHVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdEltcGw7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBTaG9ydGN1dCB0byBMZXhpY2FsIHN1YnNjcmlwdGlvbnMgd2hlbiB2YWx1ZXMgYXJlIHVzZWQgZm9yIHJlbmRlci5cbiAqL1xuZnVuY3Rpb24gdXNlTGV4aWNhbFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgaW5pdGlhbGl6ZWRTdWJzY3JpcHRpb24gPSByZWFjdC51c2VNZW1vKCgpID0+IHN1YnNjcmlwdGlvbihlZGl0b3IpLCBbZWRpdG9yLCBzdWJzY3JpcHRpb25dKTtcbiAgY29uc3QgdmFsdWVSZWYgPSByZWFjdC51c2VSZWYoaW5pdGlhbGl6ZWRTdWJzY3JpcHRpb24uaW5pdGlhbFZhbHVlRm4oKSk7XG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gcmVhY3QudXNlU3RhdGUodmFsdWVSZWYuY3VycmVudCk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgaW5pdGlhbFZhbHVlRm4sXG4gICAgICBzdWJzY3JpYmVcbiAgICB9ID0gaW5pdGlhbGl6ZWRTdWJzY3JpcHRpb247XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gaW5pdGlhbFZhbHVlRm4oKTtcblxuICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ICE9PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBjdXJyZW50VmFsdWU7XG4gICAgICBzZXRWYWx1ZShjdXJyZW50VmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzY3JpYmUobmV3VmFsdWUgPT4ge1xuICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5ld1ZhbHVlO1xuICAgICAgc2V0VmFsdWUobmV3VmFsdWUpO1xuICAgIH0pO1xuICB9LCBbaW5pdGlhbGl6ZWRTdWJzY3JpcHRpb24sIHN1YnNjcmlwdGlvbl0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gc3Vic2NyaXB0aW9uKGVkaXRvcikge1xuICByZXR1cm4ge1xuICAgIGluaXRpYWxWYWx1ZUZuOiAoKSA9PiBlZGl0b3IuaXNFZGl0YWJsZSgpLFxuICAgIHN1YnNjcmliZTogY2FsbGJhY2sgPT4ge1xuICAgICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIoY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlTGV4aWNhbEVkaXRhYmxlKCkge1xuICByZXR1cm4gdXNlTGV4aWNhbFN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb24pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVzZUxleGljYWxFZGl0YWJsZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/useLexicalEditable.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalEditable.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst useLexicalEditable =  true ? __webpack_require__(/*! ./useLexicalEditable.dev.js */ \"(ssr)/./node_modules/@lexical/react/useLexicalEditable.dev.js\") : 0\nmodule.exports = useLexicalEditable;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osMkJBQTJCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxrR0FBNkIsSUFBSSxDQUF1QztBQUNwSiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L3VzZUxleGljYWxFZGl0YWJsZS5qcz82ZmRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCB1c2VMZXhpY2FsRWRpdGFibGUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vdXNlTGV4aWNhbEVkaXRhYmxlLmRldi5qcycpIDogcmVxdWlyZSgnLi91c2VMZXhpY2FsRWRpdGFibGUucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IHVzZUxleGljYWxFZGl0YWJsZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/useLexicalEditable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.dev.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalNodeSelection.dev.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction isNodeSelected(editor, key) {\n  return editor.getEditorState().read(() => {\n    const node = lexical.$getNodeByKey(key);\n\n    if (node === null) {\n      return false;\n    }\n\n    return node.isSelected();\n  });\n}\n\nfunction useLexicalNodeSelection(key) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isSelected, setIsSelected] = react.useState(() => isNodeSelected(editor, key));\n  react.useEffect(() => {\n    let isMounted = true;\n    const unregister = editor.registerUpdateListener(() => {\n      if (isMounted) {\n        setIsSelected(isNodeSelected(editor, key));\n      }\n    });\n    return () => {\n      isMounted = false;\n      unregister();\n    };\n  }, [editor, key]);\n  const setSelected = react.useCallback(selected => {\n    editor.update(() => {\n      let selection = lexical.$getSelection();\n\n      if (!lexical.$isNodeSelection(selection)) {\n        selection = lexical.$createNodeSelection();\n        lexical.$setSelection(selection);\n      }\n\n      if (selected) {\n        selection.add(key);\n      } else {\n        selection.delete(key);\n      }\n    });\n  }, [editor, key]);\n  const clearSelected = react.useCallback(() => {\n    editor.update(() => {\n      const selection = lexical.$getSelection();\n\n      if (lexical.$isNodeSelection(selection)) {\n        selection.clear();\n      }\n    });\n  }, [editor]);\n  return [isSelected, setSelected, clearSelected];\n}\n\nexports.useLexicalNodeSelection = useLexicalNodeSelection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLDRHQUF1QztBQUM1RSxjQUFjLG1CQUFPLENBQUMsd0RBQVM7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLHdHQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L3VzZUxleGljYWxOb2RlU2VsZWN0aW9uLmRldi5qcz8yNTY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IHJlcXVpcmUoJ0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHQnKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBpc05vZGVTZWxlY3RlZChlZGl0b3IsIGtleSkge1xuICByZXR1cm4gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleShrZXkpO1xuXG4gICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZS5pc1NlbGVjdGVkKCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB1c2VMZXhpY2FsTm9kZVNlbGVjdGlvbihrZXkpIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgW2lzU2VsZWN0ZWQsIHNldElzU2VsZWN0ZWRdID0gcmVhY3QudXNlU3RhdGUoKCkgPT4gaXNOb2RlU2VsZWN0ZWQoZWRpdG9yLCBrZXkpKTtcbiAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgaXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjb25zdCB1bnJlZ2lzdGVyID0gZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgaWYgKGlzTW91bnRlZCkge1xuICAgICAgICBzZXRJc1NlbGVjdGVkKGlzTm9kZVNlbGVjdGVkKGVkaXRvciwga2V5KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgdW5yZWdpc3RlcigpO1xuICAgIH07XG4gIH0sIFtlZGl0b3IsIGtleV0pO1xuICBjb25zdCBzZXRTZWxlY3RlZCA9IHJlYWN0LnVzZUNhbGxiYWNrKHNlbGVjdGVkID0+IHtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGxldCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKCFsZXhpY2FsLiRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBzZWxlY3Rpb24gPSBsZXhpY2FsLiRjcmVhdGVOb2RlU2VsZWN0aW9uKCk7XG4gICAgICAgIGxleGljYWwuJHNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgc2VsZWN0aW9uLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0aW9uLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbZWRpdG9yLCBrZXldKTtcbiAgY29uc3QgY2xlYXJTZWxlY3RlZCA9IHJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAobGV4aWNhbC4kaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgc2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgcmV0dXJuIFtpc1NlbGVjdGVkLCBzZXRTZWxlY3RlZCwgY2xlYXJTZWxlY3RlZF07XG59XG5cbmV4cG9ydHMudXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24gPSB1c2VMZXhpY2FsTm9kZVNlbGVjdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalNodeSelection.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst useLexicalNodeSelection =  true ? __webpack_require__(/*! ./useLexicalNodeSelection.dev.js */ \"(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.dev.js\") : 0\nmodule.exports = useLexicalNodeSelection;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWixnQ0FBZ0MsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLDRHQUFrQyxJQUFJLENBQTRDO0FBQ25LIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24uanM/NGU5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vdXNlTGV4aWNhbE5vZGVTZWxlY3Rpb24uZGV2LmpzJykgOiByZXF1aXJlKCcuL3VzZUxleGljYWxOb2RlU2VsZWN0aW9uLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSB1c2VMZXhpY2FsTm9kZVNlbGVjdGlvbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/useLexicalNodeSelection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/useLexicalTextEntity.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalTextEntity.dev.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar LexicalComposerContext = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"(ssr)/./node_modules/@lexical/react/LexicalComposerContext.js\");\nvar text = __webpack_require__(/*! @lexical/text */ \"(ssr)/./node_modules/@lexical/text/LexicalText.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar react = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useLexicalTextEntity(getMatch, targetNode, createNode) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    return utils.mergeRegister(...text.registerLexicalTextEntity(editor, getMatch, targetNode, createNode));\n  }, [createNode, editor, getMatch, targetNode]);\n}\n\nexports.useLexicalTextEntity = useLexicalTextEntity;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbFRleHRFbnRpdHkuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLDZCQUE2QixtQkFBTyxDQUFDLDRHQUF1QztBQUM1RSxXQUFXLG1CQUFPLENBQUMsd0VBQWU7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjtBQUNwQyxZQUFZLG1CQUFPLENBQUMsd0dBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsNEJBQTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbFRleHRFbnRpdHkuZGV2LmpzPzlmNzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMZXhpY2FsQ29tcG9zZXJDb250ZXh0ID0gcmVxdWlyZSgnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCcpO1xudmFyIHRleHQgPSByZXF1aXJlKCdAbGV4aWNhbC90ZXh0Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdAbGV4aWNhbC91dGlscycpO1xudmFyIHJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlTGV4aWNhbFRleHRFbnRpdHkoZ2V0TWF0Y2gsIHRhcmdldE5vZGUsIGNyZWF0ZU5vZGUpIHtcbiAgY29uc3QgW2VkaXRvcl0gPSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0LnVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgcmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gdXRpbHMubWVyZ2VSZWdpc3RlciguLi50ZXh0LnJlZ2lzdGVyTGV4aWNhbFRleHRFbnRpdHkoZWRpdG9yLCBnZXRNYXRjaCwgdGFyZ2V0Tm9kZSwgY3JlYXRlTm9kZSkpO1xuICB9LCBbY3JlYXRlTm9kZSwgZWRpdG9yLCBnZXRNYXRjaCwgdGFyZ2V0Tm9kZV0pO1xufVxuXG5leHBvcnRzLnVzZUxleGljYWxUZXh0RW50aXR5ID0gdXNlTGV4aWNhbFRleHRFbnRpdHk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/useLexicalTextEntity.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/react/useLexicalTextEntity.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalTextEntity.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst useLexicalTextEntity =  true ? __webpack_require__(/*! ./useLexicalTextEntity.dev.js */ \"(ssr)/./node_modules/@lexical/react/useLexicalTextEntity.dev.js\") : 0\nmodule.exports = useLexicalTextEntity;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbFRleHRFbnRpdHkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWiw2QkFBNkIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLHNHQUErQixJQUFJLENBQXlDO0FBQzFKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbFRleHRFbnRpdHkuanM/Mzg1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgdXNlTGV4aWNhbFRleHRFbnRpdHkgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vdXNlTGV4aWNhbFRleHRFbnRpdHkuZGV2LmpzJykgOiByZXF1aXJlKCcuL3VzZUxleGljYWxUZXh0RW50aXR5LnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSB1c2VMZXhpY2FsVGV4dEVudGl0eTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/react/useLexicalTextEntity.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.dev.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/rich-text/LexicalRichText.dev.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar clipboard = __webpack_require__(/*! @lexical/clipboard */ \"(ssr)/./node_modules/@lexical/clipboard/LexicalClipboard.js\");\nvar selection = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n\n    if (range === null) {\n      return null;\n    }\n\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    }; // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n\n    if (range === null) {\n      return null;\n    }\n\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/** @module @lexical/rich-text */\nconst DRAG_DROP_PASTE = lexical.createCommand('DRAG_DROP_PASTE_FILE');\n\n/** @noInheritDoc */\nclass QuoteNode extends lexical.ElementNode {\n  static getType() {\n    return 'quote';\n  }\n\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n\n  constructor(key) {\n    super(key);\n  } // View\n\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    utils.addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'quote'\n    };\n  } // Mutation\n\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n}\nfunction $createQuoteNode() {\n  return lexical.$applyNodeReplacement(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n\n/** @noInheritDoc */\nclass HeadingNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'heading';\n  }\n\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n\n  getTag() {\n    return this.__tag;\n  } // View\n\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      utils.addClassNamesToElement(element, className);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n\n        return null;\n      }\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const newElement = anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n\n  extractWithChild() {\n    return true;\n  }\n\n}\n\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n\n  return false;\n}\n\nfunction convertHeadingElement(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n  }\n\n  return {\n    node\n  };\n}\n\nfunction convertBlockquoteElement() {\n  const node = $createQuoteNode();\n  return {\n    node\n  };\n}\n\nfunction $createHeadingNode(headingTag) {\n  return lexical.$applyNodeReplacement(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\n\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;\n\n    if (clipboardData != null && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n      clipboard.$insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\n\nasync function onCutForRichText(event, editor) {\n  await clipboard.copyToClipboard(editor, event instanceof ClipboardEvent ? event : null);\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      selection.removeText();\n    } else if (lexical.$isNodeSelection(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n} // Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain ocassions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\n\n\nfunction eventFiles(event) {\n  let dataTransfer = null;\n\n  if (event instanceof DragEvent) {\n    dataTransfer = event.dataTransfer;\n  } else if (event instanceof ClipboardEvent) {\n    dataTransfer = event.clipboardData;\n  }\n\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\n\nfunction handleIndentAndOutdent(insertTab, indentOrOutdent) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n\n    const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);\n    const parentKey = parentBlock.getKey();\n\n    if (parentBlock.canInsertTab()) {\n      insertTab(node);\n      alreadyHandled.add(key);\n    } else if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n}\n\nfunction $isTargetWithinDecorator(target) {\n  const node = lexical.$getNearestNodeFromDOMNode(target);\n  return lexical.$isDecoratorNode(node);\n}\n\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === lexical.$getRoot().getChildrenSize();\n}\n\nfunction registerRichText(editor) {\n  const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n\n    return false;\n  }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = lexical.$getSelection();\n\n    if (typeof eventOrText === 'string') {\n      if (lexical.$isRangeSelection(selection)) {\n        selection.insertText(eventOrText);\n      } else if (lexical.DEPRECATED_$isGridSelection(selection)) ;\n    } else {\n      if (!lexical.$isRangeSelection(selection) && !lexical.DEPRECATED_$isGridSelection(selection)) {\n        return false;\n      }\n\n      const dataTransfer = eventOrText.dataTransfer;\n\n      if (dataTransfer != null) {\n        clipboard.$insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if (lexical.$isRangeSelection(selection)) {\n        const data = eventOrText.data;\n\n        if (data) {\n          selection.insertText(data);\n        }\n\n        return true;\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.removeText();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.formatText(format);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection) && !lexical.$isNodeSelection(selection)) {\n      return false;\n    }\n\n    const nodes = selection.getNodes();\n\n    for (const node of nodes) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(node);\n      element.setFormat(format);\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertParagraph();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {\n    handleIndentAndOutdent(() => {\n      editor.dispatchCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, '\\t');\n    }, block => {\n      const indent = block.getIndent();\n\n      if (indent !== 10) {\n        block.setIndent(indent + 1);\n      }\n    });\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {\n    handleIndentAndOutdent(node => {\n      if (lexical.$isTextNode(node)) {\n        const textContent = node.getTextContent();\n        const character = textContent[textContent.length - 1];\n\n        if (character === '\\t') {\n          editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n        }\n      }\n    }, block => {\n      const indent = block.getIndent();\n\n      if (indent !== 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if (lexical.$isRangeSelection(selection)) {\n      const possibleNode = lexical.$getAdjacentNode(selection.focus, true);\n\n      if (lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      } else if (lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n        possibleNode.select();\n        event.preventDefault();\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if (lexical.$isRangeSelection(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n\n      const possibleNode = lexical.$getAdjacentNode(selection.focus, false);\n\n      if (lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection$1)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, true);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection$1) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    const isHoldingShift = event.shiftKey;\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, false);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n\n    if (selection.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);\n\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n\n      event.preventDefault();\n\n      if (event.shiftKey) {\n        return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n\n    return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, undefined);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    editor.blur();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = lexical.$getNearestNodeFromDOMNode(domNode);\n\n        if (node !== null) {\n          const selection = lexical.$createRangeSelection();\n\n          if (lexical.$isTextNode(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n\n          const normalizedSelection = lexical.$normalizeSelection__EXPERIMENTAL(selection);\n          lexical.$setSelection(normalizedSelection);\n        }\n\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n\n      event.preventDefault();\n      return true;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = lexical.$getSelection();\n\n    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = lexical.$getSelection();\n\n    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n\n    if (eventRange !== null) {\n      const node = lexical.$getNearestNodeFromDOMNode(eventRange.node);\n\n      if (lexical.$isDecoratorNode(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, event => {\n    clipboard.copyToClipboard(editor, event instanceof ClipboardEvent ? event : null);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\nexports.$createHeadingNode = $createHeadingNode;\nexports.$createQuoteNode = $createQuoteNode;\nexports.$isHeadingNode = $isHeadingNode;\nexports.$isQuoteNode = $isQuoteNode;\nexports.DRAG_DROP_PASTE = DRAG_DROP_PASTE;\nexports.HeadingNode = HeadingNode;\nexports.QuoteNode = QuoteNode;\nexports.eventFiles = eventFiles;\nexports.registerRichText = registerRichText;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmljaC10ZXh0L0xleGljYWxSaWNoVGV4dC5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsdUZBQW9CO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLHVGQUFvQjtBQUM1QyxZQUFZLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyx3REFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7O0FBRUEsK0VBQStFOztBQUUvRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JpY2gtdGV4dC9MZXhpY2FsUmljaFRleHQuZGV2LmpzP2M4OTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjbGlwYm9hcmQgPSByZXF1aXJlKCdAbGV4aWNhbC9jbGlwYm9hcmQnKTtcbnZhciBzZWxlY3Rpb24gPSByZXF1aXJlKCdAbGV4aWNhbC9zZWxlY3Rpb24nKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gY2FyZXRGcm9tUG9pbnQoeCwgeSkge1xuICBpZiAodHlwZW9mIGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuXG4gICAgaWYgKHJhbmdlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgICBvZmZzZXQ6IHJhbmdlLnN0YXJ0T2Zmc2V0XG4gICAgfTsgLy8gQHRzLWlnbm9yZVxuICB9IGVsc2UgaWYgKGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gQHRzLWlnbm9yZSBGRiAtIG5vIHR5cGVzXG4gICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuXG4gICAgaWYgKHJhbmdlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogcmFuZ2Uub2Zmc2V0Tm9kZSxcbiAgICAgIG9mZnNldDogcmFuZ2Uub2Zmc2V0XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHcmFjZWZ1bGx5IGhhbmRsZSBJRVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgZG9jdW1lbnRNb2RlID0gQ0FOX1VTRV9ET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBudWxsO1xuQ0FOX1VTRV9ET00gJiYgL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5DQU5fVVNFX0RPTSAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCA9IENBTl9VU0VfRE9NICYmICdJbnB1dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSA/ICdnZXRUYXJnZXRSYW5nZXMnIGluIG5ldyB3aW5kb3cuSW5wdXRFdmVudCgnaW5wdXQnKSA6IGZhbHNlO1xuY29uc3QgSVNfU0FGQVJJID0gQ0FOX1VTRV9ET00gJiYgL1ZlcnNpb25cXC9bXFxkLl0rLipTYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBJU19JT1MgPSBDQU5fVVNFX0RPTSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtOyAvLyBLZWVwIHRoZXNlIGluIGNhc2Ugd2UgbmVlZCB0byB1c2UgdGhlbSBpbiB0aGUgZnV0dXJlLlxuLy8gZXhwb3J0IGNvbnN0IElTX1dJTkRPV1M6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAvV2luLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5cbmNvbnN0IElTX0NIUk9NRSA9IENBTl9VU0VfRE9NICYmIC9eKD89LipDaHJvbWUpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBleHBvcnQgY29uc3QgY2FuVXNlVGV4dElucHV0RXZlbnQ6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZTtcblxuY29uc3QgSVNfQVBQTEVfV0VCS0lUID0gQ0FOX1VTRV9ET00gJiYgL0FwcGxlV2ViS2l0XFwvW1xcZC5dKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhSVNfQ0hST01FO1xuXG4vKiogQG1vZHVsZSBAbGV4aWNhbC9yaWNoLXRleHQgKi9cbmNvbnN0IERSQUdfRFJPUF9QQVNURSA9IGxleGljYWwuY3JlYXRlQ29tbWFuZCgnRFJBR19EUk9QX1BBU1RFX0ZJTEUnKTtcblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFF1b3RlTm9kZSBleHRlbmRzIGxleGljYWwuRWxlbWVudE5vZGUge1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3F1b3RlJztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBRdW90ZU5vZGUobm9kZS5fX2tleSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICB9IC8vIFZpZXdcblxuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYmxvY2txdW90ZScpO1xuICAgIHV0aWxzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLnF1b3RlKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2txdW90ZTogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0QmxvY2txdW90ZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlUXVvdGVOb2RlKCk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldEluZGVudChzZXJpYWxpemVkTm9kZS5pbmRlbnQpO1xuICAgIG5vZGUuc2V0RGlyZWN0aW9uKHNlcmlhbGl6ZWROb2RlLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHR5cGU6ICdxdW90ZSdcbiAgICB9O1xuICB9IC8vIE11dGF0aW9uXG5cblxuICBpbnNlcnROZXdBZnRlcihfLCByZXN0b3JlU2VsZWN0aW9uKSB7XG4gICAgY29uc3QgbmV3QmxvY2sgPSBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICBuZXdCbG9jay5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKG5ld0Jsb2NrLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbmV3QmxvY2s7XG4gIH1cblxuICBjb2xsYXBzZUF0U3RhcnQoKSB7XG4gICAgY29uc3QgcGFyYWdyYXBoID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gcGFyYWdyYXBoLmFwcGVuZChjaGlsZCkpO1xuICAgIHRoaXMucmVwbGFjZShwYXJhZ3JhcGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn1cbmZ1bmN0aW9uICRjcmVhdGVRdW90ZU5vZGUoKSB7XG4gIHJldHVybiBsZXhpY2FsLiRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgUXVvdGVOb2RlKCkpO1xufVxuZnVuY3Rpb24gJGlzUXVvdGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBRdW90ZU5vZGU7XG59XG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBIZWFkaW5nTm9kZSBleHRlbmRzIGxleGljYWwuRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnaGVhZGluZyc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgSGVhZGluZ05vZGUobm9kZS5fX3RhZywgbm9kZS5fX2tleSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih0YWcsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX3RhZyA9IHRhZztcbiAgfVxuXG4gIGdldFRhZygpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RhZztcbiAgfSAvLyBWaWV3XG5cblxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5fX3RhZztcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGNvbnN0IHRoZW1lID0gY29uZmlnLnRoZW1lO1xuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSB0aGVtZS5oZWFkaW5nO1xuXG4gICAgaWYgKGNsYXNzTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1t0YWddO1xuICAgICAgdXRpbHMuYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjbGFzc05hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBoMTogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0SGVhZGluZ0VsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIGgyOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDM6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBoNDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0SGVhZGluZ0VsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIGg1OiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDY6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydEhlYWRpbmdFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBwOiBub2RlID0+IHtcbiAgICAgICAgLy8gZG9tTm9kZSBpcyBhIDxwPiBzaW5jZSB3ZSBtYXRjaGVkIGl0IGJ5IG5vZGVOYW1lXG4gICAgICAgIGNvbnN0IHBhcmFncmFwaCA9IG5vZGU7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJhZ3JhcGguZmlyc3RDaGlsZDtcblxuICAgICAgICBpZiAoZmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBpc0dvb2dsZURvY3NUaXRsZShmaXJzdENoaWxkKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb252ZXJzaW9uOiAoKSA9PiAoe1xuICAgICAgICAgICAgICBub2RlOiBudWxsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHByaW9yaXR5OiAzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHNwYW46IG5vZGUgPT4ge1xuICAgICAgICBpZiAoaXNHb29nbGVEb2NzVGl0bGUobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udmVyc2lvbjogZG9tTm9kZSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm9kZTogJGNyZWF0ZUhlYWRpbmdOb2RlKCdoMScpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgY29uc3Qgbm9kZSA9ICRjcmVhdGVIZWFkaW5nTm9kZShzZXJpYWxpemVkTm9kZS50YWcpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4geyAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICB0YWc6IHRoaXMuZ2V0VGFnKCksXG4gICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfSAvLyBNdXRhdGlvblxuXG5cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGFuY2hvck9mZmV0ID0gc2VsZWN0aW9uID8gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgOiAwO1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBhbmNob3JPZmZldCA+IDAgJiYgYW5jaG9yT2ZmZXQgPCB0aGlzLmdldFRleHRDb250ZW50U2l6ZSgpID8gJGNyZWF0ZUhlYWRpbmdOb2RlKHRoaXMuZ2V0VGFnKCkpIDogbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCk7XG4gICAgbmV3RWxlbWVudC5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKG5ld0VsZW1lbnQsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSAhdGhpcy5pc0VtcHR5KCkgPyAkY3JlYXRlSGVhZGluZ05vZGUodGhpcy5nZXRUYWcoKSkgOiBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBuZXdFbGVtZW50LmFwcGVuZChjaGlsZCkpO1xuICAgIHRoaXMucmVwbGFjZShuZXdFbGVtZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGV4dHJhY3RXaXRoQ2hpbGQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpc0dvb2dsZURvY3NUaXRsZShkb21Ob2RlKSB7XG4gIGlmIChkb21Ob2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzcGFuJykge1xuICAgIHJldHVybiBkb21Ob2RlLnN0eWxlLmZvbnRTaXplID09PSAnMjZwdCc7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRIZWFkaW5nRWxlbWVudChkb21Ob2RlKSB7XG4gIGNvbnN0IG5vZGVOYW1lID0gZG9tTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBsZXQgbm9kZSA9IG51bGw7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaDEnIHx8IG5vZGVOYW1lID09PSAnaDInIHx8IG5vZGVOYW1lID09PSAnaDMnIHx8IG5vZGVOYW1lID09PSAnaDQnIHx8IG5vZGVOYW1lID09PSAnaDUnIHx8IG5vZGVOYW1lID09PSAnaDYnKSB7XG4gICAgbm9kZSA9ICRjcmVhdGVIZWFkaW5nTm9kZShub2RlTmFtZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5vZGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydEJsb2NrcXVvdGVFbGVtZW50KCkge1xuICBjb25zdCBub2RlID0gJGNyZWF0ZVF1b3RlTm9kZSgpO1xuICByZXR1cm4ge1xuICAgIG5vZGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gJGNyZWF0ZUhlYWRpbmdOb2RlKGhlYWRpbmdUYWcpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBIZWFkaW5nTm9kZShoZWFkaW5nVGFnKSk7XG59XG5mdW5jdGlvbiAkaXNIZWFkaW5nTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgSGVhZGluZ05vZGU7XG59XG5cbmZ1bmN0aW9uIG9uUGFzdGVGb3JSaWNoVGV4dChldmVudCwgZWRpdG9yKSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IGNsaXBib2FyZERhdGEgPSBldmVudCBpbnN0YW5jZW9mIElucHV0RXZlbnQgfHwgZXZlbnQgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50ID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG5cbiAgICBpZiAoY2xpcGJvYXJkRGF0YSAhPSBudWxsICYmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICAgIGNsaXBib2FyZC4kaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUmljaFRleHQoY2xpcGJvYXJkRGF0YSwgc2VsZWN0aW9uLCBlZGl0b3IpO1xuICAgIH1cbiAgfSwge1xuICAgIHRhZzogJ3Bhc3RlJ1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gb25DdXRGb3JSaWNoVGV4dChldmVudCwgZWRpdG9yKSB7XG4gIGF3YWl0IGNsaXBib2FyZC5jb3B5VG9DbGlwYm9hcmQoZWRpdG9yLCBldmVudCBpbnN0YW5jZW9mIENsaXBib2FyZEV2ZW50ID8gZXZlbnQgOiBudWxsKTtcbiAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBzZWxlY3Rpb24ucmVtb3ZlVGV4dCgpO1xuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5nZXROb2RlcygpLmZvckVhY2gobm9kZSA9PiBub2RlLnJlbW92ZSgpKTtcbiAgICB9XG4gIH0pO1xufSAvLyBDbGlwYm9hcmQgbWF5IGNvbnRhaW4gZmlsZXMgdGhhdCB3ZSBhcmVuJ3QgYWxsb3dlZCB0byByZWFkLiBXaGlsZSB0aGUgZXZlbnQgaXMgYXJndWFibHkgdXNlbGVzcyxcbi8vIGluIGNlcnRhaW4gb2Nhc3Npb25zLCB3ZSB3YW50IHRvIGtub3cgd2hldGhlciBpdCB3YXMgYSBmaWxlIHRyYW5zZmVyLCBhcyBvcHBvc2VkIHRvIHRleHQuIFdlXG4vLyBjb250cm9sIHRoaXMgd2l0aCB0aGUgZmlyc3QgYm9vbGVhbiBmbGFnLlxuXG5cbmZ1bmN0aW9uIGV2ZW50RmlsZXMoZXZlbnQpIHtcbiAgbGV0IGRhdGFUcmFuc2ZlciA9IG51bGw7XG5cbiAgaWYgKGV2ZW50IGluc3RhbmNlb2YgRHJhZ0V2ZW50KSB7XG4gICAgZGF0YVRyYW5zZmVyID0gZXZlbnQuZGF0YVRyYW5zZmVyO1xuICB9IGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgQ2xpcGJvYXJkRXZlbnQpIHtcbiAgICBkYXRhVHJhbnNmZXIgPSBldmVudC5jbGlwYm9hcmREYXRhO1xuICB9XG5cbiAgaWYgKGRhdGFUcmFuc2ZlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbZmFsc2UsIFtdLCBmYWxzZV07XG4gIH1cblxuICBjb25zdCB0eXBlcyA9IGRhdGFUcmFuc2Zlci50eXBlcztcbiAgY29uc3QgaGFzRmlsZXMgPSB0eXBlcy5pbmNsdWRlcygnRmlsZXMnKTtcbiAgY29uc3QgaGFzQ29udGVudCA9IHR5cGVzLmluY2x1ZGVzKCd0ZXh0L2h0bWwnKSB8fCB0eXBlcy5pbmNsdWRlcygndGV4dC9wbGFpbicpO1xuICByZXR1cm4gW2hhc0ZpbGVzLCBBcnJheS5mcm9tKGRhdGFUcmFuc2Zlci5maWxlcyksIGhhc0NvbnRlbnRdO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVJbmRlbnRBbmRPdXRkZW50KGluc2VydFRhYiwgaW5kZW50T3JPdXRkZW50KSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYWxyZWFkeUhhbmRsZWQgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBjb25zdCBrZXkgPSBub2RlLmdldEtleSgpO1xuXG4gICAgaWYgKGFscmVhZHlIYW5kbGVkLmhhcyhrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnRCbG9jayA9IHV0aWxzLiRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93KG5vZGUpO1xuICAgIGNvbnN0IHBhcmVudEtleSA9IHBhcmVudEJsb2NrLmdldEtleSgpO1xuXG4gICAgaWYgKHBhcmVudEJsb2NrLmNhbkluc2VydFRhYigpKSB7XG4gICAgICBpbnNlcnRUYWIobm9kZSk7XG4gICAgICBhbHJlYWR5SGFuZGxlZC5hZGQoa2V5KTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudEJsb2NrLmNhbkluZGVudCgpICYmICFhbHJlYWR5SGFuZGxlZC5oYXMocGFyZW50S2V5KSkge1xuICAgICAgYWxyZWFkeUhhbmRsZWQuYWRkKHBhcmVudEtleSk7XG4gICAgICBpbmRlbnRPck91dGRlbnQocGFyZW50QmxvY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiAkaXNUYXJnZXRXaXRoaW5EZWNvcmF0b3IodGFyZ2V0KSB7XG4gIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKHRhcmdldCk7XG4gIHJldHVybiBsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uICRpc1NlbGVjdGlvbkF0RW5kT2ZSb290KHNlbGVjdGlvbikge1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgcmV0dXJuIGZvY3VzLmtleSA9PT0gJ3Jvb3QnICYmIGZvY3VzLm9mZnNldCA9PT0gbGV4aWNhbC4kZ2V0Um9vdCgpLmdldENoaWxkcmVuU2l6ZSgpO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlclJpY2hUZXh0KGVkaXRvcikge1xuICBjb25zdCByZW1vdmVMaXN0ZW5lciA9IHV0aWxzLm1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkNMSUNLX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBzZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgMCksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5ERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIGlzQmFja3dhcmQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3Rpb24uZGVsZXRlQ2hhcmFjdGVyKGlzQmFja3dhcmQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkRFTEVURV9XT1JEX0NPTU1BTkQsIGlzQmFja3dhcmQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3Rpb24uZGVsZXRlV29yZChpc0JhY2t3YXJkKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5ERUxFVEVfTElORV9DT01NQU5ELCBpc0JhY2t3YXJkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uLmRlbGV0ZUxpbmUoaXNCYWNrd2FyZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBldmVudE9yVGV4dCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAodHlwZW9mIGV2ZW50T3JUZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0VGV4dChldmVudE9yVGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpIDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgIWxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhVHJhbnNmZXIgPSBldmVudE9yVGV4dC5kYXRhVHJhbnNmZXI7XG5cbiAgICAgIGlmIChkYXRhVHJhbnNmZXIgIT0gbnVsbCkge1xuICAgICAgICBjbGlwYm9hcmQuJGluc2VydERhdGFUcmFuc2ZlckZvclJpY2hUZXh0KGRhdGFUcmFuc2Zlciwgc2VsZWN0aW9uLCBlZGl0b3IpO1xuICAgICAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGV2ZW50T3JUZXh0LmRhdGE7XG5cbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0VGV4dChkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLlJFTU9WRV9URVhUX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uLnJlbW92ZVRleHQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5GT1JNQVRfVEVYVF9DT01NQU5ELCBmb3JtYXQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzZWxlY3Rpb24uZm9ybWF0VGV4dChmb3JtYXQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLkZPUk1BVF9FTEVNRU5UX0NPTU1BTkQsIGZvcm1hdCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAhbGV4aWNhbC4kaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdXRpbHMuJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3cobm9kZSk7XG4gICAgICBlbGVtZW50LnNldEZvcm1hdChmb3JtYXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLklOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQsIHNlbGVjdFN0YXJ0ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uLmluc2VydExpbmVCcmVhayhzZWxlY3RTdGFydCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNlbGVjdGlvbi5pbnNlcnRQYXJhZ3JhcGgoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5JTkRFTlRfQ09OVEVOVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgaGFuZGxlSW5kZW50QW5kT3V0ZGVudCgoKSA9PiB7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCAnXFx0Jyk7XG4gICAgfSwgYmxvY2sgPT4ge1xuICAgICAgY29uc3QgaW5kZW50ID0gYmxvY2suZ2V0SW5kZW50KCk7XG5cbiAgICAgIGlmIChpbmRlbnQgIT09IDEwKSB7XG4gICAgICAgIGJsb2NrLnNldEluZGVudChpbmRlbnQgKyAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5PVVRERU5UX0NPTlRFTlRfQ09NTUFORCwgKCkgPT4ge1xuICAgIGhhbmRsZUluZGVudEFuZE91dGRlbnQobm9kZSA9PiB7XG4gICAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgICBjb25zdCB0ZXh0Q29udGVudCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyID0gdGV4dENvbnRlbnRbdGV4dENvbnRlbnQubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGJsb2NrID0+IHtcbiAgICAgIGNvbnN0IGluZGVudCA9IGJsb2NrLmdldEluZGVudCgpO1xuXG4gICAgICBpZiAoaW5kZW50ICE9PSAwKSB7XG4gICAgICAgIGJsb2NrLnNldEluZGVudChpbmRlbnQgLSAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQVJST1dfVVBfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmICEkaXNUYXJnZXRXaXRoaW5EZWNvcmF0b3IoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgLy8gSWYgc2VsZWN0aW9uIGlzIG9uIGEgbm9kZSwgbGV0J3MgdHJ5IGFuZCBtb3ZlIHNlbGVjdGlvblxuICAgICAgLy8gYmFjayB0byBiZWluZyBhIHJhbmdlIHNlbGVjdGlvbi5cbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5vZGVzWzBdLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBwb3NzaWJsZU5vZGUgPSBsZXhpY2FsLiRnZXRBZGphY2VudE5vZGUoc2VsZWN0aW9uLmZvY3VzLCB0cnVlKTtcblxuICAgICAgaWYgKGxleGljYWwuJGlzRGVjb3JhdG9yTm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJc29sYXRlZCgpICYmICFwb3NzaWJsZU5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICBwb3NzaWJsZU5vZGUuc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSW5saW5lKCkgJiYgIXBvc3NpYmxlTm9kZS5jYW5CZUVtcHR5KCkpIHtcbiAgICAgICAgcG9zc2libGVOb2RlLnNlbGVjdCgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAvLyBJZiBzZWxlY3Rpb24gaXMgb24gYSBub2RlLCBsZXQncyB0cnkgYW5kIG1vdmUgc2VsZWN0aW9uXG4gICAgICAvLyBiYWNrIHRvIGJlaW5nIGEgcmFuZ2Ugc2VsZWN0aW9uLlxuICAgICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcblxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbm9kZXNbMF0uc2VsZWN0TmV4dCgwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGlmICgkaXNTZWxlY3Rpb25BdEVuZE9mUm9vdChzZWxlY3Rpb24pKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwb3NzaWJsZU5vZGUgPSBsZXhpY2FsLiRnZXRBZGphY2VudE5vZGUoc2VsZWN0aW9uLmZvY3VzLCBmYWxzZSk7XG5cbiAgICAgIGlmIChsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSXNvbGF0ZWQoKSAmJiAhcG9zc2libGVOb2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgcG9zc2libGVOb2RlLnNlbGVjdE5leHQoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9BUlJPV19MRUZUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24kMSA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKGxleGljYWwuJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24kMSkpIHtcbiAgICAgIC8vIElmIHNlbGVjdGlvbiBpcyBvbiBhIG5vZGUsIGxldCdzIHRyeSBhbmQgbW92ZSBzZWxlY3Rpb25cbiAgICAgIC8vIGJhY2sgdG8gYmVpbmcgYSByYW5nZSBzZWxlY3Rpb24uXG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbiQxLmdldE5vZGVzKCk7XG5cbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG5vZGVzWzBdLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24kMSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0aW9uLiRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24oc2VsZWN0aW9uJDEsIHRydWUpKSB7XG4gICAgICBjb25zdCBpc0hvbGRpbmdTaGlmdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNlbGVjdGlvbi4kbW92ZUNoYXJhY3RlcihzZWxlY3Rpb24kMSwgaXNIb2xkaW5nU2hpZnQsIHRydWUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9BUlJPV19SSUdIVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uJDEgPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uJDEpICYmICEkaXNUYXJnZXRXaXRoaW5EZWNvcmF0b3IoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgLy8gSWYgc2VsZWN0aW9uIGlzIG9uIGEgbm9kZSwgbGV0J3MgdHJ5IGFuZCBtb3ZlIHNlbGVjdGlvblxuICAgICAgLy8gYmFjayB0byBiZWluZyBhIHJhbmdlIHNlbGVjdGlvbi5cbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uJDEuZ2V0Tm9kZXMoKTtcblxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbm9kZXNbMF0uc2VsZWN0TmV4dCgwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbiQxKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGlzSG9sZGluZ1NoaWZ0ID0gZXZlbnQuc2hpZnRLZXk7XG5cbiAgICBpZiAoc2VsZWN0aW9uLiRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24oc2VsZWN0aW9uJDEsIGZhbHNlKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNlbGVjdGlvbi4kbW92ZUNoYXJhY3RlcihzZWxlY3Rpb24kMSwgaXNIb2xkaW5nU2hpZnQsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfQkFDS1NQQUNFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBpZiAoJGlzVGFyZ2V0V2l0aGluRGVjb3JhdG9yKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuXG4gICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIGFuY2hvci5vZmZzZXQgPT09IDAgJiYgIWxleGljYWwuJGlzUm9vdE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlscy4kZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdyhhbmNob3JOb2RlKTtcblxuICAgICAgaWYgKGVsZW1lbnQuZ2V0SW5kZW50KCkgPiAwKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuT1VUREVOVF9DT05URU5UX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5ERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIHRydWUpO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9ERUxFVEVfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGlmICgkaXNUYXJnZXRXaXRoaW5EZWNvcmF0b3IoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBmYWxzZSk7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0VOVEVSX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGJlZm9yZWlucHV0LCB0aGVuIHdlIGNhbiBhdm9pZCBibG9ja2luZ1xuICAgICAgLy8gdGhlIGRlZmF1bHQgYmVoYXZpb3IuIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBpT1MgY2FuXG4gICAgICAvLyBpbnRlcmNlcHQgdGhhdCB3ZSdyZSBhY3R1YWxseSBpbnNlcnRpbmcgYSBwYXJhZ3JhcGgsXG4gICAgICAvLyBhbmQgYXV0b2NvbXBsZXRlLCBhdXRvY2FwaXRhbGl6ZSBldGMgd29yayBhcyBpbnRlbmRlZC5cbiAgICAgIC8vIFRoaXMgY2FuIGFsc28gY2F1c2UgYSBzdHJhbmdlIHBlcmZvcm1hbmNlIGlzc3VlIGluXG4gICAgICAvLyBTYWZhcmksIHdoZXJlIHRoZXJlIGlzIGEgbm90aWNlYWJsZSBwYXVzZSBkdWUgdG9cbiAgICAgIC8vIHByZXZlbnRpbmcgdGhlIGtleSBkb3duIG9mIGVudGVyLlxuICAgICAgaWYgKChJU19JT1MgfHwgSVNfU0FGQVJJIHx8IElTX0FQUExFX1dFQktJVCkgJiYgQ0FOX1VTRV9CRUZPUkVfSU5QVVQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5JTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQobGV4aWNhbC5JTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0VTQ0FQRV9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIWxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGVkaXRvci5ibHVyKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuRFJPUF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3QgWywgZmlsZXNdID0gZXZlbnRGaWxlcyhldmVudCk7XG5cbiAgICBpZiAoZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICBjb25zdCB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIGNvbnN0IGV2ZW50UmFuZ2UgPSBjYXJldEZyb21Qb2ludCh4LCB5KTtcblxuICAgICAgaWYgKGV2ZW50UmFuZ2UgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG9mZnNldDogZG9tT2Zmc2V0LFxuICAgICAgICAgIG5vZGU6IGRvbU5vZGVcbiAgICAgICAgfSA9IGV2ZW50UmFuZ2U7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGRvbU5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKTtcblxuICAgICAgICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldChub2RlLmdldEtleSgpLCBkb21PZmZzZXQsICd0ZXh0Jyk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXMuc2V0KG5vZGUuZ2V0S2V5KCksIGRvbU9mZnNldCwgJ3RleHQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCkuZ2V0S2V5KCk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBub2RlLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyAxO1xuICAgICAgICAgICAgc2VsZWN0aW9uLmFuY2hvci5zZXQocGFyZW50S2V5LCBvZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXMuc2V0KHBhcmVudEtleSwgb2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTZWxlY3Rpb24gPSBsZXhpY2FsLiRub3JtYWxpemVTZWxlY3Rpb25fX0VYUEVSSU1FTlRBTChzZWxlY3Rpb24pO1xuICAgICAgICAgIGxleGljYWwuJHNldFNlbGVjdGlvbihub3JtYWxpemVkU2VsZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoRFJBR19EUk9QX1BBU1RFLCBmaWxlcyk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5EUkFHU1RBUlRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IFtpc0ZpbGVUcmFuc2Zlcl0gPSBldmVudEZpbGVzKGV2ZW50KTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChpc0ZpbGVUcmFuc2ZlciAmJiAhbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuRFJBR09WRVJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IFtpc0ZpbGVUcmFuc2Zlcl0gPSBldmVudEZpbGVzKGV2ZW50KTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChpc0ZpbGVUcmFuc2ZlciAmJiAhbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFg7XG4gICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFk7XG4gICAgY29uc3QgZXZlbnRSYW5nZSA9IGNhcmV0RnJvbVBvaW50KHgsIHkpO1xuXG4gICAgaWYgKGV2ZW50UmFuZ2UgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGV2ZW50UmFuZ2Uubm9kZSk7XG5cbiAgICAgIGlmIChsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUobm9kZSkpIHtcbiAgICAgICAgLy8gU2hvdyBicm93c2VyIGNhcmV0IGFzIHRoZSB1c2VyIGlzIGRyYWdnaW5nIHRoZSBtZWRpYSBhY3Jvc3MgdGhlIHNjcmVlbi4gV29uJ3Qgd29ya1xuICAgICAgICAvLyBmb3IgRGVjb3JhdG9yTm9kZSBub3IgaXQncyByZWxldmFudC5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5DT1BZX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjbGlwYm9hcmQuY29weVRvQ2xpcGJvYXJkKGVkaXRvciwgZXZlbnQgaW5zdGFuY2VvZiBDbGlwYm9hcmRFdmVudCA/IGV2ZW50IDogbnVsbCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuQ1VUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBvbkN1dEZvclJpY2hUZXh0KGV2ZW50LCBlZGl0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLlBBU1RFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBbLCBmaWxlcywgaGFzVGV4dENvbnRlbnRdID0gZXZlbnRGaWxlcyhldmVudCk7XG5cbiAgICBpZiAoZmlsZXMubGVuZ3RoID4gMCAmJiAhaGFzVGV4dENvbnRlbnQpIHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoRFJBR19EUk9QX1BBU1RFLCBmaWxlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgb25QYXN0ZUZvclJpY2hUZXh0KGV2ZW50LCBlZGl0b3IpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSk7XG4gIHJldHVybiByZW1vdmVMaXN0ZW5lcjtcbn1cblxuZXhwb3J0cy4kY3JlYXRlSGVhZGluZ05vZGUgPSAkY3JlYXRlSGVhZGluZ05vZGU7XG5leHBvcnRzLiRjcmVhdGVRdW90ZU5vZGUgPSAkY3JlYXRlUXVvdGVOb2RlO1xuZXhwb3J0cy4kaXNIZWFkaW5nTm9kZSA9ICRpc0hlYWRpbmdOb2RlO1xuZXhwb3J0cy4kaXNRdW90ZU5vZGUgPSAkaXNRdW90ZU5vZGU7XG5leHBvcnRzLkRSQUdfRFJPUF9QQVNURSA9IERSQUdfRFJPUF9QQVNURTtcbmV4cG9ydHMuSGVhZGluZ05vZGUgPSBIZWFkaW5nTm9kZTtcbmV4cG9ydHMuUXVvdGVOb2RlID0gUXVvdGVOb2RlO1xuZXhwb3J0cy5ldmVudEZpbGVzID0gZXZlbnRGaWxlcztcbmV4cG9ydHMucmVnaXN0ZXJSaWNoVGV4dCA9IHJlZ2lzdGVyUmljaFRleHQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.js":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/rich-text/LexicalRichText.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalRichText =  true ? __webpack_require__(/*! ./LexicalRichText.dev.js */ \"(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.dev.js\") : 0\nmodule.exports = LexicalRichText;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmljaC10ZXh0L0xleGljYWxSaWNoVGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLHdCQUF3QixLQUFzQyxHQUFHLG1CQUFPLENBQUMsZ0dBQTBCLElBQUksQ0FBb0M7QUFDM0kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yaWNoLXRleHQvTGV4aWNhbFJpY2hUZXh0LmpzPzJiNjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxSaWNoVGV4dCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsUmljaFRleHQuZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWxSaWNoVGV4dC5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbFJpY2hUZXh0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/rich-text/LexicalRichText.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.dev.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n\n    node = node.firstChild;\n  }\n\n  return null;\n}\n\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n\n  if (lexical.$isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n\n  if (lexical.$isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n\n  const firstChild = anchorDOM.firstChild;\n\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n\n  return range;\n}\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n\n  if (rootElement === null) {\n    return [];\n  }\n\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  let prevRect;\n\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i]; // Exclude a rect that is the exact same as the last rect. getClientRects() can return\n    // the same rect twice for some elements. A more sophisticated thing to do here is to\n    // merge all the rects together into a set of rects that don't overlap, so we don't\n    // generate backgrounds that are too dark.\n\n    const isDuplicateRect = prevRect && prevRect.top === selectionRect.top && prevRect.left === selectionRect.left && prevRect.width === selectionRect.width && prevRect.height === selectionRect.height; // Exclude selections that span the entire element\n\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n\n    if (isDuplicateRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n\n    prevRect = selectionRect;\n  }\n\n  return selectionRects;\n}\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n\n      styleObject[key.trim()] = value.trim();\n    }\n  }\n\n  return styleObject;\n}\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n\n  return value;\n}\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $updateElementNodeProperties(target, source) {\n  target.__first = source.__first;\n  target.__last = source.__last;\n  target.__size = source.__size;\n  target.__format = source.__format;\n  target.__indent = source.__indent;\n  target.__dir = source.__dir;\n  return target;\n}\n\nfunction $updateTextNodeProperties(target, source) {\n  target.__format = source.__format;\n  target.__style = source.__style;\n  target.__mode = source.__mode;\n  target.__detail = source.__detail;\n  return target;\n}\n\nfunction $cloneWithProperties(node) {\n  const latest = node.getLatest();\n  const constructor = latest.constructor; // @ts-expect-error\n\n  const clone = constructor.clone(latest);\n  clone.__parent = latest.__parent;\n  clone.__next = latest.__next;\n  clone.__prev = latest.__prev;\n\n  if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {\n    return $updateElementNodeProperties(clone, latest);\n  }\n\n  if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {\n    return $updateTextNodeProperties(clone, latest);\n  }\n\n  return clone;\n}\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n\n    if (isAnchor || isFocus) {\n      const isBackward = selection.isBackward();\n      const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n\n  return textNode;\n}\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n\n  return point.offset === point.getNode().getChildrenSize();\n}\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n\n  if (lexical.$isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n\n  while (remaining > 0 && currentNode !== null) {\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n\n      while (parentSibling === null) {\n        parent = parent.getParent();\n\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n\n        parentSibling = parent.getPreviousSibling();\n      }\n\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n\n        if (lexical.$isElementNode(parentSibling)) {\n          nextNode = parentSibling.getLastDescendant();\n        } else {\n          nextNode = parentSibling;\n        }\n      }\n    }\n\n    let text = currentNode.getTextContent(); // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n\n    if (text === '' && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n\n    const currentNodeSize = currentNode.getTextContentSize();\n\n    if (!lexical.$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n\n      if (parent != null && parent.getChildrenSize() === 0 && !lexical.$isRootNode(parent)) {\n        parent.remove();\n      }\n\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey(); // See if we can just revert it to what was in the last editor state\n\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = lexical.$getNodeByKey(key);\n\n        if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = lexical.$getPreviousSelection();\n        let target = currentNode;\n\n        if (!currentNode.isSimpleText()) {\n          const textNode = lexical.$createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n\n        if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset; // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = lexical.$createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n\n      remaining = 0;\n    }\n  }\n}\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n\n    return styles;\n  }, { ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n\n  if (selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key; // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n\n  if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n\n    if (lexical.$isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  } // This is the case where we only selected a single node\n\n\n  if (selectedNodes.length === 1) {\n    if (lexical.$isTextNode(firstNode)) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset; // No actual text is selected, so do nothing.\n\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n\n  } else {\n    if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n      }\n\n      $patchStyle(firstNode, patch);\n    }\n\n    if (lexical.$isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length; // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      } // if the entire last node isn't selected, split it\n\n\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n\n      if (endOffset !== 0) {\n        $patchStyle(lastNode, patch);\n      }\n    } // style all the text nodes in between\n\n\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n\n      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Converts all nodes in the selection that are of one block type to another specified by parameter\n *\n * @param selection\n * @param createElement\n * @returns\n */\n\nfunction $setBlocksType(selection, createElement) {\n  if (selection.anchor.key === 'root') {\n    const element = createElement();\n    const root = lexical.$getRoot();\n    const firstChild = root.getFirstChild();\n\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n\n    return;\n  }\n\n  const nodes = selection.getNodes();\n  let maybeBlock = selection.anchor.getNode().getParentOrThrow();\n\n  if (nodes.indexOf(maybeBlock) === -1) {\n    nodes.push(maybeBlock);\n  }\n\n  if (maybeBlock.isInline()) {\n    maybeBlock = maybeBlock.getParentOrThrow();\n\n    if (nodes.indexOf(maybeBlock) === -1) {\n      nodes.push(maybeBlock);\n    }\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (!isBlock(node)) {\n      continue;\n    }\n\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\n\nfunction isBlock(node) {\n  if (!lexical.$isElementNode(node) || lexical.$isRootOrShadowRoot(node)) {\n    return false;\n  }\n\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || lexical.$isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\n\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\n\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n\n  while (node !== null && !lexical.$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n\n    node = parentNode;\n  }\n}\n/** @deprecated */\n\n\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  const anchor = selection.anchor;\n\n  if (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n\n    target.replace(element);\n    return;\n  }\n\n  let topLevelNode = null;\n  let descendants = [];\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i]; // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n\n    if (lexical.$isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = []; // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n\n  let targetIsPrevSibling = false;\n\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n\n    target = target.getParentOrThrow();\n\n    if (lexical.$isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n\n  const emptyElements = new Set(); // Find any top level empty elements\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n\n  const movedNodes = new Set(); // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n\n    if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement); // Move node and its siblings to the new\n        // element.\n\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n\n          if (lexical.$isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n\n  let lastElement = null; // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n\n  if (lexical.$isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n\n      if (lexical.$isElementNode(firstChild)) {\n        target = firstChild;\n      }\n\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n\n  const prevSelection = lexical.$getPreviousSelection();\n\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    lexical.$setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n\n  if (lexical.$isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n\n  if (lexical.$isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n\n  return defaultValue;\n}\n\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n\n  if (selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]; // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n\n    if (lexical.$isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n\n  return styleValue === null ? defaultValue : styleValue;\n}\n\nexports.$addNodeStyle = $addNodeStyle;\nexports.$cloneWithProperties = $cloneWithProperties;\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\nexports.$isAtNodeEnd = $isAtNodeEnd;\nexports.$isParentElementRTL = $isParentElementRTL;\nexports.$moveCaretSelection = $moveCaretSelection;\nexports.$moveCharacter = $moveCharacter;\nexports.$patchStyleText = $patchStyleText;\nexports.$selectAll = $selectAll;\nexports.$setBlocksType = $setBlocksType;\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\nexports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;\nexports.$wrapNodes = $wrapNodes;\nexports.createDOMRange = createDOMRange;\nexports.createRectsFromDOMRange = createRectsFromDOMRange;\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\nexports.trimTextContentFromAnchor = trimTextContentFromAnchor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyx3REFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiwwQkFBMEI7QUFDNUMsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQSwwTUFBME07O0FBRTFNOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTSxJQUFJLGVBQWU7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTix3Q0FBd0M7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsR0FBRyxJQUFJO0FBQ1AsSUFBSSxLQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQSx5SEFBeUg7O0FBRXpIO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkMsa0JBQWtCLGlCQUFpQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQywyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLDRCQUE0QjtBQUM1QiwwQ0FBMEM7QUFDMUMsb0JBQW9CO0FBQ3BCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0Isc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2QixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLGdEQUFnRDtBQUNoRCxxQ0FBcUM7QUFDckMsa0JBQWtCO0FBQ2xCLHNCQUFzQjtBQUN0QiwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBQzdCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3NlbGVjdGlvbi9MZXhpY2FsU2VsZWN0aW9uLmRldi5qcz81ZDEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ1NTX1RPX1NUWUxFUyA9IG5ldyBNYXAoKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBnZXRET01UZXh0Tm9kZShlbGVtZW50KSB7XG4gIGxldCBub2RlID0gZWxlbWVudDtcblxuICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldERPTUluZGV4V2l0aGluUGFyZW50KG5vZGUpIHtcbiAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuXG4gIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGhhcHBlbicpO1xuICB9XG5cbiAgcmV0dXJuIFtwYXJlbnQsIEFycmF5LmZyb20ocGFyZW50LmNoaWxkTm9kZXMpLmluZGV4T2Yobm9kZSldO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVET01SYW5nZShlZGl0b3IsIGFuY2hvck5vZGUsIF9hbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgX2ZvY3VzT2Zmc2V0KSB7XG4gIGNvbnN0IGFuY2hvcktleSA9IGFuY2hvck5vZGUuZ2V0S2V5KCk7XG4gIGNvbnN0IGZvY3VzS2V5ID0gZm9jdXNOb2RlLmdldEtleSgpO1xuICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGxldCBhbmNob3JET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvcktleSk7XG4gIGxldCBmb2N1c0RPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZm9jdXNLZXkpO1xuICBsZXQgYW5jaG9yT2Zmc2V0ID0gX2FuY2hvck9mZnNldDtcbiAgbGV0IGZvY3VzT2Zmc2V0ID0gX2ZvY3VzT2Zmc2V0O1xuXG4gIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgYW5jaG9yRE9NID0gZ2V0RE9NVGV4dE5vZGUoYW5jaG9yRE9NKTtcbiAgfVxuXG4gIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICBmb2N1c0RPTSA9IGdldERPTVRleHROb2RlKGZvY3VzRE9NKTtcbiAgfVxuXG4gIGlmIChhbmNob3JOb2RlID09PSB1bmRlZmluZWQgfHwgZm9jdXNOb2RlID09PSB1bmRlZmluZWQgfHwgYW5jaG9yRE9NID09PSBudWxsIHx8IGZvY3VzRE9NID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoYW5jaG9yRE9NLm5vZGVOYW1lID09PSAnQlInKSB7XG4gICAgW2FuY2hvckRPTSwgYW5jaG9yT2Zmc2V0XSA9IGdldERPTUluZGV4V2l0aGluUGFyZW50KGFuY2hvckRPTSk7XG4gIH1cblxuICBpZiAoZm9jdXNET00ubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICBbZm9jdXNET00sIGZvY3VzT2Zmc2V0XSA9IGdldERPTUluZGV4V2l0aGluUGFyZW50KGZvY3VzRE9NKTtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBhbmNob3JET00uZmlyc3RDaGlsZDtcblxuICBpZiAoYW5jaG9yRE9NID09PSBmb2N1c0RPTSAmJiBmaXJzdENoaWxkICE9IG51bGwgJiYgZmlyc3RDaGlsZC5ub2RlTmFtZSA9PT0gJ0JSJyAmJiBhbmNob3JPZmZzZXQgPT09IDAgJiYgZm9jdXNPZmZzZXQgPT09IDApIHtcbiAgICBmb2N1c09mZnNldCA9IDE7XG4gIH1cblxuICB0cnkge1xuICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0KTtcbiAgICByYW5nZS5zZXRFbmQoZm9jdXNET00sIGZvY3VzT2Zmc2V0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHJhbmdlLmNvbGxhcHNlZCAmJiAoYW5jaG9yT2Zmc2V0ICE9PSBmb2N1c09mZnNldCB8fCBhbmNob3JLZXkgIT09IGZvY3VzS2V5KSkge1xuICAgIC8vIFJhbmdlIGlzIGJhY2t3YXJkcywgd2UgbmVlZCB0byByZXZlcnNlIGl0XG4gICAgcmFuZ2Uuc2V0U3RhcnQoZm9jdXNET00sIGZvY3VzT2Zmc2V0KTtcbiAgICByYW5nZS5zZXRFbmQoYW5jaG9yRE9NLCBhbmNob3JPZmZzZXQpO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuXG4gIGlmIChyb290RWxlbWVudCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHJvb3RSZWN0ID0gcm9vdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHJvb3RFbGVtZW50KTtcbiAgY29uc3Qgcm9vdFBhZGRpbmcgPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCk7XG4gIGNvbnN0IHNlbGVjdGlvblJlY3RzID0gQXJyYXkuZnJvbShyYW5nZS5nZXRDbGllbnRSZWN0cygpKTtcbiAgbGV0IHNlbGVjdGlvblJlY3RzTGVuZ3RoID0gc2VsZWN0aW9uUmVjdHMubGVuZ3RoO1xuICBsZXQgcHJldlJlY3Q7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb25SZWN0c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uUmVjdCA9IHNlbGVjdGlvblJlY3RzW2ldOyAvLyBFeGNsdWRlIGEgcmVjdCB0aGF0IGlzIHRoZSBleGFjdCBzYW1lIGFzIHRoZSBsYXN0IHJlY3QuIGdldENsaWVudFJlY3RzKCkgY2FuIHJldHVyblxuICAgIC8vIHRoZSBzYW1lIHJlY3QgdHdpY2UgZm9yIHNvbWUgZWxlbWVudHMuIEEgbW9yZSBzb3BoaXN0aWNhdGVkIHRoaW5nIHRvIGRvIGhlcmUgaXMgdG9cbiAgICAvLyBtZXJnZSBhbGwgdGhlIHJlY3RzIHRvZ2V0aGVyIGludG8gYSBzZXQgb2YgcmVjdHMgdGhhdCBkb24ndCBvdmVybGFwLCBzbyB3ZSBkb24ndFxuICAgIC8vIGdlbmVyYXRlIGJhY2tncm91bmRzIHRoYXQgYXJlIHRvbyBkYXJrLlxuXG4gICAgY29uc3QgaXNEdXBsaWNhdGVSZWN0ID0gcHJldlJlY3QgJiYgcHJldlJlY3QudG9wID09PSBzZWxlY3Rpb25SZWN0LnRvcCAmJiBwcmV2UmVjdC5sZWZ0ID09PSBzZWxlY3Rpb25SZWN0LmxlZnQgJiYgcHJldlJlY3Qud2lkdGggPT09IHNlbGVjdGlvblJlY3Qud2lkdGggJiYgcHJldlJlY3QuaGVpZ2h0ID09PSBzZWxlY3Rpb25SZWN0LmhlaWdodDsgLy8gRXhjbHVkZSBzZWxlY3Rpb25zIHRoYXQgc3BhbiB0aGUgZW50aXJlIGVsZW1lbnRcblxuICAgIGNvbnN0IHNlbGVjdGlvblNwYW5zRWxlbWVudCA9IHNlbGVjdGlvblJlY3Qud2lkdGggKyByb290UGFkZGluZyA9PT0gcm9vdFJlY3Qud2lkdGg7XG5cbiAgICBpZiAoaXNEdXBsaWNhdGVSZWN0IHx8IHNlbGVjdGlvblNwYW5zRWxlbWVudCkge1xuICAgICAgc2VsZWN0aW9uUmVjdHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICBzZWxlY3Rpb25SZWN0c0xlbmd0aC0tO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcHJldlJlY3QgPSBzZWxlY3Rpb25SZWN0O1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvblJlY3RzO1xufVxuZnVuY3Rpb24gZ2V0U3R5bGVPYmplY3RGcm9tUmF3Q1NTKGNzcykge1xuICBjb25zdCBzdHlsZU9iamVjdCA9IHt9O1xuICBjb25zdCBzdHlsZXMgPSBjc3Muc3BsaXQoJzsnKTtcblxuICBmb3IgKGNvbnN0IHN0eWxlIG9mIHN0eWxlcykge1xuICAgIGlmIChzdHlsZSAhPT0gJycpIHtcbiAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHN0eWxlLnNwbGl0KC86KFteXSspLyk7IC8vIHNwbGl0IG9uIGZpcnN0IGNvbG9uXG5cbiAgICAgIHN0eWxlT2JqZWN0W2tleS50cmltKCldID0gdmFsdWUudHJpbSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZU9iamVjdDtcbn1cbmZ1bmN0aW9uIGdldFN0eWxlT2JqZWN0RnJvbUNTUyhjc3MpIHtcbiAgbGV0IHZhbHVlID0gQ1NTX1RPX1NUWUxFUy5nZXQoY3NzKTtcblxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0U3R5bGVPYmplY3RGcm9tUmF3Q1NTKGNzcyk7XG4gICAgQ1NTX1RPX1NUWUxFUy5zZXQoY3NzLCB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRDU1NGcm9tU3R5bGVPYmplY3Qoc3R5bGVzKSB7XG4gIGxldCBjc3MgPSAnJztcblxuICBmb3IgKGNvbnN0IHN0eWxlIGluIHN0eWxlcykge1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgY3NzICs9IGAke3N0eWxlfTogJHtzdHlsZXNbc3R5bGVdfTtgO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjc3M7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJHVwZGF0ZUVsZW1lbnROb2RlUHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSkge1xuICB0YXJnZXQuX19maXJzdCA9IHNvdXJjZS5fX2ZpcnN0O1xuICB0YXJnZXQuX19sYXN0ID0gc291cmNlLl9fbGFzdDtcbiAgdGFyZ2V0Ll9fc2l6ZSA9IHNvdXJjZS5fX3NpemU7XG4gIHRhcmdldC5fX2Zvcm1hdCA9IHNvdXJjZS5fX2Zvcm1hdDtcbiAgdGFyZ2V0Ll9faW5kZW50ID0gc291cmNlLl9faW5kZW50O1xuICB0YXJnZXQuX19kaXIgPSBzb3VyY2UuX19kaXI7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uICR1cGRhdGVUZXh0Tm9kZVByb3BlcnRpZXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgdGFyZ2V0Ll9fZm9ybWF0ID0gc291cmNlLl9fZm9ybWF0O1xuICB0YXJnZXQuX19zdHlsZSA9IHNvdXJjZS5fX3N0eWxlO1xuICB0YXJnZXQuX19tb2RlID0gc291cmNlLl9fbW9kZTtcbiAgdGFyZ2V0Ll9fZGV0YWlsID0gc291cmNlLl9fZGV0YWlsO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiAkY2xvbmVXaXRoUHJvcGVydGllcyhub2RlKSB7XG4gIGNvbnN0IGxhdGVzdCA9IG5vZGUuZ2V0TGF0ZXN0KCk7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gbGF0ZXN0LmNvbnN0cnVjdG9yOyAvLyBAdHMtZXhwZWN0LWVycm9yXG5cbiAgY29uc3QgY2xvbmUgPSBjb25zdHJ1Y3Rvci5jbG9uZShsYXRlc3QpO1xuICBjbG9uZS5fX3BhcmVudCA9IGxhdGVzdC5fX3BhcmVudDtcbiAgY2xvbmUuX19uZXh0ID0gbGF0ZXN0Ll9fbmV4dDtcbiAgY2xvbmUuX19wcmV2ID0gbGF0ZXN0Ll9fcHJldjtcblxuICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShsYXRlc3QpICYmIGxleGljYWwuJGlzRWxlbWVudE5vZGUoY2xvbmUpKSB7XG4gICAgcmV0dXJuICR1cGRhdGVFbGVtZW50Tm9kZVByb3BlcnRpZXMoY2xvbmUsIGxhdGVzdCk7XG4gIH1cblxuICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShsYXRlc3QpICYmIGxleGljYWwuJGlzVGV4dE5vZGUoY2xvbmUpKSB7XG4gICAgcmV0dXJuICR1cGRhdGVUZXh0Tm9kZVByb3BlcnRpZXMoY2xvbmUsIGxhdGVzdCk7XG4gIH1cblxuICByZXR1cm4gY2xvbmU7XG59XG5mdW5jdGlvbiAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudChzZWxlY3Rpb24sIHRleHROb2RlKSB7XG4gIGlmICh0ZXh0Tm9kZS5pc1NlbGVjdGVkKCkgJiYgIXRleHROb2RlLmlzU2VnbWVudGVkKCkgJiYgIXRleHROb2RlLmlzVG9rZW4oKSAmJiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgaXNBbmNob3IgPSB0ZXh0Tm9kZS5pcyhhbmNob3JOb2RlKTtcbiAgICBjb25zdCBpc0ZvY3VzID0gdGV4dE5vZGUuaXMoZm9jdXNOb2RlKTtcblxuICAgIGlmIChpc0FuY2hvciB8fCBpc0ZvY3VzKSB7XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICAgIGNvbnN0IFthbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0XSA9IHNlbGVjdGlvbi5nZXRDaGFyYWN0ZXJPZmZzZXRzKCk7XG4gICAgICBjb25zdCBpc1NhbWUgPSBhbmNob3JOb2RlLmlzKGZvY3VzTm9kZSk7XG4gICAgICBjb25zdCBpc0ZpcnN0ID0gdGV4dE5vZGUuaXMoaXNCYWNrd2FyZCA/IGZvY3VzTm9kZSA6IGFuY2hvck5vZGUpO1xuICAgICAgY29uc3QgaXNMYXN0ID0gdGV4dE5vZGUuaXMoaXNCYWNrd2FyZCA/IGFuY2hvck5vZGUgOiBmb2N1c05vZGUpO1xuICAgICAgbGV0IHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICAgIGxldCBlbmRPZmZzZXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc1NhbWUpIHtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBlbmRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGVuZE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICBlbmRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIHRleHROb2RlLl9fdGV4dCA9IHRleHROb2RlLl9fdGV4dC5zbGljZShzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgIHJldHVybiB0ZXh0Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGV4dE5vZGU7XG59XG5mdW5jdGlvbiAkaXNBdE5vZGVFbmQocG9pbnQpIHtcbiAgaWYgKHBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IHBvaW50LmdldE5vZGUoKS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludC5vZmZzZXQgPT09IHBvaW50LmdldE5vZGUoKS5nZXRDaGlsZHJlblNpemUoKTtcbn1cbmZ1bmN0aW9uIHRyaW1UZXh0Q29udGVudEZyb21BbmNob3IoZWRpdG9yLCBhbmNob3IsIGRlbENvdW50KSB7XG4gIC8vIFdvcmsgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5jaG9yIHBvaW50XG4gIGxldCBjdXJyZW50Tm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGxldCByZW1haW5pbmcgPSBkZWxDb3VudDtcblxuICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBkZXNjZW5kYW50Tm9kZSA9IGN1cnJlbnROb2RlLmdldERlc2NlbmRhbnRCeUluZGV4KGFuY2hvci5vZmZzZXQpO1xuXG4gICAgaWYgKGRlc2NlbmRhbnROb2RlICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGRlc2NlbmRhbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChyZW1haW5pbmcgPiAwICYmIGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgbGV0IG5leHROb2RlID0gY3VycmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgbGV0IGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZSA9IDA7XG5cbiAgICBpZiAobmV4dE5vZGUgPT09IG51bGwpIHtcbiAgICAgIGxldCBwYXJlbnQgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBsZXQgcGFyZW50U2libGluZyA9IHBhcmVudC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgICAgd2hpbGUgKHBhcmVudFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuXG4gICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZSA9IHBhcmVudC5pc0lubGluZSgpID8gMCA6IDI7XG5cbiAgICAgICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUocGFyZW50U2libGluZykpIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IHBhcmVudFNpYmxpbmcuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0Tm9kZSA9IHBhcmVudFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgdGV4dCA9IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50KCk7IC8vIElmIHRoZSB0ZXh0IGlzIGVtcHR5LCB3ZSBuZWVkIHRvIGNvbnNpZGVyIGFkZGluZyBpbiB0d28gbGluZSBicmVha3MgdG8gbWF0Y2hcbiAgICAvLyB0aGUgY29udGVudCBpZiB3ZSB3ZXJlIHRvIGdldCBpdCBmcm9tIGl0cyBwYXJlbnQuXG5cbiAgICBpZiAodGV4dCA9PT0gJycgJiYgbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgIWN1cnJlbnROb2RlLmlzSW5saW5lKCkpIHtcbiAgICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIGhhbmRsZWQgaW4gY29yZT9cbiAgICAgIHRleHQgPSAnXFxuXFxuJztcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50Tm9kZVNpemUgPSBjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcblxuICAgIGlmICghbGV4aWNhbC4kaXNUZXh0Tm9kZShjdXJyZW50Tm9kZSkgfHwgcmVtYWluaW5nID49IGN1cnJlbnROb2RlU2l6ZSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gY3VycmVudE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBjdXJyZW50Tm9kZS5yZW1vdmUoKTtcblxuICAgICAgaWYgKHBhcmVudCAhPSBudWxsICYmIHBhcmVudC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCAmJiAhbGV4aWNhbC4kaXNSb290Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudC5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgcmVtYWluaW5nIC09IGN1cnJlbnROb2RlU2l6ZSArIGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZTtcbiAgICAgIGN1cnJlbnROb2RlID0gbmV4dE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleSA9IGN1cnJlbnROb2RlLmdldEtleSgpOyAvLyBTZWUgaWYgd2UgY2FuIGp1c3QgcmV2ZXJ0IGl0IHRvIHdoYXQgd2FzIGluIHRoZSBsYXN0IGVkaXRvciBzdGF0ZVxuXG4gICAgICBjb25zdCBwcmV2VGV4dENvbnRlbnQgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldk5vZGUgPSBsZXhpY2FsLiRnZXROb2RlQnlLZXkoa2V5KTtcblxuICAgICAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShwcmV2Tm9kZSkgJiYgcHJldk5vZGUuaXNTaW1wbGVUZXh0KCkpIHtcbiAgICAgICAgICByZXR1cm4gcHJldk5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBjdXJyZW50Tm9kZVNpemUgLSByZW1haW5pbmc7XG4gICAgICBjb25zdCBzbGljZWRUZXh0ID0gdGV4dC5zbGljZSgwLCBvZmZzZXQpO1xuXG4gICAgICBpZiAocHJldlRleHRDb250ZW50ICE9PSBudWxsICYmIHByZXZUZXh0Q29udGVudCAhPT0gdGV4dCkge1xuICAgICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IGN1cnJlbnROb2RlO1xuXG4gICAgICAgIGlmICghY3VycmVudE5vZGUuaXNTaW1wbGVUZXh0KCkpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IGxleGljYWwuJGNyZWF0ZVRleHROb2RlKHByZXZUZXh0Q29udGVudCk7XG4gICAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gdGV4dE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE5vZGUuc2V0VGV4dENvbnRlbnQocHJldlRleHRDb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIHByZXZTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICAgIGNvbnN0IHByZXZPZmZzZXQgPSBwcmV2U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQ7XG4gICAgICAgICAgdGFyZ2V0LnNlbGVjdChwcmV2T2Zmc2V0LCBwcmV2T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50Tm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgICAvLyBTcGxpdCB0ZXh0XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBhbmNob3Iua2V5ID09PSBrZXk7XG4gICAgICAgIGxldCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0OyAvLyBNb3ZlIG9mZnNldCB0byBlbmQgaWYgaXQncyBsZXNzIHRoYW4gdGhlIHJlbWFpbmluZyBudW1iZXIsIG90aGVyd2lzZVxuICAgICAgICAvLyB3ZSdsbCBoYXZlIGEgbmVnYXRpdmUgc3BsaXRTdGFydC5cblxuICAgICAgICBpZiAoYW5jaG9yT2Zmc2V0IDwgcmVtYWluaW5nKSB7XG4gICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gY3VycmVudE5vZGVTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3BsaXRTdGFydCA9IGlzU2VsZWN0ZWQgPyBhbmNob3JPZmZzZXQgLSByZW1haW5pbmcgOiAwO1xuICAgICAgICBjb25zdCBzcGxpdEVuZCA9IGlzU2VsZWN0ZWQgPyBhbmNob3JPZmZzZXQgOiBvZmZzZXQ7XG5cbiAgICAgICAgaWYgKGlzU2VsZWN0ZWQgJiYgc3BsaXRTdGFydCA9PT0gMCkge1xuICAgICAgICAgIGNvbnN0IFtleGNlc3NOb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChzcGxpdFN0YXJ0LCBzcGxpdEVuZCk7XG4gICAgICAgICAgZXhjZXNzTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBbLCBleGNlc3NOb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChzcGxpdFN0YXJ0LCBzcGxpdEVuZCk7XG4gICAgICAgICAgZXhjZXNzTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBsZXhpY2FsLiRjcmVhdGVUZXh0Tm9kZShzbGljZWRUZXh0KTtcbiAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJlbWFpbmluZyA9IDA7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkYWRkTm9kZVN0eWxlKG5vZGUpIHtcbiAgY29uc3QgQ1NTVGV4dCA9IG5vZGUuZ2V0U3R5bGUoKTtcbiAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVPYmplY3RGcm9tUmF3Q1NTKENTU1RleHQpO1xuICBDU1NfVE9fU1RZTEVTLnNldChDU1NUZXh0LCBzdHlsZXMpO1xufVxuXG5mdW5jdGlvbiAkcGF0Y2hTdHlsZSh0YXJnZXQsIHBhdGNoKSB7XG4gIGNvbnN0IHByZXZTdHlsZXMgPSBnZXRTdHlsZU9iamVjdEZyb21DU1MoJ2dldFN0eWxlJyBpbiB0YXJnZXQgPyB0YXJnZXQuZ2V0U3R5bGUoKSA6IHRhcmdldC5zdHlsZSk7XG4gIGNvbnN0IG5ld1N0eWxlcyA9IE9iamVjdC5lbnRyaWVzKHBhdGNoKS5yZWR1Y2UoKHN0eWxlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICBkZWxldGUgc3R5bGVzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc1trZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlcztcbiAgfSwgeyAuLi5wcmV2U3R5bGVzXG4gIH0gfHwge30pO1xuICBjb25zdCBuZXdDU1NUZXh0ID0gZ2V0Q1NTRnJvbVN0eWxlT2JqZWN0KG5ld1N0eWxlcyk7XG4gIHRhcmdldC5zZXRTdHlsZShuZXdDU1NUZXh0KTtcbiAgQ1NTX1RPX1NUWUxFUy5zZXQobmV3Q1NTVGV4dCwgbmV3U3R5bGVzKTtcbn1cblxuZnVuY3Rpb24gJHBhdGNoU3R5bGVUZXh0KHNlbGVjdGlvbiwgcGF0Y2gpIHtcbiAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBzZWxlY3RlZE5vZGVzTGVuZ3RoID0gc2VsZWN0ZWROb2Rlcy5sZW5ndGg7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHNlbGVjdGVkTm9kZXNMZW5ndGggLSAxO1xuICBsZXQgZmlyc3ROb2RlID0gc2VsZWN0ZWROb2Rlc1swXTtcbiAgbGV0IGxhc3ROb2RlID0gc2VsZWN0ZWROb2Rlc1tsYXN0SW5kZXhdO1xuXG4gIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICRwYXRjaFN0eWxlKHNlbGVjdGlvbiwgcGF0Y2gpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBmaXJzdE5vZGVUZXh0ID0gZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IGZpcnN0Tm9kZVRleHRMZW5ndGggPSBmaXJzdE5vZGVUZXh0Lmxlbmd0aDtcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gIGxldCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gIGxldCBzdGFydE9mZnNldCA9IGlzQmVmb3JlID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gIGxldCBlbmRPZmZzZXQgPSBpc0JlZm9yZSA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICBjb25zdCBzdGFydFR5cGUgPSBpc0JlZm9yZSA/IGFuY2hvci50eXBlIDogZm9jdXMudHlwZTtcbiAgY29uc3QgZW5kVHlwZSA9IGlzQmVmb3JlID8gZm9jdXMudHlwZSA6IGFuY2hvci50eXBlO1xuICBjb25zdCBlbmRLZXkgPSBpc0JlZm9yZSA/IGZvY3VzLmtleSA6IGFuY2hvci5rZXk7IC8vIFRoaXMgaXMgdGhlIGNhc2Ugd2hlcmUgdGhlIHVzZXIgb25seSBzZWxlY3RlZCB0aGUgdmVyeSBlbmQgb2YgdGhlXG4gIC8vIGZpcnN0IG5vZGUgc28gd2UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlIGl0IGluIHRoZSBmb3JtYXR0aW5nIGNoYW5nZS5cblxuICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShmaXJzdE5vZGUpICYmIHN0YXJ0T2Zmc2V0ID09PSBmaXJzdE5vZGVUZXh0TGVuZ3RoKSB7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBmaXJzdE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgLy8gd2UgYmFzaWNhbGx5IG1ha2UgdGhlIHNlY29uZCBub2RlIHRoZSBmaXJzdE5vZGUsIGNoYW5naW5nIG9mZnNldHMgYWNjb3JkaW5nbHlcbiAgICAgIGFuY2hvck9mZnNldCA9IDA7XG4gICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICBmaXJzdE5vZGUgPSBuZXh0U2libGluZztcbiAgICB9XG4gIH0gLy8gVGhpcyBpcyB0aGUgY2FzZSB3aGVyZSB3ZSBvbmx5IHNlbGVjdGVkIGEgc2luZ2xlIG5vZGVcblxuXG4gIGlmIChzZWxlY3RlZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gc3RhcnRUeXBlID09PSAnZWxlbWVudCcgPyAwIDogYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgIGVuZE9mZnNldCA9IGVuZFR5cGUgPT09ICdlbGVtZW50JyA/IGZpcnN0Tm9kZVRleHRMZW5ndGggOiBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0OyAvLyBObyBhY3R1YWwgdGV4dCBpcyBzZWxlY3RlZCwgc28gZG8gbm90aGluZy5cblxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSBlbmRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUaGUgZW50aXJlIG5vZGUgaXMgc2VsZWN0ZWQsIHNvIGp1c3QgZm9ybWF0IGl0XG5cblxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAwICYmIGVuZE9mZnNldCA9PT0gZmlyc3ROb2RlVGV4dExlbmd0aCkge1xuICAgICAgICAkcGF0Y2hTdHlsZShmaXJzdE5vZGUsIHBhdGNoKTtcbiAgICAgICAgZmlyc3ROb2RlLnNlbGVjdChzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBub2RlIGlzIHBhcnRpYWxseSBzZWxlY3RlZCwgc28gc3BsaXQgaXQgaW50byB0d28gbm9kZXNcbiAgICAgICAgLy8gYW5kIHN0eWxlIHRoZSBzZWxlY3RlZCBvbmUuXG4gICAgICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHN0YXJ0T2Zmc2V0ID09PSAwID8gc3BsaXROb2Rlc1swXSA6IHNwbGl0Tm9kZXNbMV07XG4gICAgICAgICRwYXRjaFN0eWxlKHJlcGxhY2VtZW50LCBwYXRjaCk7XG4gICAgICAgIHJlcGxhY2VtZW50LnNlbGVjdCgwLCBlbmRPZmZzZXQgLSBzdGFydE9mZnNldCk7XG4gICAgICB9XG4gICAgfSAvLyBtdWx0aXBsZSBub2RlcyBzZWxlY3RlZC5cblxuICB9IGVsc2Uge1xuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGZpcnN0Tm9kZSkgJiYgc3RhcnRPZmZzZXQgPCBmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgIGlmIChzdGFydE9mZnNldCAhPT0gMCkge1xuICAgICAgICAvLyB0aGUgZW50aXJlIGZpcnN0IG5vZGUgaXNuJ3Qgc2VsZWN0ZWQsIHNvIHNwbGl0IGl0XG4gICAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQpWzFdO1xuICAgICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgICB9XG5cbiAgICAgICRwYXRjaFN0eWxlKGZpcnN0Tm9kZSwgcGF0Y2gpO1xuICAgIH1cblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGxhc3ROb2RlKSkge1xuICAgICAgY29uc3QgbGFzdE5vZGVUZXh0ID0gbGFzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgIGNvbnN0IGxhc3ROb2RlVGV4dExlbmd0aCA9IGxhc3ROb2RlVGV4dC5sZW5ndGg7IC8vIFRoZSBsYXN0IG5vZGUgbWlnaHQgbm90IGFjdHVhbGx5IGJlIHRoZSBlbmQgbm9kZVxuICAgICAgLy9cbiAgICAgIC8vIElmIG5vdCwgYXNzdW1lIHRoZSBsYXN0IG5vZGUgaXMgZnVsbHktc2VsZWN0ZWQgdW5sZXNzIHRoZSBlbmQgb2Zmc2V0IGlzXG4gICAgICAvLyB6ZXJvLlxuXG4gICAgICBpZiAobGFzdE5vZGUuX19rZXkgIT09IGVuZEtleSAmJiBlbmRPZmZzZXQgIT09IDApIHtcbiAgICAgICAgZW5kT2Zmc2V0ID0gbGFzdE5vZGVUZXh0TGVuZ3RoO1xuICAgICAgfSAvLyBpZiB0aGUgZW50aXJlIGxhc3Qgbm9kZSBpc24ndCBzZWxlY3RlZCwgc3BsaXQgaXRcblxuXG4gICAgICBpZiAoZW5kT2Zmc2V0ICE9PSBsYXN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgICAgW2xhc3ROb2RlXSA9IGxhc3ROb2RlLnNwbGl0VGV4dChlbmRPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICRwYXRjaFN0eWxlKGxhc3ROb2RlLCBwYXRjaCk7XG4gICAgICB9XG4gICAgfSAvLyBzdHlsZSBhbGwgdGhlIHRleHQgbm9kZXMgaW4gYmV0d2VlblxuXG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZE5vZGUgPSBzZWxlY3RlZE5vZGVzW2ldO1xuICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlS2V5ID0gc2VsZWN0ZWROb2RlLmdldEtleSgpO1xuXG4gICAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShzZWxlY3RlZE5vZGUpICYmIHNlbGVjdGVkTm9kZUtleSAhPT0gZmlyc3ROb2RlLmdldEtleSgpICYmIHNlbGVjdGVkTm9kZUtleSAhPT0gbGFzdE5vZGUuZ2V0S2V5KCkgJiYgIXNlbGVjdGVkTm9kZS5pc1Rva2VuKCkpIHtcbiAgICAgICAgJHBhdGNoU3R5bGUoc2VsZWN0ZWROb2RlLCBwYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbi8qKlxuICogQ29udmVydHMgYWxsIG5vZGVzIGluIHRoZSBzZWxlY3Rpb24gdGhhdCBhcmUgb2Ygb25lIGJsb2NrIHR5cGUgdG8gYW5vdGhlciBzcGVjaWZpZWQgYnkgcGFyYW1ldGVyXG4gKlxuICogQHBhcmFtIHNlbGVjdGlvblxuICogQHBhcmFtIGNyZWF0ZUVsZW1lbnRcbiAqIEByZXR1cm5zXG4gKi9cblxuZnVuY3Rpb24gJHNldEJsb2Nrc1R5cGUoc2VsZWN0aW9uLCBjcmVhdGVFbGVtZW50KSB7XG4gIGlmIChzZWxlY3Rpb24uYW5jaG9yLmtleSA9PT0gJ3Jvb3QnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICBjb25zdCByb290ID0gbGV4aWNhbC4kZ2V0Um9vdCgpO1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSByb290LmdldEZpcnN0Q2hpbGQoKTtcblxuICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICBmaXJzdENoaWxkLnJlcGxhY2UoZWxlbWVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QuYXBwZW5kKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGxldCBtYXliZUJsb2NrID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkuZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gIGlmIChub2Rlcy5pbmRleE9mKG1heWJlQmxvY2spID09PSAtMSkge1xuICAgIG5vZGVzLnB1c2gobWF5YmVCbG9jayk7XG4gIH1cblxuICBpZiAobWF5YmVCbG9jay5pc0lubGluZSgpKSB7XG4gICAgbWF5YmVCbG9jayA9IG1heWJlQmxvY2suZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gICAgaWYgKG5vZGVzLmluZGV4T2YobWF5YmVCbG9jaykgPT09IC0xKSB7XG4gICAgICBub2Rlcy5wdXNoKG1heWJlQmxvY2spO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAoIWlzQmxvY2sobm9kZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgdGFyZ2V0RWxlbWVudC5zZXRGb3JtYXQobm9kZS5nZXRGb3JtYXRUeXBlKCkpO1xuICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KG5vZGUuZ2V0SW5kZW50KCkpO1xuICAgIG5vZGUucmVwbGFjZSh0YXJnZXRFbGVtZW50LCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0Jsb2NrKG5vZGUpIHtcbiAgaWYgKCFsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG5vZGUpIHx8IGxleGljYWwuJGlzUm9vdE9yU2hhZG93Um9vdChub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgY29uc3QgaXNMZWFmRWxlbWVudCA9IGZpcnN0Q2hpbGQgPT09IG51bGwgfHwgbGV4aWNhbC4kaXNUZXh0Tm9kZShmaXJzdENoaWxkKSB8fCBmaXJzdENoaWxkLmlzSW5saW5lKCk7XG4gIHJldHVybiAhbm9kZS5pc0lubGluZSgpICYmIG5vZGUuY2FuQmVFbXB0eSgpICE9PSBmYWxzZSAmJiBpc0xlYWZFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1BvaW50QXR0YWNoZWQocG9pbnQpIHtcbiAgcmV0dXJuIHBvaW50LmdldE5vZGUoKS5pc0F0dGFjaGVkKCk7XG59XG5cbmZ1bmN0aW9uICRyZW1vdmVQYXJlbnRFbXB0eUVsZW1lbnRzKHN0YXJ0aW5nTm9kZSkge1xuICBsZXQgbm9kZSA9IHN0YXJ0aW5nTm9kZTtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiAhbGV4aWNhbC4kaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgY29uc3QgbGF0ZXN0ID0gbm9kZS5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChsYXRlc3QuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgIG5vZGUucmVtb3ZlKHRydWUpO1xuICAgIH1cblxuICAgIG5vZGUgPSBwYXJlbnROb2RlO1xuICB9XG59XG4vKiogQGRlcHJlY2F0ZWQgKi9cblxuXG5mdW5jdGlvbiAkd3JhcE5vZGVzKHNlbGVjdGlvbiwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcblxuICBpZiAobm9kZXNMZW5ndGggPT09IDAgfHwgbm9kZXNMZW5ndGggPT09IDEgJiYgYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBhbmNob3IuZ2V0Tm9kZSgpLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gYW5jaG9yLnR5cGUgPT09ICd0ZXh0JyA/IGFuY2hvci5nZXROb2RlKCkuZ2V0UGFyZW50T3JUaHJvdygpIDogYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRhcmdldC5nZXRDaGlsZHJlbigpO1xuICAgIGxldCBlbGVtZW50ID0gY3JlYXRlRWxlbWVudCgpO1xuICAgIGVsZW1lbnQuc2V0Rm9ybWF0KHRhcmdldC5nZXRGb3JtYXRUeXBlKCkpO1xuICAgIGVsZW1lbnQuc2V0SW5kZW50KHRhcmdldC5nZXRJbmRlbnQoKSk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBlbGVtZW50LmFwcGVuZChjaGlsZCkpO1xuXG4gICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IHdyYXBwaW5nRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgdGFyZ2V0LnJlcGxhY2UoZWxlbWVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHRvcExldmVsTm9kZSA9IG51bGw7XG4gIGxldCBkZXNjZW5kYW50cyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTsgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgd3JhcHBpbmcgaGFzIHRvIGJlIGJyb2tlbiBkb3duIGludG8gbXVsdGlwbGUgY2h1bmtzLiBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlXG4gICAgLy8gdXNlciBzZWxlY3RlZCBtdWx0aXBsZSBSb290LWxpa2Ugbm9kZXMgdGhhdCBoYXZlIHRvIGJlIHRyZWF0ZWQgc2VwYXJhdGVseSBhcyBpZiB0aGV5IGFyZVxuICAgIC8vIHRoZWlyIG93biBicmFuY2guIEkuZS4geW91IGRvbid0IHdhbnQgdG8gd3JhcCBhIHdob2xlIHRhYmxlLCBidXQgcmF0aGVyIHRoZSBjb250ZW50cyBvZiBlYWNoXG4gICAgLy8gb2YgZWFjaCBvZiB0aGUgY2VsbCBub2Rlcy5cblxuICAgIGlmIChsZXhpY2FsLiRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICAgICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzLmxlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIGRlc2NlbmRhbnRzID0gW107XG4gICAgICB0b3BMZXZlbE5vZGUgPSBub2RlO1xuICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxOb2RlID09PSBudWxsIHx8IHRvcExldmVsTm9kZSAhPT0gbnVsbCAmJiBsZXhpY2FsLiRoYXNBbmNlc3Rvcihub2RlLCB0b3BMZXZlbE5vZGUpKSB7XG4gICAgICBkZXNjZW5kYW50cy5wdXNoKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICBkZXNjZW5kYW50cyA9IFtub2RlXTtcbiAgICB9XG4gIH1cblxuICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG59XG5mdW5jdGlvbiAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIG5vZGVzLCBub2Rlc0xlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZmlyc3ROb2RlID0gbm9kZXNbMF07XG4gIGNvbnN0IGVsZW1lbnRNYXBwaW5nID0gbmV3IE1hcCgpO1xuICBjb25zdCBlbGVtZW50cyA9IFtdOyAvLyBUaGUgYmVsb3cgbG9naWMgaXMgdG8gZmluZCB0aGUgcmlnaHQgdGFyZ2V0IGZvciB1cyB0b1xuICAvLyBlaXRoZXIgaW5zZXJ0QWZ0ZXIvaW5zZXJ0QmVmb3JlL2FwcGVuZCB0aGUgY29ycmVzcG9uZGluZ1xuICAvLyBlbGVtZW50cyB0by4gVGhpcyBpcyBtYWRlIG1vcmUgY29tcGxpY2F0ZWQgZHVlIHRvIG5lc3RlZFxuICAvLyBzdHJ1Y3R1cmVzLlxuXG4gIGxldCB0YXJnZXQgPSBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGZpcnN0Tm9kZSkgPyBmaXJzdE5vZGUgOiBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gIGlmICh0YXJnZXQuaXNJbmxpbmUoKSkge1xuICAgIHRhcmdldCA9IHRhcmdldC5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cblxuICBsZXQgdGFyZ2V0SXNQcmV2U2libGluZyA9IGZhbHNlO1xuXG4gIHdoaWxlICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRhcmdldC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgdGFyZ2V0ID0gcHJldlNpYmxpbmc7XG4gICAgICB0YXJnZXRJc1ByZXZTaWJsaW5nID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRhcmdldCA9IHRhcmdldC5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNSb290T3JTaGFkb3dSb290KHRhcmdldCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVtcHR5RWxlbWVudHMgPSBuZXcgU2V0KCk7IC8vIEZpbmQgYW55IHRvcCBsZXZlbCBlbXB0eSBlbGVtZW50c1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgIGVtcHR5RWxlbWVudHMuYWRkKG5vZGUuZ2V0S2V5KCkpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1vdmVkTm9kZXMgPSBuZXcgU2V0KCk7IC8vIE1vdmUgb3V0IGFsbCBsZWFmIG5vZGVzIGludG8gb3VyIGVsZW1lbnRzIGFycmF5LlxuICAvLyBJZiB3ZSBmaW5kIGEgdG9wIGxldmVsIGVtcHR5IGVsZW1lbnQsIGFsc28gbW92ZSBtYWtlXG4gIC8vIGFuIGVsZW1lbnQgZm9yIHRoYXQuXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGxldCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuaXNJbmxpbmUoKSkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQgIT09IG51bGwgJiYgbGV4aWNhbC4kaXNMZWFmTm9kZShub2RlKSAmJiAhbW92ZWROb2Rlcy5oYXMobm9kZS5nZXRLZXkoKSkpIHtcbiAgICAgIGNvbnN0IHBhcmVudEtleSA9IHBhcmVudC5nZXRLZXkoKTtcblxuICAgICAgaWYgKGVsZW1lbnRNYXBwaW5nLmdldChwYXJlbnRLZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRGb3JtYXQocGFyZW50LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KHBhcmVudC5nZXRJbmRlbnQoKSk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2godGFyZ2V0RWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnRNYXBwaW5nLnNldChwYXJlbnRLZXksIHRhcmdldEVsZW1lbnQpOyAvLyBNb3ZlIG5vZGUgYW5kIGl0cyBzaWJsaW5ncyB0byB0aGUgbmV3XG4gICAgICAgIC8vIGVsZW1lbnQuXG5cbiAgICAgICAgcGFyZW50LmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgdGFyZ2V0RWxlbWVudC5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgIG1vdmVkTm9kZXMuYWRkKGNoaWxkLmdldEtleSgpKTtcblxuICAgICAgICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgLy8gU2tpcCBuZXN0ZWQgbGVhZiBub2RlcyBpZiB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gbW92ZWRcbiAgICAgICAgICAgIGNoaWxkLmdldENoaWxkcmVuS2V5cygpLmZvckVhY2goa2V5ID0+IG1vdmVkTm9kZXMuYWRkKGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRyZW1vdmVQYXJlbnRFbXB0eUVsZW1lbnRzKHBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbXB0eUVsZW1lbnRzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgIHRhcmdldEVsZW1lbnQuc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KG5vZGUuZ2V0SW5kZW50KCkpO1xuICAgICAgZWxlbWVudHMucHVzaCh0YXJnZXRFbGVtZW50KTtcbiAgICAgIG5vZGUucmVtb3ZlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICB3cmFwcGluZ0VsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGxldCBsYXN0RWxlbWVudCA9IG51bGw7IC8vIElmIG91ciB0YXJnZXQgaXMgUm9vdC1saWtlLCBsZXQncyBzZWUgaWYgd2UgY2FuIHJlLWFkanVzdFxuICAvLyBzbyB0aGF0IHRoZSB0YXJnZXQgaXMgdGhlIGZpcnN0IGNoaWxkIGluc3RlYWQuXG5cbiAgaWYgKGxleGljYWwuJGlzUm9vdE9yU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgaWYgKHRhcmdldElzUHJldlNpYmxpbmcpIHtcbiAgICAgIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gZWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0YXJnZXQuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgICB0YXJnZXQgPSBmaXJzdENoaWxkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlyc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAod3JhcHBpbmdFbGVtZW50KSB7XG4gICAgICAgICAgdGFyZ2V0LmFwcGVuZCh3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgIHRhcmdldC5hcHBlbmQoZWxlbWVudCk7XG4gICAgICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAod3JhcHBpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUod3JhcHBpbmdFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShlbGVtZW50KTtcbiAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgIHRhcmdldC5pbnNlcnRBZnRlcihlbGVtZW50KTtcbiAgICAgICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuXG4gIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIGlzUG9pbnRBdHRhY2hlZChwcmV2U2VsZWN0aW9uLmFuY2hvcikgJiYgaXNQb2ludEF0dGFjaGVkKHByZXZTZWxlY3Rpb24uZm9jdXMpKSB7XG4gICAgbGV4aWNhbC4kc2V0U2VsZWN0aW9uKHByZXZTZWxlY3Rpb24uY2xvbmUoKSk7XG4gIH0gZWxzZSBpZiAobGFzdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICBsYXN0RWxlbWVudC5zZWxlY3RFbmQoKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiAkc2hvdWxkT3ZlcnJpZGVEZWZhdWx0Q2hhcmFjdGVyU2VsZWN0aW9uKHNlbGVjdGlvbiwgaXNCYWNrd2FyZCkge1xuICBjb25zdCBwb3NzaWJsZU5vZGUgPSBsZXhpY2FsLiRnZXRBZGphY2VudE5vZGUoc2VsZWN0aW9uLmZvY3VzLCBpc0JhY2t3YXJkKTtcbiAgcmV0dXJuIGxleGljYWwuJGlzRGVjb3JhdG9yTm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJc29sYXRlZCgpIHx8IGxleGljYWwuJGlzRWxlbWVudE5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSW5saW5lKCkgJiYgIXBvc3NpYmxlTm9kZS5jYW5CZUVtcHR5KCk7XG59XG5mdW5jdGlvbiAkbW92ZUNhcmV0U2VsZWN0aW9uKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGlzQmFja3dhcmQsIGdyYW51bGFyaXR5KSB7XG4gIHNlbGVjdGlvbi5tb2RpZnkoaXNIb2xkaW5nU2hpZnQgPyAnZXh0ZW5kJyA6ICdtb3ZlJywgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHkpO1xufVxuZnVuY3Rpb24gJGlzUGFyZW50RWxlbWVudFJUTChzZWxlY3Rpb24pIHtcbiAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBwYXJlbnQgPSBsZXhpY2FsLiRpc1Jvb3ROb2RlKGFuY2hvck5vZGUpID8gYW5jaG9yTm9kZSA6IGFuY2hvck5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICByZXR1cm4gcGFyZW50LmdldERpcmVjdGlvbigpID09PSAncnRsJztcbn1cbmZ1bmN0aW9uICRtb3ZlQ2hhcmFjdGVyKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGlzQmFja3dhcmQpIHtcbiAgY29uc3QgaXNSVEwgPSAkaXNQYXJlbnRFbGVtZW50UlRMKHNlbGVjdGlvbik7XG4gICRtb3ZlQ2FyZXRTZWxlY3Rpb24oc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCA/ICFpc1JUTCA6IGlzUlRMLCAnY2hhcmFjdGVyJyk7XG59XG5mdW5jdGlvbiAkc2VsZWN0QWxsKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IHRvcFBhcmVudCA9IGFuY2hvck5vZGUuZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdygpO1xuICBjb25zdCByb290ID0gdG9wUGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgbGV0IGZpcnN0Tm9kZSA9IHJvb3QuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gIGxldCBsYXN0Tm9kZSA9IHJvb3QuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgbGV0IGZpcnN0VHlwZSA9ICdlbGVtZW50JztcbiAgbGV0IGxhc3RUeXBlID0gJ2VsZW1lbnQnO1xuICBsZXQgbGFzdE9mZnNldCA9IDA7XG5cbiAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSkge1xuICAgIGZpcnN0VHlwZSA9ICd0ZXh0JztcbiAgfSBlbHNlIGlmICghbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpICYmIGZpcnN0Tm9kZSAhPT0gbnVsbCkge1xuICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cblxuICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShsYXN0Tm9kZSkpIHtcbiAgICBsYXN0VHlwZSA9ICd0ZXh0JztcbiAgICBsYXN0T2Zmc2V0ID0gbGFzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gIH0gZWxzZSBpZiAoIWxleGljYWwuJGlzRWxlbWVudE5vZGUobGFzdE5vZGUpICYmIGxhc3ROb2RlICE9PSBudWxsKSB7XG4gICAgbGFzdE5vZGUgPSBsYXN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cblxuICBpZiAoZmlyc3ROb2RlICYmIGxhc3ROb2RlKSB7XG4gICAgYW5jaG9yLnNldChmaXJzdE5vZGUuZ2V0S2V5KCksIDAsIGZpcnN0VHlwZSk7XG4gICAgZm9jdXMuc2V0KGxhc3ROb2RlLmdldEtleSgpLCBsYXN0T2Zmc2V0LCBsYXN0VHlwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gJGdldE5vZGVTdHlsZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgc3R5bGVQcm9wZXJ0eSwgZGVmYXVsdFZhbHVlKSB7XG4gIGNvbnN0IGNzcyA9IG5vZGUuZ2V0U3R5bGUoKTtcbiAgY29uc3Qgc3R5bGVPYmplY3QgPSBnZXRTdHlsZU9iamVjdEZyb21DU1MoY3NzKTtcblxuICBpZiAoc3R5bGVPYmplY3QgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc3R5bGVPYmplY3Rbc3R5bGVQcm9wZXJ0eV0gfHwgZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gJGdldFNlbGVjdGlvblN0eWxlVmFsdWVGb3JQcm9wZXJ0eShzZWxlY3Rpb24sIHN0eWxlUHJvcGVydHksIGRlZmF1bHRWYWx1ZSA9ICcnKSB7XG4gIGxldCBzdHlsZVZhbHVlID0gbnVsbDtcbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICBjb25zdCBlbmRPZmZzZXQgPSBpc0JhY2t3YXJkID8gZm9jdXMub2Zmc2V0IDogYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgZW5kTm9kZSA9IGlzQmFja3dhcmQgPyBmb2N1cy5nZXROb2RlKCkgOiBhbmNob3IuZ2V0Tm9kZSgpO1xuXG4gIGlmIChzZWxlY3Rpb24uc3R5bGUgIT09ICcnKSB7XG4gICAgY29uc3QgY3NzID0gc2VsZWN0aW9uLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlT2JqZWN0ID0gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKGNzcyk7XG5cbiAgICBpZiAoc3R5bGVPYmplY3QgIT09IG51bGwgJiYgc3R5bGVQcm9wZXJ0eSBpbiBzdHlsZU9iamVjdCkge1xuICAgICAgcmV0dXJuIHN0eWxlT2JqZWN0W3N0eWxlUHJvcGVydHldO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07IC8vIGlmIG5vIGFjdHVhbCBjaGFyYWN0ZXJzIGluIHRoZSBlbmQgbm9kZSBhcmUgc2VsZWN0ZWQsIHdlIGRvbid0XG4gICAgLy8gaW5jbHVkZSBpdCBpbiB0aGUgc2VsZWN0aW9uIGZvciBwdXJwb3NlcyBvZiBkZXRlcm1pbmluZyBzdHlsZVxuICAgIC8vIHZhbHVlXG5cbiAgICBpZiAoaSAhPT0gMCAmJiBlbmRPZmZzZXQgPT09IDAgJiYgbm9kZS5pcyhlbmROb2RlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IG5vZGVTdHlsZVZhbHVlID0gJGdldE5vZGVTdHlsZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgc3R5bGVQcm9wZXJ0eSwgZGVmYXVsdFZhbHVlKTtcblxuICAgICAgaWYgKHN0eWxlVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgc3R5bGVWYWx1ZSA9IG5vZGVTdHlsZVZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZVZhbHVlICE9PSBub2RlU3R5bGVWYWx1ZSkge1xuICAgICAgICAvLyBtdWx0aXBsZSB0ZXh0IG5vZGVzIGFyZSBpbiB0aGUgc2VsZWN0aW9uIGFuZCB0aGV5IGRvbid0IGFsbFxuICAgICAgICAvLyBoYXZlIHRoZSBzYW1lIHN0eWxlLlxuICAgICAgICBzdHlsZVZhbHVlID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZVZhbHVlID09PSBudWxsID8gZGVmYXVsdFZhbHVlIDogc3R5bGVWYWx1ZTtcbn1cblxuZXhwb3J0cy4kYWRkTm9kZVN0eWxlID0gJGFkZE5vZGVTdHlsZTtcbmV4cG9ydHMuJGNsb25lV2l0aFByb3BlcnRpZXMgPSAkY2xvbmVXaXRoUHJvcGVydGllcztcbmV4cG9ydHMuJGdldFNlbGVjdGlvblN0eWxlVmFsdWVGb3JQcm9wZXJ0eSA9ICRnZXRTZWxlY3Rpb25TdHlsZVZhbHVlRm9yUHJvcGVydHk7XG5leHBvcnRzLiRpc0F0Tm9kZUVuZCA9ICRpc0F0Tm9kZUVuZDtcbmV4cG9ydHMuJGlzUGFyZW50RWxlbWVudFJUTCA9ICRpc1BhcmVudEVsZW1lbnRSVEw7XG5leHBvcnRzLiRtb3ZlQ2FyZXRTZWxlY3Rpb24gPSAkbW92ZUNhcmV0U2VsZWN0aW9uO1xuZXhwb3J0cy4kbW92ZUNoYXJhY3RlciA9ICRtb3ZlQ2hhcmFjdGVyO1xuZXhwb3J0cy4kcGF0Y2hTdHlsZVRleHQgPSAkcGF0Y2hTdHlsZVRleHQ7XG5leHBvcnRzLiRzZWxlY3RBbGwgPSAkc2VsZWN0QWxsO1xuZXhwb3J0cy4kc2V0QmxvY2tzVHlwZSA9ICRzZXRCbG9ja3NUeXBlO1xuZXhwb3J0cy4kc2hvdWxkT3ZlcnJpZGVEZWZhdWx0Q2hhcmFjdGVyU2VsZWN0aW9uID0gJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbjtcbmV4cG9ydHMuJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQgPSAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudDtcbmV4cG9ydHMuJHdyYXBOb2RlcyA9ICR3cmFwTm9kZXM7XG5leHBvcnRzLmNyZWF0ZURPTVJhbmdlID0gY3JlYXRlRE9NUmFuZ2U7XG5leHBvcnRzLmNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlID0gY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2U7XG5leHBvcnRzLmdldFN0eWxlT2JqZWN0RnJvbUNTUyA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUztcbmV4cG9ydHMudHJpbVRleHRDb250ZW50RnJvbUFuY2hvciA9IHRyaW1UZXh0Q29udGVudEZyb21BbmNob3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/selection/LexicalSelection.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalSelection =  true ? __webpack_require__(/*! ./LexicalSelection.dev.js */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.dev.js\") : 0\nmodule.exports = LexicalSelection;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWix5QkFBeUIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLGtHQUEyQixJQUFJLENBQXFDO0FBQzlJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uanM/OGU0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbFNlbGVjdGlvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsU2VsZWN0aW9uLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsU2VsZWN0aW9uLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsU2VsZWN0aW9uOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/selection/LexicalSelection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/table/LexicalTable.dev.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lexical/table/LexicalTable.dev.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar utils = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n\n/** @noInheritDoc */\nclass TableCellNode extends lexical.DEPRECATED_GridCellNode {\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'tablecell';\n  }\n\n  static clone(node) {\n    return new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n  }\n\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    return $createTableCellNode(serializedNode.headerState, serializedNode.colSpan, serializedNode.width || undefined);\n  }\n\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(colSpan, key);\n    this.__headerState = headerState;\n    this.__width = width;\n  }\n\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n\n    if (this.__colSpan !== 1) {\n      element.colSpan = this.__colSpan;\n    }\n\n    if (this.__rowSpan !== 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n\n    utils.addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element) {\n      const element_ = element;\n      const maxWidth = 700;\n      const colCount = this.getParentOrThrow().getChildrenSize();\n      element_.style.border = '1px solid black';\n\n      if (this.__colSpan !== 1) {\n        element_.colSpan = this.__colSpan;\n      }\n\n      if (this.__rowSpan !== 1) {\n        element_.rowSpan = this.__rowSpan;\n      }\n\n      element_.style.width = `${this.getWidth() || Math.max(90, maxWidth / colCount)}px`;\n      element_.style.verticalAlign = 'top';\n      element_.style.textAlign = 'start';\n\n      if (this.hasHeader()) {\n        element_.style.backgroundColor = '#f2f3f5';\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      colSpan: super.__colSpan,\n      headerState: this.__headerState,\n      type: 'tablecell',\n      width: this.getWidth()\n    };\n  }\n\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n\n  setHeaderStyles(headerState) {\n    const self = this.getWritable();\n    self.__headerState = headerState;\n    return this.__headerState;\n  }\n\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return this.__width;\n  }\n\n  getWidth() {\n    return this.getLatest().__width;\n  }\n\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n\n    return self;\n  }\n\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan;\n  }\n\n  isShadowRoot() {\n    return true;\n  }\n\n  collapseAtStart() {\n    return true;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n}\nfunction convertTableCellNodeElement(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS);\n  return {\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !lexical.$isElementNode(lexicalNode)) {\n        const paragraphNode = lexical.$createParagraphNode();\n\n        if (lexical.$isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState, colSpan = 1, width) {\n  return lexical.$applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends lexical.DEPRECATED_GridRowNode {\n  /** @internal */\n  static getType() {\n    return 'tablerow';\n  }\n\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    return $createTableRowNode(serializedNode.height);\n  }\n\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'tablerow',\n      version: 1\n    };\n  }\n\n  createDOM(config) {\n    const element = document.createElement('tr');\n\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n\n    utils.addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n\n  isShadowRoot() {\n    return true;\n  }\n\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n\n  getHeight() {\n    return this.getLatest().__height;\n  }\n\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n}\nfunction convertTableRowElement(domNode) {\n  return {\n    node: $createTableRowNode()\n  };\n}\nfunction $createTableRowNode(height) {\n  return lexical.$applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n\nclass TableSelection {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.grid = {\n      cells: [],\n      columns: 0,\n      rows: 0\n    };\n    this.gridSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTableGrid();\n  }\n\n  getGrid() {\n    return this.grid;\n  }\n\n  removeListeners() {\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n  }\n\n  trackTableGrid() {\n    const observer = new MutationObserver(records => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n\n          if (nodeName === 'TABLE' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n\n        if (!gridNeedsRedraw) {\n          return;\n        }\n\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n\n        this.grid = getTableGrid(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      this.grid = getTableGrid(tableElement);\n      observer.observe(tableElement, {\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n\n  clearHighlight() {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.gridSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.enableHighlightStyle();\n    this.editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      const grid = getTableGrid(tableElement);\n      $updateDOMForSelection(grid, null);\n      lexical.$setSelection(null);\n      this.editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n\n  enableHighlightStyle() {\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n\n  disableHighlightStyle() {\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      tableElement.classList.add('disable-selection');\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n\n  updateTableGridSelection(selection) {\n    if (selection != null && selection.gridKey === this.tableNodeKey) {\n      this.gridSelection = selection;\n      this.isHighlightingCells = true;\n      this.disableHighlightStyle();\n      $updateDOMForSelection(this.grid, this.gridSelection);\n    } else if (selection == null) {\n      this.clearHighlight();\n    }\n  }\n\n  setFocusCellForSelection(cell, ignoreStart = false) {\n    this.editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n\n      if (this.anchorCell !== null) {\n        const domSelection = getDOMSelection(this.editor._window); // Collapse the selection\n\n        if (domSelection) {\n          domSelection.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);\n        }\n      }\n\n      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.focusX && cellY === this.focusY) {\n        return;\n      }\n\n      this.focusX = cellX;\n      this.focusY = cellY;\n\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n        if (this.gridSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode)) {\n          const focusNodeKey = focusTableCellNode.getKey();\n          this.gridSelection = this.gridSelection.clone() || lexical.DEPRECATED_$createGridSelection();\n          this.focusCellNodeKey = focusNodeKey;\n          this.gridSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey);\n          lexical.$setSelection(this.gridSelection);\n          this.editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n          $updateDOMForSelection(this.grid, this.gridSelection);\n        }\n      }\n    });\n  }\n\n  setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    this.editor.update(() => {\n      const anchorTableCellNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.gridSelection = lexical.DEPRECATED_$createGridSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n\n  formatCells(type) {\n    this.editor.update(() => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.DEPRECATED_$isGridSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n\n      const formatSelection = lexical.$createRangeSelection();\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n      selection.getNodes().forEach(cellNode => {\n        if ($isTableCellNode(cellNode) && cellNode.getTextContentSize() !== 0) {\n          anchor.set(cellNode.getKey(), 0, 'element');\n          focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n          formatSelection.formatText(type);\n        }\n      });\n      lexical.$setSelection(selection);\n      this.editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n\n  clearText() {\n    this.editor.update(() => {\n      const tableNode = lexical.$getNodeByKey(this.tableNodeKey);\n\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n\n      const selection = lexical.$getSelection();\n\n      if (!lexical.DEPRECATED_$isGridSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n\n      if (selectedNodes.length === this.grid.columns * this.grid.rows) {\n        tableNode.selectPrevious(); // Delete entire table\n\n        tableNode.remove();\n        const rootNode = lexical.$getRoot();\n        rootNode.selectStart();\n        return;\n      }\n\n      selectedNodes.forEach(cellNode => {\n        if (lexical.$isElementNode(cellNode)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          const textNode = lexical.$createTextNode();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach(child => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n      $updateDOMForSelection(this.grid, null);\n      lexical.$setSelection(null);\n      this.editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nfunction applyTableHandlers(tableNode, tableElement, editor) {\n  const rootElement = editor.getRootElement();\n\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n\n  const tableSelection = new TableSelection(editor, tableNode.getKey());\n  attachTableSelectionToTableElement(tableElement, tableSelection);\n  let isMouseDown = false;\n  let isRangeSelectionHijacked = false;\n  tableElement.addEventListener('dblclick', event => {\n    const cell = getCellFromTarget(event.target);\n\n    if (cell !== null) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      event.stopPropagation();\n      tableSelection.setAnchorCellForSelection(cell);\n      tableSelection.setFocusCellForSelection(cell, true);\n      isMouseDown = false;\n    }\n  }); // This is the anchor of the selection.\n\n  tableElement.addEventListener('mousedown', event => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      }\n\n      const cell = getCellFromTarget(event.target);\n\n      if (cell !== null) {\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n        tableSelection.setAnchorCellForSelection(cell);\n      }\n    }, 0);\n  }); // This is adjusting the focus of the selection.\n\n  tableElement.addEventListener('mousemove', event => {\n    if (isRangeSelectionHijacked) {\n      event.preventDefault();\n      event.stopPropagation();\n      event.stopImmediatePropagation();\n    }\n\n    if (isMouseDown) {\n      const cell = getCellFromTarget(event.target);\n\n      if (cell !== null) {\n        const cellX = cell.x;\n        const cellY = cell.y;\n\n        if (isMouseDown && (tableSelection.anchorX !== cellX || tableSelection.anchorY !== cellY || tableSelection.isHighlightingCells)) {\n          event.preventDefault();\n          tableSelection.setFocusCellForSelection(cell);\n        }\n      }\n    }\n  }); // Select entire table at this point, when grid selection is ready.\n\n  tableElement.addEventListener('mouseleave', () => {\n    if (isMouseDown) {\n      return;\n    }\n  }); // Clear selection when clicking outside of dom.\n\n  const mouseDownCallback = event => {\n    isMouseDown = true;\n\n    if (event.button !== 0) {\n      return;\n    }\n\n    editor.update(() => {\n      const selection = lexical.$getSelection();\n\n      if (lexical.DEPRECATED_$isGridSelection(selection) && selection.gridKey === tableSelection.tableNodeKey && rootElement.contains(event.target)) {\n        return tableSelection.clearHighlight();\n      }\n    });\n  };\n\n  window.addEventListener('mousedown', mouseDownCallback);\n  tableSelection.listenersToRemove.add(() => window.removeEventListener('mousedown', mouseDownCallback));\n\n  const mouseUpCallback = event => {\n    if (isMouseDown) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    isMouseDown = false;\n  };\n\n  window.addEventListener('mouseup', mouseUpCallback);\n  tableSelection.listenersToRemove.add(() => window.removeEventListener('mouseup', mouseUpCallback));\n  tableSelection.listenersToRemove.add(() => tableElement.addEventListener('mouseup', mouseUpCallback));\n  tableSelection.listenersToRemove.add(() => tableElement.removeEventListener('mouseup', mouseUpCallback));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    const direction = 'down';\n\n    if (lexical.$isRangeSelection(selection)) {\n      if (selection.isCollapsed()) {\n        const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n        if (!$isTableCellNode(tableCellNode)) {\n          return false;\n        }\n\n        const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n        const elementParentNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isElementNode(n));\n\n        if (elementParentNode == null) {\n          throw new Error('Expected BlockNode Parent');\n        }\n\n        const lastChild = tableCellNode.getLastChild();\n        const isSelectionInLastBlock = lastChild && elementParentNode.isParentOf(lastChild) || elementParentNode === lastChild;\n\n        if (isSelectionInLastBlock || event.shiftKey) {\n          event.preventDefault();\n          event.stopImmediatePropagation();\n          event.stopPropagation(); // Start Selection\n\n          if (event.shiftKey) {\n            tableSelection.setAnchorCellForSelection(tableNode.getCellFromCordsOrThrow(currentCords.x, currentCords.y, tableSelection.grid));\n            return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n          }\n\n          return selectGridNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n        }\n      }\n    } else if (lexical.DEPRECATED_$isGridSelection(selection) && event.shiftKey) {\n      const tableCellNode = selection.focus.getNode();\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      event.stopPropagation();\n      return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    const direction = 'up';\n\n    if (lexical.$isRangeSelection(selection)) {\n      if (selection.isCollapsed()) {\n        const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n        if (!$isTableCellNode(tableCellNode)) {\n          return false;\n        }\n\n        const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n        const elementParentNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isElementNode(n));\n\n        if (elementParentNode == null) {\n          throw new Error('Expected BlockNode Parent');\n        }\n\n        const lastChild = tableCellNode.getLastChild();\n        const isSelectionInLastBlock = lastChild && elementParentNode.isParentOf(lastChild) || elementParentNode === lastChild;\n\n        if (isSelectionInLastBlock || event.shiftKey) {\n          event.preventDefault();\n          event.stopImmediatePropagation();\n          event.stopPropagation(); // Start Selection\n\n          if (event.shiftKey) {\n            tableSelection.setAnchorCellForSelection(tableNode.getCellFromCordsOrThrow(currentCords.x, currentCords.y, tableSelection.grid));\n            return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n          }\n\n          return selectGridNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n        }\n      }\n    } else if (lexical.DEPRECATED_$isGridSelection(selection) && event.shiftKey) {\n      const tableCellNode = selection.focus.getNode();\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      event.stopPropagation();\n      return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    const direction = 'backward';\n\n    if (lexical.$isRangeSelection(selection)) {\n      if (selection.isCollapsed()) {\n        const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n        if (!$isTableCellNode(tableCellNode)) {\n          return false;\n        }\n\n        const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n        const elementParentNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isElementNode(n));\n\n        if (elementParentNode == null) {\n          throw new Error('Expected BlockNode Parent');\n        }\n\n        if (selection.anchor.offset === 0 || event.shiftKey) {\n          event.preventDefault();\n          event.stopImmediatePropagation();\n          event.stopPropagation(); // Start Selection\n\n          if (event.shiftKey) {\n            tableSelection.setAnchorCellForSelection(tableNode.getCellFromCordsOrThrow(currentCords.x, currentCords.y, tableSelection.grid));\n            return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n          }\n\n          return selectGridNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n        }\n      }\n    } else if (lexical.DEPRECATED_$isGridSelection(selection) && event.shiftKey) {\n      const tableCellNode = selection.focus.getNode();\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      event.stopPropagation();\n      return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    const direction = 'forward';\n\n    if (lexical.$isRangeSelection(selection)) {\n      if (selection.isCollapsed()) {\n        const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n        if (!$isTableCellNode(tableCellNode)) {\n          return false;\n        }\n\n        const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n        const elementParentNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isElementNode(n));\n\n        if (elementParentNode == null) {\n          throw new Error('Expected BlockNode Parent');\n        }\n\n        if (selection.anchor.offset === selection.anchor.getNode().getTextContentSize() || event.shiftKey) {\n          event.preventDefault();\n          event.stopImmediatePropagation();\n          event.stopPropagation(); // Start Selection\n\n          if (event.shiftKey) {\n            tableSelection.setAnchorCellForSelection(tableNode.getCellFromCordsOrThrow(currentCords.x, currentCords.y, tableSelection.grid));\n            return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n          }\n\n          return selectGridNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n        }\n      }\n    } else if (lexical.DEPRECATED_$isGridSelection(selection) && event.shiftKey) {\n      const tableCellNode = selection.focus.getNode();\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      event.stopPropagation();\n      return adjustFocusNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, direction);\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_HIGH));\n\n  const deleteTextHandler = command => () => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.clearText();\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n\n      if (selectionContainsPartialTable) {\n        tableSelection.clearText();\n        return true;\n      }\n\n      const nearestElementNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.$isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && utils.$findMatchingParent(nearestElementNode, n => lexical.$isElementNode(n) && $isTableCellNode(n.getParent()));\n\n      if (!lexical.$isElementNode(topLevelCellElementNode) || !lexical.$isElementNode(nearestElementNode)) {\n        return false;\n      }\n\n      if (command === lexical.DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n\n      if (command === lexical.DELETE_CHARACTER_COMMAND || command === lexical.DELETE_WORD_COMMAND) {\n        if (selection.isCollapsed() && selection.anchor.offset === 0) {\n          if (nearestElementNode !== topLevelCellElementNode) {\n            const children = nearestElementNode.getChildren();\n            const newParagraphNode = lexical.$createParagraphNode();\n            children.forEach(child => newParagraphNode.append(child));\n            nearestElementNode.replace(newParagraphNode);\n            nearestElementNode.getWritable().__parent = tableCellNode.getKey();\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  [lexical.DELETE_WORD_COMMAND, lexical.DELETE_LINE_COMMAND, lexical.DELETE_CHARACTER_COMMAND].forEach(command => {\n    tableSelection.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), lexical.COMMAND_PRIORITY_CRITICAL));\n  });\n\n  const deleteCellHandler = event => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      event.preventDefault();\n      event.stopPropagation();\n      tableSelection.clearText();\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  };\n\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, deleteCellHandler, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_DELETE_COMMAND, deleteCellHandler, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.formatCells(payload);\n      return true;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.DEPRECATED_$isGridSelection(selection)) {\n      tableSelection.clearHighlight();\n      return false;\n    } else if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n\n    if (lexical.$isRangeSelection(selection)) {\n      const tableCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n\n      if (selection.isCollapsed()) {\n        const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableSelection.grid);\n        event.preventDefault();\n        selectGridNodeInDirection(tableSelection, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, lexical.COMMAND_PRIORITY_HIGH));\n  tableSelection.listenersToRemove.add(editor.registerCommand(lexical.SELECTION_CHANGE_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n    const prevSelection = lexical.$getPreviousSelection();\n\n    if (selection && lexical.$isRangeSelection(selection) && !selection.isCollapsed()) {\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      const selectionIsInsideTable = isAnchorInside && isFocusInside && !tableNode.isSelected();\n\n      if (selectionContainsPartialTable) {\n        const isBackward = selection.isBackward();\n        const modifiedSelection = lexical.$createRangeSelection();\n        const tableKey = tableNode.getKey();\n        modifiedSelection.anchor.set(selection.anchor.key, selection.anchor.offset, selection.anchor.type);\n        modifiedSelection.focus.set(tableKey, isBackward ? 0 : tableNode.getChildrenSize(), 'element');\n        isRangeSelectionHijacked = true;\n        lexical.$setSelection(modifiedSelection);\n        $addHighlightStyleToTable(tableSelection);\n        return true;\n      } else if (selectionIsInsideTable) {\n        const {\n          grid\n        } = tableSelection;\n\n        if (selection.getNodes().filter($isTableCellNode).length === grid.rows * grid.columns) {\n          const gridSelection = lexical.DEPRECATED_$createGridSelection();\n          const tableKey = tableNode.getKey();\n          const firstCell = tableNode.getFirstChildOrThrow().getFirstChild();\n          const lastCell = tableNode.getLastChildOrThrow().getLastChild();\n\n          if (firstCell != null && lastCell != null) {\n            gridSelection.set(tableKey, firstCell.getKey(), lastCell.getKey());\n            lexical.$setSelection(gridSelection);\n            tableSelection.updateTableGridSelection(gridSelection);\n            return true;\n          }\n        }\n      }\n    }\n\n    if (selection && !selection.is(prevSelection) && (lexical.DEPRECATED_$isGridSelection(selection) || lexical.DEPRECATED_$isGridSelection(prevSelection)) && tableSelection.gridSelection && !tableSelection.gridSelection.is(prevSelection)) {\n      if (lexical.DEPRECATED_$isGridSelection(selection) && selection.gridKey === tableSelection.tableNodeKey) {\n        tableSelection.updateTableGridSelection(selection);\n      } else if (!lexical.DEPRECATED_$isGridSelection(selection) && lexical.DEPRECATED_$isGridSelection(prevSelection) && prevSelection.gridKey === tableSelection.tableNodeKey) {\n        tableSelection.updateTableGridSelection(null);\n      }\n\n      return false;\n    }\n\n    if (tableSelection.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(tableSelection);\n      isRangeSelectionHijacked = false;\n    } else if (!tableSelection.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(tableSelection);\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_CRITICAL));\n  return tableSelection;\n}\nfunction attachTableSelectionToTableElement(tableElement, tableSelection) {\n  tableElement[LEXICAL_ELEMENT_KEY] = tableSelection;\n}\nfunction getTableSelectionFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY];\n}\nfunction getCellFromTarget(node) {\n  let currentNode = node;\n\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n\n      if (cell === undefined) {\n        return null;\n      }\n\n      return cell;\n    }\n\n    currentNode = currentNode.parentNode;\n  }\n\n  return null;\n}\nfunction getTableGrid(tableElement) {\n  const cells = [];\n  const grid = {\n    cells,\n    columns: 0,\n    rows: 0\n  };\n  let currentNode = tableElement.firstChild;\n  let x = 0;\n  let y = 0;\n  cells.length = 0;\n\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        highlighted: false,\n        x,\n        y\n      }; // @ts-expect-error: internal field\n\n      currentNode._cell = cell;\n\n      if (cells[y] === undefined) {\n        cells[y] = [];\n      }\n\n      cells[y][x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n\n    const sibling = currentNode.nextSibling;\n\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n\n    const parent = currentNode.parentNode;\n\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n\n      if (parentSibling == null) {\n        break;\n      }\n\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(grid, selection) {\n  const highlightedCells = [];\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachGridCell(grid, (cell, lexicalNode) => {\n    const elem = cell.elem;\n\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      elem.style.setProperty('background-color', 'rgb(172, 206, 247)');\n      elem.style.setProperty('caret-color', 'transparent');\n      highlightedCells.push(cell);\n    } else {\n      cell.highlighted = false;\n      elem.style.removeProperty('background-color');\n      elem.style.removeProperty('caret-color');\n\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n  return highlightedCells;\n}\nfunction $forEachGridCell(grid, cb) {\n  const {\n    cells\n  } = grid;\n\n  for (let y = 0; y < cells.length; y++) {\n    const row = cells[y];\n\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      const lexicalNode = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(tableSelection) {\n  tableSelection.disableHighlightStyle();\n  $forEachGridCell(tableSelection.grid, cell => {\n    const elem = cell.elem;\n    cell.highlighted = true;\n    elem.style.setProperty('background-color', 'rgb(172, 206, 247)');\n    elem.style.setProperty('caret-color', 'transparent');\n  });\n}\nfunction $removeHighlightStyleToTable(tableSelection) {\n  tableSelection.enableHighlightStyle();\n  $forEachGridCell(tableSelection.grid, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    elem.style.removeProperty('background-color');\n    elem.style.removeProperty('caret-color');\n\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\n\nconst selectGridNodeInDirection = (tableSelection, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableSelection.grid.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableSelection.grid));\n      } else {\n        if (y !== (isForward ? tableSelection.grid.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableSelection.grid.columns - 1, y + (isForward ? 1 : -1), tableSelection.grid));\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n\n      return true;\n\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableSelection.grid));\n      } else {\n        tableNode.selectPrevious();\n      }\n\n      return true;\n\n    case 'down':\n      if (y !== tableSelection.grid.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableSelection.grid));\n      } else {\n        tableNode.selectNext();\n      }\n\n      return true;\n\n    default:\n      return false;\n  }\n};\n\nconst adjustFocusNodeInDirection = (tableSelection, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableSelection.grid.columns - 1 : 0)) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableSelection.grid));\n      }\n\n      return true;\n\n    case 'up':\n      if (y !== 0) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x, y - 1, tableSelection.grid));\n        return true;\n      } else {\n        return false;\n      }\n\n    case 'down':\n      if (y !== tableSelection.grid.rows - 1) {\n        tableSelection.setFocusCellForSelection(tableNode.getCellFromCordsOrThrow(x, y + 1, tableSelection.grid));\n        return true;\n      } else {\n        return false;\n      }\n\n    default:\n      return false;\n  }\n};\n\nfunction $isSelectionInTable(selection, tableNode) {\n  if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n\n  return false;\n}\n\nfunction selectTableCellNode(tableCell) {\n  const possibleParagraph = tableCell.getChildren().find(n => lexical.$isParagraphNode(n));\n\n  if (lexical.$isParagraphNode(possibleParagraph)) {\n    possibleParagraph.selectEnd();\n  } else {\n    tableCell.selectEnd();\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableNode extends lexical.DEPRECATED_GridNode {\n  /** @internal */\n  static getType() {\n    return 'table';\n  }\n\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: convertTableElement,\n        priority: 1\n      })\n    };\n  }\n\n  static importJSON(_serializedNode) {\n    return $createTableNode();\n  }\n\n  constructor(key) {\n    super(key);\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'table',\n      version: 1\n    };\n  }\n\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    utils.addClassNamesToElement(tableElement, config.theme.table);\n    return tableElement;\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  exportDOM(editor) {\n    return { ...super.exportDOM(editor),\n      after: tableElement => {\n        if (tableElement) {\n          const newElement = tableElement.cloneNode();\n          const colGroup = document.createElement('colgroup');\n          const tBody = document.createElement('tbody');\n          tBody.append(...tableElement.children);\n          const firstRow = this.getFirstChildOrThrow();\n\n          if (!$isTableRowNode(firstRow)) {\n            throw new Error('Expected to find row node.');\n          }\n\n          const colCount = firstRow.getChildrenSize();\n\n          for (let i = 0; i < colCount; i++) {\n            const col = document.createElement('col');\n            colGroup.append(col);\n          }\n\n          newElement.replaceChildren(colGroup, tBody);\n          return newElement;\n        }\n      }\n    };\n  }\n\n  canExtractContents() {\n    return false;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  isShadowRoot() {\n    return true;\n  }\n\n  getCordsFromCellNode(tableCellNode, grid) {\n    const {\n      rows,\n      cells\n    } = grid;\n\n    for (let y = 0; y < rows; y++) {\n      const row = cells[y];\n\n      if (row == null) {\n        throw new Error(`Row not found at y:${y}`);\n      }\n\n      const x = row.findIndex(({\n        elem\n      }) => {\n        const cellNode = lexical.$getNearestNodeFromDOMNode(elem);\n        return cellNode === tableCellNode;\n      });\n\n      if (x !== -1) {\n        return {\n          x,\n          y\n        };\n      }\n    }\n\n    throw new Error('Cell not found in table.');\n  }\n\n  getCellFromCords(x, y, grid) {\n    const {\n      cells\n    } = grid;\n    const row = cells[y];\n\n    if (row == null) {\n      return null;\n    }\n\n    const cell = row[x];\n\n    if (cell == null) {\n      return null;\n    }\n\n    return cell;\n  }\n\n  getCellFromCordsOrThrow(x, y, grid) {\n    const cell = this.getCellFromCords(x, y, grid);\n\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n\n    return cell;\n  }\n\n  getCellNodeFromCords(x, y, grid) {\n    const cell = this.getCellFromCords(x, y, grid);\n\n    if (cell == null) {\n      return null;\n    }\n\n    const node = lexical.$getNearestNodeFromDOMNode(cell.elem);\n\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n\n    return null;\n  }\n\n  getCellNodeFromCordsOrThrow(x, y, grid) {\n    const node = this.getCellNodeFromCords(x, y, grid);\n\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n\n    return node;\n  }\n\n  canSelectBefore() {\n    return true;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n}\nfunction $getElementGridForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n\n  return getTableGrid(tableElement);\n}\nfunction convertTableElement(_domNode) {\n  return {\n    node: $createTableNode()\n  };\n}\nfunction $createTableNode() {\n  return lexical.$applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) headerState |= TableCellHeaderStates.ROW;\n        if (iColumn === 0 && includeHeaders.columns) headerState |= TableCellHeaderStates.COLUMN;\n      } else if (includeHeaders) {\n        if (iRow === 0) headerState |= TableCellHeaderStates.ROW;\n        if (iColumn === 0) headerState |= TableCellHeaderStates.COLUMN;\n      }\n\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = lexical.$createParagraphNode();\n      paragraphNode.append(lexical.$createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n\n    tableNode.append(tableRowNode);\n  }\n\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableCellNode(n));\n\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableRowNode(n));\n\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = utils.$findMatchingParent(startingNode, n => $isTableNode(n));\n\n  if ($isTableNode(node)) {\n    return node;\n  }\n\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, grid) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, grid);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, grid),\n    below: tableNode.getCellNodeFromCords(x, y + 1, grid),\n    left: tableNode.getCellNodeFromCords(x - 1, y, grid),\n    right: tableNode.getCellNodeFromCords(x + 1, y, grid)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, grid) {\n  const tableRows = tableNode.getChildren();\n\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n\n  const targetRowNode = tableRows[targetIndex];\n\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, grid);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append(lexical.$createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n\n  return tableNode;\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, grid) {\n  const tableRows = tableNode.getChildren();\n\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n\n        const targetCell = tableRowChildren[targetIndex];\n\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, grid);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append(lexical.$createParagraphNode());\n\n        if (shouldInsertAfter) {\n          targetCell.insertAfter(newTableCell);\n        } else {\n          targetCell.insertBefore(newTableCell);\n        }\n      }\n    }\n  }\n\n  return tableNode;\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n\n  return tableNode;\n}\n\n/** @module @lexical/table */\nconst INSERT_TABLE_COMMAND = lexical.createCommand('INSERT_TABLE_COMMAND');\n\nexports.$createTableCellNode = $createTableCellNode;\nexports.$createTableNode = $createTableNode;\nexports.$createTableNodeWithDimensions = $createTableNodeWithDimensions;\nexports.$createTableRowNode = $createTableRowNode;\nexports.$deleteTableColumn = $deleteTableColumn;\nexports.$getElementGridForTableNode = $getElementGridForTableNode;\nexports.$getTableCellNodeFromLexicalNode = $getTableCellNodeFromLexicalNode;\nexports.$getTableColumnIndexFromTableCellNode = $getTableColumnIndexFromTableCellNode;\nexports.$getTableNodeFromLexicalNodeOrThrow = $getTableNodeFromLexicalNodeOrThrow;\nexports.$getTableRowIndexFromTableCellNode = $getTableRowIndexFromTableCellNode;\nexports.$getTableRowNodeFromTableCellNodeOrThrow = $getTableRowNodeFromTableCellNodeOrThrow;\nexports.$insertTableColumn = $insertTableColumn;\nexports.$insertTableRow = $insertTableRow;\nexports.$isTableCellNode = $isTableCellNode;\nexports.$isTableNode = $isTableNode;\nexports.$isTableRowNode = $isTableRowNode;\nexports.$removeTableRowAtIndex = $removeTableRowAtIndex;\nexports.INSERT_TABLE_COMMAND = INSERT_TABLE_COMMAND;\nexports.TableCellHeaderStates = TableCellHeaderStates;\nexports.TableCellNode = TableCellNode;\nexports.TableNode = TableNode;\nexports.TableRowNode = TableRowNode;\nexports.TableSelection = TableSelection;\nexports.applyTableHandlers = applyTableHandlers;\nexports.getCellFromTarget = getCellFromTarget;\nexports.getTableSelectionFromTableElement = getTableSelectionFromTableElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGFibGUvTGV4aWNhbFRhYmxlLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsd0RBQVM7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLDJFQUFnQjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsYUFBYTtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MscURBQXFEO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sb0JBQW9CLFVBQVU7QUFDOUI7O0FBRUE7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsaUJBQWlCO0FBQ3RDOztBQUVBLDBCQUEwQix1QkFBdUI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHNCQUFzQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsd0JBQXdCO0FBQ3hCLHNDQUFzQztBQUN0QywyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLG1DQUFtQztBQUNuQyx3Q0FBd0M7QUFDeEMsNkNBQTZDO0FBQzdDLDJDQUEyQztBQUMzQywwQ0FBMEM7QUFDMUMsZ0RBQWdEO0FBQ2hELDBCQUEwQjtBQUMxQix1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0IscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGFibGUvTGV4aWNhbFRhYmxlLmRldi5qcz8yZGU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGV4aWNhbCA9IHJlcXVpcmUoJ2xleGljYWwnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJ0BsZXhpY2FsL3V0aWxzJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IFRhYmxlQ2VsbEhlYWRlclN0YXRlcyA9IHtcbiAgQk9USDogMyxcbiAgQ09MVU1OOiAyLFxuICBOT19TVEFUVVM6IDAsXG4gIFJPVzogMVxufTtcblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFRhYmxlQ2VsbE5vZGUgZXh0ZW5kcyBsZXhpY2FsLkRFUFJFQ0FURURfR3JpZENlbGxOb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWJsZWNlbGwnO1xuICB9XG5cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFRhYmxlQ2VsbE5vZGUobm9kZS5fX2hlYWRlclN0YXRlLCBub2RlLl9fY29sU3Bhbiwgbm9kZS5fX3dpZHRoLCBub2RlLl9fa2V5KTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRkOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUYWJsZUNlbGxOb2RlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgdGg6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRhYmxlQ2VsbE5vZGVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoc2VyaWFsaXplZE5vZGUuaGVhZGVyU3RhdGUsIHNlcmlhbGl6ZWROb2RlLmNvbFNwYW4sIHNlcmlhbGl6ZWROb2RlLndpZHRoIHx8IHVuZGVmaW5lZCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVMsIGNvbFNwYW4gPSAxLCB3aWR0aCwga2V5KSB7XG4gICAgc3VwZXIoY29sU3Bhbiwga2V5KTtcbiAgICB0aGlzLl9faGVhZGVyU3RhdGUgPSBoZWFkZXJTdGF0ZTtcbiAgICB0aGlzLl9fd2lkdGggPSB3aWR0aDtcbiAgfVxuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmdldFRhZygpKTtcblxuICAgIGlmICh0aGlzLl9fd2lkdGgpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9fd2lkdGh9cHhgO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9fY29sU3BhbiAhPT0gMSkge1xuICAgICAgZWxlbWVudC5jb2xTcGFuID0gdGhpcy5fX2NvbFNwYW47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX19yb3dTcGFuICE9PSAxKSB7XG4gICAgICBlbGVtZW50LnJvd1NwYW4gPSB0aGlzLl9fcm93U3BhbjtcbiAgICB9XG5cbiAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS50YWJsZUNlbGwsIHRoaXMuaGFzSGVhZGVyKCkgJiYgY29uZmlnLnRoZW1lLnRhYmxlQ2VsbEhlYWRlcik7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBjb25zdCBlbGVtZW50XyA9IGVsZW1lbnQ7XG4gICAgICBjb25zdCBtYXhXaWR0aCA9IDcwMDtcbiAgICAgIGNvbnN0IGNvbENvdW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgICBlbGVtZW50Xy5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIGJsYWNrJztcblxuICAgICAgaWYgKHRoaXMuX19jb2xTcGFuICE9PSAxKSB7XG4gICAgICAgIGVsZW1lbnRfLmNvbFNwYW4gPSB0aGlzLl9fY29sU3BhbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX19yb3dTcGFuICE9PSAxKSB7XG4gICAgICAgIGVsZW1lbnRfLnJvd1NwYW4gPSB0aGlzLl9fcm93U3BhbjtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudF8uc3R5bGUud2lkdGggPSBgJHt0aGlzLmdldFdpZHRoKCkgfHwgTWF0aC5tYXgoOTAsIG1heFdpZHRoIC8gY29sQ291bnQpfXB4YDtcbiAgICAgIGVsZW1lbnRfLnN0eWxlLnZlcnRpY2FsQWxpZ24gPSAndG9wJztcbiAgICAgIGVsZW1lbnRfLnN0eWxlLnRleHRBbGlnbiA9ICdzdGFydCc7XG5cbiAgICAgIGlmICh0aGlzLmhhc0hlYWRlcigpKSB7XG4gICAgICAgIGVsZW1lbnRfLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjZjJmM2Y1JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cblxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7IC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGNvbFNwYW46IHN1cGVyLl9fY29sU3BhbixcbiAgICAgIGhlYWRlclN0YXRlOiB0aGlzLl9faGVhZGVyU3RhdGUsXG4gICAgICB0eXBlOiAndGFibGVjZWxsJyxcbiAgICAgIHdpZHRoOiB0aGlzLmdldFdpZHRoKClcbiAgICB9O1xuICB9XG5cbiAgZ2V0VGFnKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0hlYWRlcigpID8gJ3RoJyA6ICd0ZCc7XG4gIH1cblxuICBzZXRIZWFkZXJTdHlsZXMoaGVhZGVyU3RhdGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19oZWFkZXJTdGF0ZSA9IGhlYWRlclN0YXRlO1xuICAgIHJldHVybiB0aGlzLl9faGVhZGVyU3RhdGU7XG4gIH1cblxuICBnZXRIZWFkZXJTdHlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19oZWFkZXJTdGF0ZTtcbiAgfVxuXG4gIHNldFdpZHRoKHdpZHRoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fd2lkdGggPSB3aWR0aDtcbiAgICByZXR1cm4gdGhpcy5fX3dpZHRoO1xuICB9XG5cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX193aWR0aDtcbiAgfVxuXG4gIHRvZ2dsZUhlYWRlclN0eWxlKGhlYWRlclN0YXRlVG9Ub2dnbGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuXG4gICAgaWYgKChzZWxmLl9faGVhZGVyU3RhdGUgJiBoZWFkZXJTdGF0ZVRvVG9nZ2xlKSA9PT0gaGVhZGVyU3RhdGVUb1RvZ2dsZSkge1xuICAgICAgc2VsZi5fX2hlYWRlclN0YXRlIC09IGhlYWRlclN0YXRlVG9Ub2dnbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuX19oZWFkZXJTdGF0ZSArPSBoZWFkZXJTdGF0ZVRvVG9nZ2xlO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgaGFzSGVhZGVyU3RhdGUoaGVhZGVyU3RhdGUpIHtcbiAgICByZXR1cm4gKHRoaXMuZ2V0SGVhZGVyU3R5bGVzKCkgJiBoZWFkZXJTdGF0ZSkgPT09IGhlYWRlclN0YXRlO1xuICB9XG5cbiAgaGFzSGVhZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faGVhZGVyU3RhdGUgIT09IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gIH1cblxuICB1cGRhdGVET00ocHJldk5vZGUpIHtcbiAgICByZXR1cm4gcHJldk5vZGUuX19oZWFkZXJTdGF0ZSAhPT0gdGhpcy5fX2hlYWRlclN0YXRlIHx8IHByZXZOb2RlLl9fd2lkdGggIT09IHRoaXMuX193aWR0aCB8fCBwcmV2Tm9kZS5fX2NvbFNwYW4gIT09IHRoaXMuX19jb2xTcGFuIHx8IHByZXZOb2RlLl9fcm93U3BhbiAhPT0gdGhpcy5fX3Jvd1NwYW47XG4gIH1cblxuICBpc1NoYWRvd1Jvb3QoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb2xsYXBzZUF0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNhbkluZGVudCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxufVxuZnVuY3Rpb24gY29udmVydFRhYmxlQ2VsbE5vZGVFbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3Qgbm9kZU5hbWUgPSBkb21Ob2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSAkY3JlYXRlVGFibGVDZWxsTm9kZShub2RlTmFtZSA9PT0gJ3RoJyA/IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1cgOiBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTKTtcbiAgcmV0dXJuIHtcbiAgICBmb3JDaGlsZDogKGxleGljYWxOb2RlLCBwYXJlbnRMZXhpY2FsTm9kZSkgPT4ge1xuICAgICAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUocGFyZW50TGV4aWNhbE5vZGUpICYmICFsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGxleGljYWxOb2RlKSkge1xuICAgICAgICBjb25zdCBwYXJhZ3JhcGhOb2RlID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuXG4gICAgICAgIGlmIChsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUobGV4aWNhbE5vZGUpICYmIGxleGljYWxOb2RlLmdldFRleHRDb250ZW50KCkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZChsZXhpY2FsTm9kZSk7XG4gICAgICAgIHJldHVybiBwYXJhZ3JhcGhOb2RlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGV4aWNhbE5vZGU7XG4gICAgfSxcbiAgICBub2RlOiB0YWJsZUNlbGxOb2RlXG4gIH07XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSwgY29sU3BhbiA9IDEsIHdpZHRoKSB7XG4gIHJldHVybiBsZXhpY2FsLiRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSwgY29sU3Bhbiwgd2lkdGgpKTtcbn1cbmZ1bmN0aW9uICRpc1RhYmxlQ2VsbE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRhYmxlQ2VsbE5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFRhYmxlUm93Tm9kZSBleHRlbmRzIGxleGljYWwuREVQUkVDQVRFRF9HcmlkUm93Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWJsZXJvdyc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgVGFibGVSb3dOb2RlKG5vZGUuX19oZWlnaHQsIG5vZGUuX19rZXkpO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHI6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRhYmxlUm93RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVUYWJsZVJvd05vZGUoc2VyaWFsaXplZE5vZGUuaGVpZ2h0KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGhlaWdodCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9faGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4geyAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICB0eXBlOiAndGFibGVyb3cnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cblxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG5cbiAgICBpZiAodGhpcy5fX2hlaWdodCkge1xuICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLl9faGVpZ2h0fXB4YDtcbiAgICB9XG5cbiAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS50YWJsZVJvdyk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBpc1NoYWRvd1Jvb3QoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiB0aGlzLl9faGVpZ2h0O1xuICB9XG5cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faGVpZ2h0O1xuICB9XG5cbiAgdXBkYXRlRE9NKHByZXZOb2RlKSB7XG4gICAgcmV0dXJuIHByZXZOb2RlLl9faGVpZ2h0ICE9PSB0aGlzLl9faGVpZ2h0O1xuICB9XG5cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn1cbmZ1bmN0aW9uIGNvbnZlcnRUYWJsZVJvd0VsZW1lbnQoZG9tTm9kZSkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVUYWJsZVJvd05vZGUoKVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlUm93Tm9kZShoZWlnaHQpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUYWJsZVJvd05vZGUoaGVpZ2h0KSk7XG59XG5mdW5jdGlvbiAkaXNUYWJsZVJvd05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRhYmxlUm93Tm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IGdldERPTVNlbGVjdGlvbiA9IHRhcmdldFdpbmRvdyA9PiBDQU5fVVNFX0RPTSA/ICh0YXJnZXRXaW5kb3cgfHwgd2luZG93KS5nZXRTZWxlY3Rpb24oKSA6IG51bGw7XG5cbmNsYXNzIFRhYmxlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IoZWRpdG9yLCB0YWJsZU5vZGVLZXkpIHtcbiAgICB0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgPSBmYWxzZTtcbiAgICB0aGlzLmFuY2hvclggPSAtMTtcbiAgICB0aGlzLmFuY2hvclkgPSAtMTtcbiAgICB0aGlzLmZvY3VzWCA9IC0xO1xuICAgIHRoaXMuZm9jdXNZID0gLTE7XG4gICAgdGhpcy5saXN0ZW5lcnNUb1JlbW92ZSA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnRhYmxlTm9kZUtleSA9IHRhYmxlTm9kZUtleTtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLmdyaWQgPSB7XG4gICAgICBjZWxsczogW10sXG4gICAgICBjb2x1bW5zOiAwLFxuICAgICAgcm93czogMFxuICAgIH07XG4gICAgdGhpcy5ncmlkU2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmZvY3VzQ2VsbE5vZGVLZXkgPSBudWxsO1xuICAgIHRoaXMuYW5jaG9yQ2VsbCA9IG51bGw7XG4gICAgdGhpcy5mb2N1c0NlbGwgPSBudWxsO1xuICAgIHRoaXMuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgPSBmYWxzZTtcbiAgICB0aGlzLnRyYWNrVGFibGVHcmlkKCk7XG4gIH1cblxuICBnZXRHcmlkKCkge1xuICAgIHJldHVybiB0aGlzLmdyaWQ7XG4gIH1cblxuICByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgQXJyYXkuZnJvbSh0aGlzLmxpc3RlbmVyc1RvUmVtb3ZlKS5mb3JFYWNoKHJlbW92ZUxpc3RlbmVyID0+IHJlbW92ZUxpc3RlbmVyKCkpO1xuICB9XG5cbiAgdHJhY2tUYWJsZUdyaWQoKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihyZWNvcmRzID0+IHtcbiAgICAgIHRoaXMuZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGxldCBncmlkTmVlZHNSZWRyYXcgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHJlY29yZC50YXJnZXQ7XG4gICAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWU7XG5cbiAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdUQUJMRScgfHwgbm9kZU5hbWUgPT09ICdUUicpIHtcbiAgICAgICAgICAgIGdyaWROZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWdyaWROZWVkc1JlZHJhdykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IHRoaXMuZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG5cbiAgICAgICAgaWYgKCF0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgVGFibGVFbGVtZW50IGluIERPTScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ncmlkID0gZ2V0VGFibGVHcmlkKHRhYmxlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgdGFibGVFbGVtZW50ID0gdGhpcy5lZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcblxuICAgICAgaWYgKCF0YWJsZUVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ncmlkID0gZ2V0VGFibGVHcmlkKHRhYmxlRWxlbWVudCk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKHRhYmxlRWxlbWVudCwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY2xlYXJIaWdobGlnaHQoKSB7XG4gICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gZmFsc2U7XG4gICAgdGhpcy5hbmNob3JYID0gLTE7XG4gICAgdGhpcy5hbmNob3JZID0gLTE7XG4gICAgdGhpcy5mb2N1c1ggPSAtMTtcbiAgICB0aGlzLmZvY3VzWSA9IC0xO1xuICAgIHRoaXMuZ3JpZFNlbGVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5hbmNob3JDZWxsTm9kZUtleSA9IG51bGw7XG4gICAgdGhpcy5mb2N1c0NlbGxOb2RlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvckNlbGwgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNDZWxsID0gbnVsbDtcbiAgICB0aGlzLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzID0gZmFsc2U7XG4gICAgdGhpcy5lbmFibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgIHRoaXMuZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZU5vZGUgPSBsZXhpY2FsLiRnZXROb2RlQnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuXG4gICAgICBpZiAoISRpc1RhYmxlTm9kZSh0YWJsZU5vZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVGFibGVOb2RlLicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSB0aGlzLmVkaXRvci5nZXRFbGVtZW50QnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuXG4gICAgICBpZiAoIXRhYmxlRWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgVGFibGVFbGVtZW50IGluIERPTScpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBncmlkID0gZ2V0VGFibGVHcmlkKHRhYmxlRWxlbWVudCk7XG4gICAgICAkdXBkYXRlRE9NRm9yU2VsZWN0aW9uKGdyaWQsIG51bGwpO1xuICAgICAgbGV4aWNhbC4kc2V0U2VsZWN0aW9uKG51bGwpO1xuICAgICAgdGhpcy5lZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9XG5cbiAgZW5hYmxlSGlnaGxpZ2h0U3R5bGUoKSB7XG4gICAgdGhpcy5lZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IHRoaXMuZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG5cbiAgICAgIGlmICghdGFibGVFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBUYWJsZUVsZW1lbnQgaW4gRE9NJyk7XG4gICAgICB9XG5cbiAgICAgIHRhYmxlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkaXNhYmxlLXNlbGVjdGlvbicpO1xuICAgICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzYWJsZUhpZ2hsaWdodFN0eWxlKCkge1xuICAgIHRoaXMuZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSB0aGlzLmVkaXRvci5nZXRFbGVtZW50QnlLZXkodGhpcy50YWJsZU5vZGVLZXkpO1xuXG4gICAgICBpZiAoIXRhYmxlRWxlbWVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgVGFibGVFbGVtZW50IGluIERPTScpO1xuICAgICAgfVxuXG4gICAgICB0YWJsZUVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZGlzYWJsZS1zZWxlY3Rpb24nKTtcbiAgICAgIHRoaXMuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgPSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlVGFibGVHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgIGlmIChzZWxlY3Rpb24gIT0gbnVsbCAmJiBzZWxlY3Rpb24uZ3JpZEtleSA9PT0gdGhpcy50YWJsZU5vZGVLZXkpIHtcbiAgICAgIHRoaXMuZ3JpZFNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IHRydWU7XG4gICAgICB0aGlzLmRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbih0aGlzLmdyaWQsIHRoaXMuZ3JpZFNlbGVjdGlvbik7XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgdGhpcy5jbGVhckhpZ2hsaWdodCgpO1xuICAgIH1cbiAgfVxuXG4gIHNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihjZWxsLCBpZ25vcmVTdGFydCA9IGZhbHNlKSB7XG4gICAgdGhpcy5lZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYmxlTm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG5cbiAgICAgIGlmICghJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBUYWJsZU5vZGUuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IHRoaXMuZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG5cbiAgICAgIGlmICghdGFibGVFbGVtZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBUYWJsZUVsZW1lbnQgaW4gRE9NJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNlbGxYID0gY2VsbC54O1xuICAgICAgY29uc3QgY2VsbFkgPSBjZWxsLnk7XG4gICAgICB0aGlzLmZvY3VzQ2VsbCA9IGNlbGw7XG5cbiAgICAgIGlmICh0aGlzLmFuY2hvckNlbGwgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKHRoaXMuZWRpdG9yLl93aW5kb3cpOyAvLyBDb2xsYXBzZSB0aGUgc2VsZWN0aW9uXG5cbiAgICAgICAgaWYgKGRvbVNlbGVjdGlvbikge1xuICAgICAgICAgIGRvbVNlbGVjdGlvbi5zZXRCYXNlQW5kRXh0ZW50KHRoaXMuYW5jaG9yQ2VsbC5lbGVtLCAwLCB0aGlzLmZvY3VzQ2VsbC5lbGVtLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyAmJiAodGhpcy5hbmNob3JYICE9PSBjZWxsWCB8fCB0aGlzLmFuY2hvclkgIT09IGNlbGxZIHx8IGlnbm9yZVN0YXJ0KSkge1xuICAgICAgICB0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgICAgfSBlbHNlIGlmIChjZWxsWCA9PT0gdGhpcy5mb2N1c1ggJiYgY2VsbFkgPT09IHRoaXMuZm9jdXNZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5mb2N1c1ggPSBjZWxsWDtcbiAgICAgIHRoaXMuZm9jdXNZID0gY2VsbFk7XG5cbiAgICAgIGlmICh0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMpIHtcbiAgICAgICAgY29uc3QgZm9jdXNUYWJsZUNlbGxOb2RlID0gbGV4aWNhbC4kZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShjZWxsLmVsZW0pO1xuXG4gICAgICAgIGlmICh0aGlzLmdyaWRTZWxlY3Rpb24gIT0gbnVsbCAmJiB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ICE9IG51bGwgJiYgJGlzVGFibGVDZWxsTm9kZShmb2N1c1RhYmxlQ2VsbE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgZm9jdXNOb2RlS2V5ID0gZm9jdXNUYWJsZUNlbGxOb2RlLmdldEtleSgpO1xuICAgICAgICAgIHRoaXMuZ3JpZFNlbGVjdGlvbiA9IHRoaXMuZ3JpZFNlbGVjdGlvbi5jbG9uZSgpIHx8IGxleGljYWwuREVQUkVDQVRFRF8kY3JlYXRlR3JpZFNlbGVjdGlvbigpO1xuICAgICAgICAgIHRoaXMuZm9jdXNDZWxsTm9kZUtleSA9IGZvY3VzTm9kZUtleTtcbiAgICAgICAgICB0aGlzLmdyaWRTZWxlY3Rpb24uc2V0KHRoaXMudGFibGVOb2RlS2V5LCB0aGlzLmFuY2hvckNlbGxOb2RlS2V5LCB0aGlzLmZvY3VzQ2VsbE5vZGVLZXkpO1xuICAgICAgICAgIGxleGljYWwuJHNldFNlbGVjdGlvbih0aGlzLmdyaWRTZWxlY3Rpb24pO1xuICAgICAgICAgIHRoaXMuZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLlNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAkdXBkYXRlRE9NRm9yU2VsZWN0aW9uKHRoaXMuZ3JpZCwgdGhpcy5ncmlkU2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihjZWxsKSB7XG4gICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gZmFsc2U7XG4gICAgdGhpcy5hbmNob3JDZWxsID0gY2VsbDtcbiAgICB0aGlzLmFuY2hvclggPSBjZWxsLng7XG4gICAgdGhpcy5hbmNob3JZID0gY2VsbC55O1xuICAgIHRoaXMuZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCBhbmNob3JUYWJsZUNlbGxOb2RlID0gbGV4aWNhbC4kZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShjZWxsLmVsZW0pO1xuXG4gICAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShhbmNob3JUYWJsZUNlbGxOb2RlKSkge1xuICAgICAgICBjb25zdCBhbmNob3JOb2RlS2V5ID0gYW5jaG9yVGFibGVDZWxsTm9kZS5nZXRLZXkoKTtcbiAgICAgICAgdGhpcy5ncmlkU2VsZWN0aW9uID0gbGV4aWNhbC5ERVBSRUNBVEVEXyRjcmVhdGVHcmlkU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgPSBhbmNob3JOb2RlS2V5O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZm9ybWF0Q2VsbHModHlwZSkge1xuICAgIHRoaXMuZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgICAgaWYgKCFsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgZ3JpZCBzZWxlY3Rpb25gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBmb3JtYXRTZWxlY3Rpb24gPSBsZXhpY2FsLiRjcmVhdGVSYW5nZVNlbGVjdGlvbigpO1xuICAgICAgY29uc3QgYW5jaG9yID0gZm9ybWF0U2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGZvY3VzID0gZm9ybWF0U2VsZWN0aW9uLmZvY3VzO1xuICAgICAgc2VsZWN0aW9uLmdldE5vZGVzKCkuZm9yRWFjaChjZWxsTm9kZSA9PiB7XG4gICAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGNlbGxOb2RlKSAmJiBjZWxsTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSAhPT0gMCkge1xuICAgICAgICAgIGFuY2hvci5zZXQoY2VsbE5vZGUuZ2V0S2V5KCksIDAsICdlbGVtZW50Jyk7XG4gICAgICAgICAgZm9jdXMuc2V0KGNlbGxOb2RlLmdldEtleSgpLCBjZWxsTm9kZS5nZXRDaGlsZHJlblNpemUoKSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICBmb3JtYXRTZWxlY3Rpb24uZm9ybWF0VGV4dCh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsZXhpY2FsLiRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgIHRoaXMuZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChsZXhpY2FsLlNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsZWFyVGV4dCgpIHtcbiAgICB0aGlzLmVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgdGFibGVOb2RlID0gbGV4aWNhbC4kZ2V0Tm9kZUJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcblxuICAgICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFRhYmxlTm9kZS4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGdyaWQgc2VsZWN0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpLmZpbHRlcigkaXNUYWJsZUNlbGxOb2RlKTtcblxuICAgICAgaWYgKHNlbGVjdGVkTm9kZXMubGVuZ3RoID09PSB0aGlzLmdyaWQuY29sdW1ucyAqIHRoaXMuZ3JpZC5yb3dzKSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpOyAvLyBEZWxldGUgZW50aXJlIHRhYmxlXG5cbiAgICAgICAgdGFibGVOb2RlLnJlbW92ZSgpO1xuICAgICAgICBjb25zdCByb290Tm9kZSA9IGxleGljYWwuJGdldFJvb3QoKTtcbiAgICAgICAgcm9vdE5vZGUuc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3RlZE5vZGVzLmZvckVhY2goY2VsbE5vZGUgPT4ge1xuICAgICAgICBpZiAobGV4aWNhbC4kaXNFbGVtZW50Tm9kZShjZWxsTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhOb2RlID0gbGV4aWNhbC4kY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gbGV4aWNhbC4kY3JlYXRlVGV4dE5vZGUoKTtcbiAgICAgICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgY2VsbE5vZGUuYXBwZW5kKHBhcmFncmFwaE5vZGUpO1xuICAgICAgICAgIGNlbGxOb2RlLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQgIT09IHBhcmFncmFwaE5vZGUpIHtcbiAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbih0aGlzLmdyaWQsIG51bGwpO1xuICAgICAgbGV4aWNhbC4kc2V0U2VsZWN0aW9uKG51bGwpO1xuICAgICAgdGhpcy5lZGl0b3IuZGlzcGF0Y2hDb21tYW5kKGxleGljYWwuU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9XG5cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgTEVYSUNBTF9FTEVNRU5UX0tFWSA9ICdfX2xleGljYWxUYWJsZVNlbGVjdGlvbic7XG5mdW5jdGlvbiBhcHBseVRhYmxlSGFuZGxlcnModGFibGVOb2RlLCB0YWJsZUVsZW1lbnQsIGVkaXRvcikge1xuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuXG4gIGlmIChyb290RWxlbWVudCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gcm9vdCBlbGVtZW50LicpO1xuICB9XG5cbiAgY29uc3QgdGFibGVTZWxlY3Rpb24gPSBuZXcgVGFibGVTZWxlY3Rpb24oZWRpdG9yLCB0YWJsZU5vZGUuZ2V0S2V5KCkpO1xuICBhdHRhY2hUYWJsZVNlbGVjdGlvblRvVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgdGFibGVTZWxlY3Rpb24pO1xuICBsZXQgaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgbGV0IGlzUmFuZ2VTZWxlY3Rpb25IaWphY2tlZCA9IGZhbHNlO1xuICB0YWJsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBldmVudCA9PiB7XG4gICAgY29uc3QgY2VsbCA9IGdldENlbGxGcm9tVGFyZ2V0KGV2ZW50LnRhcmdldCk7XG5cbiAgICBpZiAoY2VsbCAhPT0gbnVsbCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0YWJsZVNlbGVjdGlvbi5zZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGNlbGwpO1xuICAgICAgdGFibGVTZWxlY3Rpb24uc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGNlbGwsIHRydWUpO1xuICAgICAgaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICB9XG4gIH0pOyAvLyBUaGlzIGlzIHRoZSBhbmNob3Igb2YgdGhlIHNlbGVjdGlvbi5cblxuICB0YWJsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZXZlbnQgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNlbGwgPSBnZXRDZWxsRnJvbVRhcmdldChldmVudC50YXJnZXQpO1xuXG4gICAgICBpZiAoY2VsbCAhPT0gbnVsbCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRhYmxlU2VsZWN0aW9uLnNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oY2VsbCk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH0pOyAvLyBUaGlzIGlzIGFkanVzdGluZyB0aGUgZm9jdXMgb2YgdGhlIHNlbGVjdGlvbi5cblxuICB0YWJsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZXZlbnQgPT4ge1xuICAgIGlmIChpc1JhbmdlU2VsZWN0aW9uSGlqYWNrZWQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIGlmIChpc01vdXNlRG93bikge1xuICAgICAgY29uc3QgY2VsbCA9IGdldENlbGxGcm9tVGFyZ2V0KGV2ZW50LnRhcmdldCk7XG5cbiAgICAgIGlmIChjZWxsICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNlbGxYID0gY2VsbC54O1xuICAgICAgICBjb25zdCBjZWxsWSA9IGNlbGwueTtcblxuICAgICAgICBpZiAoaXNNb3VzZURvd24gJiYgKHRhYmxlU2VsZWN0aW9uLmFuY2hvclggIT09IGNlbGxYIHx8IHRhYmxlU2VsZWN0aW9uLmFuY2hvclkgIT09IGNlbGxZIHx8IHRhYmxlU2VsZWN0aW9uLmlzSGlnaGxpZ2h0aW5nQ2VsbHMpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0YWJsZVNlbGVjdGlvbi5zZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oY2VsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pOyAvLyBTZWxlY3QgZW50aXJlIHRhYmxlIGF0IHRoaXMgcG9pbnQsIHdoZW4gZ3JpZCBzZWxlY3Rpb24gaXMgcmVhZHkuXG5cbiAgdGFibGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoKSA9PiB7XG4gICAgaWYgKGlzTW91c2VEb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9KTsgLy8gQ2xlYXIgc2VsZWN0aW9uIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiBkb20uXG5cbiAgY29uc3QgbW91c2VEb3duQ2FsbGJhY2sgPSBldmVudCA9PiB7XG4gICAgaXNNb3VzZURvd24gPSB0cnVlO1xuXG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmIChsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5ncmlkS2V5ID09PSB0YWJsZVNlbGVjdGlvbi50YWJsZU5vZGVLZXkgJiYgcm9vdEVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdGFibGVTZWxlY3Rpb24uY2xlYXJIaWdobGlnaHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2VEb3duQ2FsbGJhY2spO1xuICB0YWJsZVNlbGVjdGlvbi5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bkNhbGxiYWNrKSk7XG5cbiAgY29uc3QgbW91c2VVcENhbGxiYWNrID0gZXZlbnQgPT4ge1xuICAgIGlmIChpc01vdXNlRG93bikge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIGlzTW91c2VEb3duID0gZmFsc2U7XG4gIH07XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZVVwQ2FsbGJhY2spO1xuICB0YWJsZVNlbGVjdGlvbi5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZVVwQ2FsbGJhY2spKTtcbiAgdGFibGVTZWxlY3Rpb24ubGlzdGVuZXJzVG9SZW1vdmUuYWRkKCgpID0+IHRhYmxlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VVcENhbGxiYWNrKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZCgoKSA9PiB0YWJsZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlVXBDYWxsYmFjaykpO1xuICB0YWJsZVNlbGVjdGlvbi5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9BUlJPV19ET1dOX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSAnZG93bic7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG5cbiAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VycmVudENvcmRzID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlU2VsZWN0aW9uLmdyaWQpO1xuICAgICAgICBjb25zdCBlbGVtZW50UGFyZW50Tm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShuKSk7XG5cbiAgICAgICAgaWYgKGVsZW1lbnRQYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIEJsb2NrTm9kZSBQYXJlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IHRhYmxlQ2VsbE5vZGUuZ2V0TGFzdENoaWxkKCk7XG4gICAgICAgIGNvbnN0IGlzU2VsZWN0aW9uSW5MYXN0QmxvY2sgPSBsYXN0Q2hpbGQgJiYgZWxlbWVudFBhcmVudE5vZGUuaXNQYXJlbnRPZihsYXN0Q2hpbGQpIHx8IGVsZW1lbnRQYXJlbnROb2RlID09PSBsYXN0Q2hpbGQ7XG5cbiAgICAgICAgaWYgKGlzU2VsZWN0aW9uSW5MYXN0QmxvY2sgfHwgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBTdGFydCBTZWxlY3Rpb25cblxuICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgdGFibGVTZWxlY3Rpb24uc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbih0YWJsZU5vZGUuZ2V0Q2VsbEZyb21Db3Jkc09yVGhyb3coY3VycmVudENvcmRzLngsIGN1cnJlbnRDb3Jkcy55LCB0YWJsZVNlbGVjdGlvbi5ncmlkKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRqdXN0Rm9jdXNOb2RlSW5EaXJlY3Rpb24odGFibGVTZWxlY3Rpb24sIHRhYmxlTm9kZSwgY3VycmVudENvcmRzLngsIGN1cnJlbnRDb3Jkcy55LCBkaXJlY3Rpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxlY3RHcmlkTm9kZUluRGlyZWN0aW9uKHRhYmxlU2VsZWN0aW9uLCB0YWJsZU5vZGUsIGN1cnJlbnRDb3Jkcy54LCBjdXJyZW50Q29yZHMueSwgZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBldmVudC5zaGlmdEtleSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG5cbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRDb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZVNlbGVjdGlvbi5ncmlkKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuIGFkanVzdEZvY3VzTm9kZUluRGlyZWN0aW9uKHRhYmxlU2VsZWN0aW9uLCB0YWJsZU5vZGUsIGN1cnJlbnRDb3Jkcy54LCBjdXJyZW50Q29yZHMueSwgZGlyZWN0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0FSUk9XX1VQX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSAndXAnO1xuXG4gICAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpO1xuXG4gICAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZVNlbGVjdGlvbi5ncmlkKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFBhcmVudE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+IGxleGljYWwuJGlzRWxlbWVudE5vZGUobikpO1xuXG4gICAgICAgIGlmIChlbGVtZW50UGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBCbG9ja05vZGUgUGFyZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsYXN0Q2hpbGQgPSB0YWJsZUNlbGxOb2RlLmdldExhc3RDaGlsZCgpO1xuICAgICAgICBjb25zdCBpc1NlbGVjdGlvbkluTGFzdEJsb2NrID0gbGFzdENoaWxkICYmIGVsZW1lbnRQYXJlbnROb2RlLmlzUGFyZW50T2YobGFzdENoaWxkKSB8fCBlbGVtZW50UGFyZW50Tm9kZSA9PT0gbGFzdENoaWxkO1xuXG4gICAgICAgIGlmIChpc1NlbGVjdGlvbkluTGFzdEJsb2NrIHx8IGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gU3RhcnQgU2VsZWN0aW9uXG5cbiAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIHRhYmxlU2VsZWN0aW9uLnNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24odGFibGVOb2RlLmdldENlbGxGcm9tQ29yZHNPclRocm93KGN1cnJlbnRDb3Jkcy54LCBjdXJyZW50Q29yZHMueSwgdGFibGVTZWxlY3Rpb24uZ3JpZCkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkanVzdEZvY3VzTm9kZUluRGlyZWN0aW9uKHRhYmxlU2VsZWN0aW9uLCB0YWJsZU5vZGUsIGN1cnJlbnRDb3Jkcy54LCBjdXJyZW50Q29yZHMueSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2VsZWN0R3JpZE5vZGVJbkRpcmVjdGlvbih0YWJsZVNlbGVjdGlvbiwgdGFibGVOb2RlLCBjdXJyZW50Q29yZHMueCwgY3VycmVudENvcmRzLnksIGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuXG4gICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjdXJyZW50Q29yZHMgPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgdGFibGVTZWxlY3Rpb24uZ3JpZCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybiBhZGp1c3RGb2N1c05vZGVJbkRpcmVjdGlvbih0YWJsZVNlbGVjdGlvbiwgdGFibGVOb2RlLCBjdXJyZW50Q29yZHMueCwgY3VycmVudENvcmRzLnksIGRpcmVjdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfSElHSCkpO1xuICB0YWJsZVNlbGVjdGlvbi5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChsZXhpY2FsLktFWV9BUlJPV19MRUZUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSAnYmFja3dhcmQnO1xuXG4gICAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpO1xuXG4gICAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZVNlbGVjdGlvbi5ncmlkKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFBhcmVudE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+IGxleGljYWwuJGlzRWxlbWVudE5vZGUobikpO1xuXG4gICAgICAgIGlmIChlbGVtZW50UGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBCbG9ja05vZGUgUGFyZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDAgfHwgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBTdGFydCBTZWxlY3Rpb25cblxuICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgdGFibGVTZWxlY3Rpb24uc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbih0YWJsZU5vZGUuZ2V0Q2VsbEZyb21Db3Jkc09yVGhyb3coY3VycmVudENvcmRzLngsIGN1cnJlbnRDb3Jkcy55LCB0YWJsZVNlbGVjdGlvbi5ncmlkKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRqdXN0Rm9jdXNOb2RlSW5EaXJlY3Rpb24odGFibGVTZWxlY3Rpb24sIHRhYmxlTm9kZSwgY3VycmVudENvcmRzLngsIGN1cnJlbnRDb3Jkcy55LCBkaXJlY3Rpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxlY3RHcmlkTm9kZUluRGlyZWN0aW9uKHRhYmxlU2VsZWN0aW9uLCB0YWJsZU5vZGUsIGN1cnJlbnRDb3Jkcy54LCBjdXJyZW50Q29yZHMueSwgZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBldmVudC5zaGlmdEtleSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG5cbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRDb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZVNlbGVjdGlvbi5ncmlkKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuIGFkanVzdEZvY3VzTm9kZUluRGlyZWN0aW9uKHRhYmxlU2VsZWN0aW9uLCB0YWJsZU5vZGUsIGN1cnJlbnRDb3Jkcy54LCBjdXJyZW50Q29yZHMueSwgZGlyZWN0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSAnZm9yd2FyZCc7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG5cbiAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VycmVudENvcmRzID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlU2VsZWN0aW9uLmdyaWQpO1xuICAgICAgICBjb25zdCBlbGVtZW50UGFyZW50Tm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShuKSk7XG5cbiAgICAgICAgaWYgKGVsZW1lbnRQYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIEJsb2NrTm9kZSBQYXJlbnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkuZ2V0VGV4dENvbnRlbnRTaXplKCkgfHwgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBTdGFydCBTZWxlY3Rpb25cblxuICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgdGFibGVTZWxlY3Rpb24uc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbih0YWJsZU5vZGUuZ2V0Q2VsbEZyb21Db3Jkc09yVGhyb3coY3VycmVudENvcmRzLngsIGN1cnJlbnRDb3Jkcy55LCB0YWJsZVNlbGVjdGlvbi5ncmlkKSk7XG4gICAgICAgICAgICByZXR1cm4gYWRqdXN0Rm9jdXNOb2RlSW5EaXJlY3Rpb24odGFibGVTZWxlY3Rpb24sIHRhYmxlTm9kZSwgY3VycmVudENvcmRzLngsIGN1cnJlbnRDb3Jkcy55LCBkaXJlY3Rpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxlY3RHcmlkTm9kZUluRGlyZWN0aW9uKHRhYmxlU2VsZWN0aW9uLCB0YWJsZU5vZGUsIGN1cnJlbnRDb3Jkcy54LCBjdXJyZW50Q29yZHMueSwgZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBldmVudC5zaGlmdEtleSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG5cbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGN1cnJlbnRDb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZVNlbGVjdGlvbi5ncmlkKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuIGFkanVzdEZvY3VzTm9kZUluRGlyZWN0aW9uKHRhYmxlU2VsZWN0aW9uLCB0YWJsZU5vZGUsIGN1cnJlbnRDb3Jkcy54LCBjdXJyZW50Q29yZHMueSwgZGlyZWN0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG5cbiAgY29uc3QgZGVsZXRlVGV4dEhhbmRsZXIgPSBjb21tYW5kID0+ICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgdGFibGVTZWxlY3Rpb24uY2xlYXJUZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG5cbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgICBjb25zdCBpc0FuY2hvckluc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKGFuY2hvck5vZGUpO1xuICAgICAgY29uc3QgaXNGb2N1c0luc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKGZvY3VzTm9kZSk7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Db250YWluc1BhcnRpYWxUYWJsZSA9IGlzQW5jaG9ySW5zaWRlICYmICFpc0ZvY3VzSW5zaWRlIHx8IGlzRm9jdXNJbnNpZGUgJiYgIWlzQW5jaG9ySW5zaWRlO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uQ29udGFpbnNQYXJ0aWFsVGFibGUpIHtcbiAgICAgICAgdGFibGVTZWxlY3Rpb24uY2xlYXJUZXh0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZWFyZXN0RWxlbWVudE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+IGxleGljYWwuJGlzRWxlbWVudE5vZGUobikpO1xuICAgICAgY29uc3QgdG9wTGV2ZWxDZWxsRWxlbWVudE5vZGUgPSBuZWFyZXN0RWxlbWVudE5vZGUgJiYgdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChuZWFyZXN0RWxlbWVudE5vZGUsIG4gPT4gbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShuKSAmJiAkaXNUYWJsZUNlbGxOb2RlKG4uZ2V0UGFyZW50KCkpKTtcblxuICAgICAgaWYgKCFsZXhpY2FsLiRpc0VsZW1lbnROb2RlKHRvcExldmVsQ2VsbEVsZW1lbnROb2RlKSB8fCAhbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShuZWFyZXN0RWxlbWVudE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbW1hbmQgPT09IGxleGljYWwuREVMRVRFX0xJTkVfQ09NTUFORCAmJiB0b3BMZXZlbENlbGxFbGVtZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBGaXggRGVsZXRlIExpbmUgaW4gVGFibGUgQ2VsbHMuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tbWFuZCA9PT0gbGV4aWNhbC5ERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQgfHwgY29tbWFuZCA9PT0gbGV4aWNhbC5ERUxFVEVfV09SRF9DT01NQU5EKSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMCkge1xuICAgICAgICAgIGlmIChuZWFyZXN0RWxlbWVudE5vZGUgIT09IHRvcExldmVsQ2VsbEVsZW1lbnROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5lYXJlc3RFbGVtZW50Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgICAgY29uc3QgbmV3UGFyYWdyYXBoTm9kZSA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gbmV3UGFyYWdyYXBoTm9kZS5hcHBlbmQoY2hpbGQpKTtcbiAgICAgICAgICAgIG5lYXJlc3RFbGVtZW50Tm9kZS5yZXBsYWNlKG5ld1BhcmFncmFwaE5vZGUpO1xuICAgICAgICAgICAgbmVhcmVzdEVsZW1lbnROb2RlLmdldFdyaXRhYmxlKCkuX19wYXJlbnQgPSB0YWJsZUNlbGxOb2RlLmdldEtleSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIFtsZXhpY2FsLkRFTEVURV9XT1JEX0NPTU1BTkQsIGxleGljYWwuREVMRVRFX0xJTkVfQ09NTUFORCwgbGV4aWNhbC5ERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkRdLmZvckVhY2goY29tbWFuZCA9PiB7XG4gICAgdGFibGVTZWxlY3Rpb24ubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoY29tbWFuZCwgZGVsZXRlVGV4dEhhbmRsZXIoY29tbWFuZCksIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB9KTtcblxuICBjb25zdCBkZWxldGVDZWxsSGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGFibGVTZWxlY3Rpb24uY2xlYXJUZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG5cbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCBkZWxldGVDZWxsSGFuZGxlciwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuS0VZX0RFTEVURV9DT01NQU5ELCBkZWxldGVDZWxsSGFuZGxlciwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuRk9STUFUX1RFWFRfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHRhYmxlU2VsZWN0aW9uLmZvcm1hdENlbGxzKHBheWxvYWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpO1xuXG4gICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgbGV4aWNhbC5DT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBwYXlsb2FkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgdGFibGVTZWxlY3Rpb24uY2xlYXJIaWdobGlnaHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9IHV0aWxzLiRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG5cbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVTZWxlY3Rpb24ubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQobGV4aWNhbC5LRVlfVEFCX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcblxuICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZVNlbGVjdGlvbi5ncmlkKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2VsZWN0R3JpZE5vZGVJbkRpcmVjdGlvbih0YWJsZVNlbGVjdGlvbiwgdGFibGVOb2RlLCBjdXJyZW50Q29yZHMueCwgY3VycmVudENvcmRzLnksICFldmVudC5zaGlmdEtleSA/ICdmb3J3YXJkJyA6ICdiYWNrd2FyZCcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuRk9DVVNfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgcmV0dXJuIHRhYmxlTm9kZS5pc1NlbGVjdGVkKCk7XG4gIH0sIGxleGljYWwuQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIHRhYmxlU2VsZWN0aW9uLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGxleGljYWwuU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCBwYXlsb2FkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcblxuICAgIGlmIChzZWxlY3Rpb24gJiYgbGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGlzQW5jaG9ySW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2YoYW5jaG9yTm9kZSk7XG4gICAgICBjb25zdCBpc0ZvY3VzSW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2YoZm9jdXNOb2RlKTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbnRhaW5zUGFydGlhbFRhYmxlID0gaXNBbmNob3JJbnNpZGUgJiYgIWlzRm9jdXNJbnNpZGUgfHwgaXNGb2N1c0luc2lkZSAmJiAhaXNBbmNob3JJbnNpZGU7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Jc0luc2lkZVRhYmxlID0gaXNBbmNob3JJbnNpZGUgJiYgaXNGb2N1c0luc2lkZSAmJiAhdGFibGVOb2RlLmlzU2VsZWN0ZWQoKTtcblxuICAgICAgaWYgKHNlbGVjdGlvbkNvbnRhaW5zUGFydGlhbFRhYmxlKSB7XG4gICAgICAgIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICAgICAgICBjb25zdCBtb2RpZmllZFNlbGVjdGlvbiA9IGxleGljYWwuJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRhYmxlS2V5ID0gdGFibGVOb2RlLmdldEtleSgpO1xuICAgICAgICBtb2RpZmllZFNlbGVjdGlvbi5hbmNob3Iuc2V0KHNlbGVjdGlvbi5hbmNob3Iua2V5LCBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCwgc2VsZWN0aW9uLmFuY2hvci50eXBlKTtcbiAgICAgICAgbW9kaWZpZWRTZWxlY3Rpb24uZm9jdXMuc2V0KHRhYmxlS2V5LCBpc0JhY2t3YXJkID8gMCA6IHRhYmxlTm9kZS5nZXRDaGlsZHJlblNpemUoKSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgaXNSYW5nZVNlbGVjdGlvbkhpamFja2VkID0gdHJ1ZTtcbiAgICAgICAgbGV4aWNhbC4kc2V0U2VsZWN0aW9uKG1vZGlmaWVkU2VsZWN0aW9uKTtcbiAgICAgICAgJGFkZEhpZ2hsaWdodFN0eWxlVG9UYWJsZSh0YWJsZVNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb25Jc0luc2lkZVRhYmxlKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBncmlkXG4gICAgICAgIH0gPSB0YWJsZVNlbGVjdGlvbjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uLmdldE5vZGVzKCkuZmlsdGVyKCRpc1RhYmxlQ2VsbE5vZGUpLmxlbmd0aCA9PT0gZ3JpZC5yb3dzICogZ3JpZC5jb2x1bW5zKSB7XG4gICAgICAgICAgY29uc3QgZ3JpZFNlbGVjdGlvbiA9IGxleGljYWwuREVQUkVDQVRFRF8kY3JlYXRlR3JpZFNlbGVjdGlvbigpO1xuICAgICAgICAgIGNvbnN0IHRhYmxlS2V5ID0gdGFibGVOb2RlLmdldEtleSgpO1xuICAgICAgICAgIGNvbnN0IGZpcnN0Q2VsbCA9IHRhYmxlTm9kZS5nZXRGaXJzdENoaWxkT3JUaHJvdygpLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICBjb25zdCBsYXN0Q2VsbCA9IHRhYmxlTm9kZS5nZXRMYXN0Q2hpbGRPclRocm93KCkuZ2V0TGFzdENoaWxkKCk7XG5cbiAgICAgICAgICBpZiAoZmlyc3RDZWxsICE9IG51bGwgJiYgbGFzdENlbGwgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ3JpZFNlbGVjdGlvbi5zZXQodGFibGVLZXksIGZpcnN0Q2VsbC5nZXRLZXkoKSwgbGFzdENlbGwuZ2V0S2V5KCkpO1xuICAgICAgICAgICAgbGV4aWNhbC4kc2V0U2VsZWN0aW9uKGdyaWRTZWxlY3Rpb24pO1xuICAgICAgICAgICAgdGFibGVTZWxlY3Rpb24udXBkYXRlVGFibGVHcmlkU2VsZWN0aW9uKGdyaWRTZWxlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGlvbiAmJiAhc2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pICYmIChsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IGxleGljYWwuREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pKSAmJiB0YWJsZVNlbGVjdGlvbi5ncmlkU2VsZWN0aW9uICYmICF0YWJsZVNlbGVjdGlvbi5ncmlkU2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgICBpZiAobGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uZ3JpZEtleSA9PT0gdGFibGVTZWxlY3Rpb24udGFibGVOb2RlS2V5KSB7XG4gICAgICAgIHRhYmxlU2VsZWN0aW9uLnVwZGF0ZVRhYmxlR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmICghbGV4aWNhbC5ERVBSRUNBVEVEXyRpc0dyaWRTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBwcmV2U2VsZWN0aW9uLmdyaWRLZXkgPT09IHRhYmxlU2VsZWN0aW9uLnRhYmxlTm9kZUtleSkge1xuICAgICAgICB0YWJsZVNlbGVjdGlvbi51cGRhdGVUYWJsZUdyaWRTZWxlY3Rpb24obnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGFibGVTZWxlY3Rpb24uaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgJiYgIXRhYmxlTm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICRyZW1vdmVIaWdobGlnaHRTdHlsZVRvVGFibGUodGFibGVTZWxlY3Rpb24pO1xuICAgICAgaXNSYW5nZVNlbGVjdGlvbkhpamFja2VkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghdGFibGVTZWxlY3Rpb24uaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgJiYgdGFibGVOb2RlLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgJGFkZEhpZ2hsaWdodFN0eWxlVG9UYWJsZSh0YWJsZVNlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBsZXhpY2FsLkNPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgcmV0dXJuIHRhYmxlU2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gYXR0YWNoVGFibGVTZWxlY3Rpb25Ub1RhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIHRhYmxlU2VsZWN0aW9uKSB7XG4gIHRhYmxlRWxlbWVudFtMRVhJQ0FMX0VMRU1FTlRfS0VZXSA9IHRhYmxlU2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gZ2V0VGFibGVTZWxlY3Rpb25Gcm9tVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCkge1xuICByZXR1cm4gdGFibGVFbGVtZW50W0xFWElDQUxfRUxFTUVOVF9LRVldO1xufVxuZnVuY3Rpb24gZ2V0Q2VsbEZyb21UYXJnZXQobm9kZSkge1xuICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuXG4gIHdoaWxlIChjdXJyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBjdXJyZW50Tm9kZS5ub2RlTmFtZTtcblxuICAgIGlmIChub2RlTmFtZSA9PT0gJ1REJyB8fCBub2RlTmFtZSA9PT0gJ1RIJykge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGNvbnN0IGNlbGwgPSBjdXJyZW50Tm9kZS5fY2VsbDtcblxuICAgICAgaWYgKGNlbGwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfVxuXG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRUYWJsZUdyaWQodGFibGVFbGVtZW50KSB7XG4gIGNvbnN0IGNlbGxzID0gW107XG4gIGNvbnN0IGdyaWQgPSB7XG4gICAgY2VsbHMsXG4gICAgY29sdW1uczogMCxcbiAgICByb3dzOiAwXG4gIH07XG4gIGxldCBjdXJyZW50Tm9kZSA9IHRhYmxlRWxlbWVudC5maXJzdENoaWxkO1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgY2VsbHMubGVuZ3RoID0gMDtcblxuICB3aGlsZSAoY3VycmVudE5vZGUgIT0gbnVsbCkge1xuICAgIGNvbnN0IG5vZGVNYW1lID0gY3VycmVudE5vZGUubm9kZU5hbWU7XG5cbiAgICBpZiAobm9kZU1hbWUgPT09ICdURCcgfHwgbm9kZU1hbWUgPT09ICdUSCcpIHtcbiAgICAgIGNvbnN0IGVsZW0gPSBjdXJyZW50Tm9kZTtcbiAgICAgIGNvbnN0IGNlbGwgPSB7XG4gICAgICAgIGVsZW0sXG4gICAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZSxcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTsgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcblxuICAgICAgY3VycmVudE5vZGUuX2NlbGwgPSBjZWxsO1xuXG4gICAgICBpZiAoY2VsbHNbeV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjZWxsc1t5XSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBjZWxsc1t5XVt4XSA9IGNlbGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY3VycmVudE5vZGUuZmlyc3RDaGlsZDtcblxuICAgICAgaWYgKGNoaWxkICE9IG51bGwpIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2libGluZyA9IGN1cnJlbnROb2RlLm5leHRTaWJsaW5nO1xuXG4gICAgaWYgKHNpYmxpbmcgIT0gbnVsbCkge1xuICAgICAgeCsrO1xuICAgICAgY3VycmVudE5vZGUgPSBzaWJsaW5nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50ID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcblxuICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyZW50U2libGluZyA9IHBhcmVudC5uZXh0U2libGluZztcblxuICAgICAgaWYgKHBhcmVudFNpYmxpbmcgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgeSsrO1xuICAgICAgeCA9IDA7XG4gICAgICBjdXJyZW50Tm9kZSA9IHBhcmVudFNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZ3JpZC5jb2x1bW5zID0geCArIDE7XG4gIGdyaWQucm93cyA9IHkgKyAxO1xuICByZXR1cm4gZ3JpZDtcbn1cbmZ1bmN0aW9uICR1cGRhdGVET01Gb3JTZWxlY3Rpb24oZ3JpZCwgc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGhpZ2hsaWdodGVkQ2VsbHMgPSBbXTtcbiAgY29uc3Qgc2VsZWN0ZWRDZWxsTm9kZXMgPSBuZXcgU2V0KHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5nZXROb2RlcygpIDogW10pO1xuICAkZm9yRWFjaEdyaWRDZWxsKGdyaWQsIChjZWxsLCBsZXhpY2FsTm9kZSkgPT4ge1xuICAgIGNvbnN0IGVsZW0gPSBjZWxsLmVsZW07XG5cbiAgICBpZiAoc2VsZWN0ZWRDZWxsTm9kZXMuaGFzKGxleGljYWxOb2RlKSkge1xuICAgICAgY2VsbC5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICBlbGVtLnN0eWxlLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLWNvbG9yJywgJ3JnYigxNzIsIDIwNiwgMjQ3KScpO1xuICAgICAgZWxlbS5zdHlsZS5zZXRQcm9wZXJ0eSgnY2FyZXQtY29sb3InLCAndHJhbnNwYXJlbnQnKTtcbiAgICAgIGhpZ2hsaWdodGVkQ2VsbHMucHVzaChjZWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbC5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnYmFja2dyb3VuZC1jb2xvcicpO1xuICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnY2FyZXQtY29sb3InKTtcblxuICAgICAgaWYgKCFlbGVtLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaGlnaGxpZ2h0ZWRDZWxscztcbn1cbmZ1bmN0aW9uICRmb3JFYWNoR3JpZENlbGwoZ3JpZCwgY2IpIHtcbiAgY29uc3Qge1xuICAgIGNlbGxzXG4gIH0gPSBncmlkO1xuXG4gIGZvciAobGV0IHkgPSAwOyB5IDwgY2VsbHMubGVuZ3RoOyB5KyspIHtcbiAgICBjb25zdCByb3cgPSBjZWxsc1t5XTtcblxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgcm93Lmxlbmd0aDsgeCsrKSB7XG4gICAgICBjb25zdCBjZWxsID0gcm93W3hdO1xuICAgICAgY29uc3QgbGV4aWNhbE5vZGUgPSBsZXhpY2FsLiRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGNlbGwuZWxlbSk7XG5cbiAgICAgIGlmIChsZXhpY2FsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjYihjZWxsLCBsZXhpY2FsTm9kZSwge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRhZGRIaWdobGlnaHRTdHlsZVRvVGFibGUodGFibGVTZWxlY3Rpb24pIHtcbiAgdGFibGVTZWxlY3Rpb24uZGlzYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICRmb3JFYWNoR3JpZENlbGwodGFibGVTZWxlY3Rpb24uZ3JpZCwgY2VsbCA9PiB7XG4gICAgY29uc3QgZWxlbSA9IGNlbGwuZWxlbTtcbiAgICBjZWxsLmhpZ2hsaWdodGVkID0gdHJ1ZTtcbiAgICBlbGVtLnN0eWxlLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLWNvbG9yJywgJ3JnYigxNzIsIDIwNiwgMjQ3KScpO1xuICAgIGVsZW0uc3R5bGUuc2V0UHJvcGVydHkoJ2NhcmV0LWNvbG9yJywgJ3RyYW5zcGFyZW50Jyk7XG4gIH0pO1xufVxuZnVuY3Rpb24gJHJlbW92ZUhpZ2hsaWdodFN0eWxlVG9UYWJsZSh0YWJsZVNlbGVjdGlvbikge1xuICB0YWJsZVNlbGVjdGlvbi5lbmFibGVIaWdobGlnaHRTdHlsZSgpO1xuICAkZm9yRWFjaEdyaWRDZWxsKHRhYmxlU2VsZWN0aW9uLmdyaWQsIGNlbGwgPT4ge1xuICAgIGNvbnN0IGVsZW0gPSBjZWxsLmVsZW07XG4gICAgY2VsbC5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgIGVsZW0uc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2JhY2tncm91bmQtY29sb3InKTtcbiAgICBlbGVtLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdjYXJldC1jb2xvcicpO1xuXG4gICAgaWYgKCFlbGVtLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3Qgc2VsZWN0R3JpZE5vZGVJbkRpcmVjdGlvbiA9ICh0YWJsZVNlbGVjdGlvbiwgdGFibGVOb2RlLCB4LCB5LCBkaXJlY3Rpb24pID0+IHtcbiAgY29uc3QgaXNGb3J3YXJkID0gZGlyZWN0aW9uID09PSAnZm9yd2FyZCc7XG5cbiAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICBjYXNlICdiYWNrd2FyZCc6XG4gICAgY2FzZSAnZm9yd2FyZCc6XG4gICAgICBpZiAoeCAhPT0gKGlzRm9yd2FyZCA/IHRhYmxlU2VsZWN0aW9uLmdyaWQuY29sdW1ucyAtIDEgOiAwKSkge1xuICAgICAgICBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coeCArIChpc0ZvcndhcmQgPyAxIDogLTEpLCB5LCB0YWJsZVNlbGVjdGlvbi5ncmlkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoeSAhPT0gKGlzRm9yd2FyZCA/IHRhYmxlU2VsZWN0aW9uLmdyaWQucm93cyAtIDEgOiAwKSkge1xuICAgICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyhpc0ZvcndhcmQgPyAwIDogdGFibGVTZWxlY3Rpb24uZ3JpZC5jb2x1bW5zIC0gMSwgeSArIChpc0ZvcndhcmQgPyAxIDogLTEpLCB0YWJsZVNlbGVjdGlvbi5ncmlkKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRm9yd2FyZCkge1xuICAgICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhYmxlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlICd1cCc6XG4gICAgICBpZiAoeSAhPT0gMCkge1xuICAgICAgICBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coeCwgeSAtIDEsIHRhYmxlU2VsZWN0aW9uLmdyaWQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgaWYgKHkgIT09IHRhYmxlU2VsZWN0aW9uLmdyaWQucm93cyAtIDEpIHtcbiAgICAgICAgc2VsZWN0VGFibGVDZWxsTm9kZSh0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHNPclRocm93KHgsIHkgKyAxLCB0YWJsZVNlbGVjdGlvbi5ncmlkKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWJsZU5vZGUuc2VsZWN0TmV4dCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmNvbnN0IGFkanVzdEZvY3VzTm9kZUluRGlyZWN0aW9uID0gKHRhYmxlU2VsZWN0aW9uLCB0YWJsZU5vZGUsIHgsIHksIGRpcmVjdGlvbikgPT4ge1xuICBjb25zdCBpc0ZvcndhcmQgPSBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJztcblxuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgJ2JhY2t3YXJkJzpcbiAgICBjYXNlICdmb3J3YXJkJzpcbiAgICAgIGlmICh4ICE9PSAoaXNGb3J3YXJkID8gdGFibGVTZWxlY3Rpb24uZ3JpZC5jb2x1bW5zIC0gMSA6IDApKSB7XG4gICAgICAgIHRhYmxlU2VsZWN0aW9uLnNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbih0YWJsZU5vZGUuZ2V0Q2VsbEZyb21Db3Jkc09yVGhyb3coeCArIChpc0ZvcndhcmQgPyAxIDogLTEpLCB5LCB0YWJsZVNlbGVjdGlvbi5ncmlkKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSAndXAnOlxuICAgICAgaWYgKHkgIT09IDApIHtcbiAgICAgICAgdGFibGVTZWxlY3Rpb24uc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKHRhYmxlTm9kZS5nZXRDZWxsRnJvbUNvcmRzT3JUaHJvdyh4LCB5IC0gMSwgdGFibGVTZWxlY3Rpb24uZ3JpZCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgaWYgKHkgIT09IHRhYmxlU2VsZWN0aW9uLmdyaWQucm93cyAtIDEpIHtcbiAgICAgICAgdGFibGVTZWxlY3Rpb24uc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKHRhYmxlTm9kZS5nZXRDZWxsRnJvbUNvcmRzT3JUaHJvdyh4LCB5ICsgMSwgdGFibGVTZWxlY3Rpb24uZ3JpZCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uICRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpIHtcbiAgaWYgKGxleGljYWwuJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSk7XG4gICAgY29uc3QgaXNGb2N1c0luc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCkpO1xuICAgIHJldHVybiBpc0FuY2hvckluc2lkZSAmJiBpc0ZvY3VzSW5zaWRlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbCkge1xuICBjb25zdCBwb3NzaWJsZVBhcmFncmFwaCA9IHRhYmxlQ2VsbC5nZXRDaGlsZHJlbigpLmZpbmQobiA9PiBsZXhpY2FsLiRpc1BhcmFncmFwaE5vZGUobikpO1xuXG4gIGlmIChsZXhpY2FsLiRpc1BhcmFncmFwaE5vZGUocG9zc2libGVQYXJhZ3JhcGgpKSB7XG4gICAgcG9zc2libGVQYXJhZ3JhcGguc2VsZWN0RW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgdGFibGVDZWxsLnNlbGVjdEVuZCgpO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFRhYmxlTm9kZSBleHRlbmRzIGxleGljYWwuREVQUkVDQVRFRF9HcmlkTm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWJsZSc7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgVGFibGVOb2RlKG5vZGUuX19rZXkpO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFibGU6IF9ub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUYWJsZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAxXG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihfc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZVRhYmxlTm9kZSgpO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlRE9NKGNvbmZpZywgZWRpdG9yKSB7XG4gICAgY29uc3QgdGFibGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcbiAgICB1dGlscy5hZGRDbGFzc05hbWVzVG9FbGVtZW50KHRhYmxlRWxlbWVudCwgY29uZmlnLnRoZW1lLnRhYmxlKTtcbiAgICByZXR1cm4gdGFibGVFbGVtZW50O1xuICB9XG5cbiAgdXBkYXRlRE9NKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICByZXR1cm4geyAuLi5zdXBlci5leHBvcnRET00oZWRpdG9yKSxcbiAgICAgIGFmdGVyOiB0YWJsZUVsZW1lbnQgPT4ge1xuICAgICAgICBpZiAodGFibGVFbGVtZW50KSB7XG4gICAgICAgICAgY29uc3QgbmV3RWxlbWVudCA9IHRhYmxlRWxlbWVudC5jbG9uZU5vZGUoKTtcbiAgICAgICAgICBjb25zdCBjb2xHcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvbGdyb3VwJyk7XG4gICAgICAgICAgY29uc3QgdEJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0Ym9keScpO1xuICAgICAgICAgIHRCb2R5LmFwcGVuZCguLi50YWJsZUVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgICAgIGNvbnN0IGZpcnN0Um93ID0gdGhpcy5nZXRGaXJzdENoaWxkT3JUaHJvdygpO1xuXG4gICAgICAgICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoZmlyc3RSb3cpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgcm93IG5vZGUuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgY29sQ291bnQgPSBmaXJzdFJvdy5nZXRDaGlsZHJlblNpemUoKTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY29sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sJyk7XG4gICAgICAgICAgICBjb2xHcm91cC5hcHBlbmQoY29sKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdFbGVtZW50LnJlcGxhY2VDaGlsZHJlbihjb2xHcm91cCwgdEJvZHkpO1xuICAgICAgICAgIHJldHVybiBuZXdFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGNhbkV4dHJhY3RDb250ZW50cygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzU2hhZG93Um9vdCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldENvcmRzRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIGdyaWQpIHtcbiAgICBjb25zdCB7XG4gICAgICByb3dzLFxuICAgICAgY2VsbHNcbiAgICB9ID0gZ3JpZDtcblxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgcm93czsgeSsrKSB7XG4gICAgICBjb25zdCByb3cgPSBjZWxsc1t5XTtcblxuICAgICAgaWYgKHJvdyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUm93IG5vdCBmb3VuZCBhdCB5OiR7eX1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeCA9IHJvdy5maW5kSW5kZXgoKHtcbiAgICAgICAgZWxlbVxuICAgICAgfSkgPT4ge1xuICAgICAgICBjb25zdCBjZWxsTm9kZSA9IGxleGljYWwuJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZWxlbSk7XG4gICAgICAgIHJldHVybiBjZWxsTm9kZSA9PT0gdGFibGVDZWxsTm9kZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoeCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlbGwgbm90IGZvdW5kIGluIHRhYmxlLicpO1xuICB9XG5cbiAgZ2V0Q2VsbEZyb21Db3Jkcyh4LCB5LCBncmlkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2VsbHNcbiAgICB9ID0gZ3JpZDtcbiAgICBjb25zdCByb3cgPSBjZWxsc1t5XTtcblxuICAgIGlmIChyb3cgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgY2VsbCA9IHJvd1t4XTtcblxuICAgIGlmIChjZWxsID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjZWxsO1xuICB9XG5cbiAgZ2V0Q2VsbEZyb21Db3Jkc09yVGhyb3coeCwgeSwgZ3JpZCkge1xuICAgIGNvbnN0IGNlbGwgPSB0aGlzLmdldENlbGxGcm9tQ29yZHMoeCwgeSwgZ3JpZCk7XG5cbiAgICBpZiAoIWNlbGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2VsbCBub3QgZm91bmQgYXQgY29yZHMuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbGw7XG4gIH1cblxuICBnZXRDZWxsTm9kZUZyb21Db3Jkcyh4LCB5LCBncmlkKSB7XG4gICAgY29uc3QgY2VsbCA9IHRoaXMuZ2V0Q2VsbEZyb21Db3Jkcyh4LCB5LCBncmlkKTtcblxuICAgIGlmIChjZWxsID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBsZXhpY2FsLiRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGNlbGwuZWxlbSk7XG5cbiAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coeCwgeSwgZ3JpZCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHksIGdyaWQpO1xuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgYXQgY29yZHMgbm90IFRhYmxlQ2VsbE5vZGUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBjYW5TZWxlY3RCZWZvcmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn1cbmZ1bmN0aW9uICRnZXRFbGVtZW50R3JpZEZvclRhYmxlTm9kZShlZGl0b3IsIHRhYmxlTm9kZSkge1xuICBjb25zdCB0YWJsZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRhYmxlTm9kZS5nZXRLZXkoKSk7XG5cbiAgaWYgKHRhYmxlRWxlbWVudCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYWJsZSBFbGVtZW50IE5vdCBGb3VuZCcpO1xuICB9XG5cbiAgcmV0dXJuIGdldFRhYmxlR3JpZCh0YWJsZUVsZW1lbnQpO1xufVxuZnVuY3Rpb24gY29udmVydFRhYmxlRWxlbWVudChfZG9tTm9kZSkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVUYWJsZU5vZGUoKVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlTm9kZSgpIHtcbiAgcmV0dXJuIGxleGljYWwuJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUYWJsZU5vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNUYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRhYmxlTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zKHJvd0NvdW50LCBjb2x1bW5Db3VudCwgaW5jbHVkZUhlYWRlcnMgPSB0cnVlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRjcmVhdGVUYWJsZU5vZGUoKTtcblxuICBmb3IgKGxldCBpUm93ID0gMDsgaVJvdyA8IHJvd0NvdW50OyBpUm93KyspIHtcbiAgICBjb25zdCB0YWJsZVJvd05vZGUgPSAkY3JlYXRlVGFibGVSb3dOb2RlKCk7XG5cbiAgICBmb3IgKGxldCBpQ29sdW1uID0gMDsgaUNvbHVtbiA8IGNvbHVtbkNvdW50OyBpQ29sdW1uKyspIHtcbiAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5jbHVkZUhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpUm93ID09PSAwICYmIGluY2x1ZGVIZWFkZXJzLnJvd3MpIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1c7XG4gICAgICAgIGlmIChpQ29sdW1uID09PSAwICYmIGluY2x1ZGVIZWFkZXJzLmNvbHVtbnMpIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU47XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVIZWFkZXJzKSB7XG4gICAgICAgIGlmIChpUm93ID09PSAwKSBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XO1xuICAgICAgICBpZiAoaUNvbHVtbiA9PT0gMCkgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlKTtcbiAgICAgIGNvbnN0IHBhcmFncmFwaE5vZGUgPSBsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZChsZXhpY2FsLiRjcmVhdGVUZXh0Tm9kZSgpKTtcbiAgICAgIHRhYmxlQ2VsbE5vZGUuYXBwZW5kKHBhcmFncmFwaE5vZGUpO1xuICAgICAgdGFibGVSb3dOb2RlLmFwcGVuZCh0YWJsZUNlbGxOb2RlKTtcbiAgICB9XG5cbiAgICB0YWJsZU5vZGUuYXBwZW5kKHRhYmxlUm93Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ2VsbE5vZGVGcm9tTGV4aWNhbE5vZGUoc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGUgPSB1dGlscy4kZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0aW5nTm9kZSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcblxuICBpZiAoJGlzVGFibGVDZWxsTm9kZShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVSb3dOb2RlRnJvbVRhYmxlQ2VsbE5vZGVPclRocm93KHN0YXJ0aW5nTm9kZSkge1xuICBjb25zdCBub2RlID0gdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChzdGFydGluZ05vZGUsIG4gPT4gJGlzVGFibGVSb3dOb2RlKG4pKTtcblxuICBpZiAoJGlzVGFibGVSb3dOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRhYmxlIGNlbGwgdG8gYmUgaW5zaWRlIG9mIHRhYmxlIHJvdy4nKTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHN0YXJ0aW5nTm9kZSkge1xuICBjb25zdCBub2RlID0gdXRpbHMuJGZpbmRNYXRjaGluZ1BhcmVudChzdGFydGluZ05vZGUsIG4gPT4gJGlzVGFibGVOb2RlKG4pKTtcblxuICBpZiAoJGlzVGFibGVOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRhYmxlIGNlbGwgdG8gYmUgaW5zaWRlIG9mIHRhYmxlLicpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlUm93SW5kZXhGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSB7XG4gIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHRhYmxlUm93Tm9kZSk7XG4gIHJldHVybiB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKS5maW5kSW5kZXgobiA9PiBuLmlzKHRhYmxlUm93Tm9kZSkpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ29sdW1uSW5kZXhGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSB7XG4gIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIHJldHVybiB0YWJsZVJvd05vZGUuZ2V0Q2hpbGRyZW4oKS5maW5kSW5kZXgobiA9PiBuLmlzKHRhYmxlQ2VsbE5vZGUpKTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZUNlbGxTaWJsaW5nc0Zyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIGdyaWQpIHtcbiAgY29uc3QgdGFibGVOb2RlID0gJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCBncmlkKTtcbiAgcmV0dXJuIHtcbiAgICBhYm92ZTogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHkgLSAxLCBncmlkKSxcbiAgICBiZWxvdzogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHkgKyAxLCBncmlkKSxcbiAgICBsZWZ0OiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCAtIDEsIHksIGdyaWQpLFxuICAgIHJpZ2h0OiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCArIDEsIHksIGdyaWQpXG4gIH07XG59XG5mdW5jdGlvbiAkcmVtb3ZlVGFibGVSb3dBdEluZGV4KHRhYmxlTm9kZSwgaW5kZXhUb0RlbGV0ZSkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcblxuICBpZiAoaW5kZXhUb0RlbGV0ZSA+PSB0YWJsZVJvd3MubGVuZ3RoIHx8IGluZGV4VG9EZWxldGUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0YWJsZSBjZWxsIHRvIGJlIGluc2lkZSBvZiB0YWJsZSByb3cuJyk7XG4gIH1cblxuICBjb25zdCB0YXJnZXRSb3dOb2RlID0gdGFibGVSb3dzW2luZGV4VG9EZWxldGVdO1xuICB0YXJnZXRSb3dOb2RlLnJlbW92ZSgpO1xuICByZXR1cm4gdGFibGVOb2RlO1xufVxuZnVuY3Rpb24gJGluc2VydFRhYmxlUm93KHRhYmxlTm9kZSwgdGFyZ2V0SW5kZXgsIHNob3VsZEluc2VydEFmdGVyID0gdHJ1ZSwgcm93Q291bnQsIGdyaWQpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG5cbiAgaWYgKHRhcmdldEluZGV4ID49IHRhYmxlUm93cy5sZW5ndGggfHwgdGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUYWJsZSByb3cgdGFyZ2V0IGluZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG5cbiAgY29uc3QgdGFyZ2V0Um93Tm9kZSA9IHRhYmxlUm93c1t0YXJnZXRJbmRleF07XG5cbiAgaWYgKCRpc1RhYmxlUm93Tm9kZSh0YXJnZXRSb3dOb2RlKSkge1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgcm93Q291bnQ7IHIrKykge1xuICAgICAgY29uc3QgdGFibGVSb3dDZWxscyA9IHRhcmdldFJvd05vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIGNvbnN0IHRhYmxlQ29sdW1uQ291bnQgPSB0YWJsZVJvd0NlbGxzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5ld1RhYmxlUm93Tm9kZSA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcblxuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCB0YWJsZUNvbHVtbkNvdW50OyBjKyspIHtcbiAgICAgICAgY29uc3QgdGFibGVDZWxsRnJvbVRhcmdldFJvdyA9IHRhYmxlUm93Q2VsbHNbY107XG5cbiAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbEZyb21UYXJnZXRSb3cpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRhYmxlIGNlbGxgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhYm92ZSxcbiAgICAgICAgICBiZWxvd1xuICAgICAgICB9ID0gJGdldFRhYmxlQ2VsbFNpYmxpbmdzRnJvbVRhYmxlQ2VsbE5vZGUodGFibGVDZWxsRnJvbVRhcmdldFJvdywgZ3JpZCk7XG4gICAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gYWJvdmUgJiYgYWJvdmUuZ2V0V2lkdGgoKSB8fCBiZWxvdyAmJiBiZWxvdy5nZXRXaWR0aCgpIHx8IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoYWJvdmUgJiYgYWJvdmUuaGFzSGVhZGVyU3RhdGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTikgfHwgYmVsb3cgJiYgYmVsb3cuaGFzSGVhZGVyU3RhdGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTikpIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlLCAxLCB3aWR0aCk7XG4gICAgICAgIHRhYmxlQ2VsbE5vZGUuYXBwZW5kKGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgICAgIG5ld1RhYmxlUm93Tm9kZS5hcHBlbmQodGFibGVDZWxsTm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRJbnNlcnRBZnRlcikge1xuICAgICAgICB0YXJnZXRSb3dOb2RlLmluc2VydEFmdGVyKG5ld1RhYmxlUm93Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRSb3dOb2RlLmluc2VydEJlZm9yZShuZXdUYWJsZVJvd05vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvdyBiZWZvcmUgaW5zZXJ0aW9uIGluZGV4IGRvZXMgbm90IGV4aXN0LicpO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cbmZ1bmN0aW9uICRpbnNlcnRUYWJsZUNvbHVtbih0YWJsZU5vZGUsIHRhcmdldEluZGV4LCBzaG91bGRJbnNlcnRBZnRlciA9IHRydWUsIGNvbHVtbkNvdW50LCBncmlkKSB7XG4gIGNvbnN0IHRhYmxlUm93cyA9IHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpO1xuXG4gIGZvciAobGV0IHIgPSAwOyByIDwgdGFibGVSb3dzLmxlbmd0aDsgcisrKSB7XG4gICAgY29uc3QgY3VycmVudFRhYmxlUm93Tm9kZSA9IHRhYmxlUm93c1tyXTtcblxuICAgIGlmICgkaXNUYWJsZVJvd05vZGUoY3VycmVudFRhYmxlUm93Tm9kZSkpIHtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY29sdW1uQ291bnQ7IGMrKykge1xuICAgICAgICBjb25zdCB0YWJsZVJvd0NoaWxkcmVuID0gY3VycmVudFRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpO1xuXG4gICAgICAgIGlmICh0YXJnZXRJbmRleCA+PSB0YWJsZVJvd0NoaWxkcmVuLmxlbmd0aCB8fCB0YXJnZXRJbmRleCA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIGNvbHVtbiB0YXJnZXQgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXRDZWxsID0gdGFibGVSb3dDaGlsZHJlblt0YXJnZXRJbmRleF07XG5cbiAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhcmdldENlbGwpKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRhYmxlIGNlbGxgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHJpZ2h0XG4gICAgICAgIH0gPSAkZ2V0VGFibGVDZWxsU2libGluZ3NGcm9tVGFibGVDZWxsTm9kZSh0YXJnZXRDZWxsLCBncmlkKTtcbiAgICAgICAgbGV0IGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUztcblxuICAgICAgICBpZiAobGVmdCAmJiBsZWZ0Lmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1cpIHx8IHJpZ2h0ICYmIHJpZ2h0Lmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1cpKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5ld1RhYmxlQ2VsbCA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlKTtcbiAgICAgICAgbmV3VGFibGVDZWxsLmFwcGVuZChsZXhpY2FsLiRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuXG4gICAgICAgIGlmIChzaG91bGRJbnNlcnRBZnRlcikge1xuICAgICAgICAgIHRhcmdldENlbGwuaW5zZXJ0QWZ0ZXIobmV3VGFibGVDZWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRDZWxsLmluc2VydEJlZm9yZShuZXdUYWJsZUNlbGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cbmZ1bmN0aW9uICRkZWxldGVUYWJsZUNvbHVtbih0YWJsZU5vZGUsIHRhcmdldEluZGV4KSB7XG4gIGNvbnN0IHRhYmxlUm93cyA9IHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFibGVSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudFRhYmxlUm93Tm9kZSA9IHRhYmxlUm93c1tpXTtcblxuICAgIGlmICgkaXNUYWJsZVJvd05vZGUoY3VycmVudFRhYmxlUm93Tm9kZSkpIHtcbiAgICAgIGNvbnN0IHRhYmxlUm93Q2hpbGRyZW4gPSBjdXJyZW50VGFibGVSb3dOb2RlLmdldENoaWxkcmVuKCk7XG5cbiAgICAgIGlmICh0YXJnZXRJbmRleCA+PSB0YWJsZVJvd0NoaWxkcmVuLmxlbmd0aCB8fCB0YXJnZXRJbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWJsZSBjb2x1bW4gdGFyZ2V0IGluZGV4IG91dCBvZiByYW5nZScpO1xuICAgICAgfVxuXG4gICAgICB0YWJsZVJvd0NoaWxkcmVuW3RhcmdldEluZGV4XS5yZW1vdmUoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuXG4vKiogQG1vZHVsZSBAbGV4aWNhbC90YWJsZSAqL1xuY29uc3QgSU5TRVJUX1RBQkxFX0NPTU1BTkQgPSBsZXhpY2FsLmNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9UQUJMRV9DT01NQU5EJyk7XG5cbmV4cG9ydHMuJGNyZWF0ZVRhYmxlQ2VsbE5vZGUgPSAkY3JlYXRlVGFibGVDZWxsTm9kZTtcbmV4cG9ydHMuJGNyZWF0ZVRhYmxlTm9kZSA9ICRjcmVhdGVUYWJsZU5vZGU7XG5leHBvcnRzLiRjcmVhdGVUYWJsZU5vZGVXaXRoRGltZW5zaW9ucyA9ICRjcmVhdGVUYWJsZU5vZGVXaXRoRGltZW5zaW9ucztcbmV4cG9ydHMuJGNyZWF0ZVRhYmxlUm93Tm9kZSA9ICRjcmVhdGVUYWJsZVJvd05vZGU7XG5leHBvcnRzLiRkZWxldGVUYWJsZUNvbHVtbiA9ICRkZWxldGVUYWJsZUNvbHVtbjtcbmV4cG9ydHMuJGdldEVsZW1lbnRHcmlkRm9yVGFibGVOb2RlID0gJGdldEVsZW1lbnRHcmlkRm9yVGFibGVOb2RlO1xuZXhwb3J0cy4kZ2V0VGFibGVDZWxsTm9kZUZyb21MZXhpY2FsTm9kZSA9ICRnZXRUYWJsZUNlbGxOb2RlRnJvbUxleGljYWxOb2RlO1xuZXhwb3J0cy4kZ2V0VGFibGVDb2x1bW5JbmRleEZyb21UYWJsZUNlbGxOb2RlID0gJGdldFRhYmxlQ29sdW1uSW5kZXhGcm9tVGFibGVDZWxsTm9kZTtcbmV4cG9ydHMuJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3cgPSAkZ2V0VGFibGVOb2RlRnJvbUxleGljYWxOb2RlT3JUaHJvdztcbmV4cG9ydHMuJGdldFRhYmxlUm93SW5kZXhGcm9tVGFibGVDZWxsTm9kZSA9ICRnZXRUYWJsZVJvd0luZGV4RnJvbVRhYmxlQ2VsbE5vZGU7XG5leHBvcnRzLiRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3cgPSAkZ2V0VGFibGVSb3dOb2RlRnJvbVRhYmxlQ2VsbE5vZGVPclRocm93O1xuZXhwb3J0cy4kaW5zZXJ0VGFibGVDb2x1bW4gPSAkaW5zZXJ0VGFibGVDb2x1bW47XG5leHBvcnRzLiRpbnNlcnRUYWJsZVJvdyA9ICRpbnNlcnRUYWJsZVJvdztcbmV4cG9ydHMuJGlzVGFibGVDZWxsTm9kZSA9ICRpc1RhYmxlQ2VsbE5vZGU7XG5leHBvcnRzLiRpc1RhYmxlTm9kZSA9ICRpc1RhYmxlTm9kZTtcbmV4cG9ydHMuJGlzVGFibGVSb3dOb2RlID0gJGlzVGFibGVSb3dOb2RlO1xuZXhwb3J0cy4kcmVtb3ZlVGFibGVSb3dBdEluZGV4ID0gJHJlbW92ZVRhYmxlUm93QXRJbmRleDtcbmV4cG9ydHMuSU5TRVJUX1RBQkxFX0NPTU1BTkQgPSBJTlNFUlRfVEFCTEVfQ09NTUFORDtcbmV4cG9ydHMuVGFibGVDZWxsSGVhZGVyU3RhdGVzID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzO1xuZXhwb3J0cy5UYWJsZUNlbGxOb2RlID0gVGFibGVDZWxsTm9kZTtcbmV4cG9ydHMuVGFibGVOb2RlID0gVGFibGVOb2RlO1xuZXhwb3J0cy5UYWJsZVJvd05vZGUgPSBUYWJsZVJvd05vZGU7XG5leHBvcnRzLlRhYmxlU2VsZWN0aW9uID0gVGFibGVTZWxlY3Rpb247XG5leHBvcnRzLmFwcGx5VGFibGVIYW5kbGVycyA9IGFwcGx5VGFibGVIYW5kbGVycztcbmV4cG9ydHMuZ2V0Q2VsbEZyb21UYXJnZXQgPSBnZXRDZWxsRnJvbVRhcmdldDtcbmV4cG9ydHMuZ2V0VGFibGVTZWxlY3Rpb25Gcm9tVGFibGVFbGVtZW50ID0gZ2V0VGFibGVTZWxlY3Rpb25Gcm9tVGFibGVFbGVtZW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/table/LexicalTable.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/table/LexicalTable.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lexical/table/LexicalTable.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalTable =  true ? __webpack_require__(/*! ./LexicalTable.dev.js */ \"(ssr)/./node_modules/@lexical/table/LexicalTable.dev.js\") : 0\nmodule.exports = LexicalTable;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGFibGUvTGV4aWNhbFRhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1oscUJBQXFCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxzRkFBdUIsSUFBSSxDQUFpQztBQUNsSSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3RhYmxlL0xleGljYWxUYWJsZS5qcz8zYjE0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsVGFibGUgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFRhYmxlLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsVGFibGUucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxUYWJsZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/table/LexicalTable.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/text/LexicalText.dev.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lexical/text/LexicalText.dev.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/text */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n\n  mainLoop: while (node !== null) {\n    if (lexical.$isElementNode(node)) {\n      const child = node.getFirstChild();\n\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if (lexical.$isTextNode(node)) {\n      const characters = node.getTextContentSize();\n\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n\n      currentCharacters += characters;\n    }\n\n    const sibling = node.getNextSibling();\n\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n\n    let parent = node.getParent();\n\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n\n      parent = parent.getParent();\n    }\n\n    break;\n  }\n\n  return null;\n}\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n\n  let text = $rootTextContent();\n\n  if (trim) {\n    text = text.trim();\n  }\n\n  return text === '';\n}\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\nfunction $rootTextContent() {\n  const root = lexical.$getRoot();\n  return root.getTextContent();\n}\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n\n  const root = lexical.$getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n\n  if (childrenLength > 1) {\n    return false;\n  }\n\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n\n    if (lexical.$isElementNode(topBlock)) {\n      if (!lexical.$isParagraphNode(topBlock)) {\n        return false;\n      }\n\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n\n        if (!lexical.$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n\n  const replaceWithSimpleText = node => {\n    const textNode = lexical.$createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n\n  const textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n\n    const prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n\n    if (lexical.$isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    } // eslint-disable-next-line no-constant-condition\n\n\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n\n        if (lexical.$isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      } else {\n        const nextMatch = getMatch(nextText);\n\n        if (nextMatch !== null && nextMatch.start === 0) {\n          return;\n        }\n      }\n\n      if (match === null) {\n        return;\n      }\n\n      if (match.start === 0 && lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        continue;\n      }\n\n      let nodeToReplace;\n\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);\n      }\n\n      const replacementNode = createNode(nodeToReplace);\n      nodeToReplace.replace(replacementNode);\n\n      if (currentNode == null) {\n        return;\n      }\n    }\n  };\n\n  const reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n\n    if (match === null || match.start !== 0) {\n      replaceWithSimpleText(node);\n      return;\n    }\n\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n\n    const prevSibling = node.getPreviousSibling();\n\n    if (lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      replaceWithSimpleText(prevSibling);\n      replaceWithSimpleText(node);\n    }\n\n    const nextSibling = node.getNextSibling();\n\n    if (lexical.$isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      replaceWithSimpleText(nextSibling); // This may have already been converted in the previous block\n\n      if (isTargetNode(node)) {\n        replaceWithSimpleText(node);\n      }\n    }\n  };\n\n  const removePlainTextTransform = editor.registerNodeTransform(lexical.TextNode, textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexports.$canShowPlaceholder = $canShowPlaceholder;\nexports.$canShowPlaceholderCurry = $canShowPlaceholderCurry;\nexports.$findTextIntersectionFromCharacters = $findTextIntersectionFromCharacters;\nexports.$isRootTextContentEmpty = $isRootTextContentEmpty;\nexports.$isRootTextContentEmptyCurry = $isRootTextContentEmptyCurry;\nexports.$rootTextContent = $rootTextContent;\nexports.registerLexicalTextEntity = registerLexicalTextEntity;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGV4dC9MZXhpY2FsVGV4dC5kZXYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLDRCQUE0QjtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQixnQ0FBZ0M7QUFDaEMsMkNBQTJDO0FBQzNDLCtCQUErQjtBQUMvQixvQ0FBb0M7QUFDcEMsd0JBQXdCO0FBQ3hCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3RleHQvTGV4aWNhbFRleHQuZGV2LmpzP2MxNWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xuXG4vKiogQG1vZHVsZSBAbGV4aWNhbC90ZXh0ICovXG5mdW5jdGlvbiAkZmluZFRleHRJbnRlcnNlY3Rpb25Gcm9tQ2hhcmFjdGVycyhyb290LCB0YXJnZXRDaGFyYWN0ZXJzKSB7XG4gIGxldCBub2RlID0gcm9vdC5nZXRGaXJzdENoaWxkKCk7XG4gIGxldCBjdXJyZW50Q2hhcmFjdGVycyA9IDA7XG5cbiAgbWFpbkxvb3A6IHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgY29uc3QgY2hhcmFjdGVycyA9IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG5cbiAgICAgIGlmIChjdXJyZW50Q2hhcmFjdGVycyArIGNoYXJhY3RlcnMgPiB0YXJnZXRDaGFyYWN0ZXJzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IHRhcmdldENoYXJhY3RlcnMgLSBjdXJyZW50Q2hhcmFjdGVyc1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50Q2hhcmFjdGVycyArPSBjaGFyYWN0ZXJzO1xuICAgIH1cblxuICAgIGNvbnN0IHNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgbm9kZSA9IHNpYmxpbmc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBsZXQgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcblxuICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgaWYgKHBhcmVudFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IHBhcmVudFNpYmxpbmc7XG4gICAgICAgIGNvbnRpbnVlIG1haW5Mb29wO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgfVxuXG4gICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5KGlzRWRpdG9yQ29tcG9zaW5nLCB0cmltID0gdHJ1ZSkge1xuICBpZiAoaXNFZGl0b3JDb21wb3NpbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsZXQgdGV4dCA9ICRyb290VGV4dENvbnRlbnQoKTtcblxuICBpZiAodHJpbSkge1xuICAgIHRleHQgPSB0ZXh0LnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiB0ZXh0ID09PSAnJztcbn1cbmZ1bmN0aW9uICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5Q3VycnkoaXNFZGl0b3JDb21wb3NpbmcsIHRyaW0pIHtcbiAgcmV0dXJuICgpID0+ICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5KGlzRWRpdG9yQ29tcG9zaW5nLCB0cmltKTtcbn1cbmZ1bmN0aW9uICRyb290VGV4dENvbnRlbnQoKSB7XG4gIGNvbnN0IHJvb3QgPSBsZXhpY2FsLiRnZXRSb290KCk7XG4gIHJldHVybiByb290LmdldFRleHRDb250ZW50KCk7XG59XG5mdW5jdGlvbiAkY2FuU2hvd1BsYWNlaG9sZGVyKGlzQ29tcG9zaW5nKSB7XG4gIGlmICghJGlzUm9vdFRleHRDb250ZW50RW1wdHkoaXNDb21wb3NpbmcsIGZhbHNlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHJvb3QgPSBsZXhpY2FsLiRnZXRSb290KCk7XG4gIGNvbnN0IGNoaWxkcmVuID0gcm9vdC5nZXRDaGlsZHJlbigpO1xuICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9wQmxvY2sgPSBjaGlsZHJlbltpXTtcblxuICAgIGlmIChsZXhpY2FsLiRpc0VsZW1lbnROb2RlKHRvcEJsb2NrKSkge1xuICAgICAgaWYgKCFsZXhpY2FsLiRpc1BhcmFncmFwaE5vZGUodG9wQmxvY2spKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvcEJsb2NrLl9faW5kZW50ICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9wQmxvY2tDaGlsZHJlbiA9IHRvcEJsb2NrLmdldENoaWxkcmVuKCk7XG4gICAgICBjb25zdCB0b3BCbG9ja0NoaWxkcmVuTGVuZ3RoID0gdG9wQmxvY2tDaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdG9wQmxvY2tDaGlsZHJlbkxlbmd0aDsgcysrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdG9wQmxvY2tDaGlsZHJlbltpXTtcblxuICAgICAgICBpZiAoIWxleGljYWwuJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkY2FuU2hvd1BsYWNlaG9sZGVyQ3VycnkoaXNFZGl0b3JDb21wb3NpbmcpIHtcbiAgcmV0dXJuICgpID0+ICRjYW5TaG93UGxhY2Vob2xkZXIoaXNFZGl0b3JDb21wb3NpbmcpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eShlZGl0b3IsIGdldE1hdGNoLCB0YXJnZXROb2RlLCBjcmVhdGVOb2RlKSB7XG4gIGNvbnN0IGlzVGFyZ2V0Tm9kZSA9IG5vZGUgPT4ge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgdGFyZ2V0Tm9kZTtcbiAgfTtcblxuICBjb25zdCByZXBsYWNlV2l0aFNpbXBsZVRleHQgPSBub2RlID0+IHtcbiAgICBjb25zdCB0ZXh0Tm9kZSA9IGxleGljYWwuJGNyZWF0ZVRleHROb2RlKG5vZGUuZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgdGV4dE5vZGUuc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0KCkpO1xuICAgIG5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gIH07XG5cbiAgY29uc3QgZ2V0TW9kZSA9IG5vZGUgPT4ge1xuICAgIHJldHVybiBub2RlLmdldExhdGVzdCgpLl9fbW9kZTtcbiAgfTtcblxuICBjb25zdCB0ZXh0Tm9kZVRyYW5zZm9ybSA9IG5vZGUgPT4ge1xuICAgIGlmICghbm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBsZXQgdGV4dCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuICAgIGxldCBtYXRjaDtcblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgY29uc3QgcHJldmlvdXNUZXh0ID0gcHJldlNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgIGNvbnN0IGNvbWJpbmVkVGV4dCA9IHByZXZpb3VzVGV4dCArIHRleHQ7XG4gICAgICBjb25zdCBwcmV2TWF0Y2ggPSBnZXRNYXRjaChjb21iaW5lZFRleHQpO1xuXG4gICAgICBpZiAoaXNUYXJnZXROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgICBpZiAocHJldk1hdGNoID09PSBudWxsIHx8IGdldE1vZGUocHJldlNpYmxpbmcpICE9PSAwKSB7XG4gICAgICAgICAgcmVwbGFjZVdpdGhTaW1wbGVUZXh0KHByZXZTaWJsaW5nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZGlmZiA9IHByZXZNYXRjaC5lbmQgLSBwcmV2aW91c1RleHQubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjb25jYXRUZXh0ID0gdGV4dC5zbGljZSgwLCBkaWZmKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RleHRDb250ZW50ID0gcHJldmlvdXNUZXh0ICsgY29uY2F0VGV4dDtcbiAgICAgICAgICAgIHByZXZTaWJsaW5nLnNlbGVjdCgpO1xuICAgICAgICAgICAgcHJldlNpYmxpbmcuc2V0VGV4dENvbnRlbnQobmV3VGV4dENvbnRlbnQpO1xuXG4gICAgICAgICAgICBpZiAoZGlmZiA9PT0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1RleHQgPSB0ZXh0LnNsaWNlKGRpZmYpO1xuICAgICAgICAgICAgICBub2RlLnNldFRleHRDb250ZW50KHJlbWFpbmluZ1RleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXZNYXRjaCA9PT0gbnVsbCB8fCBwcmV2TWF0Y2guc3RhcnQgPCBwcmV2aW91c1RleHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cblxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIG1hdGNoID0gZ2V0TWF0Y2godGV4dCk7XG4gICAgICBsZXQgbmV4dFRleHQgPSBtYXRjaCA9PT0gbnVsbCA/ICcnIDogdGV4dC5zbGljZShtYXRjaC5lbmQpO1xuICAgICAgdGV4dCA9IG5leHRUZXh0O1xuXG4gICAgICBpZiAobmV4dFRleHQgPT09ICcnKSB7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gY3VycmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgICBpZiAobGV4aWNhbC4kaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgICAgICBuZXh0VGV4dCA9IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50KCkgKyBuZXh0U2libGluZy5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICAgIGNvbnN0IG5leHRNYXRjaCA9IGdldE1hdGNoKG5leHRUZXh0KTtcblxuICAgICAgICAgIGlmIChuZXh0TWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpc1RhcmdldE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgIHJlcGxhY2VXaXRoU2ltcGxlVGV4dChuZXh0U2libGluZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXh0U2libGluZy5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dE1hdGNoLnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXh0TWF0Y2ggPSBnZXRNYXRjaChuZXh0VGV4dCk7XG5cbiAgICAgICAgaWYgKG5leHRNYXRjaCAhPT0gbnVsbCAmJiBuZXh0TWF0Y2guc3RhcnQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoLnN0YXJ0ID09PSAwICYmIGxleGljYWwuJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpICYmIHByZXZTaWJsaW5nLmlzVGV4dEVudGl0eSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgbm9kZVRvUmVwbGFjZTtcblxuICAgICAgaWYgKG1hdGNoLnN0YXJ0ID09PSAwKSB7XG4gICAgICAgIFtub2RlVG9SZXBsYWNlLCBjdXJyZW50Tm9kZV0gPSBjdXJyZW50Tm9kZS5zcGxpdFRleHQobWF0Y2guZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFssIG5vZGVUb1JlcGxhY2UsIGN1cnJlbnROb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVwbGFjZW1lbnROb2RlID0gY3JlYXRlTm9kZShub2RlVG9SZXBsYWNlKTtcbiAgICAgIG5vZGVUb1JlcGxhY2UucmVwbGFjZShyZXBsYWNlbWVudE5vZGUpO1xuXG4gICAgICBpZiAoY3VycmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJldmVyc2VOb2RlVHJhbnNmb3JtID0gbm9kZSA9PiB7XG4gICAgY29uc3QgdGV4dCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBjb25zdCBtYXRjaCA9IGdldE1hdGNoKHRleHQpO1xuXG4gICAgaWYgKG1hdGNoID09PSBudWxsIHx8IG1hdGNoLnN0YXJ0ICE9PSAwKSB7XG4gICAgICByZXBsYWNlV2l0aFNpbXBsZVRleHQobm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRleHQubGVuZ3RoID4gbWF0Y2guZW5kKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgc3BsaXQgb3V0IHRoZSByZXN0IG9mIHRoZSB0ZXh0IGFzIHNpbXBsZSB0ZXh0XG4gICAgICBub2RlLnNwbGl0VGV4dChtYXRjaC5lbmQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKHByZXZTaWJsaW5nKSAmJiBwcmV2U2libGluZy5pc1RleHRFbnRpdHkoKSkge1xuICAgICAgcmVwbGFjZVdpdGhTaW1wbGVUZXh0KHByZXZTaWJsaW5nKTtcbiAgICAgIHJlcGxhY2VXaXRoU2ltcGxlVGV4dChub2RlKTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKG5leHRTaWJsaW5nKSAmJiBuZXh0U2libGluZy5pc1RleHRFbnRpdHkoKSkge1xuICAgICAgcmVwbGFjZVdpdGhTaW1wbGVUZXh0KG5leHRTaWJsaW5nKTsgLy8gVGhpcyBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY29udmVydGVkIGluIHRoZSBwcmV2aW91cyBibG9ja1xuXG4gICAgICBpZiAoaXNUYXJnZXROb2RlKG5vZGUpKSB7XG4gICAgICAgIHJlcGxhY2VXaXRoU2ltcGxlVGV4dChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVtb3ZlUGxhaW5UZXh0VHJhbnNmb3JtID0gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShsZXhpY2FsLlRleHROb2RlLCB0ZXh0Tm9kZVRyYW5zZm9ybSk7XG4gIGNvbnN0IHJlbW92ZVJldmVyc2VOb2RlVHJhbnNmb3JtID0gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybSh0YXJnZXROb2RlLCByZXZlcnNlTm9kZVRyYW5zZm9ybSk7XG4gIHJldHVybiBbcmVtb3ZlUGxhaW5UZXh0VHJhbnNmb3JtLCByZW1vdmVSZXZlcnNlTm9kZVRyYW5zZm9ybV07XG59XG5cbmV4cG9ydHMuJGNhblNob3dQbGFjZWhvbGRlciA9ICRjYW5TaG93UGxhY2Vob2xkZXI7XG5leHBvcnRzLiRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeSA9ICRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeTtcbmV4cG9ydHMuJGZpbmRUZXh0SW50ZXJzZWN0aW9uRnJvbUNoYXJhY3RlcnMgPSAkZmluZFRleHRJbnRlcnNlY3Rpb25Gcm9tQ2hhcmFjdGVycztcbmV4cG9ydHMuJGlzUm9vdFRleHRDb250ZW50RW1wdHkgPSAkaXNSb290VGV4dENvbnRlbnRFbXB0eTtcbmV4cG9ydHMuJGlzUm9vdFRleHRDb250ZW50RW1wdHlDdXJyeSA9ICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5Q3Vycnk7XG5leHBvcnRzLiRyb290VGV4dENvbnRlbnQgPSAkcm9vdFRleHRDb250ZW50O1xuZXhwb3J0cy5yZWdpc3RlckxleGljYWxUZXh0RW50aXR5ID0gcmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/text/LexicalText.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/text/LexicalText.js":
/*!***************************************************!*\
  !*** ./node_modules/@lexical/text/LexicalText.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalText =  true ? __webpack_require__(/*! ./LexicalText.dev.js */ \"(ssr)/./node_modules/@lexical/text/LexicalText.dev.js\") : 0\nmodule.exports = LexicalText;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGV4dC9MZXhpY2FsVGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDWTtBQUNaLG9CQUFvQixLQUFzQyxHQUFHLG1CQUFPLENBQUMsbUZBQXNCLElBQUksQ0FBZ0M7QUFDL0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90ZXh0L0xleGljYWxUZXh0LmpzP2MxMGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCdcbmNvbnN0IExleGljYWxUZXh0ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWxUZXh0LmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsVGV4dC5wcm9kLmpzJylcbm1vZHVsZS5leHBvcnRzID0gTGV4aWNhbFRleHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/text/LexicalText.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.dev.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar selection = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.js\");\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\n\n/** @module @lexical/utils */\nfunction addClassNamesToElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      const classesToAdd = className.split(' ').filter(n => n !== '');\n      element.classList.add(...classesToAdd);\n    }\n  });\n}\nfunction removeClassNamesFromElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\n\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n\n      if (done) {\n        return resolve(processed);\n      }\n\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n\n        handleNextFile();\n      });\n\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n\n    handleNextFile();\n  });\n}\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n\n  return nodes;\n}\n\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n\n  return depth;\n}\n\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return null;\n}\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n\n  return blockNode;\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n\n    let parentNode = node;\n    let childNode = node;\n\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n\n    return null;\n  };\n\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match; // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = selection.$cloneWithProperties(node);\n\n    if (lexical.$isTextNode(clone)) {\n      clone.__text = node.__text;\n    }\n\n    nodeMap.set(key, clone);\n  }\n\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n\n  editor._dirtyType = FULL_RECONCILE;\n  const selection$1 = editorState._selection;\n  lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\n}\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection();\n\n  if (lexical.$isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n\n      if (lexical.$isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n\n      const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = lexical.$getRoot();\n      root.append(node);\n    }\n\n    const paragraphNode = lexical.$createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n\n  return node.getLatest();\n}\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\n\nexports.$splitNode = lexical.$splitNode;\nexports.$dfs = $dfs;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.isHTMLAnchorElement = isHTMLAnchorElement;\nexports.isHTMLElement = isHTMLElement;\nexports.isMimeType = isMimeType;\nexports.mediaFileReader = mediaFileReader;\nexports.mergeRegister = mergeRegister;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQyx1RkFBb0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLHdEQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLDJCQUEyQjtBQUMzQiw4Q0FBOEM7QUFDOUMsNkJBQTZCO0FBQzdCLGdDQUFnQztBQUNoQywyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5QiwyQkFBMkI7QUFDM0IscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLHFDQUFxQztBQUNyQyxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbXNfY3JlYXRvci8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC91dGlscy9MZXhpY2FsVXRpbHMuZGV2LmpzP2QxMDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzZWxlY3Rpb24gPSByZXF1aXJlKCdAbGV4aWNhbC9zZWxlY3Rpb24nKTtcbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xuXG4vKiogQG1vZHVsZSBAbGV4aWNhbC91dGlscyAqL1xuZnVuY3Rpb24gYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCAuLi5jbGFzc05hbWVzKSB7XG4gIGNsYXNzTmFtZXMuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgY2xhc3Nlc1RvQWRkID0gY2xhc3NOYW1lLnNwbGl0KCcgJykuZmlsdGVyKG4gPT4gbiAhPT0gJycpO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXNUb0FkZCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCAuLi5jbGFzc05hbWVzKSB7XG4gIGNsYXNzTmFtZXMuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZS5zcGxpdCgnICcpKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNNaW1lVHlwZShmaWxlLCBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gIGZvciAoY29uc3QgYWNjZXB0YWJsZVR5cGUgb2YgYWNjZXB0YWJsZU1pbWVUeXBlcykge1xuICAgIGlmIChmaWxlLnR5cGUuc3RhcnRzV2l0aChhY2NlcHRhYmxlVHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogTGV4aWNhbCBGaWxlIFJlYWRlciB3aXRoOlxuICogIDEuIE1JTUUgdHlwZSBzdXBwb3J0XG4gKiAgMi4gYmF0Y2hlZCByZXN1bHRzIChIaXN0b3J5UGx1Z2luIGNvbXBhdGliaWxpdHkpXG4gKiAgMy4gT3JkZXIgYXdhcmUgKHJlc3BlY3RzIHRoZSBvcmRlciB3aGVuIG11bHRpcGxlIEZpbGVzIGFyZSBwYXNzZWQpXG4gKlxuICogY29uc3QgZmlsZXNSZXN1bHQgPSBhd2FpdCBtZWRpYUZpbGVSZWFkZXIoZmlsZXMsIFsnaW1hZ2UvJ10pO1xuICogZmlsZXNSZXN1bHQuZm9yRWFjaChmaWxlID0+IGVkaXRvci5kaXNwYXRjaENvbW1hbmQoJ0lOU0VSVF9JTUFHRScsIHtcbiAqICAgc3JjOiBmaWxlLnJlc3VsdCxcbiAqIH0pKTtcbiAqL1xuXG5mdW5jdGlvbiBtZWRpYUZpbGVSZWFkZXIoZmlsZXMsIGFjY2VwdGFibGVNaW1lVHlwZXMpIHtcbiAgY29uc3QgZmlsZXNJdGVyYXRvciA9IGZpbGVzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBwcm9jZXNzZWQgPSBbXTtcblxuICAgIGNvbnN0IGhhbmRsZU5leHRGaWxlID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkb25lLFxuICAgICAgICB2YWx1ZTogZmlsZVxuICAgICAgfSA9IGZpbGVzSXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShwcm9jZXNzZWQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCByZWplY3QpO1xuICAgICAgZmlsZVJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBmaWxlUmVhZGVyLnJlc3VsdDtcblxuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwcm9jZXNzZWQucHVzaCh7XG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGVOZXh0RmlsZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpc01pbWVUeXBlKGZpbGUsIGFjY2VwdGFibGVNaW1lVHlwZXMpKSB7XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gJGRmcyhzdGFydGluZ05vZGUsIGVuZGluZ05vZGUpIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgY29uc3Qgc3RhcnQgPSAoc3RhcnRpbmdOb2RlIHx8IGxleGljYWwuJGdldFJvb3QoKSkuZ2V0TGF0ZXN0KCk7XG4gIGNvbnN0IGVuZCA9IGVuZGluZ05vZGUgfHwgKGxleGljYWwuJGlzRWxlbWVudE5vZGUoc3RhcnQpID8gc3RhcnQuZ2V0TGFzdERlc2NlbmRhbnQoKSA6IHN0YXJ0KTtcbiAgbGV0IG5vZGUgPSBzdGFydDtcbiAgbGV0IGRlcHRoID0gJGdldERlcHRoKG5vZGUpO1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsICYmICFub2RlLmlzKGVuZCkpIHtcbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGRlcHRoLFxuICAgICAgbm9kZVxuICAgIH0pO1xuXG4gICAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5nZXRDaGlsZHJlblNpemUoKSA+IDApIHtcbiAgICAgIG5vZGUgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGRlcHRoKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgaW1tZWRpYXRlIHNpYmxpbmcgb3IgbmVhcmVzdCBwYXJlbnQgc2libGluZ1xuICAgICAgbGV0IHNpYmxpbmcgPSBudWxsO1xuXG4gICAgICB3aGlsZSAoc2libGluZyA9PT0gbnVsbCAmJiBub2RlICE9PSBudWxsKSB7XG4gICAgICAgIHNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICAgICAgaWYgKHNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSBzaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGUgIT09IG51bGwgJiYgbm9kZS5pcyhlbmQpKSB7XG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBkZXB0aCxcbiAgICAgIG5vZGVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn1cblxuZnVuY3Rpb24gJGdldERlcHRoKG5vZGUpIHtcbiAgbGV0IGlubmVyTm9kZSA9IG5vZGU7XG4gIGxldCBkZXB0aCA9IDA7XG5cbiAgd2hpbGUgKChpbm5lck5vZGUgPSBpbm5lck5vZGUuZ2V0UGFyZW50KCkpICE9PSBudWxsKSB7XG4gICAgZGVwdGgrKztcbiAgfVxuXG4gIHJldHVybiBkZXB0aDtcbn1cblxuZnVuY3Rpb24gJGdldE5lYXJlc3ROb2RlT2ZUeXBlKG5vZGUsIGtsYXNzKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuXG4gIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBrbGFzcykge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93KHN0YXJ0Tm9kZSkge1xuICBjb25zdCBibG9ja05vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0Tm9kZSwgbm9kZSA9PiBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuXG4gIGlmICghbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShibG9ja05vZGUpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIG5vZGUgJHtzdGFydE5vZGUuX19rZXl9IHRvIGhhdmUgY2xvc2VzdCBibG9jayBlbGVtZW50IG5vZGUuYCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJsb2NrTm9kZTtcbn1cbmZ1bmN0aW9uICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnRpbmdOb2RlLCBmaW5kRm4pIHtcbiAgbGV0IGN1cnIgPSBzdGFydGluZ05vZGU7XG5cbiAgd2hpbGUgKGN1cnIgIT09IGxleGljYWwuJGdldFJvb3QoKSAmJiBjdXJyICE9IG51bGwpIHtcbiAgICBpZiAoZmluZEZuKGN1cnIpKSB7XG4gICAgICByZXR1cm4gY3VycjtcbiAgICB9XG5cbiAgICBjdXJyID0gY3Vyci5nZXRQYXJlbnQoKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWVyZ2VSZWdpc3RlciguLi5mdW5jKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZnVuYy5mb3JFYWNoKGYgPT4gZigpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyKGVkaXRvciwgdGFyZ2V0Tm9kZSwgY2xvbmVOb2RlLCBoYW5kbGVPdmVybGFwKSB7XG4gIGNvbnN0ICRpc1RhcmdldE5vZGUgPSBub2RlID0+IHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIHRhcmdldE5vZGU7XG4gIH07XG5cbiAgY29uc3QgJGZpbmRNYXRjaCA9IG5vZGUgPT4ge1xuICAgIC8vIEZpcnN0IHZhbGlkYXRlIHdlIGRvbid0IGhhdmUgYW55IGNoaWxkcmVuIHRoYXQgYXJlIG9mIHRoZSB0YXJnZXQsXG4gICAgLy8gYXMgd2UgbmVlZCB0byBoYW5kbGUgdGhlbSBmaXJzdC5cbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmICgkaXNUYXJnZXROb2RlKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgbGV0IGNoaWxkTm9kZSA9IG5vZGU7XG5cbiAgICB3aGlsZSAocGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2hpbGROb2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLmdldFBhcmVudCgpO1xuXG4gICAgICBpZiAoJGlzVGFyZ2V0Tm9kZShwYXJlbnROb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoaWxkOiBjaGlsZE5vZGUsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgY29uc3QgZWxlbWVudE5vZGVUcmFuc2Zvcm0gPSBub2RlID0+IHtcbiAgICBjb25zdCBtYXRjaCA9ICRmaW5kTWF0Y2gobm9kZSk7XG5cbiAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIHBhcmVudFxuICAgICAgfSA9IG1hdGNoOyAvLyBTaW1wbGUgcGF0aCwgd2UgY2FuIG1vdmUgY2hpbGQgb3V0IGFuZCBzaWJsaW5ncyBpbnRvIGEgbmV3IHBhcmVudC5cblxuICAgICAgaWYgKGNoaWxkLmlzKG5vZGUpKSB7XG4gICAgICAgIGhhbmRsZU92ZXJsYXAocGFyZW50LCBub2RlKTtcbiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmdzID0gY2hpbGQuZ2V0TmV4dFNpYmxpbmdzKCk7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5nc0xlbmd0aCA9IG5leHRTaWJsaW5ncy5sZW5ndGg7XG4gICAgICAgIHBhcmVudC5pbnNlcnRBZnRlcihjaGlsZCk7XG5cbiAgICAgICAgaWYgKG5leHRTaWJsaW5nc0xlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGNvbnN0IG5ld1BhcmVudCA9IGNsb25lTm9kZShwYXJlbnQpO1xuICAgICAgICAgIGNoaWxkLmluc2VydEFmdGVyKG5ld1BhcmVudCk7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRTaWJsaW5nc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBuZXdQYXJlbnQuYXBwZW5kKG5leHRTaWJsaW5nc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYXJlbnQuY2FuQmVFbXB0eSgpICYmIHBhcmVudC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkge1xuICAgICAgICAgIHBhcmVudC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybSh0YXJnZXROb2RlLCBlbGVtZW50Tm9kZVRyYW5zZm9ybSk7XG59XG5mdW5jdGlvbiAkcmVzdG9yZUVkaXRvclN0YXRlKGVkaXRvciwgZWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgRlVMTF9SRUNPTkNJTEUgPSAyO1xuICBjb25zdCBub2RlTWFwID0gbmV3IE1hcCgpO1xuICBjb25zdCBhY3RpdmVFZGl0b3JTdGF0ZSA9IGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlO1xuXG4gIGZvciAoY29uc3QgW2tleSwgbm9kZV0gb2YgZWRpdG9yU3RhdGUuX25vZGVNYXApIHtcbiAgICBjb25zdCBjbG9uZSA9IHNlbGVjdGlvbi4kY2xvbmVXaXRoUHJvcGVydGllcyhub2RlKTtcblxuICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGNsb25lKSkge1xuICAgICAgY2xvbmUuX190ZXh0ID0gbm9kZS5fX3RleHQ7XG4gICAgfVxuXG4gICAgbm9kZU1hcC5zZXQoa2V5LCBjbG9uZSk7XG4gIH1cblxuICBpZiAoYWN0aXZlRWRpdG9yU3RhdGUpIHtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZS5fbm9kZU1hcCA9IG5vZGVNYXA7XG4gIH1cblxuICBlZGl0b3IuX2RpcnR5VHlwZSA9IEZVTExfUkVDT05DSUxFO1xuICBjb25zdCBzZWxlY3Rpb24kMSA9IGVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGxleGljYWwuJHNldFNlbGVjdGlvbihzZWxlY3Rpb24kMSA9PT0gbnVsbCA/IG51bGwgOiBzZWxlY3Rpb24kMS5jbG9uZSgpKTtcbn1cbmZ1bmN0aW9uICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdChub2RlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGxleGljYWwuJGdldFNlbGVjdGlvbigpO1xuXG4gIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCB7XG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuXG4gICAgaWYgKGxleGljYWwuJGlzUm9vdE9yU2hhZG93Um9vdChmb2N1c05vZGUpKSB7XG4gICAgICBjb25zdCBmb2N1c0NoaWxkID0gZm9jdXNOb2RlLmdldENoaWxkQXRJbmRleChmb2N1c09mZnNldCk7XG5cbiAgICAgIGlmIChmb2N1c0NoaWxkID09IG51bGwpIHtcbiAgICAgICAgZm9jdXNOb2RlLmFwcGVuZChub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvY3VzQ2hpbGQuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNlbGVjdE5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHNwbGl0Tm9kZTtcbiAgICAgIGxldCBzcGxpdE9mZnNldDtcblxuICAgICAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUoZm9jdXNOb2RlKSkge1xuICAgICAgICBzcGxpdE5vZGUgPSBmb2N1c05vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICBzcGxpdE9mZnNldCA9IGZvY3VzTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuXG4gICAgICAgIGlmIChmb2N1c09mZnNldCA+IDApIHtcbiAgICAgICAgICBzcGxpdE9mZnNldCArPSAxO1xuICAgICAgICAgIGZvY3VzTm9kZS5zcGxpdFRleHQoZm9jdXNPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGxpdE5vZGUgPSBmb2N1c05vZGU7XG4gICAgICAgIHNwbGl0T2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFssIHJpZ2h0VHJlZV0gPSBsZXhpY2FsLiRzcGxpdE5vZGUoc3BsaXROb2RlLCBzcGxpdE9mZnNldCk7XG4gICAgICByaWdodFRyZWUuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgcmlnaHRUcmVlLnNlbGVjdFN0YXJ0KCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChsZXhpY2FsLiRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBsZXhpY2FsLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0uZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdygpLmluc2VydEFmdGVyKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByb290ID0gbGV4aWNhbC4kZ2V0Um9vdCgpO1xuICAgICAgcm9vdC5hcHBlbmQobm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9IGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBub2RlLmluc2VydEFmdGVyKHBhcmFncmFwaE5vZGUpO1xuICAgIHBhcmFncmFwaE5vZGUuc2VsZWN0KCk7XG4gIH1cblxuICByZXR1cm4gbm9kZS5nZXRMYXRlc3QoKTtcbn1cbmZ1bmN0aW9uICR3cmFwTm9kZUluRWxlbWVudChub2RlLCBjcmVhdGVFbGVtZW50Tm9kZSkge1xuICBjb25zdCBlbGVtZW50Tm9kZSA9IGNyZWF0ZUVsZW1lbnROb2RlKCk7XG4gIG5vZGUucmVwbGFjZShlbGVtZW50Tm9kZSk7XG4gIGVsZW1lbnROb2RlLmFwcGVuZChub2RlKTtcbiAgcmV0dXJuIGVsZW1lbnROb2RlO1xufVxuZnVuY3Rpb24gaXNIVE1MQW5jaG9yRWxlbWVudCh4KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KHgpICYmIHgudGFnTmFtZSA9PT0gJ0EnO1xufVxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh4KSB7XG4gIC8vIEB0cy1pZ25vcmUtbmV4dC1saW5lIC0gc3RyaWN0IGNoZWNrIG9uIG5vZGVUeXBlIGhlcmUgc2hvdWxkIGZpbHRlciBvdXQgbm9uLUVsZW1lbnQgRXZlbnRUYXJnZXQgaW1wbGVtZW50b3JzXG4gIHJldHVybiB4Lm5vZGVUeXBlID09PSAxO1xufVxuXG5leHBvcnRzLiRzcGxpdE5vZGUgPSBsZXhpY2FsLiRzcGxpdE5vZGU7XG5leHBvcnRzLiRkZnMgPSAkZGZzO1xuZXhwb3J0cy4kZmluZE1hdGNoaW5nUGFyZW50ID0gJGZpbmRNYXRjaGluZ1BhcmVudDtcbmV4cG9ydHMuJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3cgPSAkZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdztcbmV4cG9ydHMuJGdldE5lYXJlc3ROb2RlT2ZUeXBlID0gJGdldE5lYXJlc3ROb2RlT2ZUeXBlO1xuZXhwb3J0cy4kaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3QgPSAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3Q7XG5leHBvcnRzLiRyZXN0b3JlRWRpdG9yU3RhdGUgPSAkcmVzdG9yZUVkaXRvclN0YXRlO1xuZXhwb3J0cy4kd3JhcE5vZGVJbkVsZW1lbnQgPSAkd3JhcE5vZGVJbkVsZW1lbnQ7XG5leHBvcnRzLmFkZENsYXNzTmFtZXNUb0VsZW1lbnQgPSBhZGRDbGFzc05hbWVzVG9FbGVtZW50O1xuZXhwb3J0cy5pc0hUTUxBbmNob3JFbGVtZW50ID0gaXNIVE1MQW5jaG9yRWxlbWVudDtcbmV4cG9ydHMuaXNIVE1MRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQ7XG5leHBvcnRzLmlzTWltZVR5cGUgPSBpc01pbWVUeXBlO1xuZXhwb3J0cy5tZWRpYUZpbGVSZWFkZXIgPSBtZWRpYUZpbGVSZWFkZXI7XG5leHBvcnRzLm1lcmdlUmVnaXN0ZXIgPSBtZXJnZVJlZ2lzdGVyO1xuZXhwb3J0cy5yZWdpc3Rlck5lc3RlZEVsZW1lbnRSZXNvbHZlciA9IHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyO1xuZXhwb3J0cy5yZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQgPSByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/utils/LexicalUtils.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalUtils =  true ? __webpack_require__(/*! ./LexicalUtils.dev.js */ \"(ssr)/./node_modules/@lexical/utils/LexicalUtils.dev.js\") : 0\nmodule.exports = LexicalUtils;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1oscUJBQXFCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxzRkFBdUIsSUFBSSxDQUFpQztBQUNsSSIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3V0aWxzL0xleGljYWxVdGlscy5qcz84MGVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsVXRpbHMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyA/IHJlcXVpcmUoJy4vTGV4aWNhbFV0aWxzLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsVXRpbHMucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWxVdGlsczsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/utils/LexicalUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/yjs/LexicalYjs.dev.js":
/*!*****************************************************!*\
  !*** ./node_modules/@lexical/yjs/LexicalYjs.dev.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar lexical = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/lexical/Lexical.js\");\nvar yjs = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\nvar selection = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/@lexical/selection/LexicalSelection.js\");\nvar offset = __webpack_require__(/*! @lexical/offset */ \"(ssr)/./node_modules/@lexical/offset/LexicalOffset.js\");\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass CollabLineBreakNode {\n  constructor(map, parent) {\n    this._key = '';\n    this._map = map;\n    this._parent = parent;\n    this._type = 'linebreak';\n  }\n\n  getNode() {\n    const node = lexical.$getNodeByKey(this._key);\n    return lexical.$isLineBreakNode(node) ? node : null;\n  }\n\n  getKey() {\n    return this._key;\n  }\n\n  getSharedType() {\n    return this._map;\n  }\n\n  getType() {\n    return this._type;\n  }\n\n  getSize() {\n    return 1;\n  }\n\n  getOffset() {\n    const collabElementNode = this._parent;\n    return collabElementNode.getChildOffset(this);\n  }\n\n  destroy(binding) {\n    const collabNodeMap = binding.collabNodeMap;\n    collabNodeMap.delete(this._key);\n  }\n\n}\nfunction $createCollabLineBreakNode(map, parent) {\n  const collabNode = new CollabLineBreakNode(map, parent); // @ts-expect-error: internal field\n\n  map._collabNode = collabNode;\n  return collabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction simpleDiffWithCursor(a, b, cursor) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0; // number of same characters counting from left\n\n  let right = 0; // number of same characters counting from right\n  // Iterate left to the right until we find a changed character\n  // First iteration considers the current cursor position\n\n  while (left < aLength && left < bLength && a[left] === b[left] && left < cursor) {\n    left++;\n  } // Iterate right to the left until we find a changed character\n\n\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  } // Try to iterate left further to the right without caring about the current cursor position\n\n\n  while (right + left < aLength && right + left < bLength && a[left] === b[left]) {\n    left++;\n  }\n\n  return {\n    index: left,\n    insert: b.slice(left, bLength - right),\n    remove: aLength - left - right\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction diffTextContentAndApplyDelta(collabNode, key, prevText, nextText) {\n  const selection = lexical.$getSelection();\n  let cursorOffset = nextText.length;\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed()) {\n    const anchor = selection.anchor;\n\n    if (anchor.key === key) {\n      cursorOffset = anchor.offset;\n    }\n  }\n\n  const diff = simpleDiffWithCursor(prevText, nextText, cursorOffset);\n  collabNode.spliceText(diff.index, diff.remove, diff.insert);\n}\n\nclass CollabTextNode {\n  constructor(map, text, parent, type) {\n    this._key = '';\n    this._map = map;\n    this._parent = parent;\n    this._text = text;\n    this._type = type;\n    this._normalized = false;\n  }\n\n  getPrevNode(nodeMap) {\n    if (nodeMap === null) {\n      return null;\n    }\n\n    const node = nodeMap.get(this._key);\n    return lexical.$isTextNode(node) ? node : null;\n  }\n\n  getNode() {\n    const node = lexical.$getNodeByKey(this._key);\n    return lexical.$isTextNode(node) ? node : null;\n  }\n\n  getSharedType() {\n    return this._map;\n  }\n\n  getType() {\n    return this._type;\n  }\n\n  getKey() {\n    return this._key;\n  }\n\n  getSize() {\n    return this._text.length + (this._normalized ? 0 : 1);\n  }\n\n  getOffset() {\n    const collabElementNode = this._parent;\n    return collabElementNode.getChildOffset(this);\n  }\n\n  spliceText(index, delCount, newText) {\n    const collabElementNode = this._parent;\n    const xmlText = collabElementNode._xmlText;\n    const offset = this.getOffset() + 1 + index;\n\n    if (delCount !== 0) {\n      xmlText.delete(offset, delCount);\n    }\n\n    if (newText !== '') {\n      xmlText.insert(offset, newText);\n    }\n  }\n\n  syncPropertiesAndTextFromLexical(binding, nextLexicalNode, prevNodeMap) {\n    const prevLexicalNode = this.getPrevNode(prevNodeMap);\n    const nextText = nextLexicalNode.__text;\n    syncPropertiesFromLexical(binding, this._map, prevLexicalNode, nextLexicalNode);\n\n    if (prevLexicalNode !== null) {\n      const prevText = prevLexicalNode.__text;\n\n      if (prevText !== nextText) {\n        const key = nextLexicalNode.__key;\n        diffTextContentAndApplyDelta(this, key, prevText, nextText);\n        this._text = nextText;\n      }\n    }\n  }\n\n  syncPropertiesAndTextFromYjs(binding, keysChanged) {\n    const lexicalNode = this.getNode();\n\n    if (!(lexicalNode !== null)) {\n      throw Error(`syncPropertiesAndTextFromYjs: cound not find decorator node`);\n    }\n\n    syncPropertiesFromYjs(binding, this._map, lexicalNode, keysChanged);\n    const collabText = this._text;\n\n    if (lexicalNode.__text !== collabText) {\n      const writable = lexicalNode.getWritable();\n      writable.__text = collabText;\n    }\n  }\n\n  destroy(binding) {\n    const collabNodeMap = binding.collabNodeMap;\n    collabNodeMap.delete(this._key);\n  }\n\n}\nfunction $createCollabTextNode(map, text, parent, type) {\n  const collabNode = new CollabTextNode(map, text, parent, type); // @ts-expect-error: internal field\n\n  map._collabNode = collabNode;\n  return collabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst excludedProperties = new Set(['__key', '__parent', '__cachedText', '__text', '__size', '__next', '__prev', '__first', '__last']);\nfunction $getNodeByKeyOrThrow(key) {\n  const node = lexical.$getNodeByKey(key);\n\n  if (!(node !== null)) {\n    throw Error(`could not find node by key`);\n  }\n\n  return node;\n}\nfunction $createCollabNodeFromLexicalNode(binding, lexicalNode, parent) {\n  const nodeType = lexicalNode.__type;\n  let collabNode;\n\n  if (lexical.$isElementNode(lexicalNode)) {\n    const xmlText = new yjs.XmlText();\n    collabNode = $createCollabElementNode(xmlText, parent, nodeType);\n    collabNode.syncPropertiesFromLexical(binding, lexicalNode, null);\n    collabNode.syncChildrenFromLexical(binding, lexicalNode, null, null, null);\n  } else if (lexical.$isTextNode(lexicalNode)) {\n    // TODO create a token text node for token, segmented nodes.\n    const map = new yjs.Map();\n    collabNode = $createCollabTextNode(map, lexicalNode.__text, parent, nodeType);\n    collabNode.syncPropertiesAndTextFromLexical(binding, lexicalNode, null);\n  } else if (lexical.$isLineBreakNode(lexicalNode)) {\n    const map = new yjs.Map();\n    map.set('__type', 'linebreak');\n    collabNode = $createCollabLineBreakNode(map, parent);\n  } else if (lexical.$isDecoratorNode(lexicalNode)) {\n    const xmlElem = new yjs.XmlElement();\n    collabNode = $createCollabDecoratorNode(xmlElem, parent, nodeType);\n    collabNode.syncPropertiesFromLexical(binding, lexicalNode, null);\n  } else {\n    {\n      throw Error(`Expected text, element, decorator, or linebreak node`);\n    }\n  }\n\n  collabNode._key = lexicalNode.__key;\n  return collabNode;\n}\n\nfunction getNodeTypeFromSharedType(sharedType) {\n  const type = sharedType instanceof yjs.Map ? sharedType.get('__type') : sharedType.getAttribute('__type');\n\n  if (!(type != null)) {\n    throw Error(`Expected shared type to include type attribute`);\n  }\n\n  return type;\n}\n\nfunction getOrInitCollabNodeFromSharedType(binding, sharedType, parent) {\n  // @ts-expect-error: internal field\n  const collabNode = sharedType._collabNode;\n\n  if (collabNode === undefined) {\n    const registeredNodes = binding.editor._nodes;\n    const type = getNodeTypeFromSharedType(sharedType);\n    const nodeInfo = registeredNodes.get(type);\n\n    if (!(nodeInfo !== undefined)) {\n      throw Error(`Node ${type} is not registered`);\n    }\n\n    const sharedParent = sharedType.parent;\n    const targetParent = parent === undefined && sharedParent !== null ? getOrInitCollabNodeFromSharedType(binding, sharedParent) : parent || null;\n\n    if (!(targetParent instanceof CollabElementNode)) {\n      throw Error(`Expected parent to be a collab element node`);\n    }\n\n    if (sharedType instanceof yjs.XmlText) {\n      return $createCollabElementNode(sharedType, targetParent, type);\n    } else if (sharedType instanceof yjs.Map) {\n      if (type === 'linebreak') {\n        return $createCollabLineBreakNode(sharedType, targetParent);\n      }\n\n      return $createCollabTextNode(sharedType, '', targetParent, type);\n    } else if (sharedType instanceof yjs.XmlElement) {\n      return $createCollabDecoratorNode(sharedType, targetParent, type);\n    }\n  }\n\n  return collabNode;\n}\nfunction createLexicalNodeFromCollabNode(binding, collabNode, parentKey) {\n  const type = collabNode.getType();\n  const registeredNodes = binding.editor._nodes;\n  const nodeInfo = registeredNodes.get(type);\n\n  if (!(nodeInfo !== undefined)) {\n    throw Error(`Node ${type} is not registered`);\n  }\n\n  const lexicalNode = new nodeInfo.klass();\n  lexicalNode.__parent = parentKey;\n  collabNode._key = lexicalNode.__key;\n\n  if (collabNode instanceof CollabElementNode) {\n    const xmlText = collabNode._xmlText;\n    collabNode.syncPropertiesFromYjs(binding, null);\n    collabNode.applyChildrenYjsDelta(binding, xmlText.toDelta());\n    collabNode.syncChildrenFromYjs(binding);\n  } else if (collabNode instanceof CollabTextNode) {\n    collabNode.syncPropertiesAndTextFromYjs(binding, null);\n  } else if (collabNode instanceof CollabDecoratorNode) {\n    collabNode.syncPropertiesFromYjs(binding, null);\n  }\n\n  binding.collabNodeMap.set(lexicalNode.__key, collabNode);\n  return lexicalNode;\n}\nfunction syncPropertiesFromYjs(binding, sharedType, lexicalNode, keysChanged) {\n  const properties = keysChanged === null ? sharedType instanceof yjs.Map ? Array.from(sharedType.keys()) : Object.keys(sharedType.getAttributes()) : Array.from(keysChanged);\n  let writableNode;\n\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n\n    if (excludedProperties.has(property)) {\n      continue;\n    }\n\n    const prevValue = lexicalNode[property];\n    let nextValue = sharedType instanceof yjs.Map ? sharedType.get(property) : sharedType.getAttribute(property);\n\n    if (prevValue !== nextValue) {\n      if (nextValue instanceof yjs.Doc) {\n        const yjsDocMap = binding.docMap;\n\n        if (prevValue instanceof yjs.Doc) {\n          yjsDocMap.delete(prevValue.guid);\n        }\n\n        const nestedEditor = lexical.createEditor();\n        const key = nextValue.guid;\n        nestedEditor._key = key;\n        yjsDocMap.set(key, nextValue);\n        nextValue = nestedEditor;\n      }\n\n      if (writableNode === undefined) {\n        writableNode = lexicalNode.getWritable();\n      }\n\n      writableNode[property] = nextValue;\n    }\n  }\n}\nfunction syncPropertiesFromLexical(binding, sharedType, prevLexicalNode, nextLexicalNode) {\n  const type = nextLexicalNode.__type;\n  const nodeProperties = binding.nodeProperties;\n  let properties = nodeProperties.get(type);\n\n  if (properties === undefined) {\n    properties = Object.keys(nextLexicalNode).filter(property => {\n      return !excludedProperties.has(property);\n    });\n    nodeProperties.set(type, properties);\n  }\n\n  const EditorClass = binding.editor.constructor;\n\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    const prevValue = prevLexicalNode === null ? undefined : prevLexicalNode[property];\n    let nextValue = nextLexicalNode[property];\n\n    if (prevValue !== nextValue) {\n      if (nextValue instanceof EditorClass) {\n        const yjsDocMap = binding.docMap;\n        let prevDoc;\n\n        if (prevValue instanceof EditorClass) {\n          // @ts-expect-error Lexical node\n          const prevKey = prevValue._key;\n          prevDoc = yjsDocMap.get(prevKey);\n          yjsDocMap.delete(prevKey);\n        } // If we already have a document, use it.\n\n\n        const doc = prevDoc || new yjs.Doc();\n        const key = doc.guid; // @ts-expect-error Lexical node\n\n        nextValue._key = key;\n        yjsDocMap.set(key, doc);\n        nextValue = doc; // Mark the node dirty as we've assigned a new key to it\n\n        binding.editor.update(() => {\n          nextLexicalNode.markDirty();\n        });\n      }\n\n      if (sharedType instanceof yjs.Map) {\n        sharedType.set(property, nextValue);\n      } else {\n        sharedType.setAttribute(property, nextValue);\n      }\n    }\n  }\n}\nfunction spliceString(str, index, delCount, newText) {\n  return str.slice(0, index) + newText + str.slice(index + delCount);\n}\nfunction getPositionFromElementAndOffset(node, offset, boundaryIsEdge) {\n  let index = 0;\n  let i = 0;\n  const children = node._children;\n  const childrenLength = children.length;\n\n  for (; i < childrenLength; i++) {\n    const child = children[i];\n    const childOffset = index;\n    const size = child.getSize();\n    index += size;\n    const exceedsBoundary = boundaryIsEdge ? index >= offset : index > offset;\n\n    if (exceedsBoundary && child instanceof CollabTextNode) {\n      let textOffset = offset - childOffset - 1;\n\n      if (textOffset < 0) {\n        textOffset = 0;\n      }\n\n      const diffLength = index - offset;\n      return {\n        length: diffLength,\n        node: child,\n        nodeIndex: i,\n        offset: textOffset\n      };\n    }\n\n    if (index > offset) {\n      return {\n        length: 0,\n        node: child,\n        nodeIndex: i,\n        offset: childOffset\n      };\n    } else if (i === childrenLength - 1) {\n      return {\n        length: 0,\n        node: null,\n        nodeIndex: i + 1,\n        offset: childOffset + 1\n      };\n    }\n  }\n\n  return {\n    length: 0,\n    node: null,\n    nodeIndex: 0,\n    offset: 0\n  };\n}\nfunction doesSelectionNeedRecovering(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  let recoveryNeeded = false;\n\n  try {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n\n    if ( // We might have removed a node that no longer exists\n    !anchorNode.isAttached() || !focusNode.isAttached() || // If we've split a node, then the offset might not be right\n    lexical.$isTextNode(anchorNode) && anchor.offset > anchorNode.getTextContentSize() || lexical.$isTextNode(focusNode) && focus.offset > focusNode.getTextContentSize()) {\n      recoveryNeeded = true;\n    }\n  } catch (e) {\n    // Sometimes checking nor a node via getNode might trigger\n    // an error, so we need recovery then too.\n    recoveryNeeded = true;\n  }\n\n  return recoveryNeeded;\n}\nfunction syncWithTransaction(binding, fn) {\n  binding.doc.transact(fn, binding);\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n\n  while (nodeKey !== null) {\n    const node = nodeMap === null ? lexical.$getNodeByKey(nodeKey) : nodeMap.get(nodeKey);\n\n    if (node === null || node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n\n  return children;\n}\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling(); // TODO: this function duplicates a bunch of operations, can be simplified.\n\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n\n      writableNode.__prev = null;\n    }\n\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n\n      writableNode.__next = null;\n    }\n\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass CollabDecoratorNode {\n  constructor(xmlElem, parent, type) {\n    this._key = '';\n    this._xmlElem = xmlElem;\n    this._parent = parent;\n    this._type = type;\n    this._unobservers = new Set();\n  }\n\n  getPrevNode(nodeMap) {\n    if (nodeMap === null) {\n      return null;\n    }\n\n    const node = nodeMap.get(this._key);\n    return lexical.$isDecoratorNode(node) ? node : null;\n  }\n\n  getNode() {\n    const node = lexical.$getNodeByKey(this._key);\n    return lexical.$isDecoratorNode(node) ? node : null;\n  }\n\n  getSharedType() {\n    return this._xmlElem;\n  }\n\n  getType() {\n    return this._type;\n  }\n\n  getKey() {\n    return this._key;\n  }\n\n  getSize() {\n    return 1;\n  }\n\n  getOffset() {\n    const collabElementNode = this._parent;\n    return collabElementNode.getChildOffset(this);\n  }\n\n  syncPropertiesFromLexical(binding, nextLexicalNode, prevNodeMap) {\n    const prevLexicalNode = this.getPrevNode(prevNodeMap);\n    const xmlElem = this._xmlElem;\n    syncPropertiesFromLexical(binding, xmlElem, prevLexicalNode, nextLexicalNode);\n  }\n\n  syncPropertiesFromYjs(binding, keysChanged) {\n    const lexicalNode = this.getNode();\n\n    if (!(lexicalNode !== null)) {\n      throw Error(`syncPropertiesFromYjs: cound not find decorator node`);\n    }\n\n    const xmlElem = this._xmlElem;\n    syncPropertiesFromYjs(binding, xmlElem, lexicalNode, keysChanged);\n  }\n\n  destroy(binding) {\n    const collabNodeMap = binding.collabNodeMap;\n    collabNodeMap.delete(this._key);\n\n    this._unobservers.forEach(unobserver => unobserver());\n\n    this._unobservers.clear();\n  }\n\n}\nfunction $createCollabDecoratorNode(xmlElem, parent, type) {\n  const collabNode = new CollabDecoratorNode(xmlElem, parent, type); // @ts-expect-error: internal field\n\n  xmlElem._collabNode = collabNode;\n  return collabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass CollabElementNode {\n  constructor(xmlText, parent, type) {\n    this._key = '';\n    this._children = [];\n    this._xmlText = xmlText;\n    this._type = type;\n    this._parent = parent;\n  }\n\n  getPrevNode(nodeMap) {\n    if (nodeMap === null) {\n      return null;\n    }\n\n    const node = nodeMap.get(this._key);\n    return lexical.$isElementNode(node) ? node : null;\n  }\n\n  getNode() {\n    const node = lexical.$getNodeByKey(this._key);\n    return lexical.$isElementNode(node) ? node : null;\n  }\n\n  getSharedType() {\n    return this._xmlText;\n  }\n\n  getType() {\n    return this._type;\n  }\n\n  getKey() {\n    return this._key;\n  }\n\n  isEmpty() {\n    return this._children.length === 0;\n  }\n\n  getSize() {\n    return 1;\n  }\n\n  getOffset() {\n    const collabElementNode = this._parent;\n\n    if (!(collabElementNode !== null)) {\n      throw Error(`getOffset: cound not find collab element node`);\n    }\n\n    return collabElementNode.getChildOffset(this);\n  }\n\n  syncPropertiesFromYjs(binding, keysChanged) {\n    const lexicalNode = this.getNode();\n\n    if (!(lexicalNode !== null)) {\n      throw Error(`syncPropertiesFromYjs: cound not find element node`);\n    }\n\n    syncPropertiesFromYjs(binding, this._xmlText, lexicalNode, keysChanged);\n  }\n\n  applyChildrenYjsDelta(binding, deltas) {\n    const children = this._children;\n    let currIndex = 0;\n\n    for (let i = 0; i < deltas.length; i++) {\n      const delta = deltas[i];\n      const insertDelta = delta.insert;\n      const deleteDelta = delta.delete;\n\n      if (delta.retain != null) {\n        currIndex += delta.retain;\n      } else if (typeof deleteDelta === 'number') {\n        let deletionSize = deleteDelta;\n\n        while (deletionSize > 0) {\n          const {\n            node,\n            nodeIndex,\n            offset,\n            length\n          } = getPositionFromElementAndOffset(this, currIndex, false);\n\n          if (node instanceof CollabElementNode || node instanceof CollabLineBreakNode || node instanceof CollabDecoratorNode) {\n            children.splice(nodeIndex, 1);\n            deletionSize -= 1;\n          } else if (node instanceof CollabTextNode) {\n            const delCount = Math.min(deletionSize, length);\n            const prevCollabNode = nodeIndex !== 0 ? children[nodeIndex - 1] : null;\n            const nodeSize = node.getSize();\n\n            if (offset === 0 && delCount === 1 && nodeIndex > 0 && prevCollabNode instanceof CollabTextNode && length === nodeSize && // If the node has no keys, it's been deleted\n            Array.from(node._map.keys()).length === 0) {\n              // Merge the text node with previous.\n              prevCollabNode._text += node._text;\n              children.splice(nodeIndex, 1);\n            } else if (offset === 0 && delCount === nodeSize) {\n              // The entire thing needs removing\n              children.splice(nodeIndex, 1);\n            } else {\n              node._text = spliceString(node._text, offset, delCount, '');\n            }\n\n            deletionSize -= delCount;\n          } else {\n            // Can occur due to the deletion from the dangling text heuristic below.\n            break;\n          }\n        }\n      } else if (insertDelta != null) {\n        if (typeof insertDelta === 'string') {\n          const {\n            node,\n            offset\n          } = getPositionFromElementAndOffset(this, currIndex, true);\n\n          if (node instanceof CollabTextNode) {\n            node._text = spliceString(node._text, offset, 0, insertDelta);\n          } else {\n            // TODO: maybe we can improve this by keeping around a redundant\n            // text node map, rather than removing all the text nodes, so there\n            // never can be dangling text.\n            // We have a conflict where there was likely a CollabTextNode and\n            // an Lexical TextNode too, but they were removed in a merge. So\n            // let's just ignore the text and trigger a removal for it from our\n            // shared type.\n            this._xmlText.delete(offset, insertDelta.length);\n          }\n\n          currIndex += insertDelta.length;\n        } else {\n          const sharedType = insertDelta;\n          const {\n            nodeIndex\n          } = getPositionFromElementAndOffset(this, currIndex, false);\n          const collabNode = getOrInitCollabNodeFromSharedType(binding, sharedType, this);\n          children.splice(nodeIndex, 0, collabNode);\n          currIndex += 1;\n        }\n      } else {\n        throw new Error('Unexpected delta format');\n      }\n    }\n  }\n\n  syncChildrenFromYjs(binding) {\n    // Now diff the children of the collab node with that of our existing Lexical node.\n    const lexicalNode = this.getNode();\n\n    if (!(lexicalNode !== null)) {\n      throw Error(`syncChildrenFromYjs: cound not find element node`);\n    }\n\n    const key = lexicalNode.__key;\n    const prevLexicalChildrenKeys = createChildrenArray(lexicalNode, null);\n    const lexicalChildrenKeysLength = prevLexicalChildrenKeys.length;\n    const collabChildren = this._children;\n    const collabChildrenLength = collabChildren.length;\n    const collabNodeMap = binding.collabNodeMap;\n    const visitedKeys = new Set();\n    let collabKeys;\n    let writableLexicalNode;\n    let prevIndex = 0;\n    let prevChildNode = null;\n\n    if (collabChildrenLength !== lexicalChildrenKeysLength) {\n      writableLexicalNode = lexicalNode.getWritable();\n    }\n\n    for (let i = 0; i < collabChildrenLength; i++) {\n      const lexicalChildKey = prevLexicalChildrenKeys[prevIndex];\n      const childCollabNode = collabChildren[i];\n      const collabLexicalChildNode = childCollabNode.getNode();\n      const collabKey = childCollabNode._key;\n\n      if (collabLexicalChildNode !== null && lexicalChildKey === collabKey) {\n        const childNeedsUpdating = lexical.$isTextNode(collabLexicalChildNode); // Update\n\n        visitedKeys.add(lexicalChildKey);\n\n        if (childNeedsUpdating) {\n          childCollabNode._key = lexicalChildKey;\n\n          if (childCollabNode instanceof CollabElementNode) {\n            const xmlText = childCollabNode._xmlText;\n            childCollabNode.syncPropertiesFromYjs(binding, null);\n            childCollabNode.applyChildrenYjsDelta(binding, xmlText.toDelta());\n            childCollabNode.syncChildrenFromYjs(binding);\n          } else if (childCollabNode instanceof CollabTextNode) {\n            childCollabNode.syncPropertiesAndTextFromYjs(binding, null);\n          } else if (childCollabNode instanceof CollabDecoratorNode) {\n            childCollabNode.syncPropertiesFromYjs(binding, null);\n          } else if (!(childCollabNode instanceof CollabLineBreakNode)) {\n            {\n              throw Error(`syncChildrenFromYjs: expected text, element, decorator, or linebreak collab node`);\n            }\n          }\n        }\n        prevChildNode = collabLexicalChildNode;\n        prevIndex++;\n      } else {\n        if (collabKeys === undefined) {\n          collabKeys = new Set();\n\n          for (let s = 0; s < collabChildrenLength; s++) {\n            const child = collabChildren[s];\n            const childKey = child._key;\n\n            if (childKey !== '') {\n              collabKeys.add(childKey);\n            }\n          }\n        }\n\n        if (collabLexicalChildNode !== null && lexicalChildKey !== undefined && !collabKeys.has(lexicalChildKey)) {\n          const nodeToRemove = $getNodeByKeyOrThrow(lexicalChildKey);\n          removeFromParent(nodeToRemove);\n          i--;\n          prevIndex++;\n          continue;\n        }\n\n        writableLexicalNode = lexicalNode.getWritable(); // Create/Replace\n\n        const lexicalChildNode = createLexicalNodeFromCollabNode(binding, childCollabNode, key);\n        const childKey = lexicalChildNode.__key;\n        collabNodeMap.set(childKey, childCollabNode);\n\n        if (prevChildNode === null) {\n          const nextSibling = writableLexicalNode.getFirstChild();\n          writableLexicalNode.__first = childKey;\n\n          if (nextSibling !== null) {\n            const writableNextSibling = nextSibling.getWritable();\n            writableNextSibling.__prev = childKey;\n            lexicalChildNode.__next = writableNextSibling.__key;\n          }\n        } else {\n          const writablePrevChildNode = prevChildNode.getWritable();\n          const nextSibling = prevChildNode.getNextSibling();\n          writablePrevChildNode.__next = childKey;\n          lexicalChildNode.__prev = prevChildNode.__key;\n\n          if (nextSibling !== null) {\n            const writableNextSibling = nextSibling.getWritable();\n            writableNextSibling.__prev = childKey;\n            lexicalChildNode.__next = writableNextSibling.__key;\n          }\n        }\n\n        if (i === collabChildrenLength - 1) {\n          writableLexicalNode.__last = childKey;\n        }\n\n        writableLexicalNode.__size++;\n        prevChildNode = lexicalChildNode;\n      }\n    }\n\n    for (let i = 0; i < lexicalChildrenKeysLength; i++) {\n      const lexicalChildKey = prevLexicalChildrenKeys[i];\n\n      if (!visitedKeys.has(lexicalChildKey)) {\n        // Remove\n        const lexicalChildNode = $getNodeByKeyOrThrow(lexicalChildKey);\n        const collabNode = binding.collabNodeMap.get(lexicalChildKey);\n\n        if (collabNode !== undefined) {\n          collabNode.destroy(binding);\n        }\n\n        removeFromParent(lexicalChildNode);\n      }\n    }\n  }\n\n  syncPropertiesFromLexical(binding, nextLexicalNode, prevNodeMap) {\n    syncPropertiesFromLexical(binding, this._xmlText, this.getPrevNode(prevNodeMap), nextLexicalNode);\n  }\n\n  _syncChildFromLexical(binding, index, key, prevNodeMap, dirtyElements, dirtyLeaves) {\n    const childCollabNode = this._children[index]; // Update\n\n    const nextChildNode = $getNodeByKeyOrThrow(key);\n\n    if (childCollabNode instanceof CollabElementNode && lexical.$isElementNode(nextChildNode)) {\n      childCollabNode.syncPropertiesFromLexical(binding, nextChildNode, prevNodeMap);\n      childCollabNode.syncChildrenFromLexical(binding, nextChildNode, prevNodeMap, dirtyElements, dirtyLeaves);\n    } else if (childCollabNode instanceof CollabTextNode && lexical.$isTextNode(nextChildNode)) {\n      childCollabNode.syncPropertiesAndTextFromLexical(binding, nextChildNode, prevNodeMap);\n    } else if (childCollabNode instanceof CollabDecoratorNode && lexical.$isDecoratorNode(nextChildNode)) {\n      childCollabNode.syncPropertiesFromLexical(binding, nextChildNode, prevNodeMap);\n    }\n  }\n\n  syncChildrenFromLexical(binding, nextLexicalNode, prevNodeMap, dirtyElements, dirtyLeaves) {\n    const prevLexicalNode = this.getPrevNode(prevNodeMap);\n    const prevChildren = prevLexicalNode === null ? [] : createChildrenArray(prevLexicalNode, prevNodeMap);\n    const nextChildren = createChildrenArray(nextLexicalNode, null);\n    const prevEndIndex = prevChildren.length - 1;\n    const nextEndIndex = nextChildren.length - 1;\n    const collabNodeMap = binding.collabNodeMap;\n    let prevChildrenSet;\n    let nextChildrenSet;\n    let prevIndex = 0;\n    let nextIndex = 0;\n\n    while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n      const prevKey = prevChildren[prevIndex];\n      const nextKey = nextChildren[nextIndex];\n\n      if (prevKey === nextKey) {\n        // Nove move, create or remove\n        this._syncChildFromLexical(binding, nextIndex, nextKey, prevNodeMap, dirtyElements, dirtyLeaves);\n\n        prevIndex++;\n        nextIndex++;\n      } else {\n        if (prevChildrenSet === undefined) {\n          prevChildrenSet = new Set(prevChildren);\n        }\n\n        if (nextChildrenSet === undefined) {\n          nextChildrenSet = new Set(nextChildren);\n        }\n\n        const nextHasPrevKey = nextChildrenSet.has(prevKey);\n        const prevHasNextKey = prevChildrenSet.has(nextKey);\n\n        if (!nextHasPrevKey) {\n          // Remove\n          this.splice(binding, nextIndex, 1);\n          prevIndex++;\n        } else {\n          // Create or replace\n          const nextChildNode = $getNodeByKeyOrThrow(nextKey);\n          const collabNode = $createCollabNodeFromLexicalNode(binding, nextChildNode, this);\n          collabNodeMap.set(nextKey, collabNode);\n\n          if (prevHasNextKey) {\n            this.splice(binding, nextIndex, 1, collabNode);\n            prevIndex++;\n            nextIndex++;\n          } else {\n            this.splice(binding, nextIndex, 0, collabNode);\n            nextIndex++;\n          }\n        }\n      }\n    }\n\n    const appendNewChildren = prevIndex > prevEndIndex;\n    const removeOldChildren = nextIndex > nextEndIndex;\n\n    if (appendNewChildren && !removeOldChildren) {\n      for (; nextIndex <= nextEndIndex; ++nextIndex) {\n        const key = nextChildren[nextIndex];\n        const nextChildNode = $getNodeByKeyOrThrow(key);\n        const collabNode = $createCollabNodeFromLexicalNode(binding, nextChildNode, this);\n        this.append(collabNode);\n        collabNodeMap.set(key, collabNode);\n      }\n    } else if (removeOldChildren && !appendNewChildren) {\n      for (let i = this._children.length - 1; i >= nextIndex; i--) {\n        this.splice(binding, i, 1);\n      }\n    }\n  }\n\n  append(collabNode) {\n    const xmlText = this._xmlText;\n    const children = this._children;\n    const lastChild = children[children.length - 1];\n    const offset = lastChild !== undefined ? lastChild.getOffset() + lastChild.getSize() : 0;\n\n    if (collabNode instanceof CollabElementNode) {\n      xmlText.insertEmbed(offset, collabNode._xmlText);\n    } else if (collabNode instanceof CollabTextNode) {\n      const map = collabNode._map;\n\n      if (map.parent === null) {\n        xmlText.insertEmbed(offset, map);\n      }\n\n      xmlText.insert(offset + 1, collabNode._text);\n    } else if (collabNode instanceof CollabLineBreakNode) {\n      xmlText.insertEmbed(offset, collabNode._map);\n    } else if (collabNode instanceof CollabDecoratorNode) {\n      xmlText.insertEmbed(offset, collabNode._xmlElem);\n    }\n\n    this._children.push(collabNode);\n  }\n\n  splice(binding, index, delCount, collabNode) {\n    const children = this._children;\n    const child = children[index];\n\n    if (child === undefined) {\n      if (!(collabNode !== undefined)) {\n        throw Error(`splice: could not find collab element node`);\n      }\n\n      this.append(collabNode);\n      return;\n    }\n\n    const offset = child.getOffset();\n\n    if (!(offset !== -1)) {\n      throw Error(`splice: expected offset to be greater than zero`);\n    }\n\n    const xmlText = this._xmlText;\n\n    if (delCount !== 0) {\n      // What if we delete many nodes, don't we need to get all their\n      // sizes?\n      xmlText.delete(offset, child.getSize());\n    }\n\n    if (collabNode instanceof CollabElementNode) {\n      xmlText.insertEmbed(offset, collabNode._xmlText);\n    } else if (collabNode instanceof CollabTextNode) {\n      const map = collabNode._map;\n\n      if (map.parent === null) {\n        xmlText.insertEmbed(offset, map);\n      }\n\n      xmlText.insert(offset + 1, collabNode._text);\n    } else if (collabNode instanceof CollabLineBreakNode) {\n      xmlText.insertEmbed(offset, collabNode._map);\n    } else if (collabNode instanceof CollabDecoratorNode) {\n      xmlText.insertEmbed(offset, collabNode._xmlElem);\n    }\n\n    if (delCount !== 0) {\n      const childrenToDelete = children.slice(index, index + delCount);\n\n      for (let i = 0; i < childrenToDelete.length; i++) {\n        childrenToDelete[i].destroy(binding);\n      }\n    }\n\n    if (collabNode !== undefined) {\n      children.splice(index, delCount, collabNode);\n    } else {\n      children.splice(index, delCount);\n    }\n  }\n\n  getChildOffset(collabNode) {\n    let offset = 0;\n    const children = this._children;\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n\n      if (child === collabNode) {\n        return offset;\n      }\n\n      offset += child.getSize();\n    }\n\n    return -1;\n  }\n\n  destroy(binding) {\n    const collabNodeMap = binding.collabNodeMap;\n    const children = this._children;\n\n    for (let i = 0; i < children.length; i++) {\n      children[i].destroy(binding);\n    }\n\n    collabNodeMap.delete(this._key);\n  }\n\n}\nfunction $createCollabElementNode(xmlText, parent, type) {\n  const collabNode = new CollabElementNode(xmlText, parent, type); // @ts-expect-error: internal field\n\n  xmlText._collabNode = collabNode;\n  return collabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createBinding(editor, provider, id, doc, docMap) {\n  if (!(doc !== undefined && doc !== null)) {\n    throw Error(`createBinding: doc is null or undefined`);\n  }\n\n  const rootXmlText = doc.get('root', yjs.XmlText);\n  const root = $createCollabElementNode(rootXmlText, null, 'root');\n  root._key = 'root';\n  return {\n    clientID: doc.clientID,\n    collabNodeMap: new Map(),\n    cursors: new Map(),\n    cursorsContainer: null,\n    doc,\n    docMap,\n    editor,\n    id,\n    nodeProperties: new Map(),\n    root\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createRelativePosition(point, binding) {\n  const collabNodeMap = binding.collabNodeMap;\n  const collabNode = collabNodeMap.get(point.key);\n\n  if (collabNode === undefined) {\n    return null;\n  }\n\n  let offset = point.offset;\n  let sharedType = collabNode.getSharedType();\n\n  if (collabNode instanceof CollabTextNode) {\n    sharedType = collabNode._parent._xmlText;\n    const currentOffset = collabNode.getOffset();\n\n    if (currentOffset === -1) {\n      return null;\n    }\n\n    offset = currentOffset + 1 + offset;\n  } else if (collabNode instanceof CollabElementNode && point.type === 'element') {\n    const parent = point.getNode();\n    let accumulatedOffset = 0;\n    let i = 0;\n    let node = parent.getFirstChild();\n\n    while (node !== null && i++ < offset) {\n      if (lexical.$isTextNode(node)) {\n        accumulatedOffset += node.getTextContentSize() + 1;\n      } else {\n        accumulatedOffset++;\n      }\n\n      node = node.getNextSibling();\n    }\n\n    offset = accumulatedOffset;\n  }\n\n  return yjs.createRelativePositionFromTypeIndex(sharedType, offset);\n}\n\nfunction createAbsolutePosition(relativePosition, binding) {\n  return yjs.createAbsolutePositionFromRelativePosition(relativePosition, binding.doc);\n}\n\nfunction shouldUpdatePosition(currentPos, pos) {\n  if (currentPos == null) {\n    if (pos != null) {\n      return true;\n    }\n  } else if (pos == null || !yjs.compareRelativePositions(currentPos, pos)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction createCursor(name, color) {\n  return {\n    color: color,\n    name: name,\n    selection: null\n  };\n}\n\nfunction destroySelection(binding, selection) {\n  const cursorsContainer = binding.cursorsContainer;\n\n  if (cursorsContainer !== null) {\n    const selections = selection.selections;\n    const selectionsLength = selections.length;\n\n    for (let i = 0; i < selectionsLength; i++) {\n      cursorsContainer.removeChild(selections[i]);\n    }\n  }\n}\n\nfunction destroyCursor(binding, cursor) {\n  const selection = cursor.selection;\n\n  if (selection !== null) {\n    destroySelection(binding, selection);\n  }\n}\n\nfunction createCursorSelection(cursor, anchorKey, anchorOffset, focusKey, focusOffset) {\n  const color = cursor.color;\n  const caret = document.createElement('span');\n  caret.style.cssText = `position:absolute;top:0;bottom:0;right:-1px;width:1px;background-color:${color};z-index:10;`;\n  const name = document.createElement('span');\n  name.textContent = cursor.name;\n  name.style.cssText = `position:absolute;left:-2px;top:-16px;background-color:${color};color:#fff;line-height:12px;font-size:12px;padding:2px;font-family:Arial;font-weight:bold;white-space:nowrap;`;\n  caret.appendChild(name);\n  return {\n    anchor: {\n      key: anchorKey,\n      offset: anchorOffset\n    },\n    caret,\n    color,\n    focus: {\n      key: focusKey,\n      offset: focusOffset\n    },\n    name,\n    selections: []\n  };\n}\n\nfunction updateCursor(binding, cursor, nextSelection, nodeMap) {\n  const editor = binding.editor;\n  const rootElement = editor.getRootElement();\n  const cursorsContainer = binding.cursorsContainer;\n\n  if (cursorsContainer === null || rootElement === null) {\n    return;\n  }\n\n  const cursorsContainerOffsetParent = cursorsContainer.offsetParent;\n\n  if (cursorsContainerOffsetParent === null) {\n    return;\n  }\n\n  const containerRect = cursorsContainerOffsetParent.getBoundingClientRect();\n  const prevSelection = cursor.selection;\n\n  if (nextSelection === null) {\n    if (prevSelection === null) {\n      return;\n    } else {\n      cursor.selection = null;\n      destroySelection(binding, prevSelection);\n      return;\n    }\n  } else {\n    cursor.selection = nextSelection;\n  }\n\n  const caret = nextSelection.caret;\n  const color = nextSelection.color;\n  const selections = nextSelection.selections;\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorNode = nodeMap.get(anchorKey);\n  const focusNode = nodeMap.get(focusKey);\n\n  if (anchorNode == null || focusNode == null) {\n    return;\n  }\n\n  let selectionRects; // In the case of a collapsed selection on a linebreak, we need\n  // to improvise as the browser will return nothing here as <br>\n  // apparantly take up no visual space :/\n  // This won't work in all cases, but it's better than just showing\n  // nothing all the time.\n\n  if (anchorNode === focusNode && lexical.$isLineBreakNode(anchorNode)) {\n    const brRect = editor.getElementByKey(anchorKey).getBoundingClientRect();\n    selectionRects = [brRect];\n  } else {\n    const range = selection.createDOMRange(editor, anchorNode, anchor.offset, focusNode, focus.offset);\n\n    if (range === null) {\n      return;\n    }\n\n    selectionRects = selection.createRectsFromDOMRange(editor, range);\n  }\n\n  const selectionsLength = selections.length;\n  const selectionRectsLength = selectionRects.length;\n\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    let selection = selections[i];\n\n    if (selection === undefined) {\n      selection = document.createElement('span');\n      selections[i] = selection;\n      const selectionBg = document.createElement('span');\n      selection.appendChild(selectionBg);\n      cursorsContainer.appendChild(selection);\n    }\n\n    const top = selectionRect.top - containerRect.top;\n    const left = selectionRect.left - containerRect.left;\n    const style = `position:absolute;top:${top}px;left:${left}px;height:${selectionRect.height}px;width:${selectionRect.width}px;pointer-events:none;z-index:5;`;\n    selection.style.cssText = style;\n    selection.firstChild.style.cssText = `${style}left:0;top:0;background-color:${color};opacity:0.3;`;\n\n    if (i === selectionRectsLength - 1) {\n      if (caret.parentNode !== selection) {\n        selection.appendChild(caret);\n      }\n    }\n  }\n\n  for (let i = selectionsLength - 1; i >= selectionRectsLength; i--) {\n    const selection = selections[i];\n    cursorsContainer.removeChild(selection);\n    selections.pop();\n  }\n}\n\nfunction syncLocalCursorPosition(binding, provider) {\n  const awareness = provider.awareness;\n  const localState = awareness.getLocalState();\n\n  if (localState === null) {\n    return;\n  }\n\n  const anchorPos = localState.anchorPos;\n  const focusPos = localState.focusPos;\n\n  if (anchorPos !== null && focusPos !== null) {\n    const anchorAbsPos = createAbsolutePosition(anchorPos, binding);\n    const focusAbsPos = createAbsolutePosition(focusPos, binding);\n\n    if (anchorAbsPos !== null && focusAbsPos !== null) {\n      const [anchorCollabNode, anchorOffset] = getCollabNodeAndOffset(anchorAbsPos.type, anchorAbsPos.index);\n      const [focusCollabNode, focusOffset] = getCollabNodeAndOffset(focusAbsPos.type, focusAbsPos.index);\n\n      if (anchorCollabNode !== null && focusCollabNode !== null) {\n        const anchorKey = anchorCollabNode.getKey();\n        const focusKey = focusCollabNode.getKey();\n        const selection = lexical.$getSelection();\n\n        if (!lexical.$isRangeSelection(selection)) {\n          return;\n        }\n\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        setPoint(anchor, anchorKey, anchorOffset);\n        setPoint(focus, focusKey, focusOffset);\n      }\n    }\n  }\n}\n\nfunction setPoint(point, key, offset) {\n  if (point.key !== key || point.offset !== offset) {\n    let anchorNode = lexical.$getNodeByKey(key);\n\n    if (anchorNode !== null && !lexical.$isElementNode(anchorNode) && !lexical.$isTextNode(anchorNode)) {\n      const parent = anchorNode.getParentOrThrow();\n      key = parent.getKey();\n      offset = anchorNode.getIndexWithinParent();\n      anchorNode = parent;\n    }\n\n    point.set(key, offset, lexical.$isElementNode(anchorNode) ? 'element' : 'text');\n  }\n}\n\nfunction getCollabNodeAndOffset( // eslint-disable-next-line @typescript-eslint/no-explicit-any\nsharedType, offset) {\n  const collabNode = sharedType._collabNode;\n\n  if (collabNode === undefined) {\n    return [null, 0];\n  }\n\n  if (collabNode instanceof CollabElementNode) {\n    const {\n      node,\n      offset: collabNodeOffset\n    } = getPositionFromElementAndOffset(collabNode, offset, true);\n\n    if (node === null) {\n      return [collabNode, 0];\n    } else {\n      return [node, collabNodeOffset];\n    }\n  }\n\n  return [null, 0];\n}\n\nfunction syncCursorPositions(binding, provider) {\n  const awarenessStates = Array.from(provider.awareness.getStates());\n  const localClientID = binding.clientID;\n  const cursors = binding.cursors;\n  const editor = binding.editor;\n  const nodeMap = editor._editorState._nodeMap;\n  const visitedClientIDs = new Set();\n\n  for (let i = 0; i < awarenessStates.length; i++) {\n    const awarenessState = awarenessStates[i];\n    const [clientID, awareness] = awarenessState;\n\n    if (clientID !== localClientID) {\n      visitedClientIDs.add(clientID);\n      const {\n        anchorPos,\n        focusPos,\n        name,\n        color,\n        focusing\n      } = awareness;\n      let selection = null;\n      let cursor = cursors.get(clientID);\n\n      if (cursor === undefined) {\n        cursor = createCursor(name, color);\n        cursors.set(clientID, cursor);\n      }\n\n      if (anchorPos !== null && focusPos !== null && focusing) {\n        const anchorAbsPos = createAbsolutePosition(anchorPos, binding);\n        const focusAbsPos = createAbsolutePosition(focusPos, binding);\n\n        if (anchorAbsPos !== null && focusAbsPos !== null) {\n          const [anchorCollabNode, anchorOffset] = getCollabNodeAndOffset(anchorAbsPos.type, anchorAbsPos.index);\n          const [focusCollabNode, focusOffset] = getCollabNodeAndOffset(focusAbsPos.type, focusAbsPos.index);\n\n          if (anchorCollabNode !== null && focusCollabNode !== null) {\n            const anchorKey = anchorCollabNode.getKey();\n            const focusKey = focusCollabNode.getKey();\n            selection = cursor.selection;\n\n            if (selection === null) {\n              selection = createCursorSelection(cursor, anchorKey, anchorOffset, focusKey, focusOffset);\n            } else {\n              const anchor = selection.anchor;\n              const focus = selection.focus;\n              anchor.key = anchorKey;\n              anchor.offset = anchorOffset;\n              focus.key = focusKey;\n              focus.offset = focusOffset;\n            }\n          }\n        }\n      }\n\n      updateCursor(binding, cursor, selection, nodeMap);\n    }\n  }\n\n  const allClientIDs = Array.from(cursors.keys());\n\n  for (let i = 0; i < allClientIDs.length; i++) {\n    const clientID = allClientIDs[i];\n\n    if (!visitedClientIDs.has(clientID)) {\n      const cursor = cursors.get(clientID);\n\n      if (cursor !== undefined) {\n        destroyCursor(binding, cursor);\n        cursors.delete(clientID);\n      }\n    }\n  }\n}\nfunction syncLexicalSelectionToYjs(binding, provider, prevSelection, nextSelection) {\n  const awareness = provider.awareness;\n  const localState = awareness.getLocalState();\n\n  if (localState === null) {\n    return;\n  }\n\n  const {\n    anchorPos: currentAnchorPos,\n    focusPos: currentFocusPos,\n    name,\n    color,\n    focusing\n  } = localState;\n  let anchorPos = null;\n  let focusPos = null;\n\n  if (nextSelection === null || currentAnchorPos !== null && !nextSelection.is(prevSelection)) {\n    if (prevSelection === null) {\n      return;\n    }\n  }\n\n  if (lexical.$isRangeSelection(nextSelection)) {\n    anchorPos = createRelativePosition(nextSelection.anchor, binding);\n    focusPos = createRelativePosition(nextSelection.focus, binding);\n  }\n\n  if (shouldUpdatePosition(currentAnchorPos, anchorPos) || shouldUpdatePosition(currentFocusPos, focusPos)) {\n    awareness.setLocalState({\n      anchorPos,\n      color,\n      focusPos,\n      focusing,\n      name\n    });\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction syncEvent(binding, event) {\n  const {\n    target\n  } = event;\n  const collabNode = getOrInitCollabNodeFromSharedType(binding, target);\n\n  if (collabNode instanceof CollabElementNode && event instanceof yjs.YTextEvent) {\n    // @ts-expect-error We need to access the private property of the class\n    const {\n      keysChanged,\n      childListChanged,\n      delta\n    } = event; // Update\n\n    if (keysChanged.size > 0) {\n      collabNode.syncPropertiesFromYjs(binding, keysChanged);\n    }\n\n    if (childListChanged) {\n      collabNode.applyChildrenYjsDelta(binding, delta);\n      collabNode.syncChildrenFromYjs(binding);\n    }\n  } else if (collabNode instanceof CollabTextNode && event instanceof yjs.YMapEvent) {\n    const {\n      keysChanged\n    } = event; // Update\n\n    if (keysChanged.size > 0) {\n      collabNode.syncPropertiesAndTextFromYjs(binding, keysChanged);\n    }\n  } else if (collabNode instanceof CollabDecoratorNode && event instanceof yjs.YXmlEvent) {\n    const {\n      attributesChanged\n    } = event; // Update\n\n    if (attributesChanged.size > 0) {\n      collabNode.syncPropertiesFromYjs(binding, attributesChanged);\n    }\n  } else {\n    {\n      throw Error(`Expected text, element, or decorator event`);\n    }\n  }\n}\n\nfunction syncYjsChangesToLexical(binding, provider, events, isFromUndoManger) {\n  const editor = binding.editor;\n  const currentEditorState = editor._editorState;\n  editor.update(() => {\n    const pendingEditorState = editor._pendingEditorState;\n\n    for (let i = 0; i < events.length; i++) {\n      const event = events[i];\n      syncEvent(binding, event);\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      // We can't use Yjs's cursor position here, as it doesn't always\n      // handle selection recovery correctly  especially on elements that\n      // get moved around or split. So instead, we roll our own solution.\n      if (doesSelectionNeedRecovering(selection)) {\n        const prevSelection = currentEditorState._selection;\n\n        if (lexical.$isRangeSelection(prevSelection)) {\n          const prevOffsetView = offset.$createOffsetView(editor, 0, currentEditorState);\n          const nextOffsetView = offset.$createOffsetView(editor, 0, pendingEditorState);\n          const [start, end] = prevOffsetView.getOffsetsFromSelection(prevSelection);\n          const nextSelection = nextOffsetView.createSelectionFromOffsets(start, end, prevOffsetView);\n\n          if (nextSelection !== null) {\n            lexical.$setSelection(nextSelection);\n          } else {\n            // Fallback is to use the Yjs cursor position\n            syncLocalCursorPosition(binding, provider);\n\n            if (doesSelectionNeedRecovering(selection)) {\n              const root = lexical.$getRoot(); // If there was a collision on the top level paragraph\n              // we need to re-add a paragraph\n\n              if (root.getChildrenSize() === 0) {\n                root.append(lexical.$createParagraphNode());\n              } // Fallback\n\n\n              lexical.$getRoot().selectEnd();\n            }\n          }\n        }\n\n        syncLexicalSelectionToYjs(binding, provider, prevSelection, lexical.$getSelection());\n      } else {\n        syncLocalCursorPosition(binding, provider);\n      }\n    }\n  }, {\n    onUpdate: () => {\n      syncCursorPositions(binding, provider);\n    },\n    skipTransforms: true,\n    tag: isFromUndoManger ? 'historic' : 'collaboration'\n  });\n}\n\nfunction handleNormalizationMergeConflicts(binding, normalizedNodes) {\n  // We handle the merge operations here\n  const normalizedNodesKeys = Array.from(normalizedNodes);\n  const collabNodeMap = binding.collabNodeMap;\n  const mergedNodes = [];\n\n  for (let i = 0; i < normalizedNodesKeys.length; i++) {\n    const nodeKey = normalizedNodesKeys[i];\n    const lexicalNode = lexical.$getNodeByKey(nodeKey);\n    const collabNode = collabNodeMap.get(nodeKey);\n\n    if (collabNode instanceof CollabTextNode) {\n      if (lexical.$isTextNode(lexicalNode)) {\n        // We mutate the text collab nodes after removing\n        // all the dead nodes first, otherwise offsets break.\n        mergedNodes.push([collabNode, lexicalNode.__text]);\n      } else {\n        const offset = collabNode.getOffset();\n\n        if (offset === -1) {\n          continue;\n        }\n\n        const parent = collabNode._parent;\n        collabNode._normalized = true;\n\n        parent._xmlText.delete(offset, 1);\n\n        collabNodeMap.delete(nodeKey);\n        const parentChildren = parent._children;\n        const index = parentChildren.indexOf(collabNode);\n        parentChildren.splice(index, 1);\n      }\n    }\n  }\n\n  for (let i = 0; i < mergedNodes.length; i++) {\n    const [collabNode, text] = mergedNodes[i];\n\n    if (collabNode instanceof CollabTextNode && typeof text === 'string') {\n      collabNode._text = text;\n    }\n  }\n}\n\nfunction syncLexicalUpdateToYjs(binding, provider, prevEditorState, currEditorState, dirtyElements, dirtyLeaves, normalizedNodes, tags) {\n  syncWithTransaction(binding, () => {\n    currEditorState.read(() => {\n      // We check if the update has come from a origin where the origin\n      // was the collaboration binding previously. This can help us\n      // prevent unnecessarily re-diffing and possible re-applying\n      // the same change editor state again. For example, if a user\n      // types a character and we get it, we don't want to then insert\n      // the same character again. The exception to this heuristic is\n      // when we need to handle normalization merge conflicts.\n      if (tags.has('collaboration') || tags.has('historic')) {\n        if (normalizedNodes.size > 0) {\n          handleNormalizationMergeConflicts(binding, normalizedNodes);\n        }\n\n        return;\n      }\n\n      if (dirtyElements.has('root')) {\n        const prevNodeMap = prevEditorState._nodeMap;\n        const nextLexicalRoot = lexical.$getRoot();\n        const collabRoot = binding.root;\n        collabRoot.syncPropertiesFromLexical(binding, nextLexicalRoot, prevNodeMap);\n        collabRoot.syncChildrenFromLexical(binding, nextLexicalRoot, prevNodeMap, dirtyElements, dirtyLeaves);\n      }\n\n      const selection = lexical.$getSelection();\n      const prevSelection = prevEditorState._selection;\n      syncLexicalSelectionToYjs(binding, provider, prevSelection, selection);\n    });\n  });\n}\n\n/** @module @lexical/yjs */\nconst CONNECTED_COMMAND = lexical.createCommand('CONNECTED_COMMAND');\nconst TOGGLE_CONNECT_COMMAND = lexical.createCommand('TOGGLE_CONNECT_COMMAND');\nfunction createUndoManager(binding, root) {\n  return new yjs.UndoManager(root, {\n    trackedOrigins: new Set([binding, null])\n  });\n}\nfunction initLocalState(provider, name, color, focusing) {\n  provider.awareness.setLocalState({\n    anchorPos: null,\n    color,\n    focusPos: null,\n    focusing: focusing,\n    name\n  });\n}\nfunction setLocalStateFocus(provider, name, color, focusing) {\n  const {\n    awareness\n  } = provider;\n  let localState = awareness.getLocalState();\n\n  if (localState === null) {\n    localState = {\n      anchorPos: null,\n      color,\n      focusPos: null,\n      focusing: focusing,\n      name\n    };\n  }\n\n  localState.focusing = focusing;\n  awareness.setLocalState(localState);\n}\n\nexports.CONNECTED_COMMAND = CONNECTED_COMMAND;\nexports.TOGGLE_CONNECT_COMMAND = TOGGLE_CONNECT_COMMAND;\nexports.createBinding = createBinding;\nexports.createUndoManager = createUndoManager;\nexports.initLocalState = initLocalState;\nexports.setLocalStateFocus = setLocalStateFocus;\nexports.syncCursorPositions = syncCursorPositions;\nexports.syncLexicalUpdateToYjs = syncLexicalUpdateToYjs;\nexports.syncYjsChangesToLexical = syncYjsChangesToLexical;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwveWpzL0xleGljYWxZanMuZGV2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyx3REFBUztBQUMvQixVQUFVLG1CQUFPLENBQUMsa0RBQUs7QUFDdkIsZ0JBQWdCLG1CQUFPLENBQUMsdUZBQW9CO0FBQzVDLGFBQWEsbUJBQU8sQ0FBQyw4RUFBaUI7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtFQUFrRTs7QUFFbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLG9CQUFvQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdGQUFnRjs7QUFFaEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsK0JBQStCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7O0FBRW5EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSwyQkFBMkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLDZCQUE2QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTSxTQUFTLFdBQVcsVUFBVSxtQkFBbUIsT0FBTyxXQUFXO0FBQ3BIO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVSxVQUFVLG1CQUFtQixPQUFPLFdBQVcsaUJBQWlCLGVBQWUsWUFBWSxrQkFBa0IsaUJBQWlCLG1CQUFtQjtBQUNyTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLE1BQU0sSUFBSSxHQUFHLE9BQU8sS0FBSyxHQUFHLFNBQVMscUJBQXFCLEdBQUcsUUFBUSxvQkFBb0IsR0FBRyxvQkFBb0IsVUFBVTtBQUMvSjtBQUNBLDRDQUE0QyxNQUFNLE9BQU8sTUFBTSxtQkFBbUIsT0FBTyxZQUFZOztBQUVyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLDJCQUEyQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQix5QkFBeUI7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVM7O0FBRWY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNLFNBQVM7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNLFNBQVM7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjs7O0FBR2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsZ0NBQWdDO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix3QkFBd0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6Qiw4QkFBOEI7QUFDOUIscUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6QixzQkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQiw4QkFBOEI7QUFDOUIsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwveWpzL0xleGljYWxZanMuZGV2LmpzPzUxMDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBsZXhpY2FsID0gcmVxdWlyZSgnbGV4aWNhbCcpO1xudmFyIHlqcyA9IHJlcXVpcmUoJ3lqcycpO1xudmFyIHNlbGVjdGlvbiA9IHJlcXVpcmUoJ0BsZXhpY2FsL3NlbGVjdGlvbicpO1xudmFyIG9mZnNldCA9IHJlcXVpcmUoJ0BsZXhpY2FsL29mZnNldCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jbGFzcyBDb2xsYWJMaW5lQnJlYWtOb2RlIHtcbiAgY29uc3RydWN0b3IobWFwLCBwYXJlbnQpIHtcbiAgICB0aGlzLl9rZXkgPSAnJztcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuX3R5cGUgPSAnbGluZWJyZWFrJztcbiAgfVxuXG4gIGdldE5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleSh0aGlzLl9rZXkpO1xuICAgIHJldHVybiBsZXhpY2FsLiRpc0xpbmVCcmVha05vZGUobm9kZSkgPyBub2RlIDogbnVsbDtcbiAgfVxuXG4gIGdldEtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5O1xuICB9XG5cbiAgZ2V0U2hhcmVkVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwO1xuICB9XG5cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgfVxuXG4gIGdldFNpemUoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBnZXRPZmZzZXQoKSB7XG4gICAgY29uc3QgY29sbGFiRWxlbWVudE5vZGUgPSB0aGlzLl9wYXJlbnQ7XG4gICAgcmV0dXJuIGNvbGxhYkVsZW1lbnROb2RlLmdldENoaWxkT2Zmc2V0KHRoaXMpO1xuICB9XG5cbiAgZGVzdHJveShiaW5kaW5nKSB7XG4gICAgY29uc3QgY29sbGFiTm9kZU1hcCA9IGJpbmRpbmcuY29sbGFiTm9kZU1hcDtcbiAgICBjb2xsYWJOb2RlTWFwLmRlbGV0ZSh0aGlzLl9rZXkpO1xuICB9XG5cbn1cbmZ1bmN0aW9uICRjcmVhdGVDb2xsYWJMaW5lQnJlYWtOb2RlKG1hcCwgcGFyZW50KSB7XG4gIGNvbnN0IGNvbGxhYk5vZGUgPSBuZXcgQ29sbGFiTGluZUJyZWFrTm9kZShtYXAsIHBhcmVudCk7IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG5cbiAgbWFwLl9jb2xsYWJOb2RlID0gY29sbGFiTm9kZTtcbiAgcmV0dXJuIGNvbGxhYk5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZURpZmZXaXRoQ3Vyc29yKGEsIGIsIGN1cnNvcikge1xuICBjb25zdCBhTGVuZ3RoID0gYS5sZW5ndGg7XG4gIGNvbnN0IGJMZW5ndGggPSBiLmxlbmd0aDtcbiAgbGV0IGxlZnQgPSAwOyAvLyBudW1iZXIgb2Ygc2FtZSBjaGFyYWN0ZXJzIGNvdW50aW5nIGZyb20gbGVmdFxuXG4gIGxldCByaWdodCA9IDA7IC8vIG51bWJlciBvZiBzYW1lIGNoYXJhY3RlcnMgY291bnRpbmcgZnJvbSByaWdodFxuICAvLyBJdGVyYXRlIGxlZnQgdG8gdGhlIHJpZ2h0IHVudGlsIHdlIGZpbmQgYSBjaGFuZ2VkIGNoYXJhY3RlclxuICAvLyBGaXJzdCBpdGVyYXRpb24gY29uc2lkZXJzIHRoZSBjdXJyZW50IGN1cnNvciBwb3NpdGlvblxuXG4gIHdoaWxlIChsZWZ0IDwgYUxlbmd0aCAmJiBsZWZ0IDwgYkxlbmd0aCAmJiBhW2xlZnRdID09PSBiW2xlZnRdICYmIGxlZnQgPCBjdXJzb3IpIHtcbiAgICBsZWZ0Kys7XG4gIH0gLy8gSXRlcmF0ZSByaWdodCB0byB0aGUgbGVmdCB1bnRpbCB3ZSBmaW5kIGEgY2hhbmdlZCBjaGFyYWN0ZXJcblxuXG4gIHdoaWxlIChyaWdodCArIGxlZnQgPCBhTGVuZ3RoICYmIHJpZ2h0ICsgbGVmdCA8IGJMZW5ndGggJiYgYVthTGVuZ3RoIC0gcmlnaHQgLSAxXSA9PT0gYltiTGVuZ3RoIC0gcmlnaHQgLSAxXSkge1xuICAgIHJpZ2h0Kys7XG4gIH0gLy8gVHJ5IHRvIGl0ZXJhdGUgbGVmdCBmdXJ0aGVyIHRvIHRoZSByaWdodCB3aXRob3V0IGNhcmluZyBhYm91dCB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb25cblxuXG4gIHdoaWxlIChyaWdodCArIGxlZnQgPCBhTGVuZ3RoICYmIHJpZ2h0ICsgbGVmdCA8IGJMZW5ndGggJiYgYVtsZWZ0XSA9PT0gYltsZWZ0XSkge1xuICAgIGxlZnQrKztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaW5kZXg6IGxlZnQsXG4gICAgaW5zZXJ0OiBiLnNsaWNlKGxlZnQsIGJMZW5ndGggLSByaWdodCksXG4gICAgcmVtb3ZlOiBhTGVuZ3RoIC0gbGVmdCAtIHJpZ2h0XG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gZGlmZlRleHRDb250ZW50QW5kQXBwbHlEZWx0YShjb2xsYWJOb2RlLCBrZXksIHByZXZUZXh0LCBuZXh0VGV4dCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcbiAgbGV0IGN1cnNvck9mZnNldCA9IG5leHRUZXh0Lmxlbmd0aDtcblxuICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcblxuICAgIGlmIChhbmNob3Iua2V5ID09PSBrZXkpIHtcbiAgICAgIGN1cnNvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZGlmZiA9IHNpbXBsZURpZmZXaXRoQ3Vyc29yKHByZXZUZXh0LCBuZXh0VGV4dCwgY3Vyc29yT2Zmc2V0KTtcbiAgY29sbGFiTm9kZS5zcGxpY2VUZXh0KGRpZmYuaW5kZXgsIGRpZmYucmVtb3ZlLCBkaWZmLmluc2VydCk7XG59XG5cbmNsYXNzIENvbGxhYlRleHROb2RlIHtcbiAgY29uc3RydWN0b3IobWFwLCB0ZXh0LCBwYXJlbnQsIHR5cGUpIHtcbiAgICB0aGlzLl9rZXkgPSAnJztcbiAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGdldFByZXZOb2RlKG5vZGVNYXApIHtcbiAgICBpZiAobm9kZU1hcCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KHRoaXMuX2tleSk7XG4gICAgcmV0dXJuIGxleGljYWwuJGlzVGV4dE5vZGUobm9kZSkgPyBub2RlIDogbnVsbDtcbiAgfVxuXG4gIGdldE5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleSh0aGlzLl9rZXkpO1xuICAgIHJldHVybiBsZXhpY2FsLiRpc1RleHROb2RlKG5vZGUpID8gbm9kZSA6IG51bGw7XG4gIH1cblxuICBnZXRTaGFyZWRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXA7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlO1xuICB9XG5cbiAgZ2V0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLl9rZXk7XG4gIH1cblxuICBnZXRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0Lmxlbmd0aCArICh0aGlzLl9ub3JtYWxpemVkID8gMCA6IDEpO1xuICB9XG5cbiAgZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IGNvbGxhYkVsZW1lbnROb2RlID0gdGhpcy5fcGFyZW50O1xuICAgIHJldHVybiBjb2xsYWJFbGVtZW50Tm9kZS5nZXRDaGlsZE9mZnNldCh0aGlzKTtcbiAgfVxuXG4gIHNwbGljZVRleHQoaW5kZXgsIGRlbENvdW50LCBuZXdUZXh0KSB7XG4gICAgY29uc3QgY29sbGFiRWxlbWVudE5vZGUgPSB0aGlzLl9wYXJlbnQ7XG4gICAgY29uc3QgeG1sVGV4dCA9IGNvbGxhYkVsZW1lbnROb2RlLl94bWxUZXh0O1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuZ2V0T2Zmc2V0KCkgKyAxICsgaW5kZXg7XG5cbiAgICBpZiAoZGVsQ291bnQgIT09IDApIHtcbiAgICAgIHhtbFRleHQuZGVsZXRlKG9mZnNldCwgZGVsQ291bnQpO1xuICAgIH1cblxuICAgIGlmIChuZXdUZXh0ICE9PSAnJykge1xuICAgICAgeG1sVGV4dC5pbnNlcnQob2Zmc2V0LCBuZXdUZXh0KTtcbiAgICB9XG4gIH1cblxuICBzeW5jUHJvcGVydGllc0FuZFRleHRGcm9tTGV4aWNhbChiaW5kaW5nLCBuZXh0TGV4aWNhbE5vZGUsIHByZXZOb2RlTWFwKSB7XG4gICAgY29uc3QgcHJldkxleGljYWxOb2RlID0gdGhpcy5nZXRQcmV2Tm9kZShwcmV2Tm9kZU1hcCk7XG4gICAgY29uc3QgbmV4dFRleHQgPSBuZXh0TGV4aWNhbE5vZGUuX190ZXh0O1xuICAgIHN5bmNQcm9wZXJ0aWVzRnJvbUxleGljYWwoYmluZGluZywgdGhpcy5fbWFwLCBwcmV2TGV4aWNhbE5vZGUsIG5leHRMZXhpY2FsTm9kZSk7XG5cbiAgICBpZiAocHJldkxleGljYWxOb2RlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmV2VGV4dCA9IHByZXZMZXhpY2FsTm9kZS5fX3RleHQ7XG5cbiAgICAgIGlmIChwcmV2VGV4dCAhPT0gbmV4dFRleHQpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbmV4dExleGljYWxOb2RlLl9fa2V5O1xuICAgICAgICBkaWZmVGV4dENvbnRlbnRBbmRBcHBseURlbHRhKHRoaXMsIGtleSwgcHJldlRleHQsIG5leHRUZXh0KTtcbiAgICAgICAgdGhpcy5fdGV4dCA9IG5leHRUZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN5bmNQcm9wZXJ0aWVzQW5kVGV4dEZyb21ZanMoYmluZGluZywga2V5c0NoYW5nZWQpIHtcbiAgICBjb25zdCBsZXhpY2FsTm9kZSA9IHRoaXMuZ2V0Tm9kZSgpO1xuXG4gICAgaWYgKCEobGV4aWNhbE5vZGUgIT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgc3luY1Byb3BlcnRpZXNBbmRUZXh0RnJvbVlqczogY291bmQgbm90IGZpbmQgZGVjb3JhdG9yIG5vZGVgKTtcbiAgICB9XG5cbiAgICBzeW5jUHJvcGVydGllc0Zyb21ZanMoYmluZGluZywgdGhpcy5fbWFwLCBsZXhpY2FsTm9kZSwga2V5c0NoYW5nZWQpO1xuICAgIGNvbnN0IGNvbGxhYlRleHQgPSB0aGlzLl90ZXh0O1xuXG4gICAgaWYgKGxleGljYWxOb2RlLl9fdGV4dCAhPT0gY29sbGFiVGV4dCkge1xuICAgICAgY29uc3Qgd3JpdGFibGUgPSBsZXhpY2FsTm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgd3JpdGFibGUuX190ZXh0ID0gY29sbGFiVGV4dDtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KGJpbmRpbmcpIHtcbiAgICBjb25zdCBjb2xsYWJOb2RlTWFwID0gYmluZGluZy5jb2xsYWJOb2RlTWFwO1xuICAgIGNvbGxhYk5vZGVNYXAuZGVsZXRlKHRoaXMuX2tleSk7XG4gIH1cblxufVxuZnVuY3Rpb24gJGNyZWF0ZUNvbGxhYlRleHROb2RlKG1hcCwgdGV4dCwgcGFyZW50LCB0eXBlKSB7XG4gIGNvbnN0IGNvbGxhYk5vZGUgPSBuZXcgQ29sbGFiVGV4dE5vZGUobWFwLCB0ZXh0LCBwYXJlbnQsIHR5cGUpOyAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuXG4gIG1hcC5fY29sbGFiTm9kZSA9IGNvbGxhYk5vZGU7XG4gIHJldHVybiBjb2xsYWJOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBleGNsdWRlZFByb3BlcnRpZXMgPSBuZXcgU2V0KFsnX19rZXknLCAnX19wYXJlbnQnLCAnX19jYWNoZWRUZXh0JywgJ19fdGV4dCcsICdfX3NpemUnLCAnX19uZXh0JywgJ19fcHJldicsICdfX2ZpcnN0JywgJ19fbGFzdCddKTtcbmZ1bmN0aW9uICRnZXROb2RlQnlLZXlPclRocm93KGtleSkge1xuICBjb25zdCBub2RlID0gbGV4aWNhbC4kZ2V0Tm9kZUJ5S2V5KGtleSk7XG5cbiAgaWYgKCEobm9kZSAhPT0gbnVsbCkpIHtcbiAgICB0aHJvdyBFcnJvcihgY291bGQgbm90IGZpbmQgbm9kZSBieSBrZXlgKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gJGNyZWF0ZUNvbGxhYk5vZGVGcm9tTGV4aWNhbE5vZGUoYmluZGluZywgbGV4aWNhbE5vZGUsIHBhcmVudCkge1xuICBjb25zdCBub2RlVHlwZSA9IGxleGljYWxOb2RlLl9fdHlwZTtcbiAgbGV0IGNvbGxhYk5vZGU7XG5cbiAgaWYgKGxleGljYWwuJGlzRWxlbWVudE5vZGUobGV4aWNhbE5vZGUpKSB7XG4gICAgY29uc3QgeG1sVGV4dCA9IG5ldyB5anMuWG1sVGV4dCgpO1xuICAgIGNvbGxhYk5vZGUgPSAkY3JlYXRlQ29sbGFiRWxlbWVudE5vZGUoeG1sVGV4dCwgcGFyZW50LCBub2RlVHlwZSk7XG4gICAgY29sbGFiTm9kZS5zeW5jUHJvcGVydGllc0Zyb21MZXhpY2FsKGJpbmRpbmcsIGxleGljYWxOb2RlLCBudWxsKTtcbiAgICBjb2xsYWJOb2RlLnN5bmNDaGlsZHJlbkZyb21MZXhpY2FsKGJpbmRpbmcsIGxleGljYWxOb2RlLCBudWxsLCBudWxsLCBudWxsKTtcbiAgfSBlbHNlIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGxleGljYWxOb2RlKSkge1xuICAgIC8vIFRPRE8gY3JlYXRlIGEgdG9rZW4gdGV4dCBub2RlIGZvciB0b2tlbiwgc2VnbWVudGVkIG5vZGVzLlxuICAgIGNvbnN0IG1hcCA9IG5ldyB5anMuTWFwKCk7XG4gICAgY29sbGFiTm9kZSA9ICRjcmVhdGVDb2xsYWJUZXh0Tm9kZShtYXAsIGxleGljYWxOb2RlLl9fdGV4dCwgcGFyZW50LCBub2RlVHlwZSk7XG4gICAgY29sbGFiTm9kZS5zeW5jUHJvcGVydGllc0FuZFRleHRGcm9tTGV4aWNhbChiaW5kaW5nLCBsZXhpY2FsTm9kZSwgbnVsbCk7XG4gIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKGxleGljYWxOb2RlKSkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyB5anMuTWFwKCk7XG4gICAgbWFwLnNldCgnX190eXBlJywgJ2xpbmVicmVhaycpO1xuICAgIGNvbGxhYk5vZGUgPSAkY3JlYXRlQ29sbGFiTGluZUJyZWFrTm9kZShtYXAsIHBhcmVudCk7XG4gIH0gZWxzZSBpZiAobGV4aWNhbC4kaXNEZWNvcmF0b3JOb2RlKGxleGljYWxOb2RlKSkge1xuICAgIGNvbnN0IHhtbEVsZW0gPSBuZXcgeWpzLlhtbEVsZW1lbnQoKTtcbiAgICBjb2xsYWJOb2RlID0gJGNyZWF0ZUNvbGxhYkRlY29yYXRvck5vZGUoeG1sRWxlbSwgcGFyZW50LCBub2RlVHlwZSk7XG4gICAgY29sbGFiTm9kZS5zeW5jUHJvcGVydGllc0Zyb21MZXhpY2FsKGJpbmRpbmcsIGxleGljYWxOb2RlLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgdGV4dCwgZWxlbWVudCwgZGVjb3JhdG9yLCBvciBsaW5lYnJlYWsgbm9kZWApO1xuICAgIH1cbiAgfVxuXG4gIGNvbGxhYk5vZGUuX2tleSA9IGxleGljYWxOb2RlLl9fa2V5O1xuICByZXR1cm4gY29sbGFiTm9kZTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVR5cGVGcm9tU2hhcmVkVHlwZShzaGFyZWRUeXBlKSB7XG4gIGNvbnN0IHR5cGUgPSBzaGFyZWRUeXBlIGluc3RhbmNlb2YgeWpzLk1hcCA/IHNoYXJlZFR5cGUuZ2V0KCdfX3R5cGUnKSA6IHNoYXJlZFR5cGUuZ2V0QXR0cmlidXRlKCdfX3R5cGUnKTtcblxuICBpZiAoISh0eXBlICE9IG51bGwpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHNoYXJlZCB0eXBlIHRvIGluY2x1ZGUgdHlwZSBhdHRyaWJ1dGVgKTtcbiAgfVxuXG4gIHJldHVybiB0eXBlO1xufVxuXG5mdW5jdGlvbiBnZXRPckluaXRDb2xsYWJOb2RlRnJvbVNoYXJlZFR5cGUoYmluZGluZywgc2hhcmVkVHlwZSwgcGFyZW50KSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gIGNvbnN0IGNvbGxhYk5vZGUgPSBzaGFyZWRUeXBlLl9jb2xsYWJOb2RlO1xuXG4gIGlmIChjb2xsYWJOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCByZWdpc3RlcmVkTm9kZXMgPSBiaW5kaW5nLmVkaXRvci5fbm9kZXM7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlRnJvbVNoYXJlZFR5cGUoc2hhcmVkVHlwZSk7XG4gICAgY29uc3Qgbm9kZUluZm8gPSByZWdpc3RlcmVkTm9kZXMuZ2V0KHR5cGUpO1xuXG4gICAgaWYgKCEobm9kZUluZm8gIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBOb2RlICR7dHlwZX0gaXMgbm90IHJlZ2lzdGVyZWRgKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaGFyZWRQYXJlbnQgPSBzaGFyZWRUeXBlLnBhcmVudDtcbiAgICBjb25zdCB0YXJnZXRQYXJlbnQgPSBwYXJlbnQgPT09IHVuZGVmaW5lZCAmJiBzaGFyZWRQYXJlbnQgIT09IG51bGwgPyBnZXRPckluaXRDb2xsYWJOb2RlRnJvbVNoYXJlZFR5cGUoYmluZGluZywgc2hhcmVkUGFyZW50KSA6IHBhcmVudCB8fCBudWxsO1xuXG4gICAgaWYgKCEodGFyZ2V0UGFyZW50IGluc3RhbmNlb2YgQ29sbGFiRWxlbWVudE5vZGUpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgcGFyZW50IHRvIGJlIGEgY29sbGFiIGVsZW1lbnQgbm9kZWApO1xuICAgIH1cblxuICAgIGlmIChzaGFyZWRUeXBlIGluc3RhbmNlb2YgeWpzLlhtbFRleHQpIHtcbiAgICAgIHJldHVybiAkY3JlYXRlQ29sbGFiRWxlbWVudE5vZGUoc2hhcmVkVHlwZSwgdGFyZ2V0UGFyZW50LCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKHNoYXJlZFR5cGUgaW5zdGFuY2VvZiB5anMuTWFwKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ2xpbmVicmVhaycpIHtcbiAgICAgICAgcmV0dXJuICRjcmVhdGVDb2xsYWJMaW5lQnJlYWtOb2RlKHNoYXJlZFR5cGUsIHRhcmdldFBhcmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkY3JlYXRlQ29sbGFiVGV4dE5vZGUoc2hhcmVkVHlwZSwgJycsIHRhcmdldFBhcmVudCwgdHlwZSk7XG4gICAgfSBlbHNlIGlmIChzaGFyZWRUeXBlIGluc3RhbmNlb2YgeWpzLlhtbEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAkY3JlYXRlQ29sbGFiRGVjb3JhdG9yTm9kZShzaGFyZWRUeXBlLCB0YXJnZXRQYXJlbnQsIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb2xsYWJOb2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlTGV4aWNhbE5vZGVGcm9tQ29sbGFiTm9kZShiaW5kaW5nLCBjb2xsYWJOb2RlLCBwYXJlbnRLZXkpIHtcbiAgY29uc3QgdHlwZSA9IGNvbGxhYk5vZGUuZ2V0VHlwZSgpO1xuICBjb25zdCByZWdpc3RlcmVkTm9kZXMgPSBiaW5kaW5nLmVkaXRvci5fbm9kZXM7XG4gIGNvbnN0IG5vZGVJbmZvID0gcmVnaXN0ZXJlZE5vZGVzLmdldCh0eXBlKTtcblxuICBpZiAoIShub2RlSW5mbyAhPT0gdW5kZWZpbmVkKSkge1xuICAgIHRocm93IEVycm9yKGBOb2RlICR7dHlwZX0gaXMgbm90IHJlZ2lzdGVyZWRgKTtcbiAgfVxuXG4gIGNvbnN0IGxleGljYWxOb2RlID0gbmV3IG5vZGVJbmZvLmtsYXNzKCk7XG4gIGxleGljYWxOb2RlLl9fcGFyZW50ID0gcGFyZW50S2V5O1xuICBjb2xsYWJOb2RlLl9rZXkgPSBsZXhpY2FsTm9kZS5fX2tleTtcblxuICBpZiAoY29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYkVsZW1lbnROb2RlKSB7XG4gICAgY29uc3QgeG1sVGV4dCA9IGNvbGxhYk5vZGUuX3htbFRleHQ7XG4gICAgY29sbGFiTm9kZS5zeW5jUHJvcGVydGllc0Zyb21ZanMoYmluZGluZywgbnVsbCk7XG4gICAgY29sbGFiTm9kZS5hcHBseUNoaWxkcmVuWWpzRGVsdGEoYmluZGluZywgeG1sVGV4dC50b0RlbHRhKCkpO1xuICAgIGNvbGxhYk5vZGUuc3luY0NoaWxkcmVuRnJvbVlqcyhiaW5kaW5nKTtcbiAgfSBlbHNlIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiVGV4dE5vZGUpIHtcbiAgICBjb2xsYWJOb2RlLnN5bmNQcm9wZXJ0aWVzQW5kVGV4dEZyb21ZanMoYmluZGluZywgbnVsbCk7XG4gIH0gZWxzZSBpZiAoY29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYkRlY29yYXRvck5vZGUpIHtcbiAgICBjb2xsYWJOb2RlLnN5bmNQcm9wZXJ0aWVzRnJvbVlqcyhiaW5kaW5nLCBudWxsKTtcbiAgfVxuXG4gIGJpbmRpbmcuY29sbGFiTm9kZU1hcC5zZXQobGV4aWNhbE5vZGUuX19rZXksIGNvbGxhYk5vZGUpO1xuICByZXR1cm4gbGV4aWNhbE5vZGU7XG59XG5mdW5jdGlvbiBzeW5jUHJvcGVydGllc0Zyb21ZanMoYmluZGluZywgc2hhcmVkVHlwZSwgbGV4aWNhbE5vZGUsIGtleXNDaGFuZ2VkKSB7XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBrZXlzQ2hhbmdlZCA9PT0gbnVsbCA/IHNoYXJlZFR5cGUgaW5zdGFuY2VvZiB5anMuTWFwID8gQXJyYXkuZnJvbShzaGFyZWRUeXBlLmtleXMoKSkgOiBPYmplY3Qua2V5cyhzaGFyZWRUeXBlLmdldEF0dHJpYnV0ZXMoKSkgOiBBcnJheS5mcm9tKGtleXNDaGFuZ2VkKTtcbiAgbGV0IHdyaXRhYmxlTm9kZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG5cbiAgICBpZiAoZXhjbHVkZWRQcm9wZXJ0aWVzLmhhcyhwcm9wZXJ0eSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZWYWx1ZSA9IGxleGljYWxOb2RlW3Byb3BlcnR5XTtcbiAgICBsZXQgbmV4dFZhbHVlID0gc2hhcmVkVHlwZSBpbnN0YW5jZW9mIHlqcy5NYXAgPyBzaGFyZWRUeXBlLmdldChwcm9wZXJ0eSkgOiBzaGFyZWRUeXBlLmdldEF0dHJpYnV0ZShwcm9wZXJ0eSk7XG5cbiAgICBpZiAocHJldlZhbHVlICE9PSBuZXh0VmFsdWUpIHtcbiAgICAgIGlmIChuZXh0VmFsdWUgaW5zdGFuY2VvZiB5anMuRG9jKSB7XG4gICAgICAgIGNvbnN0IHlqc0RvY01hcCA9IGJpbmRpbmcuZG9jTWFwO1xuXG4gICAgICAgIGlmIChwcmV2VmFsdWUgaW5zdGFuY2VvZiB5anMuRG9jKSB7XG4gICAgICAgICAgeWpzRG9jTWFwLmRlbGV0ZShwcmV2VmFsdWUuZ3VpZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXN0ZWRFZGl0b3IgPSBsZXhpY2FsLmNyZWF0ZUVkaXRvcigpO1xuICAgICAgICBjb25zdCBrZXkgPSBuZXh0VmFsdWUuZ3VpZDtcbiAgICAgICAgbmVzdGVkRWRpdG9yLl9rZXkgPSBrZXk7XG4gICAgICAgIHlqc0RvY01hcC5zZXQoa2V5LCBuZXh0VmFsdWUpO1xuICAgICAgICBuZXh0VmFsdWUgPSBuZXN0ZWRFZGl0b3I7XG4gICAgICB9XG5cbiAgICAgIGlmICh3cml0YWJsZU5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3cml0YWJsZU5vZGUgPSBsZXhpY2FsTm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgfVxuXG4gICAgICB3cml0YWJsZU5vZGVbcHJvcGVydHldID0gbmV4dFZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3luY1Byb3BlcnRpZXNGcm9tTGV4aWNhbChiaW5kaW5nLCBzaGFyZWRUeXBlLCBwcmV2TGV4aWNhbE5vZGUsIG5leHRMZXhpY2FsTm9kZSkge1xuICBjb25zdCB0eXBlID0gbmV4dExleGljYWxOb2RlLl9fdHlwZTtcbiAgY29uc3Qgbm9kZVByb3BlcnRpZXMgPSBiaW5kaW5nLm5vZGVQcm9wZXJ0aWVzO1xuICBsZXQgcHJvcGVydGllcyA9IG5vZGVQcm9wZXJ0aWVzLmdldCh0eXBlKTtcblxuICBpZiAocHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcHJvcGVydGllcyA9IE9iamVjdC5rZXlzKG5leHRMZXhpY2FsTm9kZSkuZmlsdGVyKHByb3BlcnR5ID0+IHtcbiAgICAgIHJldHVybiAhZXhjbHVkZWRQcm9wZXJ0aWVzLmhhcyhwcm9wZXJ0eSk7XG4gICAgfSk7XG4gICAgbm9kZVByb3BlcnRpZXMuc2V0KHR5cGUsIHByb3BlcnRpZXMpO1xuICB9XG5cbiAgY29uc3QgRWRpdG9yQ2xhc3MgPSBiaW5kaW5nLmVkaXRvci5jb25zdHJ1Y3RvcjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgY29uc3QgcHJldlZhbHVlID0gcHJldkxleGljYWxOb2RlID09PSBudWxsID8gdW5kZWZpbmVkIDogcHJldkxleGljYWxOb2RlW3Byb3BlcnR5XTtcbiAgICBsZXQgbmV4dFZhbHVlID0gbmV4dExleGljYWxOb2RlW3Byb3BlcnR5XTtcblxuICAgIGlmIChwcmV2VmFsdWUgIT09IG5leHRWYWx1ZSkge1xuICAgICAgaWYgKG5leHRWYWx1ZSBpbnN0YW5jZW9mIEVkaXRvckNsYXNzKSB7XG4gICAgICAgIGNvbnN0IHlqc0RvY01hcCA9IGJpbmRpbmcuZG9jTWFwO1xuICAgICAgICBsZXQgcHJldkRvYztcblxuICAgICAgICBpZiAocHJldlZhbHVlIGluc3RhbmNlb2YgRWRpdG9yQ2xhc3MpIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIExleGljYWwgbm9kZVxuICAgICAgICAgIGNvbnN0IHByZXZLZXkgPSBwcmV2VmFsdWUuX2tleTtcbiAgICAgICAgICBwcmV2RG9jID0geWpzRG9jTWFwLmdldChwcmV2S2V5KTtcbiAgICAgICAgICB5anNEb2NNYXAuZGVsZXRlKHByZXZLZXkpO1xuICAgICAgICB9IC8vIElmIHdlIGFscmVhZHkgaGF2ZSBhIGRvY3VtZW50LCB1c2UgaXQuXG5cblxuICAgICAgICBjb25zdCBkb2MgPSBwcmV2RG9jIHx8IG5ldyB5anMuRG9jKCk7XG4gICAgICAgIGNvbnN0IGtleSA9IGRvYy5ndWlkOyAvLyBAdHMtZXhwZWN0LWVycm9yIExleGljYWwgbm9kZVxuXG4gICAgICAgIG5leHRWYWx1ZS5fa2V5ID0ga2V5O1xuICAgICAgICB5anNEb2NNYXAuc2V0KGtleSwgZG9jKTtcbiAgICAgICAgbmV4dFZhbHVlID0gZG9jOyAvLyBNYXJrIHRoZSBub2RlIGRpcnR5IGFzIHdlJ3ZlIGFzc2lnbmVkIGEgbmV3IGtleSB0byBpdFxuXG4gICAgICAgIGJpbmRpbmcuZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgbmV4dExleGljYWxOb2RlLm1hcmtEaXJ0eSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoYXJlZFR5cGUgaW5zdGFuY2VvZiB5anMuTWFwKSB7XG4gICAgICAgIHNoYXJlZFR5cGUuc2V0KHByb3BlcnR5LCBuZXh0VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcmVkVHlwZS5zZXRBdHRyaWJ1dGUocHJvcGVydHksIG5leHRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzcGxpY2VTdHJpbmcoc3RyLCBpbmRleCwgZGVsQ291bnQsIG5ld1RleHQpIHtcbiAgcmV0dXJuIHN0ci5zbGljZSgwLCBpbmRleCkgKyBuZXdUZXh0ICsgc3RyLnNsaWNlKGluZGV4ICsgZGVsQ291bnQpO1xufVxuZnVuY3Rpb24gZ2V0UG9zaXRpb25Gcm9tRWxlbWVudEFuZE9mZnNldChub2RlLCBvZmZzZXQsIGJvdW5kYXJ5SXNFZGdlKSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLl9jaGlsZHJlbjtcbiAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgZm9yICg7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBjaGlsZE9mZnNldCA9IGluZGV4O1xuICAgIGNvbnN0IHNpemUgPSBjaGlsZC5nZXRTaXplKCk7XG4gICAgaW5kZXggKz0gc2l6ZTtcbiAgICBjb25zdCBleGNlZWRzQm91bmRhcnkgPSBib3VuZGFyeUlzRWRnZSA/IGluZGV4ID49IG9mZnNldCA6IGluZGV4ID4gb2Zmc2V0O1xuXG4gICAgaWYgKGV4Y2VlZHNCb3VuZGFyeSAmJiBjaGlsZCBpbnN0YW5jZW9mIENvbGxhYlRleHROb2RlKSB7XG4gICAgICBsZXQgdGV4dE9mZnNldCA9IG9mZnNldCAtIGNoaWxkT2Zmc2V0IC0gMTtcblxuICAgICAgaWYgKHRleHRPZmZzZXQgPCAwKSB7XG4gICAgICAgIHRleHRPZmZzZXQgPSAwO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkaWZmTGVuZ3RoID0gaW5kZXggLSBvZmZzZXQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGg6IGRpZmZMZW5ndGgsXG4gICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICBub2RlSW5kZXg6IGksXG4gICAgICAgIG9mZnNldDogdGV4dE9mZnNldFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPiBvZmZzZXQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgbm9kZTogY2hpbGQsXG4gICAgICAgIG5vZGVJbmRleDogaSxcbiAgICAgICAgb2Zmc2V0OiBjaGlsZE9mZnNldFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGkgPT09IGNoaWxkcmVuTGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICBub2RlOiBudWxsLFxuICAgICAgICBub2RlSW5kZXg6IGkgKyAxLFxuICAgICAgICBvZmZzZXQ6IGNoaWxkT2Zmc2V0ICsgMVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlbmd0aDogMCxcbiAgICBub2RlOiBudWxsLFxuICAgIG5vZGVJbmRleDogMCxcbiAgICBvZmZzZXQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGRvZXNTZWxlY3Rpb25OZWVkUmVjb3ZlcmluZyhzZWxlY3Rpb24pIHtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGxldCByZWNvdmVyeU5lZWRlZCA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuXG4gICAgaWYgKCAvLyBXZSBtaWdodCBoYXZlIHJlbW92ZWQgYSBub2RlIHRoYXQgbm8gbG9uZ2VyIGV4aXN0c1xuICAgICFhbmNob3JOb2RlLmlzQXR0YWNoZWQoKSB8fCAhZm9jdXNOb2RlLmlzQXR0YWNoZWQoKSB8fCAvLyBJZiB3ZSd2ZSBzcGxpdCBhIG5vZGUsIHRoZW4gdGhlIG9mZnNldCBtaWdodCBub3QgYmUgcmlnaHRcbiAgICBsZXhpY2FsLiRpc1RleHROb2RlKGFuY2hvck5vZGUpICYmIGFuY2hvci5vZmZzZXQgPiBhbmNob3JOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpIHx8IGxleGljYWwuJGlzVGV4dE5vZGUoZm9jdXNOb2RlKSAmJiBmb2N1cy5vZmZzZXQgPiBmb2N1c05vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgIHJlY292ZXJ5TmVlZGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBTb21ldGltZXMgY2hlY2tpbmcgbm9yIGEgbm9kZSB2aWEgZ2V0Tm9kZSBtaWdodCB0cmlnZ2VyXG4gICAgLy8gYW4gZXJyb3IsIHNvIHdlIG5lZWQgcmVjb3ZlcnkgdGhlbiB0b28uXG4gICAgcmVjb3ZlcnlOZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlY292ZXJ5TmVlZGVkO1xufVxuZnVuY3Rpb24gc3luY1dpdGhUcmFuc2FjdGlvbihiaW5kaW5nLCBmbikge1xuICBiaW5kaW5nLmRvYy50cmFuc2FjdChmbiwgYmluZGluZyk7XG59XG5mdW5jdGlvbiBjcmVhdGVDaGlsZHJlbkFycmF5KGVsZW1lbnQsIG5vZGVNYXApIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgbGV0IG5vZGVLZXkgPSBlbGVtZW50Ll9fZmlyc3Q7XG5cbiAgd2hpbGUgKG5vZGVLZXkgIT09IG51bGwpIHtcbiAgICBjb25zdCBub2RlID0gbm9kZU1hcCA9PT0gbnVsbCA/IGxleGljYWwuJGdldE5vZGVCeUtleShub2RlS2V5KSA6IG5vZGVNYXAuZ2V0KG5vZGVLZXkpO1xuXG4gICAgaWYgKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBjcmVhdGVDaGlsZHJlbkFycmF5OiBub2RlIGRvZXMgbm90IGV4aXN0IGluIG5vZGVNYXBgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZHJlbi5wdXNoKG5vZGVLZXkpO1xuICAgIG5vZGVLZXkgPSBub2RlLl9fbmV4dDtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIHJlbW92ZUZyb21QYXJlbnQobm9kZSkge1xuICBjb25zdCBvbGRQYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuXG4gIGlmIChvbGRQYXJlbnQgIT09IG51bGwpIHtcbiAgICBjb25zdCB3cml0YWJsZU5vZGUgPSBub2RlLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3Qgd3JpdGFibGVQYXJlbnQgPSBvbGRQYXJlbnQuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7IC8vIFRPRE86IHRoaXMgZnVuY3Rpb24gZHVwbGljYXRlcyBhIGJ1bmNoIG9mIG9wZXJhdGlvbnMsIGNhbiBiZSBzaW1wbGlmaWVkLlxuXG4gICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlUGFyZW50Ll9fZmlyc3QgPSBuZXh0U2libGluZy5fX2tleTtcbiAgICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVQYXJlbnQuX19maXJzdCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlUHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5nZXRXcml0YWJsZSgpO1xuXG4gICAgICBpZiAobmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlTmV4dFNpYmxpbmcuX19wcmV2ID0gd3JpdGFibGVQcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSB3cml0YWJsZU5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB3cml0YWJsZU5vZGUuX19wcmV2ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobmV4dFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3cml0YWJsZVByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVQYXJlbnQuX19sYXN0ID0gcHJldlNpYmxpbmcuX19rZXk7XG4gICAgICAgIHdyaXRhYmxlUHJldlNpYmxpbmcuX19uZXh0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRhYmxlUGFyZW50Ll9fbGFzdCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlTmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5nZXRXcml0YWJsZSgpO1xuXG4gICAgICBpZiAocHJldlNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlUHJldlNpYmxpbmcuX19uZXh0ID0gd3JpdGFibGVOZXh0U2libGluZy5fX2tleTtcbiAgICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSB3cml0YWJsZVByZXZTaWJsaW5nLl9fa2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB3cml0YWJsZU5vZGUuX19uZXh0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB3cml0YWJsZVBhcmVudC5fX3NpemUtLTtcbiAgICB3cml0YWJsZU5vZGUuX19wYXJlbnQgPSBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNsYXNzIENvbGxhYkRlY29yYXRvck5vZGUge1xuICBjb25zdHJ1Y3Rvcih4bWxFbGVtLCBwYXJlbnQsIHR5cGUpIHtcbiAgICB0aGlzLl9rZXkgPSAnJztcbiAgICB0aGlzLl94bWxFbGVtID0geG1sRWxlbTtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fdW5vYnNlcnZlcnMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICBnZXRQcmV2Tm9kZShub2RlTWFwKSB7XG4gICAgaWYgKG5vZGVNYXAgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldCh0aGlzLl9rZXkpO1xuICAgIHJldHVybiBsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUobm9kZSkgPyBub2RlIDogbnVsbDtcbiAgfVxuXG4gIGdldE5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGxleGljYWwuJGdldE5vZGVCeUtleSh0aGlzLl9rZXkpO1xuICAgIHJldHVybiBsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUobm9kZSkgPyBub2RlIDogbnVsbDtcbiAgfVxuXG4gIGdldFNoYXJlZFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3htbEVsZW07XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlO1xuICB9XG5cbiAgZ2V0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLl9rZXk7XG4gIH1cblxuICBnZXRTaXplKCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IGNvbGxhYkVsZW1lbnROb2RlID0gdGhpcy5fcGFyZW50O1xuICAgIHJldHVybiBjb2xsYWJFbGVtZW50Tm9kZS5nZXRDaGlsZE9mZnNldCh0aGlzKTtcbiAgfVxuXG4gIHN5bmNQcm9wZXJ0aWVzRnJvbUxleGljYWwoYmluZGluZywgbmV4dExleGljYWxOb2RlLCBwcmV2Tm9kZU1hcCkge1xuICAgIGNvbnN0IHByZXZMZXhpY2FsTm9kZSA9IHRoaXMuZ2V0UHJldk5vZGUocHJldk5vZGVNYXApO1xuICAgIGNvbnN0IHhtbEVsZW0gPSB0aGlzLl94bWxFbGVtO1xuICAgIHN5bmNQcm9wZXJ0aWVzRnJvbUxleGljYWwoYmluZGluZywgeG1sRWxlbSwgcHJldkxleGljYWxOb2RlLCBuZXh0TGV4aWNhbE5vZGUpO1xuICB9XG5cbiAgc3luY1Byb3BlcnRpZXNGcm9tWWpzKGJpbmRpbmcsIGtleXNDaGFuZ2VkKSB7XG4gICAgY29uc3QgbGV4aWNhbE5vZGUgPSB0aGlzLmdldE5vZGUoKTtcblxuICAgIGlmICghKGxleGljYWxOb2RlICE9PSBudWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYHN5bmNQcm9wZXJ0aWVzRnJvbVlqczogY291bmQgbm90IGZpbmQgZGVjb3JhdG9yIG5vZGVgKTtcbiAgICB9XG5cbiAgICBjb25zdCB4bWxFbGVtID0gdGhpcy5feG1sRWxlbTtcbiAgICBzeW5jUHJvcGVydGllc0Zyb21ZanMoYmluZGluZywgeG1sRWxlbSwgbGV4aWNhbE5vZGUsIGtleXNDaGFuZ2VkKTtcbiAgfVxuXG4gIGRlc3Ryb3koYmluZGluZykge1xuICAgIGNvbnN0IGNvbGxhYk5vZGVNYXAgPSBiaW5kaW5nLmNvbGxhYk5vZGVNYXA7XG4gICAgY29sbGFiTm9kZU1hcC5kZWxldGUodGhpcy5fa2V5KTtcblxuICAgIHRoaXMuX3Vub2JzZXJ2ZXJzLmZvckVhY2godW5vYnNlcnZlciA9PiB1bm9ic2VydmVyKCkpO1xuXG4gICAgdGhpcy5fdW5vYnNlcnZlcnMuY2xlYXIoKTtcbiAgfVxuXG59XG5mdW5jdGlvbiAkY3JlYXRlQ29sbGFiRGVjb3JhdG9yTm9kZSh4bWxFbGVtLCBwYXJlbnQsIHR5cGUpIHtcbiAgY29uc3QgY29sbGFiTm9kZSA9IG5ldyBDb2xsYWJEZWNvcmF0b3JOb2RlKHhtbEVsZW0sIHBhcmVudCwgdHlwZSk7IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG5cbiAgeG1sRWxlbS5fY29sbGFiTm9kZSA9IGNvbGxhYk5vZGU7XG4gIHJldHVybiBjb2xsYWJOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jbGFzcyBDb2xsYWJFbGVtZW50Tm9kZSB7XG4gIGNvbnN0cnVjdG9yKHhtbFRleHQsIHBhcmVudCwgdHlwZSkge1xuICAgIHRoaXMuX2tleSA9ICcnO1xuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgdGhpcy5feG1sVGV4dCA9IHhtbFRleHQ7XG4gICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB9XG5cbiAgZ2V0UHJldk5vZGUobm9kZU1hcCkge1xuICAgIGlmIChub2RlTWFwID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQodGhpcy5fa2V5KTtcbiAgICByZXR1cm4gbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShub2RlKSA/IG5vZGUgOiBudWxsO1xuICB9XG5cbiAgZ2V0Tm9kZSgpIHtcbiAgICBjb25zdCBub2RlID0gbGV4aWNhbC4kZ2V0Tm9kZUJ5S2V5KHRoaXMuX2tleSk7XG4gICAgcmV0dXJuIGxleGljYWwuJGlzRWxlbWVudE5vZGUobm9kZSkgPyBub2RlIDogbnVsbDtcbiAgfVxuXG4gIGdldFNoYXJlZFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3htbFRleHQ7XG4gIH1cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl90eXBlO1xuICB9XG5cbiAgZ2V0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLl9rZXk7XG4gIH1cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPT09IDA7XG4gIH1cblxuICBnZXRTaXplKCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IGNvbGxhYkVsZW1lbnROb2RlID0gdGhpcy5fcGFyZW50O1xuXG4gICAgaWYgKCEoY29sbGFiRWxlbWVudE5vZGUgIT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgZ2V0T2Zmc2V0OiBjb3VuZCBub3QgZmluZCBjb2xsYWIgZWxlbWVudCBub2RlYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbGxhYkVsZW1lbnROb2RlLmdldENoaWxkT2Zmc2V0KHRoaXMpO1xuICB9XG5cbiAgc3luY1Byb3BlcnRpZXNGcm9tWWpzKGJpbmRpbmcsIGtleXNDaGFuZ2VkKSB7XG4gICAgY29uc3QgbGV4aWNhbE5vZGUgPSB0aGlzLmdldE5vZGUoKTtcblxuICAgIGlmICghKGxleGljYWxOb2RlICE9PSBudWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYHN5bmNQcm9wZXJ0aWVzRnJvbVlqczogY291bmQgbm90IGZpbmQgZWxlbWVudCBub2RlYCk7XG4gICAgfVxuXG4gICAgc3luY1Byb3BlcnRpZXNGcm9tWWpzKGJpbmRpbmcsIHRoaXMuX3htbFRleHQsIGxleGljYWxOb2RlLCBrZXlzQ2hhbmdlZCk7XG4gIH1cblxuICBhcHBseUNoaWxkcmVuWWpzRGVsdGEoYmluZGluZywgZGVsdGFzKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICBsZXQgY3VyckluZGV4ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWx0YSA9IGRlbHRhc1tpXTtcbiAgICAgIGNvbnN0IGluc2VydERlbHRhID0gZGVsdGEuaW5zZXJ0O1xuICAgICAgY29uc3QgZGVsZXRlRGVsdGEgPSBkZWx0YS5kZWxldGU7XG5cbiAgICAgIGlmIChkZWx0YS5yZXRhaW4gIT0gbnVsbCkge1xuICAgICAgICBjdXJySW5kZXggKz0gZGVsdGEucmV0YWluO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVsZXRlRGVsdGEgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGxldCBkZWxldGlvblNpemUgPSBkZWxldGVEZWx0YTtcblxuICAgICAgICB3aGlsZSAoZGVsZXRpb25TaXplID4gMCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBub2RlSW5kZXgsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBsZW5ndGhcbiAgICAgICAgICB9ID0gZ2V0UG9zaXRpb25Gcm9tRWxlbWVudEFuZE9mZnNldCh0aGlzLCBjdXJySW5kZXgsIGZhbHNlKTtcblxuICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQ29sbGFiRWxlbWVudE5vZGUgfHwgbm9kZSBpbnN0YW5jZW9mIENvbGxhYkxpbmVCcmVha05vZGUgfHwgbm9kZSBpbnN0YW5jZW9mIENvbGxhYkRlY29yYXRvck5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShub2RlSW5kZXgsIDEpO1xuICAgICAgICAgICAgZGVsZXRpb25TaXplIC09IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQ29sbGFiVGV4dE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbENvdW50ID0gTWF0aC5taW4oZGVsZXRpb25TaXplLCBsZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgcHJldkNvbGxhYk5vZGUgPSBub2RlSW5kZXggIT09IDAgPyBjaGlsZHJlbltub2RlSW5kZXggLSAxXSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCBub2RlU2l6ZSA9IG5vZGUuZ2V0U2l6ZSgpO1xuXG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSAwICYmIGRlbENvdW50ID09PSAxICYmIG5vZGVJbmRleCA+IDAgJiYgcHJldkNvbGxhYk5vZGUgaW5zdGFuY2VvZiBDb2xsYWJUZXh0Tm9kZSAmJiBsZW5ndGggPT09IG5vZGVTaXplICYmIC8vIElmIHRoZSBub2RlIGhhcyBubyBrZXlzLCBpdCdzIGJlZW4gZGVsZXRlZFxuICAgICAgICAgICAgQXJyYXkuZnJvbShub2RlLl9tYXAua2V5cygpKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gTWVyZ2UgdGhlIHRleHQgbm9kZSB3aXRoIHByZXZpb3VzLlxuICAgICAgICAgICAgICBwcmV2Q29sbGFiTm9kZS5fdGV4dCArPSBub2RlLl90ZXh0O1xuICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2Uobm9kZUluZGV4LCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID09PSAwICYmIGRlbENvdW50ID09PSBub2RlU2l6ZSkge1xuICAgICAgICAgICAgICAvLyBUaGUgZW50aXJlIHRoaW5nIG5lZWRzIHJlbW92aW5nXG4gICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShub2RlSW5kZXgsIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZS5fdGV4dCA9IHNwbGljZVN0cmluZyhub2RlLl90ZXh0LCBvZmZzZXQsIGRlbENvdW50LCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0aW9uU2l6ZSAtPSBkZWxDb3VudDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FuIG9jY3VyIGR1ZSB0byB0aGUgZGVsZXRpb24gZnJvbSB0aGUgZGFuZ2xpbmcgdGV4dCBoZXVyaXN0aWMgYmVsb3cuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5zZXJ0RGVsdGEgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIGluc2VydERlbHRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBvZmZzZXRcbiAgICAgICAgICB9ID0gZ2V0UG9zaXRpb25Gcm9tRWxlbWVudEFuZE9mZnNldCh0aGlzLCBjdXJySW5kZXgsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBDb2xsYWJUZXh0Tm9kZSkge1xuICAgICAgICAgICAgbm9kZS5fdGV4dCA9IHNwbGljZVN0cmluZyhub2RlLl90ZXh0LCBvZmZzZXQsIDAsIGluc2VydERlbHRhKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgd2UgY2FuIGltcHJvdmUgdGhpcyBieSBrZWVwaW5nIGFyb3VuZCBhIHJlZHVuZGFudFxuICAgICAgICAgICAgLy8gdGV4dCBub2RlIG1hcCwgcmF0aGVyIHRoYW4gcmVtb3ZpbmcgYWxsIHRoZSB0ZXh0IG5vZGVzLCBzbyB0aGVyZVxuICAgICAgICAgICAgLy8gbmV2ZXIgY2FuIGJlIGRhbmdsaW5nIHRleHQuXG4gICAgICAgICAgICAvLyBXZSBoYXZlIGEgY29uZmxpY3Qgd2hlcmUgdGhlcmUgd2FzIGxpa2VseSBhIENvbGxhYlRleHROb2RlIGFuZFxuICAgICAgICAgICAgLy8gYW4gTGV4aWNhbCBUZXh0Tm9kZSB0b28sIGJ1dCB0aGV5IHdlcmUgcmVtb3ZlZCBpbiBhIG1lcmdlLiBTb1xuICAgICAgICAgICAgLy8gbGV0J3MganVzdCBpZ25vcmUgdGhlIHRleHQgYW5kIHRyaWdnZXIgYSByZW1vdmFsIGZvciBpdCBmcm9tIG91clxuICAgICAgICAgICAgLy8gc2hhcmVkIHR5cGUuXG4gICAgICAgICAgICB0aGlzLl94bWxUZXh0LmRlbGV0ZShvZmZzZXQsIGluc2VydERlbHRhLmxlbmd0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyckluZGV4ICs9IGluc2VydERlbHRhLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzaGFyZWRUeXBlID0gaW5zZXJ0RGVsdGE7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbm9kZUluZGV4XG4gICAgICAgICAgfSA9IGdldFBvc2l0aW9uRnJvbUVsZW1lbnRBbmRPZmZzZXQodGhpcywgY3VyckluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgY29uc3QgY29sbGFiTm9kZSA9IGdldE9ySW5pdENvbGxhYk5vZGVGcm9tU2hhcmVkVHlwZShiaW5kaW5nLCBzaGFyZWRUeXBlLCB0aGlzKTtcbiAgICAgICAgICBjaGlsZHJlbi5zcGxpY2Uobm9kZUluZGV4LCAwLCBjb2xsYWJOb2RlKTtcbiAgICAgICAgICBjdXJySW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGRlbHRhIGZvcm1hdCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN5bmNDaGlsZHJlbkZyb21ZanMoYmluZGluZykge1xuICAgIC8vIE5vdyBkaWZmIHRoZSBjaGlsZHJlbiBvZiB0aGUgY29sbGFiIG5vZGUgd2l0aCB0aGF0IG9mIG91ciBleGlzdGluZyBMZXhpY2FsIG5vZGUuXG4gICAgY29uc3QgbGV4aWNhbE5vZGUgPSB0aGlzLmdldE5vZGUoKTtcblxuICAgIGlmICghKGxleGljYWxOb2RlICE9PSBudWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYHN5bmNDaGlsZHJlbkZyb21ZanM6IGNvdW5kIG5vdCBmaW5kIGVsZW1lbnQgbm9kZWApO1xuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IGxleGljYWxOb2RlLl9fa2V5O1xuICAgIGNvbnN0IHByZXZMZXhpY2FsQ2hpbGRyZW5LZXlzID0gY3JlYXRlQ2hpbGRyZW5BcnJheShsZXhpY2FsTm9kZSwgbnVsbCk7XG4gICAgY29uc3QgbGV4aWNhbENoaWxkcmVuS2V5c0xlbmd0aCA9IHByZXZMZXhpY2FsQ2hpbGRyZW5LZXlzLmxlbmd0aDtcbiAgICBjb25zdCBjb2xsYWJDaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIGNvbnN0IGNvbGxhYkNoaWxkcmVuTGVuZ3RoID0gY29sbGFiQ2hpbGRyZW4ubGVuZ3RoO1xuICAgIGNvbnN0IGNvbGxhYk5vZGVNYXAgPSBiaW5kaW5nLmNvbGxhYk5vZGVNYXA7XG4gICAgY29uc3QgdmlzaXRlZEtleXMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IGNvbGxhYktleXM7XG4gICAgbGV0IHdyaXRhYmxlTGV4aWNhbE5vZGU7XG4gICAgbGV0IHByZXZJbmRleCA9IDA7XG4gICAgbGV0IHByZXZDaGlsZE5vZGUgPSBudWxsO1xuXG4gICAgaWYgKGNvbGxhYkNoaWxkcmVuTGVuZ3RoICE9PSBsZXhpY2FsQ2hpbGRyZW5LZXlzTGVuZ3RoKSB7XG4gICAgICB3cml0YWJsZUxleGljYWxOb2RlID0gbGV4aWNhbE5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbGxhYkNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxleGljYWxDaGlsZEtleSA9IHByZXZMZXhpY2FsQ2hpbGRyZW5LZXlzW3ByZXZJbmRleF07XG4gICAgICBjb25zdCBjaGlsZENvbGxhYk5vZGUgPSBjb2xsYWJDaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IGNvbGxhYkxleGljYWxDaGlsZE5vZGUgPSBjaGlsZENvbGxhYk5vZGUuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgY29sbGFiS2V5ID0gY2hpbGRDb2xsYWJOb2RlLl9rZXk7XG5cbiAgICAgIGlmIChjb2xsYWJMZXhpY2FsQ2hpbGROb2RlICE9PSBudWxsICYmIGxleGljYWxDaGlsZEtleSA9PT0gY29sbGFiS2V5KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkTmVlZHNVcGRhdGluZyA9IGxleGljYWwuJGlzVGV4dE5vZGUoY29sbGFiTGV4aWNhbENoaWxkTm9kZSk7IC8vIFVwZGF0ZVxuXG4gICAgICAgIHZpc2l0ZWRLZXlzLmFkZChsZXhpY2FsQ2hpbGRLZXkpO1xuXG4gICAgICAgIGlmIChjaGlsZE5lZWRzVXBkYXRpbmcpIHtcbiAgICAgICAgICBjaGlsZENvbGxhYk5vZGUuX2tleSA9IGxleGljYWxDaGlsZEtleTtcblxuICAgICAgICAgIGlmIChjaGlsZENvbGxhYk5vZGUgaW5zdGFuY2VvZiBDb2xsYWJFbGVtZW50Tm9kZSkge1xuICAgICAgICAgICAgY29uc3QgeG1sVGV4dCA9IGNoaWxkQ29sbGFiTm9kZS5feG1sVGV4dDtcbiAgICAgICAgICAgIGNoaWxkQ29sbGFiTm9kZS5zeW5jUHJvcGVydGllc0Zyb21ZanMoYmluZGluZywgbnVsbCk7XG4gICAgICAgICAgICBjaGlsZENvbGxhYk5vZGUuYXBwbHlDaGlsZHJlbllqc0RlbHRhKGJpbmRpbmcsIHhtbFRleHQudG9EZWx0YSgpKTtcbiAgICAgICAgICAgIGNoaWxkQ29sbGFiTm9kZS5zeW5jQ2hpbGRyZW5Gcm9tWWpzKGJpbmRpbmcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiVGV4dE5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkQ29sbGFiTm9kZS5zeW5jUHJvcGVydGllc0FuZFRleHRGcm9tWWpzKGJpbmRpbmcsIG51bGwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiRGVjb3JhdG9yTm9kZSkge1xuICAgICAgICAgICAgY2hpbGRDb2xsYWJOb2RlLnN5bmNQcm9wZXJ0aWVzRnJvbVlqcyhiaW5kaW5nLCBudWxsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCEoY2hpbGRDb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiTGluZUJyZWFrTm9kZSkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYHN5bmNDaGlsZHJlbkZyb21ZanM6IGV4cGVjdGVkIHRleHQsIGVsZW1lbnQsIGRlY29yYXRvciwgb3IgbGluZWJyZWFrIGNvbGxhYiBub2RlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXZDaGlsZE5vZGUgPSBjb2xsYWJMZXhpY2FsQ2hpbGROb2RlO1xuICAgICAgICBwcmV2SW5kZXgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb2xsYWJLZXlzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb2xsYWJLZXlzID0gbmV3IFNldCgpO1xuXG4gICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBjb2xsYWJDaGlsZHJlbkxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNvbGxhYkNoaWxkcmVuW3NdO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBjaGlsZC5fa2V5O1xuXG4gICAgICAgICAgICBpZiAoY2hpbGRLZXkgIT09ICcnKSB7XG4gICAgICAgICAgICAgIGNvbGxhYktleXMuYWRkKGNoaWxkS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29sbGFiTGV4aWNhbENoaWxkTm9kZSAhPT0gbnVsbCAmJiBsZXhpY2FsQ2hpbGRLZXkgIT09IHVuZGVmaW5lZCAmJiAhY29sbGFiS2V5cy5oYXMobGV4aWNhbENoaWxkS2V5KSkge1xuICAgICAgICAgIGNvbnN0IG5vZGVUb1JlbW92ZSA9ICRnZXROb2RlQnlLZXlPclRocm93KGxleGljYWxDaGlsZEtleSk7XG4gICAgICAgICAgcmVtb3ZlRnJvbVBhcmVudChub2RlVG9SZW1vdmUpO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgICBwcmV2SW5kZXgrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdyaXRhYmxlTGV4aWNhbE5vZGUgPSBsZXhpY2FsTm9kZS5nZXRXcml0YWJsZSgpOyAvLyBDcmVhdGUvUmVwbGFjZVxuXG4gICAgICAgIGNvbnN0IGxleGljYWxDaGlsZE5vZGUgPSBjcmVhdGVMZXhpY2FsTm9kZUZyb21Db2xsYWJOb2RlKGJpbmRpbmcsIGNoaWxkQ29sbGFiTm9kZSwga2V5KTtcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBsZXhpY2FsQ2hpbGROb2RlLl9fa2V5O1xuICAgICAgICBjb2xsYWJOb2RlTWFwLnNldChjaGlsZEtleSwgY2hpbGRDb2xsYWJOb2RlKTtcblxuICAgICAgICBpZiAocHJldkNoaWxkTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gd3JpdGFibGVMZXhpY2FsTm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICAgICAgd3JpdGFibGVMZXhpY2FsTm9kZS5fX2ZpcnN0ID0gY2hpbGRLZXk7XG5cbiAgICAgICAgICBpZiAobmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlTmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSBjaGlsZEtleTtcbiAgICAgICAgICAgIGxleGljYWxDaGlsZE5vZGUuX19uZXh0ID0gd3JpdGFibGVOZXh0U2libGluZy5fX2tleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2Q2hpbGROb2RlID0gcHJldkNoaWxkTm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gcHJldkNoaWxkTm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICAgIHdyaXRhYmxlUHJldkNoaWxkTm9kZS5fX25leHQgPSBjaGlsZEtleTtcbiAgICAgICAgICBsZXhpY2FsQ2hpbGROb2RlLl9fcHJldiA9IHByZXZDaGlsZE5vZGUuX19rZXk7XG5cbiAgICAgICAgICBpZiAobmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlTmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSBjaGlsZEtleTtcbiAgICAgICAgICAgIGxleGljYWxDaGlsZE5vZGUuX19uZXh0ID0gd3JpdGFibGVOZXh0U2libGluZy5fX2tleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA9PT0gY29sbGFiQ2hpbGRyZW5MZW5ndGggLSAxKSB7XG4gICAgICAgICAgd3JpdGFibGVMZXhpY2FsTm9kZS5fX2xhc3QgPSBjaGlsZEtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdyaXRhYmxlTGV4aWNhbE5vZGUuX19zaXplKys7XG4gICAgICAgIHByZXZDaGlsZE5vZGUgPSBsZXhpY2FsQ2hpbGROb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGV4aWNhbENoaWxkcmVuS2V5c0xlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsZXhpY2FsQ2hpbGRLZXkgPSBwcmV2TGV4aWNhbENoaWxkcmVuS2V5c1tpXTtcblxuICAgICAgaWYgKCF2aXNpdGVkS2V5cy5oYXMobGV4aWNhbENoaWxkS2V5KSkge1xuICAgICAgICAvLyBSZW1vdmVcbiAgICAgICAgY29uc3QgbGV4aWNhbENoaWxkTm9kZSA9ICRnZXROb2RlQnlLZXlPclRocm93KGxleGljYWxDaGlsZEtleSk7XG4gICAgICAgIGNvbnN0IGNvbGxhYk5vZGUgPSBiaW5kaW5nLmNvbGxhYk5vZGVNYXAuZ2V0KGxleGljYWxDaGlsZEtleSk7XG5cbiAgICAgICAgaWYgKGNvbGxhYk5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbGxhYk5vZGUuZGVzdHJveShiaW5kaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW92ZUZyb21QYXJlbnQobGV4aWNhbENoaWxkTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3luY1Byb3BlcnRpZXNGcm9tTGV4aWNhbChiaW5kaW5nLCBuZXh0TGV4aWNhbE5vZGUsIHByZXZOb2RlTWFwKSB7XG4gICAgc3luY1Byb3BlcnRpZXNGcm9tTGV4aWNhbChiaW5kaW5nLCB0aGlzLl94bWxUZXh0LCB0aGlzLmdldFByZXZOb2RlKHByZXZOb2RlTWFwKSwgbmV4dExleGljYWxOb2RlKTtcbiAgfVxuXG4gIF9zeW5jQ2hpbGRGcm9tTGV4aWNhbChiaW5kaW5nLCBpbmRleCwga2V5LCBwcmV2Tm9kZU1hcCwgZGlydHlFbGVtZW50cywgZGlydHlMZWF2ZXMpIHtcbiAgICBjb25zdCBjaGlsZENvbGxhYk5vZGUgPSB0aGlzLl9jaGlsZHJlbltpbmRleF07IC8vIFVwZGF0ZVxuXG4gICAgY29uc3QgbmV4dENoaWxkTm9kZSA9ICRnZXROb2RlQnlLZXlPclRocm93KGtleSk7XG5cbiAgICBpZiAoY2hpbGRDb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiRWxlbWVudE5vZGUgJiYgbGV4aWNhbC4kaXNFbGVtZW50Tm9kZShuZXh0Q2hpbGROb2RlKSkge1xuICAgICAgY2hpbGRDb2xsYWJOb2RlLnN5bmNQcm9wZXJ0aWVzRnJvbUxleGljYWwoYmluZGluZywgbmV4dENoaWxkTm9kZSwgcHJldk5vZGVNYXApO1xuICAgICAgY2hpbGRDb2xsYWJOb2RlLnN5bmNDaGlsZHJlbkZyb21MZXhpY2FsKGJpbmRpbmcsIG5leHRDaGlsZE5vZGUsIHByZXZOb2RlTWFwLCBkaXJ0eUVsZW1lbnRzLCBkaXJ0eUxlYXZlcyk7XG4gICAgfSBlbHNlIGlmIChjaGlsZENvbGxhYk5vZGUgaW5zdGFuY2VvZiBDb2xsYWJUZXh0Tm9kZSAmJiBsZXhpY2FsLiRpc1RleHROb2RlKG5leHRDaGlsZE5vZGUpKSB7XG4gICAgICBjaGlsZENvbGxhYk5vZGUuc3luY1Byb3BlcnRpZXNBbmRUZXh0RnJvbUxleGljYWwoYmluZGluZywgbmV4dENoaWxkTm9kZSwgcHJldk5vZGVNYXApO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRDb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiRGVjb3JhdG9yTm9kZSAmJiBsZXhpY2FsLiRpc0RlY29yYXRvck5vZGUobmV4dENoaWxkTm9kZSkpIHtcbiAgICAgIGNoaWxkQ29sbGFiTm9kZS5zeW5jUHJvcGVydGllc0Zyb21MZXhpY2FsKGJpbmRpbmcsIG5leHRDaGlsZE5vZGUsIHByZXZOb2RlTWFwKTtcbiAgICB9XG4gIH1cblxuICBzeW5jQ2hpbGRyZW5Gcm9tTGV4aWNhbChiaW5kaW5nLCBuZXh0TGV4aWNhbE5vZGUsIHByZXZOb2RlTWFwLCBkaXJ0eUVsZW1lbnRzLCBkaXJ0eUxlYXZlcykge1xuICAgIGNvbnN0IHByZXZMZXhpY2FsTm9kZSA9IHRoaXMuZ2V0UHJldk5vZGUocHJldk5vZGVNYXApO1xuICAgIGNvbnN0IHByZXZDaGlsZHJlbiA9IHByZXZMZXhpY2FsTm9kZSA9PT0gbnVsbCA/IFtdIDogY3JlYXRlQ2hpbGRyZW5BcnJheShwcmV2TGV4aWNhbE5vZGUsIHByZXZOb2RlTWFwKTtcbiAgICBjb25zdCBuZXh0Q2hpbGRyZW4gPSBjcmVhdGVDaGlsZHJlbkFycmF5KG5leHRMZXhpY2FsTm9kZSwgbnVsbCk7XG4gICAgY29uc3QgcHJldkVuZEluZGV4ID0gcHJldkNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgbmV4dEVuZEluZGV4ID0gbmV4dENoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgY29sbGFiTm9kZU1hcCA9IGJpbmRpbmcuY29sbGFiTm9kZU1hcDtcbiAgICBsZXQgcHJldkNoaWxkcmVuU2V0O1xuICAgIGxldCBuZXh0Q2hpbGRyZW5TZXQ7XG4gICAgbGV0IHByZXZJbmRleCA9IDA7XG4gICAgbGV0IG5leHRJbmRleCA9IDA7XG5cbiAgICB3aGlsZSAocHJldkluZGV4IDw9IHByZXZFbmRJbmRleCAmJiBuZXh0SW5kZXggPD0gbmV4dEVuZEluZGV4KSB7XG4gICAgICBjb25zdCBwcmV2S2V5ID0gcHJldkNoaWxkcmVuW3ByZXZJbmRleF07XG4gICAgICBjb25zdCBuZXh0S2V5ID0gbmV4dENoaWxkcmVuW25leHRJbmRleF07XG5cbiAgICAgIGlmIChwcmV2S2V5ID09PSBuZXh0S2V5KSB7XG4gICAgICAgIC8vIE5vdmUgbW92ZSwgY3JlYXRlIG9yIHJlbW92ZVxuICAgICAgICB0aGlzLl9zeW5jQ2hpbGRGcm9tTGV4aWNhbChiaW5kaW5nLCBuZXh0SW5kZXgsIG5leHRLZXksIHByZXZOb2RlTWFwLCBkaXJ0eUVsZW1lbnRzLCBkaXJ0eUxlYXZlcyk7XG5cbiAgICAgICAgcHJldkluZGV4Kys7XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlblNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJldkNoaWxkcmVuU2V0ID0gbmV3IFNldChwcmV2Q2hpbGRyZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRDaGlsZHJlblNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbmV4dENoaWxkcmVuU2V0ID0gbmV3IFNldChuZXh0Q2hpbGRyZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV4dEhhc1ByZXZLZXkgPSBuZXh0Q2hpbGRyZW5TZXQuaGFzKHByZXZLZXkpO1xuICAgICAgICBjb25zdCBwcmV2SGFzTmV4dEtleSA9IHByZXZDaGlsZHJlblNldC5oYXMobmV4dEtleSk7XG5cbiAgICAgICAgaWYgKCFuZXh0SGFzUHJldktleSkge1xuICAgICAgICAgIC8vIFJlbW92ZVxuICAgICAgICAgIHRoaXMuc3BsaWNlKGJpbmRpbmcsIG5leHRJbmRleCwgMSk7XG4gICAgICAgICAgcHJldkluZGV4Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIG9yIHJlcGxhY2VcbiAgICAgICAgICBjb25zdCBuZXh0Q2hpbGROb2RlID0gJGdldE5vZGVCeUtleU9yVGhyb3cobmV4dEtleSk7XG4gICAgICAgICAgY29uc3QgY29sbGFiTm9kZSA9ICRjcmVhdGVDb2xsYWJOb2RlRnJvbUxleGljYWxOb2RlKGJpbmRpbmcsIG5leHRDaGlsZE5vZGUsIHRoaXMpO1xuICAgICAgICAgIGNvbGxhYk5vZGVNYXAuc2V0KG5leHRLZXksIGNvbGxhYk5vZGUpO1xuXG4gICAgICAgICAgaWYgKHByZXZIYXNOZXh0S2V5KSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZShiaW5kaW5nLCBuZXh0SW5kZXgsIDEsIGNvbGxhYk5vZGUpO1xuICAgICAgICAgICAgcHJldkluZGV4Kys7XG4gICAgICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2UoYmluZGluZywgbmV4dEluZGV4LCAwLCBjb2xsYWJOb2RlKTtcbiAgICAgICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFwcGVuZE5ld0NoaWxkcmVuID0gcHJldkluZGV4ID4gcHJldkVuZEluZGV4O1xuICAgIGNvbnN0IHJlbW92ZU9sZENoaWxkcmVuID0gbmV4dEluZGV4ID4gbmV4dEVuZEluZGV4O1xuXG4gICAgaWYgKGFwcGVuZE5ld0NoaWxkcmVuICYmICFyZW1vdmVPbGRDaGlsZHJlbikge1xuICAgICAgZm9yICg7IG5leHRJbmRleCA8PSBuZXh0RW5kSW5kZXg7ICsrbmV4dEluZGV4KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG5leHRDaGlsZHJlbltuZXh0SW5kZXhdO1xuICAgICAgICBjb25zdCBuZXh0Q2hpbGROb2RlID0gJGdldE5vZGVCeUtleU9yVGhyb3coa2V5KTtcbiAgICAgICAgY29uc3QgY29sbGFiTm9kZSA9ICRjcmVhdGVDb2xsYWJOb2RlRnJvbUxleGljYWxOb2RlKGJpbmRpbmcsIG5leHRDaGlsZE5vZGUsIHRoaXMpO1xuICAgICAgICB0aGlzLmFwcGVuZChjb2xsYWJOb2RlKTtcbiAgICAgICAgY29sbGFiTm9kZU1hcC5zZXQoa2V5LCBjb2xsYWJOb2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlbW92ZU9sZENoaWxkcmVuICYmICFhcHBlbmROZXdDaGlsZHJlbikge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gbmV4dEluZGV4OyBpLS0pIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoYmluZGluZywgaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXBwZW5kKGNvbGxhYk5vZGUpIHtcbiAgICBjb25zdCB4bWxUZXh0ID0gdGhpcy5feG1sVGV4dDtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIGNvbnN0IGxhc3RDaGlsZCA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IG9mZnNldCA9IGxhc3RDaGlsZCAhPT0gdW5kZWZpbmVkID8gbGFzdENoaWxkLmdldE9mZnNldCgpICsgbGFzdENoaWxkLmdldFNpemUoKSA6IDA7XG5cbiAgICBpZiAoY29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYkVsZW1lbnROb2RlKSB7XG4gICAgICB4bWxUZXh0Lmluc2VydEVtYmVkKG9mZnNldCwgY29sbGFiTm9kZS5feG1sVGV4dCk7XG4gICAgfSBlbHNlIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiVGV4dE5vZGUpIHtcbiAgICAgIGNvbnN0IG1hcCA9IGNvbGxhYk5vZGUuX21hcDtcblxuICAgICAgaWYgKG1hcC5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgeG1sVGV4dC5pbnNlcnRFbWJlZChvZmZzZXQsIG1hcCk7XG4gICAgICB9XG5cbiAgICAgIHhtbFRleHQuaW5zZXJ0KG9mZnNldCArIDEsIGNvbGxhYk5vZGUuX3RleHQpO1xuICAgIH0gZWxzZSBpZiAoY29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYkxpbmVCcmVha05vZGUpIHtcbiAgICAgIHhtbFRleHQuaW5zZXJ0RW1iZWQob2Zmc2V0LCBjb2xsYWJOb2RlLl9tYXApO1xuICAgIH0gZWxzZSBpZiAoY29sbGFiTm9kZSBpbnN0YW5jZW9mIENvbGxhYkRlY29yYXRvck5vZGUpIHtcbiAgICAgIHhtbFRleHQuaW5zZXJ0RW1iZWQob2Zmc2V0LCBjb2xsYWJOb2RlLl94bWxFbGVtKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNvbGxhYk5vZGUpO1xuICB9XG5cbiAgc3BsaWNlKGJpbmRpbmcsIGluZGV4LCBkZWxDb3VudCwgY29sbGFiTm9kZSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpbmRleF07XG5cbiAgICBpZiAoY2hpbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCEoY29sbGFiTm9kZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgc3BsaWNlOiBjb3VsZCBub3QgZmluZCBjb2xsYWIgZWxlbWVudCBub2RlYCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kKGNvbGxhYk5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9mZnNldCA9IGNoaWxkLmdldE9mZnNldCgpO1xuXG4gICAgaWYgKCEob2Zmc2V0ICE9PSAtMSkpIHtcbiAgICAgIHRocm93IEVycm9yKGBzcGxpY2U6IGV4cGVjdGVkIG9mZnNldCB0byBiZSBncmVhdGVyIHRoYW4gemVyb2ApO1xuICAgIH1cblxuICAgIGNvbnN0IHhtbFRleHQgPSB0aGlzLl94bWxUZXh0O1xuXG4gICAgaWYgKGRlbENvdW50ICE9PSAwKSB7XG4gICAgICAvLyBXaGF0IGlmIHdlIGRlbGV0ZSBtYW55IG5vZGVzLCBkb24ndCB3ZSBuZWVkIHRvIGdldCBhbGwgdGhlaXJcbiAgICAgIC8vIHNpemVzP1xuICAgICAgeG1sVGV4dC5kZWxldGUob2Zmc2V0LCBjaGlsZC5nZXRTaXplKCkpO1xuICAgIH1cblxuICAgIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiRWxlbWVudE5vZGUpIHtcbiAgICAgIHhtbFRleHQuaW5zZXJ0RW1iZWQob2Zmc2V0LCBjb2xsYWJOb2RlLl94bWxUZXh0KTtcbiAgICB9IGVsc2UgaWYgKGNvbGxhYk5vZGUgaW5zdGFuY2VvZiBDb2xsYWJUZXh0Tm9kZSkge1xuICAgICAgY29uc3QgbWFwID0gY29sbGFiTm9kZS5fbWFwO1xuXG4gICAgICBpZiAobWFwLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICB4bWxUZXh0Lmluc2VydEVtYmVkKG9mZnNldCwgbWFwKTtcbiAgICAgIH1cblxuICAgICAgeG1sVGV4dC5pbnNlcnQob2Zmc2V0ICsgMSwgY29sbGFiTm9kZS5fdGV4dCk7XG4gICAgfSBlbHNlIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiTGluZUJyZWFrTm9kZSkge1xuICAgICAgeG1sVGV4dC5pbnNlcnRFbWJlZChvZmZzZXQsIGNvbGxhYk5vZGUuX21hcCk7XG4gICAgfSBlbHNlIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiRGVjb3JhdG9yTm9kZSkge1xuICAgICAgeG1sVGV4dC5pbnNlcnRFbWJlZChvZmZzZXQsIGNvbGxhYk5vZGUuX3htbEVsZW0pO1xuICAgIH1cblxuICAgIGlmIChkZWxDb3VudCAhPT0gMCkge1xuICAgICAgY29uc3QgY2hpbGRyZW5Ub0RlbGV0ZSA9IGNoaWxkcmVuLnNsaWNlKGluZGV4LCBpbmRleCArIGRlbENvdW50KTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlblRvRGVsZXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkcmVuVG9EZWxldGVbaV0uZGVzdHJveShiaW5kaW5nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29sbGFiTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjaGlsZHJlbi5zcGxpY2UoaW5kZXgsIGRlbENvdW50LCBjb2xsYWJOb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRyZW4uc3BsaWNlKGluZGV4LCBkZWxDb3VudCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0Q2hpbGRPZmZzZXQoY29sbGFiTm9kZSkge1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoY2hpbGQgPT09IGNvbGxhYk5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH1cblxuICAgICAgb2Zmc2V0ICs9IGNoaWxkLmdldFNpemUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBkZXN0cm95KGJpbmRpbmcpIHtcbiAgICBjb25zdCBjb2xsYWJOb2RlTWFwID0gYmluZGluZy5jb2xsYWJOb2RlTWFwO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZHJlbltpXS5kZXN0cm95KGJpbmRpbmcpO1xuICAgIH1cblxuICAgIGNvbGxhYk5vZGVNYXAuZGVsZXRlKHRoaXMuX2tleSk7XG4gIH1cblxufVxuZnVuY3Rpb24gJGNyZWF0ZUNvbGxhYkVsZW1lbnROb2RlKHhtbFRleHQsIHBhcmVudCwgdHlwZSkge1xuICBjb25zdCBjb2xsYWJOb2RlID0gbmV3IENvbGxhYkVsZW1lbnROb2RlKHhtbFRleHQsIHBhcmVudCwgdHlwZSk7IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG5cbiAgeG1sVGV4dC5fY29sbGFiTm9kZSA9IGNvbGxhYk5vZGU7XG4gIHJldHVybiBjb2xsYWJOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBjcmVhdGVCaW5kaW5nKGVkaXRvciwgcHJvdmlkZXIsIGlkLCBkb2MsIGRvY01hcCkge1xuICBpZiAoIShkb2MgIT09IHVuZGVmaW5lZCAmJiBkb2MgIT09IG51bGwpKSB7XG4gICAgdGhyb3cgRXJyb3IoYGNyZWF0ZUJpbmRpbmc6IGRvYyBpcyBudWxsIG9yIHVuZGVmaW5lZGApO1xuICB9XG5cbiAgY29uc3Qgcm9vdFhtbFRleHQgPSBkb2MuZ2V0KCdyb290JywgeWpzLlhtbFRleHQpO1xuICBjb25zdCByb290ID0gJGNyZWF0ZUNvbGxhYkVsZW1lbnROb2RlKHJvb3RYbWxUZXh0LCBudWxsLCAncm9vdCcpO1xuICByb290Ll9rZXkgPSAncm9vdCc7XG4gIHJldHVybiB7XG4gICAgY2xpZW50SUQ6IGRvYy5jbGllbnRJRCxcbiAgICBjb2xsYWJOb2RlTWFwOiBuZXcgTWFwKCksXG4gICAgY3Vyc29yczogbmV3IE1hcCgpLFxuICAgIGN1cnNvcnNDb250YWluZXI6IG51bGwsXG4gICAgZG9jLFxuICAgIGRvY01hcCxcbiAgICBlZGl0b3IsXG4gICAgaWQsXG4gICAgbm9kZVByb3BlcnRpZXM6IG5ldyBNYXAoKSxcbiAgICByb290XG4gIH07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbihwb2ludCwgYmluZGluZykge1xuICBjb25zdCBjb2xsYWJOb2RlTWFwID0gYmluZGluZy5jb2xsYWJOb2RlTWFwO1xuICBjb25zdCBjb2xsYWJOb2RlID0gY29sbGFiTm9kZU1hcC5nZXQocG9pbnQua2V5KTtcblxuICBpZiAoY29sbGFiTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZXQgb2Zmc2V0ID0gcG9pbnQub2Zmc2V0O1xuICBsZXQgc2hhcmVkVHlwZSA9IGNvbGxhYk5vZGUuZ2V0U2hhcmVkVHlwZSgpO1xuXG4gIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiVGV4dE5vZGUpIHtcbiAgICBzaGFyZWRUeXBlID0gY29sbGFiTm9kZS5fcGFyZW50Ll94bWxUZXh0O1xuICAgIGNvbnN0IGN1cnJlbnRPZmZzZXQgPSBjb2xsYWJOb2RlLmdldE9mZnNldCgpO1xuXG4gICAgaWYgKGN1cnJlbnRPZmZzZXQgPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBvZmZzZXQgPSBjdXJyZW50T2Zmc2V0ICsgMSArIG9mZnNldDtcbiAgfSBlbHNlIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiRWxlbWVudE5vZGUgJiYgcG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgY29uc3QgcGFyZW50ID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGxldCBhY2N1bXVsYXRlZE9mZnNldCA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBub2RlID0gcGFyZW50LmdldEZpcnN0Q2hpbGQoKTtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIGkrKyA8IG9mZnNldCkge1xuICAgICAgaWYgKGxleGljYWwuJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgICAgYWNjdW11bGF0ZWRPZmZzZXQgKz0gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY2N1bXVsYXRlZE9mZnNldCsrO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIH1cblxuICAgIG9mZnNldCA9IGFjY3VtdWxhdGVkT2Zmc2V0O1xuICB9XG5cbiAgcmV0dXJuIHlqcy5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleChzaGFyZWRUeXBlLCBvZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uKHJlbGF0aXZlUG9zaXRpb24sIGJpbmRpbmcpIHtcbiAgcmV0dXJuIHlqcy5jcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24ocmVsYXRpdmVQb3NpdGlvbiwgYmluZGluZy5kb2MpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVQb3NpdGlvbihjdXJyZW50UG9zLCBwb3MpIHtcbiAgaWYgKGN1cnJlbnRQb3MgPT0gbnVsbCkge1xuICAgIGlmIChwb3MgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBvcyA9PSBudWxsIHx8ICF5anMuY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zKGN1cnJlbnRQb3MsIHBvcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKG5hbWUsIGNvbG9yKSB7XG4gIHJldHVybiB7XG4gICAgY29sb3I6IGNvbG9yLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgc2VsZWN0aW9uOiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lTZWxlY3Rpb24oYmluZGluZywgc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGN1cnNvcnNDb250YWluZXIgPSBiaW5kaW5nLmN1cnNvcnNDb250YWluZXI7XG5cbiAgaWYgKGN1cnNvcnNDb250YWluZXIgIT09IG51bGwpIHtcbiAgICBjb25zdCBzZWxlY3Rpb25zID0gc2VsZWN0aW9uLnNlbGVjdGlvbnM7XG4gICAgY29uc3Qgc2VsZWN0aW9uc0xlbmd0aCA9IHNlbGVjdGlvbnMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb25zTGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1cnNvcnNDb250YWluZXIucmVtb3ZlQ2hpbGQoc2VsZWN0aW9uc1tpXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lDdXJzb3IoYmluZGluZywgY3Vyc29yKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGN1cnNvci5zZWxlY3Rpb247XG5cbiAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIGRlc3Ryb3lTZWxlY3Rpb24oYmluZGluZywgc2VsZWN0aW9uKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDdXJzb3JTZWxlY3Rpb24oY3Vyc29yLCBhbmNob3JLZXksIGFuY2hvck9mZnNldCwgZm9jdXNLZXksIGZvY3VzT2Zmc2V0KSB7XG4gIGNvbnN0IGNvbG9yID0gY3Vyc29yLmNvbG9yO1xuICBjb25zdCBjYXJldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgY2FyZXQuc3R5bGUuY3NzVGV4dCA9IGBwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtib3R0b206MDtyaWdodDotMXB4O3dpZHRoOjFweDtiYWNrZ3JvdW5kLWNvbG9yOiR7Y29sb3J9O3otaW5kZXg6MTA7YDtcbiAgY29uc3QgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgbmFtZS50ZXh0Q29udGVudCA9IGN1cnNvci5uYW1lO1xuICBuYW1lLnN0eWxlLmNzc1RleHQgPSBgcG9zaXRpb246YWJzb2x1dGU7bGVmdDotMnB4O3RvcDotMTZweDtiYWNrZ3JvdW5kLWNvbG9yOiR7Y29sb3J9O2NvbG9yOiNmZmY7bGluZS1oZWlnaHQ6MTJweDtmb250LXNpemU6MTJweDtwYWRkaW5nOjJweDtmb250LWZhbWlseTpBcmlhbDtmb250LXdlaWdodDpib2xkO3doaXRlLXNwYWNlOm5vd3JhcDtgO1xuICBjYXJldC5hcHBlbmRDaGlsZChuYW1lKTtcbiAgcmV0dXJuIHtcbiAgICBhbmNob3I6IHtcbiAgICAgIGtleTogYW5jaG9yS2V5LFxuICAgICAgb2Zmc2V0OiBhbmNob3JPZmZzZXRcbiAgICB9LFxuICAgIGNhcmV0LFxuICAgIGNvbG9yLFxuICAgIGZvY3VzOiB7XG4gICAgICBrZXk6IGZvY3VzS2V5LFxuICAgICAgb2Zmc2V0OiBmb2N1c09mZnNldFxuICAgIH0sXG4gICAgbmFtZSxcbiAgICBzZWxlY3Rpb25zOiBbXVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDdXJzb3IoYmluZGluZywgY3Vyc29yLCBuZXh0U2VsZWN0aW9uLCBub2RlTWFwKSB7XG4gIGNvbnN0IGVkaXRvciA9IGJpbmRpbmcuZWRpdG9yO1xuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICBjb25zdCBjdXJzb3JzQ29udGFpbmVyID0gYmluZGluZy5jdXJzb3JzQ29udGFpbmVyO1xuXG4gIGlmIChjdXJzb3JzQ29udGFpbmVyID09PSBudWxsIHx8IHJvb3RFbGVtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY3Vyc29yc0NvbnRhaW5lck9mZnNldFBhcmVudCA9IGN1cnNvcnNDb250YWluZXIub2Zmc2V0UGFyZW50O1xuXG4gIGlmIChjdXJzb3JzQ29udGFpbmVyT2Zmc2V0UGFyZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY29udGFpbmVyUmVjdCA9IGN1cnNvcnNDb250YWluZXJPZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBjdXJzb3Iuc2VsZWN0aW9uO1xuXG4gIGlmIChuZXh0U2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgaWYgKHByZXZTZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgY3Vyc29yLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICBkZXN0cm95U2VsZWN0aW9uKGJpbmRpbmcsIHByZXZTZWxlY3Rpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjdXJzb3Iuc2VsZWN0aW9uID0gbmV4dFNlbGVjdGlvbjtcbiAgfVxuXG4gIGNvbnN0IGNhcmV0ID0gbmV4dFNlbGVjdGlvbi5jYXJldDtcbiAgY29uc3QgY29sb3IgPSBuZXh0U2VsZWN0aW9uLmNvbG9yO1xuICBjb25zdCBzZWxlY3Rpb25zID0gbmV4dFNlbGVjdGlvbi5zZWxlY3Rpb25zO1xuICBjb25zdCBhbmNob3IgPSBuZXh0U2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBuZXh0U2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JLZXkgPSBhbmNob3Iua2V5O1xuICBjb25zdCBmb2N1c0tleSA9IGZvY3VzLmtleTtcbiAgY29uc3QgYW5jaG9yTm9kZSA9IG5vZGVNYXAuZ2V0KGFuY2hvcktleSk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IG5vZGVNYXAuZ2V0KGZvY3VzS2V5KTtcblxuICBpZiAoYW5jaG9yTm9kZSA9PSBudWxsIHx8IGZvY3VzTm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHNlbGVjdGlvblJlY3RzOyAvLyBJbiB0aGUgY2FzZSBvZiBhIGNvbGxhcHNlZCBzZWxlY3Rpb24gb24gYSBsaW5lYnJlYWssIHdlIG5lZWRcbiAgLy8gdG8gaW1wcm92aXNlIGFzIHRoZSBicm93c2VyIHdpbGwgcmV0dXJuIG5vdGhpbmcgaGVyZSBhcyA8YnI+XG4gIC8vIGFwcGFyYW50bHkgdGFrZSB1cCBubyB2aXN1YWwgc3BhY2UgOi9cbiAgLy8gVGhpcyB3b24ndCB3b3JrIGluIGFsbCBjYXNlcywgYnV0IGl0J3MgYmV0dGVyIHRoYW4ganVzdCBzaG93aW5nXG4gIC8vIG5vdGhpbmcgYWxsIHRoZSB0aW1lLlxuXG4gIGlmIChhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiYgbGV4aWNhbC4kaXNMaW5lQnJlYWtOb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgY29uc3QgYnJSZWN0ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JLZXkpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHNlbGVjdGlvblJlY3RzID0gW2JyUmVjdF07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uY3JlYXRlRE9NUmFuZ2UoZWRpdG9yLCBhbmNob3JOb2RlLCBhbmNob3Iub2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzLm9mZnNldCk7XG5cbiAgICBpZiAocmFuZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxlY3Rpb25SZWN0cyA9IHNlbGVjdGlvbi5jcmVhdGVSZWN0c0Zyb21ET01SYW5nZShlZGl0b3IsIHJhbmdlKTtcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdGlvbnNMZW5ndGggPSBzZWxlY3Rpb25zLmxlbmd0aDtcbiAgY29uc3Qgc2VsZWN0aW9uUmVjdHNMZW5ndGggPSBzZWxlY3Rpb25SZWN0cy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb25SZWN0c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uUmVjdCA9IHNlbGVjdGlvblJlY3RzW2ldO1xuICAgIGxldCBzZWxlY3Rpb24gPSBzZWxlY3Rpb25zW2ldO1xuXG4gICAgaWYgKHNlbGVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZWxlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBzZWxlY3Rpb25zW2ldID0gc2VsZWN0aW9uO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uQmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBzZWxlY3Rpb24uYXBwZW5kQ2hpbGQoc2VsZWN0aW9uQmcpO1xuICAgICAgY3Vyc29yc0NvbnRhaW5lci5hcHBlbmRDaGlsZChzZWxlY3Rpb24pO1xuICAgIH1cblxuICAgIGNvbnN0IHRvcCA9IHNlbGVjdGlvblJlY3QudG9wIC0gY29udGFpbmVyUmVjdC50b3A7XG4gICAgY29uc3QgbGVmdCA9IHNlbGVjdGlvblJlY3QubGVmdCAtIGNvbnRhaW5lclJlY3QubGVmdDtcbiAgICBjb25zdCBzdHlsZSA9IGBwb3NpdGlvbjphYnNvbHV0ZTt0b3A6JHt0b3B9cHg7bGVmdDoke2xlZnR9cHg7aGVpZ2h0OiR7c2VsZWN0aW9uUmVjdC5oZWlnaHR9cHg7d2lkdGg6JHtzZWxlY3Rpb25SZWN0LndpZHRofXB4O3BvaW50ZXItZXZlbnRzOm5vbmU7ei1pbmRleDo1O2A7XG4gICAgc2VsZWN0aW9uLnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcbiAgICBzZWxlY3Rpb24uZmlyc3RDaGlsZC5zdHlsZS5jc3NUZXh0ID0gYCR7c3R5bGV9bGVmdDowO3RvcDowO2JhY2tncm91bmQtY29sb3I6JHtjb2xvcn07b3BhY2l0eTowLjM7YDtcblxuICAgIGlmIChpID09PSBzZWxlY3Rpb25SZWN0c0xlbmd0aCAtIDEpIHtcbiAgICAgIGlmIChjYXJldC5wYXJlbnROb2RlICE9PSBzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmFwcGVuZENoaWxkKGNhcmV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGxldCBpID0gc2VsZWN0aW9uc0xlbmd0aCAtIDE7IGkgPj0gc2VsZWN0aW9uUmVjdHNMZW5ndGg7IGktLSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbaV07XG4gICAgY3Vyc29yc0NvbnRhaW5lci5yZW1vdmVDaGlsZChzZWxlY3Rpb24pO1xuICAgIHNlbGVjdGlvbnMucG9wKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3luY0xvY2FsQ3Vyc29yUG9zaXRpb24oYmluZGluZywgcHJvdmlkZXIpIHtcbiAgY29uc3QgYXdhcmVuZXNzID0gcHJvdmlkZXIuYXdhcmVuZXNzO1xuICBjb25zdCBsb2NhbFN0YXRlID0gYXdhcmVuZXNzLmdldExvY2FsU3RhdGUoKTtcblxuICBpZiAobG9jYWxTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGFuY2hvclBvcyA9IGxvY2FsU3RhdGUuYW5jaG9yUG9zO1xuICBjb25zdCBmb2N1c1BvcyA9IGxvY2FsU3RhdGUuZm9jdXNQb3M7XG5cbiAgaWYgKGFuY2hvclBvcyAhPT0gbnVsbCAmJiBmb2N1c1BvcyAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGFuY2hvckFic1BvcyA9IGNyZWF0ZUFic29sdXRlUG9zaXRpb24oYW5jaG9yUG9zLCBiaW5kaW5nKTtcbiAgICBjb25zdCBmb2N1c0Fic1BvcyA9IGNyZWF0ZUFic29sdXRlUG9zaXRpb24oZm9jdXNQb3MsIGJpbmRpbmcpO1xuXG4gICAgaWYgKGFuY2hvckFic1BvcyAhPT0gbnVsbCAmJiBmb2N1c0Fic1BvcyAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgW2FuY2hvckNvbGxhYk5vZGUsIGFuY2hvck9mZnNldF0gPSBnZXRDb2xsYWJOb2RlQW5kT2Zmc2V0KGFuY2hvckFic1Bvcy50eXBlLCBhbmNob3JBYnNQb3MuaW5kZXgpO1xuICAgICAgY29uc3QgW2ZvY3VzQ29sbGFiTm9kZSwgZm9jdXNPZmZzZXRdID0gZ2V0Q29sbGFiTm9kZUFuZE9mZnNldChmb2N1c0Fic1Bvcy50eXBlLCBmb2N1c0Fic1Bvcy5pbmRleCk7XG5cbiAgICAgIGlmIChhbmNob3JDb2xsYWJOb2RlICE9PSBudWxsICYmIGZvY3VzQ29sbGFiTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBhbmNob3JLZXkgPSBhbmNob3JDb2xsYWJOb2RlLmdldEtleSgpO1xuICAgICAgICBjb25zdCBmb2N1c0tleSA9IGZvY3VzQ29sbGFiTm9kZS5nZXRLZXkoKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgaWYgKCFsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICAgICAgc2V0UG9pbnQoYW5jaG9yLCBhbmNob3JLZXksIGFuY2hvck9mZnNldCk7XG4gICAgICAgIHNldFBvaW50KGZvY3VzLCBmb2N1c0tleSwgZm9jdXNPZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRQb2ludChwb2ludCwga2V5LCBvZmZzZXQpIHtcbiAgaWYgKHBvaW50LmtleSAhPT0ga2V5IHx8IHBvaW50Lm9mZnNldCAhPT0gb2Zmc2V0KSB7XG4gICAgbGV0IGFuY2hvck5vZGUgPSBsZXhpY2FsLiRnZXROb2RlQnlLZXkoa2V5KTtcblxuICAgIGlmIChhbmNob3JOb2RlICE9PSBudWxsICYmICFsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpICYmICFsZXhpY2FsLiRpc1RleHROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGtleSA9IHBhcmVudC5nZXRLZXkoKTtcbiAgICAgIG9mZnNldCA9IGFuY2hvck5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgIGFuY2hvck5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcG9pbnQuc2V0KGtleSwgb2Zmc2V0LCBsZXhpY2FsLiRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpID8gJ2VsZW1lbnQnIDogJ3RleHQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb2xsYWJOb2RlQW5kT2Zmc2V0KCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuc2hhcmVkVHlwZSwgb2Zmc2V0KSB7XG4gIGNvbnN0IGNvbGxhYk5vZGUgPSBzaGFyZWRUeXBlLl9jb2xsYWJOb2RlO1xuXG4gIGlmIChjb2xsYWJOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW251bGwsIDBdO1xuICB9XG5cbiAgaWYgKGNvbGxhYk5vZGUgaW5zdGFuY2VvZiBDb2xsYWJFbGVtZW50Tm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5vZGUsXG4gICAgICBvZmZzZXQ6IGNvbGxhYk5vZGVPZmZzZXRcbiAgICB9ID0gZ2V0UG9zaXRpb25Gcm9tRWxlbWVudEFuZE9mZnNldChjb2xsYWJOb2RlLCBvZmZzZXQsIHRydWUpO1xuXG4gICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBbY29sbGFiTm9kZSwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbbm9kZSwgY29sbGFiTm9kZU9mZnNldF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtudWxsLCAwXTtcbn1cblxuZnVuY3Rpb24gc3luY0N1cnNvclBvc2l0aW9ucyhiaW5kaW5nLCBwcm92aWRlcikge1xuICBjb25zdCBhd2FyZW5lc3NTdGF0ZXMgPSBBcnJheS5mcm9tKHByb3ZpZGVyLmF3YXJlbmVzcy5nZXRTdGF0ZXMoKSk7XG4gIGNvbnN0IGxvY2FsQ2xpZW50SUQgPSBiaW5kaW5nLmNsaWVudElEO1xuICBjb25zdCBjdXJzb3JzID0gYmluZGluZy5jdXJzb3JzO1xuICBjb25zdCBlZGl0b3IgPSBiaW5kaW5nLmVkaXRvcjtcbiAgY29uc3Qgbm9kZU1hcCA9IGVkaXRvci5fZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IHZpc2l0ZWRDbGllbnRJRHMgPSBuZXcgU2V0KCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhd2FyZW5lc3NTdGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhd2FyZW5lc3NTdGF0ZSA9IGF3YXJlbmVzc1N0YXRlc1tpXTtcbiAgICBjb25zdCBbY2xpZW50SUQsIGF3YXJlbmVzc10gPSBhd2FyZW5lc3NTdGF0ZTtcblxuICAgIGlmIChjbGllbnRJRCAhPT0gbG9jYWxDbGllbnRJRCkge1xuICAgICAgdmlzaXRlZENsaWVudElEcy5hZGQoY2xpZW50SUQpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbmNob3JQb3MsXG4gICAgICAgIGZvY3VzUG9zLFxuICAgICAgICBuYW1lLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgZm9jdXNpbmdcbiAgICAgIH0gPSBhd2FyZW5lc3M7XG4gICAgICBsZXQgc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIGxldCBjdXJzb3IgPSBjdXJzb3JzLmdldChjbGllbnRJRCk7XG5cbiAgICAgIGlmIChjdXJzb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdXJzb3IgPSBjcmVhdGVDdXJzb3IobmFtZSwgY29sb3IpO1xuICAgICAgICBjdXJzb3JzLnNldChjbGllbnRJRCwgY3Vyc29yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuY2hvclBvcyAhPT0gbnVsbCAmJiBmb2N1c1BvcyAhPT0gbnVsbCAmJiBmb2N1c2luZykge1xuICAgICAgICBjb25zdCBhbmNob3JBYnNQb3MgPSBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uKGFuY2hvclBvcywgYmluZGluZyk7XG4gICAgICAgIGNvbnN0IGZvY3VzQWJzUG9zID0gY3JlYXRlQWJzb2x1dGVQb3NpdGlvbihmb2N1c1BvcywgYmluZGluZyk7XG5cbiAgICAgICAgaWYgKGFuY2hvckFic1BvcyAhPT0gbnVsbCAmJiBmb2N1c0Fic1BvcyAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IFthbmNob3JDb2xsYWJOb2RlLCBhbmNob3JPZmZzZXRdID0gZ2V0Q29sbGFiTm9kZUFuZE9mZnNldChhbmNob3JBYnNQb3MudHlwZSwgYW5jaG9yQWJzUG9zLmluZGV4KTtcbiAgICAgICAgICBjb25zdCBbZm9jdXNDb2xsYWJOb2RlLCBmb2N1c09mZnNldF0gPSBnZXRDb2xsYWJOb2RlQW5kT2Zmc2V0KGZvY3VzQWJzUG9zLnR5cGUsIGZvY3VzQWJzUG9zLmluZGV4KTtcblxuICAgICAgICAgIGlmIChhbmNob3JDb2xsYWJOb2RlICE9PSBudWxsICYmIGZvY3VzQ29sbGFiTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yQ29sbGFiTm9kZS5nZXRLZXkoKTtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzS2V5ID0gZm9jdXNDb2xsYWJOb2RlLmdldEtleSgpO1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gY3Vyc29yLnNlbGVjdGlvbjtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBjcmVhdGVDdXJzb3JTZWxlY3Rpb24oY3Vyc29yLCBhbmNob3JLZXksIGFuY2hvck9mZnNldCwgZm9jdXNLZXksIGZvY3VzT2Zmc2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICAgICAgICBhbmNob3Iua2V5ID0gYW5jaG9yS2V5O1xuICAgICAgICAgICAgICBhbmNob3Iub2Zmc2V0ID0gYW5jaG9yT2Zmc2V0O1xuICAgICAgICAgICAgICBmb2N1cy5rZXkgPSBmb2N1c0tleTtcbiAgICAgICAgICAgICAgZm9jdXMub2Zmc2V0ID0gZm9jdXNPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZUN1cnNvcihiaW5kaW5nLCBjdXJzb3IsIHNlbGVjdGlvbiwgbm9kZU1hcCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYWxsQ2xpZW50SURzID0gQXJyYXkuZnJvbShjdXJzb3JzLmtleXMoKSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxDbGllbnRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGFsbENsaWVudElEc1tpXTtcblxuICAgIGlmICghdmlzaXRlZENsaWVudElEcy5oYXMoY2xpZW50SUQpKSB7XG4gICAgICBjb25zdCBjdXJzb3IgPSBjdXJzb3JzLmdldChjbGllbnRJRCk7XG5cbiAgICAgIGlmIChjdXJzb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZXN0cm95Q3Vyc29yKGJpbmRpbmcsIGN1cnNvcik7XG4gICAgICAgIGN1cnNvcnMuZGVsZXRlKGNsaWVudElEKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN5bmNMZXhpY2FsU2VsZWN0aW9uVG9ZanMoYmluZGluZywgcHJvdmlkZXIsIHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pIHtcbiAgY29uc3QgYXdhcmVuZXNzID0gcHJvdmlkZXIuYXdhcmVuZXNzO1xuICBjb25zdCBsb2NhbFN0YXRlID0gYXdhcmVuZXNzLmdldExvY2FsU3RhdGUoKTtcblxuICBpZiAobG9jYWxTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBhbmNob3JQb3M6IGN1cnJlbnRBbmNob3JQb3MsXG4gICAgZm9jdXNQb3M6IGN1cnJlbnRGb2N1c1BvcyxcbiAgICBuYW1lLFxuICAgIGNvbG9yLFxuICAgIGZvY3VzaW5nXG4gIH0gPSBsb2NhbFN0YXRlO1xuICBsZXQgYW5jaG9yUG9zID0gbnVsbDtcbiAgbGV0IGZvY3VzUG9zID0gbnVsbDtcblxuICBpZiAobmV4dFNlbGVjdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50QW5jaG9yUG9zICE9PSBudWxsICYmICFuZXh0U2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgaWYgKHByZXZTZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSkge1xuICAgIGFuY2hvclBvcyA9IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24obmV4dFNlbGVjdGlvbi5hbmNob3IsIGJpbmRpbmcpO1xuICAgIGZvY3VzUG9zID0gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbihuZXh0U2VsZWN0aW9uLmZvY3VzLCBiaW5kaW5nKTtcbiAgfVxuXG4gIGlmIChzaG91bGRVcGRhdGVQb3NpdGlvbihjdXJyZW50QW5jaG9yUG9zLCBhbmNob3JQb3MpIHx8IHNob3VsZFVwZGF0ZVBvc2l0aW9uKGN1cnJlbnRGb2N1c1BvcywgZm9jdXNQb3MpKSB7XG4gICAgYXdhcmVuZXNzLnNldExvY2FsU3RhdGUoe1xuICAgICAgYW5jaG9yUG9zLFxuICAgICAgY29sb3IsXG4gICAgICBmb2N1c1BvcyxcbiAgICAgIGZvY3VzaW5nLFxuICAgICAgbmFtZVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gc3luY0V2ZW50KGJpbmRpbmcsIGV2ZW50KSB7XG4gIGNvbnN0IHtcbiAgICB0YXJnZXRcbiAgfSA9IGV2ZW50O1xuICBjb25zdCBjb2xsYWJOb2RlID0gZ2V0T3JJbml0Q29sbGFiTm9kZUZyb21TaGFyZWRUeXBlKGJpbmRpbmcsIHRhcmdldCk7XG5cbiAgaWYgKGNvbGxhYk5vZGUgaW5zdGFuY2VvZiBDb2xsYWJFbGVtZW50Tm9kZSAmJiBldmVudCBpbnN0YW5jZW9mIHlqcy5ZVGV4dEV2ZW50KSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBXZSBuZWVkIHRvIGFjY2VzcyB0aGUgcHJpdmF0ZSBwcm9wZXJ0eSBvZiB0aGUgY2xhc3NcbiAgICBjb25zdCB7XG4gICAgICBrZXlzQ2hhbmdlZCxcbiAgICAgIGNoaWxkTGlzdENoYW5nZWQsXG4gICAgICBkZWx0YVxuICAgIH0gPSBldmVudDsgLy8gVXBkYXRlXG5cbiAgICBpZiAoa2V5c0NoYW5nZWQuc2l6ZSA+IDApIHtcbiAgICAgIGNvbGxhYk5vZGUuc3luY1Byb3BlcnRpZXNGcm9tWWpzKGJpbmRpbmcsIGtleXNDaGFuZ2VkKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGRMaXN0Q2hhbmdlZCkge1xuICAgICAgY29sbGFiTm9kZS5hcHBseUNoaWxkcmVuWWpzRGVsdGEoYmluZGluZywgZGVsdGEpO1xuICAgICAgY29sbGFiTm9kZS5zeW5jQ2hpbGRyZW5Gcm9tWWpzKGJpbmRpbmcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiVGV4dE5vZGUgJiYgZXZlbnQgaW5zdGFuY2VvZiB5anMuWU1hcEV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAga2V5c0NoYW5nZWRcbiAgICB9ID0gZXZlbnQ7IC8vIFVwZGF0ZVxuXG4gICAgaWYgKGtleXNDaGFuZ2VkLnNpemUgPiAwKSB7XG4gICAgICBjb2xsYWJOb2RlLnN5bmNQcm9wZXJ0aWVzQW5kVGV4dEZyb21ZanMoYmluZGluZywga2V5c0NoYW5nZWQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiRGVjb3JhdG9yTm9kZSAmJiBldmVudCBpbnN0YW5jZW9mIHlqcy5ZWG1sRXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzQ2hhbmdlZFxuICAgIH0gPSBldmVudDsgLy8gVXBkYXRlXG5cbiAgICBpZiAoYXR0cmlidXRlc0NoYW5nZWQuc2l6ZSA+IDApIHtcbiAgICAgIGNvbGxhYk5vZGUuc3luY1Byb3BlcnRpZXNGcm9tWWpzKGJpbmRpbmcsIGF0dHJpYnV0ZXNDaGFuZ2VkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRleHQsIGVsZW1lbnQsIG9yIGRlY29yYXRvciBldmVudGApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzeW5jWWpzQ2hhbmdlc1RvTGV4aWNhbChiaW5kaW5nLCBwcm92aWRlciwgZXZlbnRzLCBpc0Zyb21VbmRvTWFuZ2VyKSB7XG4gIGNvbnN0IGVkaXRvciA9IGJpbmRpbmcuZWRpdG9yO1xuICBjb25zdCBjdXJyZW50RWRpdG9yU3RhdGUgPSBlZGl0b3IuX2VkaXRvclN0YXRlO1xuICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICBjb25zdCBwZW5kaW5nRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpXTtcbiAgICAgIHN5bmNFdmVudChiaW5kaW5nLCBldmVudCk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gbGV4aWNhbC4kZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAobGV4aWNhbC4kaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAvLyBXZSBjYW4ndCB1c2UgWWpzJ3MgY3Vyc29yIHBvc2l0aW9uIGhlcmUsIGFzIGl0IGRvZXNuJ3QgYWx3YXlzXG4gICAgICAvLyBoYW5kbGUgc2VsZWN0aW9uIHJlY292ZXJ5IGNvcnJlY3RseSDigJMgZXNwZWNpYWxseSBvbiBlbGVtZW50cyB0aGF0XG4gICAgICAvLyBnZXQgbW92ZWQgYXJvdW5kIG9yIHNwbGl0LiBTbyBpbnN0ZWFkLCB3ZSByb2xsIG91ciBvd24gc29sdXRpb24uXG4gICAgICBpZiAoZG9lc1NlbGVjdGlvbk5lZWRSZWNvdmVyaW5nKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3QgcHJldlNlbGVjdGlvbiA9IGN1cnJlbnRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuXG4gICAgICAgIGlmIChsZXhpY2FsLiRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgY29uc3QgcHJldk9mZnNldFZpZXcgPSBvZmZzZXQuJGNyZWF0ZU9mZnNldFZpZXcoZWRpdG9yLCAwLCBjdXJyZW50RWRpdG9yU3RhdGUpO1xuICAgICAgICAgIGNvbnN0IG5leHRPZmZzZXRWaWV3ID0gb2Zmc2V0LiRjcmVhdGVPZmZzZXRWaWV3KGVkaXRvciwgMCwgcGVuZGluZ0VkaXRvclN0YXRlKTtcbiAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBwcmV2T2Zmc2V0Vmlldy5nZXRPZmZzZXRzRnJvbVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKTtcbiAgICAgICAgICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dE9mZnNldFZpZXcuY3JlYXRlU2VsZWN0aW9uRnJvbU9mZnNldHMoc3RhcnQsIGVuZCwgcHJldk9mZnNldFZpZXcpO1xuXG4gICAgICAgICAgaWYgKG5leHRTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxleGljYWwuJHNldFNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgaXMgdG8gdXNlIHRoZSBZanMgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAgICBzeW5jTG9jYWxDdXJzb3JQb3NpdGlvbihiaW5kaW5nLCBwcm92aWRlcik7XG5cbiAgICAgICAgICAgIGlmIChkb2VzU2VsZWN0aW9uTmVlZFJlY292ZXJpbmcoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBjb25zdCByb290ID0gbGV4aWNhbC4kZ2V0Um9vdCgpOyAvLyBJZiB0aGVyZSB3YXMgYSBjb2xsaXNpb24gb24gdGhlIHRvcCBsZXZlbCBwYXJhZ3JhcGhcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZS1hZGQgYSBwYXJhZ3JhcGhcblxuICAgICAgICAgICAgICBpZiAocm9vdC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJvb3QuYXBwZW5kKGxleGljYWwuJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgICAgICAgICAgIH0gLy8gRmFsbGJhY2tcblxuXG4gICAgICAgICAgICAgIGxleGljYWwuJGdldFJvb3QoKS5zZWxlY3RFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzeW5jTGV4aWNhbFNlbGVjdGlvblRvWWpzKGJpbmRpbmcsIHByb3ZpZGVyLCBwcmV2U2VsZWN0aW9uLCBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzeW5jTG9jYWxDdXJzb3JQb3NpdGlvbihiaW5kaW5nLCBwcm92aWRlcik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgb25VcGRhdGU6ICgpID0+IHtcbiAgICAgIHN5bmNDdXJzb3JQb3NpdGlvbnMoYmluZGluZywgcHJvdmlkZXIpO1xuICAgIH0sXG4gICAgc2tpcFRyYW5zZm9ybXM6IHRydWUsXG4gICAgdGFnOiBpc0Zyb21VbmRvTWFuZ2VyID8gJ2hpc3RvcmljJyA6ICdjb2xsYWJvcmF0aW9uJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTm9ybWFsaXphdGlvbk1lcmdlQ29uZmxpY3RzKGJpbmRpbmcsIG5vcm1hbGl6ZWROb2Rlcykge1xuICAvLyBXZSBoYW5kbGUgdGhlIG1lcmdlIG9wZXJhdGlvbnMgaGVyZVxuICBjb25zdCBub3JtYWxpemVkTm9kZXNLZXlzID0gQXJyYXkuZnJvbShub3JtYWxpemVkTm9kZXMpO1xuICBjb25zdCBjb2xsYWJOb2RlTWFwID0gYmluZGluZy5jb2xsYWJOb2RlTWFwO1xuICBjb25zdCBtZXJnZWROb2RlcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9ybWFsaXplZE5vZGVzS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGVLZXkgPSBub3JtYWxpemVkTm9kZXNLZXlzW2ldO1xuICAgIGNvbnN0IGxleGljYWxOb2RlID0gbGV4aWNhbC4kZ2V0Tm9kZUJ5S2V5KG5vZGVLZXkpO1xuICAgIGNvbnN0IGNvbGxhYk5vZGUgPSBjb2xsYWJOb2RlTWFwLmdldChub2RlS2V5KTtcblxuICAgIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiVGV4dE5vZGUpIHtcbiAgICAgIGlmIChsZXhpY2FsLiRpc1RleHROb2RlKGxleGljYWxOb2RlKSkge1xuICAgICAgICAvLyBXZSBtdXRhdGUgdGhlIHRleHQgY29sbGFiIG5vZGVzIGFmdGVyIHJlbW92aW5nXG4gICAgICAgIC8vIGFsbCB0aGUgZGVhZCBub2RlcyBmaXJzdCwgb3RoZXJ3aXNlIG9mZnNldHMgYnJlYWsuXG4gICAgICAgIG1lcmdlZE5vZGVzLnB1c2goW2NvbGxhYk5vZGUsIGxleGljYWxOb2RlLl9fdGV4dF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gY29sbGFiTm9kZS5nZXRPZmZzZXQoKTtcblxuICAgICAgICBpZiAob2Zmc2V0ID09PSAtMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gY29sbGFiTm9kZS5fcGFyZW50O1xuICAgICAgICBjb2xsYWJOb2RlLl9ub3JtYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICBwYXJlbnQuX3htbFRleHQuZGVsZXRlKG9mZnNldCwgMSk7XG5cbiAgICAgICAgY29sbGFiTm9kZU1hcC5kZWxldGUobm9kZUtleSk7XG4gICAgICAgIGNvbnN0IHBhcmVudENoaWxkcmVuID0gcGFyZW50Ll9jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnRDaGlsZHJlbi5pbmRleE9mKGNvbGxhYk5vZGUpO1xuICAgICAgICBwYXJlbnRDaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWVyZ2VkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBbY29sbGFiTm9kZSwgdGV4dF0gPSBtZXJnZWROb2Rlc1tpXTtcblxuICAgIGlmIChjb2xsYWJOb2RlIGluc3RhbmNlb2YgQ29sbGFiVGV4dE5vZGUgJiYgdHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb2xsYWJOb2RlLl90ZXh0ID0gdGV4dDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3luY0xleGljYWxVcGRhdGVUb1lqcyhiaW5kaW5nLCBwcm92aWRlciwgcHJldkVkaXRvclN0YXRlLCBjdXJyRWRpdG9yU3RhdGUsIGRpcnR5RWxlbWVudHMsIGRpcnR5TGVhdmVzLCBub3JtYWxpemVkTm9kZXMsIHRhZ3MpIHtcbiAgc3luY1dpdGhUcmFuc2FjdGlvbihiaW5kaW5nLCAoKSA9PiB7XG4gICAgY3VyckVkaXRvclN0YXRlLnJlYWQoKCkgPT4ge1xuICAgICAgLy8gV2UgY2hlY2sgaWYgdGhlIHVwZGF0ZSBoYXMgY29tZSBmcm9tIGEgb3JpZ2luIHdoZXJlIHRoZSBvcmlnaW5cbiAgICAgIC8vIHdhcyB0aGUgY29sbGFib3JhdGlvbiBiaW5kaW5nIHByZXZpb3VzbHkuIFRoaXMgY2FuIGhlbHAgdXNcbiAgICAgIC8vIHByZXZlbnQgdW5uZWNlc3NhcmlseSByZS1kaWZmaW5nIGFuZCBwb3NzaWJsZSByZS1hcHBseWluZ1xuICAgICAgLy8gdGhlIHNhbWUgY2hhbmdlIGVkaXRvciBzdGF0ZSBhZ2Fpbi4gRm9yIGV4YW1wbGUsIGlmIGEgdXNlclxuICAgICAgLy8gdHlwZXMgYSBjaGFyYWN0ZXIgYW5kIHdlIGdldCBpdCwgd2UgZG9uJ3Qgd2FudCB0byB0aGVuIGluc2VydFxuICAgICAgLy8gdGhlIHNhbWUgY2hhcmFjdGVyIGFnYWluLiBUaGUgZXhjZXB0aW9uIHRvIHRoaXMgaGV1cmlzdGljIGlzXG4gICAgICAvLyB3aGVuIHdlIG5lZWQgdG8gaGFuZGxlIG5vcm1hbGl6YXRpb24gbWVyZ2UgY29uZmxpY3RzLlxuICAgICAgaWYgKHRhZ3MuaGFzKCdjb2xsYWJvcmF0aW9uJykgfHwgdGFncy5oYXMoJ2hpc3RvcmljJykpIHtcbiAgICAgICAgaWYgKG5vcm1hbGl6ZWROb2Rlcy5zaXplID4gMCkge1xuICAgICAgICAgIGhhbmRsZU5vcm1hbGl6YXRpb25NZXJnZUNvbmZsaWN0cyhiaW5kaW5nLCBub3JtYWxpemVkTm9kZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHlFbGVtZW50cy5oYXMoJ3Jvb3QnKSkge1xuICAgICAgICBjb25zdCBwcmV2Tm9kZU1hcCA9IHByZXZFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgICAgICAgY29uc3QgbmV4dExleGljYWxSb290ID0gbGV4aWNhbC4kZ2V0Um9vdCgpO1xuICAgICAgICBjb25zdCBjb2xsYWJSb290ID0gYmluZGluZy5yb290O1xuICAgICAgICBjb2xsYWJSb290LnN5bmNQcm9wZXJ0aWVzRnJvbUxleGljYWwoYmluZGluZywgbmV4dExleGljYWxSb290LCBwcmV2Tm9kZU1hcCk7XG4gICAgICAgIGNvbGxhYlJvb3Quc3luY0NoaWxkcmVuRnJvbUxleGljYWwoYmluZGluZywgbmV4dExleGljYWxSb290LCBwcmV2Tm9kZU1hcCwgZGlydHlFbGVtZW50cywgZGlydHlMZWF2ZXMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSBsZXhpY2FsLiRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBwcmV2RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgICAgIHN5bmNMZXhpY2FsU2VsZWN0aW9uVG9ZanMoYmluZGluZywgcHJvdmlkZXIsIHByZXZTZWxlY3Rpb24sIHNlbGVjdGlvbik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKiogQG1vZHVsZSBAbGV4aWNhbC95anMgKi9cbmNvbnN0IENPTk5FQ1RFRF9DT01NQU5EID0gbGV4aWNhbC5jcmVhdGVDb21tYW5kKCdDT05ORUNURURfQ09NTUFORCcpO1xuY29uc3QgVE9HR0xFX0NPTk5FQ1RfQ09NTUFORCA9IGxleGljYWwuY3JlYXRlQ29tbWFuZCgnVE9HR0xFX0NPTk5FQ1RfQ09NTUFORCcpO1xuZnVuY3Rpb24gY3JlYXRlVW5kb01hbmFnZXIoYmluZGluZywgcm9vdCkge1xuICByZXR1cm4gbmV3IHlqcy5VbmRvTWFuYWdlcihyb290LCB7XG4gICAgdHJhY2tlZE9yaWdpbnM6IG5ldyBTZXQoW2JpbmRpbmcsIG51bGxdKVxuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRMb2NhbFN0YXRlKHByb3ZpZGVyLCBuYW1lLCBjb2xvciwgZm9jdXNpbmcpIHtcbiAgcHJvdmlkZXIuYXdhcmVuZXNzLnNldExvY2FsU3RhdGUoe1xuICAgIGFuY2hvclBvczogbnVsbCxcbiAgICBjb2xvcixcbiAgICBmb2N1c1BvczogbnVsbCxcbiAgICBmb2N1c2luZzogZm9jdXNpbmcsXG4gICAgbmFtZVxuICB9KTtcbn1cbmZ1bmN0aW9uIHNldExvY2FsU3RhdGVGb2N1cyhwcm92aWRlciwgbmFtZSwgY29sb3IsIGZvY3VzaW5nKSB7XG4gIGNvbnN0IHtcbiAgICBhd2FyZW5lc3NcbiAgfSA9IHByb3ZpZGVyO1xuICBsZXQgbG9jYWxTdGF0ZSA9IGF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCk7XG5cbiAgaWYgKGxvY2FsU3RhdGUgPT09IG51bGwpIHtcbiAgICBsb2NhbFN0YXRlID0ge1xuICAgICAgYW5jaG9yUG9zOiBudWxsLFxuICAgICAgY29sb3IsXG4gICAgICBmb2N1c1BvczogbnVsbCxcbiAgICAgIGZvY3VzaW5nOiBmb2N1c2luZyxcbiAgICAgIG5hbWVcbiAgICB9O1xuICB9XG5cbiAgbG9jYWxTdGF0ZS5mb2N1c2luZyA9IGZvY3VzaW5nO1xuICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZShsb2NhbFN0YXRlKTtcbn1cblxuZXhwb3J0cy5DT05ORUNURURfQ09NTUFORCA9IENPTk5FQ1RFRF9DT01NQU5EO1xuZXhwb3J0cy5UT0dHTEVfQ09OTkVDVF9DT01NQU5EID0gVE9HR0xFX0NPTk5FQ1RfQ09NTUFORDtcbmV4cG9ydHMuY3JlYXRlQmluZGluZyA9IGNyZWF0ZUJpbmRpbmc7XG5leHBvcnRzLmNyZWF0ZVVuZG9NYW5hZ2VyID0gY3JlYXRlVW5kb01hbmFnZXI7XG5leHBvcnRzLmluaXRMb2NhbFN0YXRlID0gaW5pdExvY2FsU3RhdGU7XG5leHBvcnRzLnNldExvY2FsU3RhdGVGb2N1cyA9IHNldExvY2FsU3RhdGVGb2N1cztcbmV4cG9ydHMuc3luY0N1cnNvclBvc2l0aW9ucyA9IHN5bmNDdXJzb3JQb3NpdGlvbnM7XG5leHBvcnRzLnN5bmNMZXhpY2FsVXBkYXRlVG9ZanMgPSBzeW5jTGV4aWNhbFVwZGF0ZVRvWWpzO1xuZXhwb3J0cy5zeW5jWWpzQ2hhbmdlc1RvTGV4aWNhbCA9IHN5bmNZanNDaGFuZ2VzVG9MZXhpY2FsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/yjs/LexicalYjs.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@lexical/yjs/LexicalYjs.js":
/*!*************************************************!*\
  !*** ./node_modules/@lexical/yjs/LexicalYjs.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst LexicalYjs =  true ? __webpack_require__(/*! ./LexicalYjs.dev.js */ \"(ssr)/./node_modules/@lexical/yjs/LexicalYjs.dev.js\") : 0\nmodule.exports = LexicalYjs;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGxleGljYWwveWpzL0xleGljYWxZanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1k7QUFDWixtQkFBbUIsS0FBc0MsR0FBRyxtQkFBTyxDQUFDLGdGQUFxQixJQUFJLENBQStCO0FBQzVIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvQGxleGljYWwveWpzL0xleGljYWxZanMuanM/YTdiMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0J1xuY29uc3QgTGV4aWNhbFlqcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnID8gcmVxdWlyZSgnLi9MZXhpY2FsWWpzLmRldi5qcycpIDogcmVxdWlyZSgnLi9MZXhpY2FsWWpzLnByb2QuanMnKVxubW9kdWxlLmV4cG9ydHMgPSBMZXhpY2FsWWpzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@lexical/yjs/LexicalYjs.js\n");

/***/ })

};
;