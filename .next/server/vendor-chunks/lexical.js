"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lexical";
exports.ids = ["vendor-chunks/lexical"];
exports.modules = {

/***/ "(ssr)/./node_modules/lexical/Lexical.dev.js":
/*!*********************************************!*\
  !*** ./node_modules/lexical/Lexical.dev.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createCommand(type) {\n  return {\n    type\n  } ;\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3; // Reconciling\n\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2; // Text node modes\n\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2; // IS_INERT = 3\n// Text node formatting\n\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT; // Text node details\n\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1; // Element node formatting\n\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6; // Reconciliation\n\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b'; // For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\n\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n'; // For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\n\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'; // eslint-disable-next-line no-misleading-character-class\n\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']'); // eslint-disable-next-line no-misleading-character-class\n\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcesssingMutations() {\n  return isProcessingMutations;\n}\n\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\n\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\n\nfunction isManagedLineBreak(dom, target, editor) {\n  return (// @ts-expect-error: internal field\n    target.__lexicalLineBreak === dom || // @ts-ignore We intentionally add this to the Node.\n    dom[`__lexicalKey_${editor._key}`] !== undefined\n  );\n}\n\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\n\nfunction handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n\n  const text = target.nodeValue;\n\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\n\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\n}\n\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement(); // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n\n        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {\n          continue;\n        }\n\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            handleTextMutation( // nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true; // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n\n          const addedDOMs = mutation.addedNodes;\n\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      } // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n\n\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.getChildrenKeys();\n            let currentDOM = targetDOM.firstChild;\n\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n\n              if (correctDOM === null) {\n                continue;\n              }\n\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      } // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n\n\n      const records = observer.takeRecords(); // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        } // Clear any of those removal mutations\n\n\n        observer.takeRecords();\n      }\n\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\n\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\n\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  } // Backward\n\n\n  let previousNode;\n\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  } // Forward\n\n\n  let nextNode;\n\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\n\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet keyCounter = 1;\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n\n  if (activeElement === null) {\n    return false;\n  }\n\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' && // @ts-ignore iternal field\n  activeElement.__lexicalEditor == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n\n  while (currentNode != null) {\n    // @ts-expect-error: internal field\n    const editor = currentNode.__lexicalEditor;\n\n    if (editor != null) {\n      return editor;\n    }\n\n    currentNode = getParentElement(currentNode);\n  }\n\n  return null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\n\nfunction isDOMNodeLexicalTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE;\n}\n\nfunction getDOMTextNode(element) {\n  let node = element;\n\n  while (node != null) {\n    if (isDOMNodeLexicalTextNode(node)) {\n      return node;\n    }\n\n    node = node.firstChild;\n  }\n\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  const isStateFlagPresent = format & activeFormat;\n\n  if (isStateFlagPresent && (alignWithFormat === null || (alignWithFormat & activeFormat) === 0)) {\n    // Remove the state flag.\n    return format ^ activeFormat;\n  }\n\n  if (alignWithFormat === null || alignWithFormat & activeFormat) {\n    // Add the state flag.\n    return format | activeFormat;\n  }\n\n  return format;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    node.__key = existingKey;\n    return;\n  }\n\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n\n  editorState._nodeMap.set(key, node); // TODO Split this function into leaf/element\n\n\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n\n  editor._cloneNotNeeded.add(key);\n\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\n\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n\n    const node = nodeMap.get(nextParentKey);\n\n    if (node === undefined) {\n      break;\n    }\n\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling(); // TODO: this function duplicates a bunch of operations, can be simplified.\n\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n\n      writableNode.__prev = null;\n    }\n\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n\n      writableNode.__next = null;\n    }\n\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n} // Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\n\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n\n  const node = editorState._nodeMap.get(key);\n\n  if (node === undefined) {\n    return null;\n  }\n\n  return node;\n}\nfunction getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor(); // @ts-ignore We intentionally add this to the Node.\n\n  const key = dom[`__lexicalKey_${editor._key}`];\n\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n\n  return null;\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n\n  while (dom != null) {\n    const node = getNodeFromDOMNode(dom, editorState);\n\n    if (node !== null) {\n      return node;\n    }\n\n    dom = getParentElement(dom);\n  }\n\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n\n    if (editorState.isEmpty()) {\n      return;\n    }\n\n    if (type === 'root') {\n      $getRoot().markDirty();\n      return;\n    }\n\n    const nodeMap = editorState._nodeMap;\n\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n\n    selection.dirty = true;\n    selection._cachedNodes = null;\n  }\n\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\nfunction getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n\n    return null;\n  }\n\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\n\nfunction getNodeKeyFromDOM( // Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n\n  while (node != null) {\n    // @ts-ignore We intentionally add this to the Node.\n    const key = node[`__lexicalKey_${editor._key}`];\n\n    if (key !== undefined) {\n      return key;\n    }\n\n    node = getParentElement(node);\n  }\n\n  return null;\n}\n\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\n    return anchorNode.nodeValue;\n  }\n\n  return null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n\n  if (domSelection === null) {\n    return;\n  }\n\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n\n    const prevTextContent = node.getTextContent();\n\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n\n        return;\n      }\n\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing || // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter())) {\n        node.markDirty();\n        return;\n      }\n\n      const selection = $getSelection();\n\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\n\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n} // This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\n\n\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(keyCode, altKey, ctrlKey, metaKey) {\n  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(keyCode, shiftKey) {\n  return isReturn(keyCode) && !shiftKey;\n}\nfunction isLineBreak(keyCode, shiftKey) {\n  return isReturn(keyCode) && shiftKey;\n} // Inserts a new line after the selection\n\nfunction isOpenLineBreak(keyCode, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && keyCode === 79;\n}\nfunction isDeleteWordBackward(keyCode, altKey, ctrlKey) {\n  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(keyCode, altKey, ctrlKey) {\n  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(keyCode);\n}\nfunction isDeleteLineForward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isDelete(keyCode);\n}\nfunction isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n\n    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;\n  }\n\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n\n  return isBackspace(keyCode);\n}\nfunction isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n\n    return isDelete(keyCode) || keyCode === 68 && ctrlKey;\n  }\n\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n\n  return isDelete(keyCode);\n}\nfunction isUndo(keyCode, shiftKey, metaKey, ctrlKey) {\n  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return keyCode === 90 && metaKey && shiftKey;\n  }\n\n  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;\n}\nfunction isCopy(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n\n  if (keyCode === 67) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n\n  return false;\n}\nfunction isCut(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n\n  if (keyCode === 88) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n\n  return false;\n}\n\nfunction isArrowLeft(keyCode) {\n  return keyCode === 37;\n}\n\nfunction isArrowRight(keyCode) {\n  return keyCode === 39;\n}\n\nfunction isArrowUp(keyCode) {\n  return keyCode === 38;\n}\n\nfunction isArrowDown(keyCode) {\n  return keyCode === 40;\n}\n\nfunction isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(keyCode, ctrlKey, metaKey) {\n  return isArrowUp(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(keyCode, ctrlKey, metaKey) {\n  return isArrowDown(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(keyCode) {\n  return keyCode === 32;\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n\n  return ctrlKey;\n}\nfunction isReturn(keyCode) {\n  return keyCode === 13;\n}\nfunction isBackspace(keyCode) {\n  return keyCode === 8;\n}\nfunction isEscape(keyCode) {\n  return keyCode === 27;\n}\nfunction isDelete(keyCode) {\n  return keyCode === 46;\n}\nfunction isSelectAll(keyCode, metaKey, ctrlKey) {\n  return keyCode === 65 && controlOrMeta(metaKey, ctrlKey);\n}\nfunction $selectAll() {\n  const root = $getRoot();\n  const selection = root.select(0, root.getChildrenSize());\n  $setSelection($normalizeSelection(selection));\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n\n  const classNames = classNamesTheme[classNameThemeType]; // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n\n  if (typeof classNames === 'string') {\n    const classNamesArr = classNames.split(' ');\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n\n  const prevMutation = mutatedNodesByType.get(nodeKey); // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\nfunction $nodesOfType(klass) {\n  const editorState = getActiveEditorState();\n  const readOnly = editorState._readOnly;\n  const klassType = klass.getType();\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\n      nodesOfType.push(node);\n    }\n  }\n\n  return nodesOfType;\n}\n\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\n\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n\n      return possibleNode;\n    }\n  }\n\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = rootElement.ownerDocument;\n  const defaultView = doc.defaultView;\n\n  if (defaultView === null) {\n    return;\n  }\n\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n\n    let diff = 0;\n\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n\n    if (isBodyElement) {\n      break;\n    }\n\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n\n  editor._updateTags.add(tag);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = domElem.ownerDocument;\n  return ownerDoc && ownerDoc.defaultView || null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n\n    parent = parent.getParentOrThrow();\n  }\n\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\nfunction $copyNode(node) {\n  // @ts-ignore\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n\n  const registeredNode = editor._nodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n    }\n  }\n\n  const replaceFunc = registeredNode.replace;\n\n  if (replaceFunc !== null) {\n    const replacementNode = replaceFunc(node);\n\n    if (!(replacementNode instanceof node.constructor)) {\n      {\n        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);\n      }\n    }\n\n    return replacementNode;\n  }\n\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\n\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = blockCursorTheme.split(' '); // @ts-expect-error: intentional\n\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n\n  return element;\n}\n\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\n\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n\n      if (needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n\n      rootElement.style.caretColor = 'transparent';\n\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n\n      return;\n    }\n  } // Remove cursor\n\n\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n\n  if (startNode == null) {\n    startNode = node;\n  }\n\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent); // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n\n    if (isParentRoot) {\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\nfunction $getChildrenRecursively(node) {\n  const nodes = [];\n  const stack = [node];\n\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n\n    if (!(currentNode !== undefined)) {\n      throw Error(`Stack.length > 0; can't be undefined`);\n    }\n\n    if ($isElementNode(currentNode)) {\n      stack.unshift(...currentNode.getChildren());\n    }\n\n    if (currentNode !== node) {\n      nodes.push(currentNode);\n    }\n  }\n\n  return nodes;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n\n      delete decorators[key];\n    }\n  }\n}\n\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n\n  while (child !== null) {\n    const childKey = child.__key; // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      } // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n\n\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n\n      nodeMapDelete.push(childKey);\n    }\n\n    child = child.getNextSibling();\n  }\n}\n\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap; // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n\n  const nodeMapDelete = [];\n\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        } // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n\n\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\n\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  } // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n\n\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\n\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\n\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\n\nconst DEFAULT_INDENT_VALUE = '40px';\n\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\n\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\n\nfunction createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1); // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      createChildrenWithDirection(children, endIndex, node, dom);\n    }\n\n    const format = node.__format;\n\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      } // Decorators are always non editable\n\n\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // @ts-expect-error: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\n\nfunction createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  createChildren(children, element, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\n\nfunction createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n\n  for (; startIndex <= endIndex; ++startIndex) {\n    createNode(children[startIndex], dom, insertDOM);\n  }\n\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  } // @ts-expect-error: internal field\n\n\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\n\nfunction isLastChildLineBreakOrDecorator(childKey, nodeMap) {\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();\n} // If we end an element with a LineBreakNode, then we need to add an additional <br>\n\n\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));\n  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);\n\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // @ts-expect-error: internal field\n      const element = dom.__lexicalLineBreak;\n\n      if (element != null) {\n        dom.removeChild(element);\n      } // @ts-expect-error: internal field\n\n\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br'); // @ts-expect-error: internal field\n\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\n\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent = // @ts-expect-error: internal field\n  dom.__lexicalDirTextContent; // @ts-expect-error: internal field\n\n  const previousDirection = dom.__lexicalDir;\n\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined; // Remove the old theme classes if they exist\n\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = previousDirectionTheme.split(' ');\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        } // @ts-ignore: intentional\n\n\n        classList.remove(...previousDirectionTheme);\n      }\n\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = nextDirectionTheme.split(' '); // @ts-expect-error: intentional\n\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        } // Update direction\n\n\n        dom.dir = direction;\n      }\n\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n\n    activeTextDirection = direction; // @ts-expect-error: internal field\n\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent; // @ts-expect-error: internal field\n\n    dom.__lexicalDir = direction;\n  }\n}\n\nfunction reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  reconcileChildren(prevElement, nextElement, dom);\n  reconcileBlockDirection(nextElement, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\n\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n\n  return children;\n}\n\nfunction reconcileChildren(prevElement, nextElement, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFrstChildKey = nextElement.__first;\n\n    if (prevFirstChildKey === nextFrstChildKey) {\n      reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = createNode(nextFrstChildKey, null, null);\n      dom.replaceChild(replacementDOM, lastDOM);\n      destroyNode(prevFirstChildKey, null);\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        // @ts-expect-error: internal field\n        const lexicalLineBreak = dom.__lexicalLineBreak;\n        const canUseFastPath = lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);\n    }\n  }\n\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  } // @ts-expect-error: internal field\n\n\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\n\nfunction reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key); // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // @ts-expect-error: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      } // @ts-expect-error: internal field\n\n\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n\n    return dom;\n  } // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n\n\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  } // Update node. If it returns true, we need to unmount and re-create the node\n\n\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = createNode(key, null, null);\n\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n\n    const nextFormat = nextNode.__format;\n\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n\n    if (isDirty) {\n      reconcileChildrenWithDirection(prevNode, nextNode, dom);\n\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    nextNode = nextNode.getWritable();\n    nextNode.__cachedText = editorTextContent;\n  }\n\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n\n  return dom;\n}\n\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n\n  pendingDecorators[key] = decorator;\n}\n\nfunction getFirstChild(element) {\n  return element.firstChild;\n}\n\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n\n  return nextSibling;\n}\n\nfunction reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n\n          reconcileNode(nextKey, dom);\n        }\n\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n  }\n\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\n\nfunction reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = ''; // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap); // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  reconcileNode('root', null); // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n\n  activeEditor$1 = undefined; // @ts-ignore\n\n  activeEditorNodes = undefined; // @ts-ignore\n\n  activeDirtyElements = undefined; // @ts-ignore\n\n  activeDirtyLeaves = undefined; // @ts-ignore\n\n  activePrevNodeMap = undefined; // @ts-ignore\n\n  activeNextNodeMap = undefined; // @ts-ignore\n\n  activeEditorConfig = undefined; // @ts-ignore\n\n  activePrevKeyToDOMMap = undefined; // @ts-ignore\n\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap; // @ts-ignore We intentionally add this to the Node.\n\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\n\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\n\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\n\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = 0;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nlet rootElementsRegistered = 0;\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0]; // This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\n\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key || // If we're working with a non-text node.\n  !$isTextNode(anchorNode) || // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT || // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() || // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) || // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) || // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style || // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\n\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\n}\n\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false; // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n\n    const selection = $getSelection(); // Update the selection format\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        } // If we have marked a collapsed selection format, and we're\n        // within the given time range  then attempt to use that format\n        // instead of getting the format from the anchor node.\n\n\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element') {\n            selection.format = 0;\n            selection.style = '';\n          }\n        }\n      } else {\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n\n          if ($isTextNode(node)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n} // This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\n\n\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Tripple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n\n          if (anchorNode !== focusNode) {\n            if ($isElementNode(anchorNode)) {\n              anchorNode.select(0);\n            } else {\n              anchorNode.getParentOrThrow().select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n\n        if (domAnchorNode !== null) {\n          const nodeType = domAnchorNode.nodeType; // If the user is attempting to click selection back onto text, then\n          // we should attempt create a range selection.\n          // When we click on an empty paragraph node or the end of a paragraph that ends\n          // with an image/poll, the nodeType will be ELEMENT_NODE\n\n          if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {\n            const newSelection = internalCreateRangeSelection(lastSelection, domSelection, editor);\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\n\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n\n  if (target instanceof Node && pointerType !== 'touch') {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\n\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n\n  const targetRanges = event.getTargetRanges();\n\n  if (targetRanges.length === 0) {\n    return null;\n  }\n\n  return targetRanges[0];\n}\n\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\n\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\n\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event); // We let the browser do its own thing for composition.\n\n  if (inputType === 'deleteCompositionText' || // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n\n        $setSelection(prevSelection.clone());\n      }\n\n      if ($isRangeSelection(selection)) {\n        // Used for handling backspace in Android.\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && selection.anchor.key === selection.focus.key) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0; // Fixes an Android bug where selection flickers when backspacing\n\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          event.preventDefault();\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n        }\n\n        return;\n      }\n    }\n\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n\n    const data = event.data; // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    } // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n\n\n    event.preventDefault();\n\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null); // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n\n          break;\n        }\n\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n\n          break;\n        }\n\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n\n    }\n  });\n}\n\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n\n      if (domSelection === null) {\n        return;\n      }\n\n      const offset = anchor.offset; // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n\n      const textLength = data.length; // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      } // This ensures consistency on Android.\n\n\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData); // onInput always fires after onCompositionEnd for FF.\n\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    } // Also flush any other mutations that might have occurred\n    // since the change.\n\n\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\n\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n\n      if ( // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\n\nfunction onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null); // Handle termination of composition.\n\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n\n      return;\n    } // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n\n\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n\n  $updateSelectedTextFromDOM(true, editor, data);\n}\n\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\n\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.keyCode;\n\n  if (editor.isComposing()) {\n    return;\n  }\n\n  const {\n    keyCode,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n\n  if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(keyCode, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(keyCode)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(keyCode, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(keyCode, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(keyCode)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(keyCode)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(keyCode)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n\n    if ($isNodeSelection(prevSelection)) {\n      if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(keyCode, metaKey, ctrlKey)) {\n        event.preventDefault();\n        editor.update(() => {\n          $selectAll();\n        });\n      } // FF does it well (no need to override behavior)\n\n    } else if (!IS_FIREFOX && isSelectAll(keyCode, metaKey, ctrlKey)) {\n      event.preventDefault();\n      editor.update(() => {\n        $selectAll();\n      });\n    }\n  }\n\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\n\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n\n  if (eventHandles === undefined) {\n    eventHandles = []; // @ts-expect-error: internal field\n\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n\n  return eventHandles;\n} // Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\n\n\nconst activeNestedEditorsMap = new Map();\n\nfunction onDocumentSelectionChange(event) {\n  const target = event.target;\n  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\n  const domSelection = getDOMSelection(targetWindow);\n\n  if (domSelection === null) {\n    return;\n  }\n\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n\n  if (nextActiveEditor === null) {\n    return;\n  }\n\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n\n      if (domAnchorNode === null) {\n        return;\n      }\n\n      const nodeType = domAnchorNode.nodeType; // If the user is attempting to click selection back onto text, then\n      // we should attempt create a range selection.\n      // When we click on an empty paragraph node or the end of a paragraph that ends\n      // with an image/poll, the nodeType will be ELEMENT_NODE\n\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\n        return;\n      }\n\n      const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor);\n      $setSelection(newSelection);\n    });\n  } // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n\n\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n\n  onSelectionChange(domSelection, nextActiveEditor, true); // If newly selected editor is nested, then add it to the map, clean map otherwise\n\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\n\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\n\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\n\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  if (rootElementsRegistered === 0) {\n    const doc = rootElement.ownerDocument;\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n\n  rootElementsRegistered++; // @ts-expect-error: internal field\n\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n\n      stopLexicalPropagation(event);\n\n      if (editor.isEditable()) {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n\n      stopLexicalPropagation(event);\n\n      if (editor.isEditable()) {\n        switch (eventName) {\n          case 'cut':\n            return dispatchCommand(editor, CUT_COMMAND, event);\n\n          case 'copy':\n            return dispatchCommand(editor, COPY_COMMAND, event);\n\n          case 'paste':\n            return dispatchCommand(editor, PASTE_COMMAND, event);\n\n          case 'dragstart':\n            return dispatchCommand(editor, DRAGSTART_COMMAND, event);\n\n          case 'dragover':\n            return dispatchCommand(editor, DRAGOVER_COMMAND, event);\n\n          case 'dragend':\n            return dispatchCommand(editor, DRAGEND_COMMAND, event);\n\n          case 'focus':\n            return dispatchCommand(editor, FOCUS_COMMAND, event);\n\n          case 'blur':\n            {\n              return dispatchCommand(editor, BLUR_COMMAND, event);\n            }\n\n          case 'drop':\n            return dispatchCommand(editor, DROP_COMMAND, event);\n        }\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  if (rootElementsRegistered !== 0) {\n    rootElementsRegistered--; // We only want to have a single global selectionchange event handler, shared\n    // between all editor instances.\n\n    if (rootElementsRegistered === 0) {\n      const doc = rootElement.ownerDocument;\n      doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n    }\n  } // @ts-expect-error: internal field\n\n\n  const editor = rootElement.__lexicalEditor;\n\n  if (editor !== null && editor !== undefined) {\n    cleanActiveNestedEditorsMap(editor); // @ts-expect-error: internal field\n\n    rootElement.__lexicalEditor = null;\n  }\n\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  } // @ts-expect-error: internal field\n\n\n  rootElement.__lexicalEventHandles = [];\n}\n\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\n\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n\n  if (parent === null) {\n    return;\n  }\n\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    removeNode(parent, restoreSelection);\n  }\n\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n\n\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  constructor(key) {\n    // @ts-expect-error\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, // @ts-expect-error\n        this.constructor);\n      }\n    }\n  } // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n\n\n  getType() {\n    return this.__type;\n  }\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n\n\n  isAttached() {\n    let nodeKey = this.__key;\n\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n\n      const node = $getNodeByKey(nodeKey);\n\n      if (node === null) {\n        break;\n      }\n\n      nodeKey = node.__parent;\n    }\n\n    return false;\n  }\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n\n\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n\n    if (targetSelection == null) {\n      return false;\n    }\n\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n\n    if ($isTextNode(this)) {\n      return isSelected;\n    } // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n\n\n    if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element' && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {\n      return false;\n    }\n\n    return isSelected;\n  }\n  /**\n   * Returns this nodes key.\n   */\n\n\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n\n\n  getIndexWithinParent() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return -1;\n    }\n\n    let node = parent.getFirstChild();\n    let index = 0;\n\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n\n      index++;\n      node = node.getNextSibling();\n    }\n\n    return -1;\n  }\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n\n\n  getParent() {\n    const parent = this.getLatest().__parent;\n\n    if (parent === null) {\n      return null;\n    }\n\n    return $getNodeByKey(parent);\n  }\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n\n\n  getParentOrThrow() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n\n    return parent;\n  }\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n\n\n  getTopLevelElement() {\n    let node = this;\n\n    while (node !== null) {\n      const parent = node.getParent();\n\n      if ($isRootOrShadowRoot(parent)) {\n        return node;\n      }\n\n      node = parent;\n    }\n\n    return null;\n  }\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n\n\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n\n    return parent;\n  }\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n\n\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n\n    return parents;\n  }\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n\n\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n\n    return parents;\n  }\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n\n\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n\n\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return siblings;\n    }\n\n    let node = parent.getFirstChild();\n\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n\n    return siblings;\n  }\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n\n\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n\n\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n\n    return siblings;\n  }\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n\n\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n\n    const aLength = a.length;\n    const bLength = b.length;\n\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n\n    const bSet = new Set(b);\n\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n\n\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n\n    return this.__key === object.__key;\n  }\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n\n\n  isBefore(targetNode) {\n    if (this === targetNode) {\n      return false;\n    }\n\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n\n    while (true) {\n      const parent = node.getParentOrThrow();\n\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n\n      node = parent;\n    }\n\n    node = targetNode;\n\n    while (true) {\n      const parent = node.getParentOrThrow();\n\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n\n      node = parent;\n    }\n\n    return indexA < indexB;\n  }\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n\n\n  isParentOf(targetNode) {\n    const key = this.__key;\n\n    if (key === targetNode.__key) {\n      return false;\n    }\n\n    let node = targetNode;\n\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n\n      node = node.getParent();\n    }\n\n    return false;\n  } // TO-DO: this function can be simplified a lot\n\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n\n\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n\n    while (true) {\n      const key = node.__key;\n\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n\n      if (node === targetNode) {\n        break;\n      }\n\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n\n      const parent = node.getParentOrThrow();\n\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n\n      if (parent === targetNode) {\n        break;\n      }\n\n      let parentSibling = null;\n      let ancestor = parent;\n\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        }\n      } while (parentSibling === null);\n\n      node = parentSibling;\n    }\n\n    if (!isBefore) {\n      nodes.reverse();\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n\n\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n\n\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n\n    return latest;\n  }\n  /**\n   * Returns a mutable version of the node. Will throw an error if\n   * called outside of a Lexical Editor {@link LexicalEditor.update} callback.\n   *\n   */\n\n\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key; // Ensure we get the latest node from pending state\n\n    const latestNode = this.getLatest();\n    const parent = latestNode.__parent;\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n\n    if (selection !== null) {\n      selection._cachedNodes = null;\n    }\n\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n\n    const constructor = latestNode.constructor; // @ts-expect-error\n\n    const mutableNode = constructor.clone(latestNode);\n    mutableNode.__parent = parent;\n    mutableNode.__next = latestNode.__next;\n    mutableNode.__prev = latestNode.__prev;\n\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\n      mutableNode.__first = latestNode.__first;\n      mutableNode.__last = latestNode.__last;\n      mutableNode.__size = latestNode.__size;\n      mutableNode.__indent = latestNode.__indent;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__dir = latestNode.__dir;\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__style = latestNode.__style;\n      mutableNode.__mode = latestNode.__mode;\n      mutableNode.__detail = latestNode.__detail;\n    }\n\n    cloneNotNeeded.add(key);\n    mutableNode.__key = key;\n    internalMarkNodeAsDirty(mutableNode); // Update reference in node map\n\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n\n\n  getTextContent() {\n    return '';\n  }\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n\n\n  getTextContentSize() {\n    return this.getTextContent().length;\n  } // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n\n\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n\n\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n\n\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n\n\n  exportJSON() {\n    {\n      throw Error(`exportJSON: base method not extended`);\n    }\n  }\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n\n\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n\n\n  static transform() {\n    return null;\n  } // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n\n\n  remove(preserveEmptyParent) {\n    removeNode(this, true, preserveEmptyParent);\n  }\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n\n\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) selection = selection.clone();\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    removeNode(self, false, true);\n\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n\n    writableReplaceWith.__prev = prevKey;\n\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n\n    if (includeChildren) {\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n\n    return writableReplaceWith;\n  }\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n\n\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n\n    return nodeToInsert;\n  }\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n\n\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev; // TODO: this is O(n), can we improve?\n\n    const index = this.getIndexWithinParent();\n\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n\n    return nodeToInsert;\n  }\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n\n\n  isParentRequired() {\n    return false;\n  }\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n\n\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n\n\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n\n\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n\n    if (nextSibling === null) {\n      return parent.select();\n    }\n\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n\n\n  markDirty() {\n    this.getWritable();\n  }\n\n}\n\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type); // Common error - split in its own invariant\n\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n\n  const editorKlass = registeredNode.klass;\n\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n\n  constructor(key) {\n    super(key);\n  }\n\n  getTextContent() {\n    return '\\n';\n  }\n\n  createDOM() {\n    return document.createElement('br');\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      br: node => {\n        const parentElement = node.parentElement; // If the <br> is the only child, then skip including it\n\n        let firstChild;\n        let lastChild;\n\n        if (parentElement !== null && ((firstChild = parentElement.firstChild) === node || firstChild.nextSibling === node && firstChild.nodeType === DOM_TEXT_TYPE && (firstChild.textContent || '').match(/^[\\s|\\r?\\n|\\t]+$/) !== null) && ((lastChild = parentElement.lastChild) === node || lastChild.previousSibling === node && lastChild.nodeType === DOM_TEXT_TYPE && (lastChild.textContent || '').match(/^[\\s|\\r?\\n|\\t]+$/) !== null)) {\n          return null;\n        }\n\n        return {\n          conversion: convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode();\n  }\n\n  exportJSON() {\n    return {\n      type: 'linebreak',\n      version: 1\n    };\n  }\n\n}\n\nfunction convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\n\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n\n  return null;\n}\n\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n\n  return 'span';\n}\n\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList; // Firstly we handle the base theme.\n\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  } // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n\n\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n\n          continue;\n        }\n\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\n\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\n\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing(); // Always add a suffix if we're composing a node\n\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        } // @ts-expect-error\n\n\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\n\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme; // Apply theme class names\n\n  const textClassNames = theme.text;\n\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\n\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n/** @noInheritDoc */\n\n\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'text';\n  }\n\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n\n\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n\n\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n\n\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n\n\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n\n\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n\n\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n\n\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n\n\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n\n\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n\n\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n\n\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n\n\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n\n\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  } // View\n\n\n  createDOM(config) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n\n    if (prevTag !== nextTag) {\n      return true;\n    }\n\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n\n    let innerDOM = dom;\n\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme; // Apply theme class names\n\n    const textClassNames = theme.text;\n\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createTextNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  } // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n\n\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor); // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n\n    if (element !== null) {\n      if (this.hasFormat('bold')) {\n        element = wrapElementWith(element, 'b');\n      }\n\n      if (this.hasFormat('italic')) {\n        element = wrapElementWith(element, 'i');\n      }\n\n      if (this.hasFormat('strikethrough')) {\n        element = wrapElementWith(element, 's');\n      }\n\n      if (this.hasFormat('underline')) {\n        element = wrapElementWith(element, 'u');\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      type: 'text',\n      version: 1\n    };\n  } // Mutators\n\n\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n\n\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.togglerUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n\n\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n\n\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it is present.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n\n\n  toggleFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return this.setFormat(this.getFormat() ^ formatFlag);\n  }\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n\n\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n\n\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n\n\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n\n    if (this.__mode === mode) {\n      return this;\n    }\n\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n\n\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n\n    return selection;\n  }\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n\n\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n\n    if (index < 0) {\n      index = handledTextLength + index;\n\n      if (index < 0) {\n        index = 0;\n      }\n    }\n\n    const selection = $getSelection();\n\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n\n\n  canInsertTextBefore() {\n    return true;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n\n\n  canInsertTextAfter() {\n    return true;\n  }\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n\n\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n\n      string += textContent[i];\n    }\n\n    if (string !== '') {\n      parts.push(string);\n    }\n\n    const partsLength = parts.length;\n\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n\n    const firstPart = parts[0];\n    const parent = self.getParentOrThrow();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    } // Handle selection\n\n\n    const selection = $getSelection(); // Then handle all other parts\n\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    } // Insert the nodes into the parent's children\n\n\n    internalMarkSiblingsAsDirty(this);\n    const writableParent = parent.getWritable();\n    const insertionIndex = this.getIndexWithinParent();\n\n    if (hasReplacedSelf) {\n      writableParent.splice(insertionIndex, 0, splitNodes);\n      this.remove();\n    } else {\n      writableParent.splice(insertionIndex, 1, splitNodes);\n    }\n\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n    }\n\n    return splitNodes;\n  }\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n\n\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n\n\n  isTextEntity() {\n    return false;\n  }\n\n}\n\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode; // Google Docs uses span tags + font-weight for bold text\n\n  const hasBoldFontWeight = span.style.fontWeight === '700'; // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n\n  const hasLinethroughTextDecoration = span.style.textDecoration === 'line-through'; // Google Docs uses span tags + font-style for italic text\n\n  const hasItalicFontStyle = span.style.fontStyle === 'italic'; // Google Docs uses span tags + text-decoration: underline for underline text\n\n  const hasUnderlineTextDecoration = span.style.textDecoration === 'underline'; // Google Docs uses span tags + vertical-align to specify subscript and superscript\n\n  const verticalAlign = span.style.verticalAlign;\n  return {\n    forChild: lexicalNode => {\n      if (!$isTextNode(lexicalNode)) {\n        return lexicalNode;\n      }\n\n      if (hasBoldFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n\n      if (hasLinethroughTextDecoration) {\n        lexicalNode.toggleFormat('strikethrough');\n      }\n\n      if (hasItalicFontStyle) {\n        lexicalNode.toggleFormat('italic');\n      }\n\n      if (hasUnderlineTextDecoration) {\n        lexicalNode.toggleFormat('underline');\n      }\n\n      if (verticalAlign === 'sub') {\n        lexicalNode.toggleFormat('subscript');\n      }\n\n      if (verticalAlign === 'super') {\n        lexicalNode.toggleFormat('superscript');\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode; // Google Docs wraps all copied HTML in a <b> with font-weight normal\n\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nconst preParentCache = new WeakMap();\n\nfunction isNodePre(node) {\n  return node.nodeName === 'PRE' || node.nodeType === DOM_ELEMENT_TYPE && node.style.whiteSpace.startsWith('pre');\n}\n\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n\n  const resultNode = cached === undefined ? parent : cached;\n\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n\n  return resultNode;\n}\n\nfunction convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n\n  if (!(parentDom !== null)) {\n    throw Error(`Expected parentElement of Text not to be null`);\n  }\n\n  let textContent = domNode_.textContent || ''; // No collapse and preserve segment break for pre, pre-wrap and pre-line\n\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n\n    return {\n      node: nodes\n    };\n  }\n\n  textContent = textContent.replace(/\\r?\\n|\\t/gm, ' ').replace('\\r', '').replace(/\\s+/g, ' ');\n\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n\n      if (previousTextContent.length > 0) {\n        if (previousTextContent.match(/(?:\\s|\\r?\\n|\\t)$/)) {\n          textContent = textContent.slice(1);\n        }\n\n        isStartOfLine = false;\n        break;\n      }\n    }\n\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^[\\s|\\r?\\n|\\t]+/, '');\n\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n\n  return {\n    node: $createTextNode(textContent)\n  };\n}\n\nconst inlineParents = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, 'i');\n\nfunction findTextInLine(text, forward) {\n  let node = text; // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    let sibling;\n\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n\n      if (parentElement === null) {\n        return null;\n      }\n\n      node = parentElement;\n    }\n\n    node = sibling;\n\n    if (node.nodeType === DOM_ELEMENT_TYPE) {\n      const display = node.style.display;\n\n      if (display === '' && node.nodeName.match(inlineParents) === null || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n\n    let descendant = node;\n\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n\n    if (node.nodeType === DOM_TEXT_TYPE) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\n\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\n\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !lexicalNode.hasFormat(format)) {\n        lexicalNode.toggleFormat(format);\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n\n  static clone(node) {\n    const newNode = new TabNode(node.__key); // TabNode __text can be either '\\t' or ''. insertText will remove the empty Node\n\n    newNode.__text = node.__text;\n    newNode.__format = node.__format;\n    newNode.__style = node.__style;\n    return newNode;\n  }\n\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n\n  static importDOM() {\n    return null;\n  }\n\n  static importJSON(serializedTabNode) {\n    const node = $createTabNode();\n    node.setFormat(serializedTabNode.format);\n    node.setStyle(serializedTabNode.style);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'tab',\n      version: 1\n    };\n  }\n\n  setTextContent(_text) {\n    {\n      throw Error(`TabNode does not support setTextContent`);\n    }\n  }\n\n  setDetail(_detail) {\n    {\n      throw Error(`TabNode does not support setDetail`);\n    }\n  }\n\n  setMode(_type) {\n    {\n      throw Error(`TabNode does not support setMode`);\n    }\n  }\n\n  canInsertTextBefore() {\n    return false;\n  }\n\n  canInsertTextAfter() {\n    return false;\n  }\n\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass Point {\n  constructor(key, offset, type) {\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n\n    return aNode.isBefore(bNode);\n  }\n\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n\n    return node;\n  }\n\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n\n      if (selection !== null) {\n        selection._cachedNodes = null;\n        selection.dirty = true;\n      }\n    }\n  }\n\n}\n\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\n\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n\n  point.set(key, offset, type);\n}\n\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\n\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target); // Fix the end point offset if it refers to the same element as start,\n    // as we've now inserted another element before it. Note that we only\n    // do it if selection is not collapsed as otherwise it'll transfer\n    // both focus and anchor to the text node below\n\n    if (end.type === 'element' && end.key === start.key && end.offset !== start.offset) {\n      end.set(end.key, end.offset + 1, 'element');\n    }\n  } // Transfer the element point to a text point.\n\n\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n\n  start.set(textNode.__key, 0, 'text');\n}\n\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\n\nclass NodeSelection {\n  constructor(objects) {\n    this.dirty = false;\n    this._nodes = objects;\n    this._cachedNodes = null;\n  }\n\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n\n  add(key) {\n    this.dirty = true;\n\n    this._nodes.add(key);\n\n    this._cachedNodes = null;\n  }\n\n  delete(key) {\n    this.dirty = true;\n\n    this._nodes.delete(key);\n\n    this._cachedNodes = null;\n  }\n\n  clear() {\n    this.dirty = true;\n\n    this._nodes.clear();\n\n    this._cachedNodes = null;\n  }\n\n  has(key) {\n    return this._nodes.has(key);\n  }\n\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n\n  extract() {\n    return this.getNodes();\n  }\n\n  insertRawText(text) {// Do nothing?\n  }\n\n  insertText() {// Do nothing?\n  }\n\n  insertNodes(nodes, selectStart) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd; // Insert nodes\n\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n\n    selectionAtEnd.insertNodes(nodes, selectStart); // Remove selected nodes\n\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n\n    return true;\n  }\n\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n\n    const objects = this._nodes;\n    const nodes = [];\n\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n\n    return nodes;\n  }\n\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n\n    return textContent;\n  }\n\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass GridSelection {\n  constructor(gridKey, anchor, focus) {\n    this.gridKey = gridKey;\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n\n  is(selection) {\n    if (!DEPRECATED_$isGridSelection(selection)) {\n      return false;\n    }\n\n    return this.gridKey === selection.gridKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n\n  set(gridKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.gridKey = gridKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n\n  clone() {\n    return new GridSelection(this.gridKey, this.anchor, this.focus);\n  }\n\n  isCollapsed() {\n    return false;\n  }\n\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n\n  extract() {\n    return this.getNodes();\n  }\n\n  insertRawText(text) {// Do nothing?\n  }\n\n  insertText() {// Do nothing?\n  }\n\n  insertNodes(nodes, selectStart) {\n    const focusNode = this.focus.getNode();\n    const selection = $normalizeSelection(focusNode.select(0, focusNode.getChildrenSize()));\n    return selection.insertNodes(nodes, selectStart);\n  } // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n\n\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n\n    if (!(anchorCellNode !== null)) {\n      throw Error(`getNodes: expected to find AnchorNode`);\n    }\n\n    const anchorCellNodeIndex = anchorCellNode.getIndexWithinParent();\n    const anchorCelRoweIndex = anchorCellNode.getParentOrThrow().getIndexWithinParent();\n    const focusCellNode = $getNodeByKey(this.focus.key);\n\n    if (!(focusCellNode !== null)) {\n      throw Error(`getNodes: expected to find FocusNode`);\n    }\n\n    const focusCellNodeIndex = focusCellNode.getIndexWithinParent();\n    const focusCellRowIndex = focusCellNode.getParentOrThrow().getIndexWithinParent();\n    const startX = Math.min(anchorCellNodeIndex, focusCellNodeIndex);\n    const stopX = Math.max(anchorCellNodeIndex, focusCellNodeIndex);\n    const startY = Math.min(anchorCelRoweIndex, focusCellRowIndex);\n    const stopY = Math.max(anchorCelRoweIndex, focusCellRowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n\n    const anchorNode = this.anchor.getNode();\n    const focusNode = this.focus.getNode();\n    const anchorCell = $findMatchingParent(anchorNode, DEPRECATED_$isGridCellNode); // todo replace with triplet\n\n    const focusCell = $findMatchingParent(focusNode, DEPRECATED_$isGridCellNode);\n\n    if (!DEPRECATED_$isGridCellNode(anchorCell)) {\n      throw Error(`Expected GridSelection anchor to be (or a child of) GridCellNode`);\n    }\n\n    if (!DEPRECATED_$isGridCellNode(focusCell)) {\n      throw Error(`Expected GridSelection focus to be (or a child of) GridCellNode`);\n    }\n\n    const anchorRow = anchorCell.getParent();\n\n    if (!DEPRECATED_$isGridRowNode(anchorRow)) {\n      throw Error(`Expected anchorCell to have a parent GridRowNode`);\n    }\n\n    const gridNode = anchorRow.getParent();\n\n    if (!DEPRECATED_$isGridNode(gridNode)) {\n      throw Error(`Expected tableNode to have a parent GridNode`);\n    } // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing GridSelection and moving the logic to the plugin would make\n    // this possible.\n\n\n    const [map, cellAMap, cellBMap] = DEPRECATED_$computeGridMap(gridNode, anchorCell, focusCell);\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n    let exploredMinColumn = minColumn;\n    let exploredMinRow = minRow;\n    let exploredMaxColumn = minColumn;\n    let exploredMaxRow = minRow;\n\n    function expandBoundary(mapValue) {\n      const {\n        cell,\n        startColumn: cellStartColumn,\n        startRow: cellStartRow\n      } = mapValue;\n      minColumn = Math.min(minColumn, cellStartColumn);\n      minRow = Math.min(minRow, cellStartRow);\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n    }\n\n    while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n      if (minColumn < exploredMinColumn) {\n        // Expand on the left\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const previousColumn = exploredMinColumn - 1;\n\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\n        }\n\n        exploredMinColumn = previousColumn;\n      }\n\n      if (minRow < exploredMinRow) {\n        // Expand on top\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const previousRow = exploredMinRow - 1;\n\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\n        }\n\n        exploredMinRow = previousRow;\n      }\n\n      if (maxColumn > exploredMaxColumn) {\n        // Expand on the right\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const nextColumn = exploredMaxColumn + 1;\n\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\n        }\n\n        exploredMaxColumn = nextColumn;\n      }\n\n      if (maxRow > exploredMaxRow) {\n        // Expand on the bottom\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const nextRow = exploredMaxRow + 1;\n\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\n        }\n\n        exploredMaxRow = nextRow;\n      }\n    }\n\n    const nodes = [gridNode];\n    let lastRow = null;\n\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n\n        if (!DEPRECATED_$isGridRowNode(currentRow)) {\n          throw Error(`Expected GridCellNode parent to be a GridRowNode`);\n        }\n\n        if (currentRow !== lastRow) {\n          nodes.push(currentRow);\n        }\n\n        nodes.push(cell, ...$getChildrenRecursively(cell));\n        lastRow = currentRow;\n      }\n    }\n\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n\n    return nodes;\n  }\n\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n\n    return textContent;\n  }\n\n}\nfunction DEPRECATED_$isGridSelection(x) {\n  return x instanceof GridSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this.format = format;\n    this.style = style;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n\n\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n\n\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n\n\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n\n\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset); // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n\n    let nodes;\n\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n    }\n\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n\n    return nodes;\n  }\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n\n\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n\n\n  getTextContent() {\n    const nodes = this.getNodes();\n\n    if (nodes.length === 0) {\n      return '';\n    }\n\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n\n    return textContent;\n  }\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n\n\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n\n\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n\n\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n\n\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n\n\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n\n\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n\n    this.insertNodes(nodes);\n  }\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection as a new\n   * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.\n   *\n   * @param text the text to insert into the Selection\n   */\n\n\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = this.isCollapsed() || anchor.isBefore(focus);\n    const format = this.format;\n    const style = this.style;\n\n    if (isBefore && anchor.type === 'element') {\n      $transferStartingElementPointToTextPoint(anchor, focus, format, style);\n    } else if (!isBefore && focus.type === 'element') {\n      $transferStartingElementPointToTextPoint(focus, anchor, format, style);\n    }\n\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const firstPoint = isBefore ? anchor : focus;\n    const endPoint = isBefore ? focus : anchor;\n    const startOffset = firstPoint.offset;\n    const endOffset = endPoint.offset;\n    let firstNode = selectedNodes[0];\n\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n\n      prevSibling.select();\n      firstNode = prevSibling;\n\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          } // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n\n\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n\n          return;\n        }\n      }\n\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]); // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode; // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      } // Handle mutations to the last node.\n\n\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n\n          lastNode = lastNode.spliceText(0, endOffset, '');\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      } // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n\n\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement); // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n\n          parent = parent.getParent();\n        }\n      } // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n\n\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      } // Remove all selected nodes that haven't already been removed.\n\n\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n\n\n  removeText() {\n    this.insertText('');\n  }\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   */\n\n\n  formatText(formatType) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType); // When changing format, we should stop composition\n\n      $setCompositionKey(null);\n      return;\n    }\n\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n\n    const selectedTextNodesLength = selectedTextNodes.length;\n\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType); // When changing format, we should stop composition\n\n      $setCompositionKey(null);\n      return;\n    }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset; // In case selection started at the end of text node use next text node\n\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n\n    if (firstNode == null) {\n      return;\n    }\n\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize(); // Single node selected\n\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n\n      if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat); // Update selection only if starts/ends on text node\n\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n\n      this.format = firstNextFormat;\n      return;\n    } // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n\n\n    if (startOffset !== 0) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat); // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize()) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n\n      lastNode.setFormat(lastNextFormat);\n    } // Process all text nodes in between\n\n\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n\n      if (!textNode.isToken()) {\n        const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n        textNode.setFormat(nextFormat);\n      }\n    } // Update selection only if starts/ends on text node\n\n\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n\n    this.format = firstNextFormat | lastNextFormat;\n  }\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accomodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   * @param selectStart - whether or not to select the start after the insertion.\n   * @returns true if the nodes were inserted successfully, false otherwise.\n   */\n\n\n  insertNodes(nodes, selectStart) {\n    // If there is a range selected remove the text in it\n    if (!this.isCollapsed()) {\n      const selectionEnd = this.isBackward() ? this.anchor : this.focus;\n      const nextSibling = selectionEnd.getNode().getNextSibling();\n      const nextSiblingKey = nextSibling ? nextSibling.getKey() : null;\n      const prevSibling = selectionEnd.getNode().getPreviousSibling();\n      const prevSiblingKey = prevSibling ? prevSibling.getKey() : null;\n      this.removeText(); // If the selection has been moved to an adjacent inline element, create\n      // a temporary text node that we can insert the nodes after.\n\n      if (this.isCollapsed() && this.focus.type === 'element') {\n        let textNode;\n\n        if (this.focus.key === nextSiblingKey && this.focus.offset === 0) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertBefore(textNode);\n        } else if (this.focus.key === prevSiblingKey && this.focus.offset === this.focus.getNode().getChildrenSize()) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertAfter(textNode);\n        }\n\n        if (textNode) {\n          this.focus.set(textNode.__key, 0, 'text');\n          this.anchor.set(textNode.__key, 0, 'text');\n        }\n      }\n    }\n\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    const anchorNode = anchor.getNode();\n    let target = anchorNode;\n\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n      const placementNode = element.getChildAtIndex(anchorOffset - 1);\n\n      if (placementNode === null) {\n        target = element;\n      } else {\n        target = placementNode;\n      }\n    }\n\n    const siblings = []; // Get all remaining text node siblings in this element so we can\n    // append them after the last node we're inserting.\n\n    const nextSiblings = anchorNode.getNextSiblings();\n    const topLevelElement = $isRootOrShadowRoot(anchorNode) ? null : anchorNode.getTopLevelElementOrThrow();\n\n    if ($isTextNode(anchorNode)) {\n      const textContent = anchorNode.getTextContent();\n      const textContentLength = textContent.length;\n\n      if (anchorOffset === 0 && textContentLength !== 0) {\n        const prevSibling = anchorNode.getPreviousSibling();\n\n        if (prevSibling !== null) {\n          target = prevSibling;\n        } else {\n          target = anchorNode.getParentOrThrow();\n        }\n\n        siblings.push(anchorNode);\n      } else if (anchorOffset === textContentLength) {\n        target = anchorNode;\n      } else if (anchorNode.isToken()) {\n        // Do nothing if we're inside a token node\n        return false;\n      } else {\n        // If we started with a range selected grab the danglingText after the\n        // end of the selection and put it on our siblings array so we can\n        // append it after the last node we're inserting\n        let danglingText;\n        [target, danglingText] = anchorNode.splitText(anchorOffset);\n        siblings.push(danglingText);\n      }\n    }\n\n    const startingNode = target;\n    siblings.push(...nextSiblings);\n    const firstNode = nodes[0];\n    let didReplaceOrMerge = false;\n    let lastNode = null; // Time to insert the nodes!\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (!$isRootOrShadowRoot(target) && !$isDecoratorNode(target) && $isElementNode(node) && !node.isInline()) {\n        // -----\n        // Heuristics for the replacement or merging of elements\n        // -----\n        // If we have an incoming element node as the first node, then we'll need\n        // see if we can merge any descendant leaf nodes into our existing target.\n        // We can do this by finding the first descendant in our node and then we can\n        // pluck it and its parent (siblings included) out and insert them directly\n        // into our target. We only do this for the first node, as we are only\n        // interested in merging with the anchor, which is our target.\n        //\n        // If we apply either the replacement or merging heuristics, we need to be\n        // careful that we're not trying to insert a non-element node into a root node,\n        // so we check if the target's parent after this logic is the root node and if\n        // so we trigger an invariant to ensure this problem is caught in development\n        // and fixed accordingly.\n        if (node.is(firstNode)) {\n          if ($isElementNode(target) && target.isEmpty() && target.canReplaceWith(node)) {\n            target.replace(node);\n            target = node;\n            didReplaceOrMerge = true;\n            continue;\n          } // We may have a node tree where there are many levels, for example with\n          // lists and tables. So let's find the first descendant to try and merge\n          // with. So if we have the target:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //\n          // and we are trying to insert:\n          //\n          // ListNode (3)\n          //   ListItemNode (4)\n          //     Text (5)\n          //   ListItemNode (6)\n          //\n          // The result would be:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //   Text (5)\n          //\n\n\n          const firstDescendant = node.getFirstDescendant();\n\n          if ($isLeafNode(firstDescendant)) {\n            let element = firstDescendant.getParentOrThrow();\n\n            while (element.isInline()) {\n              element = element.getParentOrThrow();\n            }\n\n            const children = element.getChildren();\n            const childrenLength = children.length;\n\n            if ($isElementNode(target)) {\n              let firstChild = target.getFirstChild();\n\n              for (let s = 0; s < childrenLength; s++) {\n                const child = children[s];\n\n                if (firstChild === null) {\n                  target.append(child);\n                } else {\n                  firstChild.insertAfter(child);\n                }\n\n                firstChild = child;\n              }\n            } else {\n              for (let s = childrenLength - 1; s >= 0; s--) {\n                target.insertAfter(children[s]);\n              }\n\n              target = target.getParentOrThrow();\n            }\n\n            lastNode = children[childrenLength - 1];\n            element.remove();\n            didReplaceOrMerge = true;\n\n            if (element.is(node)) {\n              continue;\n            }\n          }\n        }\n\n        if ($isTextNode(target)) {\n          if (topLevelElement === null) {\n            {\n              throw Error(`insertNode: topLevelElement is root node`);\n            }\n          }\n\n          target = topLevelElement;\n        }\n      } else if (didReplaceOrMerge && !$isElementNode(node) && !$isDecoratorNode(node) && $isRootOrShadowRoot(target.getParent())) {\n        {\n          throw Error(`insertNodes: cannot insert a non-element into a root node`);\n        }\n      }\n\n      didReplaceOrMerge = false;\n\n      if ($isElementNode(target) && !target.isInline()) {\n        lastNode = node;\n\n        if ($isDecoratorNode(node) && !node.isInline()) {\n          target = target.insertAfter(node, false);\n        } else if (!$isElementNode(node)) {\n          const firstChild = target.getFirstChild();\n\n          if (firstChild !== null) {\n            firstChild.insertBefore(node);\n          } else {\n            target.append(node);\n          }\n\n          target = node;\n        } else {\n          if (!node.canBeEmpty() && node.isEmpty()) {\n            continue;\n          }\n\n          if ($isRootNode(target)) {\n            const placementNode = target.getChildAtIndex(anchorOffset);\n\n            if (placementNode !== null) {\n              placementNode.insertBefore(node);\n            } else {\n              target.append(node);\n            }\n\n            target = node;\n          } else if (node.isInline()) {\n            target.append(node);\n            target = node;\n          } else {\n            target = target.insertAfter(node, false);\n          }\n        }\n      } else if (!$isElementNode(node) || $isElementNode(node) && node.isInline() || $isDecoratorNode(target) && !target.isInline()) {\n        lastNode = node; // when pasting top level node in the middle of paragraph\n        // we need to split paragraph instead of placing it inline\n\n        if ($isRangeSelection(this) && $isDecoratorNode(node) && ($isElementNode(target) || $isTextNode(target)) && !node.isInline()) {\n          let splitNode;\n          let splitOffset;\n\n          if ($isTextNode(target)) {\n            splitNode = target.getParentOrThrow();\n            const [textNode] = target.splitText(anchorOffset);\n            splitOffset = textNode.getIndexWithinParent() + 1;\n          } else {\n            splitNode = target;\n            splitOffset = anchorOffset;\n          }\n\n          const [, rightTree] = $splitNode(splitNode, splitOffset);\n          target = rightTree.insertBefore(node);\n        } else {\n          target = target.insertAfter(node, false);\n        }\n      } else {\n        const nextTarget = target.getParentOrThrow(); // if we're inserting an Element after a LineBreak, we want to move the target to the parent\n        // and remove the LineBreak so we don't have empty space.\n\n        if ($isLineBreakNode(target)) {\n          target.remove();\n        }\n\n        target = nextTarget; // Re-try again with the target being the parent\n\n        i--;\n        continue;\n      }\n    }\n\n    if (selectStart) {\n      // Handle moving selection to start for all nodes\n      if ($isTextNode(startingNode)) {\n        startingNode.select();\n      } else {\n        const prevSibling = target.getPreviousSibling();\n\n        if ($isTextNode(prevSibling)) {\n          prevSibling.select();\n        } else {\n          const index = target.getIndexWithinParent();\n          target.getParentOrThrow().select(index, index);\n        }\n      }\n    }\n\n    if ($isElementNode(target)) {\n      // If the last node to be inserted was a text node,\n      // then we should attempt to move selection to that.\n      const lastChild = $isTextNode(lastNode) ? lastNode : $isElementNode(lastNode) && lastNode.isInline() ? lastNode.getLastDescendant() : target.getLastDescendant();\n\n      if (!selectStart) {\n        // Handle moving selection to end for elements\n        if (lastChild === null) {\n          target.select();\n        } else if ($isTextNode(lastChild)) {\n          if (lastChild.getTextContent() === '') {\n            lastChild.selectPrevious();\n          } else {\n            lastChild.select();\n          }\n        } else {\n          lastChild.selectNext();\n        }\n      }\n\n      if (siblings.length !== 0) {\n        const originalTarget = target;\n\n        for (let i = siblings.length - 1; i >= 0; i--) {\n          const sibling = siblings[i];\n          const prevParent = sibling.getParentOrThrow();\n\n          if ($isElementNode(target) && !$isBlockElementNode(sibling) && !($isDecoratorNode(sibling) && ( // Note: We are only looking for decorators that are inline and not isolated.\n          !sibling.isInline() || sibling.isIsolated()))) {\n            if (originalTarget === target) {\n              target.append(sibling);\n            } else {\n              target.insertBefore(sibling);\n            }\n\n            target = sibling;\n          } else if (!$isElementNode(target) && !$isBlockElementNode(sibling)) {\n            target.insertBefore(sibling);\n            target = sibling;\n          } else {\n            if ($isElementNode(sibling) && !sibling.canInsertAfter(target)) {\n              // @ts-ignore The clone method does exist on the constructor.\n              const prevParentClone = prevParent.constructor.clone(prevParent);\n\n              if (!$isElementNode(prevParentClone)) {\n                {\n                  throw Error(`insertNodes: cloned parent clone is not an element`);\n                }\n              }\n\n              prevParentClone.append(sibling);\n              target.insertAfter(prevParentClone);\n            } else {\n              target.insertAfter(sibling);\n            }\n          } // Check if the prev parent is empty, as it might need\n          // removing.\n\n\n          if (prevParent.isEmpty() && !prevParent.canBeEmpty()) {\n            prevParent.remove();\n          }\n        }\n      }\n    } else if (!selectStart) {\n      // Handle moving selection to end for other nodes\n      if ($isTextNode(target)) {\n        target.select();\n      } else {\n        const element = target.getParentOrThrow();\n        const index = target.getIndexWithinParent() + 1;\n        element.select(index, index);\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   */\n\n\n  insertParagraph() {\n    if (!this.isCollapsed()) {\n      this.removeText();\n    }\n\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    let currentElement;\n    let nodesToMove = [];\n    let siblingsToMove = [];\n\n    if (anchor.type === 'text') {\n      const anchorNode = anchor.getNode();\n      nodesToMove = anchorNode.getNextSiblings().reverse();\n      currentElement = anchorNode.getParentOrThrow();\n      const isInline = currentElement.isInline();\n      const textContentLength = isInline ? currentElement.getTextContentSize() : anchorNode.getTextContentSize();\n\n      if (anchorOffset === 0) {\n        nodesToMove.push(anchorNode);\n      } else {\n        if (isInline) {\n          // For inline nodes, we want to move all the siblings to the new paragraph\n          // if selection is at the end, we just move the siblings. Otherwise, we also\n          // split the text node and add that and it's siblings below.\n          siblingsToMove = currentElement.getNextSiblings();\n        }\n\n        if (anchorOffset !== textContentLength) {\n          if (!isInline || anchorOffset !== anchorNode.getTextContentSize()) {\n            const [, splitNode] = anchorNode.splitText(anchorOffset);\n            nodesToMove.push(splitNode);\n          }\n        }\n      }\n    } else {\n      currentElement = anchor.getNode();\n\n      if ($isRootOrShadowRoot(currentElement)) {\n        const paragraph = $createParagraphNode();\n        const child = currentElement.getChildAtIndex(anchorOffset);\n        paragraph.select();\n\n        if (child !== null) {\n          child.insertBefore(paragraph, false);\n        } else {\n          currentElement.append(paragraph);\n        }\n\n        return;\n      }\n\n      nodesToMove = currentElement.getChildren().slice(anchorOffset).reverse();\n    }\n\n    const nodesToMoveLength = nodesToMove.length;\n\n    if (anchorOffset === 0 && nodesToMoveLength > 0 && currentElement.isInline()) {\n      const parent = currentElement.getParentOrThrow();\n      const newElement = parent.insertNewAfter(this, false);\n\n      if ($isElementNode(newElement)) {\n        const children = parent.getChildren();\n\n        for (let i = 0; i < children.length; i++) {\n          newElement.append(children[i]);\n        }\n      }\n\n      return;\n    }\n\n    const newElement = currentElement.insertNewAfter(this, false);\n\n    if (newElement === null) {\n      // Handle as a line break insertion\n      this.insertLineBreak();\n    } else if ($isElementNode(newElement)) {\n      // If we're at the beginning of the current element, move the new element to be before the current element\n      const currentElementFirstChild = currentElement.getFirstChild();\n      const isBeginning = anchorOffset === 0 && (currentElement.is(anchor.getNode()) || currentElementFirstChild && currentElementFirstChild.is(anchor.getNode()));\n\n      if (isBeginning && nodesToMoveLength > 0) {\n        currentElement.insertBefore(newElement);\n        return;\n      }\n\n      let firstChild = null;\n      const siblingsToMoveLength = siblingsToMove.length;\n      const parent = newElement.getParentOrThrow(); // For inline elements, we append the siblings to the parent.\n\n      if (siblingsToMoveLength > 0) {\n        for (let i = 0; i < siblingsToMoveLength; i++) {\n          const siblingToMove = siblingsToMove[i];\n          parent.append(siblingToMove);\n        }\n      }\n\n      if (nodesToMoveLength !== 0) {\n        for (let i = 0; i < nodesToMoveLength; i++) {\n          const nodeToMove = nodesToMove[i];\n\n          if (firstChild === null) {\n            newElement.append(nodeToMove);\n          } else {\n            firstChild.insertBefore(nodeToMove);\n          }\n\n          firstChild = nodeToMove;\n        }\n      }\n\n      if (!newElement.canBeEmpty() && newElement.getChildrenSize() === 0) {\n        newElement.selectPrevious();\n        newElement.remove();\n      } else {\n        newElement.selectStart();\n      }\n    }\n  }\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   *\n   * @param selectStart whether or not to select the start of the insertion range after the operation completes.\n   */\n\n\n  insertLineBreak(selectStart) {\n    const lineBreakNode = $createLineBreakNode();\n    const anchor = this.anchor;\n\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n\n      if ($isRootNode(element)) {\n        this.insertParagraph();\n      }\n    }\n\n    if (selectStart) {\n      this.insertNodes([lineBreakNode], true);\n    } else {\n      if (this.insertNodes([lineBreakNode])) {\n        lineBreakNode.selectNext(0, 0);\n      }\n    }\n  }\n  /**\n   * Returns the character-based offsets of the Selection, accounting for non-text Points\n   * by using the children size or text content.\n   *\n   * @returns the character offsets for the Selection\n   */\n\n\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n\n\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n\n      return [firstNode];\n    }\n\n    const isBefore = anchor.isBefore(focus);\n\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n\n    return selectedNodes;\n  }\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n\n\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move'; // Handle the selection movement around decorators.\n\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n\n          if (!isBackward) {\n            offset++;\n          }\n        }\n\n        focus.set(elementKey, offset, 'element');\n\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n\n        return;\n      }\n    }\n\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n\n    if (!domSelection) {\n      return;\n    }\n\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement; // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    } // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n\n\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity); // Guard against no ranges\n\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0); // Apply the DOM selection to our Lexical selection.\n\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        } // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n\n\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const focus = this.focus;\n      let anchorNode = anchor.getNode();\n\n      if (!isBackward && ( // Delete forward handle case\n      anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n        const parent = anchorNode.getParent();\n        const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n\n        if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n          return;\n        }\n      } // Handle the deletion around decorators.\n\n\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n\n        return;\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n\n      this.modify('extend', isBackward, 'character');\n\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n\n    this.removeText();\n\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      if (this.anchor.type === 'text') {\n        this.modify('extend', isBackward, 'lineboundary');\n      } // If selection is extended to cover text edge then extend it one character more\n      // to delete its parent element. Otherwise text content will be deleted but empty\n      // parent node will remain\n\n\n      const endPoint = isBackward ? this.focus : this.anchor;\n\n      if (endPoint.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n    }\n\n    this.removeText();\n  }\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      this.modify('extend', isBackward, 'word');\n    }\n\n    this.removeText();\n  }\n\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\n\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n\n  if (point.type === 'text') {\n    return offset;\n  }\n\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\n\nfunction getCharacterOffsets(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\n\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\n\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\n\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\n\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n\n      break;\n    }\n  }\n\n  const nextTextContent = split.join('').trim();\n\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\n\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\n\nfunction internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode; // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false; // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length; // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n\n    if (childDOM === editor._blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (editor._blockCursorElement !== null) {\n      resolvedOffset--;\n    }\n\n    resolvedNode = getNodeFromDOM(childDOM);\n\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = getNodeFromDOM(dom); // Ensure resolvedElement is actually a element.\n\n      if (resolvedElement === null) {\n        return null;\n      }\n\n      if ($isElementNode(resolvedElement)) {\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n\n          if (descendant === null) {\n            resolvedElement = child;\n            resolvedOffset = 0;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n        }\n\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent(); // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = getNodeFromDOM(dom);\n  }\n\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\n\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize(); // @ts-expect-error: intentional\n\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0; // @ts-expect-error: intentional\n\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\n\nfunction normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus); // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n\n    const editor = getActiveEditor();\n\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\n\nfunction internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n\n  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n\n  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = getNodeFromDOM(anchorDOM);\n    const focusNode = getNodeFromDOM(focusDOM); // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  } // Handle normalization of selection when it is at the boundaries.\n\n\n  normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\n\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n} // This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction DEPRECATED_$createGridSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new GridSelection('root', anchor, focus);\n}\nfunction internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n\n  if ($isNodeSelection(lastSelection) || DEPRECATED_$isGridSelection(lastSelection)) {\n    return lastSelection.clone();\n  }\n\n  return internalCreateRangeSelection(lastSelection, domSelection, editor);\n}\nfunction internalCreateRangeSelection(lastSelection, domSelection, editor) {\n  const windowObj = editor._window;\n\n  if (windowObj === null) {\n    return null;\n  } // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n\n  const windowEvent = windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcesssingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  } // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n\n\n  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n\n  const parentKey = parentNode.__key; // Single node. We shift selection but never redimension it\n\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element'); // The new selection might point to text nodes, try to resolve them\n\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  } // The new selection might point to text nodes, try to resolve them\n\n\n  $updateSelectionResolveTextNodes(selection);\n}\n\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n\n    return;\n  }\n\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\n\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement; // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n\n    return;\n  }\n\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  } // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n\n\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  } // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n\n\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n\n    if (anchor.type !== 'element') {\n      return;\n    }\n  } // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n\n\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  } catch (error) {// If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n  }\n\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n\n    if (selectionTarget !== null) {\n      let selectionRect;\n\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes, selectStart) {\n  let selection = $getSelection() || $getPreviousSelection();\n\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n\n  return selection.insertNodes(nodes, selectStart);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n\n  if (selection === null) {\n    return '';\n  }\n\n  return selection.getTextContent();\n}\nfunction DEPRECATED_$computeGridMap(grid, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n\n  function write(startRow, startColumn, cell) {\n    const value = {\n      cell,\n      startColumn,\n      startRow\n    };\n    const rowSpan = cell.__rowSpan;\n    const colSpan = cell.__colSpan;\n\n    for (let i = 0; i < rowSpan; i++) {\n      if (tableMap[startRow + i] === undefined) {\n        tableMap[startRow + i] = [];\n      }\n\n      for (let j = 0; j < colSpan; j++) {\n        tableMap[startRow + i][startColumn + j] = value;\n      }\n    }\n\n    if (cellA.is(cell)) {\n      cellAValue = value;\n    }\n\n    if (cellB.is(cell)) {\n      cellBValue = value;\n    }\n  }\n\n  function isEmpty(row, column) {\n    return tableMap[row] === undefined || tableMap[row][column] === undefined;\n  }\n\n  const gridChildren = grid.getChildren();\n\n  for (let i = 0; i < gridChildren.length; i++) {\n    const row = gridChildren[i];\n\n    if (!DEPRECATED_$isGridRowNode(row)) {\n      throw Error(`Expected GridNode children to be GridRowNode`);\n    }\n\n    const rowChildren = row.getChildren();\n    let j = 0;\n\n    for (const cell of rowChildren) {\n      if (!DEPRECATED_$isGridCellNode(cell)) {\n        throw Error(`Expected GridRowNode children to be GridCellNode`);\n      }\n\n      while (!isEmpty(i, j)) {\n        j++;\n      }\n\n      write(i, j, cell);\n      j += cell.__colSpan;\n    }\n  }\n\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Grid`);\n  }\n\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Grid`);\n  }\n\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction DEPRECATED_$getNodeTriplet(source) {\n  let cell;\n\n  if (source instanceof DEPRECATED_GridCellNode) {\n    cell = source;\n  } else if (source instanceof LexicalNode) {\n    const cell_ = $findMatchingParent(source, DEPRECATED_$isGridCellNode);\n\n    if (!DEPRECATED_$isGridCellNode(cell_)) {\n      throw Error(`Expected to find a parent GridCellNode`);\n    }\n\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), DEPRECATED_$isGridCellNode);\n\n    if (!DEPRECATED_$isGridCellNode(cell_)) {\n      throw Error(`Expected to find a parent GridCellNode`);\n    }\n\n    cell = cell_;\n  }\n\n  const row = cell.getParent();\n\n  if (!DEPRECATED_$isGridRowNode(row)) {\n    throw Error(`Expected GridCellNode to have a parent GridRowNode`);\n  }\n\n  const grid = row.getParent();\n\n  if (!DEPRECATED_$isGridNode(grid)) {\n    throw Error(`Expected GridRowNode to have a parent GridNode`);\n  }\n\n  return [cell, row, grid];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\n    }\n  }\n\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\n    }\n  }\n\n  return activeEditor;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n\n  const transformsArrLength = transformsArr.length;\n\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\n\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined && // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\n\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\n\n\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n\n        dirtyLeaves.add(nodeKey);\n      }\n\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size; // We want to prioritize node transforms over element transforms\n\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    } // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n\n\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n\n      const node = nodeMap.get(nodeKey);\n\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\n\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\n\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n\n  const nodeClass = registeredNode.klass;\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n\n  return node;\n}\n\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n\n    if (updateFn) {\n      updateFn();\n    } // Make the editorState immutable\n\n\n    editorState._readOnly = true;\n\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n\n  return editorState;\n} // This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = null;\n\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\n\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\n\nfunction commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n\n  if (pendingEditorState === null) {\n    return;\n  } // ======\n  // Reconciliation has started.\n  // ======\n\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false; // We don't want updates to sync block the reconciliation.\n\n    editor._updating = true;\n\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      } // Reset editor and restore incoming editor state to the DOM\n\n\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n\n      Object.freeze(pendingSelection);\n    }\n  }\n\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n\n    editor._cloneNotNeeded.clear();\n\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n\n  $garbageCollectDetachedDecorators(editor, pendingEditorState); // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window); // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n\n  if (editor._editable && // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n\n\n  const pendingDecorators = editor._pendingDecorators;\n\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  } // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n\n\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  triggerEnqueuedUpdates(editor);\n}\n\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\n\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags\n      });\n    }\n  }\n}\n\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n\n  const editors = getEditorsToPropagate(editor);\n\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      beginUpdate(editor, updateFn, options);\n    }\n  }\n}\n\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\n\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false; // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      let tag;\n\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        tag = options.tag;\n\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n\n        if (tag) {\n          editor._updateTags.add(tag);\n        }\n      }\n\n      nextUpdateFn();\n    }\n  }\n\n  return skipTransforms;\n}\n\nfunction beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n  let discrete = false;\n\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection != null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = internalCreateSelection(editor);\n      }\n    }\n\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n\n    const endingCompositionKey = editor._compositionKey;\n\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n\n    const pendingSelection = pendingEditorState._selection;\n\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    } // Restore existing editor state to the DOM\n\n\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n\n    editor._cloneNotNeeded.clear();\n\n    editor._dirtyLeaves = new Set();\n\n    editor._dirtyElements.clear();\n\n    commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);\n\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\n\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\n\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n  }\n\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n\n  isIsolated() {\n    return false;\n  }\n\n  isInline() {\n    return true;\n  }\n\n  isKeyboardSelectable() {\n    return true;\n  }\n\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__indent = 0;\n    this.__dir = null;\n  }\n\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n\n    return children;\n  }\n\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n\n    return children;\n  }\n\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n\n      child = child.getNextSibling();\n    }\n\n    return textNodes;\n  }\n\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getFirstChild();\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      break;\n    }\n\n    return node;\n  }\n\n  getLastDescendant() {\n    let node = this.getLastChild();\n\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getLastChild();\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      break;\n    }\n\n    return node;\n  }\n\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length; // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n\n    return firstChild;\n  }\n\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n\n    return lastChild;\n  }\n\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n\n        node = node.getNextSibling();\n        i++;\n      }\n\n      return null;\n    }\n\n    node = this.getLastChild();\n    i = size - 1;\n\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n\n      node = node.getPreviousSibling();\n      i--;\n    }\n\n    return null;\n  }\n\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n\n    return textContent;\n  }\n\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n\n    return textContentSize;\n  }\n\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n\n    return false;\n  } // Mutators\n\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n\n    const key = this.__key;\n\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n\n    return selection;\n  }\n\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n\n    if ($isElementNode(firstNode) || $isTextNode(firstNode)) {\n      return firstNode.select(0, 0);\n    } // Decorator or LineBreak\n\n\n    if (firstNode !== null) {\n      return firstNode.selectPrevious();\n    }\n\n    return this.select(0, 0);\n  }\n\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      return lastNode.select();\n    } // Decorator or LineBreak\n\n\n    if (lastNode !== null) {\n      return lastNode.selectNext();\n    }\n\n    return this.select();\n  }\n\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n\n    let prevNode = nodeBeforeRange;\n\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n\n      const writableNodeToInsert = nodeToInsert.getWritable();\n\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      } // Set child parent to self\n\n\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n\n    writableSelf.__size = newSize; // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        } // Cleanup if node can't be empty\n\n\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n\n    return writableSelf;\n  } // JSON serialization\n\n\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'element',\n      version: 1\n    };\n  } // These are intended to be extends for specific element heuristics.\n\n\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n\n\n  collapseAtStart(selection) {\n    return false;\n  }\n\n  excludeFromCopy(destination) {\n    return false;\n  } // TODO 0.10 deprecate\n\n\n  canExtractContents() {\n    return true;\n  }\n\n  canReplaceWith(replacement) {\n    return true;\n  }\n\n  canInsertAfter(node) {\n    return true;\n  }\n\n  canBeEmpty() {\n    return true;\n  }\n\n  canInsertTextBefore() {\n    return true;\n  }\n\n  canInsertTextAfter() {\n    return true;\n  }\n\n  isInline() {\n    return false;\n  } // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n\n\n  isShadowRoot() {\n    return false;\n  }\n\n  canMergeWith(node) {\n    return false;\n  }\n\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\n\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n\n  while (node) {\n    const nodeKey = node.__key;\n\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n\n    node = node.getParent();\n  }\n\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n  static getType() {\n    return 'root';\n  }\n\n  static clone() {\n    return new RootNode();\n  }\n\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n\n  getTextContent() {\n    const cachedText = this.__cachedText;\n\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n\n    return super.getTextContent();\n  }\n\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  } // View\n\n\n  updateDOM(prevNode, dom) {\n    return false;\n  } // Mutate\n\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n\n    return super.append(...nodesToAppend);\n  }\n\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    const node = $getRoot();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'root',\n      version: 1\n    };\n  }\n\n  collapseAtStart() {\n    return true;\n  }\n\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n\n  const pendingSelection = editorState._selection; // Check if we need to update because of changes in selection\n\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\n\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n\n  const serializedChildren = serializedNode.children;\n\n  if ($isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n\n    const children = node.getChildren();\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  } // @ts-expect-error\n\n\n  return serializedNode;\n}\n\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n\n  read(callbackFn) {\n    return readEditorState(this, callbackFn);\n  }\n\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n\n  toJSON() {\n    return readEditorState(this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  } // View\n\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element && this.isEmpty()) {\n      element.append(document.createElement('br'));\n    }\n\n    if (element) {\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n\n      if (direction) {\n        element.dir = direction;\n      }\n\n      const indent = this.getIndent();\n\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML, but\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\n        element.style.textIndent = `${indent * 20}px`;\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createParagraphNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'paragraph',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter(_, restoreSelection) {\n    const newElement = $createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart() {\n    const children = this.getChildren(); // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n\n      const prevSibling = this.getPreviousSibling();\n\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nfunction convertParagraphElement(element) {\n  const node = $createParagraphNode();\n\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    const indent = parseInt(element.style.textIndent, 10) / 20;\n\n    if (indent > 0) {\n      node.setIndent(indent);\n    }\n  }\n\n  return {\n    node\n  };\n}\n\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n\n  editor._cloneNotNeeded.clear();\n\n  editor._dirtyLeaves = new Set();\n\n  editor._dirtyElements.clear();\n\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  } // Remove all the DOM nodes from the root element\n\n\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\n\nfunction initializeConversionCache(nodes) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM != null ? node.klass.importDOM.bind(node.klass) : null;\n\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n\n    handledConversions.add(importDOM);\n    const map = importDOM();\n\n    if (map !== null) {\n      Object.keys(map).forEach(key => {\n        let currentCache = conversionCache.get(key);\n\n        if (currentCache === undefined) {\n          currentCache = [];\n          conversionCache.set(key, currentCache);\n        }\n\n        currentCache.push(map[key]);\n      });\n    }\n  });\n  return conversionCache;\n}\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\n\n\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ...(config.nodes || [])];\n  const onError = config.onError;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replacementClass = null;\n      let replacementKlass = null;\n\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replacementClass = options.with;\n        replacementKlass = options.withKlass ? options.withKlass : null;\n      } // Ensure custom nodes implement required methods.\n\n\n      {\n        const name = klass.name;\n\n        if (name !== 'RootNode') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n\n          if ( // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') && // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n\n          if (proto instanceof DecoratorNode) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n\n          if ( // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n\n          if ( // eslint-disable-next-line no-prototype-builtins\n          !proto.hasOwnProperty('exportJSON')) {\n            console.warn(`${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n\n      registeredNodes.set(type, {\n        klass,\n        replace: replacementClass,\n        replaceWithKlass: replacementKlass,\n        transforms\n      });\n    }\n  }\n\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes), isEditable);\n\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n\n  return editor;\n}\nclass LexicalEditor {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor; // The root element associated with this editor\n\n    this._rootElement = null; // The current editor state\n\n    this._editorState = editorState; // Handling of drafts and updates\n\n    this._pendingEditorState = null; // Used to help co-ordinate selection and events\n\n    this._compositionKey = null;\n    this._deferred = []; // Used during reconciliation\n\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false; // Listeners\n\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    }; // Commands\n\n    this._commands = new Map(); // Editor configuration for theme/context.\n\n    this._config = config; // Mapping of types to their nodes\n\n    this._nodes = nodes; // React node decorators for portals\n\n    this._decorators = {};\n    this._pendingDecorators = null; // Used to optimize reconciliation\n\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set(); // Handling of DOM mutations\n\n    this._observer = null; // Used for identifying owning editors\n\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n\n\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched, subject to priority. Listeners that run at a higher priority can \"intercept\"\n   * commands and prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners registered at the same priority level will run deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n\n    const commandsMap = this._commands;\n\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n\n    const listenersInPriorityOrder = commandsMap.get(command);\n\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerMutationListener(klass, listener) {\n    const registeredNode = this._nodes.get(klass.getType());\n\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klass);\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n  /** @internal */\n\n\n  registerNodeTransformToKlass(klass, listener) {\n    const type = klass.getType();\n\n    const registeredNode = this._nodes.get(type);\n\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n\n    const transforms = registeredNode.transforms;\n    transforms.add(listener);\n    return registeredNode;\n  }\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n\n    markAllNodesAsDirty(this, klass.getType());\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n\n\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n\n\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload.\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n\n\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n\n\n  getDecorators() {\n    return this._decorators;\n  }\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n\n\n  getRootElement() {\n    return this._rootElement;\n  }\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n\n\n  getKey() {\n    return this._key;\n  }\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n\n\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n\n        this._updateTags.add('history-merge');\n\n        commitPendingUpdates(this); // TODO: remove this flag once we no longer use UEv2 internally\n\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n      } else {\n        // If content editable is unmounted we'll reset editor state back to original\n        // (or pending) editor state since there will be no reconciliation\n        this._editorState = pendingEditorState;\n        this._pendingEditorState = null;\n        this._window = null;\n      }\n\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n\n\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n\n\n  getEditorState() {\n    return this._editorState;\n  }\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n\n\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n\n      commitPendingUpdates(this);\n    }\n\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n\n    this._dirtyElements.set('root', false);\n\n    this._compositionKey = null;\n\n    if (tag != null) {\n      tags.add(tag);\n    }\n\n    commitPendingUpdates(this);\n  }\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserliazation from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n\n\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n\n\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n\n\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n\n          if (callbackFn) {\n            callbackFn();\n          }\n        },\n        tag: 'focus'\n      }); // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n  /**\n   * Removes focus from the editor.\n   */\n\n\n  blur() {\n    const rootElement = this._rootElement;\n\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n\n    const domSelection = getDOMSelection(this._window);\n\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n\n\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n\n\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n\n\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass DEPRECATED_GridCellNode extends ElementNode {\n  /** @internal */\n  constructor(colSpan, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      colSpan: this.__colSpan,\n      rowSpan: this.__rowSpan\n    };\n  }\n\n  getColSpan() {\n    return this.__colSpan;\n  }\n\n  setColSpan(colSpan) {\n    this.getWritable().__colSpan = colSpan;\n    return this;\n  }\n\n  getRowSpan() {\n    return this.__rowSpan;\n  }\n\n  setRowSpan(rowSpan) {\n    this.getWritable().__rowSpan = rowSpan;\n    return this;\n  }\n\n}\nfunction DEPRECATED_$isGridCellNode(node) {\n  return node instanceof DEPRECATED_GridCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridNode extends ElementNode {}\nfunction DEPRECATED_$isGridNode(node) {\n  return node instanceof DEPRECATED_GridNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridRowNode extends ElementNode {}\nfunction DEPRECATED_$isGridRowNode(node) {\n  return node instanceof DEPRECATED_GridRowNode;\n}\n\nexports.$addUpdateTag = $addUpdateTag;\nexports.$applyNodeReplacement = $applyNodeReplacement;\nexports.$copyNode = $copyNode;\nexports.$createLineBreakNode = $createLineBreakNode;\nexports.$createNodeSelection = $createNodeSelection;\nexports.$createParagraphNode = $createParagraphNode;\nexports.$createRangeSelection = $createRangeSelection;\nexports.$createTabNode = $createTabNode;\nexports.$createTextNode = $createTextNode;\nexports.$getAdjacentNode = $getAdjacentNode;\nexports.$getNearestNodeFromDOMNode = $getNearestNodeFromDOMNode;\nexports.$getNearestRootOrShadowRoot = $getNearestRootOrShadowRoot;\nexports.$getNodeByKey = $getNodeByKey;\nexports.$getPreviousSelection = $getPreviousSelection;\nexports.$getRoot = $getRoot;\nexports.$getSelection = $getSelection;\nexports.$getTextContent = $getTextContent;\nexports.$hasAncestor = $hasAncestor;\nexports.$hasUpdateTag = $hasUpdateTag;\nexports.$insertNodes = $insertNodes;\nexports.$isBlockElementNode = $isBlockElementNode;\nexports.$isDecoratorNode = $isDecoratorNode;\nexports.$isElementNode = $isElementNode;\nexports.$isInlineElementOrDecoratorNode = $isInlineElementOrDecoratorNode;\nexports.$isLeafNode = $isLeafNode;\nexports.$isLineBreakNode = $isLineBreakNode;\nexports.$isNodeSelection = $isNodeSelection;\nexports.$isParagraphNode = $isParagraphNode;\nexports.$isRangeSelection = $isRangeSelection;\nexports.$isRootNode = $isRootNode;\nexports.$isRootOrShadowRoot = $isRootOrShadowRoot;\nexports.$isTabNode = $isTabNode;\nexports.$isTextNode = $isTextNode;\nexports.$nodesOfType = $nodesOfType;\nexports.$normalizeSelection__EXPERIMENTAL = $normalizeSelection;\nexports.$parseSerializedNode = $parseSerializedNode;\nexports.$setCompositionKey = $setCompositionKey;\nexports.$setSelection = $setSelection;\nexports.$splitNode = $splitNode;\nexports.BLUR_COMMAND = BLUR_COMMAND;\nexports.CAN_REDO_COMMAND = CAN_REDO_COMMAND;\nexports.CAN_UNDO_COMMAND = CAN_UNDO_COMMAND;\nexports.CLEAR_EDITOR_COMMAND = CLEAR_EDITOR_COMMAND;\nexports.CLEAR_HISTORY_COMMAND = CLEAR_HISTORY_COMMAND;\nexports.CLICK_COMMAND = CLICK_COMMAND;\nexports.COMMAND_PRIORITY_CRITICAL = COMMAND_PRIORITY_CRITICAL;\nexports.COMMAND_PRIORITY_EDITOR = COMMAND_PRIORITY_EDITOR;\nexports.COMMAND_PRIORITY_HIGH = COMMAND_PRIORITY_HIGH;\nexports.COMMAND_PRIORITY_LOW = COMMAND_PRIORITY_LOW;\nexports.COMMAND_PRIORITY_NORMAL = COMMAND_PRIORITY_NORMAL;\nexports.CONTROLLED_TEXT_INSERTION_COMMAND = CONTROLLED_TEXT_INSERTION_COMMAND;\nexports.COPY_COMMAND = COPY_COMMAND;\nexports.CUT_COMMAND = CUT_COMMAND;\nexports.DELETE_CHARACTER_COMMAND = DELETE_CHARACTER_COMMAND;\nexports.DELETE_LINE_COMMAND = DELETE_LINE_COMMAND;\nexports.DELETE_WORD_COMMAND = DELETE_WORD_COMMAND;\nexports.DEPRECATED_$computeGridMap = DEPRECATED_$computeGridMap;\nexports.DEPRECATED_$createGridSelection = DEPRECATED_$createGridSelection;\nexports.DEPRECATED_$getNodeTriplet = DEPRECATED_$getNodeTriplet;\nexports.DEPRECATED_$isGridCellNode = DEPRECATED_$isGridCellNode;\nexports.DEPRECATED_$isGridNode = DEPRECATED_$isGridNode;\nexports.DEPRECATED_$isGridRowNode = DEPRECATED_$isGridRowNode;\nexports.DEPRECATED_$isGridSelection = DEPRECATED_$isGridSelection;\nexports.DEPRECATED_GridCellNode = DEPRECATED_GridCellNode;\nexports.DEPRECATED_GridNode = DEPRECATED_GridNode;\nexports.DEPRECATED_GridRowNode = DEPRECATED_GridRowNode;\nexports.DRAGEND_COMMAND = DRAGEND_COMMAND;\nexports.DRAGOVER_COMMAND = DRAGOVER_COMMAND;\nexports.DRAGSTART_COMMAND = DRAGSTART_COMMAND;\nexports.DROP_COMMAND = DROP_COMMAND;\nexports.DecoratorNode = DecoratorNode;\nexports.ElementNode = ElementNode;\nexports.FOCUS_COMMAND = FOCUS_COMMAND;\nexports.FORMAT_ELEMENT_COMMAND = FORMAT_ELEMENT_COMMAND;\nexports.FORMAT_TEXT_COMMAND = FORMAT_TEXT_COMMAND;\nexports.INDENT_CONTENT_COMMAND = INDENT_CONTENT_COMMAND;\nexports.INSERT_LINE_BREAK_COMMAND = INSERT_LINE_BREAK_COMMAND;\nexports.INSERT_PARAGRAPH_COMMAND = INSERT_PARAGRAPH_COMMAND;\nexports.INSERT_TAB_COMMAND = INSERT_TAB_COMMAND;\nexports.KEY_ARROW_DOWN_COMMAND = KEY_ARROW_DOWN_COMMAND;\nexports.KEY_ARROW_LEFT_COMMAND = KEY_ARROW_LEFT_COMMAND;\nexports.KEY_ARROW_RIGHT_COMMAND = KEY_ARROW_RIGHT_COMMAND;\nexports.KEY_ARROW_UP_COMMAND = KEY_ARROW_UP_COMMAND;\nexports.KEY_BACKSPACE_COMMAND = KEY_BACKSPACE_COMMAND;\nexports.KEY_DELETE_COMMAND = KEY_DELETE_COMMAND;\nexports.KEY_DOWN_COMMAND = KEY_DOWN_COMMAND;\nexports.KEY_ENTER_COMMAND = KEY_ENTER_COMMAND;\nexports.KEY_ESCAPE_COMMAND = KEY_ESCAPE_COMMAND;\nexports.KEY_MODIFIER_COMMAND = KEY_MODIFIER_COMMAND;\nexports.KEY_SPACE_COMMAND = KEY_SPACE_COMMAND;\nexports.KEY_TAB_COMMAND = KEY_TAB_COMMAND;\nexports.LineBreakNode = LineBreakNode;\nexports.MOVE_TO_END = MOVE_TO_END;\nexports.MOVE_TO_START = MOVE_TO_START;\nexports.OUTDENT_CONTENT_COMMAND = OUTDENT_CONTENT_COMMAND;\nexports.PASTE_COMMAND = PASTE_COMMAND;\nexports.ParagraphNode = ParagraphNode;\nexports.REDO_COMMAND = REDO_COMMAND;\nexports.REMOVE_TEXT_COMMAND = REMOVE_TEXT_COMMAND;\nexports.RootNode = RootNode;\nexports.SELECTION_CHANGE_COMMAND = SELECTION_CHANGE_COMMAND;\nexports.TabNode = TabNode;\nexports.TextNode = TextNode;\nexports.UNDO_COMMAND = UNDO_COMMAND;\nexports.createCommand = createCommand;\nexports.createEditor = createEditor;\nexports.getNearestEditorFromDOMNode = getNearestEditorFromDOMNode;\nexports.isSelectionCapturedInDecoratorInput = isSelectionCapturedInDecoratorInput;\nexports.isSelectionWithinEditor = isSelectionWithinEditor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGV4aWNhbC9MZXhpY2FsLmRldi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRzs7QUFFQSwrRUFBK0U7O0FBRS9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSUFBMEk7O0FBRTFJO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0EsOElBQThJOztBQUU5SSwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHdDQUF3QztBQUN4QztBQUNBOztBQUVBOztBQUVBLDBCQUEwQixzQkFBc0I7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBOztBQUVBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7OztBQUd2QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEMsa0NBQWtDLFlBQVk7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFLElBQUk7QUFDakY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLHNEQUFzRDtBQUM5Rjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMsd0JBQXdCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSxRQUFRLElBQUkscUJBQXFCO0FBQzdHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHdCQUF3QjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGOztBQUVsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTs7QUFFakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQyxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QixpQ0FBaUM7O0FBRWpDLG1DQUFtQzs7QUFFbkMsaUNBQWlDOztBQUVqQyxpQ0FBaUM7O0FBRWpDLGlDQUFpQzs7QUFFakMsa0NBQWtDOztBQUVsQyxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFLElBQUk7QUFDakY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhOQUE4TjtBQUM5TjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsaUJBQWlCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFROztBQUVSLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7O0FBRUEsa0JBQWtCLDhCQUE4QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKOztBQUVBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBOztBQUVBOztBQUVBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDhCQUE4QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixhQUFhO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDRCQUE0QjtBQUNyRTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywyQ0FBMkM7QUFDbEY7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJDQUEyQztBQUNyRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHdCQUF3QjtBQUNuRztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZEQUE2RDs7O0FBRzdEO0FBQ0E7QUFDQSwyREFBMkQsWUFBWTtBQUN2RTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTSxVQUFVLFlBQVksaUNBQWlDLGtCQUFrQjtBQUN0SDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDOztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyQkFBMkI7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTix1Q0FBdUM7O0FBRXZDO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCLDZEQUE2RDs7QUFFN0QscUZBQXFGOztBQUVyRixnRUFBZ0U7O0FBRWhFLGdGQUFnRjs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7O0FBRUEsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7O0FBRXBELG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9GQUFvRjs7QUFFcEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUIsYUFBYTtBQUN0Qyw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsWUFBWTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBHQUEwRztBQUMxRzs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdEQUFnRCxRQUFRO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0c7O0FBRWxHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUZBQWlGO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7O0FBR04saUNBQWlDLGVBQWU7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekIsb0JBQW9CLGtCQUFrQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhCQUE4QixvQkFBb0I7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUixzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxnR0FBZ0c7O0FBRWhHO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGtCQUFrQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBLElBQUksZUFBZTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQix5QkFBeUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQix5QkFBeUI7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFpRTtBQUNqRTtBQUNBOztBQUVBLCtFQUErRTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQix5QkFBeUI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsTUFBTSx5QkFBeUIsT0FBTztBQUNwRTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2Qyw4QkFBOEI7O0FBRTlCLHFDQUFxQzs7QUFFckMscUNBQXFDOztBQUVyQztBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLGdDQUFnQzs7QUFFaEMsMkJBQTJCOztBQUUzQix5QkFBeUI7O0FBRXpCO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQywyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDJCQUEyQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scUNBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsb0NBQW9DO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlDQUF5QztBQUM1RTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx5QkFBeUI7QUFDbkYsaUVBQWlFLG1DQUFtQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU8sR0FBRztBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMscUJBQXFCO0FBQ3JCLDZCQUE2QjtBQUM3QixnQkFBZ0I7QUFDaEIscUJBQXFCO0FBQ3JCLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQiwyQkFBMkI7QUFDM0Isd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0Qix1Q0FBdUM7QUFDdkMsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsMkJBQTJCO0FBQzNCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCLHlDQUF5QztBQUN6Qyw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3QixxQkFBcUI7QUFDckIsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQix5Q0FBeUM7QUFDekMsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixnQ0FBZ0M7QUFDaEMsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQixrQ0FBa0M7QUFDbEMsdUNBQXVDO0FBQ3ZDLGtDQUFrQztBQUNsQyxrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyxtQ0FBbUM7QUFDbkMsK0JBQStCO0FBQy9CLDJCQUEyQjtBQUMzQiw4QkFBOEI7QUFDOUIsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLDhCQUE4QjtBQUM5QiwyQkFBMkI7QUFDM0IsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0IsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLDRCQUE0QjtBQUM1Qix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLCtCQUErQjtBQUMvQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQiwyQkFBMkI7QUFDM0IsZ0JBQWdCO0FBQ2hCLGdDQUFnQztBQUNoQyxlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLG1DQUFtQztBQUNuQywyQ0FBMkM7QUFDM0MsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY21zX2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvbGV4aWNhbC9MZXhpY2FsLmRldi5qcz83MTI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBjcmVhdGVDb21tYW5kKHR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlXG4gIH0gO1xufVxuY29uc3QgU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5EJyk7XG5jb25zdCBDTElDS19DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ0xJQ0tfQ09NTUFORCcpO1xuY29uc3QgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5EJyk7XG5jb25zdCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCcpO1xuY29uc3QgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5EJyk7XG5jb25zdCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQnKTtcbmNvbnN0IFBBU1RFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdQQVNURV9DT01NQU5EJyk7XG5jb25zdCBSRU1PVkVfVEVYVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnUkVNT1ZFX1RFWFRfQ09NTUFORCcpO1xuY29uc3QgREVMRVRFX1dPUkRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0RFTEVURV9XT1JEX0NPTU1BTkQnKTtcbmNvbnN0IERFTEVURV9MSU5FX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdERUxFVEVfTElORV9DT01NQU5EJyk7XG5jb25zdCBGT1JNQVRfVEVYVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnRk9STUFUX1RFWFRfQ09NTUFORCcpO1xuY29uc3QgVU5ET19DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnVU5ET19DT01NQU5EJyk7XG5jb25zdCBSRURPX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdSRURPX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9ET1dOX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlET1dOX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9BUlJPV19SSUdIVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQnKTtcbmNvbnN0IE1PVkVfVE9fRU5EID0gY3JlYXRlQ29tbWFuZCgnTU9WRV9UT19FTkQnKTtcbmNvbnN0IEtFWV9BUlJPV19MRUZUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfQVJST1dfTEVGVF9DT01NQU5EJyk7XG5jb25zdCBNT1ZFX1RPX1NUQVJUID0gY3JlYXRlQ29tbWFuZCgnTU9WRV9UT19TVEFSVCcpO1xuY29uc3QgS0VZX0FSUk9XX1VQX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfQVJST1dfVVBfQ09NTUFORCcpO1xuY29uc3QgS0VZX0FSUk9XX0RPV05fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9BUlJPV19ET1dOX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9FTlRFUl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0VOVEVSX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9TUEFDRV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX1NQQUNFX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9CQUNLU1BBQ0VfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9CQUNLU1BBQ0VfQ09NTUFORCcpO1xuY29uc3QgS0VZX0VTQ0FQRV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0VTQ0FQRV9DT01NQU5EJyk7XG5jb25zdCBLRVlfREVMRVRFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfREVMRVRFX0NPTU1BTkQnKTtcbmNvbnN0IEtFWV9UQUJfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9UQUJfQ09NTUFORCcpO1xuY29uc3QgSU5TRVJUX1RBQl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX1RBQl9DT01NQU5EJyk7XG5jb25zdCBJTkRFTlRfQ09OVEVOVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5ERU5UX0NPTlRFTlRfQ09NTUFORCcpO1xuY29uc3QgT1VUREVOVF9DT05URU5UX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdPVVRERU5UX0NPTlRFTlRfQ09NTUFORCcpO1xuY29uc3QgRFJPUF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnRFJPUF9DT01NQU5EJyk7XG5jb25zdCBGT1JNQVRfRUxFTUVOVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnRk9STUFUX0VMRU1FTlRfQ09NTUFORCcpO1xuY29uc3QgRFJBR1NUQVJUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdEUkFHU1RBUlRfQ09NTUFORCcpO1xuY29uc3QgRFJBR09WRVJfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0RSQUdPVkVSX0NPTU1BTkQnKTtcbmNvbnN0IERSQUdFTkRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0RSQUdFTkRfQ09NTUFORCcpO1xuY29uc3QgQ09QWV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ09QWV9DT01NQU5EJyk7XG5jb25zdCBDVVRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NVVF9DT01NQU5EJyk7XG5jb25zdCBDTEVBUl9FRElUT1JfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NMRUFSX0VESVRPUl9DT01NQU5EJyk7XG5jb25zdCBDTEVBUl9ISVNUT1JZX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDTEVBUl9ISVNUT1JZX0NPTU1BTkQnKTtcbmNvbnN0IENBTl9SRURPX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDQU5fUkVET19DT01NQU5EJyk7XG5jb25zdCBDQU5fVU5ET19DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ0FOX1VORE9fQ09NTUFORCcpO1xuY29uc3QgRk9DVVNfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0ZPQ1VTX0NPTU1BTkQnKTtcbmNvbnN0IEJMVVJfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0JMVVJfQ09NTUFORCcpO1xuY29uc3QgS0VZX01PRElGSUVSX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfTU9ESUZJRVJfQ09NTUFORCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IGRvY3VtZW50TW9kZSA9IENBTl9VU0VfRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogbnVsbDtcbmNvbnN0IElTX0FQUExFID0gQ0FOX1VTRV9ET00gJiYgL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19GSVJFRk9YID0gQ0FOX1VTRV9ET00gJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3gpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgQ0FOX1VTRV9CRUZPUkVfSU5QVVQgPSBDQU5fVVNFX0RPTSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcbmNvbnN0IElTX1NBRkFSSSA9IENBTl9VU0VfRE9NICYmIC9WZXJzaW9uXFwvW1xcZC5dKy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgSVNfSU9TID0gQ0FOX1VTRV9ET00gJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTsgLy8gS2VlcCB0aGVzZSBpbiBjYXNlIHdlIG5lZWQgdG8gdXNlIHRoZW0gaW4gdGhlIGZ1dHVyZS5cbi8vIGV4cG9ydCBjb25zdCBJU19XSU5ET1dTOiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgL1dpbi8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG5jb25zdCBJU19DSFJPTUUgPSBDQU5fVVNFX0RPTSAmJiAvXig/PS4qQ2hyb21lKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gZXhwb3J0IGNvbnN0IGNhblVzZVRleHRJbnB1dEV2ZW50OiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbmNvbnN0IElTX0FQUExFX1dFQktJVCA9IENBTl9VU0VfRE9NICYmIC9BcHBsZVdlYktpdFxcL1tcXGQuXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIUlTX0NIUk9NRTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBET01fRUxFTUVOVF9UWVBFID0gMTtcbmNvbnN0IERPTV9URVhUX1RZUEUgPSAzOyAvLyBSZWNvbmNpbGluZ1xuXG5jb25zdCBOT19ESVJUWV9OT0RFUyA9IDA7XG5jb25zdCBIQVNfRElSVFlfTk9ERVMgPSAxO1xuY29uc3QgRlVMTF9SRUNPTkNJTEUgPSAyOyAvLyBUZXh0IG5vZGUgbW9kZXNcblxuY29uc3QgSVNfTk9STUFMID0gMDtcbmNvbnN0IElTX1RPS0VOID0gMTtcbmNvbnN0IElTX1NFR01FTlRFRCA9IDI7IC8vIElTX0lORVJUID0gM1xuLy8gVGV4dCBub2RlIGZvcm1hdHRpbmdcblxuY29uc3QgSVNfQk9MRCA9IDE7XG5jb25zdCBJU19JVEFMSUMgPSAxIDw8IDE7XG5jb25zdCBJU19TVFJJS0VUSFJPVUdIID0gMSA8PCAyO1xuY29uc3QgSVNfVU5ERVJMSU5FID0gMSA8PCAzO1xuY29uc3QgSVNfQ09ERSA9IDEgPDwgNDtcbmNvbnN0IElTX1NVQlNDUklQVCA9IDEgPDwgNTtcbmNvbnN0IElTX1NVUEVSU0NSSVBUID0gMSA8PCA2O1xuY29uc3QgSVNfSElHSExJR0hUID0gMSA8PCA3O1xuY29uc3QgSVNfQUxMX0ZPUk1BVFRJTkcgPSBJU19CT0xEIHwgSVNfSVRBTElDIHwgSVNfU1RSSUtFVEhST1VHSCB8IElTX1VOREVSTElORSB8IElTX0NPREUgfCBJU19TVUJTQ1JJUFQgfCBJU19TVVBFUlNDUklQVCB8IElTX0hJR0hMSUdIVDsgLy8gVGV4dCBub2RlIGRldGFpbHNcblxuY29uc3QgSVNfRElSRUNUSU9OTEVTUyA9IDE7XG5jb25zdCBJU19VTk1FUkdFQUJMRSA9IDEgPDwgMTsgLy8gRWxlbWVudCBub2RlIGZvcm1hdHRpbmdcblxuY29uc3QgSVNfQUxJR05fTEVGVCA9IDE7XG5jb25zdCBJU19BTElHTl9DRU5URVIgPSAyO1xuY29uc3QgSVNfQUxJR05fUklHSFQgPSAzO1xuY29uc3QgSVNfQUxJR05fSlVTVElGWSA9IDQ7XG5jb25zdCBJU19BTElHTl9TVEFSVCA9IDU7XG5jb25zdCBJU19BTElHTl9FTkQgPSA2OyAvLyBSZWNvbmNpbGlhdGlvblxuXG5jb25zdCBOT05fQlJFQUtJTkdfU1BBQ0UgPSAnXFx1MDBBMCc7XG5jb25zdCBaRVJPX1dJRFRIX1NQQUNFID0gJ1xcdTIwMGInOyAvLyBGb3IgaU9TL1NhZmFyaSB3ZSB1c2UgYSBub24gYnJlYWtpbmcgc3BhY2UsIG90aGVyd2lzZSB0aGUgY3Vyc29yIGFwcGVhcnNcbi8vIG92ZXJsYXBwaW5nIHRoZSBjb21wb3NlZCB0ZXh0LlxuXG5jb25zdCBDT01QT1NJVElPTl9TVUZGSVggPSBJU19TQUZBUkkgfHwgSVNfSU9TIHx8IElTX0FQUExFX1dFQktJVCA/IE5PTl9CUkVBS0lOR19TUEFDRSA6IFpFUk9fV0lEVEhfU1BBQ0U7XG5jb25zdCBET1VCTEVfTElORV9CUkVBSyA9ICdcXG5cXG4nOyAvLyBGb3IgRkYsIHdlIG5lZWQgdG8gdXNlIGEgbm9uLWJyZWFraW5nIHNwYWNlLCBvciBpdCBnZXRzIGNvbXBvc2l0aW9uXG4vLyBpbiBhIHN0dWNrIHN0YXRlLlxuXG5jb25zdCBDT01QT1NJVElPTl9TVEFSVF9DSEFSID0gSVNfRklSRUZPWCA/IE5PTl9CUkVBS0lOR19TUEFDRSA6IENPTVBPU0lUSU9OX1NVRkZJWDtcbmNvbnN0IFJUTCA9ICdcXHUwNTkxLVxcdTA3RkZcXHVGQjFELVxcdUZERkRcXHVGRTcwLVxcdUZFRkMnO1xuY29uc3QgTFRSID0gJ0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNicgKyAnXFx1MDBGOC1cXHUwMkI4XFx1MDMwMC1cXHUwNTkwXFx1MDgwMC1cXHUxRkZGXFx1MjAwRVxcdTJDMDAtXFx1RkIxQycgKyAnXFx1RkUwMC1cXHVGRTZGXFx1RkVGRC1cXHVGRkZGJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1pc2xlYWRpbmctY2hhcmFjdGVyLWNsYXNzXG5cbmNvbnN0IFJUTF9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bXicgKyBMVFIgKyAnXSpbJyArIFJUTCArICddJyk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzc1xuXG5jb25zdCBMVFJfUkVHRVggPSBuZXcgUmVnRXhwKCdeW14nICsgUlRMICsgJ10qWycgKyBMVFIgKyAnXScpO1xuY29uc3QgVEVYVF9UWVBFX1RPX0ZPUk1BVCA9IHtcbiAgYm9sZDogSVNfQk9MRCxcbiAgY29kZTogSVNfQ09ERSxcbiAgaGlnaGxpZ2h0OiBJU19ISUdITElHSFQsXG4gIGl0YWxpYzogSVNfSVRBTElDLFxuICBzdHJpa2V0aHJvdWdoOiBJU19TVFJJS0VUSFJPVUdILFxuICBzdWJzY3JpcHQ6IElTX1NVQlNDUklQVCxcbiAgc3VwZXJzY3JpcHQ6IElTX1NVUEVSU0NSSVBULFxuICB1bmRlcmxpbmU6IElTX1VOREVSTElORVxufTtcbmNvbnN0IERFVEFJTF9UWVBFX1RPX0RFVEFJTCA9IHtcbiAgZGlyZWN0aW9ubGVzczogSVNfRElSRUNUSU9OTEVTUyxcbiAgdW5tZXJnZWFibGU6IElTX1VOTUVSR0VBQkxFXG59O1xuY29uc3QgRUxFTUVOVF9UWVBFX1RPX0ZPUk1BVCA9IHtcbiAgY2VudGVyOiBJU19BTElHTl9DRU5URVIsXG4gIGVuZDogSVNfQUxJR05fRU5ELFxuICBqdXN0aWZ5OiBJU19BTElHTl9KVVNUSUZZLFxuICBsZWZ0OiBJU19BTElHTl9MRUZULFxuICByaWdodDogSVNfQUxJR05fUklHSFQsXG4gIHN0YXJ0OiBJU19BTElHTl9TVEFSVFxufTtcbmNvbnN0IEVMRU1FTlRfRk9STUFUX1RPX1RZUEUgPSB7XG4gIFtJU19BTElHTl9DRU5URVJdOiAnY2VudGVyJyxcbiAgW0lTX0FMSUdOX0VORF06ICdlbmQnLFxuICBbSVNfQUxJR05fSlVTVElGWV06ICdqdXN0aWZ5JyxcbiAgW0lTX0FMSUdOX0xFRlRdOiAnbGVmdCcsXG4gIFtJU19BTElHTl9SSUdIVF06ICdyaWdodCcsXG4gIFtJU19BTElHTl9TVEFSVF06ICdzdGFydCdcbn07XG5jb25zdCBURVhUX01PREVfVE9fVFlQRSA9IHtcbiAgbm9ybWFsOiBJU19OT1JNQUwsXG4gIHNlZ21lbnRlZDogSVNfU0VHTUVOVEVELFxuICB0b2tlbjogSVNfVE9LRU5cbn07XG5jb25zdCBURVhUX1RZUEVfVE9fTU9ERSA9IHtcbiAgW0lTX05PUk1BTF06ICdub3JtYWwnLFxuICBbSVNfU0VHTUVOVEVEXTogJ3NlZ21lbnRlZCcsXG4gIFtJU19UT0tFTl06ICd0b2tlbidcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgVEVYVF9NVVRBVElPTl9WQVJJQU5DRSA9IDEwMDtcbmxldCBpc1Byb2Nlc3NpbmdNdXRhdGlvbnMgPSBmYWxzZTtcbmxldCBsYXN0VGV4dEVudHJ5VGltZVN0YW1wID0gMDtcbmZ1bmN0aW9uIGdldElzUHJvY2Vzc3NpbmdNdXRhdGlvbnMoKSB7XG4gIHJldHVybiBpc1Byb2Nlc3NpbmdNdXRhdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRpbWVTdGFtcChldmVudCkge1xuICBsYXN0VGV4dEVudHJ5VGltZVN0YW1wID0gZXZlbnQudGltZVN0YW1wO1xufVxuXG5mdW5jdGlvbiBpbml0VGV4dEVudHJ5TGlzdGVuZXIoZWRpdG9yKSB7XG4gIGlmIChsYXN0VGV4dEVudHJ5VGltZVN0YW1wID09PSAwKSB7XG4gICAgZ2V0V2luZG93KGVkaXRvcikuYWRkRXZlbnRMaXN0ZW5lcigndGV4dElucHV0JywgdXBkYXRlVGltZVN0YW1wLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc01hbmFnZWRMaW5lQnJlYWsoZG9tLCB0YXJnZXQsIGVkaXRvcikge1xuICByZXR1cm4gKC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gICAgdGFyZ2V0Ll9fbGV4aWNhbExpbmVCcmVhayA9PT0gZG9tIHx8IC8vIEB0cy1pZ25vcmUgV2UgaW50ZW50aW9uYWxseSBhZGQgdGhpcyB0byB0aGUgTm9kZS5cbiAgICBkb21bYF9fbGV4aWNhbEtleV8ke2VkaXRvci5fa2V5fWBdICE9PSB1bmRlZmluZWRcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGFzdFNlbGVjdGlvbihlZGl0b3IpIHtcbiAgcmV0dXJuIGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gc2VsZWN0aW9uICE9PSBudWxsID8gc2VsZWN0aW9uLmNsb25lKCkgOiBudWxsO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlVGV4dE11dGF0aW9uKHRhcmdldCwgbm9kZSwgZWRpdG9yKSB7XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG4gIGxldCBhbmNob3JPZmZzZXQgPSBudWxsO1xuICBsZXQgZm9jdXNPZmZzZXQgPSBudWxsO1xuXG4gIGlmIChkb21TZWxlY3Rpb24gIT09IG51bGwgJiYgZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IHRhcmdldCkge1xuICAgIGFuY2hvck9mZnNldCA9IGRvbVNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XG4gICAgZm9jdXNPZmZzZXQgPSBkb21TZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gIH1cblxuICBjb25zdCB0ZXh0ID0gdGFyZ2V0Lm5vZGVWYWx1ZTtcblxuICBpZiAodGV4dCAhPT0gbnVsbCkge1xuICAgICR1cGRhdGVUZXh0Tm9kZUZyb21ET01Db250ZW50KG5vZGUsIHRleHQsIGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVUZXh0Tm9kZUZyb21NdXRhdGlvbihzZWxlY3Rpb24sIHRhcmdldERPTSwgdGFyZ2V0Tm9kZSkge1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcblxuICAgIGlmIChhbmNob3JOb2RlLmlzKHRhcmdldE5vZGUpICYmIHNlbGVjdGlvbi5mb3JtYXQgIT09IGFuY2hvck5vZGUuZ2V0Rm9ybWF0KCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0RE9NLm5vZGVUeXBlID09PSBET01fVEVYVF9UWVBFICYmIHRhcmdldE5vZGUuaXNBdHRhY2hlZCgpO1xufVxuXG5mdW5jdGlvbiAkZmx1c2hNdXRhdGlvbnMkMShlZGl0b3IsIG11dGF0aW9ucywgb2JzZXJ2ZXIpIHtcbiAgaXNQcm9jZXNzaW5nTXV0YXRpb25zID0gdHJ1ZTtcbiAgY29uc3Qgc2hvdWxkRmx1c2hUZXh0TXV0YXRpb25zID0gcGVyZm9ybWFuY2Uubm93KCkgLSBsYXN0VGV4dEVudHJ5VGltZVN0YW1wID4gVEVYVF9NVVRBVElPTl9WQVJJQU5DRTtcblxuICB0cnkge1xuICAgIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKSB8fCBnZXRMYXN0U2VsZWN0aW9uKGVkaXRvcik7XG4gICAgICBjb25zdCBiYWRET01UYXJnZXRzID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTsgLy8gV2UgdXNlIHRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZSwgYXMgdGhhdCByZWZsZWN0cyB3aGF0IGlzXG4gICAgICAvLyBhY3R1YWxseSBcIm9uIHNjcmVlblwiLlxuXG4gICAgICBjb25zdCBjdXJyZW50RWRpdG9yU3RhdGUgPSBlZGl0b3IuX2VkaXRvclN0YXRlO1xuICAgICAgY29uc3QgYmxvY2tDdXJzb3JFbGVtZW50ID0gZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQ7XG4gICAgICBsZXQgc2hvdWxkUmV2ZXJ0U2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICBsZXQgcG9zc2libGVUZXh0Rm9yRmlyZWZveFBhc3RlID0gJyc7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uID0gbXV0YXRpb25zW2ldO1xuICAgICAgICBjb25zdCB0eXBlID0gbXV0YXRpb24udHlwZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0RE9NID0gbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBsZXQgdGFyZ2V0Tm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKHRhcmdldERPTSwgY3VycmVudEVkaXRvclN0YXRlKTtcblxuICAgICAgICBpZiAodGFyZ2V0Tm9kZSA9PT0gbnVsbCAmJiB0YXJnZXRET00gIT09IHJvb3RFbGVtZW50IHx8ICRpc0RlY29yYXRvck5vZGUodGFyZ2V0Tm9kZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnY2hhcmFjdGVyRGF0YScpIHtcbiAgICAgICAgICAvLyBUZXh0IG11dGF0aW9ucyBhcmUgZGVmZXJyZWQgYW5kIHBhc3NlZCB0byBtdXRhdGlvbiBsaXN0ZW5lcnMgdG8gYmVcbiAgICAgICAgICAvLyBwcm9jZXNzZWQgb3V0c2lkZSBvZiB0aGUgTGV4aWNhbCBlbmdpbmUuXG4gICAgICAgICAgaWYgKHNob3VsZEZsdXNoVGV4dE11dGF0aW9ucyAmJiAkaXNUZXh0Tm9kZSh0YXJnZXROb2RlKSAmJiBzaG91bGRVcGRhdGVUZXh0Tm9kZUZyb21NdXRhdGlvbihzZWxlY3Rpb24sIHRhcmdldERPTSwgdGFyZ2V0Tm9kZSkpIHtcbiAgICAgICAgICAgIGhhbmRsZVRleHRNdXRhdGlvbiggLy8gbm9kZVR5cGUgPT09IERPTV9URVhUX1RZUEUgaXMgYSBUZXh0IERPTSBub2RlXG4gICAgICAgICAgICB0YXJnZXRET00sIHRhcmdldE5vZGUsIGVkaXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgc2hvdWxkUmV2ZXJ0U2VsZWN0aW9uID0gdHJ1ZTsgLy8gV2UgYXR0ZW1wdCB0byBcInVuZG9cIiBhbnkgY2hhbmdlcyB0aGF0IGhhdmUgb2NjdXJyZWQgb3V0c2lkZVxuICAgICAgICAgIC8vIG9mIExleGljYWwuIFdlIHdhbnQgTGV4aWNhbCdzIGVkaXRvciBzdGF0ZSB0byBiZSBzb3VyY2Ugb2YgdHJ1dGguXG4gICAgICAgICAgLy8gVG8gdGhlIHVzZXIsIHRoZXNlIHdpbGwgbG9vayBsaWtlIG5vLW9wcy5cblxuICAgICAgICAgIGNvbnN0IGFkZGVkRE9NcyA9IG11dGF0aW9uLmFkZGVkTm9kZXM7XG5cbiAgICAgICAgICBmb3IgKGxldCBzID0gMDsgcyA8IGFkZGVkRE9Ncy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgY29uc3QgYWRkZWRET00gPSBhZGRlZERPTXNbc107XG4gICAgICAgICAgICBjb25zdCBub2RlID0gZ2V0Tm9kZUZyb21ET01Ob2RlKGFkZGVkRE9NKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudERPTSA9IGFkZGVkRE9NLnBhcmVudE5vZGU7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRET00gIT0gbnVsbCAmJiBhZGRlZERPTSAhPT0gYmxvY2tDdXJzb3JFbGVtZW50ICYmIG5vZGUgPT09IG51bGwgJiYgKGFkZGVkRE9NLm5vZGVOYW1lICE9PSAnQlInIHx8ICFpc01hbmFnZWRMaW5lQnJlYWsoYWRkZWRET00sIHBhcmVudERPTSwgZWRpdG9yKSkpIHtcbiAgICAgICAgICAgICAgaWYgKElTX0ZJUkVGT1gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NzaWJsZVRleHQgPSBhZGRlZERPTS5pbm5lclRleHQgfHwgYWRkZWRET00ubm9kZVZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlVGV4dCkge1xuICAgICAgICAgICAgICAgICAgcG9zc2libGVUZXh0Rm9yRmlyZWZveFBhc3RlICs9IHBvc3NpYmxlVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwYXJlbnRET00ucmVtb3ZlQ2hpbGQoYWRkZWRET00pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlbW92ZWRET01zID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzO1xuICAgICAgICAgIGNvbnN0IHJlbW92ZWRET01zTGVuZ3RoID0gcmVtb3ZlZERPTXMubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHJlbW92ZWRET01zTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IHVucmVtb3ZlZEJScyA9IDA7XG5cbiAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgcmVtb3ZlZERPTXNMZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgICBjb25zdCByZW1vdmVkRE9NID0gcmVtb3ZlZERPTXNbc107XG5cbiAgICAgICAgICAgICAgaWYgKHJlbW92ZWRET00ubm9kZU5hbWUgPT09ICdCUicgJiYgaXNNYW5hZ2VkTGluZUJyZWFrKHJlbW92ZWRET00sIHRhcmdldERPTSwgZWRpdG9yKSB8fCBibG9ja0N1cnNvckVsZW1lbnQgPT09IHJlbW92ZWRET00pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRET00uYXBwZW5kQ2hpbGQocmVtb3ZlZERPTSk7XG4gICAgICAgICAgICAgICAgdW5yZW1vdmVkQlJzKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbW92ZWRET01zTGVuZ3RoICE9PSB1bnJlbW92ZWRCUnMpIHtcbiAgICAgICAgICAgICAgaWYgKHRhcmdldERPTSA9PT0gcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gaW50ZXJuYWxHZXRSb290KGN1cnJlbnRFZGl0b3JTdGF0ZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBiYWRET01UYXJnZXRzLnNldCh0YXJnZXRET00sIHRhcmdldE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBOb3cgd2UgcHJvY2VzcyBlYWNoIG9mIHRoZSB1bmlxdWUgdGFyZ2V0IG5vZGVzLCBhdHRlbXB0aW5nXG4gICAgICAvLyB0byByZXN0b3JlIHRoZWlyIGNvbnRlbnRzIGJhY2sgdG8gdGhlIHNvdXJjZSBvZiB0cnV0aCwgd2hpY2hcbiAgICAgIC8vIGlzIExleGljYWwncyBcImN1cnJlbnRcIiBlZGl0b3Igc3RhdGUuIFRoaXMgaXMgYmFzaWNhbGx5IGxpa2VcbiAgICAgIC8vIGFuIGludGVybmFsIHJldmVydCBvbiB0aGUgRE9NLlxuXG5cbiAgICAgIGlmIChiYWRET01UYXJnZXRzLnNpemUgPiAwKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3RhcmdldERPTSwgdGFyZ2V0Tm9kZV0gb2YgYmFkRE9NVGFyZ2V0cykge1xuICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZSh0YXJnZXROb2RlKSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRLZXlzID0gdGFyZ2V0Tm9kZS5nZXRDaGlsZHJlbktleXMoKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50RE9NID0gdGFyZ2V0RE9NLmZpcnN0Q2hpbGQ7XG5cbiAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgY2hpbGRLZXlzLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGtleSA9IGNoaWxkS2V5c1tzXTtcbiAgICAgICAgICAgICAgY29uc3QgY29ycmVjdERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoa2V5KTtcblxuICAgICAgICAgICAgICBpZiAoY29ycmVjdERPTSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRET00gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRhcmdldERPTS5hcHBlbmRDaGlsZChjb3JyZWN0RE9NKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RE9NID0gY29ycmVjdERPTTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50RE9NICE9PSBjb3JyZWN0RE9NKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RE9NLnJlcGxhY2VDaGlsZChjb3JyZWN0RE9NLCBjdXJyZW50RE9NKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGN1cnJlbnRET00gPSBjdXJyZW50RE9NLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoJGlzVGV4dE5vZGUodGFyZ2V0Tm9kZSkpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGUubWFya0RpcnR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIENhcHR1cmUgYWxsIHRoZSBtdXRhdGlvbnMgbWFkZSBkdXJpbmcgdGhpcyBmdW5jdGlvbi4gVGhpc1xuICAgICAgLy8gYWxzbyBwcmV2ZW50cyB1cyBoYXZpbmcgdG8gcHJvY2VzcyB0aGVtIG9uIHRoZSBuZXh0IGN5Y2xlXG4gICAgICAvLyBvZiBvbk11dGF0aW9uLCBhcyB0aGVzZSBtdXRhdGlvbnMgd2VyZSBtYWRlIGJ5IHVzLlxuXG5cbiAgICAgIGNvbnN0IHJlY29yZHMgPSBvYnNlcnZlci50YWtlUmVjb3JkcygpOyAvLyBDaGVjayBmb3IgYW55IHJhbmRvbSBhdXRvLWFkZGVkIDxicj4gZWxlbWVudHMsIGFuZCByZW1vdmUgdGhlbS5cbiAgICAgIC8vIFRoZXNlIGdldCBhZGRlZCBieSB0aGUgYnJvd3NlciB3aGVuIHdlIHVuZG8gdGhlIGFib3ZlIG11dGF0aW9uc1xuICAgICAgLy8gYW5kIHRoaXMgY2FuIGxlYWQgdG8gYSBicm9rZW4gVUkuXG5cbiAgICAgIGlmIChyZWNvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWNvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcmVjb3JkID0gcmVjb3Jkc1tpXTtcbiAgICAgICAgICBjb25zdCBhZGRlZE5vZGVzID0gcmVjb3JkLmFkZGVkTm9kZXM7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gcmVjb3JkLnRhcmdldDtcblxuICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgYWRkZWROb2Rlcy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgY29uc3QgYWRkZWRET00gPSBhZGRlZE5vZGVzW3NdO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50RE9NID0gYWRkZWRET00ucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudERPTSAhPSBudWxsICYmIGFkZGVkRE9NLm5vZGVOYW1lID09PSAnQlInICYmICFpc01hbmFnZWRMaW5lQnJlYWsoYWRkZWRET00sIHRhcmdldCwgZWRpdG9yKSkge1xuICAgICAgICAgICAgICBwYXJlbnRET00ucmVtb3ZlQ2hpbGQoYWRkZWRET00pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDbGVhciBhbnkgb2YgdGhvc2UgcmVtb3ZhbCBtdXRhdGlvbnNcblxuXG4gICAgICAgIG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFJldmVydFNlbGVjdGlvbikge1xuICAgICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgJHNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgaXNGaXJlZm94Q2xpcGJvYXJkRXZlbnRzKGVkaXRvcikpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dChwb3NzaWJsZVRleHRGb3JGaXJlZm94UGFzdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgaXNQcm9jZXNzaW5nTXV0YXRpb25zID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoUm9vdE11dGF0aW9ucyhlZGl0b3IpIHtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBlZGl0b3IuX29ic2VydmVyO1xuXG4gIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG11dGF0aW9ucyA9IG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgJGZsdXNoTXV0YXRpb25zJDEoZWRpdG9yLCBtdXRhdGlvbnMsIG9ic2VydmVyKTtcbiAgfVxufVxuZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIoZWRpdG9yKSB7XG4gIGluaXRUZXh0RW50cnlMaXN0ZW5lcihlZGl0b3IpO1xuICBlZGl0b3IuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucywgb2JzZXJ2ZXIpID0+IHtcbiAgICAkZmx1c2hNdXRhdGlvbnMkMShlZGl0b3IsIG11dGF0aW9ucywgb2JzZXJ2ZXIpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiAkY2FuU2ltcGxlVGV4dE5vZGVzQmVNZXJnZWQobm9kZTEsIG5vZGUyKSB7XG4gIGNvbnN0IG5vZGUxTW9kZSA9IG5vZGUxLl9fbW9kZTtcbiAgY29uc3Qgbm9kZTFGb3JtYXQgPSBub2RlMS5fX2Zvcm1hdDtcbiAgY29uc3Qgbm9kZTFTdHlsZSA9IG5vZGUxLl9fc3R5bGU7XG4gIGNvbnN0IG5vZGUyTW9kZSA9IG5vZGUyLl9fbW9kZTtcbiAgY29uc3Qgbm9kZTJGb3JtYXQgPSBub2RlMi5fX2Zvcm1hdDtcbiAgY29uc3Qgbm9kZTJTdHlsZSA9IG5vZGUyLl9fc3R5bGU7XG4gIHJldHVybiAobm9kZTFNb2RlID09PSBudWxsIHx8IG5vZGUxTW9kZSA9PT0gbm9kZTJNb2RlKSAmJiAobm9kZTFGb3JtYXQgPT09IG51bGwgfHwgbm9kZTFGb3JtYXQgPT09IG5vZGUyRm9ybWF0KSAmJiAobm9kZTFTdHlsZSA9PT0gbnVsbCB8fCBub2RlMVN0eWxlID09PSBub2RlMlN0eWxlKTtcbn1cblxuZnVuY3Rpb24gJG1lcmdlVGV4dE5vZGVzKG5vZGUxLCBub2RlMikge1xuICBjb25zdCB3cml0YWJsZU5vZGUxID0gbm9kZTEubWVyZ2VXaXRoU2libGluZyhub2RlMik7XG5cbiAgY29uc3Qgbm9ybWFsaXplZE5vZGVzID0gZ2V0QWN0aXZlRWRpdG9yKCkuX25vcm1hbGl6ZWROb2RlcztcblxuICBub3JtYWxpemVkTm9kZXMuYWRkKG5vZGUxLl9fa2V5KTtcbiAgbm9ybWFsaXplZE5vZGVzLmFkZChub2RlMi5fX2tleSk7XG4gIHJldHVybiB3cml0YWJsZU5vZGUxO1xufVxuXG5mdW5jdGlvbiAkbm9ybWFsaXplVGV4dE5vZGUodGV4dE5vZGUpIHtcbiAgbGV0IG5vZGUgPSB0ZXh0Tm9kZTtcblxuICBpZiAobm9kZS5fX3RleHQgPT09ICcnICYmIG5vZGUuaXNTaW1wbGVUZXh0KCkgJiYgIW5vZGUuaXNVbm1lcmdlYWJsZSgpKSB7XG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgICByZXR1cm47XG4gIH0gLy8gQmFja3dhcmRcblxuXG4gIGxldCBwcmV2aW91c05vZGU7XG5cbiAgd2hpbGUgKChwcmV2aW91c05vZGUgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpKSAhPT0gbnVsbCAmJiAkaXNUZXh0Tm9kZShwcmV2aW91c05vZGUpICYmIHByZXZpb3VzTm9kZS5pc1NpbXBsZVRleHQoKSAmJiAhcHJldmlvdXNOb2RlLmlzVW5tZXJnZWFibGUoKSkge1xuICAgIGlmIChwcmV2aW91c05vZGUuX190ZXh0ID09PSAnJykge1xuICAgICAgcHJldmlvdXNOb2RlLnJlbW92ZSgpO1xuICAgIH0gZWxzZSBpZiAoJGNhblNpbXBsZVRleHROb2Rlc0JlTWVyZ2VkKHByZXZpb3VzTm9kZSwgbm9kZSkpIHtcbiAgICAgIG5vZGUgPSAkbWVyZ2VUZXh0Tm9kZXMocHJldmlvdXNOb2RlLCBub2RlKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8gRm9yd2FyZFxuXG5cbiAgbGV0IG5leHROb2RlO1xuXG4gIHdoaWxlICgobmV4dE5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCkpICE9PSBudWxsICYmICRpc1RleHROb2RlKG5leHROb2RlKSAmJiBuZXh0Tm9kZS5pc1NpbXBsZVRleHQoKSAmJiAhbmV4dE5vZGUuaXNVbm1lcmdlYWJsZSgpKSB7XG4gICAgaWYgKG5leHROb2RlLl9fdGV4dCA9PT0gJycpIHtcbiAgICAgIG5leHROb2RlLnJlbW92ZSgpO1xuICAgIH0gZWxzZSBpZiAoJGNhblNpbXBsZVRleHROb2Rlc0JlTWVyZ2VkKG5vZGUsIG5leHROb2RlKSkge1xuICAgICAgbm9kZSA9ICRtZXJnZVRleHROb2Rlcyhub2RlLCBuZXh0Tm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkbm9ybWFsaXplU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAkbm9ybWFsaXplUG9pbnQoc2VsZWN0aW9uLmFuY2hvcik7XG4gICRub3JtYWxpemVQb2ludChzZWxlY3Rpb24uZm9jdXMpO1xuICByZXR1cm4gc2VsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiAkbm9ybWFsaXplUG9pbnQocG9pbnQpIHtcbiAgd2hpbGUgKHBvaW50LnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgIGNvbnN0IG5vZGUgPSBwb2ludC5nZXROb2RlKCk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gcG9pbnQub2Zmc2V0O1xuICAgIGxldCBuZXh0Tm9kZTtcbiAgICBsZXQgbmV4dE9mZnNldEF0RW5kO1xuXG4gICAgaWYgKG9mZnNldCA9PT0gbm9kZS5nZXRDaGlsZHJlblNpemUoKSkge1xuICAgICAgbmV4dE5vZGUgPSBub2RlLmdldENoaWxkQXRJbmRleChvZmZzZXQgLSAxKTtcbiAgICAgIG5leHRPZmZzZXRBdEVuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHROb2RlID0gbm9kZS5nZXRDaGlsZEF0SW5kZXgob2Zmc2V0KTtcbiAgICAgIG5leHRPZmZzZXRBdEVuZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0Tm9kZSkpIHtcbiAgICAgIHBvaW50LnNldChuZXh0Tm9kZS5fX2tleSwgbmV4dE9mZnNldEF0RW5kID8gbmV4dE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgOiAwLCAndGV4dCcpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmICghJGlzRWxlbWVudE5vZGUobmV4dE5vZGUpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwb2ludC5zZXQobmV4dE5vZGUuX19rZXksIG5leHRPZmZzZXRBdEVuZCA/IG5leHROb2RlLmdldENoaWxkcmVuU2l6ZSgpIDogMCwgJ2VsZW1lbnQnKTtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5sZXQga2V5Q291bnRlciA9IDE7XG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUtleSgpIHtcbiAgcmV0dXJuICcnICsga2V5Q291bnRlcisrO1xufVxuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZE5vZGVPclRocm93KGVkaXRvciwgbm9kZVR5cGUpIHtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSBlZGl0b3IuX25vZGVzLmdldChub2RlVHlwZSk7XG5cbiAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgcmVnaXN0ZXJlZE5vZGU6IFR5cGUgJHtub2RlVHlwZX0gbm90IGZvdW5kYCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlZ2lzdGVyZWROb2RlO1xufVxuY29uc3Qgc2NoZWR1bGVNaWNyb1Rhc2sgPSB0eXBlb2YgcXVldWVNaWNyb3Rhc2sgPT09ICdmdW5jdGlvbicgPyBxdWV1ZU1pY3JvdGFzayA6IGZuID0+IHtcbiAgLy8gTm8gd2luZG93IHByZWZpeCBpbnRlbmRlZCAoIzE0MDApXG4gIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm4pO1xufTtcbmZ1bmN0aW9uICRpc1NlbGVjdGlvbkNhcHR1cmVkSW5EZWNvcmF0b3Iobm9kZSkge1xuICByZXR1cm4gJGlzRGVjb3JhdG9yTm9kZSgkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShub2RlKSk7XG59XG5mdW5jdGlvbiBpc1NlbGVjdGlvbkNhcHR1cmVkSW5EZWNvcmF0b3JJbnB1dChhbmNob3JET00pIHtcbiAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBub2RlTmFtZSA9IGFjdGl2ZUVsZW1lbnQubm9kZU5hbWU7XG4gIHJldHVybiAkaXNEZWNvcmF0b3JOb2RlKCRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGFuY2hvckRPTSkpICYmIChub2RlTmFtZSA9PT0gJ0lOUFVUJyB8fCBub2RlTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fCBhY3RpdmVFbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnICYmIC8vIEB0cy1pZ25vcmUgaXRlcm5hbCBmaWVsZFxuICBhY3RpdmVFbGVtZW50Ll9fbGV4aWNhbEVkaXRvciA9PSBudWxsKTtcbn1cbmZ1bmN0aW9uIGlzU2VsZWN0aW9uV2l0aGluRWRpdG9yKGVkaXRvciwgYW5jaG9yRE9NLCBmb2N1c0RPTSkge1xuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIHJvb3RFbGVtZW50ICE9PSBudWxsICYmIHJvb3RFbGVtZW50LmNvbnRhaW5zKGFuY2hvckRPTSkgJiYgcm9vdEVsZW1lbnQuY29udGFpbnMoZm9jdXNET00pICYmIC8vIElnbm9yZSBpZiBzZWxlY3Rpb24gaXMgd2l0aGluIG5lc3RlZCBlZGl0b3JcbiAgICBhbmNob3JET00gIT09IG51bGwgJiYgIWlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcklucHV0KGFuY2hvckRPTSkgJiYgZ2V0TmVhcmVzdEVkaXRvckZyb21ET01Ob2RlKGFuY2hvckRPTSkgPT09IGVkaXRvcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RFZGl0b3JGcm9tRE9NTm9kZShub2RlKSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG5cbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgIGNvbnN0IGVkaXRvciA9IGN1cnJlbnROb2RlLl9fbGV4aWNhbEVkaXRvcjtcblxuICAgIGlmIChlZGl0b3IgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICB9XG5cbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudEVsZW1lbnQoY3VycmVudE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRUZXh0RGlyZWN0aW9uKHRleHQpIHtcbiAgaWYgKFJUTF9SRUdFWC50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuICdydGwnO1xuICB9XG5cbiAgaWYgKExUUl9SRUdFWC50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuICdsdHInO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiAkaXNUb2tlbk9yU2VnbWVudGVkKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNUb2tlbigpIHx8IG5vZGUuaXNTZWdtZW50ZWQoKTtcbn1cblxuZnVuY3Rpb24gaXNET01Ob2RlTGV4aWNhbFRleHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IERPTV9URVhUX1RZUEU7XG59XG5cbmZ1bmN0aW9uIGdldERPTVRleHROb2RlKGVsZW1lbnQpIHtcbiAgbGV0IG5vZGUgPSBlbGVtZW50O1xuXG4gIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICBpZiAoaXNET01Ob2RlTGV4aWNhbFRleHROb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB0b2dnbGVUZXh0Rm9ybWF0VHlwZShmb3JtYXQsIHR5cGUsIGFsaWduV2l0aEZvcm1hdCkge1xuICBjb25zdCBhY3RpdmVGb3JtYXQgPSBURVhUX1RZUEVfVE9fRk9STUFUW3R5cGVdO1xuICBjb25zdCBpc1N0YXRlRmxhZ1ByZXNlbnQgPSBmb3JtYXQgJiBhY3RpdmVGb3JtYXQ7XG5cbiAgaWYgKGlzU3RhdGVGbGFnUHJlc2VudCAmJiAoYWxpZ25XaXRoRm9ybWF0ID09PSBudWxsIHx8IChhbGlnbldpdGhGb3JtYXQgJiBhY3RpdmVGb3JtYXQpID09PSAwKSkge1xuICAgIC8vIFJlbW92ZSB0aGUgc3RhdGUgZmxhZy5cbiAgICByZXR1cm4gZm9ybWF0IF4gYWN0aXZlRm9ybWF0O1xuICB9XG5cbiAgaWYgKGFsaWduV2l0aEZvcm1hdCA9PT0gbnVsbCB8fCBhbGlnbldpdGhGb3JtYXQgJiBhY3RpdmVGb3JtYXQpIHtcbiAgICAvLyBBZGQgdGhlIHN0YXRlIGZsYWcuXG4gICAgcmV0dXJuIGZvcm1hdCB8IGFjdGl2ZUZvcm1hdDtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXQ7XG59XG5mdW5jdGlvbiAkaXNMZWFmTm9kZShub2RlKSB7XG4gIHJldHVybiAkaXNUZXh0Tm9kZShub2RlKSB8fCAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpIHx8ICRpc0RlY29yYXRvck5vZGUobm9kZSk7XG59XG5mdW5jdGlvbiAkc2V0Tm9kZUtleShub2RlLCBleGlzdGluZ0tleSkge1xuICBpZiAoZXhpc3RpbmdLZXkgIT0gbnVsbCkge1xuICAgIG5vZGUuX19rZXkgPSBleGlzdGluZ0tleTtcbiAgICByZXR1cm47XG4gIH1cblxuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgZXJyb3JPbkluZmluaXRlVHJhbnNmb3JtcygpO1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBrZXkgPSBnZW5lcmF0ZVJhbmRvbUtleSgpO1xuXG4gIGVkaXRvclN0YXRlLl9ub2RlTWFwLnNldChrZXksIG5vZGUpOyAvLyBUT0RPIFNwbGl0IHRoaXMgZnVuY3Rpb24gaW50byBsZWFmL2VsZW1lbnRcblxuXG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGVkaXRvci5fZGlydHlFbGVtZW50cy5zZXQoa2V5LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBlZGl0b3IuX2RpcnR5TGVhdmVzLmFkZChrZXkpO1xuICB9XG5cbiAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZC5hZGQoa2V5KTtcblxuICBlZGl0b3IuX2RpcnR5VHlwZSA9IEhBU19ESVJUWV9OT0RFUztcbiAgbm9kZS5fX2tleSA9IGtleTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxNYXJrUGFyZW50RWxlbWVudHNBc0RpcnR5KHBhcmVudEtleSwgbm9kZU1hcCwgZGlydHlFbGVtZW50cykge1xuICBsZXQgbmV4dFBhcmVudEtleSA9IHBhcmVudEtleTtcblxuICB3aGlsZSAobmV4dFBhcmVudEtleSAhPT0gbnVsbCkge1xuICAgIGlmIChkaXJ0eUVsZW1lbnRzLmhhcyhuZXh0UGFyZW50S2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChuZXh0UGFyZW50S2V5KTtcblxuICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRpcnR5RWxlbWVudHMuc2V0KG5leHRQYXJlbnRLZXksIGZhbHNlKTtcbiAgICBuZXh0UGFyZW50S2V5ID0gbm9kZS5fX3BhcmVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVGcm9tUGFyZW50KG5vZGUpIHtcbiAgY29uc3Qgb2xkUGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcblxuICBpZiAob2xkUGFyZW50ICE9PSBudWxsKSB7XG4gICAgY29uc3Qgd3JpdGFibGVOb2RlID0gbm9kZS5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHdyaXRhYmxlUGFyZW50ID0gb2xkUGFyZW50LmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpOyAvLyBUT0RPOiB0aGlzIGZ1bmN0aW9uIGR1cGxpY2F0ZXMgYSBidW5jaCBvZiBvcGVyYXRpb25zLCBjYW4gYmUgc2ltcGxpZmllZC5cblxuICAgIGlmIChwcmV2U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlTmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZVBhcmVudC5fX2ZpcnN0ID0gbmV4dFNpYmxpbmcuX19rZXk7XG4gICAgICAgIHdyaXRhYmxlTmV4dFNpYmxpbmcuX19wcmV2ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRhYmxlUGFyZW50Ll9fZmlyc3QgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cml0YWJsZVByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcblxuICAgICAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlTmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IHdyaXRhYmxlUHJldlNpYmxpbmcuX19rZXk7XG4gICAgICAgIHdyaXRhYmxlUHJldlNpYmxpbmcuX19uZXh0ID0gd3JpdGFibGVOZXh0U2libGluZy5fX2tleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRhYmxlUHJldlNpYmxpbmcuX19uZXh0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgd3JpdGFibGVOb2RlLl9fcHJldiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAocHJldlNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlUGFyZW50Ll9fbGFzdCA9IHByZXZTaWJsaW5nLl9fa2V5O1xuICAgICAgICB3cml0YWJsZVByZXZTaWJsaW5nLl9fbmV4dCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0YWJsZVBhcmVudC5fX2xhc3QgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB3cml0YWJsZU5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcuZ2V0V3JpdGFibGUoKTtcblxuICAgICAgaWYgKHByZXZTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlUHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZVByZXZTaWJsaW5nLl9fbmV4dCA9IHdyaXRhYmxlTmV4dFNpYmxpbmcuX19rZXk7XG4gICAgICAgIHdyaXRhYmxlTmV4dFNpYmxpbmcuX19wcmV2ID0gd3JpdGFibGVQcmV2U2libGluZy5fX2tleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRhYmxlTmV4dFNpYmxpbmcuX19wcmV2ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgd3JpdGFibGVOb2RlLl9fbmV4dCA9IG51bGw7XG4gICAgfVxuXG4gICAgd3JpdGFibGVQYXJlbnQuX19zaXplLS07XG4gICAgd3JpdGFibGVOb2RlLl9fcGFyZW50ID0gbnVsbDtcbiAgfVxufSAvLyBOZXZlciB1c2UgdGhpcyBmdW5jdGlvbiBkaXJlY3RseSEgSXQgd2lsbCBicmVha1xuLy8gdGhlIGNsb25pbmcgaGV1cmlzdGljLiBJbnN0ZWFkIHVzZSBub2RlLmdldFdyaXRhYmxlKCkuXG5cbmZ1bmN0aW9uIGludGVybmFsTWFya05vZGVBc0RpcnR5KG5vZGUpIHtcbiAgZXJyb3JPbkluZmluaXRlVHJhbnNmb3JtcygpO1xuICBjb25zdCBsYXRlc3QgPSBub2RlLmdldExhdGVzdCgpO1xuICBjb25zdCBwYXJlbnQgPSBsYXRlc3QuX19wYXJlbnQ7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gZ2V0QWN0aXZlRWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgY29uc3QgZGlydHlFbGVtZW50cyA9IGVkaXRvci5fZGlydHlFbGVtZW50cztcblxuICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaW50ZXJuYWxNYXJrUGFyZW50RWxlbWVudHNBc0RpcnR5KHBhcmVudCwgbm9kZU1hcCwgZGlydHlFbGVtZW50cyk7XG4gIH1cblxuICBjb25zdCBrZXkgPSBsYXRlc3QuX19rZXk7XG4gIGVkaXRvci5fZGlydHlUeXBlID0gSEFTX0RJUlRZX05PREVTO1xuXG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGRpcnR5RWxlbWVudHMuc2V0KGtleSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVE9ETyBzcGxpdCBpbnRlcm5hbGx5IE1hcmtOb2RlQXNEaXJ0eSBpbnRvIHR3byBkZWRpY2F0ZWQgRWxlbWVudC9sZWF2ZSBmdW5jdGlvbnNcbiAgICBlZGl0b3IuX2RpcnR5TGVhdmVzLmFkZChrZXkpO1xuICB9XG59XG5mdW5jdGlvbiBpbnRlcm5hbE1hcmtTaWJsaW5nc0FzRGlydHkobm9kZSkge1xuICBjb25zdCBwcmV2aW91c05vZGUgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICBjb25zdCBuZXh0Tm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICBpZiAocHJldmlvdXNOb2RlICE9PSBudWxsKSB7XG4gICAgaW50ZXJuYWxNYXJrTm9kZUFzRGlydHkocHJldmlvdXNOb2RlKTtcbiAgfVxuXG4gIGlmIChuZXh0Tm9kZSAhPT0gbnVsbCkge1xuICAgIGludGVybmFsTWFya05vZGVBc0RpcnR5KG5leHROb2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gJHNldENvbXBvc2l0aW9uS2V5KGNvbXBvc2l0aW9uS2V5KSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgY29uc3QgcHJldmlvdXNDb21wb3NpdGlvbktleSA9IGVkaXRvci5fY29tcG9zaXRpb25LZXk7XG5cbiAgaWYgKGNvbXBvc2l0aW9uS2V5ICE9PSBwcmV2aW91c0NvbXBvc2l0aW9uS2V5KSB7XG4gICAgZWRpdG9yLl9jb21wb3NpdGlvbktleSA9IGNvbXBvc2l0aW9uS2V5O1xuXG4gICAgaWYgKHByZXZpb3VzQ29tcG9zaXRpb25LZXkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHByZXZpb3VzQ29tcG9zaXRpb25LZXkpO1xuXG4gICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmdldFdyaXRhYmxlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvc2l0aW9uS2V5ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShjb21wb3NpdGlvbktleSk7XG5cbiAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRnZXRDb21wb3NpdGlvbktleSgpIHtcbiAgaWYgKGlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICByZXR1cm4gZWRpdG9yLl9jb21wb3NpdGlvbktleTtcbn1cbmZ1bmN0aW9uICRnZXROb2RlQnlLZXkoa2V5LCBfZWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBfZWRpdG9yU3RhdGUgfHwgZ2V0QWN0aXZlRWRpdG9yU3RhdGUoKTtcblxuICBjb25zdCBub2RlID0gZWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KGtleSk7XG5cbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBnZXROb2RlRnJvbURPTU5vZGUoZG9tLCBlZGl0b3JTdGF0ZSkge1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTsgLy8gQHRzLWlnbm9yZSBXZSBpbnRlbnRpb25hbGx5IGFkZCB0aGlzIHRvIHRoZSBOb2RlLlxuXG4gIGNvbnN0IGtleSA9IGRvbVtgX19sZXhpY2FsS2V5XyR7ZWRpdG9yLl9rZXl9YF07XG5cbiAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICRnZXROb2RlQnlLZXkoa2V5LCBlZGl0b3JTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKHN0YXJ0aW5nRE9NLCBlZGl0b3JTdGF0ZSkge1xuICBsZXQgZG9tID0gc3RhcnRpbmdET007XG5cbiAgd2hpbGUgKGRvbSAhPSBudWxsKSB7XG4gICAgY29uc3Qgbm9kZSA9IGdldE5vZGVGcm9tRE9NTm9kZShkb20sIGVkaXRvclN0YXRlKTtcblxuICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBkb20gPSBnZXRQYXJlbnRFbGVtZW50KGRvbSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNsb25lRGVjb3JhdG9ycyhlZGl0b3IpIHtcbiAgY29uc3QgY3VycmVudERlY29yYXRvcnMgPSBlZGl0b3IuX2RlY29yYXRvcnM7XG4gIGNvbnN0IHBlbmRpbmdEZWNvcmF0b3JzID0gT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudERlY29yYXRvcnMpO1xuICBlZGl0b3IuX3BlbmRpbmdEZWNvcmF0b3JzID0gcGVuZGluZ0RlY29yYXRvcnM7XG4gIHJldHVybiBwZW5kaW5nRGVjb3JhdG9ycztcbn1cbmZ1bmN0aW9uIGdldEVkaXRvclN0YXRlVGV4dENvbnRlbnQoZWRpdG9yU3RhdGUpIHtcbiAgcmV0dXJuIGVkaXRvclN0YXRlLnJlYWQoKCkgPT4gJGdldFJvb3QoKS5nZXRUZXh0Q29udGVudCgpKTtcbn1cbmZ1bmN0aW9uIG1hcmtBbGxOb2Rlc0FzRGlydHkoZWRpdG9yLCB0eXBlKSB7XG4gIC8vIE1hcmsgYWxsIGV4aXN0aW5nIHRleHQgbm9kZXMgYXMgZGlydHlcbiAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgIGNvbnN0IGVkaXRvclN0YXRlID0gZ2V0QWN0aXZlRWRpdG9yU3RhdGUoKTtcblxuICAgIGlmIChlZGl0b3JTdGF0ZS5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3Jvb3QnKSB7XG4gICAgICAkZ2V0Um9vdCgpLm1hcmtEaXJ0eSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcblxuICAgIGZvciAoY29uc3QgWywgbm9kZV0gb2Ygbm9kZU1hcCkge1xuICAgICAgbm9kZS5tYXJrRGlydHkoKTtcbiAgICB9XG4gIH0sIGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlID09PSBudWxsID8ge1xuICAgIHRhZzogJ2hpc3RvcnktbWVyZ2UnXG4gIH0gOiB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gJGdldFJvb3QoKSB7XG4gIHJldHVybiBpbnRlcm5hbEdldFJvb3QoZ2V0QWN0aXZlRWRpdG9yU3RhdGUoKSk7XG59XG5mdW5jdGlvbiBpbnRlcm5hbEdldFJvb3QoZWRpdG9yU3RhdGUpIHtcbiAgcmV0dXJuIGVkaXRvclN0YXRlLl9ub2RlTWFwLmdldCgncm9vdCcpO1xufVxuZnVuY3Rpb24gJHNldFNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgZXJyb3JPblJlYWRPbmx5KCk7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gZ2V0QWN0aXZlRWRpdG9yU3RhdGUoKTtcblxuICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgJHNldFNlbGVjdGlvbiBjYWxsZWQgb24gZnJvemVuIHNlbGVjdGlvbiBvYmplY3QuIEVuc3VyZSBzZWxlY3Rpb24gaXMgY2xvbmVkIGJlZm9yZSBwYXNzaW5nIGluLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICBzZWxlY3Rpb24uX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgfVxuXG4gIGVkaXRvclN0YXRlLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiAkZmx1c2hNdXRhdGlvbnMoKSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgZmx1c2hSb290TXV0YXRpb25zKGVkaXRvcik7XG59XG5mdW5jdGlvbiBnZXROb2RlRnJvbURPTShkb20pIHtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IG5vZGVLZXkgPSBnZXROb2RlS2V5RnJvbURPTShkb20sIGVkaXRvcik7XG5cbiAgaWYgKG5vZGVLZXkgPT09IG51bGwpIHtcbiAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuXG4gICAgaWYgKGRvbSA9PT0gcm9vdEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAkZ2V0Tm9kZUJ5S2V5KCdyb290Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gJGdldE5vZGVCeUtleShub2RlS2V5KTtcbn1cbmZ1bmN0aW9uIGdldFRleHROb2RlT2Zmc2V0KG5vZGUsIG1vdmVTZWxlY3Rpb25Ub0VuZCkge1xuICByZXR1cm4gbW92ZVNlbGVjdGlvblRvRW5kID8gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSA6IDA7XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVLZXlGcm9tRE9NKCAvLyBOb3RlIHRoYXQgbm9kZSBoZXJlIHJlZmVycyB0byBhIERPTSBOb2RlLCBub3QgYW4gTGV4aWNhbCBOb2RlXG5kb20sIGVkaXRvcikge1xuICBsZXQgbm9kZSA9IGRvbTtcblxuICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgLy8gQHRzLWlnbm9yZSBXZSBpbnRlbnRpb25hbGx5IGFkZCB0aGlzIHRvIHRoZSBOb2RlLlxuICAgIGNvbnN0IGtleSA9IG5vZGVbYF9fbGV4aWNhbEtleV8ke2VkaXRvci5fa2V5fWBdO1xuXG4gICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRQYXJlbnRFbGVtZW50KG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRvZXNDb250YWluR3JhcGhlbWUoc3RyKSB7XG4gIHJldHVybiAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIGdldEVkaXRvcnNUb1Byb3BhZ2F0ZShlZGl0b3IpIHtcbiAgY29uc3QgZWRpdG9yc1RvUHJvcGFnYXRlID0gW107XG4gIGxldCBjdXJyZW50RWRpdG9yID0gZWRpdG9yO1xuXG4gIHdoaWxlIChjdXJyZW50RWRpdG9yICE9PSBudWxsKSB7XG4gICAgZWRpdG9yc1RvUHJvcGFnYXRlLnB1c2goY3VycmVudEVkaXRvcik7XG4gICAgY3VycmVudEVkaXRvciA9IGN1cnJlbnRFZGl0b3IuX3BhcmVudEVkaXRvcjtcbiAgfVxuXG4gIHJldHVybiBlZGl0b3JzVG9Qcm9wYWdhdGU7XG59XG5mdW5jdGlvbiBjcmVhdGVVSUQoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5yZXBsYWNlKC9bXmEtel0rL2csICcnKS5zdWJzdHIoMCwgNSk7XG59XG5mdW5jdGlvbiBnZXRBbmNob3JUZXh0RnJvbURPTShhbmNob3JOb2RlKSB7XG4gIGlmIChhbmNob3JOb2RlLm5vZGVUeXBlID09PSBET01fVEVYVF9UWVBFKSB7XG4gICAgcmV0dXJuIGFuY2hvck5vZGUubm9kZVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiAkdXBkYXRlU2VsZWN0ZWRUZXh0RnJvbURPTShpc0NvbXBvc2l0aW9uRW5kLCBlZGl0b3IsIGRhdGEpIHtcbiAgLy8gVXBkYXRlIHRoZSB0ZXh0IGNvbnRlbnQgd2l0aCB0aGUgbGF0ZXN0IGNvbXBvc2l0aW9uIHRleHRcbiAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcblxuICBpZiAoZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgYW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICBsZXQge1xuICAgIGFuY2hvck9mZnNldCxcbiAgICBmb2N1c09mZnNldFxuICB9ID0gZG9tU2VsZWN0aW9uO1xuXG4gIGlmIChhbmNob3JOb2RlICE9PSBudWxsKSB7XG4gICAgbGV0IHRleHRDb250ZW50ID0gZ2V0QW5jaG9yVGV4dEZyb21ET00oYW5jaG9yTm9kZSk7XG4gICAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGFuY2hvck5vZGUpO1xuXG4gICAgaWYgKHRleHRDb250ZW50ICE9PSBudWxsICYmICRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAvLyBEYXRhIGlzIGludGVudGlvbmFsbHkgdHJ1dGh5LCBhcyB3ZSBjaGVjayBmb3IgYm9vbGVhbiwgbnVsbCBhbmQgZW1wdHkgc3RyaW5nLlxuICAgICAgaWYgKHRleHRDb250ZW50ID09PSBDT01QT1NJVElPTl9TVUZGSVggJiYgZGF0YSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGV4dENvbnRlbnQgPSBkYXRhO1xuICAgICAgICBhbmNob3JPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGZvY3VzT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dENvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgJHVwZGF0ZVRleHROb2RlRnJvbURPTUNvbnRlbnQobm9kZSwgdGV4dENvbnRlbnQsIGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQsIGlzQ29tcG9zaXRpb25FbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJHVwZGF0ZVRleHROb2RlRnJvbURPTUNvbnRlbnQodGV4dE5vZGUsIHRleHRDb250ZW50LCBhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0LCBjb21wb3NpdGlvbkVuZCkge1xuICBsZXQgbm9kZSA9IHRleHROb2RlO1xuXG4gIGlmIChub2RlLmlzQXR0YWNoZWQoKSAmJiAoY29tcG9zaXRpb25FbmQgfHwgIW5vZGUuaXNEaXJ0eSgpKSkge1xuICAgIGNvbnN0IGlzQ29tcG9zaW5nID0gbm9kZS5pc0NvbXBvc2luZygpO1xuICAgIGxldCBub3JtYWxpemVkVGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudDtcblxuICAgIGlmICgoaXNDb21wb3NpbmcgfHwgY29tcG9zaXRpb25FbmQpICYmIHRleHRDb250ZW50W3RleHRDb250ZW50Lmxlbmd0aCAtIDFdID09PSBDT01QT1NJVElPTl9TVUZGSVgpIHtcbiAgICAgIG5vcm1hbGl6ZWRUZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDAsIC0xKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2VGV4dENvbnRlbnQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG5cbiAgICBpZiAoY29tcG9zaXRpb25FbmQgfHwgbm9ybWFsaXplZFRleHRDb250ZW50ICE9PSBwcmV2VGV4dENvbnRlbnQpIHtcbiAgICAgIGlmIChub3JtYWxpemVkVGV4dENvbnRlbnQgPT09ICcnKSB7XG4gICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcblxuICAgICAgICBpZiAoIUlTX1NBRkFSSSAmJiAhSVNfSU9TICYmICFJU19BUFBMRV9XRUJLSVQpIHtcbiAgICAgICAgICAvLyBGb3IgY29tcG9zaXRpb24gKG1haW5seSBBbmRyb2lkKSwgd2UgaGF2ZSB0byByZW1vdmUgdGhlIG5vZGUgb24gYSBsYXRlciB1cGRhdGVcbiAgICAgICAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAobm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAyMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgICAgIGNvbnN0IHByZXZUZXh0Q29udGVudFNpemUgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgY29uc3QgY29tcG9zaXRpb25LZXkgPSAkZ2V0Q29tcG9zaXRpb25LZXkoKTtcbiAgICAgIGNvbnN0IG5vZGVLZXkgPSBub2RlLmdldEtleSgpO1xuXG4gICAgICBpZiAobm9kZS5pc1Rva2VuKCkgfHwgY29tcG9zaXRpb25LZXkgIT09IG51bGwgJiYgbm9kZUtleSA9PT0gY29tcG9zaXRpb25LZXkgJiYgIWlzQ29tcG9zaW5nIHx8IC8vIENoZWNrIGlmIGNoYXJhY3RlciB3YXMgYWRkZWQgYXQgdGhlIHN0YXJ0IG9yIGJvdW5kYXJpZXMgd2hlbiBub3QgaW5zZXJ0YWJsZSwgYW5kIHdlIG5lZWRcbiAgICAgIC8vIHRvIGNsZWFyIHRoaXMgaW5wdXQgZnJvbSBvY2N1cnJpbmcgYXMgdGhhdCBhY3Rpb24gd2Fzbid0IHBlcm1pdHRlZC5cbiAgICAgICRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIChwYXJlbnQgIT09IG51bGwgJiYgIXBhcmVudC5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgJiYgcHJldlNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSAwIHx8IHByZXZTZWxlY3Rpb24uYW5jaG9yLmtleSA9PT0gdGV4dE5vZGUuX19rZXkgJiYgcHJldlNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0ID09PSAwICYmICFub2RlLmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCBwcmV2U2VsZWN0aW9uLmZvY3VzLmtleSA9PT0gdGV4dE5vZGUuX19rZXkgJiYgcHJldlNlbGVjdGlvbi5mb2N1cy5vZmZzZXQgPT09IHByZXZUZXh0Q29udGVudFNpemUgJiYgIW5vZGUuY2FuSW5zZXJ0VGV4dEFmdGVyKCkpKSB7XG4gICAgICAgIG5vZGUubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgYW5jaG9yT2Zmc2V0ID09PSBudWxsIHx8IGZvY3VzT2Zmc2V0ID09PSBudWxsKSB7XG4gICAgICAgIG5vZGUuc2V0VGV4dENvbnRlbnQobm9ybWFsaXplZFRleHRDb250ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3Rpb24uc2V0VGV4dE5vZGVSYW5nZShub2RlLCBhbmNob3JPZmZzZXQsIG5vZGUsIGZvY3VzT2Zmc2V0KTtcblxuICAgICAgaWYgKG5vZGUuaXNTZWdtZW50ZWQoKSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9ICRjcmVhdGVUZXh0Tm9kZShvcmlnaW5hbFRleHRDb250ZW50KTtcbiAgICAgICAgbm9kZS5yZXBsYWNlKHJlcGxhY2VtZW50KTtcbiAgICAgICAgbm9kZSA9IHJlcGxhY2VtZW50O1xuICAgICAgfVxuXG4gICAgICBub2RlLnNldFRleHRDb250ZW50KG5vcm1hbGl6ZWRUZXh0Q29udGVudCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uICRwcmV2aW91c1NpYmxpbmdEb2VzTm90QWNjZXB0VGV4dChub2RlKSB7XG4gIGNvbnN0IHByZXZpb3VzU2libGluZyA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gIHJldHVybiAoJGlzVGV4dE5vZGUocHJldmlvdXNTaWJsaW5nKSB8fCAkaXNFbGVtZW50Tm9kZShwcmV2aW91c1NpYmxpbmcpICYmIHByZXZpb3VzU2libGluZy5pc0lubGluZSgpKSAmJiAhcHJldmlvdXNTaWJsaW5nLmNhbkluc2VydFRleHRBZnRlcigpO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNvbm5lY3RlZCB0byAkc2hvdWxkUHJldmVudERlZmF1bHRBbmRJbnNlcnRUZXh0IGFuZCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlXG4vLyBUZXh0Tm9kZSBib3VuZGFyaWVzIGFyZSB3cml0YWJsZSBvciB3ZSBzaG91bGQgdXNlIHRoZSBwcmV2aW91cy9uZXh0IHNpYmxpbmcgaW5zdGVhZC4gRm9yIGV4YW1wbGUsXG4vLyBpbiB0aGUgY2FzZSBvZiBhIExpbmtOb2RlLCBib3VuZGFyaWVzIGFyZSBub3Qgd3JpdGFibGUuXG5cblxuZnVuY3Rpb24gJHNob3VsZEluc2VydFRleHRBZnRlck9yQmVmb3JlVGV4dE5vZGUoc2VsZWN0aW9uLCBub2RlKSB7XG4gIGlmIChub2RlLmlzU2VnbWVudGVkKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBvZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIGNvbnN0IGlzVG9rZW4gPSBub2RlLmlzVG9rZW4oKTtcblxuICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgcmV0dXJuICFub2RlLmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAhcGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCBpc1Rva2VuIHx8ICRwcmV2aW91c1NpYmxpbmdEb2VzTm90QWNjZXB0VGV4dChub2RlKTtcbiAgfSBlbHNlIGlmIChvZmZzZXQgPT09IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICByZXR1cm4gIW5vZGUuY2FuSW5zZXJ0VGV4dEFmdGVyKCkgfHwgIXBhcmVudC5jYW5JbnNlcnRUZXh0QWZ0ZXIoKSB8fCBpc1Rva2VuO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNUYWIoa2V5Q29kZSwgYWx0S2V5LCBjdHJsS2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBrZXlDb2RlID09PSA5ICYmICFhbHRLZXkgJiYgIWN0cmxLZXkgJiYgIW1ldGFLZXk7XG59XG5mdW5jdGlvbiBpc0JvbGQoa2V5Q29kZSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBrZXlDb2RlID09PSA2NiAmJiAhYWx0S2V5ICYmIGNvbnRyb2xPck1ldGEobWV0YUtleSwgY3RybEtleSk7XG59XG5mdW5jdGlvbiBpc0l0YWxpYyhrZXlDb2RlLCBhbHRLZXksIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgcmV0dXJuIGtleUNvZGUgPT09IDczICYmICFhbHRLZXkgJiYgY29udHJvbE9yTWV0YShtZXRhS2V5LCBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uIGlzVW5kZXJsaW5lKGtleUNvZGUsIGFsdEtleSwgbWV0YUtleSwgY3RybEtleSkge1xuICByZXR1cm4ga2V5Q29kZSA9PT0gODUgJiYgIWFsdEtleSAmJiBjb250cm9sT3JNZXRhKG1ldGFLZXksIGN0cmxLZXkpO1xufVxuZnVuY3Rpb24gaXNQYXJhZ3JhcGgoa2V5Q29kZSwgc2hpZnRLZXkpIHtcbiAgcmV0dXJuIGlzUmV0dXJuKGtleUNvZGUpICYmICFzaGlmdEtleTtcbn1cbmZ1bmN0aW9uIGlzTGluZUJyZWFrKGtleUNvZGUsIHNoaWZ0S2V5KSB7XG4gIHJldHVybiBpc1JldHVybihrZXlDb2RlKSAmJiBzaGlmdEtleTtcbn0gLy8gSW5zZXJ0cyBhIG5ldyBsaW5lIGFmdGVyIHRoZSBzZWxlY3Rpb25cblxuZnVuY3Rpb24gaXNPcGVuTGluZUJyZWFrKGtleUNvZGUsIGN0cmxLZXkpIHtcbiAgLy8gNzkgPSBLZXlPXG4gIHJldHVybiBJU19BUFBMRSAmJiBjdHJsS2V5ICYmIGtleUNvZGUgPT09IDc5O1xufVxuZnVuY3Rpb24gaXNEZWxldGVXb3JkQmFja3dhcmQoa2V5Q29kZSwgYWx0S2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBpc0JhY2tzcGFjZShrZXlDb2RlKSAmJiAoSVNfQVBQTEUgPyBhbHRLZXkgOiBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlV29yZEZvcndhcmQoa2V5Q29kZSwgYWx0S2V5LCBjdHJsS2V5KSB7XG4gIHJldHVybiBpc0RlbGV0ZShrZXlDb2RlKSAmJiAoSVNfQVBQTEUgPyBhbHRLZXkgOiBjdHJsS2V5KTtcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlTGluZUJhY2t3YXJkKGtleUNvZGUsIG1ldGFLZXkpIHtcbiAgcmV0dXJuIElTX0FQUExFICYmIG1ldGFLZXkgJiYgaXNCYWNrc3BhY2Uoa2V5Q29kZSk7XG59XG5mdW5jdGlvbiBpc0RlbGV0ZUxpbmVGb3J3YXJkKGtleUNvZGUsIG1ldGFLZXkpIHtcbiAgcmV0dXJuIElTX0FQUExFICYmIG1ldGFLZXkgJiYgaXNEZWxldGUoa2V5Q29kZSk7XG59XG5mdW5jdGlvbiBpc0RlbGV0ZUJhY2t3YXJkKGtleUNvZGUsIGFsdEtleSwgbWV0YUtleSwgY3RybEtleSkge1xuICBpZiAoSVNfQVBQTEUpIHtcbiAgICBpZiAoYWx0S2V5IHx8IG1ldGFLZXkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNCYWNrc3BhY2Uoa2V5Q29kZSkgfHwga2V5Q29kZSA9PT0gNzIgJiYgY3RybEtleTtcbiAgfVxuXG4gIGlmIChjdHJsS2V5IHx8IGFsdEtleSB8fCBtZXRhS2V5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzQmFja3NwYWNlKGtleUNvZGUpO1xufVxuZnVuY3Rpb24gaXNEZWxldGVGb3J3YXJkKGtleUNvZGUsIGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpIHtcbiAgaWYgKElTX0FQUExFKSB7XG4gICAgaWYgKHNoaWZ0S2V5IHx8IGFsdEtleSB8fCBtZXRhS2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRGVsZXRlKGtleUNvZGUpIHx8IGtleUNvZGUgPT09IDY4ICYmIGN0cmxLZXk7XG4gIH1cblxuICBpZiAoY3RybEtleSB8fCBhbHRLZXkgfHwgbWV0YUtleSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0RlbGV0ZShrZXlDb2RlKTtcbn1cbmZ1bmN0aW9uIGlzVW5kbyhrZXlDb2RlLCBzaGlmdEtleSwgbWV0YUtleSwgY3RybEtleSkge1xuICByZXR1cm4ga2V5Q29kZSA9PT0gOTAgJiYgIXNoaWZ0S2V5ICYmIGNvbnRyb2xPck1ldGEobWV0YUtleSwgY3RybEtleSk7XG59XG5mdW5jdGlvbiBpc1JlZG8oa2V5Q29kZSwgc2hpZnRLZXksIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgaWYgKElTX0FQUExFKSB7XG4gICAgcmV0dXJuIGtleUNvZGUgPT09IDkwICYmIG1ldGFLZXkgJiYgc2hpZnRLZXk7XG4gIH1cblxuICByZXR1cm4ga2V5Q29kZSA9PT0gODkgJiYgY3RybEtleSB8fCBrZXlDb2RlID09PSA5MCAmJiBjdHJsS2V5ICYmIHNoaWZ0S2V5O1xufVxuZnVuY3Rpb24gaXNDb3B5KGtleUNvZGUsIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSB7XG4gIGlmIChzaGlmdEtleSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChrZXlDb2RlID09PSA2Nykge1xuICAgIHJldHVybiBJU19BUFBMRSA/IG1ldGFLZXkgOiBjdHJsS2V5O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDdXQoa2V5Q29kZSwgc2hpZnRLZXksIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgaWYgKHNoaWZ0S2V5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGtleUNvZGUgPT09IDg4KSB7XG4gICAgcmV0dXJuIElTX0FQUExFID8gbWV0YUtleSA6IGN0cmxLZXk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzQXJyb3dMZWZ0KGtleUNvZGUpIHtcbiAgcmV0dXJuIGtleUNvZGUgPT09IDM3O1xufVxuXG5mdW5jdGlvbiBpc0Fycm93UmlnaHQoa2V5Q29kZSkge1xuICByZXR1cm4ga2V5Q29kZSA9PT0gMzk7XG59XG5cbmZ1bmN0aW9uIGlzQXJyb3dVcChrZXlDb2RlKSB7XG4gIHJldHVybiBrZXlDb2RlID09PSAzODtcbn1cblxuZnVuY3Rpb24gaXNBcnJvd0Rvd24oa2V5Q29kZSkge1xuICByZXR1cm4ga2V5Q29kZSA9PT0gNDA7XG59XG5cbmZ1bmN0aW9uIGlzTW92ZUJhY2t3YXJkKGtleUNvZGUsIGN0cmxLZXksIGFsdEtleSwgbWV0YUtleSkge1xuICByZXR1cm4gaXNBcnJvd0xlZnQoa2V5Q29kZSkgJiYgIWN0cmxLZXkgJiYgIW1ldGFLZXkgJiYgIWFsdEtleTtcbn1cbmZ1bmN0aW9uIGlzTW92ZVRvU3RhcnQoa2V5Q29kZSwgY3RybEtleSwgc2hpZnRLZXksIGFsdEtleSwgbWV0YUtleSkge1xuICByZXR1cm4gaXNBcnJvd0xlZnQoa2V5Q29kZSkgJiYgIWFsdEtleSAmJiAhc2hpZnRLZXkgJiYgKGN0cmxLZXkgfHwgbWV0YUtleSk7XG59XG5mdW5jdGlvbiBpc01vdmVGb3J3YXJkKGtleUNvZGUsIGN0cmxLZXksIGFsdEtleSwgbWV0YUtleSkge1xuICByZXR1cm4gaXNBcnJvd1JpZ2h0KGtleUNvZGUpICYmICFjdHJsS2V5ICYmICFtZXRhS2V5ICYmICFhbHRLZXk7XG59XG5mdW5jdGlvbiBpc01vdmVUb0VuZChrZXlDb2RlLCBjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBpc0Fycm93UmlnaHQoa2V5Q29kZSkgJiYgIWFsdEtleSAmJiAhc2hpZnRLZXkgJiYgKGN0cmxLZXkgfHwgbWV0YUtleSk7XG59XG5mdW5jdGlvbiBpc01vdmVVcChrZXlDb2RlLCBjdHJsS2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBpc0Fycm93VXAoa2V5Q29kZSkgJiYgIWN0cmxLZXkgJiYgIW1ldGFLZXk7XG59XG5mdW5jdGlvbiBpc01vdmVEb3duKGtleUNvZGUsIGN0cmxLZXksIG1ldGFLZXkpIHtcbiAgcmV0dXJuIGlzQXJyb3dEb3duKGtleUNvZGUpICYmICFjdHJsS2V5ICYmICFtZXRhS2V5O1xufVxuZnVuY3Rpb24gaXNNb2RpZmllcihjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSB7XG4gIHJldHVybiBjdHJsS2V5IHx8IHNoaWZ0S2V5IHx8IGFsdEtleSB8fCBtZXRhS2V5O1xufVxuZnVuY3Rpb24gaXNTcGFjZShrZXlDb2RlKSB7XG4gIHJldHVybiBrZXlDb2RlID09PSAzMjtcbn1cbmZ1bmN0aW9uIGNvbnRyb2xPck1ldGEobWV0YUtleSwgY3RybEtleSkge1xuICBpZiAoSVNfQVBQTEUpIHtcbiAgICByZXR1cm4gbWV0YUtleTtcbiAgfVxuXG4gIHJldHVybiBjdHJsS2V5O1xufVxuZnVuY3Rpb24gaXNSZXR1cm4oa2V5Q29kZSkge1xuICByZXR1cm4ga2V5Q29kZSA9PT0gMTM7XG59XG5mdW5jdGlvbiBpc0JhY2tzcGFjZShrZXlDb2RlKSB7XG4gIHJldHVybiBrZXlDb2RlID09PSA4O1xufVxuZnVuY3Rpb24gaXNFc2NhcGUoa2V5Q29kZSkge1xuICByZXR1cm4ga2V5Q29kZSA9PT0gMjc7XG59XG5mdW5jdGlvbiBpc0RlbGV0ZShrZXlDb2RlKSB7XG4gIHJldHVybiBrZXlDb2RlID09PSA0Njtcbn1cbmZ1bmN0aW9uIGlzU2VsZWN0QWxsKGtleUNvZGUsIG1ldGFLZXksIGN0cmxLZXkpIHtcbiAgcmV0dXJuIGtleUNvZGUgPT09IDY1ICYmIGNvbnRyb2xPck1ldGEobWV0YUtleSwgY3RybEtleSk7XG59XG5mdW5jdGlvbiAkc2VsZWN0QWxsKCkge1xuICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgY29uc3Qgc2VsZWN0aW9uID0gcm9vdC5zZWxlY3QoMCwgcm9vdC5nZXRDaGlsZHJlblNpemUoKSk7XG4gICRzZXRTZWxlY3Rpb24oJG5vcm1hbGl6ZVNlbGVjdGlvbihzZWxlY3Rpb24pKTtcbn1cbmZ1bmN0aW9uIGdldENhY2hlZENsYXNzTmFtZUFycmF5KGNsYXNzTmFtZXNUaGVtZSwgY2xhc3NOYW1lVGhlbWVUeXBlKSB7XG4gIGlmIChjbGFzc05hbWVzVGhlbWUuX19sZXhpY2FsQ2xhc3NOYW1lQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsYXNzTmFtZXNUaGVtZS5fX2xleGljYWxDbGFzc05hbWVDYWNoZSA9IHt9O1xuICB9XG5cbiAgY29uc3QgY2xhc3NOYW1lc0NhY2hlID0gY2xhc3NOYW1lc1RoZW1lLl9fbGV4aWNhbENsYXNzTmFtZUNhY2hlO1xuICBjb25zdCBjYWNoZWRDbGFzc05hbWVzID0gY2xhc3NOYW1lc0NhY2hlW2NsYXNzTmFtZVRoZW1lVHlwZV07XG5cbiAgaWYgKGNhY2hlZENsYXNzTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjYWNoZWRDbGFzc05hbWVzO1xuICB9XG5cbiAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXNUaGVtZVtjbGFzc05hbWVUaGVtZVR5cGVdOyAvLyBBcyB3ZSdyZSB1c2luZyBjbGFzc0xpc3QsIHdlIG5lZWRcbiAgLy8gdG8gaGFuZGxlIGNsYXNzTmFtZSB0b2tlbnMgdGhhdCBoYXZlIHNwYWNlcy5cbiAgLy8gVGhlIGVhc2llc3Qgd2F5IHRvIGRvIHRoaXMgdG8gY29udmVydCB0aGVcbiAgLy8gY2xhc3NOYW1lIHRva2VucyB0byBhbiBhcnJheSB0aGF0IGNhbiBiZVxuICAvLyBhcHBsaWVkIHRvIGNsYXNzTGlzdC5hZGQoKS9yZW1vdmUoKS5cblxuICBpZiAodHlwZW9mIGNsYXNzTmFtZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lc0FyciA9IGNsYXNzTmFtZXMuc3BsaXQoJyAnKTtcbiAgICBjbGFzc05hbWVzQ2FjaGVbY2xhc3NOYW1lVGhlbWVUeXBlXSA9IGNsYXNzTmFtZXNBcnI7XG4gICAgcmV0dXJuIGNsYXNzTmFtZXNBcnI7XG4gIH1cblxuICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIHNldE11dGF0ZWROb2RlKG11dGF0ZWROb2RlcywgcmVnaXN0ZXJlZE5vZGVzLCBtdXRhdGlvbkxpc3RlbmVycywgbm9kZSwgbXV0YXRpb24pIHtcbiAgaWYgKG11dGF0aW9uTGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBub2RlVHlwZSA9IG5vZGUuX190eXBlO1xuICBjb25zdCBub2RlS2V5ID0gbm9kZS5fX2tleTtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSByZWdpc3RlcmVkTm9kZXMuZ2V0KG5vZGVUeXBlKTtcblxuICBpZiAocmVnaXN0ZXJlZE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBUeXBlICR7bm9kZVR5cGV9IG5vdCBpbiByZWdpc3RlcmVkTm9kZXNgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBrbGFzcyA9IHJlZ2lzdGVyZWROb2RlLmtsYXNzO1xuICBsZXQgbXV0YXRlZE5vZGVzQnlUeXBlID0gbXV0YXRlZE5vZGVzLmdldChrbGFzcyk7XG5cbiAgaWYgKG11dGF0ZWROb2Rlc0J5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbXV0YXRlZE5vZGVzQnlUeXBlID0gbmV3IE1hcCgpO1xuICAgIG11dGF0ZWROb2Rlcy5zZXQoa2xhc3MsIG11dGF0ZWROb2Rlc0J5VHlwZSk7XG4gIH1cblxuICBjb25zdCBwcmV2TXV0YXRpb24gPSBtdXRhdGVkTm9kZXNCeVR5cGUuZ2V0KG5vZGVLZXkpOyAvLyBJZiB0aGUgbm9kZSBoYXMgYWxyZWFkeSBiZWVuIFwiZGVzdHJveWVkXCIsIHlldCB3ZSBhcmVcbiAgLy8gcmUtbWFraW5nIGl0LCB0aGVuIHRoaXMgbWVhbnMgYSBtb3ZlIGxpa2VseSBoYXBwZW5lZC5cbiAgLy8gV2Ugc2hvdWxkIGNoYW5nZSB0aGUgbXV0YXRpb24gdG8gYmUgdGhhdCBvZiBcInVwZGF0ZWRcIlxuICAvLyBpbnN0ZWFkLlxuXG4gIGNvbnN0IGlzTW92ZSA9IHByZXZNdXRhdGlvbiA9PT0gJ2Rlc3Ryb3llZCcgJiYgbXV0YXRpb24gPT09ICdjcmVhdGVkJztcblxuICBpZiAocHJldk11dGF0aW9uID09PSB1bmRlZmluZWQgfHwgaXNNb3ZlKSB7XG4gICAgbXV0YXRlZE5vZGVzQnlUeXBlLnNldChub2RlS2V5LCBpc01vdmUgPyAndXBkYXRlZCcgOiBtdXRhdGlvbik7XG4gIH1cbn1cbmZ1bmN0aW9uICRub2Rlc09mVHlwZShrbGFzcykge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IHJlYWRPbmx5ID0gZWRpdG9yU3RhdGUuX3JlYWRPbmx5O1xuICBjb25zdCBrbGFzc1R5cGUgPSBrbGFzcy5nZXRUeXBlKCk7XG4gIGNvbnN0IG5vZGVzID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IG5vZGVzT2ZUeXBlID0gW107XG5cbiAgZm9yIChjb25zdCBbLCBub2RlXSBvZiBub2Rlcykge1xuICAgIGlmIChub2RlIGluc3RhbmNlb2Yga2xhc3MgJiYgbm9kZS5fX3R5cGUgPT09IGtsYXNzVHlwZSAmJiAocmVhZE9ubHkgfHwgbm9kZS5pc0F0dGFjaGVkKCkpKSB7XG4gICAgICBub2Rlc09mVHlwZS5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2Rlc09mVHlwZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUVsZW1lbnQoZWxlbWVudCwgaXNCYWNrd2FyZCwgZm9jdXNPZmZzZXQpIHtcbiAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5nZXRQYXJlbnQoKTtcbiAgbGV0IG9mZnNldCA9IGZvY3VzT2Zmc2V0O1xuICBsZXQgYmxvY2sgPSBlbGVtZW50O1xuXG4gIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoaXNCYWNrd2FyZCAmJiBmb2N1c09mZnNldCA9PT0gMCkge1xuICAgICAgb2Zmc2V0ID0gYmxvY2suZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgIGJsb2NrID0gcGFyZW50O1xuICAgIH0gZWxzZSBpZiAoIWlzQmFja3dhcmQgJiYgZm9jdXNPZmZzZXQgPT09IGJsb2NrLmdldENoaWxkcmVuU2l6ZSgpKSB7XG4gICAgICBvZmZzZXQgPSBibG9jay5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgMTtcbiAgICAgIGJsb2NrID0gcGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBibG9jay5nZXRDaGlsZEF0SW5kZXgoaXNCYWNrd2FyZCA/IG9mZnNldCAtIDEgOiBvZmZzZXQpO1xufVxuXG5mdW5jdGlvbiAkZ2V0QWRqYWNlbnROb2RlKGZvY3VzLCBpc0JhY2t3YXJkKSB7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuXG4gIGlmIChmb2N1cy50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICBjb25zdCBibG9jayA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICByZXR1cm4gcmVzb2x2ZUVsZW1lbnQoYmxvY2ssIGlzQmFja3dhcmQsIGZvY3VzT2Zmc2V0KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG5cbiAgICBpZiAoaXNCYWNrd2FyZCAmJiBmb2N1c09mZnNldCA9PT0gMCB8fCAhaXNCYWNrd2FyZCAmJiBmb2N1c09mZnNldCA9PT0gZm9jdXNOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICBjb25zdCBwb3NzaWJsZU5vZGUgPSBpc0JhY2t3YXJkID8gZm9jdXNOb2RlLmdldFByZXZpb3VzU2libGluZygpIDogZm9jdXNOb2RlLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICAgIGlmIChwb3NzaWJsZU5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVFbGVtZW50KGZvY3VzTm9kZS5nZXRQYXJlbnRPclRocm93KCksIGlzQmFja3dhcmQsIGZvY3VzTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgKGlzQmFja3dhcmQgPyAwIDogMSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zc2libGVOb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNGaXJlZm94Q2xpcGJvYXJkRXZlbnRzKGVkaXRvcikge1xuICBjb25zdCBldmVudCA9IGdldFdpbmRvdyhlZGl0b3IpLmV2ZW50O1xuICBjb25zdCBpbnB1dFR5cGUgPSBldmVudCAmJiBldmVudC5pbnB1dFR5cGU7XG4gIHJldHVybiBpbnB1dFR5cGUgPT09ICdpbnNlcnRGcm9tUGFzdGUnIHx8IGlucHV0VHlwZSA9PT0gJ2luc2VydEZyb21QYXN0ZUFzUXVvdGF0aW9uJztcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIGNvbW1hbmQsIHBheWxvYWQpIHtcbiAgcmV0dXJuIHRyaWdnZXJDb21tYW5kTGlzdGVuZXJzKGVkaXRvciwgY29tbWFuZCwgcGF5bG9hZCk7XG59XG5mdW5jdGlvbiAkdGV4dENvbnRlbnRSZXF1aXJlc0RvdWJsZUxpbmVicmVha0F0RW5kKG5vZGUpIHtcbiAgcmV0dXJuICEkaXNSb290Tm9kZShub2RlKSAmJiAhbm9kZS5pc0xhc3RDaGlsZCgpICYmICFub2RlLmlzSW5saW5lKCk7XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50QnlLZXlPclRocm93KGVkaXRvciwga2V5KSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBlZGl0b3IuX2tleVRvRE9NTWFwLmdldChrZXkpO1xuXG4gIGlmIChlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgUmVjb25jaWxpYXRpb246IGNvdWxkIG5vdCBmaW5kIERPTSBlbGVtZW50IGZvciBub2RlIGtleSAke2tleX1gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudEVsZW1lbnQobm9kZSkge1xuICBjb25zdCBwYXJlbnRFbGVtZW50ID0gbm9kZS5hc3NpZ25lZFNsb3QgfHwgbm9kZS5wYXJlbnRFbGVtZW50O1xuICByZXR1cm4gcGFyZW50RWxlbWVudCAhPT0gbnVsbCAmJiBwYXJlbnRFbGVtZW50Lm5vZGVUeXBlID09PSAxMSA/IHBhcmVudEVsZW1lbnQuaG9zdCA6IHBhcmVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlld0lmTmVlZGVkKGVkaXRvciwgc2VsZWN0aW9uUmVjdCwgcm9vdEVsZW1lbnQpIHtcbiAgY29uc3QgZG9jID0gcm9vdEVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgY29uc3QgZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXc7XG5cbiAgaWYgKGRlZmF1bHRWaWV3ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IHtcbiAgICB0b3A6IGN1cnJlbnRUb3AsXG4gICAgYm90dG9tOiBjdXJyZW50Qm90dG9tXG4gIH0gPSBzZWxlY3Rpb25SZWN0O1xuICBsZXQgdGFyZ2V0VG9wID0gMDtcbiAgbGV0IHRhcmdldEJvdHRvbSA9IDA7XG4gIGxldCBlbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG5cbiAgd2hpbGUgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICBjb25zdCBpc0JvZHlFbGVtZW50ID0gZWxlbWVudCA9PT0gZG9jLmJvZHk7XG5cbiAgICBpZiAoaXNCb2R5RWxlbWVudCkge1xuICAgICAgdGFyZ2V0VG9wID0gMDtcbiAgICAgIHRhcmdldEJvdHRvbSA9IGdldFdpbmRvdyhlZGl0b3IpLmlubmVySGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRhcmdldFRvcCA9IHRhcmdldFJlY3QudG9wO1xuICAgICAgdGFyZ2V0Qm90dG9tID0gdGFyZ2V0UmVjdC5ib3R0b207XG4gICAgfVxuXG4gICAgbGV0IGRpZmYgPSAwO1xuXG4gICAgaWYgKGN1cnJlbnRUb3AgPCB0YXJnZXRUb3ApIHtcbiAgICAgIGRpZmYgPSAtKHRhcmdldFRvcCAtIGN1cnJlbnRUb3ApO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEJvdHRvbSA+IHRhcmdldEJvdHRvbSkge1xuICAgICAgZGlmZiA9IGN1cnJlbnRCb3R0b20gLSB0YXJnZXRCb3R0b207XG4gICAgfVxuXG4gICAgaWYgKGRpZmYgIT09IDApIHtcbiAgICAgIGlmIChpc0JvZHlFbGVtZW50KSB7XG4gICAgICAgIC8vIE9ubHkgaGFuZGxlcyBzY3JvbGxpbmcgb2YgWSBheGlzXG4gICAgICAgIGRlZmF1bHRWaWV3LnNjcm9sbEJ5KDAsIGRpZmYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wICs9IGRpZmY7XG4gICAgICAgIGNvbnN0IHlPZmZzZXQgPSBlbGVtZW50LnNjcm9sbFRvcCAtIHNjcm9sbFRvcDtcbiAgICAgICAgY3VycmVudFRvcCAtPSB5T2Zmc2V0O1xuICAgICAgICBjdXJyZW50Qm90dG9tIC09IHlPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQm9keUVsZW1lbnQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBnZXRQYXJlbnRFbGVtZW50KGVsZW1lbnQpO1xuICB9XG59XG5mdW5jdGlvbiAkaGFzVXBkYXRlVGFnKHRhZykge1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgcmV0dXJuIGVkaXRvci5fdXBkYXRlVGFncy5oYXModGFnKTtcbn1cbmZ1bmN0aW9uICRhZGRVcGRhdGVUYWcodGFnKSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcblxuICBlZGl0b3IuX3VwZGF0ZVRhZ3MuYWRkKHRhZyk7XG59XG5mdW5jdGlvbiAkbWF5YmVNb3ZlQ2hpbGRyZW5TZWxlY3Rpb25Ub1BhcmVudChwYXJlbnROb2RlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgISRpc0VsZW1lbnROb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBhbmNob3IsXG4gICAgZm9jdXNcbiAgfSA9IHNlbGVjdGlvbjtcbiAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcblxuICBpZiAoJGhhc0FuY2VzdG9yKGFuY2hvck5vZGUsIHBhcmVudE5vZGUpKSB7XG4gICAgYW5jaG9yLnNldChwYXJlbnROb2RlLl9fa2V5LCAwLCAnZWxlbWVudCcpO1xuICB9XG5cbiAgaWYgKCRoYXNBbmNlc3Rvcihmb2N1c05vZGUsIHBhcmVudE5vZGUpKSB7XG4gICAgZm9jdXMuc2V0KHBhcmVudE5vZGUuX19rZXksIDAsICdlbGVtZW50Jyk7XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJGhhc0FuY2VzdG9yKGNoaWxkLCB0YXJnZXROb2RlKSB7XG4gIGxldCBwYXJlbnQgPSBjaGlsZC5nZXRQYXJlbnQoKTtcblxuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKHBhcmVudC5pcyh0YXJnZXROb2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFZpZXcoZG9tRWxlbSkge1xuICBjb25zdCBvd25lckRvYyA9IGRvbUVsZW0ub3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIG93bmVyRG9jICYmIG93bmVyRG9jLmRlZmF1bHRWaWV3IHx8IG51bGw7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3coZWRpdG9yKSB7XG4gIGNvbnN0IHdpbmRvd09iaiA9IGVkaXRvci5fd2luZG93O1xuXG4gIGlmICh3aW5kb3dPYmogPT09IG51bGwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgd2luZG93IG9iamVjdCBub3QgZm91bmRgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2luZG93T2JqO1xufVxuZnVuY3Rpb24gJGlzSW5saW5lRWxlbWVudE9yRGVjb3JhdG9yTm9kZShub2RlKSB7XG4gIHJldHVybiAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCkgfHwgJGlzRGVjb3JhdG9yTm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCk7XG59XG5mdW5jdGlvbiAkZ2V0TmVhcmVzdFJvb3RPclNoYWRvd1Jvb3Qobm9kZSkge1xuICBsZXQgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnQ7XG59XG5mdW5jdGlvbiAkaXNSb290T3JTaGFkb3dSb290KG5vZGUpIHtcbiAgcmV0dXJuICRpc1Jvb3ROb2RlKG5vZGUpIHx8ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGUuaXNTaGFkb3dSb290KCk7XG59XG5mdW5jdGlvbiAkY29weU5vZGUobm9kZSkge1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IGNvcHkgPSBub2RlLmNvbnN0cnVjdG9yLmNsb25lKG5vZGUpO1xuICAkc2V0Tm9kZUtleShjb3B5LCBudWxsKTtcbiAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobm9kZSkge1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLmNvbnN0cnVjdG9yLmdldFR5cGUoKTtcblxuICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IGVkaXRvci5fbm9kZXMuZ2V0KG5vZGVUeXBlKTtcblxuICBpZiAocmVnaXN0ZXJlZE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGAkaW5pdGlhbGl6ZU5vZGUgZmFpbGVkLiBFbnN1cmUgbm9kZSBoYXMgYmVlbiByZWdpc3RlcmVkIHRvIHRoZSBlZGl0b3IuIFlvdSBjYW4gZG8gdGhpcyBieSBwYXNzaW5nIHRoZSBub2RlIGNsYXNzIHZpYSB0aGUgXCJub2Rlc1wiIGFycmF5IGluIHRoZSBlZGl0b3IgY29uZmlnLmApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlcGxhY2VGdW5jID0gcmVnaXN0ZXJlZE5vZGUucmVwbGFjZTtcblxuICBpZiAocmVwbGFjZUZ1bmMgIT09IG51bGwpIHtcbiAgICBjb25zdCByZXBsYWNlbWVudE5vZGUgPSByZXBsYWNlRnVuYyhub2RlKTtcblxuICAgIGlmICghKHJlcGxhY2VtZW50Tm9kZSBpbnN0YW5jZW9mIG5vZGUuY29uc3RydWN0b3IpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGAkaW5pdGlhbGl6ZU5vZGUgZmFpbGVkLiBFbnN1cmUgcmVwbGFjZW1lbnQgbm9kZSBpcyBhIHN1YmNsYXNzIG9mIHRoZSBvcmlnaW5hbCBub2RlLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXBsYWNlbWVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGVycm9yT25JbnNlcnRUZXh0Tm9kZU9uUm9vdChub2RlLCBpbnNlcnROb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuXG4gIGlmICgkaXNSb290Tm9kZShwYXJlbnROb2RlKSAmJiAhJGlzRWxlbWVudE5vZGUoaW5zZXJ0Tm9kZSkgJiYgISRpc0RlY29yYXRvck5vZGUoaW5zZXJ0Tm9kZSkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgT25seSBlbGVtZW50IG9yIGRlY29yYXRvciBub2RlcyBjYW4gYmUgaW5zZXJ0ZWQgaW4gdG8gdGhlIHJvb3Qgbm9kZWApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVCbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yQ29uZmlnKSB7XG4gIGNvbnN0IHRoZW1lID0gZWRpdG9yQ29uZmlnLnRoZW1lO1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gJ2ZhbHNlJztcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1jdXJzb3InLCAndHJ1ZScpO1xuICBsZXQgYmxvY2tDdXJzb3JUaGVtZSA9IHRoZW1lLmJsb2NrQ3Vyc29yO1xuXG4gIGlmIChibG9ja0N1cnNvclRoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGJsb2NrQ3Vyc29yVGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWVzQXJyID0gYmxvY2tDdXJzb3JUaGVtZS5zcGxpdCgnICcpOyAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlbnRpb25hbFxuXG4gICAgICBibG9ja0N1cnNvclRoZW1lID0gdGhlbWUuYmxvY2tDdXJzb3IgPSBjbGFzc05hbWVzQXJyO1xuICAgIH1cblxuICAgIGlmIChibG9ja0N1cnNvclRoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5ibG9ja0N1cnNvclRoZW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gbmVlZHNCbG9ja0N1cnNvcihub2RlKSB7XG4gIHJldHVybiAoJGlzRGVjb3JhdG9yTm9kZShub2RlKSB8fCAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhbm9kZS5jYW5CZUVtcHR5KCkpICYmICFub2RlLmlzSW5saW5lKCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZURPTUJsb2NrQ3Vyc29yRWxlbWVudChibG9ja0N1cnNvckVsZW1lbnQsIGVkaXRvciwgcm9vdEVsZW1lbnQpIHtcbiAgcm9vdEVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2NhcmV0LWNvbG9yJyk7XG4gIGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50ID0gbnVsbDtcbiAgY29uc3QgcGFyZW50RWxlbWVudCA9IGJsb2NrQ3Vyc29yRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXG4gIGlmIChwYXJlbnRFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgcGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChibG9ja0N1cnNvckVsZW1lbnQpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVET01CbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yLCByb290RWxlbWVudCwgbmV4dFNlbGVjdGlvbikge1xuICBsZXQgYmxvY2tDdXJzb3JFbGVtZW50ID0gZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQ7XG5cbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKG5leHRTZWxlY3Rpb24pICYmIG5leHRTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBuZXh0U2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgcm9vdEVsZW1lbnQuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICBjb25zdCBhbmNob3IgPSBuZXh0U2VsZWN0aW9uLmFuY2hvcjtcbiAgICBjb25zdCBlbGVtZW50Tm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICBjb25zdCBlbGVtZW50Tm9kZVNpemUgPSBlbGVtZW50Tm9kZS5nZXRDaGlsZHJlblNpemUoKTtcbiAgICBsZXQgaXNCbG9ja0N1cnNvciA9IGZhbHNlO1xuICAgIGxldCBpbnNlcnRCZWZvcmVFbGVtZW50ID0gbnVsbDtcblxuICAgIGlmIChvZmZzZXQgPT09IGVsZW1lbnROb2RlU2l6ZSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBlbGVtZW50Tm9kZS5nZXRDaGlsZEF0SW5kZXgob2Zmc2V0IC0gMSk7XG5cbiAgICAgIGlmIChuZWVkc0Jsb2NrQ3Vyc29yKGNoaWxkKSkge1xuICAgICAgICBpc0Jsb2NrQ3Vyc29yID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGQgPSBlbGVtZW50Tm9kZS5nZXRDaGlsZEF0SW5kZXgob2Zmc2V0KTtcblxuICAgICAgaWYgKG5lZWRzQmxvY2tDdXJzb3IoY2hpbGQpKSB7XG4gICAgICAgIGNvbnN0IHNpYmxpbmcgPSBjaGlsZC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgICAgICBpZiAoc2libGluZyA9PT0gbnVsbCB8fCBuZWVkc0Jsb2NrQ3Vyc29yKHNpYmxpbmcpKSB7XG4gICAgICAgICAgaXNCbG9ja0N1cnNvciA9IHRydWU7XG4gICAgICAgICAgaW5zZXJ0QmVmb3JlRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY2hpbGQuX19rZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQmxvY2tDdXJzb3IpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGVsZW1lbnROb2RlLl9fa2V5KTtcblxuICAgICAgaWYgKGJsb2NrQ3Vyc29yRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICBlZGl0b3IuX2Jsb2NrQ3Vyc29yRWxlbWVudCA9IGJsb2NrQ3Vyc29yRWxlbWVudCA9IGNyZWF0ZUJsb2NrQ3Vyc29yRWxlbWVudChlZGl0b3IuX2NvbmZpZyk7XG4gICAgICB9XG5cbiAgICAgIHJvb3RFbGVtZW50LnN0eWxlLmNhcmV0Q29sb3IgPSAndHJhbnNwYXJlbnQnO1xuXG4gICAgICBpZiAoaW5zZXJ0QmVmb3JlRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50RE9NLmFwcGVuZENoaWxkKGJsb2NrQ3Vyc29yRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50RE9NLmluc2VydEJlZm9yZShibG9ja0N1cnNvckVsZW1lbnQsIGluc2VydEJlZm9yZUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IC8vIFJlbW92ZSBjdXJzb3JcblxuXG4gIGlmIChibG9ja0N1cnNvckVsZW1lbnQgIT09IG51bGwpIHtcbiAgICByZW1vdmVET01CbG9ja0N1cnNvckVsZW1lbnQoYmxvY2tDdXJzb3JFbGVtZW50LCBlZGl0b3IsIHJvb3RFbGVtZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RE9NU2VsZWN0aW9uKHRhcmdldFdpbmRvdykge1xuICByZXR1cm4gIUNBTl9VU0VfRE9NID8gbnVsbCA6ICh0YXJnZXRXaW5kb3cgfHwgd2luZG93KS5nZXRTZWxlY3Rpb24oKTtcbn1cbmZ1bmN0aW9uICRzcGxpdE5vZGUobm9kZSwgb2Zmc2V0KSB7XG4gIGxldCBzdGFydE5vZGUgPSBub2RlLmdldENoaWxkQXRJbmRleChvZmZzZXQpO1xuXG4gIGlmIChzdGFydE5vZGUgPT0gbnVsbCkge1xuICAgIHN0YXJ0Tm9kZSA9IG5vZGU7XG4gIH1cblxuICBpZiAoISEkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgdGhyb3cgRXJyb3IoYENhbiBub3QgY2FsbCAkc3BsaXROb2RlKCkgb24gcm9vdCBlbGVtZW50YCk7XG4gIH1cblxuICBjb25zdCByZWN1cnNlID0gY3VycmVudE5vZGUgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IGN1cnJlbnROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBjb25zdCBpc1BhcmVudFJvb3QgPSAkaXNSb290T3JTaGFkb3dSb290KHBhcmVudCk7IC8vIFRoZSBub2RlIHdlIHN0YXJ0IHNwbGl0IGZyb20gKGxlYWYpIGlzIG1vdmVkLCBidXQgaXRzIHJlY3Vyc2l2ZVxuICAgIC8vIHBhcmVudHMgYXJlIGNvcGllZCB0byBjcmVhdGUgc2VwYXJhdGUgdHJlZVxuXG4gICAgY29uc3Qgbm9kZVRvTW92ZSA9IGN1cnJlbnROb2RlID09PSBzdGFydE5vZGUgJiYgIWlzUGFyZW50Um9vdCA/IGN1cnJlbnROb2RlIDogJGNvcHlOb2RlKGN1cnJlbnROb2RlKTtcblxuICAgIGlmIChpc1BhcmVudFJvb3QpIHtcbiAgICAgIGN1cnJlbnROb2RlLmluc2VydEFmdGVyKG5vZGVUb01vdmUpO1xuICAgICAgcmV0dXJuIFtjdXJyZW50Tm9kZSwgbm9kZVRvTW92ZSwgbm9kZVRvTW92ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtsZWZ0VHJlZSwgcmlnaHRUcmVlLCBuZXdQYXJlbnRdID0gcmVjdXJzZShwYXJlbnQpO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmdzID0gY3VycmVudE5vZGUuZ2V0TmV4dFNpYmxpbmdzKCk7XG4gICAgICBuZXdQYXJlbnQuYXBwZW5kKG5vZGVUb01vdmUsIC4uLm5leHRTaWJsaW5ncyk7XG4gICAgICByZXR1cm4gW2xlZnRUcmVlLCByaWdodFRyZWUsIG5vZGVUb01vdmVdO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBbbGVmdFRyZWUsIHJpZ2h0VHJlZV0gPSByZWN1cnNlKHN0YXJ0Tm9kZSk7XG4gIHJldHVybiBbbGVmdFRyZWUsIHJpZ2h0VHJlZV07XG59XG5mdW5jdGlvbiAkZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0aW5nTm9kZSwgZmluZEZuKSB7XG4gIGxldCBjdXJyID0gc3RhcnRpbmdOb2RlO1xuXG4gIHdoaWxlIChjdXJyICE9PSAkZ2V0Um9vdCgpICYmIGN1cnIgIT0gbnVsbCkge1xuICAgIGlmIChmaW5kRm4oY3VycikpIHtcbiAgICAgIHJldHVybiBjdXJyO1xuICAgIH1cblxuICAgIGN1cnIgPSBjdXJyLmdldFBhcmVudCgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiAkZ2V0Q2hpbGRyZW5SZWN1cnNpdmVseShub2RlKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGNvbnN0IHN0YWNrID0gW25vZGVdO1xuXG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY3VycmVudE5vZGUgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmICghKGN1cnJlbnROb2RlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgU3RhY2subGVuZ3RoID4gMDsgY2FuJ3QgYmUgdW5kZWZpbmVkYCk7XG4gICAgfVxuXG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgc3RhY2sudW5zaGlmdCguLi5jdXJyZW50Tm9kZS5nZXRDaGlsZHJlbigpKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudE5vZGUgIT09IG5vZGUpIHtcbiAgICAgIG5vZGVzLnB1c2goY3VycmVudE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuZnVuY3Rpb24gJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWNvcmF0b3JzKGVkaXRvciwgcGVuZGluZ0VkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGN1cnJlbnREZWNvcmF0b3JzID0gZWRpdG9yLl9kZWNvcmF0b3JzO1xuICBjb25zdCBwZW5kaW5nRGVjb3JhdG9ycyA9IGVkaXRvci5fcGVuZGluZ0RlY29yYXRvcnM7XG4gIGxldCBkZWNvcmF0b3JzID0gcGVuZGluZ0RlY29yYXRvcnMgfHwgY3VycmVudERlY29yYXRvcnM7XG4gIGNvbnN0IG5vZGVNYXAgPSBwZW5kaW5nRWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGxldCBrZXk7XG5cbiAgZm9yIChrZXkgaW4gZGVjb3JhdG9ycykge1xuICAgIGlmICghbm9kZU1hcC5oYXMoa2V5KSkge1xuICAgICAgaWYgKGRlY29yYXRvcnMgPT09IGN1cnJlbnREZWNvcmF0b3JzKSB7XG4gICAgICAgIGRlY29yYXRvcnMgPSBjbG9uZURlY29yYXRvcnMoZWRpdG9yKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGRlY29yYXRvcnNba2V5XTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWVwQ2hpbGROb2Rlcyhub2RlLCBwYXJlbnRLZXksIHByZXZOb2RlTWFwLCBub2RlTWFwLCBub2RlTWFwRGVsZXRlLCBkaXJ0eU5vZGVzKSB7XG4gIGxldCBjaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGNoaWxkS2V5ID0gY2hpbGQuX19rZXk7IC8vIFRPRE8gUmV2aXNlIGNvbmRpdGlvbiBiZWxvdywgcmVkdW5kYW50PyBMZXhpY2FsTm9kZSBhbHJlYWR5IGNsZWFucyB1cCBjaGlsZHJlbiB3aGVuIG1vdmluZyBOb2Rlc1xuXG4gICAgaWYgKGNoaWxkLl9fcGFyZW50ID09PSBwYXJlbnRLZXkpIHtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWVwQ2hpbGROb2RlcyhjaGlsZCwgY2hpbGRLZXksIHByZXZOb2RlTWFwLCBub2RlTWFwLCBub2RlTWFwRGVsZXRlLCBkaXJ0eU5vZGVzKTtcbiAgICAgIH0gLy8gSWYgd2UgaGF2ZSBjcmVhdGVkIGEgbm9kZSBhbmQgaXQgd2FzIGRlcmVmZXJlbmNlZCwgdGhlbiBhbHNvXG4gICAgICAvLyByZW1vdmUgaXQgZnJvbSBvdXQgZGlydHkgbm9kZXMgU2V0LlxuXG5cbiAgICAgIGlmICghcHJldk5vZGVNYXAuaGFzKGNoaWxkS2V5KSkge1xuICAgICAgICBkaXJ0eU5vZGVzLmRlbGV0ZShjaGlsZEtleSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGVNYXBEZWxldGUucHVzaChjaGlsZEtleSk7XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5nZXROZXh0U2libGluZygpO1xuICB9XG59XG5cbmZ1bmN0aW9uICRnYXJiYWdlQ29sbGVjdERldGFjaGVkTm9kZXMocHJldkVkaXRvclN0YXRlLCBlZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXMsIGRpcnR5RWxlbWVudHMpIHtcbiAgY29uc3QgcHJldk5vZGVNYXAgPSBwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDsgLy8gU3RvcmUgZGlydHlFbGVtZW50cyBpbiBhIHF1ZXVlIGZvciBsYXRlciBkZWxldGlvbjsgZGVsZXRpbmcgZGlydHkgc3VidHJlZXMgdG9vIGVhcmx5IHdpbGxcbiAgLy8gaGluZGVyIGFjY2Vzc2luZyAuX19uZXh0IG9uIGNoaWxkIG5vZGVzXG5cbiAgY29uc3Qgbm9kZU1hcERlbGV0ZSA9IFtdO1xuXG4gIGZvciAoY29uc3QgW25vZGVLZXldIG9mIGRpcnR5RWxlbWVudHMpIHtcbiAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQobm9kZUtleSk7XG5cbiAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBHYXJiYWdlIGNvbGxlY3Qgbm9kZSBhbmQgaXRzIGNoaWxkcmVuIGlmIHRoZXkgZXhpc3RcbiAgICAgIGlmICghbm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWVwQ2hpbGROb2Rlcyhub2RlLCBub2RlS2V5LCBwcmV2Tm9kZU1hcCwgbm9kZU1hcCwgbm9kZU1hcERlbGV0ZSwgZGlydHlFbGVtZW50cyk7XG4gICAgICAgIH0gLy8gSWYgd2UgaGF2ZSBjcmVhdGVkIGEgbm9kZSBhbmQgaXQgd2FzIGRlcmVmZXJlbmNlZCwgdGhlbiBhbHNvXG4gICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIG91dCBkaXJ0eSBub2RlcyBTZXQuXG5cblxuICAgICAgICBpZiAoIXByZXZOb2RlTWFwLmhhcyhub2RlS2V5KSkge1xuICAgICAgICAgIGRpcnR5RWxlbWVudHMuZGVsZXRlKG5vZGVLZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZU1hcERlbGV0ZS5wdXNoKG5vZGVLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3Qgbm9kZUtleSBvZiBub2RlTWFwRGVsZXRlKSB7XG4gICAgbm9kZU1hcC5kZWxldGUobm9kZUtleSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IG5vZGVLZXkgb2YgZGlydHlMZWF2ZXMpIHtcbiAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQobm9kZUtleSk7XG5cbiAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmICFub2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgaWYgKCFwcmV2Tm9kZU1hcC5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgZGlydHlMZWF2ZXMuZGVsZXRlKG5vZGVLZXkpO1xuICAgICAgfVxuXG4gICAgICBub2RlTWFwLmRlbGV0ZShub2RlS2V5KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xubGV0IHN1YlRyZWVUZXh0Q29udGVudCA9ICcnO1xubGV0IHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gJyc7XG5sZXQgZWRpdG9yVGV4dENvbnRlbnQgPSAnJztcbmxldCBhY3RpdmVFZGl0b3JDb25maWc7XG5sZXQgYWN0aXZlRWRpdG9yJDE7XG5sZXQgYWN0aXZlRWRpdG9yTm9kZXM7XG5sZXQgdHJlYXRBbGxOb2Rlc0FzRGlydHkgPSBmYWxzZTtcbmxldCBhY3RpdmVFZGl0b3JTdGF0ZVJlYWRPbmx5ID0gZmFsc2U7XG5sZXQgYWN0aXZlTXV0YXRpb25MaXN0ZW5lcnM7XG5sZXQgYWN0aXZlVGV4dERpcmVjdGlvbiA9IG51bGw7XG5sZXQgYWN0aXZlRGlydHlFbGVtZW50cztcbmxldCBhY3RpdmVEaXJ0eUxlYXZlcztcbmxldCBhY3RpdmVQcmV2Tm9kZU1hcDtcbmxldCBhY3RpdmVOZXh0Tm9kZU1hcDtcbmxldCBhY3RpdmVQcmV2S2V5VG9ET01NYXA7XG5sZXQgbXV0YXRlZE5vZGVzO1xuXG5mdW5jdGlvbiBkZXN0cm95Tm9kZShrZXksIHBhcmVudERPTSkge1xuICBjb25zdCBub2RlID0gYWN0aXZlUHJldk5vZGVNYXAuZ2V0KGtleSk7XG5cbiAgaWYgKHBhcmVudERPTSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IGRvbSA9IGdldFByZXZFbGVtZW50QnlLZXlPclRocm93KGtleSk7XG5cbiAgICBpZiAoZG9tLnBhcmVudE5vZGUgPT09IHBhcmVudERPTSkge1xuICAgICAgcGFyZW50RE9NLnJlbW92ZUNoaWxkKGRvbSk7XG4gICAgfVxuICB9IC8vIFRoaXMgbG9naWMgaXMgcmVhbGx5IGltcG9ydGFudCwgb3RoZXJ3aXNlIHdlIHdpbGwgbGVhayBET00gbm9kZXNcbiAgLy8gd2hlbiB0aGVpciBjb3JyZXNwb25kaW5nIExleGljYWxOb2RlcyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBlZGl0b3Igc3RhdGUuXG5cblxuICBpZiAoIWFjdGl2ZU5leHROb2RlTWFwLmhhcyhrZXkpKSB7XG4gICAgYWN0aXZlRWRpdG9yJDEuX2tleVRvRE9NTWFwLmRlbGV0ZShrZXkpO1xuICB9XG5cbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBjcmVhdGVDaGlsZHJlbkFycmF5KG5vZGUsIGFjdGl2ZVByZXZOb2RlTWFwKTtcbiAgICBkZXN0cm95Q2hpbGRyZW4oY2hpbGRyZW4sIDAsIGNoaWxkcmVuLmxlbmd0aCAtIDEsIG51bGwpO1xuICB9XG5cbiAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHNldE11dGF0ZWROb2RlKG11dGF0ZWROb2RlcywgYWN0aXZlRWRpdG9yTm9kZXMsIGFjdGl2ZU11dGF0aW9uTGlzdGVuZXJzLCBub2RlLCAnZGVzdHJveWVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzdHJveUNoaWxkcmVuKGNoaWxkcmVuLCBfc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRvbSkge1xuICBsZXQgc3RhcnRJbmRleCA9IF9zdGFydEluZGV4O1xuXG4gIGZvciAoOyBzdGFydEluZGV4IDw9IGVuZEluZGV4OyArK3N0YXJ0SW5kZXgpIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW3N0YXJ0SW5kZXhdO1xuXG4gICAgaWYgKGNoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlc3Ryb3lOb2RlKGNoaWxkLCBkb20pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsIHZhbHVlKSB7XG4gIGRvbVN0eWxlLnNldFByb3BlcnR5KCd0ZXh0LWFsaWduJywgdmFsdWUpO1xufVxuXG5jb25zdCBERUZBVUxUX0lOREVOVF9WQUxVRSA9ICc0MHB4JztcblxuZnVuY3Rpb24gc2V0RWxlbWVudEluZGVudChkb20sIGluZGVudCkge1xuICBjb25zdCBpbmRlbnRDbGFzc05hbWUgPSBhY3RpdmVFZGl0b3JDb25maWcudGhlbWUuaW5kZW50O1xuXG4gIGlmICh0eXBlb2YgaW5kZW50Q2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGVsZW1lbnRIYXNDbGFzc05hbWUgPSBkb20uY2xhc3NMaXN0LmNvbnRhaW5zKGluZGVudENsYXNzTmFtZSk7XG5cbiAgICBpZiAoaW5kZW50ID4gMCAmJiAhZWxlbWVudEhhc0NsYXNzTmFtZSkge1xuICAgICAgZG9tLmNsYXNzTGlzdC5hZGQoaW5kZW50Q2xhc3NOYW1lKTtcbiAgICB9IGVsc2UgaWYgKGluZGVudCA8IDEgJiYgZWxlbWVudEhhc0NsYXNzTmFtZSkge1xuICAgICAgZG9tLmNsYXNzTGlzdC5yZW1vdmUoaW5kZW50Q2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBpbmRlbnRhdGlvbkJhc2VWYWx1ZSA9IGdldENvbXB1dGVkU3R5bGUoZG9tKS5nZXRQcm9wZXJ0eVZhbHVlKCctLWxleGljYWwtaW5kZW50LWJhc2UtdmFsdWUnKSB8fCBERUZBVUxUX0lOREVOVF9WQUxVRTtcbiAgZG9tLnN0eWxlLnNldFByb3BlcnR5KCdwYWRkaW5nLWlubGluZS1zdGFydCcsIGluZGVudCA9PT0gMCA/ICcnIDogYGNhbGMoJHtpbmRlbnR9ICogJHtpbmRlbnRhdGlvbkJhc2VWYWx1ZX0pYCk7XG59XG5cbmZ1bmN0aW9uIHNldEVsZW1lbnRGb3JtYXQoZG9tLCBmb3JtYXQpIHtcbiAgY29uc3QgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG5cbiAgaWYgKGZvcm1hdCA9PT0gMCkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJycpO1xuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gSVNfQUxJR05fTEVGVCkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2xlZnQnKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX0NFTlRFUikge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2NlbnRlcicpO1xuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gSVNfQUxJR05fUklHSFQpIHtcbiAgICBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsICdyaWdodCcpO1xuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gSVNfQUxJR05fSlVTVElGWSkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2p1c3RpZnknKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX1NUQVJUKSB7XG4gICAgc2V0VGV4dEFsaWduKGRvbVN0eWxlLCAnc3RhcnQnKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX0VORCkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUoa2V5LCBwYXJlbnRET00sIGluc2VydERPTSkge1xuICBjb25zdCBub2RlID0gYWN0aXZlTmV4dE5vZGVNYXAuZ2V0KGtleSk7XG5cbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBjcmVhdGVOb2RlOiBub2RlIGRvZXMgbm90IGV4aXN0IGluIG5vZGVNYXBgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkb20gPSBub2RlLmNyZWF0ZURPTShhY3RpdmVFZGl0b3JDb25maWcsIGFjdGl2ZUVkaXRvciQxKTtcbiAgc3RvcmVET01XaXRoS2V5KGtleSwgZG9tLCBhY3RpdmVFZGl0b3IkMSk7IC8vIFRoaXMgaGVscHMgcHJlc2VydmUgdGhlIHRleHQsIGFuZCBzdG9wcyBzcGVsbCBjaGVjayB0b29scyBmcm9tXG4gIC8vIG1lcmdpbmcgb3IgYnJlYWsgdGhlIHNwYW5zICh3aGljaCBoYXBwZW5zIGlmIHRoZXkgYXJlIG1pc3NpbmdcbiAgLy8gdGhpcyBhdHRyaWJ1dGUpLlxuXG4gIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC10ZXh0JywgJ3RydWUnKTtcbiAgfSBlbHNlIGlmICgkaXNEZWNvcmF0b3JOb2RlKG5vZGUpKSB7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLWRlY29yYXRvcicsICd0cnVlJyk7XG4gIH1cblxuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBub2RlLl9faW5kZW50O1xuICAgIGNvbnN0IGNoaWxkcmVuU2l6ZSA9IG5vZGUuX19zaXplO1xuXG4gICAgaWYgKGluZGVudCAhPT0gMCkge1xuICAgICAgc2V0RWxlbWVudEluZGVudChkb20sIGluZGVudCk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuU2l6ZSAhPT0gMCkge1xuICAgICAgY29uc3QgZW5kSW5kZXggPSBjaGlsZHJlblNpemUgLSAxO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjcmVhdGVDaGlsZHJlbkFycmF5KG5vZGUsIGFjdGl2ZU5leHROb2RlTWFwKTtcbiAgICAgIGNyZWF0ZUNoaWxkcmVuV2l0aERpcmVjdGlvbihjaGlsZHJlbiwgZW5kSW5kZXgsIG5vZGUsIGRvbSk7XG4gICAgfVxuXG4gICAgY29uc3QgZm9ybWF0ID0gbm9kZS5fX2Zvcm1hdDtcblxuICAgIGlmIChmb3JtYXQgIT09IDApIHtcbiAgICAgIHNldEVsZW1lbnRGb3JtYXQoZG9tLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGlmICghbm9kZS5pc0lubGluZSgpKSB7XG4gICAgICByZWNvbmNpbGVFbGVtZW50VGVybWluYXRpbmdMaW5lQnJlYWsobnVsbCwgbm9kZSwgZG9tKTtcbiAgICB9XG5cbiAgICBpZiAoJHRleHRDb250ZW50UmVxdWlyZXNEb3VibGVMaW5lYnJlYWtBdEVuZChub2RlKSkge1xuICAgICAgc3ViVHJlZVRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICAgICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG5cbiAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShub2RlKSkge1xuICAgICAgY29uc3QgZGVjb3JhdG9yID0gbm9kZS5kZWNvcmF0ZShhY3RpdmVFZGl0b3IkMSwgYWN0aXZlRWRpdG9yQ29uZmlnKTtcblxuICAgICAgaWYgKGRlY29yYXRvciAhPT0gbnVsbCkge1xuICAgICAgICByZWNvbmNpbGVEZWNvcmF0b3Ioa2V5LCBkZWNvcmF0b3IpO1xuICAgICAgfSAvLyBEZWNvcmF0b3JzIGFyZSBhbHdheXMgbm9uIGVkaXRhYmxlXG5cblxuICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9ICdmYWxzZSc7XG4gICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgaWYgKCFub2RlLmlzRGlyZWN0aW9ubGVzcygpKSB7XG4gICAgICAgIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3ViVHJlZVRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgfVxuXG4gIGlmIChwYXJlbnRET00gIT09IG51bGwpIHtcbiAgICBpZiAoaW5zZXJ0RE9NICE9IG51bGwpIHtcbiAgICAgIHBhcmVudERPTS5pbnNlcnRCZWZvcmUoZG9tLCBpbnNlcnRET00pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgICAgY29uc3QgcG9zc2libGVMaW5lQnJlYWsgPSBwYXJlbnRET00uX19sZXhpY2FsTGluZUJyZWFrO1xuXG4gICAgICBpZiAocG9zc2libGVMaW5lQnJlYWsgIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRET00uaW5zZXJ0QmVmb3JlKGRvbSwgcG9zc2libGVMaW5lQnJlYWspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50RE9NLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIC8vIEZyZWV6ZSB0aGUgbm9kZSBpbiBERVYgdG8gcHJldmVudCBhY2NpZGVudGFsIG11dGF0aW9uc1xuICAgIE9iamVjdC5mcmVlemUobm9kZSk7XG4gIH1cblxuICBzZXRNdXRhdGVkTm9kZShtdXRhdGVkTm9kZXMsIGFjdGl2ZUVkaXRvck5vZGVzLCBhY3RpdmVNdXRhdGlvbkxpc3RlbmVycywgbm9kZSwgJ2NyZWF0ZWQnKTtcbiAgcmV0dXJuIGRvbTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW5XaXRoRGlyZWN0aW9uKGNoaWxkcmVuLCBlbmRJbmRleCwgZWxlbWVudCwgZG9tKSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudDtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSAnJztcbiAgY3JlYXRlQ2hpbGRyZW4oY2hpbGRyZW4sIGVsZW1lbnQsIDAsIGVuZEluZGV4LCBkb20sIG51bGwpO1xuICByZWNvbmNpbGVCbG9ja0RpcmVjdGlvbihlbGVtZW50LCBkb20pO1xuICBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCA9IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuKGNoaWxkcmVuLCBlbGVtZW50LCBfc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRvbSwgaW5zZXJ0RE9NKSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ID0gc3ViVHJlZVRleHRDb250ZW50O1xuICBzdWJUcmVlVGV4dENvbnRlbnQgPSAnJztcbiAgbGV0IHN0YXJ0SW5kZXggPSBfc3RhcnRJbmRleDtcblxuICBmb3IgKDsgc3RhcnRJbmRleCA8PSBlbmRJbmRleDsgKytzdGFydEluZGV4KSB7XG4gICAgY3JlYXRlTm9kZShjaGlsZHJlbltzdGFydEluZGV4XSwgZG9tLCBpbnNlcnRET00pO1xuICB9XG5cbiAgaWYgKCR0ZXh0Q29udGVudFJlcXVpcmVzRG91YmxlTGluZWJyZWFrQXRFbmQoZWxlbWVudCkpIHtcbiAgICBzdWJUcmVlVGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gIH0gLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcblxuXG4gIGRvbS5fX2xleGljYWxUZXh0Q29udGVudCA9IHN1YlRyZWVUZXh0Q29udGVudDtcbiAgc3ViVHJlZVRleHRDb250ZW50ID0gcHJldmlvdXNTdWJUcmVlVGV4dENvbnRlbnQgKyBzdWJUcmVlVGV4dENvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzTGFzdENoaWxkTGluZUJyZWFrT3JEZWNvcmF0b3IoY2hpbGRLZXksIG5vZGVNYXApIHtcbiAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KGNoaWxkS2V5KTtcbiAgcmV0dXJuICRpc0xpbmVCcmVha05vZGUobm9kZSkgfHwgJGlzRGVjb3JhdG9yTm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCk7XG59IC8vIElmIHdlIGVuZCBhbiBlbGVtZW50IHdpdGggYSBMaW5lQnJlYWtOb2RlLCB0aGVuIHdlIG5lZWQgdG8gYWRkIGFuIGFkZGl0aW9uYWwgPGJyPlxuXG5cbmZ1bmN0aW9uIHJlY29uY2lsZUVsZW1lbnRUZXJtaW5hdGluZ0xpbmVCcmVhayhwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGRvbSkge1xuICBjb25zdCBwcmV2TGluZUJyZWFrID0gcHJldkVsZW1lbnQgIT09IG51bGwgJiYgKHByZXZFbGVtZW50Ll9fc2l6ZSA9PT0gMCB8fCBpc0xhc3RDaGlsZExpbmVCcmVha09yRGVjb3JhdG9yKHByZXZFbGVtZW50Ll9fbGFzdCwgYWN0aXZlUHJldk5vZGVNYXApKTtcbiAgY29uc3QgbmV4dExpbmVCcmVhayA9IG5leHRFbGVtZW50Ll9fc2l6ZSA9PT0gMCB8fCBpc0xhc3RDaGlsZExpbmVCcmVha09yRGVjb3JhdG9yKG5leHRFbGVtZW50Ll9fbGFzdCwgYWN0aXZlTmV4dE5vZGVNYXApO1xuXG4gIGlmIChwcmV2TGluZUJyZWFrKSB7XG4gICAgaWYgKCFuZXh0TGluZUJyZWFrKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgICAgY29uc3QgZWxlbWVudCA9IGRvbS5fX2xleGljYWxMaW5lQnJlYWs7XG5cbiAgICAgIGlmIChlbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgZG9tLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgfSAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuXG5cbiAgICAgIGRvbS5fX2xleGljYWxMaW5lQnJlYWsgPSBudWxsO1xuICAgIH1cbiAgfSBlbHNlIGlmIChuZXh0TGluZUJyZWFrKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJyk7IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG5cbiAgICBkb20uX19sZXhpY2FsTGluZUJyZWFrID0gZWxlbWVudDtcbiAgICBkb20uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb25jaWxlQmxvY2tEaXJlY3Rpb24oZWxlbWVudCwgZG9tKSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50ID0gLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgZG9tLl9fbGV4aWNhbERpclRleHRDb250ZW50OyAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuXG4gIGNvbnN0IHByZXZpb3VzRGlyZWN0aW9uID0gZG9tLl9fbGV4aWNhbERpcjtcblxuICBpZiAocHJldmlvdXNTdWJUcmVlRGlyZWN0aW9uVGV4dENvbnRlbnQgIT09IHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50IHx8IHByZXZpb3VzRGlyZWN0aW9uICE9PSBhY3RpdmVUZXh0RGlyZWN0aW9uKSB7XG4gICAgY29uc3QgaGFzRW1wdHlEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPT09ICcnO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGhhc0VtcHR5RGlyZWN0aW9uZWRUZXh0Q29udGVudCA/IGFjdGl2ZVRleHREaXJlY3Rpb24gOiBnZXRUZXh0RGlyZWN0aW9uKHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50KTtcblxuICAgIGlmIChkaXJlY3Rpb24gIT09IHByZXZpb3VzRGlyZWN0aW9uKSB7XG4gICAgICBjb25zdCBjbGFzc0xpc3QgPSBkb20uY2xhc3NMaXN0O1xuICAgICAgY29uc3QgdGhlbWUgPSBhY3RpdmVFZGl0b3JDb25maWcudGhlbWU7XG4gICAgICBsZXQgcHJldmlvdXNEaXJlY3Rpb25UaGVtZSA9IHByZXZpb3VzRGlyZWN0aW9uICE9PSBudWxsID8gdGhlbWVbcHJldmlvdXNEaXJlY3Rpb25dIDogdW5kZWZpbmVkO1xuICAgICAgbGV0IG5leHREaXJlY3Rpb25UaGVtZSA9IGRpcmVjdGlvbiAhPT0gbnVsbCA/IHRoZW1lW2RpcmVjdGlvbl0gOiB1bmRlZmluZWQ7IC8vIFJlbW92ZSB0aGUgb2xkIHRoZW1lIGNsYXNzZXMgaWYgdGhleSBleGlzdFxuXG4gICAgICBpZiAocHJldmlvdXNEaXJlY3Rpb25UaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJldmlvdXNEaXJlY3Rpb25UaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb25zdCBjbGFzc05hbWVzQXJyID0gcHJldmlvdXNEaXJlY3Rpb25UaGVtZS5zcGxpdCgnICcpO1xuICAgICAgICAgIHByZXZpb3VzRGlyZWN0aW9uVGhlbWUgPSB0aGVtZVtwcmV2aW91c0RpcmVjdGlvbl0gPSBjbGFzc05hbWVzQXJyO1xuICAgICAgICB9IC8vIEB0cy1pZ25vcmU6IGludGVudGlvbmFsXG5cblxuICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKC4uLnByZXZpb3VzRGlyZWN0aW9uVGhlbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBudWxsIHx8IGhhc0VtcHR5RGlyZWN0aW9uZWRUZXh0Q29udGVudCAmJiBkaXJlY3Rpb24gPT09ICdsdHInKSB7XG4gICAgICAgIC8vIFJlbW92ZSBkaXJlY3Rpb25cbiAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgnZGlyJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcHBseSB0aGUgbmV3IHRoZW1lIGNsYXNzZXMgaWYgdGhleSBleGlzdFxuICAgICAgICBpZiAobmV4dERpcmVjdGlvblRoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5leHREaXJlY3Rpb25UaGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZXNBcnIgPSBuZXh0RGlyZWN0aW9uVGhlbWUuc3BsaXQoJyAnKTsgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZW50aW9uYWxcblxuICAgICAgICAgICAgbmV4dERpcmVjdGlvblRoZW1lID0gdGhlbWVbZGlyZWN0aW9uXSA9IGNsYXNzTmFtZXNBcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5leHREaXJlY3Rpb25UaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKC4uLm5leHREaXJlY3Rpb25UaGVtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFVwZGF0ZSBkaXJlY3Rpb25cblxuXG4gICAgICAgIGRvbS5kaXIgPSBkaXJlY3Rpb247XG4gICAgICB9XG5cbiAgICAgIGlmICghYWN0aXZlRWRpdG9yU3RhdGVSZWFkT25seSkge1xuICAgICAgICBjb25zdCB3cml0YWJsZU5vZGUgPSBlbGVtZW50LmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlTm9kZS5fX2RpciA9IGRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhY3RpdmVUZXh0RGlyZWN0aW9uID0gZGlyZWN0aW9uOyAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuXG4gICAgZG9tLl9fbGV4aWNhbERpclRleHRDb250ZW50ID0gc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQ7IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG5cbiAgICBkb20uX19sZXhpY2FsRGlyID0gZGlyZWN0aW9uO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuV2l0aERpcmVjdGlvbihwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGRvbSkge1xuICBjb25zdCBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudCA9IHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50O1xuICBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCA9ICcnO1xuICByZWNvbmNpbGVDaGlsZHJlbihwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGRvbSk7XG4gIHJlY29uY2lsZUJsb2NrRGlyZWN0aW9uKG5leHRFbGVtZW50LCBkb20pO1xuICBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCA9IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDaGlsZHJlbkFycmF5KGVsZW1lbnQsIG5vZGVNYXApIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgbGV0IG5vZGVLZXkgPSBlbGVtZW50Ll9fZmlyc3Q7XG5cbiAgd2hpbGUgKG5vZGVLZXkgIT09IG51bGwpIHtcbiAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQobm9kZUtleSk7XG5cbiAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBjcmVhdGVDaGlsZHJlbkFycmF5OiBub2RlIGRvZXMgbm90IGV4aXN0IGluIG5vZGVNYXBgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZHJlbi5wdXNoKG5vZGVLZXkpO1xuICAgIG5vZGVLZXkgPSBub2RlLl9fbmV4dDtcbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4ocHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBkb20pIHtcbiAgY29uc3QgcHJldmlvdXNTdWJUcmVlVGV4dENvbnRlbnQgPSBzdWJUcmVlVGV4dENvbnRlbnQ7XG4gIGNvbnN0IHByZXZDaGlsZHJlblNpemUgPSBwcmV2RWxlbWVudC5fX3NpemU7XG4gIGNvbnN0IG5leHRDaGlsZHJlblNpemUgPSBuZXh0RWxlbWVudC5fX3NpemU7XG4gIHN1YlRyZWVUZXh0Q29udGVudCA9ICcnO1xuXG4gIGlmIChwcmV2Q2hpbGRyZW5TaXplID09PSAxICYmIG5leHRDaGlsZHJlblNpemUgPT09IDEpIHtcbiAgICBjb25zdCBwcmV2Rmlyc3RDaGlsZEtleSA9IHByZXZFbGVtZW50Ll9fZmlyc3Q7XG4gICAgY29uc3QgbmV4dEZyc3RDaGlsZEtleSA9IG5leHRFbGVtZW50Ll9fZmlyc3Q7XG5cbiAgICBpZiAocHJldkZpcnN0Q2hpbGRLZXkgPT09IG5leHRGcnN0Q2hpbGRLZXkpIHtcbiAgICAgIHJlY29uY2lsZU5vZGUocHJldkZpcnN0Q2hpbGRLZXksIGRvbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3RET00gPSBnZXRQcmV2RWxlbWVudEJ5S2V5T3JUaHJvdyhwcmV2Rmlyc3RDaGlsZEtleSk7XG4gICAgICBjb25zdCByZXBsYWNlbWVudERPTSA9IGNyZWF0ZU5vZGUobmV4dEZyc3RDaGlsZEtleSwgbnVsbCwgbnVsbCk7XG4gICAgICBkb20ucmVwbGFjZUNoaWxkKHJlcGxhY2VtZW50RE9NLCBsYXN0RE9NKTtcbiAgICAgIGRlc3Ryb3lOb2RlKHByZXZGaXJzdENoaWxkS2V5LCBudWxsKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJldkNoaWxkcmVuID0gY3JlYXRlQ2hpbGRyZW5BcnJheShwcmV2RWxlbWVudCwgYWN0aXZlUHJldk5vZGVNYXApO1xuICAgIGNvbnN0IG5leHRDaGlsZHJlbiA9IGNyZWF0ZUNoaWxkcmVuQXJyYXkobmV4dEVsZW1lbnQsIGFjdGl2ZU5leHROb2RlTWFwKTtcblxuICAgIGlmIChwcmV2Q2hpbGRyZW5TaXplID09PSAwKSB7XG4gICAgICBpZiAobmV4dENoaWxkcmVuU2l6ZSAhPT0gMCkge1xuICAgICAgICBjcmVhdGVDaGlsZHJlbihuZXh0Q2hpbGRyZW4sIG5leHRFbGVtZW50LCAwLCBuZXh0Q2hpbGRyZW5TaXplIC0gMSwgZG9tLCBudWxsKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlblNpemUgPT09IDApIHtcbiAgICAgIGlmIChwcmV2Q2hpbGRyZW5TaXplICE9PSAwKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gICAgICAgIGNvbnN0IGxleGljYWxMaW5lQnJlYWsgPSBkb20uX19sZXhpY2FsTGluZUJyZWFrO1xuICAgICAgICBjb25zdCBjYW5Vc2VGYXN0UGF0aCA9IGxleGljYWxMaW5lQnJlYWsgPT0gbnVsbDtcbiAgICAgICAgZGVzdHJveUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgMCwgcHJldkNoaWxkcmVuU2l6ZSAtIDEsIGNhblVzZUZhc3RQYXRoID8gbnVsbCA6IGRvbSk7XG5cbiAgICAgICAgaWYgKGNhblVzZUZhc3RQYXRoKSB7XG4gICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciByZW1vdmluZyBET00gbm9kZXNcbiAgICAgICAgICBkb20udGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWNvbmNpbGVOb2RlQ2hpbGRyZW4obmV4dEVsZW1lbnQsIHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBwcmV2Q2hpbGRyZW5TaXplLCBuZXh0Q2hpbGRyZW5TaXplLCBkb20pO1xuICAgIH1cbiAgfVxuXG4gIGlmICgkdGV4dENvbnRlbnRSZXF1aXJlc0RvdWJsZUxpbmVicmVha0F0RW5kKG5leHRFbGVtZW50KSkge1xuICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSBET1VCTEVfTElORV9CUkVBSztcbiAgfSAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuXG5cbiAgZG9tLl9fbGV4aWNhbFRleHRDb250ZW50ID0gc3ViVHJlZVRleHRDb250ZW50O1xuICBzdWJUcmVlVGV4dENvbnRlbnQgPSBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudCArIHN1YlRyZWVUZXh0Q29udGVudDtcbn1cblxuZnVuY3Rpb24gcmVjb25jaWxlTm9kZShrZXksIHBhcmVudERPTSkge1xuICBjb25zdCBwcmV2Tm9kZSA9IGFjdGl2ZVByZXZOb2RlTWFwLmdldChrZXkpO1xuICBsZXQgbmV4dE5vZGUgPSBhY3RpdmVOZXh0Tm9kZU1hcC5nZXQoa2V5KTtcblxuICBpZiAocHJldk5vZGUgPT09IHVuZGVmaW5lZCB8fCBuZXh0Tm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYHJlY29uY2lsZU5vZGU6IHByZXZOb2RlIG9yIG5leHROb2RlIGRvZXMgbm90IGV4aXN0IGluIG5vZGVNYXBgKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBpc0RpcnR5ID0gdHJlYXRBbGxOb2Rlc0FzRGlydHkgfHwgYWN0aXZlRGlydHlMZWF2ZXMuaGFzKGtleSkgfHwgYWN0aXZlRGlydHlFbGVtZW50cy5oYXMoa2V5KTtcbiAgY29uc3QgZG9tID0gZ2V0RWxlbWVudEJ5S2V5T3JUaHJvdyhhY3RpdmVFZGl0b3IkMSwga2V5KTsgLy8gSWYgdGhlIG5vZGUga2V5IHBvaW50cyB0byB0aGUgc2FtZSBpbnN0YW5jZSBpbiBib3RoIHN0YXRlc1xuICAvLyBhbmQgaXNuJ3QgZGlydHksIHdlIGp1c3QgdXBkYXRlIHRoZSB0ZXh0IGNvbnRlbnQgY2FjaGVcbiAgLy8gYW5kIHJldHVybiB0aGUgZXhpc3RpbmcgRE9NIE5vZGUuXG5cbiAgaWYgKHByZXZOb2RlID09PSBuZXh0Tm9kZSAmJiAhaXNEaXJ0eSkge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShwcmV2Tm9kZSkpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gICAgICBjb25zdCBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudCA9IGRvbS5fX2xleGljYWxUZXh0Q29udGVudDtcblxuICAgICAgaWYgKHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3ViVHJlZVRleHRDb250ZW50ICs9IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50O1xuICAgICAgICBlZGl0b3JUZXh0Q29udGVudCArPSBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudDtcbiAgICAgIH0gLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcblxuXG4gICAgICBjb25zdCBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudCA9IGRvbS5fX2xleGljYWxEaXJUZXh0Q29udGVudDtcblxuICAgICAgaWYgKHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgKz0gcHJldmlvdXNTdWJUcmVlRGlyZWN0aW9uVGV4dENvbnRlbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRleHQgPSBwcmV2Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuXG4gICAgICBpZiAoJGlzVGV4dE5vZGUocHJldk5vZGUpICYmICFwcmV2Tm9kZS5pc0RpcmVjdGlvbmxlc3MoKSkge1xuICAgICAgICBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCArPSB0ZXh0O1xuICAgICAgfVxuXG4gICAgICBlZGl0b3JUZXh0Q29udGVudCArPSB0ZXh0O1xuICAgICAgc3ViVHJlZVRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvbTtcbiAgfSAvLyBJZiB0aGUgbm9kZSBrZXkgZG9lc24ndCBwb2ludCB0byB0aGUgc2FtZSBpbnN0YW5jZSBpbiBib3RoIG1hcHMsXG4gIC8vIGl0IG1lYW5zIGl0IHdlcmUgY2xvbmVkLiBJZiB0aGV5J3JlIGFsc28gZGlydHksIHdlIG1hcmsgdGhlbSBhcyBtdXRhdGVkLlxuXG5cbiAgaWYgKHByZXZOb2RlICE9PSBuZXh0Tm9kZSAmJiBpc0RpcnR5KSB7XG4gICAgc2V0TXV0YXRlZE5vZGUobXV0YXRlZE5vZGVzLCBhY3RpdmVFZGl0b3JOb2RlcywgYWN0aXZlTXV0YXRpb25MaXN0ZW5lcnMsIG5leHROb2RlLCAndXBkYXRlZCcpO1xuICB9IC8vIFVwZGF0ZSBub2RlLiBJZiBpdCByZXR1cm5zIHRydWUsIHdlIG5lZWQgdG8gdW5tb3VudCBhbmQgcmUtY3JlYXRlIHRoZSBub2RlXG5cblxuICBpZiAobmV4dE5vZGUudXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGFjdGl2ZUVkaXRvckNvbmZpZykpIHtcbiAgICBjb25zdCByZXBsYWNlbWVudERPTSA9IGNyZWF0ZU5vZGUoa2V5LCBudWxsLCBudWxsKTtcblxuICAgIGlmIChwYXJlbnRET00gPT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYHJlY29uY2lsZU5vZGU6IHBhcmVudERPTSBpcyBudWxsYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFyZW50RE9NLnJlcGxhY2VDaGlsZChyZXBsYWNlbWVudERPTSwgZG9tKTtcbiAgICBkZXN0cm95Tm9kZShrZXksIG51bGwpO1xuICAgIHJldHVybiByZXBsYWNlbWVudERPTTtcbiAgfVxuXG4gIGlmICgkaXNFbGVtZW50Tm9kZShwcmV2Tm9kZSkgJiYgJGlzRWxlbWVudE5vZGUobmV4dE5vZGUpKSB7XG4gICAgLy8gUmVjb25jaWxlIGVsZW1lbnQgY2hpbGRyZW5cbiAgICBjb25zdCBuZXh0SW5kZW50ID0gbmV4dE5vZGUuX19pbmRlbnQ7XG5cbiAgICBpZiAobmV4dEluZGVudCAhPT0gcHJldk5vZGUuX19pbmRlbnQpIHtcbiAgICAgIHNldEVsZW1lbnRJbmRlbnQoZG9tLCBuZXh0SW5kZW50KTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXh0Rm9ybWF0ID0gbmV4dE5vZGUuX19mb3JtYXQ7XG5cbiAgICBpZiAobmV4dEZvcm1hdCAhPT0gcHJldk5vZGUuX19mb3JtYXQpIHtcbiAgICAgIHNldEVsZW1lbnRGb3JtYXQoZG9tLCBuZXh0Rm9ybWF0KTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXJ0eSkge1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW5XaXRoRGlyZWN0aW9uKHByZXZOb2RlLCBuZXh0Tm9kZSwgZG9tKTtcblxuICAgICAgaWYgKCEkaXNSb290Tm9kZShuZXh0Tm9kZSkgJiYgIW5leHROb2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgcmVjb25jaWxlRWxlbWVudFRlcm1pbmF0aW5nTGluZUJyZWFrKHByZXZOb2RlLCBuZXh0Tm9kZSwgZG9tKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoJHRleHRDb250ZW50UmVxdWlyZXNEb3VibGVMaW5lYnJlYWtBdEVuZChuZXh0Tm9kZSkpIHtcbiAgICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSBET1VCTEVfTElORV9CUkVBSztcbiAgICAgIGVkaXRvclRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0ZXh0ID0gbmV4dE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcblxuICAgIGlmICgkaXNEZWNvcmF0b3JOb2RlKG5leHROb2RlKSkge1xuICAgICAgY29uc3QgZGVjb3JhdG9yID0gbmV4dE5vZGUuZGVjb3JhdGUoYWN0aXZlRWRpdG9yJDEsIGFjdGl2ZUVkaXRvckNvbmZpZyk7XG5cbiAgICAgIGlmIChkZWNvcmF0b3IgIT09IG51bGwpIHtcbiAgICAgICAgcmVjb25jaWxlRGVjb3JhdG9yKGtleSwgZGVjb3JhdG9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCRpc1RleHROb2RlKG5leHROb2RlKSAmJiAhbmV4dE5vZGUuaXNEaXJlY3Rpb25sZXNzKCkpIHtcbiAgICAgIC8vIEhhbmRsZSB0ZXh0IGNvbnRlbnQsIGZvciBMVFIsIExUUiBjYXNlcy5cbiAgICAgIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgfVxuXG4gICAgc3ViVHJlZVRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgfVxuXG4gIGlmICghYWN0aXZlRWRpdG9yU3RhdGVSZWFkT25seSAmJiAkaXNSb290Tm9kZShuZXh0Tm9kZSkgJiYgbmV4dE5vZGUuX19jYWNoZWRUZXh0ICE9PSBlZGl0b3JUZXh0Q29udGVudCkge1xuICAgIC8vIENhY2hlIHRoZSBsYXRlc3QgdGV4dCBjb250ZW50LlxuICAgIG5leHROb2RlID0gbmV4dE5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICBuZXh0Tm9kZS5fX2NhY2hlZFRleHQgPSBlZGl0b3JUZXh0Q29udGVudDtcbiAgfVxuXG4gIHtcbiAgICAvLyBGcmVlemUgdGhlIG5vZGUgaW4gREVWIHRvIHByZXZlbnQgYWNjaWRlbnRhbCBtdXRhdGlvbnNcbiAgICBPYmplY3QuZnJlZXplKG5leHROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBkb207XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZURlY29yYXRvcihrZXksIGRlY29yYXRvcikge1xuICBsZXQgcGVuZGluZ0RlY29yYXRvcnMgPSBhY3RpdmVFZGl0b3IkMS5fcGVuZGluZ0RlY29yYXRvcnM7XG4gIGNvbnN0IGN1cnJlbnREZWNvcmF0b3JzID0gYWN0aXZlRWRpdG9yJDEuX2RlY29yYXRvcnM7XG5cbiAgaWYgKHBlbmRpbmdEZWNvcmF0b3JzID09PSBudWxsKSB7XG4gICAgaWYgKGN1cnJlbnREZWNvcmF0b3JzW2tleV0gPT09IGRlY29yYXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBlbmRpbmdEZWNvcmF0b3JzID0gY2xvbmVEZWNvcmF0b3JzKGFjdGl2ZUVkaXRvciQxKTtcbiAgfVxuXG4gIHBlbmRpbmdEZWNvcmF0b3JzW2tleV0gPSBkZWNvcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGdldEZpcnN0Q2hpbGQoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5maXJzdENoaWxkO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0U2libGluZyhlbGVtZW50KSB7XG4gIGxldCBuZXh0U2libGluZyA9IGVsZW1lbnQubmV4dFNpYmxpbmc7XG5cbiAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsICYmIG5leHRTaWJsaW5nID09PSBhY3RpdmVFZGl0b3IkMS5fYmxvY2tDdXJzb3JFbGVtZW50KSB7XG4gICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5uZXh0U2libGluZztcbiAgfVxuXG4gIHJldHVybiBuZXh0U2libGluZztcbn1cblxuZnVuY3Rpb24gcmVjb25jaWxlTm9kZUNoaWxkcmVuKG5leHRFbGVtZW50LCBwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgcHJldkNoaWxkcmVuTGVuZ3RoLCBuZXh0Q2hpbGRyZW5MZW5ndGgsIGRvbSkge1xuICBjb25zdCBwcmV2RW5kSW5kZXggPSBwcmV2Q2hpbGRyZW5MZW5ndGggLSAxO1xuICBjb25zdCBuZXh0RW5kSW5kZXggPSBuZXh0Q2hpbGRyZW5MZW5ndGggLSAxO1xuICBsZXQgcHJldkNoaWxkcmVuU2V0O1xuICBsZXQgbmV4dENoaWxkcmVuU2V0O1xuICBsZXQgc2libGluZ0RPTSA9IGdldEZpcnN0Q2hpbGQoZG9tKTtcbiAgbGV0IHByZXZJbmRleCA9IDA7XG4gIGxldCBuZXh0SW5kZXggPSAwO1xuXG4gIHdoaWxlIChwcmV2SW5kZXggPD0gcHJldkVuZEluZGV4ICYmIG5leHRJbmRleCA8PSBuZXh0RW5kSW5kZXgpIHtcbiAgICBjb25zdCBwcmV2S2V5ID0gcHJldkNoaWxkcmVuW3ByZXZJbmRleF07XG4gICAgY29uc3QgbmV4dEtleSA9IG5leHRDaGlsZHJlbltuZXh0SW5kZXhdO1xuXG4gICAgaWYgKHByZXZLZXkgPT09IG5leHRLZXkpIHtcbiAgICAgIHNpYmxpbmdET00gPSBnZXROZXh0U2libGluZyhyZWNvbmNpbGVOb2RlKG5leHRLZXksIGRvbSkpO1xuICAgICAgcHJldkluZGV4Kys7XG4gICAgICBuZXh0SW5kZXgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByZXZDaGlsZHJlblNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByZXZDaGlsZHJlblNldCA9IG5ldyBTZXQocHJldkNoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRDaGlsZHJlblNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5leHRDaGlsZHJlblNldCA9IG5ldyBTZXQobmV4dENoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV4dEhhc1ByZXZLZXkgPSBuZXh0Q2hpbGRyZW5TZXQuaGFzKHByZXZLZXkpO1xuICAgICAgY29uc3QgcHJldkhhc05leHRLZXkgPSBwcmV2Q2hpbGRyZW5TZXQuaGFzKG5leHRLZXkpO1xuXG4gICAgICBpZiAoIW5leHRIYXNQcmV2S2V5KSB7XG4gICAgICAgIC8vIFJlbW92ZSBwcmV2XG4gICAgICAgIHNpYmxpbmdET00gPSBnZXROZXh0U2libGluZyhnZXRQcmV2RWxlbWVudEJ5S2V5T3JUaHJvdyhwcmV2S2V5KSk7XG4gICAgICAgIGRlc3Ryb3lOb2RlKHByZXZLZXksIGRvbSk7XG4gICAgICAgIHByZXZJbmRleCsrO1xuICAgICAgfSBlbHNlIGlmICghcHJldkhhc05leHRLZXkpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5leHRcbiAgICAgICAgY3JlYXRlTm9kZShuZXh0S2V5LCBkb20sIHNpYmxpbmdET00pO1xuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1vdmUgbmV4dFxuICAgICAgICBjb25zdCBjaGlsZERPTSA9IGdldEVsZW1lbnRCeUtleU9yVGhyb3coYWN0aXZlRWRpdG9yJDEsIG5leHRLZXkpO1xuXG4gICAgICAgIGlmIChjaGlsZERPTSA9PT0gc2libGluZ0RPTSkge1xuICAgICAgICAgIHNpYmxpbmdET00gPSBnZXROZXh0U2libGluZyhyZWNvbmNpbGVOb2RlKG5leHRLZXksIGRvbSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzaWJsaW5nRE9NICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvbS5pbnNlcnRCZWZvcmUoY2hpbGRET00sIHNpYmxpbmdET00pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoY2hpbGRET00pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlY29uY2lsZU5vZGUobmV4dEtleSwgZG9tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZJbmRleCsrO1xuICAgICAgICBuZXh0SW5kZXgrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBhcHBlbmROZXdDaGlsZHJlbiA9IHByZXZJbmRleCA+IHByZXZFbmRJbmRleDtcbiAgY29uc3QgcmVtb3ZlT2xkQ2hpbGRyZW4gPSBuZXh0SW5kZXggPiBuZXh0RW5kSW5kZXg7XG5cbiAgaWYgKGFwcGVuZE5ld0NoaWxkcmVuICYmICFyZW1vdmVPbGRDaGlsZHJlbikge1xuICAgIGNvbnN0IHByZXZpb3VzTm9kZSA9IG5leHRDaGlsZHJlbltuZXh0RW5kSW5kZXggKyAxXTtcbiAgICBjb25zdCBpbnNlcnRET00gPSBwcmV2aW91c05vZGUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhY3RpdmVFZGl0b3IkMS5nZXRFbGVtZW50QnlLZXkocHJldmlvdXNOb2RlKTtcbiAgICBjcmVhdGVDaGlsZHJlbihuZXh0Q2hpbGRyZW4sIG5leHRFbGVtZW50LCBuZXh0SW5kZXgsIG5leHRFbmRJbmRleCwgZG9tLCBpbnNlcnRET00pO1xuICB9IGVsc2UgaWYgKHJlbW92ZU9sZENoaWxkcmVuICYmICFhcHBlbmROZXdDaGlsZHJlbikge1xuICAgIGRlc3Ryb3lDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIHByZXZJbmRleCwgcHJldkVuZEluZGV4LCBkb20pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZVJvb3QocHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUsIGVkaXRvciwgZGlydHlUeXBlLCBkaXJ0eUVsZW1lbnRzLCBkaXJ0eUxlYXZlcykge1xuICAvLyBXZSBjYWNoZSB0ZXh0IGNvbnRlbnQgdG8gbWFrZSByZXRyaWV2YWwgbW9yZSBlZmZpY2llbnQuXG4gIC8vIFRoZSBjYWNoZSBtdXN0IGJlIHJlYnVpbHQgZHVyaW5nIHJlY29uY2lsaWF0aW9uIHRvIGFjY291bnQgZm9yIGFueSBjaGFuZ2VzLlxuICBzdWJUcmVlVGV4dENvbnRlbnQgPSAnJztcbiAgZWRpdG9yVGV4dENvbnRlbnQgPSAnJztcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSAnJzsgLy8gUmF0aGVyIHRoYW4gcGFzcyBhcm91bmQgYSBsb2FkIG9mIGFyZ3VtZW50cyB0aHJvdWdoIHRoZSBzdGFjayByZWN1cnNpdmVseVxuICAvLyB3ZSBpbnN0ZWFkIHNldCB0aGVtIGFzIGJpbmRpbmdzIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIG1vZHVsZS5cblxuICB0cmVhdEFsbE5vZGVzQXNEaXJ0eSA9IGRpcnR5VHlwZSA9PT0gRlVMTF9SRUNPTkNJTEU7XG4gIGFjdGl2ZVRleHREaXJlY3Rpb24gPSBudWxsO1xuICBhY3RpdmVFZGl0b3IkMSA9IGVkaXRvcjtcbiAgYWN0aXZlRWRpdG9yQ29uZmlnID0gZWRpdG9yLl9jb25maWc7XG4gIGFjdGl2ZUVkaXRvck5vZGVzID0gZWRpdG9yLl9ub2RlcztcbiAgYWN0aXZlTXV0YXRpb25MaXN0ZW5lcnMgPSBhY3RpdmVFZGl0b3IkMS5fbGlzdGVuZXJzLm11dGF0aW9uO1xuICBhY3RpdmVEaXJ0eUVsZW1lbnRzID0gZGlydHlFbGVtZW50cztcbiAgYWN0aXZlRGlydHlMZWF2ZXMgPSBkaXJ0eUxlYXZlcztcbiAgYWN0aXZlUHJldk5vZGVNYXAgPSBwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGFjdGl2ZU5leHROb2RlTWFwID0gbmV4dEVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBhY3RpdmVFZGl0b3JTdGF0ZVJlYWRPbmx5ID0gbmV4dEVkaXRvclN0YXRlLl9yZWFkT25seTtcbiAgYWN0aXZlUHJldktleVRvRE9NTWFwID0gbmV3IE1hcChlZGl0b3IuX2tleVRvRE9NTWFwKTsgLy8gV2Uga2VlcCB0cmFjayBvZiBtdXRhdGVkIG5vZGVzIHNvIHdlIGNhbiB0cmlnZ2VyIG11dGF0aW9uXG4gIC8vIGxpc3RlbmVycyBsYXRlciBpbiB0aGUgdXBkYXRlIGN5Y2xlLlxuXG4gIGNvbnN0IGN1cnJlbnRNdXRhdGVkTm9kZXMgPSBuZXcgTWFwKCk7XG4gIG11dGF0ZWROb2RlcyA9IGN1cnJlbnRNdXRhdGVkTm9kZXM7XG4gIHJlY29uY2lsZU5vZGUoJ3Jvb3QnLCBudWxsKTsgLy8gV2UgZG9uJ3Qgd2FudCBhIGJ1bmNoIG9mIHZvaWQgY2hlY2tzIHRocm91Z2hvdXQgdGhlIHNjb3BlXG4gIC8vIHNvIGluc3RlYWQgd2UgbWFrZSBpdCBzZWVtIHRoYXQgdGhlc2UgdmFsdWVzIGFyZSBhbHdheXMgc2V0LlxuICAvLyBXZSBhbHNvIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGNsZWFyIHRoZW0gZG93biwgb3RoZXJ3aXNlIHdlXG4gIC8vIGNhbiBsZWFrIG1lbW9yeS5cbiAgLy8gQHRzLWlnbm9yZVxuXG4gIGFjdGl2ZUVkaXRvciQxID0gdW5kZWZpbmVkOyAvLyBAdHMtaWdub3JlXG5cbiAgYWN0aXZlRWRpdG9yTm9kZXMgPSB1bmRlZmluZWQ7IC8vIEB0cy1pZ25vcmVcblxuICBhY3RpdmVEaXJ0eUVsZW1lbnRzID0gdW5kZWZpbmVkOyAvLyBAdHMtaWdub3JlXG5cbiAgYWN0aXZlRGlydHlMZWF2ZXMgPSB1bmRlZmluZWQ7IC8vIEB0cy1pZ25vcmVcblxuICBhY3RpdmVQcmV2Tm9kZU1hcCA9IHVuZGVmaW5lZDsgLy8gQHRzLWlnbm9yZVxuXG4gIGFjdGl2ZU5leHROb2RlTWFwID0gdW5kZWZpbmVkOyAvLyBAdHMtaWdub3JlXG5cbiAgYWN0aXZlRWRpdG9yQ29uZmlnID0gdW5kZWZpbmVkOyAvLyBAdHMtaWdub3JlXG5cbiAgYWN0aXZlUHJldktleVRvRE9NTWFwID0gdW5kZWZpbmVkOyAvLyBAdHMtaWdub3JlXG5cbiAgbXV0YXRlZE5vZGVzID0gdW5kZWZpbmVkO1xuICByZXR1cm4gY3VycmVudE11dGF0ZWROb2Rlcztcbn1cbmZ1bmN0aW9uIHN0b3JlRE9NV2l0aEtleShrZXksIGRvbSwgZWRpdG9yKSB7XG4gIGNvbnN0IGtleVRvRE9NTWFwID0gZWRpdG9yLl9rZXlUb0RPTU1hcDsgLy8gQHRzLWlnbm9yZSBXZSBpbnRlbnRpb25hbGx5IGFkZCB0aGlzIHRvIHRoZSBOb2RlLlxuXG4gIGRvbVsnX19sZXhpY2FsS2V5XycgKyBlZGl0b3IuX2tleV0gPSBrZXk7XG4gIGtleVRvRE9NTWFwLnNldChrZXksIGRvbSk7XG59XG5cbmZ1bmN0aW9uIGdldFByZXZFbGVtZW50QnlLZXlPclRocm93KGtleSkge1xuICBjb25zdCBlbGVtZW50ID0gYWN0aXZlUHJldktleVRvRE9NTWFwLmdldChrZXkpO1xuXG4gIGlmIChlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgUmVjb25jaWxpYXRpb246IGNvdWxkIG5vdCBmaW5kIERPTSBlbGVtZW50IGZvciBub2RlIGtleSAke2tleX1gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgUEFTU19USFJPVUdIX0NPTU1BTkQgPSBPYmplY3QuZnJlZXplKHt9KTtcbmNvbnN0IEFORFJPSURfQ09NUE9TSVRJT05fTEFURU5DWSA9IDMwO1xuY29uc3Qgcm9vdEVsZW1lbnRFdmVudHMgPSBbWydrZXlkb3duJywgb25LZXlEb3duXSwgWydwb2ludGVyZG93bicsIG9uUG9pbnRlckRvd25dLCBbJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnRdLCBbJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZF0sIFsnaW5wdXQnLCBvbklucHV0XSwgWydjbGljaycsIG9uQ2xpY2tdLCBbJ2N1dCcsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydjb3B5JywgUEFTU19USFJPVUdIX0NPTU1BTkRdLCBbJ2RyYWdzdGFydCcsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydkcmFnb3ZlcicsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydkcmFnZW5kJywgUEFTU19USFJPVUdIX0NPTU1BTkRdLCBbJ3Bhc3RlJywgUEFTU19USFJPVUdIX0NPTU1BTkRdLCBbJ2ZvY3VzJywgUEFTU19USFJPVUdIX0NPTU1BTkRdLCBbJ2JsdXInLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsnZHJvcCcsIFBBU1NfVEhST1VHSF9DT01NQU5EXV07XG5cbmlmIChDQU5fVVNFX0JFRk9SRV9JTlBVVCkge1xuICByb290RWxlbWVudEV2ZW50cy5wdXNoKFsnYmVmb3JlaW5wdXQnLCAoZXZlbnQsIGVkaXRvcikgPT4gb25CZWZvcmVJbnB1dChldmVudCwgZWRpdG9yKV0pO1xufVxuXG5sZXQgbGFzdEtleURvd25UaW1lU3RhbXAgPSAwO1xubGV0IGxhc3RLZXlDb2RlID0gMDtcbmxldCBsYXN0QmVmb3JlSW5wdXRJbnNlcnRUZXh0VGltZVN0YW1wID0gMDtcbmxldCB1bnByb2Nlc3NlZEJlZm9yZUlucHV0RGF0YSA9IG51bGw7XG5sZXQgcm9vdEVsZW1lbnRzUmVnaXN0ZXJlZCA9IDA7XG5sZXQgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlID0gZmFsc2U7XG5sZXQgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tTW91c2VEb3duID0gZmFsc2U7XG5sZXQgaXNJbnNlcnRMaW5lQnJlYWsgPSBmYWxzZTtcbmxldCBpc0ZpcmVmb3hFbmRpbmdDb21wb3NpdGlvbiA9IGZhbHNlO1xubGV0IGNvbGxhcHNlZFNlbGVjdGlvbkZvcm1hdCA9IFswLCAnJywgMCwgJ3Jvb3QnLCAwXTsgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBMZXhpY2FsIHNob3VsZCBhdHRlbXB0IHRvIG92ZXJyaWRlXG4vLyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIGZvciBpbnNlcnRpb24gb2YgdGV4dCBhbmQgdXNlIGl0cyBvd24gaW50ZXJuYWxcbi8vIGhldXJpc3RpY3MuIFRoaXMgaXMgYW4gZXh0cmVtZWx5IGltcG9ydGFudCBmdW5jdGlvbiwgYW5kIG1ha2VzIG11Y2ggb2YgTGV4aWNhbFxuLy8gd29yayBhcyBpbnRlbmRlZCBiZXR3ZWVuIGRpZmZlcmVudCBicm93c2VycyBhbmQgYWNyb3NzIHdvcmQsIGxpbmUgYW5kIGNoYXJhY3RlclxuLy8gYm91bmRhcnkvZm9ybWF0cy4gSXQgYWxzbyBpcyBpbXBvcnRhbnQgZm9yIHRleHQgcmVwbGFjZW1lbnQsIG5vZGUgc2NoZW1hcyBhbmRcbi8vIGNvbXBvc2l0aW9uIG1lY2hhbmljcy5cblxuZnVuY3Rpb24gJHNob3VsZFByZXZlbnREZWZhdWx0QW5kSW5zZXJ0VGV4dChzZWxlY3Rpb24sIGRvbVRhcmdldFJhbmdlLCB0ZXh0LCB0aW1lU3RhbXAsIGlzQmVmb3JlSW5wdXQpIHtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvci5fd2luZG93KTtcbiAgY29uc3QgZG9tQW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbiAhPT0gbnVsbCA/IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlIDogbnVsbDtcbiAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yLmtleTtcbiAgY29uc3QgYmFja2luZ0FuY2hvckVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvcktleSk7XG4gIGNvbnN0IHRleHRMZW5ndGggPSB0ZXh0Lmxlbmd0aDtcbiAgcmV0dXJuIGFuY2hvcktleSAhPT0gZm9jdXMua2V5IHx8IC8vIElmIHdlJ3JlIHdvcmtpbmcgd2l0aCBhIG5vbi10ZXh0IG5vZGUuXG4gICEkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSB8fCAvLyBJZiB3ZSBhcmUgcmVwbGFjaW5nIGEgcmFuZ2Ugd2l0aCBhIHNpbmdsZSBjaGFyYWN0ZXIgb3IgZ3JhcGhlbWUsIGFuZCBub3QgY29tcG9zaW5nLlxuICAoIWlzQmVmb3JlSW5wdXQgJiYgKCFDQU5fVVNFX0JFRk9SRV9JTlBVVCB8fCAvLyBXZSBjaGVjayB0byBzZWUgaWYgdGhlcmUgaGFzIGJlZW5cbiAgLy8gYSByZWNlbnQgYmVmb3JlaW5wdXQgZXZlbnQgZm9yIFwidGV4dElucHV0XCIuIElmIHRoZXJlIGhhcyBiZWVuIG9uZSBpbiB0aGUgbGFzdFxuICAvLyA1MG1zIHRoZW4gd2UgcHJvY2VlZCBhcyBub3JtYWwuIEhvd2V2ZXIsIGlmIHRoZXJlIGlzIG5vdCwgdGhlbiB0aGlzIGlzIGxpa2VseVxuICAvLyBhIGRhbmdsaW5nIGBpbnB1dGAgZXZlbnQgY2F1c2VkIGJ5IGV4ZWNDb21tYW5kKCdpbnNlcnRUZXh0JykuXG4gIGxhc3RCZWZvcmVJbnB1dEluc2VydFRleHRUaW1lU3RhbXAgPCB0aW1lU3RhbXAgKyA1MCkgfHwgYW5jaG9yTm9kZS5pc0RpcnR5KCkgJiYgdGV4dExlbmd0aCA8IDIgfHwgZG9lc0NvbnRhaW5HcmFwaGVtZSh0ZXh0KSkgJiYgYW5jaG9yLm9mZnNldCAhPT0gZm9jdXMub2Zmc2V0ICYmICFhbmNob3JOb2RlLmlzQ29tcG9zaW5nKCkgfHwgLy8gQW55IG5vbiBzdGFuZGFyZCB0ZXh0IG5vZGUuXG4gICRpc1Rva2VuT3JTZWdtZW50ZWQoYW5jaG9yTm9kZSkgfHwgLy8gSWYgdGhlIHRleHQgbGVuZ3RoIGlzIG1vcmUgdGhhbiBhIHNpbmdsZSBjaGFyYWN0ZXIgYW5kIHdlJ3JlIGVpdGhlclxuICAvLyBkZWFsaW5nIHdpdGggdGhpcyBpbiBcImJlZm9yZWlucHV0XCIgb3Igd2hlcmUgdGhlIG5vZGUgaGFzIGFscmVhZHkgcmVjZW50bHlcbiAgLy8gYmVlbiBjaGFuZ2VkICh0aHVzIGlzIGRpcnR5KS5cbiAgYW5jaG9yTm9kZS5pc0RpcnR5KCkgJiYgdGV4dExlbmd0aCA+IDEgfHwgLy8gSWYgdGhlIERPTSBzZWxlY3Rpb24gZWxlbWVudCBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIGJhY2tpbmcgbm9kZSBkdXJpbmcgYmVmb3JlaW5wdXQuXG4gIChpc0JlZm9yZUlucHV0IHx8ICFDQU5fVVNFX0JFRk9SRV9JTlBVVCkgJiYgYmFja2luZ0FuY2hvckVsZW1lbnQgIT09IG51bGwgJiYgIWFuY2hvck5vZGUuaXNDb21wb3NpbmcoKSAmJiBkb21BbmNob3JOb2RlICE9PSBnZXRET01UZXh0Tm9kZShiYWNraW5nQW5jaG9yRWxlbWVudCkgfHwgLy8gSWYgVGFyZ2V0UmFuZ2UgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBET00gc2VsZWN0aW9uOyBicm93c2VyIHRyeWluZyB0byBlZGl0IHJhbmRvbSBwYXJ0c1xuICAvLyBvZiB0aGUgZWRpdG9yLlxuICBkb21TZWxlY3Rpb24gIT09IG51bGwgJiYgZG9tVGFyZ2V0UmFuZ2UgIT09IG51bGwgJiYgKCFkb21UYXJnZXRSYW5nZS5jb2xsYXBzZWQgfHwgZG9tVGFyZ2V0UmFuZ2Uuc3RhcnRDb250YWluZXIgIT09IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlIHx8IGRvbVRhcmdldFJhbmdlLnN0YXJ0T2Zmc2V0ICE9PSBkb21TZWxlY3Rpb24uYW5jaG9yT2Zmc2V0KSB8fCAvLyBDaGVjayBpZiB3ZSdyZSBjaGFuZ2luZyBmcm9tIGJvbGQgdG8gaXRhbGljcywgb3Igc29tZSBvdGhlciBmb3JtYXQuXG4gIGFuY2hvck5vZGUuZ2V0Rm9ybWF0KCkgIT09IHNlbGVjdGlvbi5mb3JtYXQgfHwgYW5jaG9yTm9kZS5nZXRTdHlsZSgpICE9PSBzZWxlY3Rpb24uc3R5bGUgfHwgLy8gT25lIGxhc3Qgc2V0IG9mIGhldXJpc3RpY3MgdG8gY2hlY2sgYWdhaW5zdC5cbiAgJHNob3VsZEluc2VydFRleHRBZnRlck9yQmVmb3JlVGV4dE5vZGUoc2VsZWN0aW9uLCBhbmNob3JOb2RlKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkU2tpcFNlbGVjdGlvbkNoYW5nZShkb21Ob2RlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGRvbU5vZGUgIT09IG51bGwgJiYgZG9tTm9kZS5ub2RlVmFsdWUgIT09IG51bGwgJiYgZG9tTm9kZS5ub2RlVHlwZSA9PT0gRE9NX1RFWFRfVFlQRSAmJiBvZmZzZXQgIT09IDAgJiYgb2Zmc2V0ICE9PSBkb21Ob2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIG9uU2VsZWN0aW9uQ2hhbmdlKGRvbVNlbGVjdGlvbiwgZWRpdG9yLCBpc0FjdGl2ZSkge1xuICBjb25zdCB7XG4gICAgYW5jaG9yTm9kZTogYW5jaG9yRE9NLFxuICAgIGFuY2hvck9mZnNldCxcbiAgICBmb2N1c05vZGU6IGZvY3VzRE9NLFxuICAgIGZvY3VzT2Zmc2V0XG4gIH0gPSBkb21TZWxlY3Rpb247XG5cbiAgaWYgKGlzU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSkge1xuICAgIGlzU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSA9IGZhbHNlOyAvLyBJZiBuYXRpdmUgRE9NIHNlbGVjdGlvbiBpcyBvbiBhIERPTSBlbGVtZW50LCB0aGVuXG4gICAgLy8gd2Ugc2hvdWxkIGNvbnRpbnVlIGFzIHVzdWFsLCBhcyBMZXhpY2FsJ3Mgc2VsZWN0aW9uXG4gICAgLy8gbWF5IGhhdmUgbm9ybWFsaXplZCB0byBhIGJldHRlciBjaGlsZC4gSWYgdGhlIERPTVxuICAgIC8vIGVsZW1lbnQgaXMgYSB0ZXh0IG5vZGUsIHdlIGNhbiBzYWZlbHkgYXBwbHkgdGhpc1xuICAgIC8vIG9wdGltaXphdGlvbiBhbmQgc2tpcCB0aGUgc2VsZWN0aW9uIGNoYW5nZSBlbnRpcmVseS5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gY2hlY2sgaWYgdGhlIG9mZnNldCBpcyBhdCB0aGUgYm91bmRhcnksXG4gICAgLy8gYmVjYXVzZSBpbiB0aGlzIGNhc2UsIHdlIG1pZ2h0IG5lZWQgdG8gbm9ybWFsaXplIHRvIGFcbiAgICAvLyBzaWJsaW5nIGluc3RlYWQuXG5cbiAgICBpZiAoc2hvdWxkU2tpcFNlbGVjdGlvbkNoYW5nZShhbmNob3JET00sIGFuY2hvck9mZnNldCkgJiYgc2hvdWxkU2tpcFNlbGVjdGlvbkNoYW5nZShmb2N1c0RPTSwgZm9jdXNPZmZzZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgIC8vIE5vbi1hY3RpdmUgZWRpdG9yIGRvbid0IG5lZWQgYW55IGV4dHJhIGxvZ2ljIGZvciBzZWxlY3Rpb24sIGl0IG9ubHkgbmVlZHMgdXBkYXRlXG4gICAgLy8gdG8gcmVjb25jaWxlIHNlbGVjdGlvbiAoc2V0IGl0IHRvIG51bGwpIHRvIGVuc3VyZSB0aGF0IG9ubHkgb25lIGVkaXRvciBoYXMgbm9uLW51bGwgc2VsZWN0aW9uLlxuICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgICRzZXRTZWxlY3Rpb24obnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpOyAvLyBVcGRhdGUgdGhlIHNlbGVjdGlvbiBmb3JtYXRcblxuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICAvLyBCYWRseSBpbnRlcnByZXRlZCByYW5nZSBzZWxlY3Rpb24gd2hlbiBjb2xsYXBzZWQgLSAjMTQ4MlxuICAgICAgICBpZiAoZG9tU2VsZWN0aW9uLnR5cGUgPT09ICdSYW5nZScgJiYgZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IGRvbVNlbGVjdGlvbi5mb2N1c05vZGUpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICAgICAgICB9IC8vIElmIHdlIGhhdmUgbWFya2VkIGEgY29sbGFwc2VkIHNlbGVjdGlvbiBmb3JtYXQsIGFuZCB3ZSdyZVxuICAgICAgICAvLyB3aXRoaW4gdGhlIGdpdmVuIHRpbWUgcmFuZ2Ug4oCTIHRoZW4gYXR0ZW1wdCB0byB1c2UgdGhhdCBmb3JtYXRcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBnZXR0aW5nIHRoZSBmb3JtYXQgZnJvbSB0aGUgYW5jaG9yIG5vZGUuXG5cblxuICAgICAgICBjb25zdCB3aW5kb3dFdmVudCA9IGdldFdpbmRvdyhlZGl0b3IpLmV2ZW50O1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZVN0YW1wID0gd2luZG93RXZlbnQgPyB3aW5kb3dFdmVudC50aW1lU3RhbXAgOiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgY29uc3QgW2xhc3RGb3JtYXQsIGxhc3RTdHlsZSwgbGFzdE9mZnNldCwgbGFzdEtleSwgdGltZVN0YW1wXSA9IGNvbGxhcHNlZFNlbGVjdGlvbkZvcm1hdDtcblxuICAgICAgICBpZiAoY3VycmVudFRpbWVTdGFtcCA8IHRpbWVTdGFtcCArIDIwMCAmJiBhbmNob3Iub2Zmc2V0ID09PSBsYXN0T2Zmc2V0ICYmIGFuY2hvci5rZXkgPT09IGxhc3RLZXkpIHtcbiAgICAgICAgICBzZWxlY3Rpb24uZm9ybWF0ID0gbGFzdEZvcm1hdDtcbiAgICAgICAgICBzZWxlY3Rpb24uc3R5bGUgPSBsYXN0U3R5bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFuY2hvci50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbi5mb3JtYXQgPSBhbmNob3JOb2RlLmdldEZvcm1hdCgpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLnN0eWxlID0gYW5jaG9yTm9kZS5nZXRTdHlsZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgICAgICAgICAgc2VsZWN0aW9uLmZvcm1hdCA9IDA7XG4gICAgICAgICAgICBzZWxlY3Rpb24uc3R5bGUgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjb21iaW5lZEZvcm1hdCA9IElTX0FMTF9GT1JNQVRUSU5HO1xuICAgICAgICBsZXQgaGFzVGV4dE5vZGVzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICAgIGNvbnN0IG5vZGVzTGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgICAgICAgLy8gVE9ETzogd2hhdCBhYm91dCBzdHlsZT9cbiAgICAgICAgICAgIGhhc1RleHROb2RlcyA9IHRydWU7XG4gICAgICAgICAgICBjb21iaW5lZEZvcm1hdCAmPSBub2RlLmdldEZvcm1hdCgpO1xuXG4gICAgICAgICAgICBpZiAoY29tYmluZWRGb3JtYXQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0aW9uLmZvcm1hdCA9IGhhc1RleHROb2RlcyA/IGNvbWJpbmVkRm9ybWF0IDogMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH0pO1xufSAvLyBUaGlzIGlzIGEgd29yay1hcm91bmQgaXMgbWFpbmx5IENocm9tZSBzcGVjaWZpYyBidWcgd2hlcmUgaWYgeW91IHNlbGVjdFxuLy8gdGhlIGNvbnRlbnRzIG9mIGFuIGVtcHR5IGJsb2NrLCB5b3UgY2Fubm90IGVhc2lseSB1bnNlbGVjdCBhbnl0aGluZy5cbi8vIFRoaXMgcmVzdWx0cyBpbiBhIHRpbnkgc2VsZWN0aW9uIGJveCB0aGF0IGxvb2tzIGJ1Z2d5L2Jyb2tlbi4gVGhpcyBjYW5cbi8vIGFsc28gaGVscCBvdGhlciBicm93c2VycyB3aGVuIHNlbGVjdGlvbiBtaWdodCBcImFwcGVhclwiIGxvc3QsIHdoZW4gaXRcbi8vIHJlYWxseSBpc24ndC5cblxuXG5mdW5jdGlvbiBvbkNsaWNrKGV2ZW50LCBlZGl0b3IpIHtcbiAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICAgIGNvbnN0IGxhc3RTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcblxuICAgIGlmIChkb21TZWxlY3Rpb24pIHtcbiAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuXG4gICAgICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGFuY2hvci5vZmZzZXQgPT09IDAgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgISRpc1Jvb3ROb2RlKGFuY2hvck5vZGUpICYmICRnZXRSb290KCkuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDEgJiYgYW5jaG9yTm9kZS5nZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCkuaXNFbXB0eSgpICYmIGxhc3RTZWxlY3Rpb24gIT09IG51bGwgJiYgc2VsZWN0aW9uLmlzKGxhc3RTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGV0YWlsID09PSAzICYmICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICAgIC8vIFRyaXBwbGUgY2xpY2sgY2F1c2luZyBzZWxlY3Rpb24gdG8gb3ZlcmZsb3cgaW50byB0aGUgbmVhcmVzdCBlbGVtZW50LiBJbiB0aGF0XG4gICAgICAgICAgLy8gY2FzZSB2aXN1YWxseSBpdCBsb29rcyBsaWtlIGEgc2luZ2xlIGVsZW1lbnQgY29udGVudCBpcyBzZWxlY3RlZCwgZm9jdXMgbm9kZVxuICAgICAgICAgIC8vIGlzIGFjdHVhbGx5IGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgZWxlbWVudCAoaWYgcHJlc2VudCkgYW5kIGFueSBtYW5pcHVsYXRpb25zXG4gICAgICAgICAgLy8gd2l0aCBzZWxlY3Rpb24gKGZvcm1hdHRpbmcpIGFyZSBhZmZlY3Rpbmcgc2Vjb25kIGVsZW1lbnQgYXMgd2VsbFxuICAgICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcblxuICAgICAgICAgIGlmIChhbmNob3JOb2RlICE9PSBmb2N1c05vZGUpIHtcbiAgICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgICBhbmNob3JOb2RlLnNlbGVjdCgwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFuY2hvck5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgc2VsZWN0aW9uIG9uIHRvdWNoIGRldmljZXMgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGV4dCBhZnRlciBhXG4gICAgICAgIC8vIG5vZGUgc2VsZWN0aW9uLiBTZWUgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tTW91c2VEb3duIGZvciB0aGUgaW52ZXJzZVxuICAgICAgICBjb25zdCBkb21BbmNob3JOb2RlID0gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGU7XG5cbiAgICAgICAgaWYgKGRvbUFuY2hvck5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBub2RlVHlwZSA9IGRvbUFuY2hvck5vZGUubm9kZVR5cGU7IC8vIElmIHRoZSB1c2VyIGlzIGF0dGVtcHRpbmcgdG8gY2xpY2sgc2VsZWN0aW9uIGJhY2sgb250byB0ZXh0LCB0aGVuXG4gICAgICAgICAgLy8gd2Ugc2hvdWxkIGF0dGVtcHQgY3JlYXRlIGEgcmFuZ2Ugc2VsZWN0aW9uLlxuICAgICAgICAgIC8vIFdoZW4gd2UgY2xpY2sgb24gYW4gZW1wdHkgcGFyYWdyYXBoIG5vZGUgb3IgdGhlIGVuZCBvZiBhIHBhcmFncmFwaCB0aGF0IGVuZHNcbiAgICAgICAgICAvLyB3aXRoIGFuIGltYWdlL3BvbGwsIHRoZSBub2RlVHlwZSB3aWxsIGJlIEVMRU1FTlRfTk9ERVxuXG4gICAgICAgICAgaWYgKG5vZGVUeXBlID09PSBET01fRUxFTUVOVF9UWVBFIHx8IG5vZGVUeXBlID09PSBET01fVEVYVF9UWVBFKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSBpbnRlcm5hbENyZWF0ZVJhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24sIGRvbVNlbGVjdGlvbiwgZWRpdG9yKTtcbiAgICAgICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDTElDS19DT01NQU5ELCBldmVudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvblBvaW50ZXJEb3duKGV2ZW50LCBlZGl0b3IpIHtcbiAgLy8gVE9ETyBpbXBsZW1lbnQgdGV4dCBkcmFnICYgZHJvcFxuICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIGNvbnN0IHBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG5cbiAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIE5vZGUgJiYgcG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHtcbiAgICB1cGRhdGVFZGl0b3IoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAvLyBEcmFnICYgZHJvcCBzaG91bGQgbm90IHJlY29tcHV0ZSBzZWxlY3Rpb24gdW50aWwgbW91c2UgdXA7IG90aGVyd2lzZSB0aGUgaW5pdGlhbGx5XG4gICAgICAvLyBzZWxlY3RlZCBjb250ZW50IGlzIGxvc3QuXG4gICAgICBpZiAoISRpc1NlbGVjdGlvbkNhcHR1cmVkSW5EZWNvcmF0b3IodGFyZ2V0KSkge1xuICAgICAgICBpc1NlbGVjdGlvbkNoYW5nZUZyb21Nb3VzZURvd24gPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldFJhbmdlKGV2ZW50KSB7XG4gIGlmICghZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB0YXJnZXRSYW5nZXMgPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKTtcblxuICBpZiAodGFyZ2V0UmFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldFJhbmdlc1swXTtcbn1cblxuZnVuY3Rpb24gJGNhblJlbW92ZVRleHQoYW5jaG9yTm9kZSwgZm9jdXNOb2RlKSB7XG4gIHJldHVybiBhbmNob3JOb2RlICE9PSBmb2N1c05vZGUgfHwgJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkgfHwgJGlzRWxlbWVudE5vZGUoZm9jdXNOb2RlKSB8fCAhYW5jaG9yTm9kZS5pc1Rva2VuKCkgfHwgIWZvY3VzTm9kZS5pc1Rva2VuKCk7XG59XG5cbmZ1bmN0aW9uIGlzUG9zc2libHlBbmRyb2lkS2V5UHJlc3ModGltZVN0YW1wKSB7XG4gIHJldHVybiBsYXN0S2V5Q29kZSA9PT0gMjI5ICYmIHRpbWVTdGFtcCA8IGxhc3RLZXlEb3duVGltZVN0YW1wICsgQU5EUk9JRF9DT01QT1NJVElPTl9MQVRFTkNZO1xufVxuXG5mdW5jdGlvbiBvbkJlZm9yZUlucHV0KGV2ZW50LCBlZGl0b3IpIHtcbiAgY29uc3QgaW5wdXRUeXBlID0gZXZlbnQuaW5wdXRUeXBlO1xuICBjb25zdCB0YXJnZXRSYW5nZSA9IGdldFRhcmdldFJhbmdlKGV2ZW50KTsgLy8gV2UgbGV0IHRoZSBicm93c2VyIGRvIGl0cyBvd24gdGhpbmcgZm9yIGNvbXBvc2l0aW9uLlxuXG4gIGlmIChpbnB1dFR5cGUgPT09ICdkZWxldGVDb21wb3NpdGlvblRleHQnIHx8IC8vIElmIHdlJ3JlIHBhc3RpbmcgaW4gRkYsIHdlIHNob3VsZG4ndCBnZXQgdGhpcyBldmVudFxuICAvLyBhcyB0aGUgYHBhc3RlYCBldmVudCBzaG91bGQgaGF2ZSB0cmlnZ2VyZWQsIHVubGVzcyB0aGVcbiAgLy8gdXNlciBoYXMgZG9tLmV2ZW50LmNsaXBib2FyZGV2ZW50cy5lbmFibGVkIGRpc2FibGVkIGluXG4gIC8vIGFib3V0OmNvbmZpZy4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlXG4gIC8vIHBhc3RlZCBjb250ZW50IGluIHRoZSBET00gbXV0YXRpb24gcGhhc2UuXG4gIElTX0ZJUkVGT1ggJiYgaXNGaXJlZm94Q2xpcGJvYXJkRXZlbnRzKGVkaXRvcikpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoaW5wdXRUeXBlID09PSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoaW5wdXRUeXBlID09PSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJykge1xuICAgICAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBVc2UgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcblxuICAgICAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgJHNldFNlbGVjdGlvbihwcmV2U2VsZWN0aW9uLmNsb25lKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICAvLyBVc2VkIGZvciBoYW5kbGluZyBiYWNrc3BhY2UgaW4gQW5kcm9pZC5cbiAgICAgICAgaWYgKGlzUG9zc2libHlBbmRyb2lkS2V5UHJlc3MoZXZlbnQudGltZVN0YW1wKSAmJiBlZGl0b3IuaXNDb21wb3NpbmcoKSAmJiBzZWxlY3Rpb24uYW5jaG9yLmtleSA9PT0gc2VsZWN0aW9uLmZvY3VzLmtleSkge1xuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgICAgICBsYXN0S2V5RG93blRpbWVTdGFtcCA9IDA7IC8vIEZpeGVzIGFuIEFuZHJvaWQgYnVnIHdoZXJlIHNlbGVjdGlvbiBmbGlja2VycyB3aGVuIGJhY2tzcGFjaW5nXG5cbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZUVkaXRvcihlZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgQU5EUk9JRF9DT01QT1NJVElPTl9MQVRFTkNZKTtcblxuICAgICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgICAgICBhbmNob3JOb2RlLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLmZvcm1hdCA9IGFuY2hvck5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uc3R5bGUgPSBhbmNob3JOb2RlLmdldFN0eWxlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YTsgLy8gVGhpcyByZXByZXNlbnRzIHRoZSBjYXNlIHdoZW4gdHdvIGJlZm9yZWlucHV0IGV2ZW50cyBhcmUgdHJpZ2dlcmVkIGF0IHRoZSBzYW1lIHRpbWUgKHdpdGhvdXQgYVxuICAgIC8vIGZ1bGwgZXZlbnQgbG9vcCBlbmRpbmcgYXQgaW5wdXQpLiBUaGlzIGhhcHBlbnMgd2l0aCBNYWNPUyB3aXRoIHRoZSBkZWZhdWx0IGtleWJvYXJkIHNldHRpbmdzLFxuICAgIC8vIGEgY29tYmluYXRpb24gb2YgYXV0b2NvcnJlY3Rpb24gKyBhdXRvY2FwaXRhbGl6YXRpb24uXG4gICAgLy8gSGF2aW5nIExleGljYWwgcnVuIGV2ZXJ5dGhpbmcgaW4gY29udHJvbGxlZCBtb2RlIHdvdWxkIGZpeCB0aGUgaXNzdWUgd2l0aG91dCBhZGRpdGlvbmFsIGNvZGVcbiAgICAvLyBidXQgdGhpcyB3b3VsZCBraWxsIHRoZSBtYXNzaXZlIHBlcmZvcm1hbmNlIHdpbiBmcm9tIHRoZSBtb3N0IGNvbW1vbiB0eXBpbmcgZXZlbnQuXG4gICAgLy8gQWx0ZXJuYXRpdmVseSwgd2hlbiB0aGlzIGhhcHBlbnMgd2UgY2FuIHByZW1hdHVyZWx5IHVwZGF0ZSBvdXIgRWRpdG9yU3RhdGUgYmFzZWQgb24gdGhlIERPTVxuICAgIC8vIGNvbnRlbnQsIGEgam9iIHRoYXQgd291bGQgdXN1YWxseSBiZSB0aGUgaW5wdXQgZXZlbnQncyByZXNwb25zaWJpbGl0eS5cblxuICAgIGlmICh1bnByb2Nlc3NlZEJlZm9yZUlucHV0RGF0YSAhPT0gbnVsbCkge1xuICAgICAgJHVwZGF0ZVNlbGVjdGVkVGV4dEZyb21ET00oZmFsc2UsIGVkaXRvciwgdW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEpO1xuICAgIH1cblxuICAgIGlmICgoIXNlbGVjdGlvbi5kaXJ0eSB8fCB1bnByb2Nlc3NlZEJlZm9yZUlucHV0RGF0YSAhPT0gbnVsbCkgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgISRpc1Jvb3ROb2RlKHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKSAmJiB0YXJnZXRSYW5nZSAhPT0gbnVsbCkge1xuICAgICAgc2VsZWN0aW9uLmFwcGx5RE9NUmFuZ2UodGFyZ2V0UmFuZ2UpO1xuICAgIH1cblxuICAgIHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhID0gbnVsbDtcbiAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcblxuICAgIGlmIChpbnB1dFR5cGUgPT09ICdpbnNlcnRUZXh0JyB8fCBpbnB1dFR5cGUgPT09ICdpbnNlcnRUcmFuc3Bvc2UnKSB7XG4gICAgICBpZiAoZGF0YSA9PT0gJ1xcbicpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBET1VCTEVfTElORV9CUkVBSykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgPT0gbnVsbCAmJiBldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgLy8gR2V0cyBhcm91bmQgYSBTYWZhcmkgdGV4dCByZXBsYWNlbWVudCBidWcuXG4gICAgICAgIGNvbnN0IHRleHQgPSBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dCh0ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSAhPSBudWxsICYmICRzaG91bGRQcmV2ZW50RGVmYXVsdEFuZEluc2VydFRleHQoc2VsZWN0aW9uLCB0YXJnZXRSYW5nZSwgZGF0YSwgZXZlbnQudGltZVN0YW1wLCB0cnVlKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEgPSBkYXRhO1xuICAgICAgfVxuXG4gICAgICBsYXN0QmVmb3JlSW5wdXRJbnNlcnRUZXh0VGltZVN0YW1wID0gZXZlbnQudGltZVN0YW1wO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gUHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGNhcnJ5aW5nIG91dFxuICAgIC8vIHRoZSBpbnB1dCBldmVudCwgc28gd2UgY2FuIGNvbnRyb2wgdGhlXG4gICAgLy8gb3V0cHV0LlxuXG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgc3dpdGNoIChpbnB1dFR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydEZyb21ZYW5rJzpcbiAgICAgIGNhc2UgJ2luc2VydEZyb21Ecm9wJzpcbiAgICAgIGNhc2UgJ2luc2VydFJlcGxhY2VtZW50VGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRGcm9tQ29tcG9zaXRpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uXG4gICAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2luc2VydExpbmVCcmVhayc6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBVc2VkIGZvciBBbmRyb2lkXG4gICAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIElOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRQYXJhZ3JhcGgnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVXNlZCBmb3IgQW5kcm9pZFxuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTsgLy8gU2FmYXJpIGRvZXMgbm90IHByb3ZpZGUgdGhlIHR5cGUgXCJpbnNlcnRMaW5lQnJlYWtcIi5cbiAgICAgICAgICAvLyBTbyBpbnN0ZWFkLCB3ZSBuZWVkIHRvIGluZmVyIGl0IGZyb20gdGhlIGtleWJvYXJkIGV2ZW50LlxuICAgICAgICAgIC8vIFdlIGRvIG5vdCBhcHBseSB0aGlzIGxvZ2ljIHRvIGlPUyB0byBhbGxvdyBuZXdsaW5lIGF1dG8tY2FwaXRhbGl6YXRpb25cbiAgICAgICAgICAvLyB3b3JrIHdpdGhvdXQgY3JlYXRpbmcgbGluZWJyZWFrcyB3aGVuIHByZXNzaW5nIEVudGVyXG5cbiAgICAgICAgICBpZiAoaXNJbnNlcnRMaW5lQnJlYWsgJiYgIUlTX0lPUykge1xuICAgICAgICAgICAgaXNJbnNlcnRMaW5lQnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIElOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2luc2VydEZyb21QYXN0ZSc6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tUGFzdGVBc1F1b3RhdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBQQVNURV9DT01NQU5ELCBldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlQnlDb21wb3NpdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoJGNhblJlbW92ZVRleHQoYW5jaG9yTm9kZSwgZm9jdXNOb2RlKSkge1xuICAgICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUkVNT1ZFX1RFWFRfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5RHJhZyc6XG4gICAgICBjYXNlICdkZWxldGVCeUN1dCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBSRU1PVkVfVEVYVF9DT01NQU5ELCBldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlQ29udGVudCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVXb3JkQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX1dPUkRfQ09NTUFORCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlV29yZEZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX1dPUkRfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lQmFja3dhcmQnOlxuICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVCYWNrd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfTElORV9DT01NQU5ELCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVDb250ZW50Rm9yd2FyZCc6XG4gICAgICBjYXNlICdkZWxldGVIYXJkTGluZUZvcndhcmQnOlxuICAgICAgY2FzZSAnZGVsZXRlU29mdExpbmVGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9MSU5FX0NPTU1BTkQsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdmb3JtYXRTdHJpa2VUaHJvdWdoJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICdzdHJpa2V0aHJvdWdoJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZm9ybWF0Qm9sZCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBGT1JNQVRfVEVYVF9DT01NQU5ELCAnYm9sZCcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2Zvcm1hdEl0YWxpYyc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBGT1JNQVRfVEVYVF9DT01NQU5ELCAnaXRhbGljJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZm9ybWF0VW5kZXJsaW5lJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICd1bmRlcmxpbmUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdoaXN0b3J5VW5kbyc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBVTkRPX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaGlzdG9yeVJlZG8nOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUkVET19DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvbklucHV0KGV2ZW50LCBlZGl0b3IpIHtcbiAgLy8gV2UgZG9uJ3Qgd2FudCB0aGUgb25JbnB1dCB0byBidWJibGUsIGluIHRoZSBjYXNlIG9mIG5lc3RlZCBlZGl0b3JzLlxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICBjb25zdCB0YXJnZXRSYW5nZSA9IGdldFRhcmdldFJhbmdlKGV2ZW50KTtcblxuICAgIGlmIChkYXRhICE9IG51bGwgJiYgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAkc2hvdWxkUHJldmVudERlZmF1bHRBbmRJbnNlcnRUZXh0KHNlbGVjdGlvbiwgdGFyZ2V0UmFuZ2UsIGRhdGEsIGV2ZW50LnRpbWVTdGFtcCwgZmFsc2UpKSB7XG4gICAgICAvLyBHaXZlbiB3ZSdyZSBvdmVyLXJpZGluZyB0aGUgZGVmYXVsdCBiZWhhdmlvciwgd2Ugd2lsbCBuZWVkXG4gICAgICAvLyB0byBlbnN1cmUgdG8gZGlzYWJsZSBjb21wb3NpdGlvbiBiZWZvcmUgZGlzcGF0Y2hpbmcgdGhlXG4gICAgICAvLyBpbnNlcnRUZXh0IGNvbW1hbmQgZm9yIHdoZW4gY2hhbmdpbmcgdGhlIHNlcXVlbmNlIGZvciBGRi5cbiAgICAgIGlmIChpc0ZpcmVmb3hFbmRpbmdDb21wb3NpdGlvbikge1xuICAgICAgICBvbkNvbXBvc2l0aW9uRW5kSW1wbChlZGl0b3IsIGRhdGEpO1xuICAgICAgICBpc0ZpcmVmb3hFbmRpbmdDb21wb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuXG4gICAgICBpZiAoZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2Zmc2V0ID0gYW5jaG9yLm9mZnNldDsgLy8gSWYgdGhlIGNvbnRlbnQgaXMgdGhlIHNhbWUgYXMgaW5zZXJ0ZWQsIHRoZW4gZG9uJ3QgZGlzcGF0Y2ggYW4gaW5zZXJ0aW9uLlxuICAgICAgLy8gR2l2ZW4gb25JbnB1dCBkb2Vzbid0IHRha2UgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIChpdCB1c2VzIHRoZSBwcmV2aW91cylcbiAgICAgIC8vIHdlIGNhbiBjb21wYXJlIHRoYXQgYWdhaW5zdCB3aGF0IHRoZSBET00gY3VycmVudGx5IHNheXMuXG5cbiAgICAgIGlmICghQ0FOX1VTRV9CRUZPUkVfSU5QVVQgfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgISRpc1RleHROb2RlKGFuY2hvck5vZGUpIHx8IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBudWxsIHx8IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnQoKS5zbGljZSgwLCBvZmZzZXQpICsgZGF0YSArIGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnQoKS5zbGljZShvZmZzZXQgKyBzZWxlY3Rpb24uZm9jdXMub2Zmc2V0KSAhPT0gZ2V0QW5jaG9yVGV4dEZyb21ET00oZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUpKSB7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRleHRMZW5ndGggPSBkYXRhLmxlbmd0aDsgLy8gQW5vdGhlciBoYWNrIGZvciBGRiwgYXMgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBJTUUgaXMgc3RpbGxcbiAgICAgIC8vIG9wZW4sIGV2ZW4gdGhvdWdoIGNvbXBvc2l0aW9uZW5kIGhhcyBhbHJlYWR5IGZpcmVkIChzaWdoKS5cblxuICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgdGV4dExlbmd0aCA+IDEgJiYgZXZlbnQuaW5wdXRUeXBlID09PSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0JyAmJiAhZWRpdG9yLmlzQ29tcG9zaW5nKCkpIHtcbiAgICAgICAgc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgLT0gdGV4dExlbmd0aDtcbiAgICAgIH0gLy8gVGhpcyBlbnN1cmVzIGNvbnNpc3RlbmN5IG9uIEFuZHJvaWQuXG5cblxuICAgICAgaWYgKCFJU19TQUZBUkkgJiYgIUlTX0lPUyAmJiAhSVNfQVBQTEVfV0VCS0lUICYmIGVkaXRvci5pc0NvbXBvc2luZygpKSB7XG4gICAgICAgIGxhc3RLZXlEb3duVGltZVN0YW1wID0gMDtcbiAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGFyYWN0ZXJEYXRhID0gZGF0YSAhPT0gbnVsbCA/IGRhdGEgOiB1bmRlZmluZWQ7XG4gICAgICAkdXBkYXRlU2VsZWN0ZWRUZXh0RnJvbURPTShmYWxzZSwgZWRpdG9yLCBjaGFyYWN0ZXJEYXRhKTsgLy8gb25JbnB1dCBhbHdheXMgZmlyZXMgYWZ0ZXIgb25Db21wb3NpdGlvbkVuZCBmb3IgRkYuXG5cbiAgICAgIGlmIChpc0ZpcmVmb3hFbmRpbmdDb21wb3NpdGlvbikge1xuICAgICAgICBvbkNvbXBvc2l0aW9uRW5kSW1wbChlZGl0b3IsIGRhdGEgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IC8vIEFsc28gZmx1c2ggYW55IG90aGVyIG11dGF0aW9ucyB0aGF0IG1pZ2h0IGhhdmUgb2NjdXJyZWRcbiAgICAvLyBzaW5jZSB0aGUgY2hhbmdlLlxuXG5cbiAgICAkZmx1c2hNdXRhdGlvbnMoKTtcbiAgfSk7XG4gIHVucHJvY2Vzc2VkQmVmb3JlSW5wdXREYXRhID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0KGV2ZW50LCBlZGl0b3IpIHtcbiAgdXBkYXRlRWRpdG9yKGVkaXRvciwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmICFlZGl0b3IuaXNDb21wb3NpbmcoKSkge1xuICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IG5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICRzZXRDb21wb3NpdGlvbktleShhbmNob3Iua2V5KTtcblxuICAgICAgaWYgKCAvLyBJZiBpdCBoYXMgYmVlbiAzMG1zIHNpbmNlIHRoZSBsYXN0IGtleWRvd24sIHRoZW4gd2Ugc2hvdWxkXG4gICAgICAvLyBhcHBseSB0aGUgZW1wdHkgc3BhY2UgaGV1cmlzdGljLiBXZSBjYW4ndCBkbyB0aGlzIGZvciBTYWZhcmksXG4gICAgICAvLyBhcyB0aGUga2V5ZG93biBmaXJlcyBhZnRlciBjb21wb3NpdGlvbiBzdGFydC5cbiAgICAgIGV2ZW50LnRpbWVTdGFtcCA8IGxhc3RLZXlEb3duVGltZVN0YW1wICsgQU5EUk9JRF9DT01QT1NJVElPTl9MQVRFTkNZIHx8IC8vIEZGIGhhcyBpc3N1ZXMgYXJvdW5kIGNvbXBvc2luZyBtdWx0aWJ5dGUgY2hhcmFjdGVycywgc28gd2UgYWxzb1xuICAgICAgLy8gbmVlZCB0byBpbnZva2UgdGhlIGVtcHR5IHNwYWNlIGhldXJpc3RpYyBiZWxvdy5cbiAgICAgIGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgfHwgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8IG5vZGUuZ2V0Rm9ybWF0KCkgIT09IHNlbGVjdGlvbi5mb3JtYXQgfHwgbm9kZS5nZXRTdHlsZSgpICE9PSBzZWxlY3Rpb24uc3R5bGUpIHtcbiAgICAgICAgLy8gV2UgaW5zZXJ0IGEgemVybyB3aWR0aCBjaGFyYWN0ZXIsIHJlYWR5IGZvciB0aGUgY29tcG9zaXRpb25cbiAgICAgICAgLy8gdG8gZ2V0IGluc2VydGVkIGludG8gdGhlIG5ldyBub2RlIHdlIGNyZWF0ZS4gSWZcbiAgICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhpcywgU2FmYXJpIHdpbGwgZmFpbCBvbiB1cyBiZWNhdXNlXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIHRleHQgbm9kZSBtYXRjaGluZyB0aGUgc2VsZWN0aW9uLlxuICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIENPTVBPU0lUSU9OX1NUQVJUX0NIQVIpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmRJbXBsKGVkaXRvciwgZGF0YSkge1xuICBjb25zdCBjb21wb3NpdGlvbktleSA9IGVkaXRvci5fY29tcG9zaXRpb25LZXk7XG4gICRzZXRDb21wb3NpdGlvbktleShudWxsKTsgLy8gSGFuZGxlIHRlcm1pbmF0aW9uIG9mIGNvbXBvc2l0aW9uLlxuXG4gIGlmIChjb21wb3NpdGlvbktleSAhPT0gbnVsbCAmJiBkYXRhICE9IG51bGwpIHtcbiAgICAvLyBDb21wb3NpdGlvbiBjYW4gc29tZXRpbWVzIG1vdmUgdG8gYW4gYWRqYWNlbnQgRE9NIG5vZGUgd2hlbiBiYWNrc3BhY2luZy5cbiAgICAvLyBTbyBjaGVjayBmb3IgdGhlIGVtcHR5IGNhc2UuXG4gICAgaWYgKGRhdGEgPT09ICcnKSB7XG4gICAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShjb21wb3NpdGlvbktleSk7XG4gICAgICBjb25zdCB0ZXh0Tm9kZSA9IGdldERPTVRleHROb2RlKGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY29tcG9zaXRpb25LZXkpKTtcblxuICAgICAgaWYgKHRleHROb2RlICE9PSBudWxsICYmIHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gbnVsbCAmJiAkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgICAkdXBkYXRlVGV4dE5vZGVGcm9tRE9NQ29udGVudChub2RlLCB0ZXh0Tm9kZS5ub2RlVmFsdWUsIG51bGwsIG51bGwsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDb21wb3NpdGlvbiBjYW4gc29tZXRpbWVzIGJlIHRoYXQgb2YgYSBuZXcgbGluZS4gSW4gd2hpY2ggY2FzZSwgd2UgbmVlZCB0b1xuICAgIC8vIGhhbmRsZSB0aGF0IGFjY29yZGluZ2x5LlxuXG5cbiAgICBpZiAoZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSAnXFxuJykge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuXG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaXMgYSBsaW5lIGJyZWFrLCB3ZSBhbHNvIG5lZWQgdG8gaW5zZXJ0XG4gICAgICAgIC8vIGEgbGluZSBicmVhay5cbiAgICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgICAgIHNlbGVjdGlvbi5hbmNob3Iuc2V0KGZvY3VzLmtleSwgZm9jdXMub2Zmc2V0LCBmb2N1cy50eXBlKTtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0VOVEVSX0NPTU1BTkQsIG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgJHVwZGF0ZVNlbGVjdGVkVGV4dEZyb21ET00odHJ1ZSwgZWRpdG9yLCBkYXRhKTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZChldmVudCwgZWRpdG9yKSB7XG4gIC8vIEZpcmVmb3ggZmlyZXMgb25Db21wb3NpdGlvbkVuZCBiZWZvcmUgb25JbnB1dCwgYnV0IENocm9tZS9XZWJraXQsXG4gIC8vIGZpcmUgb25JbnB1dCBiZWZvcmUgb25Db21wb3NpdGlvbkVuZC4gVG8gZW5zdXJlIHRoZSBzZXF1ZW5jZSB3b3Jrc1xuICAvLyBsaWtlIENocm9tZS9XZWJraXQgd2UgdXNlIHRoZSBpc0ZpcmVmb3hFbmRpbmdDb21wb3NpdGlvbiBmbGFnIHRvXG4gIC8vIGRlZmVyIGhhbmRsaW5nIG9mIG9uQ29tcG9zaXRpb25FbmQgaW4gRmlyZWZveCB0aWxsIHdlIGhhdmUgcHJvY2Vzc2VkXG4gIC8vIHRoZSBsb2dpYyBpbiBvbklucHV0LlxuICBpZiAoSVNfRklSRUZPWCkge1xuICAgIGlzRmlyZWZveEVuZGluZ0NvbXBvc2l0aW9uID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVFZGl0b3IoZWRpdG9yLCAoKSA9PiB7XG4gICAgICBvbkNvbXBvc2l0aW9uRW5kSW1wbChlZGl0b3IsIGV2ZW50LmRhdGEpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uS2V5RG93bihldmVudCwgZWRpdG9yKSB7XG4gIGxhc3RLZXlEb3duVGltZVN0YW1wID0gZXZlbnQudGltZVN0YW1wO1xuICBsYXN0S2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG5cbiAgaWYgKGVkaXRvci5pc0NvbXBvc2luZygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGtleUNvZGUsXG4gICAgc2hpZnRLZXksXG4gICAgY3RybEtleSxcbiAgICBtZXRhS2V5LFxuICAgIGFsdEtleVxuICB9ID0gZXZlbnQ7XG5cbiAgaWYgKGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9ET1dOX0NPTU1BTkQsIGV2ZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpc01vdmVGb3J3YXJkKGtleUNvZGUsIGN0cmxLZXksIGFsdEtleSwgbWV0YUtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfQVJST1dfUklHSFRfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzTW92ZVRvRW5kKGtleUNvZGUsIGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgTU9WRV9UT19FTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc01vdmVCYWNrd2FyZChrZXlDb2RlLCBjdHJsS2V5LCBhbHRLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzTW92ZVRvU3RhcnQoa2V5Q29kZSwgY3RybEtleSwgc2hpZnRLZXksIGFsdEtleSwgbWV0YUtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBNT1ZFX1RPX1NUQVJULCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNNb3ZlVXAoa2V5Q29kZSwgY3RybEtleSwgbWV0YUtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfQVJST1dfVVBfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzTW92ZURvd24oa2V5Q29kZSwgY3RybEtleSwgbWV0YUtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNMaW5lQnJlYWsoa2V5Q29kZSwgc2hpZnRLZXkpKSB7XG4gICAgaXNJbnNlcnRMaW5lQnJlYWsgPSB0cnVlO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9FTlRFUl9DT01NQU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNTcGFjZShrZXlDb2RlKSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9TUEFDRV9DT01NQU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNPcGVuTGluZUJyZWFrKGtleUNvZGUsIGN0cmxLZXkpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpc0luc2VydExpbmVCcmVhayA9IHRydWU7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAoaXNQYXJhZ3JhcGgoa2V5Q29kZSwgc2hpZnRLZXkpKSB7XG4gICAgaXNJbnNlcnRMaW5lQnJlYWsgPSBmYWxzZTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfRU5URVJfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzRGVsZXRlQmFja3dhcmQoa2V5Q29kZSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgIGlmIChpc0JhY2tzcGFjZShrZXlDb2RlKSkge1xuICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCBldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIHRydWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VzY2FwZShrZXlDb2RlKSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9FU0NBUEVfQ09NTUFORCwgZXZlbnQpO1xuICB9IGVsc2UgaWYgKGlzRGVsZXRlRm9yd2FyZChrZXlDb2RlLCBjdHJsS2V5LCBzaGlmdEtleSwgYWx0S2V5LCBtZXRhS2V5KSkge1xuICAgIGlmIChpc0RlbGV0ZShrZXlDb2RlKSkge1xuICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0RFTEVURV9DT01NQU5ELCBldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIGZhbHNlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNEZWxldGVXb3JkQmFja3dhcmQoa2V5Q29kZSwgYWx0S2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX1dPUkRfQ09NTUFORCwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAoaXNEZWxldGVXb3JkRm9yd2FyZChrZXlDb2RlLCBhbHRLZXksIGN0cmxLZXkpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfV09SRF9DT01NQU5ELCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAoaXNEZWxldGVMaW5lQmFja3dhcmQoa2V5Q29kZSwgbWV0YUtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9MSU5FX0NPTU1BTkQsIHRydWUpO1xuICB9IGVsc2UgaWYgKGlzRGVsZXRlTGluZUZvcndhcmQoa2V5Q29kZSwgbWV0YUtleSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9MSU5FX0NPTU1BTkQsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChpc0JvbGQoa2V5Q29kZSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9STUFUX1RFWFRfQ09NTUFORCwgJ2JvbGQnKTtcbiAgfSBlbHNlIGlmIChpc1VuZGVybGluZShrZXlDb2RlLCBhbHRLZXksIG1ldGFLZXksIGN0cmxLZXkpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBGT1JNQVRfVEVYVF9DT01NQU5ELCAndW5kZXJsaW5lJyk7XG4gIH0gZWxzZSBpZiAoaXNJdGFsaWMoa2V5Q29kZSwgYWx0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9STUFUX1RFWFRfQ09NTUFORCwgJ2l0YWxpYycpO1xuICB9IGVsc2UgaWYgKGlzVGFiKGtleUNvZGUsIGFsdEtleSwgY3RybEtleSwgbWV0YUtleSkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfVEFCX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc1VuZG8oa2V5Q29kZSwgc2hpZnRLZXksIG1ldGFLZXksIGN0cmxLZXkpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBVTkRPX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH0gZWxzZSBpZiAoaXNSZWRvKGtleUNvZGUsIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUkVET19DT01NQU5ELCB1bmRlZmluZWQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBlZGl0b3IuX2VkaXRvclN0YXRlLl9zZWxlY3Rpb247XG5cbiAgICBpZiAoJGlzTm9kZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSkge1xuICAgICAgaWYgKGlzQ29weShrZXlDb2RlLCBzaGlmdEtleSwgbWV0YUtleSwgY3RybEtleSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ09QWV9DT01NQU5ELCBldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzQ3V0KGtleUNvZGUsIHNoaWZ0S2V5LCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDVVRfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChpc1NlbGVjdEFsbChrZXlDb2RlLCBtZXRhS2V5LCBjdHJsS2V5KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAkc2VsZWN0QWxsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBGRiBkb2VzIGl0IHdlbGwgKG5vIG5lZWQgdG8gb3ZlcnJpZGUgYmVoYXZpb3IpXG5cbiAgICB9IGVsc2UgaWYgKCFJU19GSVJFRk9YICYmIGlzU2VsZWN0QWxsKGtleUNvZGUsIG1ldGFLZXksIGN0cmxLZXkpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICRzZWxlY3RBbGwoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc01vZGlmaWVyKGN0cmxLZXksIHNoaWZ0S2V5LCBhbHRLZXksIG1ldGFLZXkpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX01PRElGSUVSX0NPTU1BTkQsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSb290RWxlbWVudFJlbW92ZUhhbmRsZXMocm9vdEVsZW1lbnQpIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgbGV0IGV2ZW50SGFuZGxlcyA9IHJvb3RFbGVtZW50Ll9fbGV4aWNhbEV2ZW50SGFuZGxlcztcblxuICBpZiAoZXZlbnRIYW5kbGVzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudEhhbmRsZXMgPSBbXTsgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcblxuICAgIHJvb3RFbGVtZW50Ll9fbGV4aWNhbEV2ZW50SGFuZGxlcyA9IGV2ZW50SGFuZGxlcztcbiAgfVxuXG4gIHJldHVybiBldmVudEhhbmRsZXM7XG59IC8vIE1hcHBpbmcgcm9vdCBlZGl0b3JzIHRvIHRoZWlyIGFjdGl2ZSBuZXN0ZWQgZWRpdG9ycywgY29udGFpbnMgbmVzdGVkIGVkaXRvcnNcbi8vIG1hcHBpbmcgb25seSwgc28gaWYgcm9vdCBlZGl0b3IgaXMgc2VsZWN0ZWQgbWFwIHdpbGwgaGF2ZSBubyByZWZlcmVuY2UgdG8gZnJlZSB1cCBtZW1vcnlcblxuXG5jb25zdCBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwID0gbmV3IE1hcCgpO1xuXG5mdW5jdGlvbiBvbkRvY3VtZW50U2VsZWN0aW9uQ2hhbmdlKGV2ZW50KSB7XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgY29uc3QgdGFyZ2V0V2luZG93ID0gdGFyZ2V0ID09IG51bGwgPyBudWxsIDogdGFyZ2V0Lm5vZGVUeXBlID09PSA5ID8gdGFyZ2V0LmRlZmF1bHRWaWV3IDogdGFyZ2V0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbih0YXJnZXRXaW5kb3cpO1xuXG4gIGlmIChkb21TZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBuZXh0QWN0aXZlRWRpdG9yID0gZ2V0TmVhcmVzdEVkaXRvckZyb21ET01Ob2RlKGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlKTtcblxuICBpZiAobmV4dEFjdGl2ZUVkaXRvciA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpc1NlbGVjdGlvbkNoYW5nZUZyb21Nb3VzZURvd24pIHtcbiAgICBpc1NlbGVjdGlvbkNoYW5nZUZyb21Nb3VzZURvd24gPSBmYWxzZTtcbiAgICB1cGRhdGVFZGl0b3IobmV4dEFjdGl2ZUVkaXRvciwgKCkgPT4ge1xuICAgICAgY29uc3QgbGFzdFNlbGVjdGlvbiA9ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICAgICAgY29uc3QgZG9tQW5jaG9yTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuXG4gICAgICBpZiAoZG9tQW5jaG9yTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGVUeXBlID0gZG9tQW5jaG9yTm9kZS5ub2RlVHlwZTsgLy8gSWYgdGhlIHVzZXIgaXMgYXR0ZW1wdGluZyB0byBjbGljayBzZWxlY3Rpb24gYmFjayBvbnRvIHRleHQsIHRoZW5cbiAgICAgIC8vIHdlIHNob3VsZCBhdHRlbXB0IGNyZWF0ZSBhIHJhbmdlIHNlbGVjdGlvbi5cbiAgICAgIC8vIFdoZW4gd2UgY2xpY2sgb24gYW4gZW1wdHkgcGFyYWdyYXBoIG5vZGUgb3IgdGhlIGVuZCBvZiBhIHBhcmFncmFwaCB0aGF0IGVuZHNcbiAgICAgIC8vIHdpdGggYW4gaW1hZ2UvcG9sbCwgdGhlIG5vZGVUeXBlIHdpbGwgYmUgRUxFTUVOVF9OT0RFXG5cbiAgICAgIGlmIChub2RlVHlwZSAhPT0gRE9NX0VMRU1FTlRfVFlQRSAmJiBub2RlVHlwZSAhPT0gRE9NX1RFWFRfVFlQRSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IGludGVybmFsQ3JlYXRlUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbiwgZG9tU2VsZWN0aW9uLCBuZXh0QWN0aXZlRWRpdG9yKTtcbiAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICB9KTtcbiAgfSAvLyBXaGVuIGVkaXRvciByZWNlaXZlcyBzZWxlY3Rpb24gY2hhbmdlIGV2ZW50LCB3ZSdyZSBjaGVja2luZyBpZlxuICAvLyBpdCBoYXMgYW55IHNpYmxpbmcgZWRpdG9ycyAod2l0aGluIHNhbWUgcGFyZW50IGVkaXRvcikgdGhhdCB3ZXJlIGFjdGl2ZVxuICAvLyBiZWZvcmUsIGFuZCB0cmlnZ2VyIHNlbGVjdGlvbiBjaGFuZ2Ugb24gaXQgdG8gbnVsbGlmeSBzZWxlY3Rpb24uXG5cblxuICBjb25zdCBlZGl0b3JzID0gZ2V0RWRpdG9yc1RvUHJvcGFnYXRlKG5leHRBY3RpdmVFZGl0b3IpO1xuICBjb25zdCByb290RWRpdG9yID0gZWRpdG9yc1tlZGl0b3JzLmxlbmd0aCAtIDFdO1xuICBjb25zdCByb290RWRpdG9yS2V5ID0gcm9vdEVkaXRvci5fa2V5O1xuICBjb25zdCBhY3RpdmVOZXN0ZWRFZGl0b3IgPSBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmdldChyb290RWRpdG9yS2V5KTtcbiAgY29uc3QgcHJldkFjdGl2ZUVkaXRvciA9IGFjdGl2ZU5lc3RlZEVkaXRvciB8fCByb290RWRpdG9yO1xuXG4gIGlmIChwcmV2QWN0aXZlRWRpdG9yICE9PSBuZXh0QWN0aXZlRWRpdG9yKSB7XG4gICAgb25TZWxlY3Rpb25DaGFuZ2UoZG9tU2VsZWN0aW9uLCBwcmV2QWN0aXZlRWRpdG9yLCBmYWxzZSk7XG4gIH1cblxuICBvblNlbGVjdGlvbkNoYW5nZShkb21TZWxlY3Rpb24sIG5leHRBY3RpdmVFZGl0b3IsIHRydWUpOyAvLyBJZiBuZXdseSBzZWxlY3RlZCBlZGl0b3IgaXMgbmVzdGVkLCB0aGVuIGFkZCBpdCB0byB0aGUgbWFwLCBjbGVhbiBtYXAgb3RoZXJ3aXNlXG5cbiAgaWYgKG5leHRBY3RpdmVFZGl0b3IgIT09IHJvb3RFZGl0b3IpIHtcbiAgICBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLnNldChyb290RWRpdG9yS2V5LCBuZXh0QWN0aXZlRWRpdG9yKTtcbiAgfSBlbHNlIGlmIChhY3RpdmVOZXN0ZWRFZGl0b3IpIHtcbiAgICBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmRlbGV0ZShyb290RWRpdG9yS2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIC8vIFdlIGF0dGFjaCBhIHNwZWNpYWwgcHJvcGVydHkgdG8gZW5zdXJlIHRoZSBzYW1lIGV2ZW50IGRvZXNuJ3QgcmUtZmlyZVxuICAvLyBmb3IgcGFyZW50IGVkaXRvcnMuXG4gIC8vIEB0cy1pZ25vcmVcbiAgZXZlbnQuX2xleGljYWxIYW5kbGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaGFzU3RvcHBlZExleGljYWxQcm9wYWdhdGlvbihldmVudCkge1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IHN0b3BwZWQgPSBldmVudC5fbGV4aWNhbEhhbmRsZWQgPT09IHRydWU7XG4gIHJldHVybiBzdG9wcGVkO1xufVxuXG5mdW5jdGlvbiBhZGRSb290RWxlbWVudEV2ZW50cyhyb290RWxlbWVudCwgZWRpdG9yKSB7XG4gIC8vIFdlIG9ubHkgd2FudCB0byBoYXZlIGEgc2luZ2xlIGdsb2JhbCBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQgaGFuZGxlciwgc2hhcmVkXG4gIC8vIGJldHdlZW4gYWxsIGVkaXRvciBpbnN0YW5jZXMuXG4gIGlmIChyb290RWxlbWVudHNSZWdpc3RlcmVkID09PSAwKSB7XG4gICAgY29uc3QgZG9jID0gcm9vdEVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgb25Eb2N1bWVudFNlbGVjdGlvbkNoYW5nZSk7XG4gIH1cblxuICByb290RWxlbWVudHNSZWdpc3RlcmVkKys7IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG5cbiAgcm9vdEVsZW1lbnQuX19sZXhpY2FsRWRpdG9yID0gZWRpdG9yO1xuICBjb25zdCByZW1vdmVIYW5kbGVzID0gZ2V0Um9vdEVsZW1lbnRSZW1vdmVIYW5kbGVzKHJvb3RFbGVtZW50KTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvb3RFbGVtZW50RXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgW2V2ZW50TmFtZSwgb25FdmVudF0gPSByb290RWxlbWVudEV2ZW50c1tpXTtcbiAgICBjb25zdCBldmVudEhhbmRsZXIgPSB0eXBlb2Ygb25FdmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50ID0+IHtcbiAgICAgIGlmIChoYXNTdG9wcGVkTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN0b3BMZXhpY2FsUHJvcGFnYXRpb24oZXZlbnQpO1xuXG4gICAgICBpZiAoZWRpdG9yLmlzRWRpdGFibGUoKSkge1xuICAgICAgICBvbkV2ZW50KGV2ZW50LCBlZGl0b3IpO1xuICAgICAgfVxuICAgIH0gOiBldmVudCA9PiB7XG4gICAgICBpZiAoaGFzU3RvcHBlZExleGljYWxQcm9wYWdhdGlvbihldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzdG9wTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KTtcblxuICAgICAgaWYgKGVkaXRvci5pc0VkaXRhYmxlKCkpIHtcbiAgICAgICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgICAgICBjYXNlICdjdXQnOlxuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENVVF9DT01NQU5ELCBldmVudCk7XG5cbiAgICAgICAgICBjYXNlICdjb3B5JzpcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDT1BZX0NPTU1BTkQsIGV2ZW50KTtcblxuICAgICAgICAgIGNhc2UgJ3Bhc3RlJzpcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBQQVNURV9DT01NQU5ELCBldmVudCk7XG5cbiAgICAgICAgICBjYXNlICdkcmFnc3RhcnQnOlxuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERSQUdTVEFSVF9DT01NQU5ELCBldmVudCk7XG5cbiAgICAgICAgICBjYXNlICdkcmFnb3Zlcic6XG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRFJBR09WRVJfQ09NTUFORCwgZXZlbnQpO1xuXG4gICAgICAgICAgY2FzZSAnZHJhZ2VuZCc6XG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRFJBR0VORF9DT01NQU5ELCBldmVudCk7XG5cbiAgICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9DVVNfQ09NTUFORCwgZXZlbnQpO1xuXG4gICAgICAgICAgY2FzZSAnYmx1cic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBCTFVSX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERST1BfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgICByZW1vdmVIYW5kbGVzLnB1c2goKCkgPT4ge1xuICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbW92ZVJvb3RFbGVtZW50RXZlbnRzKHJvb3RFbGVtZW50KSB7XG4gIGlmIChyb290RWxlbWVudHNSZWdpc3RlcmVkICE9PSAwKSB7XG4gICAgcm9vdEVsZW1lbnRzUmVnaXN0ZXJlZC0tOyAvLyBXZSBvbmx5IHdhbnQgdG8gaGF2ZSBhIHNpbmdsZSBnbG9iYWwgc2VsZWN0aW9uY2hhbmdlIGV2ZW50IGhhbmRsZXIsIHNoYXJlZFxuICAgIC8vIGJldHdlZW4gYWxsIGVkaXRvciBpbnN0YW5jZXMuXG5cbiAgICBpZiAocm9vdEVsZW1lbnRzUmVnaXN0ZXJlZCA9PT0gMCkge1xuICAgICAgY29uc3QgZG9jID0gcm9vdEVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBvbkRvY3VtZW50U2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gIH0gLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcblxuXG4gIGNvbnN0IGVkaXRvciA9IHJvb3RFbGVtZW50Ll9fbGV4aWNhbEVkaXRvcjtcblxuICBpZiAoZWRpdG9yICE9PSBudWxsICYmIGVkaXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2xlYW5BY3RpdmVOZXN0ZWRFZGl0b3JzTWFwKGVkaXRvcik7IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG5cbiAgICByb290RWxlbWVudC5fX2xleGljYWxFZGl0b3IgPSBudWxsO1xuICB9XG5cbiAgY29uc3QgcmVtb3ZlSGFuZGxlcyA9IGdldFJvb3RFbGVtZW50UmVtb3ZlSGFuZGxlcyhyb290RWxlbWVudCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVIYW5kbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVtb3ZlSGFuZGxlc1tpXSgpO1xuICB9IC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG5cblxuICByb290RWxlbWVudC5fX2xleGljYWxFdmVudEhhbmRsZXMgPSBbXTtcbn1cblxuZnVuY3Rpb24gY2xlYW5BY3RpdmVOZXN0ZWRFZGl0b3JzTWFwKGVkaXRvcikge1xuICBpZiAoZWRpdG9yLl9wYXJlbnRFZGl0b3IgIT09IG51bGwpIHtcbiAgICAvLyBGb3IgbmVzdGVkIGVkaXRvciBjbGVhbnVwIG1hcCBpZiB0aGlzIGVkaXRvciB3YXMgbWFya2VkIGFzIGFjdGl2ZVxuICAgIGNvbnN0IGVkaXRvcnMgPSBnZXRFZGl0b3JzVG9Qcm9wYWdhdGUoZWRpdG9yKTtcbiAgICBjb25zdCByb290RWRpdG9yID0gZWRpdG9yc1tlZGl0b3JzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHJvb3RFZGl0b3JLZXkgPSByb290RWRpdG9yLl9rZXk7XG5cbiAgICBpZiAoYWN0aXZlTmVzdGVkRWRpdG9yc01hcC5nZXQocm9vdEVkaXRvcktleSkgPT09IGVkaXRvcikge1xuICAgICAgYWN0aXZlTmVzdGVkRWRpdG9yc01hcC5kZWxldGUocm9vdEVkaXRvcktleSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEZvciB0b3AtbGV2ZWwgZWRpdG9ycyBjbGVhbnVwIG1hcFxuICAgIGFjdGl2ZU5lc3RlZEVkaXRvcnNNYXAuZGVsZXRlKGVkaXRvci5fa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSgpIHtcbiAgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hcmtDb2xsYXBzZWRTZWxlY3Rpb25Gb3JtYXQoZm9ybWF0LCBzdHlsZSwgb2Zmc2V0LCBrZXksIHRpbWVTdGFtcCkge1xuICBjb2xsYXBzZWRTZWxlY3Rpb25Gb3JtYXQgPSBbZm9ybWF0LCBzdHlsZSwgb2Zmc2V0LCBrZXksIHRpbWVTdGFtcF07XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZVRvUmVtb3ZlLCByZXN0b3JlU2VsZWN0aW9uLCBwcmVzZXJ2ZUVtcHR5UGFyZW50KSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCBrZXkgPSBub2RlVG9SZW1vdmUuX19rZXk7XG4gIGNvbnN0IHBhcmVudCA9IG5vZGVUb1JlbW92ZS5nZXRQYXJlbnQoKTtcblxuICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc2VsZWN0aW9uID0gJG1heWJlTW92ZUNoaWxkcmVuU2VsZWN0aW9uVG9QYXJlbnQobm9kZVRvUmVtb3ZlKTtcbiAgbGV0IHNlbGVjdGlvbk1vdmVkID0gZmFsc2U7XG5cbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgcmVzdG9yZVNlbGVjdGlvbikge1xuICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG5cbiAgICBpZiAoYW5jaG9yLmtleSA9PT0ga2V5KSB7XG4gICAgICBtb3ZlU2VsZWN0aW9uUG9pbnRUb1NpYmxpbmcoYW5jaG9yLCBub2RlVG9SZW1vdmUsIHBhcmVudCwgbm9kZVRvUmVtb3ZlLmdldFByZXZpb3VzU2libGluZygpLCBub2RlVG9SZW1vdmUuZ2V0TmV4dFNpYmxpbmcoKSk7XG4gICAgICBzZWxlY3Rpb25Nb3ZlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGZvY3VzLmtleSA9PT0ga2V5KSB7XG4gICAgICBtb3ZlU2VsZWN0aW9uUG9pbnRUb1NpYmxpbmcoZm9jdXMsIG5vZGVUb1JlbW92ZSwgcGFyZW50LCBub2RlVG9SZW1vdmUuZ2V0UHJldmlvdXNTaWJsaW5nKCksIG5vZGVUb1JlbW92ZS5nZXROZXh0U2libGluZygpKTtcbiAgICAgIHNlbGVjdGlvbk1vdmVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHJlc3RvcmVTZWxlY3Rpb24gJiYgbm9kZVRvUmVtb3ZlLmlzU2VsZWN0ZWQoKSkge1xuICAgIG5vZGVUb1JlbW92ZS5zZWxlY3RQcmV2aW91cygpO1xuICB9XG5cbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgcmVzdG9yZVNlbGVjdGlvbiAmJiAhc2VsZWN0aW9uTW92ZWQpIHtcbiAgICAvLyBEb2luZyB0aGlzIGlzIE8obikgc28gbGV0cyBhdm9pZCBpdCB1bmxlc3Mgd2UgbmVlZCB0byBkbyBpdFxuICAgIGNvbnN0IGluZGV4ID0gbm9kZVRvUmVtb3ZlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgcmVtb3ZlRnJvbVBhcmVudChub2RlVG9SZW1vdmUpO1xuICAgICR1cGRhdGVFbGVtZW50U2VsZWN0aW9uT25DcmVhdGVEZWxldGVOb2RlKHNlbGVjdGlvbiwgcGFyZW50LCBpbmRleCwgLTEpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUZyb21QYXJlbnQobm9kZVRvUmVtb3ZlKTtcbiAgfVxuXG4gIGlmICghcHJlc2VydmVFbXB0eVBhcmVudCAmJiAhJGlzUm9vdE9yU2hhZG93Um9vdChwYXJlbnQpICYmICFwYXJlbnQuY2FuQmVFbXB0eSgpICYmIHBhcmVudC5pc0VtcHR5KCkpIHtcbiAgICByZW1vdmVOb2RlKHBhcmVudCwgcmVzdG9yZVNlbGVjdGlvbik7XG4gIH1cblxuICBpZiAocmVzdG9yZVNlbGVjdGlvbiAmJiAkaXNSb290Tm9kZShwYXJlbnQpICYmIHBhcmVudC5pc0VtcHR5KCkpIHtcbiAgICBwYXJlbnQuc2VsZWN0RW5kKCk7XG4gIH1cbn1cbmNsYXNzIExleGljYWxOb2RlIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgYWJzdHJhY3QgY2xhc3NlcyB1bmZvcnR1bmF0ZWx5LCBzbyB3ZSBjYW4ndCBfZm9yY2VfXG4gIC8vIHN1YmNsYXNzZXMgb2YgTm9kZSB0byBpbXBsZW1lbnQgc3RhdGljcy4gQWxsIHN1YmNsYXNzZXMgb2YgTm9kZSBzaG91bGQgaGF2ZVxuICAvLyBhIHN0YXRpYyBnZXRUeXBlIGFuZCBjbG9uZSBtZXRob2QgdGhvdWdoLiBXZSBkZWZpbmUgZ2V0VHlwZSBhbmQgY2xvbmUgaGVyZSBzbyB3ZSBjYW4gY2FsbCBpdFxuICAvLyBvbiBhbnkgIE5vZGUsIGFuZCB3ZSB0aHJvdyB0aGlzIGVycm9yIGJ5IGRlZmF1bHQgc2luY2UgdGhlIHN1YmNsYXNzIHNob3VsZCBwcm92aWRlXG4gIC8vIHRoZWlyIG93biBpbXBsZW1lbnRhdGlvbi5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIHR5cGUgb2YgdGhpcyBub2RlLiBFdmVyeSBub2RlIG11c3RcbiAgICogaW1wbGVtZW50IHRoaXMgYW5kIGl0IE1VU1QgQkUgVU5JUVVFIGFtb25nc3Qgbm9kZXMgcmVnaXN0ZXJlZFxuICAgKiBvbiB0aGUgZWRpdG9yLlxuICAgKlxuICAgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7dGhpcy5uYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgLmdldFR5cGUoKS5gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENsb25lcyB0aGlzIG5vZGUsIGNyZWF0aW5nIGEgbmV3IG5vZGUgd2l0aCBhIGRpZmZlcmVudCBrZXlcbiAgICogYW5kIGFkZGluZyBpdCB0byB0aGUgRWRpdG9yU3RhdGUgKGJ1dCBub3QgYXR0YWNoaW5nIGl0IGFueXdoZXJlISkuIEFsbCBub2RlcyBtdXN0XG4gICAqIGltcGxlbWVudCB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICovXG5cblxuICBzdGF0aWMgY2xvbmUoX2RhdGEpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHt0aGlzLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuY2xvbmUoKS5gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgdGhpcy5fX3R5cGUgPSB0aGlzLmNvbnN0cnVjdG9yLmdldFR5cGUoKTtcbiAgICB0aGlzLl9fcGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLl9fcHJldiA9IG51bGw7XG4gICAgdGhpcy5fX25leHQgPSBudWxsO1xuICAgICRzZXROb2RlS2V5KHRoaXMsIGtleSk7XG5cbiAgICB7XG4gICAgICBpZiAodGhpcy5fX3R5cGUgIT09ICdyb290Jykge1xuICAgICAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICAgICAgZXJyb3JPblR5cGVLbGFzc01pc21hdGNoKHRoaXMuX190eXBlLCAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBHZXR0ZXJzIGFuZCBUcmF2ZXJzZXJzXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmluZyB0eXBlIG9mIHRoaXMgbm9kZS5cbiAgICovXG5cblxuICBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9fdHlwZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGEgcGF0aCBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgdGhlIFJvb3ROb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIFRoaXMgaXMgYSB3YXkgb2YgZGV0ZXJtaW5pbmcgaWYgdGhlIG5vZGUgaXMgXCJhdHRhY2hlZFwiIEVkaXRvclN0YXRlLiBVbmF0dGFjaGVkIG5vZGVzXG4gICAqIHdvbid0IGJlIHJlY29uY2lsZWQgYW5kIHdpbGwgdWx0aW1hdGVsdCBiZSBjbGVhbmVkIHVwIGJ5IHRoZSBMZXhpY2FsIEdDLlxuICAgKi9cblxuXG4gIGlzQXR0YWNoZWQoKSB7XG4gICAgbGV0IG5vZGVLZXkgPSB0aGlzLl9fa2V5O1xuXG4gICAgd2hpbGUgKG5vZGVLZXkgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlS2V5ID09PSAncm9vdCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KG5vZGVLZXkpO1xuXG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbm9kZUtleSA9IG5vZGUuX19wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHByb3ZpZGVkIFNlbGVjdGlvbi4sIGZhbHNlIG90aGVyd2lzZS5cbiAgICogUmVsaWVzIG9uIHRoZSBhbGdvcml0aG1zIGltcGxlbWVudGVkIGluIHtAbGluayBCYXNlU2VsZWN0aW9uLmdldE5vZGVzfSB0byBkZXRlcm1pbmVcbiAgICogd2hhdCdzIGluY2x1ZGVkLlxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB0aGF0IHdlIHdhbnQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBub2RlIGlzIGluLlxuICAgKi9cblxuXG4gIGlzU2VsZWN0ZWQoc2VsZWN0aW9uKSB7XG4gICAgY29uc3QgdGFyZ2V0U2VsZWN0aW9uID0gc2VsZWN0aW9uIHx8ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmICh0YXJnZXRTZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSB0YXJnZXRTZWxlY3Rpb24uZ2V0Tm9kZXMoKS5zb21lKG4gPT4gbi5fX2tleSA9PT0gdGhpcy5fX2tleSk7XG5cbiAgICBpZiAoJGlzVGV4dE5vZGUodGhpcykpIHtcbiAgICAgIHJldHVybiBpc1NlbGVjdGVkO1xuICAgIH0gLy8gRm9yIGlubGluZSBpbWFnZXMgaW5zaWRlIG9mIGVsZW1lbnQgbm9kZXMuXG4gICAgLy8gV2l0aG91dCB0aGlzIGNoYW5nZSB0aGUgaW1hZ2Ugd2lsbCBiZSBzZWxlY3RlZCBpZiB0aGUgY3Vyc29yIGlzIGJlZm9yZSBvciBhZnRlciBpdC5cblxuXG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHRhcmdldFNlbGVjdGlvbikgJiYgdGFyZ2V0U2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgdGFyZ2V0U2VsZWN0aW9uLmZvY3VzLnR5cGUgPT09ICdlbGVtZW50JyAmJiB0YXJnZXRTZWxlY3Rpb24uYW5jaG9yLmtleSA9PT0gdGFyZ2V0U2VsZWN0aW9uLmZvY3VzLmtleSAmJiB0YXJnZXRTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gdGFyZ2V0U2VsZWN0aW9uLmZvY3VzLm9mZnNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBpc1NlbGVjdGVkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgbm9kZXMga2V5LlxuICAgKi9cblxuXG4gIGdldEtleSgpIHtcbiAgICAvLyBLZXkgaXMgc3RhYmxlIGJldHdlZW4gY29waWVzXG4gICAgcmV0dXJuIHRoaXMuX19rZXk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHplcm8tYmFzZWQgaW5kZXggb2YgdGhpcyBub2RlIHdpdGhpbiB0aGUgcGFyZW50LlxuICAgKi9cblxuXG4gIGdldEluZGV4V2l0aGluUGFyZW50KCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgbGV0IG5vZGUgPSBwYXJlbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGxldCBpbmRleCA9IDA7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuaXMobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuXG4gICAgICBpbmRleCsrO1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCBvZiB0aGlzIG5vZGUsIG9yIG51bGwgaWYgbm9uZSBpcyBmb3VuZC5cbiAgICovXG5cblxuICBnZXRQYXJlbnQoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRMYXRlc3QoKS5fX3BhcmVudDtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiAkZ2V0Tm9kZUJ5S2V5KHBhcmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCBvZiB0aGlzIG5vZGUsIG9yIHRocm93cyBpZiBub25lIGlzIGZvdW5kLlxuICAgKi9cblxuXG4gIGdldFBhcmVudE9yVGhyb3coKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIG5vZGUgJHt0aGlzLl9fa2V5fSB0byBoYXZlIGEgcGFyZW50LmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhpZ2hlc3QgKGluIHRoZSBFZGl0b3JTdGF0ZSB0cmVlKVxuICAgKiBub24tcm9vdCBhbmNlc3RvciBvZiB0aGlzIG5vZGUsIG9yIG51bGwgaWYgbm9uZSBpcyBmb3VuZC4gU2VlIHtAbGluayBsZXhpY2FsISRpc1Jvb3RPclNoYWRvd1Jvb3R9XG4gICAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHdoaWNoIEVsZW1lbnRzIGNvbXByaXNlIFwicm9vdHNcIi5cbiAgICovXG5cblxuICBnZXRUb3BMZXZlbEVsZW1lbnQoKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhpZ2hlc3QgKGluIHRoZSBFZGl0b3JTdGF0ZSB0cmVlKVxuICAgKiBub24tcm9vdCBhbmNlc3RvciBvZiB0aGlzIG5vZGUsIG9yIHRocm93cyBpZiBub25lIGlzIGZvdW5kLiBTZWUge0BsaW5rIGxleGljYWwhJGlzUm9vdE9yU2hhZG93Um9vdH1cbiAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gd2hpY2ggRWxlbWVudHMgY29tcHJpc2UgXCJyb290c1wiLlxuICAgKi9cblxuXG4gIGdldFRvcExldmVsRWxlbWVudE9yVGhyb3coKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRUb3BMZXZlbEVsZW1lbnQoKTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIG5vZGUgJHt0aGlzLl9fa2V5fSB0byBoYXZlIGEgdG9wIHBhcmVudCBlbGVtZW50LmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBldmVyeSBhbmNlc3RvciBvZiB0aGlzIG5vZGUsXG4gICAqIGFsbCB0aGUgd2F5IHVwIHRvIHRoZSBSb290Tm9kZS5cbiAgICpcbiAgICovXG5cblxuICBnZXRQYXJlbnRzKCkge1xuICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICBsZXQgbm9kZSA9IHRoaXMuZ2V0UGFyZW50KCk7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudHM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBrZXlzIG9mIGV2ZXJ5IGFuY2VzdG9yIG9mIHRoaXMgbm9kZSxcbiAgICogYWxsIHRoZSB3YXkgdXAgdG8gdGhlIFJvb3ROb2RlLlxuICAgKlxuICAgKi9cblxuXG4gIGdldFBhcmVudEtleXMoKSB7XG4gICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgIGxldCBub2RlID0gdGhpcy5nZXRQYXJlbnQoKTtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBwYXJlbnRzLnB1c2gobm9kZS5fX2tleSk7XG4gICAgICBub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50cztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgXCJwcmV2aW91c1wiIHNpYmxpbmdzIC0gdGhhdCBpcywgdGhlIG5vZGUgdGhhdCBjb21lc1xuICAgKiBiZWZvcmUgdGhpcyBvbmUgaW4gdGhlIHNhbWUgcGFyZW50LlxuICAgKlxuICAgKi9cblxuXG4gIGdldFByZXZpb3VzU2libGluZygpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwcmV2S2V5ID0gc2VsZi5fX3ByZXY7XG4gICAgcmV0dXJuIHByZXZLZXkgPT09IG51bGwgPyBudWxsIDogJGdldE5vZGVCeUtleShwcmV2S2V5KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgXCJwcmV2aW91c1wiIHNpYmxpbmdzIC0gdGhhdCBpcywgdGhlIG5vZGVzIHRoYXQgY29tZSBiZXR3ZWVuXG4gICAqIHRoaXMgb25lIGFuZCB0aGUgZmlyc3QgY2hpbGQgb2YgaXQncyBwYXJlbnQsIGluY2x1c2l2ZS5cbiAgICpcbiAgICovXG5cblxuICBnZXRQcmV2aW91c1NpYmxpbmdzKCkge1xuICAgIGNvbnN0IHNpYmxpbmdzID0gW107XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzaWJsaW5ncztcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IHBhcmVudC5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUuaXModGhpcykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHNpYmxpbmdzLnB1c2gobm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIH1cblxuICAgIHJldHVybiBzaWJsaW5ncztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgXCJuZXh0XCIgc2libGluZ3MgLSB0aGF0IGlzLCB0aGUgbm9kZSB0aGF0IGNvbWVzXG4gICAqIGFmdGVyIHRoaXMgb25lIGluIHRoZSBzYW1lIHBhcmVudFxuICAgKlxuICAgKi9cblxuXG4gIGdldE5leHRTaWJsaW5nKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IG5leHRLZXkgPSBzZWxmLl9fbmV4dDtcbiAgICByZXR1cm4gbmV4dEtleSA9PT0gbnVsbCA/IG51bGwgOiAkZ2V0Tm9kZUJ5S2V5KG5leHRLZXkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBcIm5leHRcIiBzaWJsaW5ncyAtIHRoYXQgaXMsIHRoZSBub2RlcyB0aGF0IGNvbWUgYmV0d2VlbiB0aGlzXG4gICAqIG9uZSBhbmQgdGhlIGxhc3QgY2hpbGQgb2YgaXQncyBwYXJlbnQsIGluY2x1c2l2ZS5cbiAgICpcbiAgICovXG5cblxuICBnZXROZXh0U2libGluZ3MoKSB7XG4gICAgY29uc3Qgc2libGluZ3MgPSBbXTtcbiAgICBsZXQgbm9kZSA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5ncy5wdXNoKG5vZGUpO1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2libGluZ3M7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsb3Nlc3QgY29tbW9uIGFuY2VzdG9yIG9mIHRoaXMgbm9kZSBhbmQgdGhlIHByb3ZpZGVkIG9uZSBvciBudWxsXG4gICAqIGlmIG9uZSBjYW5ub3QgYmUgZm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlIC0gdGhlIG90aGVyIG5vZGUgdG8gZmluZCB0aGUgY29tbW9uIGFuY2VzdG9yIG9mLlxuICAgKi9cblxuXG4gIGdldENvbW1vbkFuY2VzdG9yKG5vZGUpIHtcbiAgICBjb25zdCBhID0gdGhpcy5nZXRQYXJlbnRzKCk7XG4gICAgY29uc3QgYiA9IG5vZGUuZ2V0UGFyZW50cygpO1xuXG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKHRoaXMpKSB7XG4gICAgICBhLnVuc2hpZnQodGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICBiLnVuc2hpZnQobm9kZSk7XG4gICAgfVxuXG4gICAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGNvbnN0IGJMZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIGlmIChhTGVuZ3RoID09PSAwIHx8IGJMZW5ndGggPT09IDAgfHwgYVthTGVuZ3RoIC0gMV0gIT09IGJbYkxlbmd0aCAtIDFdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBiU2V0ID0gbmV3IFNldChiKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYUxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhbmNlc3RvciA9IGFbaV07XG5cbiAgICAgIGlmIChiU2V0LmhhcyhhbmNlc3RvcikpIHtcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIG5vZGUgaXMgdGhlIGV4YWN0IHNhbWUgb25lIGFzIHRoaXMgbm9kZSwgZnJvbSBMZXhpY2FsJ3MgcGVyc3BlY3RpdmUuXG4gICAqIEFsd2F5cyB1c2UgdGhpcyBpbnN0ZWFkIG9mIHJlZmVyZW50aWFsIGVxdWFsaXR5LlxuICAgKlxuICAgKiBAcGFyYW0gb2JqZWN0IC0gdGhlIG5vZGUgdG8gcGVyZm9ybSB0aGUgZXF1YWxpdHkgY29tcGFyaXNvbiBvbi5cbiAgICovXG5cblxuICBpcyhvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX2tleSA9PT0gb2JqZWN0Ll9fa2V5O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGxvZ2ljYWwgcHJlY2VkZXMgdGhlIHRhcmdldCBub2RlIGluIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXROb2RlIC0gdGhlIG5vZGUgd2UncmUgdGVzdGluZyB0byBzZWUgaWYgaXQncyBhZnRlciB0aGlzIG9uZS5cbiAgICovXG5cblxuICBpc0JlZm9yZSh0YXJnZXROb2RlKSB7XG4gICAgaWYgKHRoaXMgPT09IHRhcmdldE5vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0Tm9kZS5pc1BhcmVudE9mKHRoaXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1BhcmVudE9mKHRhcmdldE5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgY29tbW9uQW5jZXN0b3IgPSB0aGlzLmdldENvbW1vbkFuY2VzdG9yKHRhcmdldE5vZGUpO1xuICAgIGxldCBpbmRleEEgPSAwO1xuICAgIGxldCBpbmRleEIgPSAwO1xuICAgIGxldCBub2RlID0gdGhpcztcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgICAgaWYgKHBhcmVudCA9PT0gY29tbW9uQW5jZXN0b3IpIHtcbiAgICAgICAgaW5kZXhBID0gbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG5cbiAgICBub2RlID0gdGFyZ2V0Tm9kZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgICAgaWYgKHBhcmVudCA9PT0gY29tbW9uQW5jZXN0b3IpIHtcbiAgICAgICAgaW5kZXhCID0gbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXhBIDwgaW5kZXhCO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGlzIHRoZSBwYXJlbnQgb2YgdGhlIHRhcmdldCBub2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXROb2RlIC0gdGhlIHdvdWxkLWJlIGNoaWxkIG5vZGUuXG4gICAqL1xuXG5cbiAgaXNQYXJlbnRPZih0YXJnZXROb2RlKSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5fX2tleTtcblxuICAgIGlmIChrZXkgPT09IHRhcmdldE5vZGUuX19rZXkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IHRhcmdldE5vZGU7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUuX19rZXkgPT09IGtleSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRPLURPOiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBzaW1wbGlmaWVkIGEgbG90XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIGJldHdlZW4gdGhpcyBub2RlIGFuZFxuICAgKiB0aGUgdGFyZ2V0IG5vZGUgaW4gdGhlIEVkaXRvclN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0Tm9kZSAtIHRoZSBub2RlIHRoYXQgbWFya3MgdGhlIG90aGVyIGVuZCBvZiB0aGUgcmFuZ2Ugb2Ygbm9kZXMgdG8gYmUgcmV0dXJuZWQuXG4gICAqL1xuXG5cbiAgZ2V0Tm9kZXNCZXR3ZWVuKHRhcmdldE5vZGUpIHtcbiAgICBjb25zdCBpc0JlZm9yZSA9IHRoaXMuaXNCZWZvcmUodGFyZ2V0Tm9kZSk7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIGxldCBub2RlID0gdGhpcztcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBrZXkgPSBub2RlLl9fa2V5O1xuXG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGtleSkpIHtcbiAgICAgICAgdmlzaXRlZC5hZGQoa2V5KTtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUgPT09IHRhcmdldE5vZGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkID0gJGlzRWxlbWVudE5vZGUobm9kZSkgPyBpc0JlZm9yZSA/IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpIDogbm9kZS5nZXRMYXN0Q2hpbGQoKSA6IG51bGw7XG5cbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXh0U2libGluZyA9IGlzQmVmb3JlID8gbm9kZS5nZXROZXh0U2libGluZygpIDogbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgICAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBuZXh0U2libGluZztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKHBhcmVudC5fX2tleSkpIHtcbiAgICAgICAgbm9kZXMucHVzaChwYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50ID09PSB0YXJnZXROb2RlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBsZXQgcGFyZW50U2libGluZyA9IG51bGw7XG4gICAgICBsZXQgYW5jZXN0b3IgPSBwYXJlbnQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yID09PSBudWxsKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYGdldE5vZGVzQmV0d2VlbjogYW5jZXN0b3IgaXMgbnVsbGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudFNpYmxpbmcgPSBpc0JlZm9yZSA/IGFuY2VzdG9yLmdldE5leHRTaWJsaW5nKCkgOiBhbmNlc3Rvci5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5nZXRQYXJlbnQoKTtcblxuICAgICAgICBpZiAoYW5jZXN0b3IgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocGFyZW50U2libGluZyA9PT0gbnVsbCAmJiAhdmlzaXRlZC5oYXMoYW5jZXN0b3IuX19rZXkpKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKHBhcmVudFNpYmxpbmcgPT09IG51bGwpO1xuXG4gICAgICBub2RlID0gcGFyZW50U2libGluZztcbiAgICB9XG5cbiAgICBpZiAoIWlzQmVmb3JlKSB7XG4gICAgICBub2Rlcy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGhhcyBiZWVuIG1hcmtlZCBkaXJ0eSBkdXJpbmcgdGhpcyB1cGRhdGUgY3ljbGUuXG4gICAqXG4gICAqL1xuXG5cbiAgaXNEaXJ0eSgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgICBjb25zdCBkaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gICAgcmV0dXJuIGRpcnR5TGVhdmVzICE9PSBudWxsICYmIGRpcnR5TGVhdmVzLmhhcyh0aGlzLl9fa2V5KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGF0ZXN0IHZlcnNpb24gb2YgdGhlIG5vZGUgZnJvbSB0aGUgYWN0aXZlIEVkaXRvclN0YXRlLlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gYXZvaWQgZ2V0dGluZyB2YWx1ZXMgZnJvbSBzdGFsZSBub2RlIHJlZmVyZW5jZXMuXG4gICAqXG4gICAqL1xuXG5cbiAgZ2V0TGF0ZXN0KCkge1xuICAgIGNvbnN0IGxhdGVzdCA9ICRnZXROb2RlQnlLZXkodGhpcy5fX2tleSk7XG5cbiAgICBpZiAobGF0ZXN0ID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsIG5vZGUgZG9lcyBub3QgZXhpc3QgaW4gYWN0aXZlIGVkaXRvciBzdGF0ZS4gQXZvaWQgdXNpbmcgdGhlIHNhbWUgbm9kZSByZWZlcmVuY2VzIGJldHdlZW4gbmVzdGVkIGNsb3N1cmVzIGZyb20gZWRpdG9yU3RhdGUucmVhZC9lZGl0b3IudXBkYXRlLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYXRlc3Q7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBtdXRhYmxlIHZlcnNpb24gb2YgdGhlIG5vZGUuIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWZcbiAgICogY2FsbGVkIG91dHNpZGUgb2YgYSBMZXhpY2FsIEVkaXRvciB7QGxpbmsgTGV4aWNhbEVkaXRvci51cGRhdGV9IGNhbGxiYWNrLlxuICAgKlxuICAgKi9cblxuXG4gIGdldFdyaXRhYmxlKCkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGNvbnN0IGVkaXRvclN0YXRlID0gZ2V0QWN0aXZlRWRpdG9yU3RhdGUoKTtcbiAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5fX2tleTsgLy8gRW5zdXJlIHdlIGdldCB0aGUgbGF0ZXN0IG5vZGUgZnJvbSBwZW5kaW5nIHN0YXRlXG5cbiAgICBjb25zdCBsYXRlc3ROb2RlID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwYXJlbnQgPSBsYXRlc3ROb2RlLl9fcGFyZW50O1xuICAgIGNvbnN0IGNsb25lTm90TmVlZGVkID0gZWRpdG9yLl9jbG9uZU5vdE5lZWRlZDtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICBzZWxlY3Rpb24uX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY2xvbmVOb3ROZWVkZWQuaGFzKGtleSkpIHtcbiAgICAgIC8vIFRyYW5zZm9ybXMgY2xlYXIgdGhlIGRpcnR5IG5vZGUgc2V0IG9uIGVhY2ggaXRlcmF0aW9uIHRvIGtlZXAgdHJhY2sgb24gbmV3bHkgZGlydHkgbm9kZXNcbiAgICAgIGludGVybmFsTWFya05vZGVBc0RpcnR5KGxhdGVzdE5vZGUpO1xuICAgICAgcmV0dXJuIGxhdGVzdE5vZGU7XG4gICAgfVxuXG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBsYXRlc3ROb2RlLmNvbnN0cnVjdG9yOyAvLyBAdHMtZXhwZWN0LWVycm9yXG5cbiAgICBjb25zdCBtdXRhYmxlTm9kZSA9IGNvbnN0cnVjdG9yLmNsb25lKGxhdGVzdE5vZGUpO1xuICAgIG11dGFibGVOb2RlLl9fcGFyZW50ID0gcGFyZW50O1xuICAgIG11dGFibGVOb2RlLl9fbmV4dCA9IGxhdGVzdE5vZGUuX19uZXh0O1xuICAgIG11dGFibGVOb2RlLl9fcHJldiA9IGxhdGVzdE5vZGUuX19wcmV2O1xuXG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGxhdGVzdE5vZGUpICYmICRpc0VsZW1lbnROb2RlKG11dGFibGVOb2RlKSkge1xuICAgICAgbXV0YWJsZU5vZGUuX19maXJzdCA9IGxhdGVzdE5vZGUuX19maXJzdDtcbiAgICAgIG11dGFibGVOb2RlLl9fbGFzdCA9IGxhdGVzdE5vZGUuX19sYXN0O1xuICAgICAgbXV0YWJsZU5vZGUuX19zaXplID0gbGF0ZXN0Tm9kZS5fX3NpemU7XG4gICAgICBtdXRhYmxlTm9kZS5fX2luZGVudCA9IGxhdGVzdE5vZGUuX19pbmRlbnQ7XG4gICAgICBtdXRhYmxlTm9kZS5fX2Zvcm1hdCA9IGxhdGVzdE5vZGUuX19mb3JtYXQ7XG4gICAgICBtdXRhYmxlTm9kZS5fX2RpciA9IGxhdGVzdE5vZGUuX19kaXI7XG4gICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZShsYXRlc3ROb2RlKSAmJiAkaXNUZXh0Tm9kZShtdXRhYmxlTm9kZSkpIHtcbiAgICAgIG11dGFibGVOb2RlLl9fZm9ybWF0ID0gbGF0ZXN0Tm9kZS5fX2Zvcm1hdDtcbiAgICAgIG11dGFibGVOb2RlLl9fc3R5bGUgPSBsYXRlc3ROb2RlLl9fc3R5bGU7XG4gICAgICBtdXRhYmxlTm9kZS5fX21vZGUgPSBsYXRlc3ROb2RlLl9fbW9kZTtcbiAgICAgIG11dGFibGVOb2RlLl9fZGV0YWlsID0gbGF0ZXN0Tm9kZS5fX2RldGFpbDtcbiAgICB9XG5cbiAgICBjbG9uZU5vdE5lZWRlZC5hZGQoa2V5KTtcbiAgICBtdXRhYmxlTm9kZS5fX2tleSA9IGtleTtcbiAgICBpbnRlcm5hbE1hcmtOb2RlQXNEaXJ0eShtdXRhYmxlTm9kZSk7IC8vIFVwZGF0ZSByZWZlcmVuY2UgaW4gbm9kZSBtYXBcblxuICAgIG5vZGVNYXAuc2V0KGtleSwgbXV0YWJsZU5vZGUpO1xuICAgIHJldHVybiBtdXRhYmxlTm9kZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBub2RlLiBPdmVycmlkZSB0aGlzIGZvclxuICAgKiBjdXN0b20gbm9kZXMgdGhhdCBzaG91bGQgaGF2ZSBhIHJlcHJlc2VudGF0aW9uIGluIHBsYWluIHRleHRcbiAgICogZm9ybWF0IChmb3IgY29weSArIHBhc3RlLCBmb3IgZXhhbXBsZSlcbiAgICpcbiAgICovXG5cblxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHByb2R1Y2VkIGJ5IGNhbGxpbmcgZ2V0VGV4dENvbnRlbnQgb24gdGhpcyBub2RlLlxuICAgKlxuICAgKi9cblxuXG4gIGdldFRleHRDb250ZW50U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aDtcbiAgfSAvLyBWaWV3XG5cbiAgLyoqXG4gICAqIENhbGxlZCBkdXJpbmcgdGhlIHJlY29uY2lsaWF0aW9uIHByb2Nlc3MgdG8gZGV0ZXJtaW5lIHdoaWNoIG5vZGVzXG4gICAqIHRvIGluc2VydCBpbnRvIHRoZSBET00gZm9yIHRoaXMgTGV4aWNhbCBOb2RlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBtdXN0IHJldHVybiBleGFjdGx5IG9uZSBIVE1MRWxlbWVudC4gTmVzdGVkIGVsZW1lbnRzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBEbyBub3QgYXR0ZW1wdCB0byB1cGRhdGUgdGhlIExleGljYWwgRWRpdG9yU3RhdGUgZHVyaW5nIHRoaXMgcGhhc2Ugb2YgdGhlIHVwZGF0ZSBsaWZlY3lsZS5cbiAgICpcbiAgICogQHBhcmFtIF9jb25maWcgLSBhbGxvd3MgYWNjZXNzIHRvIHRoaW5ncyBsaWtlIHRoZSBFZGl0b3JUaGVtZSAodG8gYXBwbHkgY2xhc3NlcykgZHVyaW5nIHJlY29uY2lsaWF0aW9uLlxuICAgKiBAcGFyYW0gX2VkaXRvciAtIGFsbG93cyBhY2Nlc3MgdG8gdGhlIGVkaXRvciBmb3IgY29udGV4dCBkdXJpbmcgcmVjb25jaWxpYXRpb24uXG4gICAqXG4gICAqICovXG5cblxuICBjcmVhdGVET00oX2NvbmZpZywgX2VkaXRvcikge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBjcmVhdGVET006IGJhc2UgbWV0aG9kIG5vdCBleHRlbmRlZGApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBub2RlIGNoYW5nZXMgYW5kIHNob3VsZCB1cGRhdGUgdGhlIERPTVxuICAgKiBpbiB3aGF0ZXZlciB3YXkgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaXQgYWxpZ24gd2l0aCBhbnkgY2hhbmdlcyB0aGF0IG1pZ2h0XG4gICAqIGhhdmUgaGFwcGVuZWQgZHVyaW5nIHRoZSB1cGRhdGUuXG4gICAqXG4gICAqIFJldHVybmluZyBcInRydWVcIiBoZXJlIHdpbGwgY2F1c2UgbGV4aWNhbCB0byB1bm1vdW50IGFuZCByZWNyZWF0ZSB0aGUgRE9NIG5vZGVcbiAgICogKGJ5IGNhbGxpbmcgY3JlYXRlRE9NKS4gWW91IHdvdWxkIG5lZWQgdG8gZG8gdGhpcyBpZiB0aGUgZWxlbWVudCB0YWcgY2hhbmdlcyxcbiAgICogZm9yIGluc3RhbmNlLlxuICAgKlxuICAgKiAqL1xuXG5cbiAgdXBkYXRlRE9NKF9wcmV2Tm9kZSwgX2RvbSwgX2NvbmZpZykge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGB1cGRhdGVET006IGJhc2UgbWV0aG9kIG5vdCBleHRlbmRlZGApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29udHJvbHMgaG93IHRoZSB0aGlzIG5vZGUgaXMgc2VyaWFsaXplZCB0byBIVE1MLiBUaGlzIGlzIGltcG9ydGFudCBmb3JcbiAgICogY29weSBhbmQgcGFzdGUgYmV0d2VlbiBMZXhpY2FsIGFuZCBub24tTGV4aWNhbCBlZGl0b3JzLCBvciBMZXhpY2FsIGVkaXRvcnMgd2l0aCBkaWZmZXJlbnQgbmFtZXNwYWNlcyxcbiAgICogaW4gd2hpY2ggY2FzZSB0aGUgcHJpbWFyeSB0cmFuc2ZlciBmb3JtYXQgaXMgSFRNTC4gSXQncyBhbHNvIGltcG9ydGFudCBpZiB5b3UncmUgc2VyaWFsaXppbmdcbiAgICogdG8gSFRNTCBmb3IgYW55IG90aGVyIHJlYXNvbiB2aWEge0BsaW5rIEBsZXhpY2FsL2h0bWwhJGdlbmVyYXRlSHRtbEZyb21Ob2Rlc30uIFlvdSBjb3VsZFxuICAgKiBhbHNvIHVzZSB0aGlzIG1ldGhvZCB0byBidWlsZCB5b3VyIG93biBIVE1MIHJlbmRlcmVyLlxuICAgKlxuICAgKiAqL1xuXG5cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmNyZWF0ZURPTShlZGl0b3IuX2NvbmZpZywgZWRpdG9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENvbnRyb2xzIGhvdyB0aGUgdGhpcyBub2RlIGlzIHNlcmlhbGl6ZWQgdG8gSlNPTi4gVGhpcyBpcyBpbXBvcnRhbnQgZm9yXG4gICAqIGNvcHkgYW5kIHBhc3RlIGJldHdlZW4gTGV4aWNhbCBlZGl0b3JzIHNoYXJpbmcgdGhlIHNhbWUgbmFtZXNwYWNlLiBJdCdzIGFsc28gaW1wb3J0YW50XG4gICAqIGlmIHlvdSdyZSBzZXJpYWxpemluZyB0byBKU09OIGZvciBwZXJzaXN0ZW50IHN0b3JhZ2Ugc29tZXdoZXJlLlxuICAgKiBTZWUgW1NlcmlhbGl6YXRpb24gJiBEZXNlcmlhbGl6YXRpb25dKGh0dHBzOi8vbGV4aWNhbC5kZXYvZG9jcy9jb25jZXB0cy9zZXJpYWxpemF0aW9uI2xleGljYWwtLS1odG1sKS5cbiAgICpcbiAgICogKi9cblxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYGV4cG9ydEpTT046IGJhc2UgbWV0aG9kIG5vdCBleHRlbmRlZGApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ29udHJvbHMgaG93IHRoZSB0aGlzIG5vZGUgaXMgZGVzZXJpYWxpemVkIGZyb20gSlNPTi4gVGhpcyBpcyB1c3VhbGx5IGJvaWxlcnBsYXRlLFxuICAgKiBidXQgcHJvdmlkZXMgYW4gYWJzdHJhY3Rpb24gYmV0d2VlbiB0aGUgbm9kZSBpbXBsZW1lbnRhdGlvbiBhbmQgc2VyaWFsaXplZCBpbnRlcmZhY2UgdGhhdCBjYW5cbiAgICogYmUgaW1wb3J0YW50IGlmIHlvdSBldmVyIG1ha2UgYnJlYWtpbmcgY2hhbmdlcyB0byBhIG5vZGUgc2NoZW1hIChieSBhZGRpbmcgb3IgcmVtb3ZpbmcgcHJvcGVydGllcykuXG4gICAqIFNlZSBbU2VyaWFsaXphdGlvbiAmIERlc2VyaWFsaXphdGlvbl0oaHR0cHM6Ly9sZXhpY2FsLmRldi9kb2NzL2NvbmNlcHRzL3NlcmlhbGl6YXRpb24jbGV4aWNhbC0tLWh0bWwpLlxuICAgKlxuICAgKiAqL1xuXG5cbiAgc3RhdGljIGltcG9ydEpTT04oX3NlcmlhbGl6ZWROb2RlKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7dGhpcy5uYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgLmltcG9ydEpTT04oKS5gKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICpcbiAgICogUmVnaXN0ZXJzIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBhcyBhIHRyYW5zZm9ybSBvbiB0aGUgbm9kZSBkdXJpbmdcbiAgICogRWRpdG9yIGluaXRpYWxpemF0aW9uLiBNb3N0IHN1Y2ggdXNlIGNhc2VzIHNob3VsZCBiZSBhZGRyZXNzZWQgdmlhXG4gICAqIHRoZSB7QGxpbmsgTGV4aWNhbEVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm19IEFQSS5cbiAgICpcbiAgICogRXhwZXJpbWVudGFsIC0gdXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuXG5cbiAgc3RhdGljIHRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBTZXR0ZXJzIGFuZCBtdXRhdG9yc1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoaXMgTGV4aWNhbE5vZGUgZnJvbSB0aGUgRWRpdG9yU3RhdGUuIElmIHRoZSBub2RlIGlzbid0IHJlLWluc2VydGVkXG4gICAqIHNvbWV3aGVyZSwgdGhlIExleGljYWwgZ2FyYmFnZSBjb2xsZWN0b3Igd2lsbCBldmVudHVhbGx5IGNsZWFuIGl0IHVwLlxuICAgKlxuICAgKiBAcGFyYW0gcHJlc2VydmVFbXB0eVBhcmVudCAtIElmIGZhbHN5LCB0aGUgbm9kZSdzIHBhcmVudCB3aWxsIGJlIHJlbW92ZWQgaWZcbiAgICogaXQncyBlbXB0eSBhZnRlciB0aGUgcmVtb3ZhbCBvcGVyYXRpb24uIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IsIHN1YmplY3QgdG9cbiAgICogb3RoZXIgbm9kZSBoZXVyaXN0aWNzIHN1Y2ggYXMge0BsaW5rIEVsZW1lbnROb2RlI2NhbkJlRW1wdHl9XG4gICAqICovXG5cblxuICByZW1vdmUocHJlc2VydmVFbXB0eVBhcmVudCkge1xuICAgIHJlbW92ZU5vZGUodGhpcywgdHJ1ZSwgcHJlc2VydmVFbXB0eVBhcmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoaXMgTGV4aWNhbE5vZGUgd2l0aCB0aGUgcHJvdmlkZWQgbm9kZSwgb3B0aW9uYWxseSB0cmFuc2ZlcnJpbmcgdGhlIGNoaWxkcmVuXG4gICAqIG9mIHRoZSByZXBsYWNlZCBub2RlIHRvIHRoZSByZXBsYWNpbmcgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHJlcGxhY2VXaXRoIC0gVGhlIG5vZGUgdG8gcmVwbGFjZSB0aGlzIG9uZSB3aXRoLlxuICAgKiBAcGFyYW0gaW5jbHVkZUNoaWxkcmVuIC0gV2hldGhlciBvciBub3QgdG8gdHJhbnNmZXIgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSB0byB0aGUgcmVwbGFjaW5nIG5vZGUuXG4gICAqICovXG5cblxuICByZXBsYWNlKHJlcGxhY2VXaXRoLCBpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBsZXQgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgIGVycm9yT25JbnNlcnRUZXh0Tm9kZU9uUm9vdCh0aGlzLCByZXBsYWNlV2l0aCk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgdG9SZXBsYWNlS2V5ID0gdGhpcy5fX2tleTtcbiAgICBjb25zdCBrZXkgPSByZXBsYWNlV2l0aC5fX2tleTtcbiAgICBjb25zdCB3cml0YWJsZVJlcGxhY2VXaXRoID0gcmVwbGFjZVdpdGguZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCB3cml0YWJsZVBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3Qgc2l6ZSA9IHdyaXRhYmxlUGFyZW50Ll9fc2l6ZTtcbiAgICByZW1vdmVGcm9tUGFyZW50KHdyaXRhYmxlUmVwbGFjZVdpdGgpO1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gc2VsZi5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IHNlbGYuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBjb25zdCBwcmV2S2V5ID0gc2VsZi5fX3ByZXY7XG4gICAgY29uc3QgbmV4dEtleSA9IHNlbGYuX19uZXh0O1xuICAgIGNvbnN0IHBhcmVudEtleSA9IHNlbGYuX19wYXJlbnQ7XG4gICAgcmVtb3ZlTm9kZShzZWxmLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50Ll9fZmlyc3QgPSBrZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlUHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBrZXk7XG4gICAgfVxuXG4gICAgd3JpdGFibGVSZXBsYWNlV2l0aC5fX3ByZXYgPSBwcmV2S2V5O1xuXG4gICAgaWYgKG5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICB3cml0YWJsZVBhcmVudC5fX2xhc3QgPSBrZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlTmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSBrZXk7XG4gICAgfVxuXG4gICAgd3JpdGFibGVSZXBsYWNlV2l0aC5fX25leHQgPSBuZXh0S2V5O1xuICAgIHdyaXRhYmxlUmVwbGFjZVdpdGguX19wYXJlbnQgPSBwYXJlbnRLZXk7XG4gICAgd3JpdGFibGVQYXJlbnQuX19zaXplID0gc2l6ZTtcblxuICAgIGlmIChpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgd3JpdGFibGVSZXBsYWNlV2l0aC5hcHBlbmQoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcblxuICAgICAgaWYgKGFuY2hvci5rZXkgPT09IHRvUmVwbGFjZUtleSkge1xuICAgICAgICAkbW92ZVNlbGVjdGlvblBvaW50VG9FbmQoYW5jaG9yLCB3cml0YWJsZVJlcGxhY2VXaXRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvY3VzLmtleSA9PT0gdG9SZXBsYWNlS2V5KSB7XG4gICAgICAgICRtb3ZlU2VsZWN0aW9uUG9pbnRUb0VuZChmb2N1cywgd3JpdGFibGVSZXBsYWNlV2l0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCRnZXRDb21wb3NpdGlvbktleSgpID09PSB0b1JlcGxhY2VLZXkpIHtcbiAgICAgICRzZXRDb21wb3NpdGlvbktleShrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiB3cml0YWJsZVJlcGxhY2VXaXRoO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIGEgbm9kZSBhZnRlciB0aGlzIExleGljYWxOb2RlIChhcyB0aGUgbmV4dCBzaWJsaW5nKS5cbiAgICpcbiAgICogQHBhcmFtIG5vZGVUb0luc2VydCAtIFRoZSBub2RlIHRvIGluc2VydCBhZnRlciB0aGlzIG9uZS5cbiAgICogQHBhcmFtIHJlc3RvcmVTZWxlY3Rpb24gLSBXaGV0aGVyIG9yIG5vdCB0byBhdHRlbXB0IHRvIHJlc29sdmUgdGhlXG4gICAqIHNlbGVjdGlvbiB0byB0aGUgYXBwcm9wcmlhdGUgcGxhY2UgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cbiAgICogKi9cblxuXG4gIGluc2VydEFmdGVyKG5vZGVUb0luc2VydCwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBlcnJvck9uSW5zZXJ0VGV4dE5vZGVPblJvb3QodGhpcywgbm9kZVRvSW5zZXJ0KTtcbiAgICBjb25zdCB3cml0YWJsZVNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3Qgd3JpdGFibGVOb2RlVG9JbnNlcnQgPSBub2RlVG9JbnNlcnQuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBvbGRQYXJlbnQgPSB3cml0YWJsZU5vZGVUb0luc2VydC5nZXRQYXJlbnQoKTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgbGV0IGVsZW1lbnRBbmNob3JTZWxlY3Rpb25Pbk5vZGUgPSBmYWxzZTtcbiAgICBsZXQgZWxlbWVudEZvY3VzU2VsZWN0aW9uT25Ob2RlID0gZmFsc2U7XG5cbiAgICBpZiAob2xkUGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiB0aGlzIGlzIE8obiksIGNhbiB3ZSBpbXByb3ZlP1xuICAgICAgY29uc3Qgb2xkSW5kZXggPSBub2RlVG9JbnNlcnQuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9JbnNlcnQpO1xuXG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBvbGRQYXJlbnRLZXkgPSBvbGRQYXJlbnQuX19rZXk7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICBlbGVtZW50QW5jaG9yU2VsZWN0aW9uT25Ob2RlID0gYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBhbmNob3Iua2V5ID09PSBvbGRQYXJlbnRLZXkgJiYgYW5jaG9yLm9mZnNldCA9PT0gb2xkSW5kZXggKyAxO1xuICAgICAgICBlbGVtZW50Rm9jdXNTZWxlY3Rpb25Pbk5vZGUgPSBmb2N1cy50eXBlID09PSAnZWxlbWVudCcgJiYgZm9jdXMua2V5ID09PSBvbGRQYXJlbnRLZXkgJiYgZm9jdXMub2Zmc2V0ID09PSBvbGRJbmRleCArIDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSB0aGlzLmdldE5leHRTaWJsaW5nKCk7XG4gICAgY29uc3Qgd3JpdGFibGVQYXJlbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IGluc2VydEtleSA9IHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fa2V5O1xuICAgIGNvbnN0IG5leHRLZXkgPSB3cml0YWJsZVNlbGYuX19uZXh0O1xuXG4gICAgaWYgKG5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICB3cml0YWJsZVBhcmVudC5fX2xhc3QgPSBpbnNlcnRLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlTmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgd3JpdGFibGVOZXh0U2libGluZy5fX3ByZXYgPSBpbnNlcnRLZXk7XG4gICAgfVxuXG4gICAgd3JpdGFibGVQYXJlbnQuX19zaXplKys7XG4gICAgd3JpdGFibGVTZWxmLl9fbmV4dCA9IGluc2VydEtleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX25leHQgPSBuZXh0S2V5O1xuICAgIHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fcHJldiA9IHdyaXRhYmxlU2VsZi5fX2tleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3BhcmVudCA9IHdyaXRhYmxlU2VsZi5fX3BhcmVudDtcblxuICAgIGlmIChyZXN0b3JlU2VsZWN0aW9uICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgICAgJHVwZGF0ZUVsZW1lbnRTZWxlY3Rpb25PbkNyZWF0ZURlbGV0ZU5vZGUoc2VsZWN0aW9uLCB3cml0YWJsZVBhcmVudCwgaW5kZXggKyAxKTtcbiAgICAgIGNvbnN0IHdyaXRhYmxlUGFyZW50S2V5ID0gd3JpdGFibGVQYXJlbnQuX19rZXk7XG5cbiAgICAgIGlmIChlbGVtZW50QW5jaG9yU2VsZWN0aW9uT25Ob2RlKSB7XG4gICAgICAgIHNlbGVjdGlvbi5hbmNob3Iuc2V0KHdyaXRhYmxlUGFyZW50S2V5LCBpbmRleCArIDIsICdlbGVtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50Rm9jdXNTZWxlY3Rpb25Pbk5vZGUpIHtcbiAgICAgICAgc2VsZWN0aW9uLmZvY3VzLnNldCh3cml0YWJsZVBhcmVudEtleSwgaW5kZXggKyAyLCAnZWxlbWVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlVG9JbnNlcnQ7XG4gIH1cbiAgLyoqXG4gICAqIEluc2VydHMgYSBub2RlIGJlZm9yZSB0aGlzIExleGljYWxOb2RlIChhcyB0aGUgcHJldmlvdXMgc2libGluZykuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlVG9JbnNlcnQgLSBUaGUgbm9kZSB0byBpbnNlcnQgYWZ0ZXIgdGhpcyBvbmUuXG4gICAqIEBwYXJhbSByZXN0b3JlU2VsZWN0aW9uIC0gV2hldGhlciBvciBub3QgdG8gYXR0ZW1wdCB0byByZXNvbHZlIHRoZVxuICAgKiBzZWxlY3Rpb24gdG8gdGhlIGFwcHJvcHJpYXRlIHBsYWNlIGFmdGVyIHRoZSBvcGVyYXRpb24gaXMgY29tcGxldGUuXG4gICAqICovXG5cblxuICBpbnNlcnRCZWZvcmUobm9kZVRvSW5zZXJ0LCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGVycm9yT25JbnNlcnRUZXh0Tm9kZU9uUm9vdCh0aGlzLCBub2RlVG9JbnNlcnQpO1xuICAgIGNvbnN0IHdyaXRhYmxlU2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCB3cml0YWJsZU5vZGVUb0luc2VydCA9IG5vZGVUb0luc2VydC5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IGluc2VydEtleSA9IHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fa2V5O1xuICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9JbnNlcnQpO1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCB3cml0YWJsZVBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3QgcHJldktleSA9IHdyaXRhYmxlU2VsZi5fX3ByZXY7IC8vIFRPRE86IHRoaXMgaXMgTyhuKSwgY2FuIHdlIGltcHJvdmU/XG5cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcblxuICAgIGlmIChwcmV2U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgd3JpdGFibGVQYXJlbnQuX19maXJzdCA9IGluc2VydEtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVQcmV2U2libGluZyA9IHByZXZTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICB3cml0YWJsZVByZXZTaWJsaW5nLl9fbmV4dCA9IGluc2VydEtleTtcbiAgICB9XG5cbiAgICB3cml0YWJsZVBhcmVudC5fX3NpemUrKztcbiAgICB3cml0YWJsZVNlbGYuX19wcmV2ID0gaW5zZXJ0S2V5O1xuICAgIHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fcHJldiA9IHByZXZLZXk7XG4gICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19uZXh0ID0gd3JpdGFibGVTZWxmLl9fa2V5O1xuICAgIHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fcGFyZW50ID0gd3JpdGFibGVTZWxmLl9fcGFyZW50O1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgIGlmIChyZXN0b3JlU2VsZWN0aW9uICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgJHVwZGF0ZUVsZW1lbnRTZWxlY3Rpb25PbkNyZWF0ZURlbGV0ZU5vZGUoc2VsZWN0aW9uLCBwYXJlbnQsIGluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZVRvSW5zZXJ0O1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIG5vZGUgaGFzIGEgcmVxdWlyZWQgcGFyZW50LiBVc2VkIGR1cmluZyBjb3B5ICsgcGFzdGUgb3BlcmF0aW9uc1xuICAgKiB0byBub3JtYWxpemUgbm9kZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYmUgb3JwaGFuZWQuIEZvciBleGFtcGxlLCBMaXN0SXRlbU5vZGVzIHdpdGhvdXRcbiAgICogYSBMaXN0Tm9kZSBwYXJlbnQgb3IgVGV4dE5vZGVzIHdpdGggYSBQYXJhZ3JhcGhOb2RlIHBhcmVudC5cbiAgICpcbiAgICogKi9cblxuXG4gIGlzUGFyZW50UmVxdWlyZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3JlYXRpb24gbG9naWMgZm9yIGFueSByZXF1aXJlZCBwYXJlbnQuIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpZiB7QGxpbmsgaXNQYXJlbnRSZXF1aXJlZH0gcmV0dXJucyB0cnVlLlxuICAgKlxuICAgKiAqL1xuXG5cbiAgY3JlYXRlUGFyZW50RWxlbWVudE5vZGUoKSB7XG4gICAgcmV0dXJuICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmVzIHNlbGVjdGlvbiB0byB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGlzIG5vZGUsIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0cy5cbiAgICpcbiAgICogQHBhcmFtIGFuY2hvck9mZnNldCAtIFRoZSBhbmNob3Igb2Zmc2V0IGZvciBzZWxlY3Rpb24uXG4gICAqIEBwYXJhbSBmb2N1c09mZnNldCAtICBUaGUgZm9jdXMgb2Zmc2V0IGZvciBzZWxlY3Rpb25cbiAgICogKi9cblxuXG4gIHNlbGVjdFByZXZpb3VzKGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBwYXJlbnQuc2VsZWN0KDAsIDApO1xuICAgIH1cblxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShwcmV2U2libGluZykpIHtcbiAgICAgIHJldHVybiBwcmV2U2libGluZy5zZWxlY3QoKTtcbiAgICB9IGVsc2UgaWYgKCEkaXNUZXh0Tm9kZShwcmV2U2libGluZykpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gcHJldlNpYmxpbmcuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDE7XG4gICAgICByZXR1cm4gcGFyZW50LnNlbGVjdChpbmRleCwgaW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2U2libGluZy5zZWxlY3QoYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCk7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmVzIHNlbGVjdGlvbiB0byB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoaXMgbm9kZSwgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXRzLlxuICAgKlxuICAgKiBAcGFyYW0gYW5jaG9yT2Zmc2V0IC0gVGhlIGFuY2hvciBvZmZzZXQgZm9yIHNlbGVjdGlvbi5cbiAgICogQHBhcmFtIGZvY3VzT2Zmc2V0IC0gIFRoZSBmb2N1cyBvZmZzZXQgZm9yIHNlbGVjdGlvblxuICAgKiAqL1xuXG5cbiAgc2VsZWN0TmV4dChhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0KSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSB0aGlzLmdldE5leHRTaWJsaW5nKCk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgICBpZiAobmV4dFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBwYXJlbnQuc2VsZWN0KCk7XG4gICAgfVxuXG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgcmV0dXJuIG5leHRTaWJsaW5nLnNlbGVjdCgwLCAwKTtcbiAgICB9IGVsc2UgaWYgKCEkaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbmV4dFNpYmxpbmcuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgIHJldHVybiBwYXJlbnQuc2VsZWN0KGluZGV4LCBpbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5leHRTaWJsaW5nLnNlbGVjdChhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0KTtcbiAgfVxuICAvKipcbiAgICogTWFya3MgYSBub2RlIGRpcnR5LCB0cmlnZ2VyaW5nIHRyYW5zZm9ybXMgYW5kXG4gICAqIGZvcmNpbmcgaXQgdG8gYmUgcmVjb25jaWxlZCBkdXJpbmcgdGhlIHVwZGF0ZSBjeWNsZS5cbiAgICpcbiAgICogKi9cblxuXG4gIG1hcmtEaXJ0eSgpIHtcbiAgICB0aGlzLmdldFdyaXRhYmxlKCk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBlcnJvck9uVHlwZUtsYXNzTWlzbWF0Y2godHlwZSwga2xhc3MpIHtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSBnZXRBY3RpdmVFZGl0b3IoKS5fbm9kZXMuZ2V0KHR5cGUpOyAvLyBDb21tb24gZXJyb3IgLSBzcGxpdCBpbiBpdHMgb3duIGludmFyaWFudFxuXG5cbiAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgQ3JlYXRlIG5vZGU6IEF0dGVtcHRlZCB0byBjcmVhdGUgbm9kZSAke2tsYXNzLm5hbWV9IHRoYXQgd2FzIG5vdCBjb25maWd1cmVkIHRvIGJlIHVzZWQgb24gdGhlIGVkaXRvci5gKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBlZGl0b3JLbGFzcyA9IHJlZ2lzdGVyZWROb2RlLmtsYXNzO1xuXG4gIGlmIChlZGl0b3JLbGFzcyAhPT0ga2xhc3MpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgQ3JlYXRlIG5vZGU6IFR5cGUgJHt0eXBlfSBpbiBub2RlICR7a2xhc3MubmFtZX0gZG9lcyBub3QgbWF0Y2ggcmVnaXN0ZXJlZCBub2RlICR7ZWRpdG9yS2xhc3MubmFtZX0gd2l0aCB0aGUgc2FtZSB0eXBlYCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpbmVCcmVha05vZGUgZXh0ZW5kcyBMZXhpY2FsTm9kZSB7XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnbGluZWJyZWFrJztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lQnJlYWtOb2RlKG5vZGUuX19rZXkpO1xuICB9XG5cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgfVxuXG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIHJldHVybiAnXFxuJztcbiAgfVxuXG4gIGNyZWF0ZURPTSgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKTtcbiAgfVxuXG4gIHVwZGF0ZURPTSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBicjogbm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7IC8vIElmIHRoZSA8YnI+IGlzIHRoZSBvbmx5IGNoaWxkLCB0aGVuIHNraXAgaW5jbHVkaW5nIGl0XG5cbiAgICAgICAgbGV0IGZpcnN0Q2hpbGQ7XG4gICAgICAgIGxldCBsYXN0Q2hpbGQ7XG5cbiAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQgIT09IG51bGwgJiYgKChmaXJzdENoaWxkID0gcGFyZW50RWxlbWVudC5maXJzdENoaWxkKSA9PT0gbm9kZSB8fCBmaXJzdENoaWxkLm5leHRTaWJsaW5nID09PSBub2RlICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IERPTV9URVhUX1RZUEUgJiYgKGZpcnN0Q2hpbGQudGV4dENvbnRlbnQgfHwgJycpLm1hdGNoKC9eW1xcc3xcXHI/XFxufFxcdF0rJC8pICE9PSBudWxsKSAmJiAoKGxhc3RDaGlsZCA9IHBhcmVudEVsZW1lbnQubGFzdENoaWxkKSA9PT0gbm9kZSB8fCBsYXN0Q2hpbGQucHJldmlvdXNTaWJsaW5nID09PSBub2RlICYmIGxhc3RDaGlsZC5ub2RlVHlwZSA9PT0gRE9NX1RFWFRfVFlQRSAmJiAobGFzdENoaWxkLnRleHRDb250ZW50IHx8ICcnKS5tYXRjaCgvXltcXHN8XFxyP1xcbnxcXHRdKyQvKSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29udmVyc2lvbjogY29udmVydExpbmVCcmVha0VsZW1lbnQsXG4gICAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZExpbmVCcmVha05vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUxpbmVCcmVha05vZGUoKTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdsaW5lYnJlYWsnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH1cblxufVxuXG5mdW5jdGlvbiBjb252ZXJ0TGluZUJyZWFrRWxlbWVudChub2RlKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUxpbmVCcmVha05vZGUoKVxuICB9O1xufVxuXG5mdW5jdGlvbiAkY3JlYXRlTGluZUJyZWFrTm9kZSgpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgTGluZUJyZWFrTm9kZSgpKTtcbn1cbmZ1bmN0aW9uICRpc0xpbmVCcmVha05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIExpbmVCcmVha05vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gZ2V0RWxlbWVudE91dGVyVGFnKG5vZGUsIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ICYgSVNfQ09ERSkge1xuICAgIHJldHVybiAnY29kZSc7XG4gIH1cblxuICBpZiAoZm9ybWF0ICYgSVNfSElHSExJR0hUKSB7XG4gICAgcmV0dXJuICdtYXJrJztcbiAgfVxuXG4gIGlmIChmb3JtYXQgJiBJU19TVUJTQ1JJUFQpIHtcbiAgICByZXR1cm4gJ3N1Yic7XG4gIH1cblxuICBpZiAoZm9ybWF0ICYgSVNfU1VQRVJTQ1JJUFQpIHtcbiAgICByZXR1cm4gJ3N1cCc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RWxlbWVudElubmVyVGFnKG5vZGUsIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ICYgSVNfQk9MRCkge1xuICAgIHJldHVybiAnc3Ryb25nJztcbiAgfVxuXG4gIGlmIChmb3JtYXQgJiBJU19JVEFMSUMpIHtcbiAgICByZXR1cm4gJ2VtJztcbiAgfVxuXG4gIHJldHVybiAnc3Bhbic7XG59XG5cbmZ1bmN0aW9uIHNldFRleHRUaGVtZUNsYXNzTmFtZXModGFnLCBwcmV2Rm9ybWF0LCBuZXh0Rm9ybWF0LCBkb20sIHRleHRDbGFzc05hbWVzKSB7XG4gIGNvbnN0IGRvbUNsYXNzTGlzdCA9IGRvbS5jbGFzc0xpc3Q7IC8vIEZpcnN0bHkgd2UgaGFuZGxlIHRoZSBiYXNlIHRoZW1lLlxuXG4gIGxldCBjbGFzc05hbWVzID0gZ2V0Q2FjaGVkQ2xhc3NOYW1lQXJyYXkodGV4dENsYXNzTmFtZXMsICdiYXNlJyk7XG5cbiAgaWYgKGNsYXNzTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGRvbUNsYXNzTGlzdC5hZGQoLi4uY2xhc3NOYW1lcyk7XG4gIH0gLy8gU2Vjb25kbHkgd2UgaGFuZGxlIHRoZSBzcGVjaWFsIGNhc2U6IHVuZGVybGluZSArIHN0cmlrZXRocm91Z2guXG4gIC8vIFdlIGhhdmUgdG8gZG8gdGhpcyBhcyB3ZSBuZWVkIGEgd2F5IHRvIGNvbXBvc2UgdGhlIGZhY3QgdGhhdFxuICAvLyB0aGUgc2FtZSBDU1MgcHJvcGVydHkgd2lsbCBuZWVkIHRvIGJlIHVzZWQ6IHRleHQtZGVjb3JhdGlvbi5cbiAgLy8gSW4gYW4gaWRlYWwgd29ybGQgd2Ugc2hvdWxkbid0IGhhdmUgdG8gZG8gdGhpcywgYnV0IHRoZXJlJ3Mgbm9cbiAgLy8gZWFzeSB3b3JrYXJvdW5kIGZvciBtYW55IGF0b21pYyBDU1Mgc3lzdGVtcyB0b2RheS5cblxuXG4gIGNsYXNzTmFtZXMgPSBnZXRDYWNoZWRDbGFzc05hbWVBcnJheSh0ZXh0Q2xhc3NOYW1lcywgJ3VuZGVybGluZVN0cmlrZXRocm91Z2gnKTtcbiAgbGV0IGhhc1VuZGVybGluZVN0cmlrZXRocm91Z2ggPSBmYWxzZTtcbiAgY29uc3QgcHJldlVuZGVybGluZVN0cmlrZXRocm91Z2ggPSBwcmV2Rm9ybWF0ICYgSVNfVU5ERVJMSU5FICYmIHByZXZGb3JtYXQgJiBJU19TVFJJS0VUSFJPVUdIO1xuICBjb25zdCBuZXh0VW5kZXJsaW5lU3RyaWtldGhyb3VnaCA9IG5leHRGb3JtYXQgJiBJU19VTkRFUkxJTkUgJiYgbmV4dEZvcm1hdCAmIElTX1NUUklLRVRIUk9VR0g7XG5cbiAgaWYgKGNsYXNzTmFtZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChuZXh0VW5kZXJsaW5lU3RyaWtldGhyb3VnaCkge1xuICAgICAgaGFzVW5kZXJsaW5lU3RyaWtldGhyb3VnaCA9IHRydWU7XG5cbiAgICAgIGlmICghcHJldlVuZGVybGluZVN0cmlrZXRocm91Z2gpIHtcbiAgICAgICAgZG9tQ2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoKSB7XG4gICAgICBkb21DbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3Qga2V5IGluIFRFWFRfVFlQRV9UT19GT1JNQVQpIHtcbiAgICBjb25zdCBmb3JtYXQgPSBrZXk7XG4gICAgY29uc3QgZmxhZyA9IFRFWFRfVFlQRV9UT19GT1JNQVRbZm9ybWF0XTtcbiAgICBjbGFzc05hbWVzID0gZ2V0Q2FjaGVkQ2xhc3NOYW1lQXJyYXkodGV4dENsYXNzTmFtZXMsIGtleSk7XG5cbiAgICBpZiAoY2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAobmV4dEZvcm1hdCAmIGZsYWcpIHtcbiAgICAgICAgaWYgKGhhc1VuZGVybGluZVN0cmlrZXRocm91Z2ggJiYgKGtleSA9PT0gJ3VuZGVybGluZScgfHwga2V5ID09PSAnc3RyaWtldGhyb3VnaCcpKSB7XG4gICAgICAgICAgaWYgKHByZXZGb3JtYXQgJiBmbGFnKSB7XG4gICAgICAgICAgICBkb21DbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChwcmV2Rm9ybWF0ICYgZmxhZykgPT09IDAgfHwgcHJldlVuZGVybGluZVN0cmlrZXRocm91Z2ggJiYga2V5ID09PSAndW5kZXJsaW5lJyB8fCBrZXkgPT09ICdzdHJpa2V0aHJvdWdoJykge1xuICAgICAgICAgIGRvbUNsYXNzTGlzdC5hZGQoLi4uY2xhc3NOYW1lcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJldkZvcm1hdCAmIGZsYWcpIHtcbiAgICAgICAgZG9tQ2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc05hbWVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkNvbXBvc2VkVGV4dChhLCBiKSB7XG4gIGNvbnN0IGFMZW5ndGggPSBhLmxlbmd0aDtcbiAgY29uc3QgYkxlbmd0aCA9IGIubGVuZ3RoO1xuICBsZXQgbGVmdCA9IDA7XG4gIGxldCByaWdodCA9IDA7XG5cbiAgd2hpbGUgKGxlZnQgPCBhTGVuZ3RoICYmIGxlZnQgPCBiTGVuZ3RoICYmIGFbbGVmdF0gPT09IGJbbGVmdF0pIHtcbiAgICBsZWZ0Kys7XG4gIH1cblxuICB3aGlsZSAocmlnaHQgKyBsZWZ0IDwgYUxlbmd0aCAmJiByaWdodCArIGxlZnQgPCBiTGVuZ3RoICYmIGFbYUxlbmd0aCAtIHJpZ2h0IC0gMV0gPT09IGJbYkxlbmd0aCAtIHJpZ2h0IC0gMV0pIHtcbiAgICByaWdodCsrO1xuICB9XG5cbiAgcmV0dXJuIFtsZWZ0LCBhTGVuZ3RoIC0gbGVmdCAtIHJpZ2h0LCBiLnNsaWNlKGxlZnQsIGJMZW5ndGggLSByaWdodCldO1xufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudChuZXh0VGV4dCwgZG9tLCBub2RlKSB7XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBkb20uZmlyc3RDaGlsZDtcbiAgY29uc3QgaXNDb21wb3NpbmcgPSBub2RlLmlzQ29tcG9zaW5nKCk7IC8vIEFsd2F5cyBhZGQgYSBzdWZmaXggaWYgd2UncmUgY29tcG9zaW5nIGEgbm9kZVxuXG4gIGNvbnN0IHN1ZmZpeCA9IGlzQ29tcG9zaW5nID8gQ09NUE9TSVRJT05fU1VGRklYIDogJyc7XG4gIGNvbnN0IHRleHQgPSBuZXh0VGV4dCArIHN1ZmZpeDtcblxuICBpZiAoZmlyc3RDaGlsZCA9PSBudWxsKSB7XG4gICAgZG9tLnRleHRDb250ZW50ID0gdGV4dDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBub2RlVmFsdWUgPSBmaXJzdENoaWxkLm5vZGVWYWx1ZTtcblxuICAgIGlmIChub2RlVmFsdWUgIT09IHRleHQpIHtcbiAgICAgIGlmIChpc0NvbXBvc2luZyB8fCBJU19GSVJFRk9YKSB7XG4gICAgICAgIC8vIFdlIGFsc28gdXNlIHRoZSBkaWZmIGNvbXBvc2VkIHRleHQgZm9yIGdlbmVyYWwgdGV4dCBpbiBGRiB0byBhdm9pZFxuICAgICAgICAvLyB0aGUgc3BlbGxjaGVjayByZWQgbGluZSBmcm9tIGZsaWNrZXJpbmcuXG4gICAgICAgIGNvbnN0IFtpbmRleCwgcmVtb3ZlLCBpbnNlcnRdID0gZGlmZkNvbXBvc2VkVGV4dChub2RlVmFsdWUsIHRleHQpO1xuXG4gICAgICAgIGlmIChyZW1vdmUgIT09IDApIHtcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgZmlyc3RDaGlsZC5kZWxldGVEYXRhKGluZGV4LCByZW1vdmUpO1xuICAgICAgICB9IC8vIEB0cy1leHBlY3QtZXJyb3JcblxuXG4gICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0RGF0YShpbmRleCwgaW5zZXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dElubmVyRE9NKGlubmVyRE9NLCBub2RlLCBpbm5lclRhZywgZm9ybWF0LCB0ZXh0LCBjb25maWcpIHtcbiAgc2V0VGV4dENvbnRlbnQodGV4dCwgaW5uZXJET00sIG5vZGUpO1xuICBjb25zdCB0aGVtZSA9IGNvbmZpZy50aGVtZTsgLy8gQXBwbHkgdGhlbWUgY2xhc3MgbmFtZXNcblxuICBjb25zdCB0ZXh0Q2xhc3NOYW1lcyA9IHRoZW1lLnRleHQ7XG5cbiAgaWYgKHRleHRDbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXRUZXh0VGhlbWVDbGFzc05hbWVzKGlubmVyVGFnLCAwLCBmb3JtYXQsIGlubmVyRE9NLCB0ZXh0Q2xhc3NOYW1lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JhcEVsZW1lbnRXaXRoKGVsZW1lbnQsIHRhZykge1xuICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgZWwuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIHJldHVybiBlbDtcbn1cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5cblxuY2xhc3MgVGV4dE5vZGUgZXh0ZW5kcyBMZXhpY2FsTm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0ZXh0JztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0Tm9kZShub2RlLl9fdGV4dCwgbm9kZS5fX2tleSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih0ZXh0LCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX190ZXh0ID0gdGV4dDtcbiAgICB0aGlzLl9fZm9ybWF0ID0gMDtcbiAgICB0aGlzLl9fc3R5bGUgPSAnJztcbiAgICB0aGlzLl9fbW9kZSA9IDA7XG4gICAgdGhpcy5fX2RldGFpbCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSAzMi1iaXQgaW50ZWdlciB0aGF0IHJlcHJlc2VudHMgdGhlIFRleHRGb3JtYXRUeXBlcyBjdXJyZW50bHkgYXBwbGllZCB0byB0aGVcbiAgICogVGV4dE5vZGUuIFlvdSBwcm9iYWJseSBkb24ndCB3YW50IHRvIHVzZSB0aGlzIG1ldGhvZCBkaXJlY3RseSAtIGNvbnNpZGVyIHVzaW5nIFRleHROb2RlLmhhc0Zvcm1hdCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIG51bWJlciByZXByZXNlbnRpbmcgdGhlIGZvcm1hdCBvZiB0aGUgdGV4dCBub2RlLlxuICAgKi9cblxuXG4gIGdldEZvcm1hdCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2Zvcm1hdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIDMyLWJpdCBpbnRlZ2VyIHRoYXQgcmVwcmVzZW50cyB0aGUgVGV4dERldGFpbFR5cGVzIGN1cnJlbnRseSBhcHBsaWVkIHRvIHRoZVxuICAgKiBUZXh0Tm9kZS4gWW91IHByb2JhYmx5IGRvbid0IHdhbnQgdG8gdXNlIHRoaXMgbWV0aG9kIGRpcmVjdGx5IC0gY29uc2lkZXIgdXNpbmcgVGV4dE5vZGUuaXNEaXJlY3Rpb25sZXNzXG4gICAqIG9yIFRleHROb2RlLmlzVW5tZXJnZWFibGUgaW5zdGVhZC5cbiAgICpcbiAgICogQHJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBkZXRhaWwgb2YgdGhlIHRleHQgbm9kZS5cbiAgICovXG5cblxuICBnZXREZXRhaWwoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19kZXRhaWw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1vZGUgKFRleHRNb2RlVHlwZSkgb2YgdGhlIFRleHROb2RlLCB3aGljaCBtYXkgYmUgXCJub3JtYWxcIiwgXCJ0b2tlblwiLCBvciBcInNlZ21lbnRlZFwiXG4gICAqXG4gICAqIEByZXR1cm5zIFRleHRNb2RlVHlwZS5cbiAgICovXG5cblxuICBnZXRNb2RlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBURVhUX1RZUEVfVE9fTU9ERVtzZWxmLl9fbW9kZV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0eWxlcyBjdXJyZW50bHkgYXBwbGllZCB0byB0aGUgbm9kZS4gVGhpcyBpcyBhbmFsb2dvdXMgdG8gQ1NTVGV4dCBpbiB0aGUgRE9NLlxuICAgKlxuICAgKiBAcmV0dXJucyBDU1NUZXh0LWxpa2Ugc3RyaW5nIG9mIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSB1bmRlcmx5aW5nIERPTSBub2RlLlxuICAgKi9cblxuXG4gIGdldFN0eWxlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fc3R5bGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgaW4gXCJ0b2tlblwiIG1vZGUuIFRleHROb2RlcyBpbiB0b2tlbiBtb2RlIGNhbiBiZSBuYXZpZ2F0ZWQgdGhyb3VnaCBjaGFyYWN0ZXItYnktY2hhcmFjdGVyXG4gICAqIHdpdGggYSBSYW5nZVNlbGVjdGlvbiwgYnV0IGFyZSBkZWxldGVkIGFzIGEgc2luZ2xlIGVudGl0eSAobm90IGludmRpdmlkdWFsbHkgYnkgY2hhcmFjdGVyKS5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBpbiB0b2tlbiBtb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgaXNUb2tlbigpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX21vZGUgPT09IElTX1RPS0VOO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIExleGljYWwgZGV0ZWN0cyB0aGF0IGFuIElNRSBvciBvdGhlciAzcmQtcGFydHkgc2NyaXB0IGlzIGF0dGVtcHRpbmcgdG9cbiAgICogbXV0YXRlIHRoZSBUZXh0Tm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cblxuXG4gIGlzQ29tcG9zaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9fa2V5ID09PSAkZ2V0Q29tcG9zaXRpb25LZXkoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBpbiBcInNlZ2VtZW50ZWRcIiBtb2RlLiBUZXh0Tm9kZXMgaW4gc2VnZW1lbnRlZCBtb2RlIGNhbiBiZSBuYXZpZ2F0ZWQgdGhyb3VnaCBjaGFyYWN0ZXItYnktY2hhcmFjdGVyXG4gICAqIHdpdGggYSBSYW5nZVNlbGVjdGlvbiwgYnV0IGFyZSBkZWxldGVkIGluIHNwYWNlLWRlbGltaXRlZCBcInNlZ21lbnRzXCIuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgaW4gc2VnbWVudGVkIG1vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBpc1NlZ21lbnRlZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX21vZGUgPT09IElTX1NFR01FTlRFRDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBcImRpcmVjdGlvbmxlc3NcIi4gRGlyZWN0aW9ubGVzcyBub2RlcyBkb24ndCByZXNwZWN0IGNoYW5nZXMgYmV0d2VlbiBSVEwgYW5kIExUUiBtb2Rlcy5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBkaXJlY3Rpb25sZXNzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgaXNEaXJlY3Rpb25sZXNzKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiAoc2VsZi5fX2RldGFpbCAmIElTX0RJUkVDVElPTkxFU1MpICE9PSAwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIHVubWVyZ2VhYmxlLiBJbiBzb21lIHNjZW5hcmlvcywgTGV4aWNhbCB0cmllcyB0byBtZXJnZVxuICAgKiBhZGphY2VudCBUZXh0Tm9kZXMgaW50byBhIHNpbmdsZSBUZXh0Tm9kZS4gSWYgYSBUZXh0Tm9kZSBpcyB1bm1lcmdlYWJsZSwgdGhpcyB3b24ndCBoYXBwZW4uXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgdW5tZXJnZWFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBpc1VubWVyZ2VhYmxlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiAoc2VsZi5fX2RldGFpbCAmIElTX1VOTUVSR0VBQkxFKSAhPT0gMDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBoYXMgdGhlIHByb3ZpZGVkIGZvcm1hdCBhcHBsaWVkLiBVc2UgdGhpcyB3aXRoIHRoZSBodW1hbi1yZWFkYWJsZSBUZXh0Rm9ybWF0VHlwZVxuICAgKiBzdHJpbmcgdmFsdWVzIHRvIGdldCB0aGUgZm9ybWF0IG9mIGEgVGV4dE5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gdGhlIFRleHRGb3JtYXRUeXBlIHRvIGNoZWNrIGZvci5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBoYXMgdGhlIHByb3ZpZGVkIGZvcm1hdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cblxuXG4gIGhhc0Zvcm1hdCh0eXBlKSB7XG4gICAgY29uc3QgZm9ybWF0RmxhZyA9IFRFWFRfVFlQRV9UT19GT1JNQVRbdHlwZV07XG4gICAgcmV0dXJuICh0aGlzLmdldEZvcm1hdCgpICYgZm9ybWF0RmxhZykgIT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgc2ltcGxlIHRleHQuIFNpbXBsZSB0ZXh0IGlzIGRlZmluZWQgYXMgYSBUZXh0Tm9kZSB0aGF0IGhhcyB0aGUgc3RyaW5nIHR5cGUgXCJ0ZXh0XCJcbiAgICogKGkuZS4sIG5vdCBhIHN1YmNsYXNzKSBhbmQgaGFzIG5vIG1vZGUgYXBwbGllZCB0byBpdCAoaS5lLiwgbm90IHNlZ21lbnRlZCBvciB0b2tlbikuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgc2ltcGxlIHRleHQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBpc1NpbXBsZVRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190eXBlID09PSAndGV4dCcgJiYgdGhpcy5fX21vZGUgPT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRleHQgY29udGVudCBvZiB0aGUgbm9kZSBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGUuXG4gICAqL1xuXG5cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX190ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmb3JtYXQgZmxhZ3MgYXBwbGllZCB0byB0aGUgbm9kZSBhcyBhIDMyLWJpdCBpbnRlZ2VyLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIG51bWJlciByZXByZXNlbnRpbmcgdGhlIFRleHRGb3JtYXRUeXBlcyBhcHBsaWVkIHRvIHRoZSBub2RlLlxuICAgKi9cblxuXG4gIGdldEZvcm1hdEZsYWdzKHR5cGUsIGFsaWduV2l0aEZvcm1hdCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IGZvcm1hdCA9IHNlbGYuX19mb3JtYXQ7XG4gICAgcmV0dXJuIHRvZ2dsZVRleHRGb3JtYXRUeXBlKGZvcm1hdCwgdHlwZSwgYWxpZ25XaXRoRm9ybWF0KTtcbiAgfSAvLyBWaWV3XG5cblxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5fX2Zvcm1hdDtcbiAgICBjb25zdCBvdXRlclRhZyA9IGdldEVsZW1lbnRPdXRlclRhZyh0aGlzLCBmb3JtYXQpO1xuICAgIGNvbnN0IGlubmVyVGFnID0gZ2V0RWxlbWVudElubmVyVGFnKHRoaXMsIGZvcm1hdCk7XG4gICAgY29uc3QgdGFnID0gb3V0ZXJUYWcgPT09IG51bGwgPyBpbm5lclRhZyA6IG91dGVyVGFnO1xuICAgIGNvbnN0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBsZXQgaW5uZXJET00gPSBkb207XG5cbiAgICBpZiAob3V0ZXJUYWcgIT09IG51bGwpIHtcbiAgICAgIGlubmVyRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpbm5lclRhZyk7XG4gICAgICBkb20uYXBwZW5kQ2hpbGQoaW5uZXJET00pO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHQgPSB0aGlzLl9fdGV4dDtcbiAgICBjcmVhdGVUZXh0SW5uZXJET00oaW5uZXJET00sIHRoaXMsIGlubmVyVGFnLCBmb3JtYXQsIHRleHQsIGNvbmZpZyk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLl9fc3R5bGU7XG5cbiAgICBpZiAoc3R5bGUgIT09ICcnKSB7XG4gICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xuICAgIH1cblxuICAgIHJldHVybiBkb207XG4gIH1cblxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgY29uc3QgbmV4dFRleHQgPSB0aGlzLl9fdGV4dDtcbiAgICBjb25zdCBwcmV2Rm9ybWF0ID0gcHJldk5vZGUuX19mb3JtYXQ7XG4gICAgY29uc3QgbmV4dEZvcm1hdCA9IHRoaXMuX19mb3JtYXQ7XG4gICAgY29uc3QgcHJldk91dGVyVGFnID0gZ2V0RWxlbWVudE91dGVyVGFnKHRoaXMsIHByZXZGb3JtYXQpO1xuICAgIGNvbnN0IG5leHRPdXRlclRhZyA9IGdldEVsZW1lbnRPdXRlclRhZyh0aGlzLCBuZXh0Rm9ybWF0KTtcbiAgICBjb25zdCBwcmV2SW5uZXJUYWcgPSBnZXRFbGVtZW50SW5uZXJUYWcodGhpcywgcHJldkZvcm1hdCk7XG4gICAgY29uc3QgbmV4dElubmVyVGFnID0gZ2V0RWxlbWVudElubmVyVGFnKHRoaXMsIG5leHRGb3JtYXQpO1xuICAgIGNvbnN0IHByZXZUYWcgPSBwcmV2T3V0ZXJUYWcgPT09IG51bGwgPyBwcmV2SW5uZXJUYWcgOiBwcmV2T3V0ZXJUYWc7XG4gICAgY29uc3QgbmV4dFRhZyA9IG5leHRPdXRlclRhZyA9PT0gbnVsbCA/IG5leHRJbm5lclRhZyA6IG5leHRPdXRlclRhZztcblxuICAgIGlmIChwcmV2VGFnICE9PSBuZXh0VGFnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJldk91dGVyVGFnID09PSBuZXh0T3V0ZXJUYWcgJiYgcHJldklubmVyVGFnICE9PSBuZXh0SW5uZXJUYWcpIHtcbiAgICAgIC8vIHNob3VsZCBhbHdheXMgYmUgYW4gZWxlbWVudFxuICAgICAgY29uc3QgcHJldklubmVyRE9NID0gZG9tLmZpcnN0Q2hpbGQ7XG5cbiAgICAgIGlmIChwcmV2SW5uZXJET00gPT0gbnVsbCkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYHVwZGF0ZURPTTogcHJldklubmVyRE9NIGlzIG51bGwgb3IgdW5kZWZpbmVkYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV4dElubmVyRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuZXh0SW5uZXJUYWcpO1xuICAgICAgY3JlYXRlVGV4dElubmVyRE9NKG5leHRJbm5lckRPTSwgdGhpcywgbmV4dElubmVyVGFnLCBuZXh0Rm9ybWF0LCBuZXh0VGV4dCwgY29uZmlnKTtcbiAgICAgIGRvbS5yZXBsYWNlQ2hpbGQobmV4dElubmVyRE9NLCBwcmV2SW5uZXJET00pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBpbm5lckRPTSA9IGRvbTtcblxuICAgIGlmIChuZXh0T3V0ZXJUYWcgIT09IG51bGwpIHtcbiAgICAgIGlmIChwcmV2T3V0ZXJUYWcgIT09IG51bGwpIHtcbiAgICAgICAgaW5uZXJET00gPSBkb20uZmlyc3RDaGlsZDtcblxuICAgICAgICBpZiAoaW5uZXJET00gPT0gbnVsbCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGB1cGRhdGVET006IGlubmVyRE9NIGlzIG51bGwgb3IgdW5kZWZpbmVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0VGV4dENvbnRlbnQobmV4dFRleHQsIGlubmVyRE9NLCB0aGlzKTtcbiAgICBjb25zdCB0aGVtZSA9IGNvbmZpZy50aGVtZTsgLy8gQXBwbHkgdGhlbWUgY2xhc3MgbmFtZXNcblxuICAgIGNvbnN0IHRleHRDbGFzc05hbWVzID0gdGhlbWUudGV4dDtcblxuICAgIGlmICh0ZXh0Q2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkICYmIHByZXZGb3JtYXQgIT09IG5leHRGb3JtYXQpIHtcbiAgICAgIHNldFRleHRUaGVtZUNsYXNzTmFtZXMobmV4dElubmVyVGFnLCBwcmV2Rm9ybWF0LCBuZXh0Rm9ybWF0LCBpbm5lckRPTSwgdGV4dENsYXNzTmFtZXMpO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZTdHlsZSA9IHByZXZOb2RlLl9fc3R5bGU7XG4gICAgY29uc3QgbmV4dFN0eWxlID0gdGhpcy5fX3N0eWxlO1xuXG4gICAgaWYgKHByZXZTdHlsZSAhPT0gbmV4dFN0eWxlKSB7XG4gICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG5leHRTdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnI3RleHQnOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dERPTU5vZGUsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIGI6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRCcmluZ0F0dGVudGlvblRvRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgY29kZTogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBlbTogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBpOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHM6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgc3BhbjogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFNwYW5FbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBzdHJvbmc6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgc3ViOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHN1cDogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICB1OiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIGNvbnN0IG5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoc2VyaWFsaXplZE5vZGUudGV4dCk7XG4gICAgbm9kZS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KTtcbiAgICBub2RlLnNldERldGFpbChzZXJpYWxpemVkTm9kZS5kZXRhaWwpO1xuICAgIG5vZGUuc2V0TW9kZShzZXJpYWxpemVkTm9kZS5tb2RlKTtcbiAgICBub2RlLnNldFN0eWxlKHNlcmlhbGl6ZWROb2RlLnN0eWxlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfSAvLyBUaGlzIGltcHJvdmVzIExleGljYWwncyBiYXNpYyB0ZXh0IG91dHB1dCBpbiBjb3B5K3Bhc3RlIHBsdXNcbiAgLy8gZm9yIGhlYWRsZXNzIG1vZGUgd2hlcmUgcGVvcGxlIG1pZ2h0IHVzZSBMZXhpY2FsIHRvIGdlbmVyYXRlXG4gIC8vIEhUTUwgY29udGVudCBhbmQgbm90IGhhdmUgdGhlIGFiaWxpdHkgdG8gdXNlIENTUyBjbGFzc2VzLlxuXG5cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGxldCB7XG4gICAgICBlbGVtZW50XG4gICAgfSA9IHN1cGVyLmV4cG9ydERPTShlZGl0b3IpOyAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byBwcm9wZXJseSBhZGQgc3VwcG9ydCBmb3IgbW9zdCBjbGllbnRzLFxuICAgIC8vIGV2ZW4gaWYgaXQncyBzZW1hbnRpY2FsbHkgaW5jb3JyZWN0IHRvIGhhdmUgdG8gcmVzb3J0IHRvIHVzaW5nXG4gICAgLy8gPGI+LCA8dT4sIDxzPiwgPGk+IGVsZW1lbnRzLlxuXG4gICAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmhhc0Zvcm1hdCgnYm9sZCcpKSB7XG4gICAgICAgIGVsZW1lbnQgPSB3cmFwRWxlbWVudFdpdGgoZWxlbWVudCwgJ2InKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaGFzRm9ybWF0KCdpdGFsaWMnKSkge1xuICAgICAgICBlbGVtZW50ID0gd3JhcEVsZW1lbnRXaXRoKGVsZW1lbnQsICdpJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc0Zvcm1hdCgnc3RyaWtldGhyb3VnaCcpKSB7XG4gICAgICAgIGVsZW1lbnQgPSB3cmFwRWxlbWVudFdpdGgoZWxlbWVudCwgJ3MnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaGFzRm9ybWF0KCd1bmRlcmxpbmUnKSkge1xuICAgICAgICBlbGVtZW50ID0gd3JhcEVsZW1lbnRXaXRoKGVsZW1lbnQsICd1Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGV0YWlsOiB0aGlzLmdldERldGFpbCgpLFxuICAgICAgZm9ybWF0OiB0aGlzLmdldEZvcm1hdCgpLFxuICAgICAgbW9kZTogdGhpcy5nZXRNb2RlKCksXG4gICAgICBzdHlsZTogdGhpcy5nZXRTdHlsZSgpLFxuICAgICAgdGV4dDogdGhpcy5nZXRUZXh0Q29udGVudCgpLFxuICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgdmVyc2lvbjogMVxuICAgIH07XG4gIH0gLy8gTXV0YXRvcnNcblxuXG4gIHNlbGVjdGlvblRyYW5zZm9ybShwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub2RlIGZvcm1hdCB0byB0aGUgcHJvdmlkZWQgVGV4dEZvcm1hdFR5cGUgb3IgMzItYml0IGludGVnZXIuIE5vdGUgdGhhdCB0aGUgVGV4dEZvcm1hdFR5cGVcbiAgICogdmVyc2lvbiBvZiB0aGUgYXJndW1lbnQgY2FuIG9ubHkgc3BlY2lmeSBvbmUgZm9ybWF0IGFuZCBkb2luZyBzbyB3aWxsIHJlbW92ZSBhbGwgb3RoZXIgZm9ybWF0cyB0aGF0XG4gICAqIG1heSBiZSBhcHBsaWVkIHRvIHRoZSBub2RlLiBGb3IgdG9nZ2xpbmcgYmVoYXZpb3IsIGNvbnNpZGVyIHVzaW5nIHtAbGluayBUZXh0Tm9kZS50b2dnbGVGb3JtYXR9XG4gICAqXG4gICAqIEBwYXJhbSBmb3JtYXQgLSBUZXh0Rm9ybWF0VHlwZSBvciAzMi1iaXQgaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIG5vZGUgZm9ybWF0LlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKiAvLyBUT0RPIDAuMTIgVGhpcyBzaG91bGQganVzdCBiZSBhIGBzdHJpbmdgLlxuICAgKi9cblxuXG4gIHNldEZvcm1hdChmb3JtYXQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19mb3JtYXQgPSB0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJyA/IFRFWFRfVFlQRV9UT19GT1JNQVRbZm9ybWF0XSA6IGZvcm1hdDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbm9kZSBkZXRhaWwgdG8gdGhlIHByb3ZpZGVkIFRleHREZXRhaWxUeXBlIG9yIDMyLWJpdCBpbnRlZ2VyLiBOb3RlIHRoYXQgdGhlIFRleHREZXRhaWxUeXBlXG4gICAqIHZlcnNpb24gb2YgdGhlIGFyZ3VtZW50IGNhbiBvbmx5IHNwZWNpZnkgb25lIGRldGFpbCB2YWx1ZSBhbmQgZG9pbmcgc28gd2lsbCByZW1vdmUgYWxsIG90aGVyIGRldGFpbCB2YWx1ZXMgdGhhdFxuICAgKiBtYXkgYmUgYXBwbGllZCB0byB0aGUgbm9kZS4gRm9yIHRvZ2dsaW5nIGJlaGF2aW9yLCBjb25zaWRlciB1c2luZyB7QGxpbmsgVGV4dE5vZGUudG9nZ2xlRGlyZWN0aW9ubGVzc31cbiAgICogb3Ige0BsaW5rIFRleHROb2RlLnRvZ2dsZXJVbm1lcmdlYWJsZX1cbiAgICpcbiAgICogQHBhcmFtIGRldGFpbCAtIFRleHREZXRhaWxUeXBlIG9yIDMyLWJpdCBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgbm9kZSBkZXRhaWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqIC8vIFRPRE8gMC4xMiBUaGlzIHNob3VsZCBqdXN0IGJlIGEgYHN0cmluZ2AuXG4gICAqL1xuXG5cbiAgc2V0RGV0YWlsKGRldGFpbCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2RldGFpbCA9IHR5cGVvZiBkZXRhaWwgPT09ICdzdHJpbmcnID8gREVUQUlMX1RZUEVfVE9fREVUQUlMW2RldGFpbF0gOiBkZXRhaWw7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5vZGUgc3R5bGUgdG8gdGhlIHByb3ZpZGVkIENTU1RleHQtbGlrZSBzdHJpbmcuIFNldCB0aGlzIHByb3BlcnR5IGFzIHlvdVxuICAgKiB3b3VsZCBhbiBIVE1MRWxlbWVudCBzdHlsZSBhdHRyaWJ1dGUgdG8gYXBwbHkgaW5saW5lIHN0eWxlcyB0byB0aGUgdW5kZXJseWluZyBET00gRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHN0eWxlIC0gQ1NTVGV4dCB0byBiZSBhcHBsaWVkIHRvIHRoZSB1bmRlcmx5aW5nIEhUTUxFbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cblxuXG4gIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fc3R5bGUgPSBzdHlsZTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICAvKipcbiAgICogQXBwbGllcyB0aGUgcHJvdmlkZWQgZm9ybWF0IHRvIHRoaXMgVGV4dE5vZGUgaWYgaXQncyBub3QgcHJlc2VudC4gUmVtb3ZlcyBpdCBpZiBpdCBpcyBwcmVzZW50LlxuICAgKiBQcmVmZXIgdXNpbmcgdGhpcyBtZXRob2QgdG8gdHVybiBzcGVjaWZpYyBmb3JtYXRzIG9uIGFuZCBvZmYuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gVGV4dEZvcm1hdFR5cGUgdG8gdG9nZ2xlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cblxuXG4gIHRvZ2dsZUZvcm1hdCh0eXBlKSB7XG4gICAgY29uc3QgZm9ybWF0RmxhZyA9IFRFWFRfVFlQRV9UT19GT1JNQVRbdHlwZV07XG4gICAgcmV0dXJuIHRoaXMuc2V0Rm9ybWF0KHRoaXMuZ2V0Rm9ybWF0KCkgXiBmb3JtYXRGbGFnKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgZGlyZWN0aW9ubGVzcyBkZXRhaWwgdmFsdWUgb2YgdGhlIG5vZGUuIFByZWZlciB1c2luZyB0aGlzIG1ldGhvZCBvdmVyIHNldERldGFpbC5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG5cblxuICB0b2dnbGVEaXJlY3Rpb25sZXNzKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2RldGFpbCBePSBJU19ESVJFQ1RJT05MRVNTO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSB1bm1lcmdlYWJsZSBkZXRhaWwgdmFsdWUgb2YgdGhlIG5vZGUuIFByZWZlciB1c2luZyB0aGlzIG1ldGhvZCBvdmVyIHNldERldGFpbC5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG5cblxuICB0b2dnbGVVbm1lcmdlYWJsZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19kZXRhaWwgXj0gSVNfVU5NRVJHRUFCTEU7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1vZGUgb2YgdGhlIG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqL1xuXG5cbiAgc2V0TW9kZSh0eXBlKSB7XG4gICAgY29uc3QgbW9kZSA9IFRFWFRfTU9ERV9UT19UWVBFW3R5cGVdO1xuXG4gICAgaWYgKHRoaXMuX19tb2RlID09PSBtb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19tb2RlID0gbW9kZTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gdGV4dCAtIHRoZSBzdHJpbmcgdG8gc2V0IGFzIHRoZSB0ZXh0IHZhbHVlIG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cblxuXG4gIHNldFRleHRDb250ZW50KHRleHQpIHtcbiAgICBpZiAodGhpcy5fX3RleHQgPT09IHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3RleHQgPSB0ZXh0O1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IExleGljYWwgc2VsZWN0aW9uIHRvIGJlIGEgUmFuZ2VTZWxlY3Rpb24gd2l0aCBhbmNob3IgYW5kIGZvY3VzIG9uIHRoaXMgVGV4dE5vZGUgYXQgdGhlIHByb3ZpZGVkIG9mZnNldHMuXG4gICAqXG4gICAqIEBwYXJhbSBfYW5jaG9yT2Zmc2V0IC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgU2VsZWN0aW9uIGFuY2hvciB3aWxsIGJlIHBsYWNlZC5cbiAgICogQHBhcmFtIF9mb2N1c09mZnNldCAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIFNlbGVjdGlvbiBmb2N1cyB3aWxsIGJlIHBsYWNlZC5cbiAgICpcbiAgICogQHJldHVybnMgdGhlIG5ldyBSYW5nZVNlbGVjdGlvbi5cbiAgICovXG5cblxuICBzZWxlY3QoX2FuY2hvck9mZnNldCwgX2ZvY3VzT2Zmc2V0KSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgbGV0IGFuY2hvck9mZnNldCA9IF9hbmNob3JPZmZzZXQ7XG4gICAgbGV0IGZvY3VzT2Zmc2V0ID0gX2ZvY3VzT2Zmc2V0O1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IGtleSA9IHRoaXMuX19rZXk7XG5cbiAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBsYXN0T2Zmc2V0ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAgIGlmIChhbmNob3JPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbmNob3JPZmZzZXQgPSBsYXN0T2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9jdXNPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb2N1c09mZnNldCA9IGxhc3RPZmZzZXQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuY2hvck9mZnNldCA9IDA7XG4gICAgICBmb2N1c09mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gaW50ZXJuYWxNYWtlUmFuZ2VTZWxlY3Rpb24oa2V5LCBhbmNob3JPZmZzZXQsIGtleSwgZm9jdXNPZmZzZXQsICd0ZXh0JywgJ3RleHQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29tcG9zaXRpb25LZXkgPSAkZ2V0Q29tcG9zaXRpb25LZXkoKTtcblxuICAgICAgaWYgKGNvbXBvc2l0aW9uS2V5ID09PSBzZWxlY3Rpb24uYW5jaG9yLmtleSB8fCBjb21wb3NpdGlvbktleSA9PT0gc2VsZWN0aW9uLmZvY3VzLmtleSkge1xuICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkoa2V5KTtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2UodGhpcywgYW5jaG9yT2Zmc2V0LCB0aGlzLCBmb2N1c09mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyB0aGUgcHJvdmlkZWQgdGV4dCBpbnRvIHRoaXMgVGV4dE5vZGUgYXQgdGhlIHByb3ZpZGVkIG9mZnNldCwgZGVsZXRpbmcgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAqIHNwZWNpZmllZC4gQ2FuIG9wdGlvbmFsbHkgY2FsY3VsYXRlIGEgbmV3IHNlbGVjdGlvbiBhZnRlciB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKlxuICAgKiBAcGFyYW0gb2Zmc2V0IC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgc3BsaWNlIG9wZXJhdGlvbiBzaG91bGQgYmVnaW4uXG4gICAqIEBwYXJhbSBkZWxDb3VudCAtIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBkZWxldGUsIHN0YXJ0aW5nIGZyb20gdGhlIG9mZnNldC5cbiAgICogQHBhcmFtIG5ld1RleHQgLSB0aGUgdGV4dCB0byBpbnNlcnQgaW50byB0aGUgVGV4dE5vZGUgYXQgdGhlIG9mZnNldC5cbiAgICogQHBhcmFtIG1vdmVTZWxlY3Rpb24gLSBvcHRpb25hbCwgd2hldGhlciBvciBub3QgdG8gbW92ZSBzZWxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGUgaW5zZXJ0ZWQgc3Vic3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cblxuXG4gIHNwbGljZVRleHQob2Zmc2V0LCBkZWxDb3VudCwgbmV3VGV4dCwgbW92ZVNlbGVjdGlvbikge1xuICAgIGNvbnN0IHdyaXRhYmxlU2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCB0ZXh0ID0gd3JpdGFibGVTZWxmLl9fdGV4dDtcbiAgICBjb25zdCBoYW5kbGVkVGV4dExlbmd0aCA9IG5ld1RleHQubGVuZ3RoO1xuICAgIGxldCBpbmRleCA9IG9mZnNldDtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIGluZGV4ID0gaGFuZGxlZFRleHRMZW5ndGggKyBpbmRleDtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKG1vdmVTZWxlY3Rpb24gJiYgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gb2Zmc2V0ICsgaGFuZGxlZFRleHRMZW5ndGg7XG4gICAgICBzZWxlY3Rpb24uc2V0VGV4dE5vZGVSYW5nZSh3cml0YWJsZVNlbGYsIG5ld09mZnNldCwgd3JpdGFibGVTZWxmLCBuZXdPZmZzZXQpO1xuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZWRUZXh0ID0gdGV4dC5zbGljZSgwLCBpbmRleCkgKyBuZXdUZXh0ICsgdGV4dC5zbGljZShpbmRleCArIGRlbENvdW50KTtcbiAgICB3cml0YWJsZVNlbGYuX190ZXh0ID0gdXBkYXRlZFRleHQ7XG4gICAgcmV0dXJuIHdyaXRhYmxlU2VsZjtcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGVuIGJ5IFRleHROb2RlIHN1YmNsYXNzZXMgdG8gY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgdGhvc2Ugbm9kZXNcbiAgICogd2hlbiBhIHVzZXIgZXZlbnQgd291bGQgY2F1c2UgdGV4dCB0byBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlbSBpbiB0aGUgZWRpdG9yLiBJZiB0cnVlLCBMZXhpY2FsIHdpbGwgYXR0ZW1wdFxuICAgKiB0byBpbnNlcnQgdGV4dCBpbnRvIHRoaXMgbm9kZS4gSWYgZmFsc2UsIGl0IHdpbGwgaW5zZXJ0IHRoZSB0ZXh0IGluIGEgbmV3IHNpYmxpbmcgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0ZXh0IGNhbiBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIG5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBjYW5JbnNlcnRUZXh0QmVmb3JlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZSBvdmVycmlkZW4gYnkgVGV4dE5vZGUgc3ViY2xhc3NlcyB0byBjb250cm9sIHRoZSBiZWhhdmlvciBvZiB0aG9zZSBub2Rlc1xuICAgKiB3aGVuIGEgdXNlciBldmVudCB3b3VsZCBjYXVzZSB0ZXh0IHRvIGJlIGluc2VydGVkIGFmdGVyIHRoZW0gaW4gdGhlIGVkaXRvci4gSWYgdHJ1ZSwgTGV4aWNhbCB3aWxsIGF0dGVtcHRcbiAgICogdG8gaW5zZXJ0IHRleHQgaW50byB0aGlzIG5vZGUuIElmIGZhbHNlLCBpdCB3aWxsIGluc2VydCB0aGUgdGV4dCBpbiBhIG5ldyBzaWJsaW5nIG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGV4dCBjYW4gYmUgaW5zZXJ0ZWQgYWZ0ZXIgdGhlIG5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFNwbGl0cyB0aGlzIFRleHROb2RlIGF0IHRoZSBwcm92aWRlZCBjaGFyYWN0ZXIgb2Zmc2V0cywgZm9ybWluZyBuZXcgVGV4dE5vZGVzIGZyb20gdGhlIHN1YnN0cmluZ3NcbiAgICogZm9ybWVkIGJ5IHRoZSBzcGxpdCwgYW5kIGluc2VydGluZyB0aG9zZSBuZXcgVGV4dE5vZGVzIGludG8gdGhlIGVkaXRvciwgcmVwbGFjaW5nIHRoZSBvbmUgdGhhdCB3YXMgc3BsaXQuXG4gICAqXG4gICAqIEBwYXJhbSBzcGxpdE9mZnNldHMgLSByZXN0IHBhcmFtIG9mIHRoZSB0ZXh0IGNvbnRlbnQgY2hhcmFjdGVyIG9mZnNldHMgYXQgd2hpY2ggdGhpcyBub2RlIHNob3VsZCBiZSBzcGxpdC5cbiAgICpcbiAgICogQHJldHVybnMgYW4gQXJyYXkgY29udGFpbmluZyB0aGUgbmV3bHktY3JlYXRlZCBUZXh0Tm9kZXMuXG4gICAqL1xuXG5cbiAgc3BsaXRUZXh0KC4uLnNwbGl0T2Zmc2V0cykge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IHRleHRDb250ZW50ID0gc2VsZi5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IGtleSA9IHNlbGYuX19rZXk7XG4gICAgY29uc3QgY29tcG9zaXRpb25LZXkgPSAkZ2V0Q29tcG9zaXRpb25LZXkoKTtcbiAgICBjb25zdCBvZmZzZXRzU2V0ID0gbmV3IFNldChzcGxpdE9mZnNldHMpO1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgY29uc3QgdGV4dExlbmd0aCA9IHRleHRDb250ZW50Lmxlbmd0aDtcbiAgICBsZXQgc3RyaW5nID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0cmluZyAhPT0gJycgJiYgb2Zmc2V0c1NldC5oYXMoaSkpIHtcbiAgICAgICAgcGFydHMucHVzaChzdHJpbmcpO1xuICAgICAgICBzdHJpbmcgPSAnJztcbiAgICAgIH1cblxuICAgICAgc3RyaW5nICs9IHRleHRDb250ZW50W2ldO1xuICAgIH1cblxuICAgIGlmIChzdHJpbmcgIT09ICcnKSB7XG4gICAgICBwYXJ0cy5wdXNoKHN0cmluZyk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFydHNMZW5ndGggPSBwYXJ0cy5sZW5ndGg7XG5cbiAgICBpZiAocGFydHNMZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKHBhcnRzWzBdID09PSB0ZXh0Q29udGVudCkge1xuICAgICAgcmV0dXJuIFtzZWxmXTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdFBhcnQgPSBwYXJ0c1swXTtcbiAgICBjb25zdCBwYXJlbnQgPSBzZWxmLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBsZXQgd3JpdGFibGVOb2RlO1xuICAgIGNvbnN0IGZvcm1hdCA9IHNlbGYuZ2V0Rm9ybWF0KCk7XG4gICAgY29uc3Qgc3R5bGUgPSBzZWxmLmdldFN0eWxlKCk7XG4gICAgY29uc3QgZGV0YWlsID0gc2VsZi5fX2RldGFpbDtcbiAgICBsZXQgaGFzUmVwbGFjZWRTZWxmID0gZmFsc2U7XG5cbiAgICBpZiAoc2VsZi5pc1NlZ21lbnRlZCgpKSB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgVGV4dE5vZGVcbiAgICAgIHdyaXRhYmxlTm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShmaXJzdFBhcnQpO1xuICAgICAgd3JpdGFibGVOb2RlLl9fZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgd3JpdGFibGVOb2RlLl9fc3R5bGUgPSBzdHlsZTtcbiAgICAgIHdyaXRhYmxlTm9kZS5fX2RldGFpbCA9IGRldGFpbDtcbiAgICAgIGhhc1JlcGxhY2VkU2VsZiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciB0aGUgZmlyc3QgcGFydCwgdXBkYXRlIHRoZSBleGlzdGluZyBub2RlXG4gICAgICB3cml0YWJsZU5vZGUgPSBzZWxmLmdldFdyaXRhYmxlKCk7XG4gICAgICB3cml0YWJsZU5vZGUuX190ZXh0ID0gZmlyc3RQYXJ0O1xuICAgIH0gLy8gSGFuZGxlIHNlbGVjdGlvblxuXG5cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7IC8vIFRoZW4gaGFuZGxlIGFsbCBvdGhlciBwYXJ0c1xuXG4gICAgY29uc3Qgc3BsaXROb2RlcyA9IFt3cml0YWJsZU5vZGVdO1xuICAgIGxldCB0ZXh0U2l6ZSA9IGZpcnN0UGFydC5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGNvbnN0IHBhcnRTaXplID0gcGFydC5sZW5ndGg7XG4gICAgICBjb25zdCBzaWJsaW5nID0gJGNyZWF0ZVRleHROb2RlKHBhcnQpLmdldFdyaXRhYmxlKCk7XG4gICAgICBzaWJsaW5nLl9fZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgc2libGluZy5fX3N0eWxlID0gc3R5bGU7XG4gICAgICBzaWJsaW5nLl9fZGV0YWlsID0gZGV0YWlsO1xuICAgICAgY29uc3Qgc2libGluZ0tleSA9IHNpYmxpbmcuX19rZXk7XG4gICAgICBjb25zdCBuZXh0VGV4dFNpemUgPSB0ZXh0U2l6ZSArIHBhcnRTaXplO1xuXG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcblxuICAgICAgICBpZiAoYW5jaG9yLmtleSA9PT0ga2V5ICYmIGFuY2hvci50eXBlID09PSAndGV4dCcgJiYgYW5jaG9yLm9mZnNldCA+IHRleHRTaXplICYmIGFuY2hvci5vZmZzZXQgPD0gbmV4dFRleHRTaXplKSB7XG4gICAgICAgICAgYW5jaG9yLmtleSA9IHNpYmxpbmdLZXk7XG4gICAgICAgICAgYW5jaG9yLm9mZnNldCAtPSB0ZXh0U2l6ZTtcbiAgICAgICAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvY3VzLmtleSA9PT0ga2V5ICYmIGZvY3VzLnR5cGUgPT09ICd0ZXh0JyAmJiBmb2N1cy5vZmZzZXQgPiB0ZXh0U2l6ZSAmJiBmb2N1cy5vZmZzZXQgPD0gbmV4dFRleHRTaXplKSB7XG4gICAgICAgICAgZm9jdXMua2V5ID0gc2libGluZ0tleTtcbiAgICAgICAgICBmb2N1cy5vZmZzZXQgLT0gdGV4dFNpemU7XG4gICAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY29tcG9zaXRpb25LZXkgPT09IGtleSkge1xuICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkoc2libGluZ0tleSk7XG4gICAgICB9XG5cbiAgICAgIHRleHRTaXplID0gbmV4dFRleHRTaXplO1xuICAgICAgc3BsaXROb2Rlcy5wdXNoKHNpYmxpbmcpO1xuICAgIH0gLy8gSW5zZXJ0IHRoZSBub2RlcyBpbnRvIHRoZSBwYXJlbnQncyBjaGlsZHJlblxuXG5cbiAgICBpbnRlcm5hbE1hcmtTaWJsaW5nc0FzRGlydHkodGhpcyk7XG4gICAgY29uc3Qgd3JpdGFibGVQYXJlbnQgPSBwYXJlbnQuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBpbnNlcnRpb25JbmRleCA9IHRoaXMuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcblxuICAgIGlmIChoYXNSZXBsYWNlZFNlbGYpIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50LnNwbGljZShpbnNlcnRpb25JbmRleCwgMCwgc3BsaXROb2Rlcyk7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cml0YWJsZVBhcmVudC5zcGxpY2UoaW5zZXJ0aW9uSW5kZXgsIDEsIHNwbGl0Tm9kZXMpO1xuICAgIH1cblxuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAkdXBkYXRlRWxlbWVudFNlbGVjdGlvbk9uQ3JlYXRlRGVsZXRlTm9kZShzZWxlY3Rpb24sIHBhcmVudCwgaW5zZXJ0aW9uSW5kZXgsIHBhcnRzTGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwbGl0Tm9kZXM7XG4gIH1cbiAgLyoqXG4gICAqIE1lcmdlcyB0aGUgdGFyZ2V0IFRleHROb2RlIGludG8gdGhpcyBUZXh0Tm9kZSwgcmVtb3ZpbmcgdGhlIHRhcmdldCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0IC0gdGhlIFRleHROb2RlIHRvIG1lcmdlIGludG8gdGhpcyBvbmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqL1xuXG5cbiAgbWVyZ2VXaXRoU2libGluZyh0YXJnZXQpIHtcbiAgICBjb25zdCBpc0JlZm9yZSA9IHRhcmdldCA9PT0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgIGlmICghaXNCZWZvcmUgJiYgdGFyZ2V0ICE9PSB0aGlzLmdldE5leHRTaWJsaW5nKCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYG1lcmdlV2l0aFNpYmxpbmc6IHNpYmxpbmcgbXVzdCBiZSBhIHByZXZpb3VzIG9yIG5leHQgc2libGluZ2ApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGtleSA9IHRoaXMuX19rZXk7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gdGFyZ2V0Ll9fa2V5O1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLl9fdGV4dDtcbiAgICBjb25zdCB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgY29uc3QgY29tcG9zaXRpb25LZXkgPSAkZ2V0Q29tcG9zaXRpb25LZXkoKTtcblxuICAgIGlmIChjb21wb3NpdGlvbktleSA9PT0gdGFyZ2V0S2V5KSB7XG4gICAgICAkc2V0Q29tcG9zaXRpb25LZXkoa2V5KTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuXG4gICAgICBpZiAoYW5jaG9yICE9PSBudWxsICYmIGFuY2hvci5rZXkgPT09IHRhcmdldEtleSkge1xuICAgICAgICBhZGp1c3RQb2ludE9mZnNldEZvck1lcmdlZFNpYmxpbmcoYW5jaG9yLCBpc0JlZm9yZSwga2V5LCB0YXJnZXQsIHRleHRMZW5ndGgpO1xuICAgICAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9jdXMgIT09IG51bGwgJiYgZm9jdXMua2V5ID09PSB0YXJnZXRLZXkpIHtcbiAgICAgICAgYWRqdXN0UG9pbnRPZmZzZXRGb3JNZXJnZWRTaWJsaW5nKGZvY3VzLCBpc0JlZm9yZSwga2V5LCB0YXJnZXQsIHRleHRMZW5ndGgpO1xuICAgICAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldFRleHQgPSB0YXJnZXQuX190ZXh0O1xuICAgIGNvbnN0IG5ld1RleHQgPSBpc0JlZm9yZSA/IHRhcmdldFRleHQgKyB0ZXh0IDogdGV4dCArIHRhcmdldFRleHQ7XG4gICAgdGhpcy5zZXRUZXh0Q29udGVudChuZXdUZXh0KTtcbiAgICBjb25zdCB3cml0YWJsZVNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgIHJldHVybiB3cml0YWJsZVNlbGY7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRlbiBieSBUZXh0Tm9kZSBzdWJjbGFzc2VzIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yIG9mIHRob3NlIG5vZGVzXG4gICAqIHdoZW4gdXNlZCB3aXRoIHRoZSByZWdpc3RlckxleGljYWxUZXh0RW50aXR5IGZ1bmN0aW9uLiBJZiB5b3UncmUgdXNpbmcgcmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eSwgdGhlXG4gICAqIG5vZGUgY2xhc3MgdGhhdCB5b3UgY3JlYXRlIGFuZCByZXBsYWNlIG1hdGNoZWQgdGV4dCB3aXRoIHNob3VsZCByZXR1cm4gdHJ1ZSBmcm9tIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIHRvIGJlIHRyZWF0ZWQgYXMgYSBcInRleHQgZW50aXR5XCIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBpc1RleHRFbnRpdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gY29udmVydFNwYW5FbGVtZW50KGRvbU5vZGUpIHtcbiAgLy8gZG9tTm9kZSBpcyBhIDxzcGFuPiBzaW5jZSB3ZSBtYXRjaGVkIGl0IGJ5IG5vZGVOYW1lXG4gIGNvbnN0IHNwYW4gPSBkb21Ob2RlOyAvLyBHb29nbGUgRG9jcyB1c2VzIHNwYW4gdGFncyArIGZvbnQtd2VpZ2h0IGZvciBib2xkIHRleHRcblxuICBjb25zdCBoYXNCb2xkRm9udFdlaWdodCA9IHNwYW4uc3R5bGUuZm9udFdlaWdodCA9PT0gJzcwMCc7IC8vIEdvb2dsZSBEb2NzIHVzZXMgc3BhbiB0YWdzICsgdGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2ggZm9yIHN0cmlrZXRocm91Z2ggdGV4dFxuXG4gIGNvbnN0IGhhc0xpbmV0aHJvdWdoVGV4dERlY29yYXRpb24gPSBzcGFuLnN0eWxlLnRleHREZWNvcmF0aW9uID09PSAnbGluZS10aHJvdWdoJzsgLy8gR29vZ2xlIERvY3MgdXNlcyBzcGFuIHRhZ3MgKyBmb250LXN0eWxlIGZvciBpdGFsaWMgdGV4dFxuXG4gIGNvbnN0IGhhc0l0YWxpY0ZvbnRTdHlsZSA9IHNwYW4uc3R5bGUuZm9udFN0eWxlID09PSAnaXRhbGljJzsgLy8gR29vZ2xlIERvY3MgdXNlcyBzcGFuIHRhZ3MgKyB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBmb3IgdW5kZXJsaW5lIHRleHRcblxuICBjb25zdCBoYXNVbmRlcmxpbmVUZXh0RGVjb3JhdGlvbiA9IHNwYW4uc3R5bGUudGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnOyAvLyBHb29nbGUgRG9jcyB1c2VzIHNwYW4gdGFncyArIHZlcnRpY2FsLWFsaWduIHRvIHNwZWNpZnkgc3Vic2NyaXB0IGFuZCBzdXBlcnNjcmlwdFxuXG4gIGNvbnN0IHZlcnRpY2FsQWxpZ24gPSBzcGFuLnN0eWxlLnZlcnRpY2FsQWxpZ247XG4gIHJldHVybiB7XG4gICAgZm9yQ2hpbGQ6IGxleGljYWxOb2RlID0+IHtcbiAgICAgIGlmICghJGlzVGV4dE5vZGUobGV4aWNhbE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBsZXhpY2FsTm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0JvbGRGb250V2VpZ2h0KSB7XG4gICAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnYm9sZCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzTGluZXRocm91Z2hUZXh0RGVjb3JhdGlvbikge1xuICAgICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoJ3N0cmlrZXRocm91Z2gnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0l0YWxpY0ZvbnRTdHlsZSkge1xuICAgICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoJ2l0YWxpYycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzVW5kZXJsaW5lVGV4dERlY29yYXRpb24pIHtcbiAgICAgICAgbGV4aWNhbE5vZGUudG9nZ2xlRm9ybWF0KCd1bmRlcmxpbmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZlcnRpY2FsQWxpZ24gPT09ICdzdWInKSB7XG4gICAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnc3Vic2NyaXB0Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJ0aWNhbEFsaWduID09PSAnc3VwZXInKSB7XG4gICAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnc3VwZXJzY3JpcHQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxleGljYWxOb2RlO1xuICAgIH0sXG4gICAgbm9kZTogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0QnJpbmdBdHRlbnRpb25Ub0VsZW1lbnQoZG9tTm9kZSkge1xuICAvLyBkb21Ob2RlIGlzIGEgPGI+IHNpbmNlIHdlIG1hdGNoZWQgaXQgYnkgbm9kZU5hbWVcbiAgY29uc3QgYiA9IGRvbU5vZGU7IC8vIEdvb2dsZSBEb2NzIHdyYXBzIGFsbCBjb3BpZWQgSFRNTCBpbiBhIDxiPiB3aXRoIGZvbnQtd2VpZ2h0IG5vcm1hbFxuXG4gIGNvbnN0IGhhc05vcm1hbEZvbnRXZWlnaHQgPSBiLnN0eWxlLmZvbnRXZWlnaHQgPT09ICdub3JtYWwnO1xuICByZXR1cm4ge1xuICAgIGZvckNoaWxkOiBsZXhpY2FsTm9kZSA9PiB7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUobGV4aWNhbE5vZGUpICYmICFoYXNOb3JtYWxGb250V2VpZ2h0KSB7XG4gICAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnYm9sZCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGV4aWNhbE5vZGU7XG4gICAgfSxcbiAgICBub2RlOiBudWxsXG4gIH07XG59XG5cbmNvbnN0IHByZVBhcmVudENhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gaXNOb2RlUHJlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09ICdQUkUnIHx8IG5vZGUubm9kZVR5cGUgPT09IERPTV9FTEVNRU5UX1RZUEUgJiYgbm9kZS5zdHlsZS53aGl0ZVNwYWNlLnN0YXJ0c1dpdGgoJ3ByZScpO1xufVxuXG5mdW5jdGlvbiBmaW5kUGFyZW50UHJlRE9NTm9kZShub2RlKSB7XG4gIGxldCBjYWNoZWQ7XG4gIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIGNvbnN0IHZpc2l0ZWQgPSBbbm9kZV07XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiAoY2FjaGVkID0gcHJlUGFyZW50Q2FjaGUuZ2V0KHBhcmVudCkpID09PSB1bmRlZmluZWQgJiYgIWlzTm9kZVByZShwYXJlbnQpKSB7XG4gICAgdmlzaXRlZC5wdXNoKHBhcmVudCk7XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICBjb25zdCByZXN1bHROb2RlID0gY2FjaGVkID09PSB1bmRlZmluZWQgPyBwYXJlbnQgOiBjYWNoZWQ7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJlUGFyZW50Q2FjaGUuc2V0KHZpc2l0ZWRbaV0sIHJlc3VsdE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdE5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUZXh0RE9NTm9kZShkb21Ob2RlKSB7XG4gIGNvbnN0IGRvbU5vZGVfID0gZG9tTm9kZTtcbiAgY29uc3QgcGFyZW50RG9tID0gZG9tTm9kZS5wYXJlbnRFbGVtZW50O1xuXG4gIGlmICghKHBhcmVudERvbSAhPT0gbnVsbCkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgcGFyZW50RWxlbWVudCBvZiBUZXh0IG5vdCB0byBiZSBudWxsYCk7XG4gIH1cblxuICBsZXQgdGV4dENvbnRlbnQgPSBkb21Ob2RlXy50ZXh0Q29udGVudCB8fCAnJzsgLy8gTm8gY29sbGFwc2UgYW5kIHByZXNlcnZlIHNlZ21lbnQgYnJlYWsgZm9yIHByZSwgcHJlLXdyYXAgYW5kIHByZS1saW5lXG5cbiAgaWYgKGZpbmRQYXJlbnRQcmVET01Ob2RlKGRvbU5vZGVfKSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHBhcnRzID0gdGV4dENvbnRlbnQuc3BsaXQoLyhcXHI/XFxufFxcdCkvKTtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IHBhcnRzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgaWYgKHBhcnQgPT09ICdcXG4nIHx8IHBhcnQgPT09ICdcXHJcXG4nKSB7XG4gICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZUxpbmVCcmVha05vZGUoKSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICdcXHQnKSB7XG4gICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZVRhYk5vZGUoKSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnQgIT09ICcnKSB7XG4gICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZVRleHROb2RlKHBhcnQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbm9kZXNcbiAgICB9O1xuICB9XG5cbiAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5yZXBsYWNlKC9cXHI/XFxufFxcdC9nbSwgJyAnKS5yZXBsYWNlKCdcXHInLCAnJykucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuXG4gIGlmICh0ZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gIH1cblxuICBpZiAodGV4dENvbnRlbnRbMF0gPT09ICcgJykge1xuICAgIC8vIFRyYXZlcnNlIGJhY2t3YXJkIHdoaWxlIGluIHRoZSBzYW1lIGxpbmUuIElmIGNvbnRlbnQgY29udGFpbnMgbmV3IGxpbmUgb3IgdGFiIC0+IHBvbnRlbnRpYWxcbiAgICAvLyBkZWxldGUsIG90aGVyIGVsZW1lbnRzIGNhbiBib3Jyb3cgZnJvbSB0aGlzIG9uZS4gRGVsZXRpb24gZGVwZW5kcyBvbiB3aGV0aGVyIGl0J3MgYWxzbyB0aGVcbiAgICAvLyBsYXN0IHNwYWNlIChzZWUgbmV4dCBjb25kaXRpb246IHRleHRDb250ZW50W3RleHRDb250ZW50Lmxlbmd0aCAtIDFdID09PSAnICcpKVxuICAgIGxldCBwcmV2aW91c1RleHQgPSBkb21Ob2RlXztcbiAgICBsZXQgaXNTdGFydE9mTGluZSA9IHRydWU7XG5cbiAgICB3aGlsZSAocHJldmlvdXNUZXh0ICE9PSBudWxsICYmIChwcmV2aW91c1RleHQgPSBmaW5kVGV4dEluTGluZShwcmV2aW91c1RleHQsIGZhbHNlKSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzVGV4dENvbnRlbnQgPSBwcmV2aW91c1RleHQudGV4dENvbnRlbnQgfHwgJyc7XG5cbiAgICAgIGlmIChwcmV2aW91c1RleHRDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHByZXZpb3VzVGV4dENvbnRlbnQubWF0Y2goLyg/Olxcc3xcXHI/XFxufFxcdCkkLykpIHtcbiAgICAgICAgICB0ZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNTdGFydE9mTGluZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNTdGFydE9mTGluZSkge1xuICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgxKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGV4dENvbnRlbnRbdGV4dENvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICcgJykge1xuICAgIC8vIFRyYXZlcnNlIGZvcndhcmQgd2hpbGUgaW4gdGhlIHNhbWUgbGluZSwgcHJlc2VydmUgaWYgbmV4dCBpbmxpbmUgd2lsbCByZXF1aXJlIGEgc3BhY2VcbiAgICBsZXQgbmV4dFRleHQgPSBkb21Ob2RlXztcbiAgICBsZXQgaXNFbmRPZkxpbmUgPSB0cnVlO1xuXG4gICAgd2hpbGUgKG5leHRUZXh0ICE9PSBudWxsICYmIChuZXh0VGV4dCA9IGZpbmRUZXh0SW5MaW5lKG5leHRUZXh0LCB0cnVlKSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5leHRUZXh0Q29udGVudCA9IChuZXh0VGV4dC50ZXh0Q29udGVudCB8fCAnJykucmVwbGFjZSgvXltcXHN8XFxyP1xcbnxcXHRdKy8sICcnKTtcblxuICAgICAgaWYgKG5leHRUZXh0Q29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlzRW5kT2ZMaW5lID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0VuZE9mTGluZSkge1xuICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgwLCB0ZXh0Q29udGVudC5sZW5ndGggLSAxKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGV4dENvbnRlbnQgPT09ICcnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlVGV4dE5vZGUodGV4dENvbnRlbnQpXG4gIH07XG59XG5cbmNvbnN0IGlubGluZVBhcmVudHMgPSBuZXcgUmVnRXhwKC9eKGF8YWJicnxhY3JvbnltfGJ8Y2l0ZXxjb2RlfGRlbHxlbXxpfGluc3xrYmR8bGFiZWx8b3V0cHV0fHF8cnVieXxzfHNhbXB8c3BhbnxzdHJvbmd8c3VifHN1cHx0aW1lfHV8dHR8dmFyKSQvLCAnaScpO1xuXG5mdW5jdGlvbiBmaW5kVGV4dEluTGluZSh0ZXh0LCBmb3J3YXJkKSB7XG4gIGxldCBub2RlID0gdGV4dDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbGV0IHNpYmxpbmc7XG5cbiAgICB3aGlsZSAoKHNpYmxpbmcgPSBmb3J3YXJkID8gbm9kZS5uZXh0U2libGluZyA6IG5vZGUucHJldmlvdXNTaWJsaW5nKSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcblxuICAgICAgaWYgKHBhcmVudEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBwYXJlbnRFbGVtZW50O1xuICAgIH1cblxuICAgIG5vZGUgPSBzaWJsaW5nO1xuXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IERPTV9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIGNvbnN0IGRpc3BsYXkgPSBub2RlLnN0eWxlLmRpc3BsYXk7XG5cbiAgICAgIGlmIChkaXNwbGF5ID09PSAnJyAmJiBub2RlLm5vZGVOYW1lLm1hdGNoKGlubGluZVBhcmVudHMpID09PSBudWxsIHx8IGRpc3BsYXkgIT09ICcnICYmICFkaXNwbGF5LnN0YXJ0c1dpdGgoJ2lubGluZScpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBkZXNjZW5kYW50ID0gbm9kZTtcblxuICAgIHdoaWxlICgoZGVzY2VuZGFudCA9IGZvcndhcmQgPyBub2RlLmZpcnN0Q2hpbGQgOiBub2RlLmxhc3RDaGlsZCkgIT09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBkZXNjZW5kYW50O1xuICAgIH1cblxuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBET01fVEVYVF9UWVBFKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBub2RlTmFtZVRvVGV4dEZvcm1hdCA9IHtcbiAgY29kZTogJ2NvZGUnLFxuICBlbTogJ2l0YWxpYycsXG4gIGk6ICdpdGFsaWMnLFxuICBzOiAnc3RyaWtldGhyb3VnaCcsXG4gIHN0cm9uZzogJ2JvbGQnLFxuICBzdWI6ICdzdWJzY3JpcHQnLFxuICBzdXA6ICdzdXBlcnNjcmlwdCcsXG4gIHU6ICd1bmRlcmxpbmUnXG59O1xuXG5mdW5jdGlvbiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQoZG9tTm9kZSkge1xuICBjb25zdCBmb3JtYXQgPSBub2RlTmFtZVRvVGV4dEZvcm1hdFtkb21Ob2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO1xuXG4gIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZm9yQ2hpbGQ6IGxleGljYWxOb2RlID0+IHtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShsZXhpY2FsTm9kZSkgJiYgIWxleGljYWxOb2RlLmhhc0Zvcm1hdChmb3JtYXQpKSB7XG4gICAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdChmb3JtYXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGV4aWNhbE5vZGU7XG4gICAgfSxcbiAgICBub2RlOiBudWxsXG4gIH07XG59XG5cbmZ1bmN0aW9uICRjcmVhdGVUZXh0Tm9kZSh0ZXh0ID0gJycpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgVGV4dE5vZGUodGV4dCkpO1xufVxuZnVuY3Rpb24gJGlzVGV4dE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRleHROb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBUYWJOb2RlIGV4dGVuZHMgVGV4dE5vZGUge1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3RhYic7XG4gIH1cblxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgVGFiTm9kZShub2RlLl9fa2V5KTsgLy8gVGFiTm9kZSBfX3RleHQgY2FuIGJlIGVpdGhlciAnXFx0JyBvciAnJy4gaW5zZXJ0VGV4dCB3aWxsIHJlbW92ZSB0aGUgZW1wdHkgTm9kZVxuXG4gICAgbmV3Tm9kZS5fX3RleHQgPSBub2RlLl9fdGV4dDtcbiAgICBuZXdOb2RlLl9fZm9ybWF0ID0gbm9kZS5fX2Zvcm1hdDtcbiAgICBuZXdOb2RlLl9fc3R5bGUgPSBub2RlLl9fc3R5bGU7XG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcignXFx0Jywga2V5KTtcbiAgICB0aGlzLl9fZGV0YWlsID0gSVNfVU5NRVJHRUFCTEU7XG4gIH1cblxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZFRhYk5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZVRhYk5vZGUoKTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkVGFiTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0U3R5bGUoc2VyaWFsaXplZFRhYk5vZGUuc3R5bGUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4geyAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICB0eXBlOiAndGFiJyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG5cbiAgc2V0VGV4dENvbnRlbnQoX3RleHQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgVGFiTm9kZSBkb2VzIG5vdCBzdXBwb3J0IHNldFRleHRDb250ZW50YCk7XG4gICAgfVxuICB9XG5cbiAgc2V0RGV0YWlsKF9kZXRhaWwpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgVGFiTm9kZSBkb2VzIG5vdCBzdXBwb3J0IHNldERldGFpbGApO1xuICAgIH1cbiAgfVxuXG4gIHNldE1vZGUoX3R5cGUpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgVGFiTm9kZSBkb2VzIG5vdCBzdXBwb3J0IHNldE1vZGVgKTtcbiAgICB9XG4gIH1cblxuICBjYW5JbnNlcnRUZXh0QmVmb3JlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNhbkluc2VydFRleHRBZnRlcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxufVxuZnVuY3Rpb24gJGNyZWF0ZVRhYk5vZGUoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRhYk5vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNUYWJOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUYWJOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jbGFzcyBQb2ludCB7XG4gIGNvbnN0cnVjdG9yKGtleSwgb2Zmc2V0LCB0eXBlKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgaXMocG9pbnQpIHtcbiAgICByZXR1cm4gdGhpcy5rZXkgPT09IHBvaW50LmtleSAmJiB0aGlzLm9mZnNldCA9PT0gcG9pbnQub2Zmc2V0ICYmIHRoaXMudHlwZSA9PT0gcG9pbnQudHlwZTtcbiAgfVxuXG4gIGlzQmVmb3JlKGIpIHtcbiAgICBsZXQgYU5vZGUgPSB0aGlzLmdldE5vZGUoKTtcbiAgICBsZXQgYk5vZGUgPSBiLmdldE5vZGUoKTtcbiAgICBjb25zdCBhT2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgY29uc3QgYk9mZnNldCA9IGIub2Zmc2V0O1xuXG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGFOb2RlKSkge1xuICAgICAgY29uc3QgYU5vZGVEZXNjZW5kYW50ID0gYU5vZGUuZ2V0RGVzY2VuZGFudEJ5SW5kZXgoYU9mZnNldCk7XG4gICAgICBhTm9kZSA9IGFOb2RlRGVzY2VuZGFudCAhPSBudWxsID8gYU5vZGVEZXNjZW5kYW50IDogYU5vZGU7XG4gICAgfVxuXG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGJOb2RlKSkge1xuICAgICAgY29uc3QgYk5vZGVEZXNjZW5kYW50ID0gYk5vZGUuZ2V0RGVzY2VuZGFudEJ5SW5kZXgoYk9mZnNldCk7XG4gICAgICBiTm9kZSA9IGJOb2RlRGVzY2VuZGFudCAhPSBudWxsID8gYk5vZGVEZXNjZW5kYW50IDogYk5vZGU7XG4gICAgfVxuXG4gICAgaWYgKGFOb2RlID09PSBiTm9kZSkge1xuICAgICAgcmV0dXJuIGFPZmZzZXQgPCBiT2Zmc2V0O1xuICAgIH1cblxuICAgIHJldHVybiBhTm9kZS5pc0JlZm9yZShiTm9kZSk7XG4gIH1cblxuICBnZXROb2RlKCkge1xuICAgIGNvbnN0IGtleSA9IHRoaXMua2V5O1xuICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGtleSk7XG5cbiAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgUG9pbnQuZ2V0Tm9kZTogbm9kZSBub3QgZm91bmRgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHNldChrZXksIG9mZnNldCwgdHlwZSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbjtcbiAgICBjb25zdCBvbGRLZXkgPSB0aGlzLmtleTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gICAgaWYgKCFpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSgpKSB7XG4gICAgICBpZiAoJGdldENvbXBvc2l0aW9uS2V5KCkgPT09IG9sZEtleSkge1xuICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkoa2V5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBzZWxlY3Rpb24uX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiAkY3JlYXRlUG9pbnQoa2V5LCBvZmZzZXQsIHR5cGUpIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZW50aW9uYWxseSBjYXN0IGFzIHdlIHVzZSBhIGNsYXNzIGZvciBwZXJmIHJlYXNvbnNcbiAgcmV0dXJuIG5ldyBQb2ludChrZXksIG9mZnNldCwgdHlwZSk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdFBvaW50T25Ob2RlKHBvaW50LCBub2RlKSB7XG4gIGxldCBrZXkgPSBub2RlLl9fa2V5O1xuICBsZXQgb2Zmc2V0ID0gcG9pbnQub2Zmc2V0O1xuICBsZXQgdHlwZSA9ICdlbGVtZW50JztcblxuICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICB0eXBlID0gJ3RleHQnO1xuICAgIGNvbnN0IHRleHRDb250ZW50TGVuZ3RoID0gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcblxuICAgIGlmIChvZmZzZXQgPiB0ZXh0Q29udGVudExlbmd0aCkge1xuICAgICAgb2Zmc2V0ID0gdGV4dENvbnRlbnRMZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuXG4gICAgaWYgKCRpc1RleHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAga2V5ID0gbmV4dFNpYmxpbmcuX19rZXk7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgdHlwZSA9ICd0ZXh0JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIGtleSA9IHBhcmVudE5vZGUuX19rZXk7XG4gICAgICAgIG9mZnNldCA9IG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcG9pbnQuc2V0KGtleSwgb2Zmc2V0LCB0eXBlKTtcbn1cblxuZnVuY3Rpb24gJG1vdmVTZWxlY3Rpb25Qb2ludFRvRW5kKHBvaW50LCBub2RlKSB7XG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IGxhc3ROb2RlID0gbm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpO1xuXG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGxhc3ROb2RlKSB8fCAkaXNUZXh0Tm9kZShsYXN0Tm9kZSkpIHtcbiAgICAgIHNlbGVjdFBvaW50T25Ob2RlKHBvaW50LCBsYXN0Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdFBvaW50T25Ob2RlKHBvaW50LCBub2RlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2VsZWN0UG9pbnRPbk5vZGUocG9pbnQsIG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uICR0cmFuc2ZlclN0YXJ0aW5nRWxlbWVudFBvaW50VG9UZXh0UG9pbnQoc3RhcnQsIGVuZCwgZm9ybWF0LCBzdHlsZSkge1xuICBjb25zdCBlbGVtZW50ID0gc3RhcnQuZ2V0Tm9kZSgpO1xuICBjb25zdCBwbGFjZW1lbnROb2RlID0gZWxlbWVudC5nZXRDaGlsZEF0SW5kZXgoc3RhcnQub2Zmc2V0KTtcbiAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoKTtcbiAgY29uc3QgdGFyZ2V0ID0gJGlzUm9vdE5vZGUoZWxlbWVudCkgPyAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpLmFwcGVuZCh0ZXh0Tm9kZSkgOiB0ZXh0Tm9kZTtcbiAgdGV4dE5vZGUuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gIHRleHROb2RlLnNldFN0eWxlKHN0eWxlKTtcblxuICBpZiAocGxhY2VtZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIGVsZW1lbnQuYXBwZW5kKHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgcGxhY2VtZW50Tm9kZS5pbnNlcnRCZWZvcmUodGFyZ2V0KTsgLy8gRml4IHRoZSBlbmQgcG9pbnQgb2Zmc2V0IGlmIGl0IHJlZmVycyB0byB0aGUgc2FtZSBlbGVtZW50IGFzIHN0YXJ0LFxuICAgIC8vIGFzIHdlJ3ZlIG5vdyBpbnNlcnRlZCBhbm90aGVyIGVsZW1lbnQgYmVmb3JlIGl0LiBOb3RlIHRoYXQgd2Ugb25seVxuICAgIC8vIGRvIGl0IGlmIHNlbGVjdGlvbiBpcyBub3QgY29sbGFwc2VkIGFzIG90aGVyd2lzZSBpdCdsbCB0cmFuc2ZlclxuICAgIC8vIGJvdGggZm9jdXMgYW5kIGFuY2hvciB0byB0aGUgdGV4dCBub2RlIGJlbG93XG5cbiAgICBpZiAoZW5kLnR5cGUgPT09ICdlbGVtZW50JyAmJiBlbmQua2V5ID09PSBzdGFydC5rZXkgJiYgZW5kLm9mZnNldCAhPT0gc3RhcnQub2Zmc2V0KSB7XG4gICAgICBlbmQuc2V0KGVuZC5rZXksIGVuZC5vZmZzZXQgKyAxLCAnZWxlbWVudCcpO1xuICAgIH1cbiAgfSAvLyBUcmFuc2ZlciB0aGUgZWxlbWVudCBwb2ludCB0byBhIHRleHQgcG9pbnQuXG5cblxuICBpZiAoc3RhcnQuaXMoZW5kKSkge1xuICAgIGVuZC5zZXQodGV4dE5vZGUuX19rZXksIDAsICd0ZXh0Jyk7XG4gIH1cblxuICBzdGFydC5zZXQodGV4dE5vZGUuX19rZXksIDAsICd0ZXh0Jyk7XG59XG5cbmZ1bmN0aW9uICRzZXRQb2ludFZhbHVlcyhwb2ludCwga2V5LCBvZmZzZXQsIHR5cGUpIHtcbiAgcG9pbnQua2V5ID0ga2V5O1xuICBwb2ludC5vZmZzZXQgPSBvZmZzZXQ7XG4gIHBvaW50LnR5cGUgPSB0eXBlO1xufVxuXG5jbGFzcyBOb2RlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0cykge1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLl9ub2RlcyA9IG9iamVjdHM7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG5cbiAgaXMoc2VsZWN0aW9uKSB7XG4gICAgaWYgKCEkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBhID0gdGhpcy5fbm9kZXM7XG4gICAgY29uc3QgYiA9IHNlbGVjdGlvbi5fbm9kZXM7XG4gICAgcmV0dXJuIGEuc2l6ZSA9PT0gYi5zaXplICYmIEFycmF5LmZyb20oYSkuZXZlcnkoa2V5ID0+IGIuaGFzKGtleSkpO1xuICB9XG5cbiAgYWRkKGtleSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgdGhpcy5fbm9kZXMuYWRkKGtleSk7XG5cbiAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG51bGw7XG4gIH1cblxuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICB0aGlzLl9ub2Rlcy5kZWxldGUoa2V5KTtcblxuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuXG4gICAgdGhpcy5fbm9kZXMuY2xlYXIoKTtcblxuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgfVxuXG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXMuaGFzKGtleSk7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24obmV3IFNldCh0aGlzLl9ub2RlcykpO1xuICB9XG5cbiAgZXh0cmFjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROb2RlcygpO1xuICB9XG5cbiAgaW5zZXJ0UmF3VGV4dCh0ZXh0KSB7Ly8gRG8gbm90aGluZz9cbiAgfVxuXG4gIGluc2VydFRleHQoKSB7Ly8gRG8gbm90aGluZz9cbiAgfVxuXG4gIGluc2VydE5vZGVzKG5vZGVzLCBzZWxlY3RTdGFydCkge1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2Rlc0xlbmd0aCA9IHNlbGVjdGVkTm9kZXMubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3RTZWxlY3RlZE5vZGUgPSBzZWxlY3RlZE5vZGVzW3NlbGVjdGVkTm9kZXNMZW5ndGggLSAxXTtcbiAgICBsZXQgc2VsZWN0aW9uQXRFbmQ7IC8vIEluc2VydCBub2Rlc1xuXG4gICAgaWYgKCRpc1RleHROb2RlKGxhc3RTZWxlY3RlZE5vZGUpKSB7XG4gICAgICBzZWxlY3Rpb25BdEVuZCA9IGxhc3RTZWxlY3RlZE5vZGUuc2VsZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGFzdFNlbGVjdGVkTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgMTtcbiAgICAgIHNlbGVjdGlvbkF0RW5kID0gbGFzdFNlbGVjdGVkTm9kZS5nZXRQYXJlbnRPclRocm93KCkuc2VsZWN0KGluZGV4LCBpbmRleCk7XG4gICAgfVxuXG4gICAgc2VsZWN0aW9uQXRFbmQuaW5zZXJ0Tm9kZXMobm9kZXMsIHNlbGVjdFN0YXJ0KTsgLy8gUmVtb3ZlIHNlbGVjdGVkIG5vZGVzXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGVkTm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgc2VsZWN0ZWROb2Rlc1tpXS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldE5vZGVzKCkge1xuICAgIGNvbnN0IGNhY2hlZE5vZGVzID0gdGhpcy5fY2FjaGVkTm9kZXM7XG5cbiAgICBpZiAoY2FjaGVkTm9kZXMgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZWROb2RlcztcbiAgICB9XG5cbiAgICBjb25zdCBvYmplY3RzID0gdGhpcy5fbm9kZXM7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcblxuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIG9iamVjdHMpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KG9iamVjdCk7XG5cbiAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSgpKSB7XG4gICAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG5vZGVzO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgIGxldCB0ZXh0Q29udGVudCA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGV4dENvbnRlbnQgKz0gbm9kZXNbaV0uZ2V0VGV4dENvbnRlbnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gIH1cblxufVxuZnVuY3Rpb24gJGlzUmFuZ2VTZWxlY3Rpb24oeCkge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIFJhbmdlU2VsZWN0aW9uO1xufVxuY2xhc3MgR3JpZFNlbGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGdyaWRLZXksIGFuY2hvciwgZm9jdXMpIHtcbiAgICB0aGlzLmdyaWRLZXkgPSBncmlkS2V5O1xuICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIHRoaXMuZm9jdXMgPSBmb2N1cztcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICAgIGFuY2hvci5fc2VsZWN0aW9uID0gdGhpcztcbiAgICBmb2N1cy5fc2VsZWN0aW9uID0gdGhpcztcbiAgfVxuXG4gIGlzKHNlbGVjdGlvbikge1xuICAgIGlmICghREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ncmlkS2V5ID09PSBzZWxlY3Rpb24uZ3JpZEtleSAmJiB0aGlzLmFuY2hvci5pcyhzZWxlY3Rpb24uYW5jaG9yKSAmJiB0aGlzLmZvY3VzLmlzKHNlbGVjdGlvbi5mb2N1cyk7XG4gIH1cblxuICBzZXQoZ3JpZEtleSwgYW5jaG9yQ2VsbEtleSwgZm9jdXNDZWxsS2V5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5ncmlkS2V5ID0gZ3JpZEtleTtcbiAgICB0aGlzLmFuY2hvci5rZXkgPSBhbmNob3JDZWxsS2V5O1xuICAgIHRoaXMuZm9jdXMua2V5ID0gZm9jdXNDZWxsS2V5O1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgR3JpZFNlbGVjdGlvbih0aGlzLmdyaWRLZXksIHRoaXMuYW5jaG9yLCB0aGlzLmZvY3VzKTtcbiAgfVxuXG4gIGlzQ29sbGFwc2VkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzQmFja3dhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXMuaXNCZWZvcmUodGhpcy5hbmNob3IpO1xuICB9XG5cbiAgZ2V0Q2hhcmFjdGVyT2Zmc2V0cygpIHtcbiAgICByZXR1cm4gZ2V0Q2hhcmFjdGVyT2Zmc2V0cyh0aGlzKTtcbiAgfVxuXG4gIGV4dHJhY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXMoKTtcbiAgfVxuXG4gIGluc2VydFJhd1RleHQodGV4dCkgey8vIERvIG5vdGhpbmc/XG4gIH1cblxuICBpbnNlcnRUZXh0KCkgey8vIERvIG5vdGhpbmc/XG4gIH1cblxuICBpbnNlcnROb2Rlcyhub2Rlcywgc2VsZWN0U3RhcnQpIHtcbiAgICBjb25zdCBmb2N1c05vZGUgPSB0aGlzLmZvY3VzLmdldE5vZGUoKTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkbm9ybWFsaXplU2VsZWN0aW9uKGZvY3VzTm9kZS5zZWxlY3QoMCwgZm9jdXNOb2RlLmdldENoaWxkcmVuU2l6ZSgpKSk7XG4gICAgcmV0dXJuIHNlbGVjdGlvbi5pbnNlcnROb2Rlcyhub2Rlcywgc2VsZWN0U3RhcnQpO1xuICB9IC8vIFRPRE8gRGVwcmVjYXRlIHRoaXMgbWV0aG9kLiBJdCdzIGNvbmZ1c2luZyB3aGVuIHVzZWQgd2l0aCBjb2xzcGFufHJvd3NwYW5cblxuXG4gIGdldFNoYXBlKCkge1xuICAgIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGdldE5vZGVCeUtleSh0aGlzLmFuY2hvci5rZXkpO1xuXG4gICAgaWYgKCEoYW5jaG9yQ2VsbE5vZGUgIT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgZ2V0Tm9kZXM6IGV4cGVjdGVkIHRvIGZpbmQgQW5jaG9yTm9kZWApO1xuICAgIH1cblxuICAgIGNvbnN0IGFuY2hvckNlbGxOb2RlSW5kZXggPSBhbmNob3JDZWxsTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgIGNvbnN0IGFuY2hvckNlbFJvd2VJbmRleCA9IGFuY2hvckNlbGxOb2RlLmdldFBhcmVudE9yVGhyb3coKS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHRoaXMuZm9jdXMua2V5KTtcblxuICAgIGlmICghKGZvY3VzQ2VsbE5vZGUgIT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgZ2V0Tm9kZXM6IGV4cGVjdGVkIHRvIGZpbmQgRm9jdXNOb2RlYCk7XG4gICAgfVxuXG4gICAgY29uc3QgZm9jdXNDZWxsTm9kZUluZGV4ID0gZm9jdXNDZWxsTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgIGNvbnN0IGZvY3VzQ2VsbFJvd0luZGV4ID0gZm9jdXNDZWxsTm9kZS5nZXRQYXJlbnRPclRocm93KCkuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICBjb25zdCBzdGFydFggPSBNYXRoLm1pbihhbmNob3JDZWxsTm9kZUluZGV4LCBmb2N1c0NlbGxOb2RlSW5kZXgpO1xuICAgIGNvbnN0IHN0b3BYID0gTWF0aC5tYXgoYW5jaG9yQ2VsbE5vZGVJbmRleCwgZm9jdXNDZWxsTm9kZUluZGV4KTtcbiAgICBjb25zdCBzdGFydFkgPSBNYXRoLm1pbihhbmNob3JDZWxSb3dlSW5kZXgsIGZvY3VzQ2VsbFJvd0luZGV4KTtcbiAgICBjb25zdCBzdG9wWSA9IE1hdGgubWF4KGFuY2hvckNlbFJvd2VJbmRleCwgZm9jdXNDZWxsUm93SW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tWDogTWF0aC5taW4oc3RhcnRYLCBzdG9wWCksXG4gICAgICBmcm9tWTogTWF0aC5taW4oc3RhcnRZLCBzdG9wWSksXG4gICAgICB0b1g6IE1hdGgubWF4KHN0YXJ0WCwgc3RvcFgpLFxuICAgICAgdG9ZOiBNYXRoLm1heChzdGFydFksIHN0b3BZKVxuICAgIH07XG4gIH1cblxuICBnZXROb2RlcygpIHtcbiAgICBjb25zdCBjYWNoZWROb2RlcyA9IHRoaXMuX2NhY2hlZE5vZGVzO1xuXG4gICAgaWYgKGNhY2hlZE5vZGVzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTm9kZXM7XG4gICAgfVxuXG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHRoaXMuYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSB0aGlzLmZvY3VzLmdldE5vZGUoKTtcbiAgICBjb25zdCBhbmNob3JDZWxsID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3JOb2RlLCBERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZSk7IC8vIHRvZG8gcmVwbGFjZSB3aXRoIHRyaXBsZXRcblxuICAgIGNvbnN0IGZvY3VzQ2VsbCA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXNOb2RlLCBERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZSk7XG5cbiAgICBpZiAoIURFUFJFQ0FURURfJGlzR3JpZENlbGxOb2RlKGFuY2hvckNlbGwpKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgR3JpZFNlbGVjdGlvbiBhbmNob3IgdG8gYmUgKG9yIGEgY2hpbGQgb2YpIEdyaWRDZWxsTm9kZWApO1xuICAgIH1cblxuICAgIGlmICghREVQUkVDQVRFRF8kaXNHcmlkQ2VsbE5vZGUoZm9jdXNDZWxsKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIEdyaWRTZWxlY3Rpb24gZm9jdXMgdG8gYmUgKG9yIGEgY2hpbGQgb2YpIEdyaWRDZWxsTm9kZWApO1xuICAgIH1cblxuICAgIGNvbnN0IGFuY2hvclJvdyA9IGFuY2hvckNlbGwuZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAoIURFUFJFQ0FURURfJGlzR3JpZFJvd05vZGUoYW5jaG9yUm93KSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIGFuY2hvckNlbGwgdG8gaGF2ZSBhIHBhcmVudCBHcmlkUm93Tm9kZWApO1xuICAgIH1cblxuICAgIGNvbnN0IGdyaWROb2RlID0gYW5jaG9yUm93LmdldFBhcmVudCgpO1xuXG4gICAgaWYgKCFERVBSRUNBVEVEXyRpc0dyaWROb2RlKGdyaWROb2RlKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRhYmxlTm9kZSB0byBoYXZlIGEgcGFyZW50IEdyaWROb2RlYCk7XG4gICAgfSAvLyBUT0RPIE1hcHBpbmcgdGhlIHdob2xlIEdyaWQgZXZlcnkgdGltZSBub3QgZWZmaWNpZW50LiBXZSBuZWVkIHRvIGNvbXB1dGUgdGhlIGVudGlyZSBzdGF0ZSBvbmx5XG4gICAgLy8gb25jZSAob24gbG9hZCkgYW5kIGl0ZXJhdGUgb24gaXQgYXMgdXBkYXRlcyBvY2N1ci4gSG93ZXZlciwgdG8gZG8gdGhpcyB3ZSBuZWVkIHRvIGhhdmUgdGhlXG4gICAgLy8gYWJpbGl0eSB0byBzdG9yZSBhIHN0YXRlLiBLaWxsaW5nIEdyaWRTZWxlY3Rpb24gYW5kIG1vdmluZyB0aGUgbG9naWMgdG8gdGhlIHBsdWdpbiB3b3VsZCBtYWtlXG4gICAgLy8gdGhpcyBwb3NzaWJsZS5cblxuXG4gICAgY29uc3QgW21hcCwgY2VsbEFNYXAsIGNlbGxCTWFwXSA9IERFUFJFQ0FURURfJGNvbXB1dGVHcmlkTWFwKGdyaWROb2RlLCBhbmNob3JDZWxsLCBmb2N1c0NlbGwpO1xuICAgIGxldCBtaW5Db2x1bW4gPSBNYXRoLm1pbihjZWxsQU1hcC5zdGFydENvbHVtbiwgY2VsbEJNYXAuc3RhcnRDb2x1bW4pO1xuICAgIGxldCBtaW5Sb3cgPSBNYXRoLm1pbihjZWxsQU1hcC5zdGFydFJvdywgY2VsbEJNYXAuc3RhcnRSb3cpO1xuICAgIGxldCBtYXhDb2x1bW4gPSBNYXRoLm1heChjZWxsQU1hcC5zdGFydENvbHVtbiArIGNlbGxBTWFwLmNlbGwuX19jb2xTcGFuIC0gMSwgY2VsbEJNYXAuc3RhcnRDb2x1bW4gKyBjZWxsQk1hcC5jZWxsLl9fY29sU3BhbiAtIDEpO1xuICAgIGxldCBtYXhSb3cgPSBNYXRoLm1heChjZWxsQU1hcC5zdGFydFJvdyArIGNlbGxBTWFwLmNlbGwuX19yb3dTcGFuIC0gMSwgY2VsbEJNYXAuc3RhcnRSb3cgKyBjZWxsQk1hcC5jZWxsLl9fcm93U3BhbiAtIDEpO1xuICAgIGxldCBleHBsb3JlZE1pbkNvbHVtbiA9IG1pbkNvbHVtbjtcbiAgICBsZXQgZXhwbG9yZWRNaW5Sb3cgPSBtaW5Sb3c7XG4gICAgbGV0IGV4cGxvcmVkTWF4Q29sdW1uID0gbWluQ29sdW1uO1xuICAgIGxldCBleHBsb3JlZE1heFJvdyA9IG1pblJvdztcblxuICAgIGZ1bmN0aW9uIGV4cGFuZEJvdW5kYXJ5KG1hcFZhbHVlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Q29sdW1uOiBjZWxsU3RhcnRDb2x1bW4sXG4gICAgICAgIHN0YXJ0Um93OiBjZWxsU3RhcnRSb3dcbiAgICAgIH0gPSBtYXBWYWx1ZTtcbiAgICAgIG1pbkNvbHVtbiA9IE1hdGgubWluKG1pbkNvbHVtbiwgY2VsbFN0YXJ0Q29sdW1uKTtcbiAgICAgIG1pblJvdyA9IE1hdGgubWluKG1pblJvdywgY2VsbFN0YXJ0Um93KTtcbiAgICAgIG1heENvbHVtbiA9IE1hdGgubWF4KG1heENvbHVtbiwgY2VsbFN0YXJ0Q29sdW1uICsgY2VsbC5fX2NvbFNwYW4gLSAxKTtcbiAgICAgIG1heFJvdyA9IE1hdGgubWF4KG1heFJvdywgY2VsbFN0YXJ0Um93ICsgY2VsbC5fX3Jvd1NwYW4gLSAxKTtcbiAgICB9XG5cbiAgICB3aGlsZSAobWluQ29sdW1uIDwgZXhwbG9yZWRNaW5Db2x1bW4gfHwgbWluUm93IDwgZXhwbG9yZWRNaW5Sb3cgfHwgbWF4Q29sdW1uID4gZXhwbG9yZWRNYXhDb2x1bW4gfHwgbWF4Um93ID4gZXhwbG9yZWRNYXhSb3cpIHtcbiAgICAgIGlmIChtaW5Db2x1bW4gPCBleHBsb3JlZE1pbkNvbHVtbikge1xuICAgICAgICAvLyBFeHBhbmQgb24gdGhlIGxlZnRcbiAgICAgICAgY29uc3Qgcm93RGlmZiA9IGV4cGxvcmVkTWF4Um93IC0gZXhwbG9yZWRNaW5Sb3c7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzQ29sdW1uID0gZXhwbG9yZWRNaW5Db2x1bW4gLSAxO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHJvd0RpZmY7IGkrKykge1xuICAgICAgICAgIGV4cGFuZEJvdW5kYXJ5KG1hcFtleHBsb3JlZE1pblJvdyArIGldW3ByZXZpb3VzQ29sdW1uXSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBsb3JlZE1pbkNvbHVtbiA9IHByZXZpb3VzQ29sdW1uO1xuICAgICAgfVxuXG4gICAgICBpZiAobWluUm93IDwgZXhwbG9yZWRNaW5Sb3cpIHtcbiAgICAgICAgLy8gRXhwYW5kIG9uIHRvcFxuICAgICAgICBjb25zdCBjb2x1bW5EaWZmID0gZXhwbG9yZWRNYXhDb2x1bW4gLSBleHBsb3JlZE1pbkNvbHVtbjtcbiAgICAgICAgY29uc3QgcHJldmlvdXNSb3cgPSBleHBsb3JlZE1pblJvdyAtIDE7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gY29sdW1uRGlmZjsgaSsrKSB7XG4gICAgICAgICAgZXhwYW5kQm91bmRhcnkobWFwW3ByZXZpb3VzUm93XVtleHBsb3JlZE1pbkNvbHVtbiArIGldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGxvcmVkTWluUm93ID0gcHJldmlvdXNSb3c7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXhDb2x1bW4gPiBleHBsb3JlZE1heENvbHVtbikge1xuICAgICAgICAvLyBFeHBhbmQgb24gdGhlIHJpZ2h0XG4gICAgICAgIGNvbnN0IHJvd0RpZmYgPSBleHBsb3JlZE1heFJvdyAtIGV4cGxvcmVkTWluUm93O1xuICAgICAgICBjb25zdCBuZXh0Q29sdW1uID0gZXhwbG9yZWRNYXhDb2x1bW4gKyAxO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHJvd0RpZmY7IGkrKykge1xuICAgICAgICAgIGV4cGFuZEJvdW5kYXJ5KG1hcFtleHBsb3JlZE1pblJvdyArIGldW25leHRDb2x1bW5dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGxvcmVkTWF4Q29sdW1uID0gbmV4dENvbHVtbjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heFJvdyA+IGV4cGxvcmVkTWF4Um93KSB7XG4gICAgICAgIC8vIEV4cGFuZCBvbiB0aGUgYm90dG9tXG4gICAgICAgIGNvbnN0IGNvbHVtbkRpZmYgPSBleHBsb3JlZE1heENvbHVtbiAtIGV4cGxvcmVkTWluQ29sdW1uO1xuICAgICAgICBjb25zdCBuZXh0Um93ID0gZXhwbG9yZWRNYXhSb3cgKyAxO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGNvbHVtbkRpZmY7IGkrKykge1xuICAgICAgICAgIGV4cGFuZEJvdW5kYXJ5KG1hcFtuZXh0Um93XVtleHBsb3JlZE1pbkNvbHVtbiArIGldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGxvcmVkTWF4Um93ID0gbmV4dFJvdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBub2RlcyA9IFtncmlkTm9kZV07XG4gICAgbGV0IGxhc3RSb3cgPSBudWxsO1xuXG4gICAgZm9yIChsZXQgaSA9IG1pblJvdzsgaSA8PSBtYXhSb3c7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IG1pbkNvbHVtbjsgaiA8PSBtYXhDb2x1bW47IGorKykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2VsbFxuICAgICAgICB9ID0gbWFwW2ldW2pdO1xuICAgICAgICBjb25zdCBjdXJyZW50Um93ID0gY2VsbC5nZXRQYXJlbnQoKTtcblxuICAgICAgICBpZiAoIURFUFJFQ0FURURfJGlzR3JpZFJvd05vZGUoY3VycmVudFJvdykpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgR3JpZENlbGxOb2RlIHBhcmVudCB0byBiZSBhIEdyaWRSb3dOb2RlYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudFJvdyAhPT0gbGFzdFJvdykge1xuICAgICAgICAgIG5vZGVzLnB1c2goY3VycmVudFJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICBub2Rlcy5wdXNoKGNlbGwsIC4uLiRnZXRDaGlsZHJlblJlY3Vyc2l2ZWx5KGNlbGwpKTtcbiAgICAgICAgbGFzdFJvdyA9IGN1cnJlbnRSb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSgpKSB7XG4gICAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG5vZGVzO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgIGxldCB0ZXh0Q29udGVudCA9ICcnO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGV4dENvbnRlbnQgKz0gbm9kZXNbaV0uZ2V0VGV4dENvbnRlbnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gIH1cblxufVxuZnVuY3Rpb24gREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBHcmlkU2VsZWN0aW9uO1xufVxuY2xhc3MgUmFuZ2VTZWxlY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihhbmNob3IsIGZvY3VzLCBmb3JtYXQsIHN0eWxlKSB7XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgdGhpcy5mb2N1cyA9IGZvY3VzO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICAgIGFuY2hvci5fc2VsZWN0aW9uID0gdGhpcztcbiAgICBmb2N1cy5fc2VsZWN0aW9uID0gdGhpcztcbiAgfVxuICAvKipcbiAgICogVXNlZCB0byBjaGVjayBpZiB0aGUgcHJvdmlkZWQgc2VsZWN0aW9ucyBpcyBlcXVhbCB0byB0aGlzIG9uZSBieSB2YWx1ZSxcbiAgICogaW5sdWRpbmcgYW5jaG9yLCBmb2N1cywgZm9ybWF0LCBhbmQgc3R5bGUgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHNlbGVjdGlvbiAtIHRoZSBTZWxlY3Rpb24gdG8gY29tcGFyZSB0aGlzIG9uZSB0by5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgU2VsZWN0aW9ucyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBpcyhzZWxlY3Rpb24pIHtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hbmNob3IuaXMoc2VsZWN0aW9uLmFuY2hvcikgJiYgdGhpcy5mb2N1cy5pcyhzZWxlY3Rpb24uZm9jdXMpICYmIHRoaXMuZm9ybWF0ID09PSBzZWxlY3Rpb24uZm9ybWF0ICYmIHRoaXMuc3R5bGUgPT09IHNlbGVjdGlvbi5zdHlsZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBTZWxlY3Rpb24gaXMgXCJiYWNrd2FyZHNcIiwgbWVhbmluZyB0aGUgZm9jdXNcbiAgICogbG9naWNhbGx5IHByZWNlZGVzIHRoZSBhbmNob3IgaW4gdGhlIEVkaXRvclN0YXRlLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBTZWxlY3Rpb24gaXMgYmFja3dhcmRzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgaXNCYWNrd2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb2N1cy5pc0JlZm9yZSh0aGlzLmFuY2hvcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgU2VsZWN0aW9uIGlzIFwiY29sbGFwc2VkXCIsIG1lYW5pbmcgdGhlIGFuY2hvciBhbmQgZm9jdXMgYXJlXG4gICAqIHRoZSBzYW1lIG5vZGUgYW5kIGhhdmUgdGhlIHNhbWUgb2Zmc2V0LlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBTZWxlY3Rpb24gaXMgY29sbGFwc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgaXNDb2xsYXBzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5jaG9yLmlzKHRoaXMuZm9jdXMpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGFsbCB0aGUgbm9kZXMgaW4gdGhlIFNlbGVjdGlvbi4gVXNlcyBjYWNoaW5nIHRvIG1ha2UgaXQgZ2VuZXJhbGx5IHN1aXRhYmxlXG4gICAqIGZvciB1c2UgaW4gaG90IHBhdGhzLlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBBcnJheSBjb250YWluaW5nIGFsbCB0aGUgbm9kZXMgaW4gdGhlIFNlbGVjdGlvblxuICAgKi9cblxuXG4gIGdldE5vZGVzKCkge1xuICAgIGNvbnN0IGNhY2hlZE5vZGVzID0gdGhpcy5fY2FjaGVkTm9kZXM7XG5cbiAgICBpZiAoY2FjaGVkTm9kZXMgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZWROb2RlcztcbiAgICB9XG5cbiAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICBjb25zdCBmb2N1cyA9IHRoaXMuZm9jdXM7XG4gICAgY29uc3QgaXNCZWZvcmUgPSBhbmNob3IuaXNCZWZvcmUoZm9jdXMpO1xuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBpc0JlZm9yZSA/IGFuY2hvciA6IGZvY3VzO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGlzQmVmb3JlID8gZm9jdXMgOiBhbmNob3I7XG4gICAgbGV0IGZpcnN0Tm9kZSA9IGZpcnN0UG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGxldCBsYXN0Tm9kZSA9IGxhc3RQb2ludC5nZXROb2RlKCk7XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBmaXJzdFBvaW50Lm9mZnNldDtcbiAgICBjb25zdCBlbmRPZmZzZXQgPSBsYXN0UG9pbnQub2Zmc2V0O1xuXG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGZpcnN0Tm9kZURlc2NlbmRhbnQgPSBmaXJzdE5vZGUuZ2V0RGVzY2VuZGFudEJ5SW5kZXgoc3RhcnRPZmZzZXQpO1xuICAgICAgZmlyc3ROb2RlID0gZmlyc3ROb2RlRGVzY2VuZGFudCAhPSBudWxsID8gZmlyc3ROb2RlRGVzY2VuZGFudCA6IGZpcnN0Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobGFzdE5vZGUpKSB7XG4gICAgICBsZXQgbGFzdE5vZGVEZXNjZW5kYW50ID0gbGFzdE5vZGUuZ2V0RGVzY2VuZGFudEJ5SW5kZXgoZW5kT2Zmc2V0KTsgLy8gV2UgZG9uJ3Qgd2FudCB0byBvdmVyLXNlbGVjdCwgYXMgbm9kZSBzZWxlY3Rpb24gaW5mZXJzIHRoZSBjaGlsZCBiZWZvcmVcbiAgICAgIC8vIHRoZSBsYXN0IGRlc2NlbmRhbnQsIG5vdCBpbmNsdWRpbmcgdGhhdCBkZXNjZW5kYW50LlxuXG4gICAgICBpZiAobGFzdE5vZGVEZXNjZW5kYW50ICE9PSBudWxsICYmIGxhc3ROb2RlRGVzY2VuZGFudCAhPT0gZmlyc3ROb2RlICYmIGxhc3ROb2RlLmdldENoaWxkQXRJbmRleChlbmRPZmZzZXQpID09PSBsYXN0Tm9kZURlc2NlbmRhbnQpIHtcbiAgICAgICAgbGFzdE5vZGVEZXNjZW5kYW50ID0gbGFzdE5vZGVEZXNjZW5kYW50LmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgfVxuXG4gICAgICBsYXN0Tm9kZSA9IGxhc3ROb2RlRGVzY2VuZGFudCAhPSBudWxsID8gbGFzdE5vZGVEZXNjZW5kYW50IDogbGFzdE5vZGU7XG4gICAgfVxuXG4gICAgbGV0IG5vZGVzO1xuXG4gICAgaWYgKGZpcnN0Tm9kZS5pcyhsYXN0Tm9kZSkpIHtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpICYmIGZpcnN0Tm9kZS5nZXRDaGlsZHJlblNpemUoKSA+IDApIHtcbiAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVzID0gW2ZpcnN0Tm9kZV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVzID0gZmlyc3ROb2RlLmdldE5vZGVzQmV0d2VlbihsYXN0Tm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSgpKSB7XG4gICAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG5vZGVzO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGlzIFNlbGVjdGlvbiB0byBiZSBvZiB0eXBlIFwidGV4dFwiIGF0IHRoZSBwcm92aWRlZCBhbmNob3IgYW5kIGZvY3VzIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIGFuY2hvck5vZGUgLSB0aGUgYW5jaG9yIG5vZGUgdG8gc2V0IG9uIHRoZSBTZWxlY3Rpb25cbiAgICogQHBhcmFtIGFuY2hvck9mZnNldCAtIHRoZSBvZmZzZXQgdG8gc2V0IG9uIHRoZSBTZWxlY3Rpb25cbiAgICogQHBhcmFtIGZvY3VzTm9kZSAtIHRoZSBmb2N1cyBub2RlIHRvIHNldCBvbiB0aGUgU2VsZWN0aW9uXG4gICAqIEBwYXJhbSBmb2N1c09mZnNldCAtIHRoZSBmb2N1cyBvZmZzZXQgdG8gc2V0IG9uIHRoZSBTZWxlY3Rpb25cbiAgICovXG5cblxuICBzZXRUZXh0Tm9kZVJhbmdlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmFuY2hvciwgYW5jaG9yTm9kZS5fX2tleSwgYW5jaG9yT2Zmc2V0LCAndGV4dCcpO1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmZvY3VzLCBmb2N1c05vZGUuX19rZXksIGZvY3VzT2Zmc2V0LCAndGV4dCcpO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgKHBsYWluKSB0ZXh0IGNvbnRlbnQgb2YgYWxsIHRoZSBub2RlcyBpbiB0aGUgc2VsZWN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHRleHQgY29udGVudCBvZiBhbGwgdGhlIG5vZGVzIGluIHRoZSBTZWxlY3Rpb25cbiAgICovXG5cblxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcblxuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdE5vZGUgPSBub2Rlc1swXTtcbiAgICBjb25zdCBsYXN0Tm9kZSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBpc0JlZm9yZSA9IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgY29uc3QgW2FuY2hvck9mZnNldCwgZm9jdXNPZmZzZXRdID0gZ2V0Q2hhcmFjdGVyT2Zmc2V0cyh0aGlzKTtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICBsZXQgcHJldldhc0VsZW1lbnQgPSB0cnVlO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICBpZiAoIXByZXZXYXNFbGVtZW50KSB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgKz0gJ1xcbic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICBwcmV2V2FzRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZXYXNFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldldhc0VsZW1lbnQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgICAgICBsZXQgdGV4dCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcblxuICAgICAgICAgIGlmIChub2RlID09PSBmaXJzdE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBsYXN0Tm9kZSkge1xuICAgICAgICAgICAgICBpZiAoYW5jaG9yLnR5cGUgIT09ICdlbGVtZW50JyB8fCBmb2N1cy50eXBlICE9PSAnZWxlbWVudCcgfHwgZm9jdXMub2Zmc2V0ID09PSBhbmNob3Iub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGFuY2hvck9mZnNldCA8IGZvY3VzT2Zmc2V0ID8gdGV4dC5zbGljZShhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0KSA6IHRleHQuc2xpY2UoZm9jdXNPZmZzZXQsIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRleHQgPSBpc0JlZm9yZSA/IHRleHQuc2xpY2UoYW5jaG9yT2Zmc2V0KSA6IHRleHQuc2xpY2UoZm9jdXNPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gbGFzdE5vZGUpIHtcbiAgICAgICAgICAgIHRleHQgPSBpc0JlZm9yZSA/IHRleHQuc2xpY2UoMCwgZm9jdXNPZmZzZXQpIDogdGV4dC5zbGljZSgwLCBhbmNob3JPZmZzZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoKCRpc0RlY29yYXRvck5vZGUobm9kZSkgfHwgJGlzTGluZUJyZWFrTm9kZShub2RlKSkgJiYgKG5vZGUgIT09IGxhc3ROb2RlIHx8ICF0aGlzLmlzQ29sbGFwc2VkKCkpKSB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgKz0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHRDb250ZW50O1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBtYXAgYSBET00gc2VsZWN0aW9uIHJhbmdlIG9udG8gdGhpcyBMZXhpY2FsIFNlbGVjdGlvbixcbiAgICogc2V0dGluZyB0aGUgYW5jaG9yLCBmb2N1cywgYW5kIHR5cGUgYWNjb3JkaW5nbHlcbiAgICpcbiAgICogQHBhcmFtIHJhbmdlIGEgRE9NIFNlbGVjdGlvbiByYW5nZSBjb25mb3JtaW5nIHRvIHRoZSBTdGF0aWNSYW5nZSBpbnRlcmZhY2UuXG4gICAqL1xuXG5cbiAgYXBwbHlET01SYW5nZShyYW5nZSkge1xuICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgIGNvbnN0IGN1cnJlbnRFZGl0b3JTdGF0ZSA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpO1xuICAgIGNvbnN0IGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgICBjb25zdCByZXNvbHZlZFNlbGVjdGlvblBvaW50cyA9IGludGVybmFsUmVzb2x2ZVNlbGVjdGlvblBvaW50cyhyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQsIHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0LCBlZGl0b3IsIGxhc3RTZWxlY3Rpb24pO1xuXG4gICAgaWYgKHJlc29sdmVkU2VsZWN0aW9uUG9pbnRzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgW2FuY2hvclBvaW50LCBmb2N1c1BvaW50XSA9IHJlc29sdmVkU2VsZWN0aW9uUG9pbnRzO1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmFuY2hvciwgYW5jaG9yUG9pbnQua2V5LCBhbmNob3JQb2ludC5vZmZzZXQsIGFuY2hvclBvaW50LnR5cGUpO1xuICAgICRzZXRQb2ludFZhbHVlcyh0aGlzLmZvY3VzLCBmb2N1c1BvaW50LmtleSwgZm9jdXNQb2ludC5vZmZzZXQsIGZvY3VzUG9pbnQudHlwZSk7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFJhbmdlU2VsZWN0aW9uLCBjb3B5aW5nIG92ZXIgYWxsIHRoZSBwcm9wZXJ0eSB2YWx1ZXMgZnJvbSB0aGlzIG9uZS5cbiAgICpcbiAgICogQHJldHVybnMgYSBuZXcgUmFuZ2VTZWxlY3Rpb24gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0eSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAqL1xuXG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IG5ldyBSYW5nZVNlbGVjdGlvbigkY3JlYXRlUG9pbnQoYW5jaG9yLmtleSwgYW5jaG9yLm9mZnNldCwgYW5jaG9yLnR5cGUpLCAkY3JlYXRlUG9pbnQoZm9jdXMua2V5LCBmb2N1cy5vZmZzZXQsIGZvY3VzLnR5cGUpLCB0aGlzLmZvcm1hdCwgdGhpcy5zdHlsZSk7XG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgcHJvdmlkZWQgZm9ybWF0IG9uIGFsbCB0aGUgVGV4dE5vZGVzIGluIHRoZSBTZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBmb3JtYXQgYSBzdHJpbmcgVGV4dEZvcm1hdFR5cGUgdG8gdG9nZ2xlIG9uIHRoZSBUZXh0Tm9kZXMgaW4gdGhlIHNlbGVjdGlvblxuICAgKi9cblxuXG4gIHRvZ2dsZUZvcm1hdChmb3JtYXQpIHtcbiAgICB0aGlzLmZvcm1hdCA9IHRvZ2dsZVRleHRGb3JtYXRUeXBlKHRoaXMuZm9ybWF0LCBmb3JtYXQsIG51bGwpO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgc3R5bGUgcHJvcGVydHkgb24gdGhlIFNlbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gc3R5bGUgLSB0aGUgc3R5bGUgdG8gc2V0IGF0IHRoZSB2YWx1ZSBvZiB0aGUgc3R5bGUgcHJvcGVydHkuXG4gICAqL1xuXG5cbiAgc2V0U3R5bGUoc3R5bGUpIHtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgVGV4dEZvcm1hdFR5cGUgaXMgcHJlc2VudCBvbiB0aGUgU2VsZWN0aW9uLiBUaGlzIHdpbGwgYmUgdHJ1ZSBpZiBhbnkgbm9kZSBpbiB0aGUgU2VsZWN0aW9uXG4gICAqIGhhcyB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgdGhlIFRleHRGb3JtYXRUeXBlIHRvIGNoZWNrIGZvci5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgZm9ybWF0IGlzIGN1cnJlbnRseSB0b2dnbGVkIG9uIG9uIHRoZSBTZWxlY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBoYXNGb3JtYXQodHlwZSkge1xuICAgIGNvbnN0IGZvcm1hdEZsYWcgPSBURVhUX1RZUEVfVE9fRk9STUFUW3R5cGVdO1xuICAgIHJldHVybiAodGhpcy5mb3JtYXQgJiBmb3JtYXRGbGFnKSAhPT0gMDtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gaW5zZXJ0IHRoZSBwcm92aWRlZCB0ZXh0IGludG8gdGhlIEVkaXRvclN0YXRlIGF0IHRoZSBjdXJyZW50IFNlbGVjdGlvbi5cbiAgICogY29udmVydHMgdGFicywgbmV3bGluZXMsIGFuZCBjYXJyaWFnZSByZXR1cm5zIGludG8gTGV4aWNhbE5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0gdGV4dCB0aGUgdGV4dCB0byBpbnNlcnQgaW50byB0aGUgU2VsZWN0aW9uXG4gICAqL1xuXG5cbiAgaW5zZXJ0UmF3VGV4dCh0ZXh0KSB7XG4gICAgY29uc3QgcGFydHMgPSB0ZXh0LnNwbGl0KC8oXFxyP1xcbnxcXHQpLyk7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJ0cy5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgIGlmIChwYXJ0ID09PSAnXFxuJyB8fCBwYXJ0ID09PSAnXFxyXFxuJykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVMaW5lQnJlYWtOb2RlKCkpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnXFx0Jykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVUYWJOb2RlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZXMucHVzaCgkY3JlYXRlVGV4dE5vZGUocGFydCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5zZXJ0Tm9kZXMobm9kZXMpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBpbnNlcnQgdGhlIHByb3ZpZGVkIHRleHQgaW50byB0aGUgRWRpdG9yU3RhdGUgYXQgdGhlIGN1cnJlbnQgU2VsZWN0aW9uIGFzIGEgbmV3XG4gICAqIExleGljYWwgVGV4dE5vZGUsIGFjY29yZGluZyB0byBhIHNlcmllcyBvZiBpbnNlcnRpb24gaGV1cmlzdGljcyBiYXNlZCBvbiB0aGUgc2VsZWN0aW9uIHR5cGUgYW5kIHBvc2l0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gdGV4dCB0aGUgdGV4dCB0byBpbnNlcnQgaW50byB0aGUgU2VsZWN0aW9uXG4gICAqL1xuXG5cbiAgaW5zZXJ0VGV4dCh0ZXh0KSB7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgIGNvbnN0IGlzQmVmb3JlID0gdGhpcy5pc0NvbGxhcHNlZCgpIHx8IGFuY2hvci5pc0JlZm9yZShmb2N1cyk7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLnN0eWxlO1xuXG4gICAgaWYgKGlzQmVmb3JlICYmIGFuY2hvci50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgICR0cmFuc2ZlclN0YXJ0aW5nRWxlbWVudFBvaW50VG9UZXh0UG9pbnQoYW5jaG9yLCBmb2N1cywgZm9ybWF0LCBzdHlsZSk7XG4gICAgfSBlbHNlIGlmICghaXNCZWZvcmUgJiYgZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICAkdHJhbnNmZXJTdGFydGluZ0VsZW1lbnRQb2ludFRvVGV4dFBvaW50KGZvY3VzLCBhbmNob3IsIGZvcm1hdCwgc3R5bGUpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2Rlc0xlbmd0aCA9IHNlbGVjdGVkTm9kZXMubGVuZ3RoO1xuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBpc0JlZm9yZSA/IGFuY2hvciA6IGZvY3VzO1xuICAgIGNvbnN0IGVuZFBvaW50ID0gaXNCZWZvcmUgPyBmb2N1cyA6IGFuY2hvcjtcbiAgICBjb25zdCBzdGFydE9mZnNldCA9IGZpcnN0UG9pbnQub2Zmc2V0O1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IGVuZFBvaW50Lm9mZnNldDtcbiAgICBsZXQgZmlyc3ROb2RlID0gc2VsZWN0ZWROb2Rlc1swXTtcblxuICAgIGlmICghJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0VGV4dDogZmlyc3Qgbm9kZSBpcyBub3QgYSB0ZXh0IG5vZGVgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdE5vZGVUZXh0ID0gZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgY29uc3QgZmlyc3ROb2RlVGV4dExlbmd0aCA9IGZpcnN0Tm9kZVRleHQubGVuZ3RoO1xuICAgIGNvbnN0IGZpcnN0Tm9kZVBhcmVudCA9IGZpcnN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gc2VsZWN0ZWROb2Rlc0xlbmd0aCAtIDE7XG4gICAgbGV0IGxhc3ROb2RlID0gc2VsZWN0ZWROb2Rlc1tsYXN0SW5kZXhdO1xuXG4gICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSAmJiBzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlVGV4dExlbmd0aCAmJiAoZmlyc3ROb2RlLmlzU2VnbWVudGVkKCkgfHwgZmlyc3ROb2RlLmlzVG9rZW4oKSB8fCAhZmlyc3ROb2RlLmNhbkluc2VydFRleHRBZnRlcigpIHx8ICFmaXJzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEFmdGVyKCkgJiYgZmlyc3ROb2RlLmdldE5leHRTaWJsaW5nKCkgPT09IG51bGwpKSB7XG4gICAgICBsZXQgbmV4dFNpYmxpbmcgPSBmaXJzdE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgaWYgKCEkaXNUZXh0Tm9kZShuZXh0U2libGluZykgfHwgIW5leHRTaWJsaW5nLmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAkaXNUb2tlbk9yU2VnbWVudGVkKG5leHRTaWJsaW5nKSkge1xuICAgICAgICBuZXh0U2libGluZyA9ICRjcmVhdGVUZXh0Tm9kZSgpO1xuICAgICAgICBuZXh0U2libGluZy5zZXRGb3JtYXQoZm9ybWF0KTtcblxuICAgICAgICBpZiAoIWZpcnN0Tm9kZVBhcmVudC5jYW5JbnNlcnRUZXh0QWZ0ZXIoKSkge1xuICAgICAgICAgIGZpcnN0Tm9kZVBhcmVudC5pbnNlcnRBZnRlcihuZXh0U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlyc3ROb2RlLmluc2VydEFmdGVyKG5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0U2libGluZy5zZWxlY3QoMCwgMCk7XG4gICAgICBmaXJzdE5vZGUgPSBuZXh0U2libGluZztcblxuICAgICAgaWYgKHRleHQgIT09ICcnKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0VGV4dCh0ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbGxhcHNlZCgpICYmIHN0YXJ0T2Zmc2V0ID09PSAwICYmIChmaXJzdE5vZGUuaXNTZWdtZW50ZWQoKSB8fCBmaXJzdE5vZGUuaXNUb2tlbigpIHx8ICFmaXJzdE5vZGUuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHx8ICFmaXJzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpICYmIGZpcnN0Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA9PT0gbnVsbCkpIHtcbiAgICAgIGxldCBwcmV2U2libGluZyA9IGZpcnN0Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgICAgaWYgKCEkaXNUZXh0Tm9kZShwcmV2U2libGluZykgfHwgJGlzVG9rZW5PclNlZ21lbnRlZChwcmV2U2libGluZykpIHtcbiAgICAgICAgcHJldlNpYmxpbmcgPSAkY3JlYXRlVGV4dE5vZGUoKTtcbiAgICAgICAgcHJldlNpYmxpbmcuc2V0Rm9ybWF0KGZvcm1hdCk7XG5cbiAgICAgICAgaWYgKCFmaXJzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpKSB7XG4gICAgICAgICAgZmlyc3ROb2RlUGFyZW50Lmluc2VydEJlZm9yZShwcmV2U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlyc3ROb2RlLmluc2VydEJlZm9yZShwcmV2U2libGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldlNpYmxpbmcuc2VsZWN0KCk7XG4gICAgICBmaXJzdE5vZGUgPSBwcmV2U2libGluZztcblxuICAgICAgaWYgKHRleHQgIT09ICcnKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0VGV4dCh0ZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmlyc3ROb2RlLmlzU2VnbWVudGVkKCkgJiYgc3RhcnRPZmZzZXQgIT09IGZpcnN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICAgIHRleHROb2RlLnNldEZvcm1hdChmb3JtYXQpO1xuICAgICAgZmlyc3ROb2RlLnJlcGxhY2UodGV4dE5vZGUpO1xuICAgICAgZmlyc3ROb2RlID0gdGV4dE5vZGU7XG4gICAgfSBlbHNlIGlmICghdGhpcy5pc0NvbGxhcHNlZCgpICYmIHRleHQgIT09ICcnKSB7XG4gICAgICAvLyBXaGVuIHRoZSBmaXJzdE5vZGUgb3IgbGFzdE5vZGUgcGFyZW50cyBhcmUgZWxlbWVudHMgdGhhdFxuICAgICAgLy8gZG8gbm90IGFsbG93IHRleHQgdG8gYmUgaW5zZXJ0ZWQgYmVmb3JlIG9yIGFmdGVyLCB3ZSBmaXJzdFxuICAgICAgLy8gY2xlYXIgdGhlIGNvbnRlbnQuIFRoZW4gd2Ugbm9ybWFsaXplIHNlbGVjdGlvbiwgdGhlbiBpbnNlcnRcbiAgICAgIC8vIHRoZSBuZXcgY29udGVudC5cbiAgICAgIGNvbnN0IGxhc3ROb2RlUGFyZW50ID0gbGFzdE5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgICAgIGlmICghZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAhZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRBZnRlcigpIHx8ICRpc0VsZW1lbnROb2RlKGxhc3ROb2RlUGFyZW50KSAmJiAoIWxhc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAhbGFzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEFmdGVyKCkpKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0VGV4dCgnJyk7XG4gICAgICAgIG5vcm1hbGl6ZVNlbGVjdGlvblBvaW50c0ZvckJvdW5kYXJpZXModGhpcy5hbmNob3IsIHRoaXMuZm9jdXMsIG51bGwpO1xuICAgICAgICB0aGlzLmluc2VydFRleHQodGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0ZWROb2Rlc0xlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGZpcnN0Tm9kZS5pc1Rva2VuKCkpIHtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgIHRleHROb2RlLnNlbGVjdCgpO1xuICAgICAgICBmaXJzdE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlyc3ROb2RlRm9ybWF0ID0gZmlyc3ROb2RlLmdldEZvcm1hdCgpO1xuICAgICAgY29uc3QgZmlyc3ROb2RlU3R5bGUgPSBmaXJzdE5vZGUuZ2V0U3R5bGUoKTtcblxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSBlbmRPZmZzZXQgJiYgKGZpcnN0Tm9kZUZvcm1hdCAhPT0gZm9ybWF0IHx8IGZpcnN0Tm9kZVN0eWxlICE9PSBzdHlsZSkpIHtcbiAgICAgICAgaWYgKGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpID09PSAnJykge1xuICAgICAgICAgIGZpcnN0Tm9kZS5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICBmaXJzdE5vZGUuc2V0U3R5bGUoc3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgICAgIHRleHROb2RlLnNldEZvcm1hdChmb3JtYXQpO1xuICAgICAgICAgIHRleHROb2RlLnNldFN0eWxlKHN0eWxlKTtcbiAgICAgICAgICB0ZXh0Tm9kZS5zZWxlY3QoKTtcblxuICAgICAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgZmlyc3ROb2RlLmluc2VydEJlZm9yZSh0ZXh0Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBbdGFyZ2V0Tm9kZV0gPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIHRhcmdldE5vZGUuaW5zZXJ0QWZ0ZXIodGV4dE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICB9IC8vIFdoZW4gY29tcG9zaW5nLCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgYW5jaG9yIG9mZnNldCBzbyB0aGF0XG4gICAgICAgICAgLy8gd2UgY29ycmVjdGx5IHJlcGxhY2UgdGhhdCByaWdodCByYW5nZS5cblxuXG4gICAgICAgICAgaWYgKHRleHROb2RlLmlzQ29tcG9zaW5nKCkgJiYgdGhpcy5hbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvci5vZmZzZXQgLT0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlbENvdW50ID0gZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQ7XG4gICAgICBmaXJzdE5vZGUgPSBmaXJzdE5vZGUuc3BsaWNlVGV4dChzdGFydE9mZnNldCwgZGVsQ291bnQsIHRleHQsIHRydWUpO1xuXG4gICAgICBpZiAoZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCkgPT09ICcnKSB7XG4gICAgICAgIGZpcnN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5hbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGlmIChmaXJzdE5vZGUuaXNDb21wb3NpbmcoKSkge1xuICAgICAgICAgIC8vIFdoZW4gY29tcG9zaW5nLCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgYW5jaG9yIG9mZnNldCBzbyB0aGF0XG4gICAgICAgICAgLy8gd2UgY29ycmVjdGx5IHJlcGxhY2UgdGhhdCByaWdodCByYW5nZS5cbiAgICAgICAgICB0aGlzLmFuY2hvci5vZmZzZXQgLT0gdGV4dC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5mb3JtYXQgPSBmaXJzdE5vZGVGb3JtYXQ7XG4gICAgICAgICAgdGhpcy5zdHlsZSA9IGZpcnN0Tm9kZVN0eWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1hcmtlZE5vZGVLZXlzRm9yS2VlcCA9IG5ldyBTZXQoWy4uLmZpcnN0Tm9kZS5nZXRQYXJlbnRLZXlzKCksIC4uLmxhc3ROb2RlLmdldFBhcmVudEtleXMoKV0pOyAvLyBXZSBoYXZlIHRvIGdldCB0aGUgcGFyZW50IGVsZW1lbnRzIGJlZm9yZSB0aGUgbmV4dCBzZWN0aW9uLFxuICAgICAgLy8gYXMgaW4gdGhhdCBzZWN0aW9uIHdlIG1pZ2h0IG11dGF0ZSB0aGUgbGFzdE5vZGUuXG5cbiAgICAgIGNvbnN0IGZpcnN0RWxlbWVudCA9ICRpc0VsZW1lbnROb2RlKGZpcnN0Tm9kZSkgPyBmaXJzdE5vZGUgOiBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgbGV0IGxhc3RFbGVtZW50ID0gJGlzRWxlbWVudE5vZGUobGFzdE5vZGUpID8gbGFzdE5vZGUgOiBsYXN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBsZXQgbGFzdEVsZW1lbnRDaGlsZCA9IGxhc3ROb2RlOyAvLyBJZiB0aGUgbGFzdCBlbGVtZW50IGlzIGlubGluZSwgd2Ugc2hvdWxkIGluc3RlYWQgbG9vayBhdCBnZXR0aW5nXG4gICAgICAvLyB0aGUgbm9kZXMgb2YgaXRzIHBhcmVudCwgcmF0aGVyIHRoYW4gaXRzZWxmLiBUaGlzIGJlaGF2aW9yIHdpbGxcbiAgICAgIC8vIHRoZW4gYmV0dGVyIG1hdGNoIGhvdyB0ZXh0IG5vZGUgaW5zZXJ0aW9ucyB3b3JrLiBXZSB3aWxsIG5lZWQgdG9cbiAgICAgIC8vIGFsc28gdXBkYXRlIHRoZSBsYXN0IGVsZW1lbnQncyBjaGlsZCBhY2NvcmRpbmdseSBhcyB3ZSBkbyB0aGlzLlxuXG4gICAgICBpZiAoIWZpcnN0RWxlbWVudC5pcyhsYXN0RWxlbWVudCkgJiYgbGFzdEVsZW1lbnQuaXNJbmxpbmUoKSkge1xuICAgICAgICAvLyBLZWVwIHRyYXZlcnNpbmcgdGlsbCB3ZSBoYXZlIGEgbm9uLWlubGluZSBlbGVtZW50IHBhcmVudC5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGxhc3RFbGVtZW50Q2hpbGQgPSBsYXN0RWxlbWVudDtcbiAgICAgICAgICBsYXN0RWxlbWVudCA9IGxhc3RFbGVtZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgfSB3aGlsZSAobGFzdEVsZW1lbnQuaXNJbmxpbmUoKSk7XG4gICAgICB9IC8vIEhhbmRsZSBtdXRhdGlvbnMgdG8gdGhlIGxhc3Qgbm9kZS5cblxuXG4gICAgICBpZiAoZW5kUG9pbnQudHlwZSA9PT0gJ3RleHQnICYmIChlbmRPZmZzZXQgIT09IDAgfHwgbGFzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKSA9PT0gJycpIHx8IGVuZFBvaW50LnR5cGUgPT09ICdlbGVtZW50JyAmJiBsYXN0Tm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpIDwgZW5kT2Zmc2V0KSB7XG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShsYXN0Tm9kZSkgJiYgIWxhc3ROb2RlLmlzVG9rZW4oKSAmJiBlbmRPZmZzZXQgIT09IGxhc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICAgICAgaWYgKGxhc3ROb2RlLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKGxhc3ROb2RlLmdldFRleHRDb250ZW50KCkpO1xuICAgICAgICAgICAgbGFzdE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IHRleHROb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxhc3ROb2RlID0gbGFzdE5vZGUuc3BsaWNlVGV4dCgwLCBlbmRPZmZzZXQsICcnKTtcbiAgICAgICAgICBtYXJrZWROb2RlS2V5c0ZvcktlZXAuYWRkKGxhc3ROb2RlLl9fa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBsYXN0Tm9kZVBhcmVudCA9IGxhc3ROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcblxuICAgICAgICAgIGlmICghbGFzdE5vZGVQYXJlbnQuY2FuQmVFbXB0eSgpICYmIGxhc3ROb2RlUGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID09PSAxKSB7XG4gICAgICAgICAgICBsYXN0Tm9kZVBhcmVudC5yZW1vdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdE5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXJrZWROb2RlS2V5c0ZvcktlZXAuYWRkKGxhc3ROb2RlLl9fa2V5KTtcbiAgICAgIH0gLy8gRWl0aGVyIG1vdmUgdGhlIHJlbWFpbmluZyBub2RlcyBvZiB0aGUgbGFzdCBwYXJlbnQgdG8gYWZ0ZXJcbiAgICAgIC8vIHRoZSBmaXJzdCBjaGlsZCwgb3IgcmVtb3ZlIHRoZW0gZW50aXJlbHkuIElmIHRoZSBsYXN0IHBhcmVudFxuICAgICAgLy8gaXMgdGhlIHNhbWUgYXMgdGhlIGZpcnN0IHBhcmVudCwgdGhpcyBsb2dpYyBhbHNvIHdvcmtzLlxuXG5cbiAgICAgIGNvbnN0IGxhc3ROb2RlQ2hpbGRyZW4gPSBsYXN0RWxlbWVudC5nZXRDaGlsZHJlbigpO1xuICAgICAgY29uc3Qgc2VsZWN0ZWROb2Rlc1NldCA9IG5ldyBTZXQoc2VsZWN0ZWROb2Rlcyk7XG4gICAgICBjb25zdCBmaXJzdEFuZExhc3RFbGVtZW50c0FyZUVxdWFsID0gZmlyc3RFbGVtZW50LmlzKGxhc3RFbGVtZW50KTsgLy8gV2UgY2hvb3NlIGEgdGFyZ2V0IHRvIGluc2VydCBhbGwgbm9kZXMgYWZ0ZXIuIEluIHRoZSBjYXNlIG9mIGhhdmluZ1xuICAgICAgLy8gYW5kIGlubGluZSBzdGFydGluZyBwYXJlbnQgZWxlbWVudCB3aXRoIGEgc3RhcnRpbmcgbm9kZSB0aGF0IGhhcyBub1xuICAgICAgLy8gc2libGluZ3MsIHdlIHNob3VsZCBpbnNlcnQgYWZ0ZXIgdGhlIHN0YXJ0aW5nIHBhcmVudCBlbGVtZW50LCBvdGhlcndpc2VcbiAgICAgIC8vIHdlIHdpbGwgaW5jb3JyZWN0bHkgbWVyZ2UgaW50byB0aGUgc3RhcnRpbmcgcGFyZW50IGVsZW1lbnQuXG4gICAgICAvLyBUT0RPOiBzaG91bGQgd2Uga2VlcCBvbiB0cmF2ZXJzaW5nIHBhcmVudHMgaWYgd2UncmUgaW5zaWRlIGFub3RoZXJcbiAgICAgIC8vIG5lc3RlZCBpbmxpbmUgZWxlbWVudD9cblxuICAgICAgY29uc3QgaW5zZXJ0aW9uVGFyZ2V0ID0gZmlyc3RFbGVtZW50LmlzSW5saW5lKCkgJiYgZmlyc3ROb2RlLmdldE5leHRTaWJsaW5nKCkgPT09IG51bGwgPyBmaXJzdEVsZW1lbnQgOiBmaXJzdE5vZGU7XG5cbiAgICAgIGZvciAobGV0IGkgPSBsYXN0Tm9kZUNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGxhc3ROb2RlQ2hpbGQgPSBsYXN0Tm9kZUNoaWxkcmVuW2ldO1xuXG4gICAgICAgIGlmIChsYXN0Tm9kZUNoaWxkLmlzKGZpcnN0Tm9kZSkgfHwgJGlzRWxlbWVudE5vZGUobGFzdE5vZGVDaGlsZCkgJiYgbGFzdE5vZGVDaGlsZC5pc1BhcmVudE9mKGZpcnN0Tm9kZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYXN0Tm9kZUNoaWxkLmlzQXR0YWNoZWQoKSkge1xuICAgICAgICAgIGlmICghc2VsZWN0ZWROb2Rlc1NldC5oYXMobGFzdE5vZGVDaGlsZCkgfHwgbGFzdE5vZGVDaGlsZC5pcyhsYXN0RWxlbWVudENoaWxkKSkge1xuICAgICAgICAgICAgaWYgKCFmaXJzdEFuZExhc3RFbGVtZW50c0FyZUVxdWFsKSB7XG4gICAgICAgICAgICAgIGluc2VydGlvblRhcmdldC5pbnNlcnRBZnRlcihsYXN0Tm9kZUNoaWxkLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3ROb2RlQ2hpbGQucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZmlyc3RBbmRMYXN0RWxlbWVudHNBcmVFcXVhbCkge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGFscmVhZHkgbW92ZWQgb3V0IGFsbCB0aGUgbm9kZXMgb2YgdGhlXG4gICAgICAgIC8vIGxhc3QgcGFyZW50LCBhbmQgaWYgc28sIHRyYXZlcnNlIHRoZSBwYXJlbnQgdHJlZSBhbmQgbWFya1xuICAgICAgICAvLyB0aGVtIGFsbCBhcyBiZWluZyBhYmxlIHRvIGRlbGV0ZWQgdG9vLlxuICAgICAgICBsZXQgcGFyZW50ID0gbGFzdEVsZW1lbnQ7XG4gICAgICAgIGxldCBsYXN0UmVtb3ZlZFBhcmVudCA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50LmdldENoaWxkcmVuKCk7XG4gICAgICAgICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDAgfHwgY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXS5pcyhsYXN0UmVtb3ZlZFBhcmVudCkpIHtcbiAgICAgICAgICAgIG1hcmtlZE5vZGVLZXlzRm9yS2VlcC5kZWxldGUocGFyZW50Ll9fa2V5KTtcbiAgICAgICAgICAgIGxhc3RSZW1vdmVkUGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBFbnN1cmUgd2UgZG8gc3BsaWNpbmcgYWZ0ZXIgbW92aW5nIG9mIG5vZGVzLCBhcyBzcGxpY2luZ1xuICAgICAgLy8gY2FuIGhhdmUgc2lkZS1lZmZlY3RzIChpbiB0aGUgY2FzZSBvZiBoYXNodGFncykuXG5cblxuICAgICAgaWYgKCFmaXJzdE5vZGUuaXNUb2tlbigpKSB7XG4gICAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZS5zcGxpY2VUZXh0KHN0YXJ0T2Zmc2V0LCBmaXJzdE5vZGVUZXh0TGVuZ3RoIC0gc3RhcnRPZmZzZXQsIHRleHQsIHRydWUpO1xuXG4gICAgICAgIGlmIChmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnQoKSA9PT0gJycpIHtcbiAgICAgICAgICBmaXJzdE5vZGUucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3ROb2RlLmlzQ29tcG9zaW5nKCkgJiYgdGhpcy5hbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgLy8gV2hlbiBjb21wb3NpbmcsIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBhbmNob3Igb2Zmc2V0IHNvIHRoYXRcbiAgICAgICAgICAvLyB3ZSBjb3JyZWN0bHkgcmVwbGFjZSB0aGF0IHJpZ2h0IHJhbmdlLlxuICAgICAgICAgIHRoaXMuYW5jaG9yLm9mZnNldCAtPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlVGV4dExlbmd0aCkge1xuICAgICAgICBmaXJzdE5vZGUuc2VsZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgdGV4dE5vZGUuc2VsZWN0KCk7XG4gICAgICAgIGZpcnN0Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgIH0gLy8gUmVtb3ZlIGFsbCBzZWxlY3RlZCBub2RlcyB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHJlbW92ZWQuXG5cblxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZWxlY3RlZE5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gc2VsZWN0ZWROb2Rlc1tpXTtcbiAgICAgICAgY29uc3Qga2V5ID0gc2VsZWN0ZWROb2RlLl9fa2V5O1xuXG4gICAgICAgIGlmICghbWFya2VkTm9kZUtleXNGb3JLZWVwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgc2VsZWN0ZWROb2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSB0ZXh0IGluIHRoZSBTZWxlY3Rpb24sIGFkanVzdGluZyB0aGUgRWRpdG9yU3RhdGUgYWNjb3JkaW5nbHkuXG4gICAqL1xuXG5cbiAgcmVtb3ZlVGV4dCgpIHtcbiAgICB0aGlzLmluc2VydFRleHQoJycpO1xuICB9XG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBwcm92aWRlZCBmb3JtYXQgdG8gdGhlIFRleHROb2RlcyBpbiB0aGUgU2VsZWN0aW9uLCBzcGxpdHRpbmcgb3JcbiAgICogbWVyZ2luZyBub2RlcyBhcyBuZWNlc3NhcnkuXG4gICAqXG4gICAqIEBwYXJhbSBmb3JtYXRUeXBlIHRoZSBmb3JtYXQgdHlwZSB0byBhcHBseSB0byB0aGUgbm9kZXMgaW4gdGhlIFNlbGVjdGlvbi5cbiAgICovXG5cblxuICBmb3JtYXRUZXh0KGZvcm1hdFR5cGUpIHtcbiAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICB0aGlzLnRvZ2dsZUZvcm1hdChmb3JtYXRUeXBlKTsgLy8gV2hlbiBjaGFuZ2luZyBmb3JtYXQsIHdlIHNob3VsZCBzdG9wIGNvbXBvc2l0aW9uXG5cbiAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgIGNvbnN0IHNlbGVjdGVkVGV4dE5vZGVzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHNlbGVjdGVkTm9kZSBvZiBzZWxlY3RlZE5vZGVzKSB7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoc2VsZWN0ZWROb2RlKSkge1xuICAgICAgICBzZWxlY3RlZFRleHROb2Rlcy5wdXNoKHNlbGVjdGVkTm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0ZWRUZXh0Tm9kZXNMZW5ndGggPSBzZWxlY3RlZFRleHROb2Rlcy5sZW5ndGg7XG5cbiAgICBpZiAoc2VsZWN0ZWRUZXh0Tm9kZXNMZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMudG9nZ2xlRm9ybWF0KGZvcm1hdFR5cGUpOyAvLyBXaGVuIGNoYW5naW5nIGZvcm1hdCwgd2Ugc2hvdWxkIHN0b3AgY29tcG9zaXRpb25cblxuICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBpc0JhY2t3YXJkID0gdGhpcy5pc0JhY2t3YXJkKCk7XG4gICAgY29uc3Qgc3RhcnRQb2ludCA9IGlzQmFja3dhcmQgPyBmb2N1cyA6IGFuY2hvcjtcbiAgICBjb25zdCBlbmRQb2ludCA9IGlzQmFja3dhcmQgPyBhbmNob3IgOiBmb2N1cztcbiAgICBsZXQgZmlyc3RJbmRleCA9IDA7XG4gICAgbGV0IGZpcnN0Tm9kZSA9IHNlbGVjdGVkVGV4dE5vZGVzWzBdO1xuICAgIGxldCBzdGFydE9mZnNldCA9IHN0YXJ0UG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnID8gMCA6IHN0YXJ0UG9pbnQub2Zmc2V0OyAvLyBJbiBjYXNlIHNlbGVjdGlvbiBzdGFydGVkIGF0IHRoZSBlbmQgb2YgdGV4dCBub2RlIHVzZSBuZXh0IHRleHQgbm9kZVxuXG4gICAgaWYgKHN0YXJ0UG9pbnQudHlwZSA9PT0gJ3RleHQnICYmIHN0YXJ0T2Zmc2V0ID09PSBmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgIGZpcnN0SW5kZXggPSAxO1xuICAgICAgZmlyc3ROb2RlID0gc2VsZWN0ZWRUZXh0Tm9kZXNbMV07XG4gICAgICBzdGFydE9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0Tm9kZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3ROZXh0Rm9ybWF0ID0gZmlyc3ROb2RlLmdldEZvcm1hdEZsYWdzKGZvcm1hdFR5cGUsIG51bGwpO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IHNlbGVjdGVkVGV4dE5vZGVzTGVuZ3RoIC0gMTtcbiAgICBsZXQgbGFzdE5vZGUgPSBzZWxlY3RlZFRleHROb2Rlc1tsYXN0SW5kZXhdO1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IGVuZFBvaW50LnR5cGUgPT09ICd0ZXh0JyA/IGVuZFBvaW50Lm9mZnNldCA6IGxhc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpOyAvLyBTaW5nbGUgbm9kZSBzZWxlY3RlZFxuXG4gICAgaWYgKGZpcnN0Tm9kZS5pcyhsYXN0Tm9kZSkpIHtcbiAgICAgIC8vIE5vIGFjdHVhbCB0ZXh0IGlzIHNlbGVjdGVkLCBzbyBkbyBub3RoaW5nLlxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSBlbmRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUaGUgZW50aXJlIG5vZGUgaXMgc2VsZWN0ZWQsIHNvIGp1c3QgZm9ybWF0IGl0XG5cblxuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAwICYmIGVuZE9mZnNldCA9PT0gZmlyc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICAgIGZpcnN0Tm9kZS5zZXRGb3JtYXQoZmlyc3ROZXh0Rm9ybWF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vZGUgaXMgcGFydGlhbGx5IHNlbGVjdGVkLCBzbyBzcGxpdCBpdCBpbnRvIHR3byBub2Rlc1xuICAgICAgICAvLyBhZGQgc3R5bGUgdGhlIHNlbGVjdGVkIG9uZS5cbiAgICAgICAgY29uc3Qgc3BsaXROb2RlcyA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gc3RhcnRPZmZzZXQgPT09IDAgPyBzcGxpdE5vZGVzWzBdIDogc3BsaXROb2Rlc1sxXTtcbiAgICAgICAgcmVwbGFjZW1lbnQuc2V0Rm9ybWF0KGZpcnN0TmV4dEZvcm1hdCk7IC8vIFVwZGF0ZSBzZWxlY3Rpb24gb25seSBpZiBzdGFydHMvZW5kcyBvbiB0ZXh0IG5vZGVcblxuICAgICAgICBpZiAoc3RhcnRQb2ludC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBzdGFydFBvaW50LnNldChyZXBsYWNlbWVudC5fX2tleSwgMCwgJ3RleHQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmRQb2ludC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBlbmRQb2ludC5zZXQocmVwbGFjZW1lbnQuX19rZXksIGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZm9ybWF0ID0gZmlyc3ROZXh0Rm9ybWF0O1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gTXVsdGlwbGUgbm9kZXMgc2VsZWN0ZWRcbiAgICAvLyBUaGUgZW50aXJlIGZpcnN0IG5vZGUgaXNuJ3Qgc2VsZWN0ZWQsIHNvIHNwbGl0IGl0XG5cblxuICAgIGlmIChzdGFydE9mZnNldCAhPT0gMCkge1xuICAgICAgWywgZmlyc3ROb2RlXSA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQpO1xuICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGZpcnN0Tm9kZS5zZXRGb3JtYXQoZmlyc3ROZXh0Rm9ybWF0KTtcbiAgICBjb25zdCBsYXN0TmV4dEZvcm1hdCA9IGxhc3ROb2RlLmdldEZvcm1hdEZsYWdzKGZvcm1hdFR5cGUsIGZpcnN0TmV4dEZvcm1hdCk7IC8vIElmIHRoZSBvZmZzZXQgaXMgMCwgaXQgbWVhbnMgbm8gYWN0dWFsIGNoYXJhY3RlcnMgYXJlIHNlbGVjdGVkLFxuICAgIC8vIHNvIHdlIHNraXAgZm9ybWF0dGluZyB0aGUgbGFzdCBub2RlIGFsdG9nZXRoZXIuXG5cbiAgICBpZiAoZW5kT2Zmc2V0ID4gMCkge1xuICAgICAgaWYgKGVuZE9mZnNldCAhPT0gbGFzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgICAgW2xhc3ROb2RlXSA9IGxhc3ROb2RlLnNwbGl0VGV4dChlbmRPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICBsYXN0Tm9kZS5zZXRGb3JtYXQobGFzdE5leHRGb3JtYXQpO1xuICAgIH0gLy8gUHJvY2VzcyBhbGwgdGV4dCBub2RlcyBpbiBiZXR3ZWVuXG5cblxuICAgIGZvciAobGV0IGkgPSBmaXJzdEluZGV4ICsgMTsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0Tm9kZSA9IHNlbGVjdGVkVGV4dE5vZGVzW2ldO1xuXG4gICAgICBpZiAoIXRleHROb2RlLmlzVG9rZW4oKSkge1xuICAgICAgICBjb25zdCBuZXh0Rm9ybWF0ID0gdGV4dE5vZGUuZ2V0Rm9ybWF0RmxhZ3MoZm9ybWF0VHlwZSwgbGFzdE5leHRGb3JtYXQpO1xuICAgICAgICB0ZXh0Tm9kZS5zZXRGb3JtYXQobmV4dEZvcm1hdCk7XG4gICAgICB9XG4gICAgfSAvLyBVcGRhdGUgc2VsZWN0aW9uIG9ubHkgaWYgc3RhcnRzL2VuZHMgb24gdGV4dCBub2RlXG5cblxuICAgIGlmIChzdGFydFBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgc3RhcnRQb2ludC5zZXQoZmlyc3ROb2RlLl9fa2V5LCBzdGFydE9mZnNldCwgJ3RleHQnKTtcbiAgICB9XG5cbiAgICBpZiAoZW5kUG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBlbmRQb2ludC5zZXQobGFzdE5vZGUuX19rZXksIGVuZE9mZnNldCwgJ3RleHQnKTtcbiAgICB9XG5cbiAgICB0aGlzLmZvcm1hdCA9IGZpcnN0TmV4dEZvcm1hdCB8IGxhc3ROZXh0Rm9ybWF0O1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBcImludGVsbGlnZW50bHlcIiBpbnNlcnQgYW4gYXJiaXRyYXJ5IGxpc3Qgb2YgTGV4aWNhbCBub2RlcyBpbnRvIHRoZSBFZGl0b3JTdGF0ZSBhdCB0aGVcbiAgICogY3VycmVudCBTZWxlY3Rpb24gYWNjb3JkaW5nIHRvIGEgc2V0IG9mIGhldXJpc3RpY3MgdGhhdCBkZXRlcm1pbmUgaG93IHN1cnJvdW5kaW5nIG5vZGVzXG4gICAqIHNob3VsZCBiZSBjaGFuZ2VkLCByZXBsYWNlZCwgb3IgbW92ZWQgdG8gYWNjb21vZGF0ZSB0aGUgaW5jb21pbmcgb25lcy5cbiAgICpcbiAgICogQHBhcmFtIG5vZGVzIC0gdGhlIG5vZGVzIHRvIGluc2VydFxuICAgKiBAcGFyYW0gc2VsZWN0U3RhcnQgLSB3aGV0aGVyIG9yIG5vdCB0byBzZWxlY3QgdGhlIHN0YXJ0IGFmdGVyIHRoZSBpbnNlcnRpb24uXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGVzIHdlcmUgaW5zZXJ0ZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgaW5zZXJ0Tm9kZXMobm9kZXMsIHNlbGVjdFN0YXJ0KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYSByYW5nZSBzZWxlY3RlZCByZW1vdmUgdGhlIHRleHQgaW4gaXRcbiAgICBpZiAoIXRoaXMuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uRW5kID0gdGhpcy5pc0JhY2t3YXJkKCkgPyB0aGlzLmFuY2hvciA6IHRoaXMuZm9jdXM7XG4gICAgICBjb25zdCBuZXh0U2libGluZyA9IHNlbGVjdGlvbkVuZC5nZXROb2RlKCkuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nS2V5ID0gbmV4dFNpYmxpbmcgPyBuZXh0U2libGluZy5nZXRLZXkoKSA6IG51bGw7XG4gICAgICBjb25zdCBwcmV2U2libGluZyA9IHNlbGVjdGlvbkVuZC5nZXROb2RlKCkuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBjb25zdCBwcmV2U2libGluZ0tleSA9IHByZXZTaWJsaW5nID8gcHJldlNpYmxpbmcuZ2V0S2V5KCkgOiBudWxsO1xuICAgICAgdGhpcy5yZW1vdmVUZXh0KCk7IC8vIElmIHRoZSBzZWxlY3Rpb24gaGFzIGJlZW4gbW92ZWQgdG8gYW4gYWRqYWNlbnQgaW5saW5lIGVsZW1lbnQsIGNyZWF0ZVxuICAgICAgLy8gYSB0ZW1wb3JhcnkgdGV4dCBub2RlIHRoYXQgd2UgY2FuIGluc2VydCB0aGUgbm9kZXMgYWZ0ZXIuXG5cbiAgICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkgJiYgdGhpcy5mb2N1cy50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgICAgbGV0IHRleHROb2RlO1xuXG4gICAgICAgIGlmICh0aGlzLmZvY3VzLmtleSA9PT0gbmV4dFNpYmxpbmdLZXkgJiYgdGhpcy5mb2N1cy5vZmZzZXQgPT09IDApIHtcbiAgICAgICAgICB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMuZm9jdXMuZ2V0Tm9kZSgpLmluc2VydEJlZm9yZSh0ZXh0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5mb2N1cy5rZXkgPT09IHByZXZTaWJsaW5nS2V5ICYmIHRoaXMuZm9jdXMub2Zmc2V0ID09PSB0aGlzLmZvY3VzLmdldE5vZGUoKS5nZXRDaGlsZHJlblNpemUoKSkge1xuICAgICAgICAgIHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKCk7XG4gICAgICAgICAgdGhpcy5mb2N1cy5nZXROb2RlKCkuaW5zZXJ0QWZ0ZXIodGV4dE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHROb2RlKSB7XG4gICAgICAgICAgdGhpcy5mb2N1cy5zZXQodGV4dE5vZGUuX19rZXksIDAsICd0ZXh0Jyk7XG4gICAgICAgICAgdGhpcy5hbmNob3Iuc2V0KHRleHROb2RlLl9fa2V5LCAwLCAndGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBsZXQgdGFyZ2V0ID0gYW5jaG9yTm9kZTtcblxuICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IHBsYWNlbWVudE5vZGUgPSBlbGVtZW50LmdldENoaWxkQXRJbmRleChhbmNob3JPZmZzZXQgLSAxKTtcblxuICAgICAgaWYgKHBsYWNlbWVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0ID0gZWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldCA9IHBsYWNlbWVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2libGluZ3MgPSBbXTsgLy8gR2V0IGFsbCByZW1haW5pbmcgdGV4dCBub2RlIHNpYmxpbmdzIGluIHRoaXMgZWxlbWVudCBzbyB3ZSBjYW5cbiAgICAvLyBhcHBlbmQgdGhlbSBhZnRlciB0aGUgbGFzdCBub2RlIHdlJ3JlIGluc2VydGluZy5cblxuICAgIGNvbnN0IG5leHRTaWJsaW5ncyA9IGFuY2hvck5vZGUuZ2V0TmV4dFNpYmxpbmdzKCk7XG4gICAgY29uc3QgdG9wTGV2ZWxFbGVtZW50ID0gJGlzUm9vdE9yU2hhZG93Um9vdChhbmNob3JOb2RlKSA/IG51bGwgOiBhbmNob3JOb2RlLmdldFRvcExldmVsRWxlbWVudE9yVGhyb3coKTtcblxuICAgIGlmICgkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCB0ZXh0Q29udGVudExlbmd0aCA9IHRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKGFuY2hvck9mZnNldCA9PT0gMCAmJiB0ZXh0Q29udGVudExlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBwcmV2U2libGluZyA9IGFuY2hvck5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICAgICAgaWYgKHByZXZTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gcHJldlNpYmxpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0ID0gYW5jaG9yTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgIH1cblxuICAgICAgICBzaWJsaW5ncy5wdXNoKGFuY2hvck5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChhbmNob3JPZmZzZXQgPT09IHRleHRDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgIHRhcmdldCA9IGFuY2hvck5vZGU7XG4gICAgICB9IGVsc2UgaWYgKGFuY2hvck5vZGUuaXNUb2tlbigpKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgd2UncmUgaW5zaWRlIGEgdG9rZW4gbm9kZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB3ZSBzdGFydGVkIHdpdGggYSByYW5nZSBzZWxlY3RlZCBncmFiIHRoZSBkYW5nbGluZ1RleHQgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGVuZCBvZiB0aGUgc2VsZWN0aW9uIGFuZCBwdXQgaXQgb24gb3VyIHNpYmxpbmdzIGFycmF5IHNvIHdlIGNhblxuICAgICAgICAvLyBhcHBlbmQgaXQgYWZ0ZXIgdGhlIGxhc3Qgbm9kZSB3ZSdyZSBpbnNlcnRpbmdcbiAgICAgICAgbGV0IGRhbmdsaW5nVGV4dDtcbiAgICAgICAgW3RhcmdldCwgZGFuZ2xpbmdUZXh0XSA9IGFuY2hvck5vZGUuc3BsaXRUZXh0KGFuY2hvck9mZnNldCk7XG4gICAgICAgIHNpYmxpbmdzLnB1c2goZGFuZ2xpbmdUZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdGFydGluZ05vZGUgPSB0YXJnZXQ7XG4gICAgc2libGluZ3MucHVzaCguLi5uZXh0U2libGluZ3MpO1xuICAgIGNvbnN0IGZpcnN0Tm9kZSA9IG5vZGVzWzBdO1xuICAgIGxldCBkaWRSZXBsYWNlT3JNZXJnZSA9IGZhbHNlO1xuICAgIGxldCBsYXN0Tm9kZSA9IG51bGw7IC8vIFRpbWUgdG8gaW5zZXJ0IHRoZSBub2RlcyFcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgaWYgKCEkaXNSb290T3JTaGFkb3dSb290KHRhcmdldCkgJiYgISRpc0RlY29yYXRvck5vZGUodGFyZ2V0KSAmJiAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhbm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAgIC8vIC0tLS0tXG4gICAgICAgIC8vIEhldXJpc3RpY3MgZm9yIHRoZSByZXBsYWNlbWVudCBvciBtZXJnaW5nIG9mIGVsZW1lbnRzXG4gICAgICAgIC8vIC0tLS0tXG4gICAgICAgIC8vIElmIHdlIGhhdmUgYW4gaW5jb21pbmcgZWxlbWVudCBub2RlIGFzIHRoZSBmaXJzdCBub2RlLCB0aGVuIHdlJ2xsIG5lZWRcbiAgICAgICAgLy8gc2VlIGlmIHdlIGNhbiBtZXJnZSBhbnkgZGVzY2VuZGFudCBsZWFmIG5vZGVzIGludG8gb3VyIGV4aXN0aW5nIHRhcmdldC5cbiAgICAgICAgLy8gV2UgY2FuIGRvIHRoaXMgYnkgZmluZGluZyB0aGUgZmlyc3QgZGVzY2VuZGFudCBpbiBvdXIgbm9kZSBhbmQgdGhlbiB3ZSBjYW5cbiAgICAgICAgLy8gcGx1Y2sgaXQgYW5kIGl0cyBwYXJlbnQgKHNpYmxpbmdzIGluY2x1ZGVkKSBvdXQgYW5kIGluc2VydCB0aGVtIGRpcmVjdGx5XG4gICAgICAgIC8vIGludG8gb3VyIHRhcmdldC4gV2Ugb25seSBkbyB0aGlzIGZvciB0aGUgZmlyc3Qgbm9kZSwgYXMgd2UgYXJlIG9ubHlcbiAgICAgICAgLy8gaW50ZXJlc3RlZCBpbiBtZXJnaW5nIHdpdGggdGhlIGFuY2hvciwgd2hpY2ggaXMgb3VyIHRhcmdldC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgd2UgYXBwbHkgZWl0aGVyIHRoZSByZXBsYWNlbWVudCBvciBtZXJnaW5nIGhldXJpc3RpY3MsIHdlIG5lZWQgdG8gYmVcbiAgICAgICAgLy8gY2FyZWZ1bCB0aGF0IHdlJ3JlIG5vdCB0cnlpbmcgdG8gaW5zZXJ0IGEgbm9uLWVsZW1lbnQgbm9kZSBpbnRvIGEgcm9vdCBub2RlLFxuICAgICAgICAvLyBzbyB3ZSBjaGVjayBpZiB0aGUgdGFyZ2V0J3MgcGFyZW50IGFmdGVyIHRoaXMgbG9naWMgaXMgdGhlIHJvb3Qgbm9kZSBhbmQgaWZcbiAgICAgICAgLy8gc28gd2UgdHJpZ2dlciBhbiBpbnZhcmlhbnQgdG8gZW5zdXJlIHRoaXMgcHJvYmxlbSBpcyBjYXVnaHQgaW4gZGV2ZWxvcG1lbnRcbiAgICAgICAgLy8gYW5kIGZpeGVkIGFjY29yZGluZ2x5LlxuICAgICAgICBpZiAobm9kZS5pcyhmaXJzdE5vZGUpKSB7XG4gICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHRhcmdldCkgJiYgdGFyZ2V0LmlzRW1wdHkoKSAmJiB0YXJnZXQuY2FuUmVwbGFjZVdpdGgobm9kZSkpIHtcbiAgICAgICAgICAgIHRhcmdldC5yZXBsYWNlKG5vZGUpO1xuICAgICAgICAgICAgdGFyZ2V0ID0gbm9kZTtcbiAgICAgICAgICAgIGRpZFJlcGxhY2VPck1lcmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gV2UgbWF5IGhhdmUgYSBub2RlIHRyZWUgd2hlcmUgdGhlcmUgYXJlIG1hbnkgbGV2ZWxzLCBmb3IgZXhhbXBsZSB3aXRoXG4gICAgICAgICAgLy8gbGlzdHMgYW5kIHRhYmxlcy4gU28gbGV0J3MgZmluZCB0aGUgZmlyc3QgZGVzY2VuZGFudCB0byB0cnkgYW5kIG1lcmdlXG4gICAgICAgICAgLy8gd2l0aC4gU28gaWYgd2UgaGF2ZSB0aGUgdGFyZ2V0OlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gUGFyYWdyYXBoICgxKVxuICAgICAgICAgIC8vICAgVGV4dCAoMilcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIGFuZCB3ZSBhcmUgdHJ5aW5nIHRvIGluc2VydDpcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIExpc3ROb2RlICgzKVxuICAgICAgICAgIC8vICAgTGlzdEl0ZW1Ob2RlICg0KVxuICAgICAgICAgIC8vICAgICBUZXh0ICg1KVxuICAgICAgICAgIC8vICAgTGlzdEl0ZW1Ob2RlICg2KVxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVGhlIHJlc3VsdCB3b3VsZCBiZTpcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFBhcmFncmFwaCAoMSlcbiAgICAgICAgICAvLyAgIFRleHQgKDIpXG4gICAgICAgICAgLy8gICBUZXh0ICg1KVxuICAgICAgICAgIC8vXG5cblxuICAgICAgICAgIGNvbnN0IGZpcnN0RGVzY2VuZGFudCA9IG5vZGUuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG5cbiAgICAgICAgICBpZiAoJGlzTGVhZk5vZGUoZmlyc3REZXNjZW5kYW50KSkge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBmaXJzdERlc2NlbmRhbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gICAgICAgICAgICB3aGlsZSAoZWxlbWVudC5pc0lubGluZSgpKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBlbGVtZW50LmdldENoaWxkcmVuKCk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgbGV0IGZpcnN0Q2hpbGQgPSB0YXJnZXQuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgY2hpbGRyZW5MZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5bc107XG5cbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QWZ0ZXIoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZpcnN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgcyA9IGNoaWxkcmVuTGVuZ3RoIC0gMTsgcyA+PSAwOyBzLS0pIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIoY2hpbGRyZW5bc10pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdE5vZGUgPSBjaGlsZHJlbltjaGlsZHJlbkxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICAgIGRpZFJlcGxhY2VPck1lcmdlID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuaXMobm9kZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRpc1RleHROb2RlKHRhcmdldCkpIHtcbiAgICAgICAgICBpZiAodG9wTGV2ZWxFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKGBpbnNlcnROb2RlOiB0b3BMZXZlbEVsZW1lbnQgaXMgcm9vdCBub2RlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGFyZ2V0ID0gdG9wTGV2ZWxFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRpZFJlcGxhY2VPck1lcmdlICYmICEkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhJGlzRGVjb3JhdG9yTm9kZShub2RlKSAmJiAkaXNSb290T3JTaGFkb3dSb290KHRhcmdldC5nZXRQYXJlbnQoKSkpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKGBpbnNlcnROb2RlczogY2Fubm90IGluc2VydCBhIG5vbi1lbGVtZW50IGludG8gYSByb290IG5vZGVgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkaWRSZXBsYWNlT3JNZXJnZSA9IGZhbHNlO1xuXG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUodGFyZ2V0KSAmJiAhdGFyZ2V0LmlzSW5saW5lKCkpIHtcbiAgICAgICAgbGFzdE5vZGUgPSBub2RlO1xuXG4gICAgICAgIGlmICgkaXNEZWNvcmF0b3JOb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaW5zZXJ0QWZ0ZXIobm9kZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0YXJnZXQuZ2V0Rmlyc3RDaGlsZCgpO1xuXG4gICAgICAgICAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQuYXBwZW5kKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhcmdldCA9IG5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFub2RlLmNhbkJlRW1wdHkoKSAmJiBub2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCRpc1Jvb3ROb2RlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlbWVudE5vZGUgPSB0YXJnZXQuZ2V0Q2hpbGRBdEluZGV4KGFuY2hvck9mZnNldCk7XG5cbiAgICAgICAgICAgIGlmIChwbGFjZW1lbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBsYWNlbWVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZChub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFyZ2V0ID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFwcGVuZChub2RlKTtcbiAgICAgICAgICAgIHRhcmdldCA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5pbnNlcnRBZnRlcihub2RlLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSB8fCAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCkgfHwgJGlzRGVjb3JhdG9yTm9kZSh0YXJnZXQpICYmICF0YXJnZXQuaXNJbmxpbmUoKSkge1xuICAgICAgICBsYXN0Tm9kZSA9IG5vZGU7IC8vIHdoZW4gcGFzdGluZyB0b3AgbGV2ZWwgbm9kZSBpbiB0aGUgbWlkZGxlIG9mIHBhcmFncmFwaFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHNwbGl0IHBhcmFncmFwaCBpbnN0ZWFkIG9mIHBsYWNpbmcgaXQgaW5saW5lXG5cbiAgICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHRoaXMpICYmICRpc0RlY29yYXRvck5vZGUobm9kZSkgJiYgKCRpc0VsZW1lbnROb2RlKHRhcmdldCkgfHwgJGlzVGV4dE5vZGUodGFyZ2V0KSkgJiYgIW5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICAgIGxldCBzcGxpdE5vZGU7XG4gICAgICAgICAgbGV0IHNwbGl0T2Zmc2V0O1xuXG4gICAgICAgICAgaWYgKCRpc1RleHROb2RlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHNwbGl0Tm9kZSA9IHRhcmdldC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgICAgICBjb25zdCBbdGV4dE5vZGVdID0gdGFyZ2V0LnNwbGl0VGV4dChhbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgc3BsaXRPZmZzZXQgPSB0ZXh0Tm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3BsaXROb2RlID0gdGFyZ2V0O1xuICAgICAgICAgICAgc3BsaXRPZmZzZXQgPSBhbmNob3JPZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgWywgcmlnaHRUcmVlXSA9ICRzcGxpdE5vZGUoc3BsaXROb2RlLCBzcGxpdE9mZnNldCk7XG4gICAgICAgICAgdGFyZ2V0ID0gcmlnaHRUcmVlLmluc2VydEJlZm9yZShub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaW5zZXJ0QWZ0ZXIobm9kZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXh0VGFyZ2V0ID0gdGFyZ2V0LmdldFBhcmVudE9yVGhyb3coKTsgLy8gaWYgd2UncmUgaW5zZXJ0aW5nIGFuIEVsZW1lbnQgYWZ0ZXIgYSBMaW5lQnJlYWssIHdlIHdhbnQgdG8gbW92ZSB0aGUgdGFyZ2V0IHRvIHRoZSBwYXJlbnRcbiAgICAgICAgLy8gYW5kIHJlbW92ZSB0aGUgTGluZUJyZWFrIHNvIHdlIGRvbid0IGhhdmUgZW1wdHkgc3BhY2UuXG5cbiAgICAgICAgaWYgKCRpc0xpbmVCcmVha05vZGUodGFyZ2V0KSkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCA9IG5leHRUYXJnZXQ7IC8vIFJlLXRyeSBhZ2FpbiB3aXRoIHRoZSB0YXJnZXQgYmVpbmcgdGhlIHBhcmVudFxuXG4gICAgICAgIGktLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdFN0YXJ0KSB7XG4gICAgICAvLyBIYW5kbGUgbW92aW5nIHNlbGVjdGlvbiB0byBzdGFydCBmb3IgYWxsIG5vZGVzXG4gICAgICBpZiAoJGlzVGV4dE5vZGUoc3RhcnRpbmdOb2RlKSkge1xuICAgICAgICBzdGFydGluZ05vZGUuc2VsZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcmV2U2libGluZyA9IHRhcmdldC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgICAgICBpZiAoJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICAgICAgcHJldlNpYmxpbmcuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0YXJnZXQuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICAgICB0YXJnZXQuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdChpbmRleCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKHRhcmdldCkpIHtcbiAgICAgIC8vIElmIHRoZSBsYXN0IG5vZGUgdG8gYmUgaW5zZXJ0ZWQgd2FzIGEgdGV4dCBub2RlLFxuICAgICAgLy8gdGhlbiB3ZSBzaG91bGQgYXR0ZW1wdCB0byBtb3ZlIHNlbGVjdGlvbiB0byB0aGF0LlxuICAgICAgY29uc3QgbGFzdENoaWxkID0gJGlzVGV4dE5vZGUobGFzdE5vZGUpID8gbGFzdE5vZGUgOiAkaXNFbGVtZW50Tm9kZShsYXN0Tm9kZSkgJiYgbGFzdE5vZGUuaXNJbmxpbmUoKSA/IGxhc3ROb2RlLmdldExhc3REZXNjZW5kYW50KCkgOiB0YXJnZXQuZ2V0TGFzdERlc2NlbmRhbnQoKTtcblxuICAgICAgaWYgKCFzZWxlY3RTdGFydCkge1xuICAgICAgICAvLyBIYW5kbGUgbW92aW5nIHNlbGVjdGlvbiB0byBlbmQgZm9yIGVsZW1lbnRzXG4gICAgICAgIGlmIChsYXN0Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICB0YXJnZXQuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoJGlzVGV4dE5vZGUobGFzdENoaWxkKSkge1xuICAgICAgICAgIGlmIChsYXN0Q2hpbGQuZ2V0VGV4dENvbnRlbnQoKSA9PT0gJycpIHtcbiAgICAgICAgICAgIGxhc3RDaGlsZC5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0Q2hpbGQuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RDaGlsZC5zZWxlY3ROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNpYmxpbmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFRhcmdldCA9IHRhcmdldDtcblxuICAgICAgICBmb3IgKGxldCBpID0gc2libGluZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gc2libGluZ3NbaV07XG4gICAgICAgICAgY29uc3QgcHJldlBhcmVudCA9IHNpYmxpbmcuZ2V0UGFyZW50T3JUaHJvdygpO1xuXG4gICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHRhcmdldCkgJiYgISRpc0Jsb2NrRWxlbWVudE5vZGUoc2libGluZykgJiYgISgkaXNEZWNvcmF0b3JOb2RlKHNpYmxpbmcpICYmICggLy8gTm90ZTogV2UgYXJlIG9ubHkgbG9va2luZyBmb3IgZGVjb3JhdG9ycyB0aGF0IGFyZSBpbmxpbmUgYW5kIG5vdCBpc29sYXRlZC5cbiAgICAgICAgICAhc2libGluZy5pc0lubGluZSgpIHx8IHNpYmxpbmcuaXNJc29sYXRlZCgpKSkpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbFRhcmdldCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHRhcmdldC5hcHBlbmQoc2libGluZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0YXJnZXQgPSBzaWJsaW5nO1xuICAgICAgICAgIH0gZWxzZSBpZiAoISRpc0VsZW1lbnROb2RlKHRhcmdldCkgJiYgISRpc0Jsb2NrRWxlbWVudE5vZGUoc2libGluZykpIHtcbiAgICAgICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoc2libGluZyk7XG4gICAgICAgICAgICB0YXJnZXQgPSBzaWJsaW5nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoc2libGluZykgJiYgIXNpYmxpbmcuY2FuSW5zZXJ0QWZ0ZXIodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRoZSBjbG9uZSBtZXRob2QgZG9lcyBleGlzdCBvbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgICAgIGNvbnN0IHByZXZQYXJlbnRDbG9uZSA9IHByZXZQYXJlbnQuY29uc3RydWN0b3IuY2xvbmUocHJldlBhcmVudCk7XG5cbiAgICAgICAgICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShwcmV2UGFyZW50Q2xvbmUpKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYGluc2VydE5vZGVzOiBjbG9uZWQgcGFyZW50IGNsb25lIGlzIG5vdCBhbiBlbGVtZW50YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcHJldlBhcmVudENsb25lLmFwcGVuZChzaWJsaW5nKTtcbiAgICAgICAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKHByZXZQYXJlbnRDbG9uZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIoc2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBDaGVjayBpZiB0aGUgcHJldiBwYXJlbnQgaXMgZW1wdHksIGFzIGl0IG1pZ2h0IG5lZWRcbiAgICAgICAgICAvLyByZW1vdmluZy5cblxuXG4gICAgICAgICAgaWYgKHByZXZQYXJlbnQuaXNFbXB0eSgpICYmICFwcmV2UGFyZW50LmNhbkJlRW1wdHkoKSkge1xuICAgICAgICAgICAgcHJldlBhcmVudC5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFzZWxlY3RTdGFydCkge1xuICAgICAgLy8gSGFuZGxlIG1vdmluZyBzZWxlY3Rpb24gdG8gZW5kIGZvciBvdGhlciBub2Rlc1xuICAgICAgaWYgKCRpc1RleHROb2RlKHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0LnNlbGVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRhcmdldC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGFyZ2V0LmdldEluZGV4V2l0aGluUGFyZW50KCkgKyAxO1xuICAgICAgICBlbGVtZW50LnNlbGVjdChpbmRleCwgaW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnRzIGEgbmV3IFBhcmFncmFwaE5vZGUgaW50byB0aGUgRWRpdG9yU3RhdGUgYXQgdGhlIGN1cnJlbnQgU2VsZWN0aW9uXG4gICAqL1xuXG5cbiAgaW5zZXJ0UGFyYWdyYXBoKCkge1xuICAgIGlmICghdGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICB0aGlzLnJlbW92ZVRleHQoKTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICBjb25zdCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgIGxldCBjdXJyZW50RWxlbWVudDtcbiAgICBsZXQgbm9kZXNUb01vdmUgPSBbXTtcbiAgICBsZXQgc2libGluZ3NUb01vdmUgPSBbXTtcblxuICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIG5vZGVzVG9Nb3ZlID0gYW5jaG9yTm9kZS5nZXROZXh0U2libGluZ3MoKS5yZXZlcnNlKCk7XG4gICAgICBjdXJyZW50RWxlbWVudCA9IGFuY2hvck5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgY29uc3QgaXNJbmxpbmUgPSBjdXJyZW50RWxlbWVudC5pc0lubGluZSgpO1xuICAgICAgY29uc3QgdGV4dENvbnRlbnRMZW5ndGggPSBpc0lubGluZSA/IGN1cnJlbnRFbGVtZW50LmdldFRleHRDb250ZW50U2l6ZSgpIDogYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcblxuICAgICAgaWYgKGFuY2hvck9mZnNldCA9PT0gMCkge1xuICAgICAgICBub2Rlc1RvTW92ZS5wdXNoKGFuY2hvck5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzSW5saW5lKSB7XG4gICAgICAgICAgLy8gRm9yIGlubGluZSBub2Rlcywgd2Ugd2FudCB0byBtb3ZlIGFsbCB0aGUgc2libGluZ3MgdG8gdGhlIG5ldyBwYXJhZ3JhcGhcbiAgICAgICAgICAvLyBpZiBzZWxlY3Rpb24gaXMgYXQgdGhlIGVuZCwgd2UganVzdCBtb3ZlIHRoZSBzaWJsaW5ncy4gT3RoZXJ3aXNlLCB3ZSBhbHNvXG4gICAgICAgICAgLy8gc3BsaXQgdGhlIHRleHQgbm9kZSBhbmQgYWRkIHRoYXQgYW5kIGl0J3Mgc2libGluZ3MgYmVsb3cuXG4gICAgICAgICAgc2libGluZ3NUb01vdmUgPSBjdXJyZW50RWxlbWVudC5nZXROZXh0U2libGluZ3MoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbmNob3JPZmZzZXQgIT09IHRleHRDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFpc0lubGluZSB8fCBhbmNob3JPZmZzZXQgIT09IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFssIHNwbGl0Tm9kZV0gPSBhbmNob3JOb2RlLnNwbGl0VGV4dChhbmNob3JPZmZzZXQpO1xuICAgICAgICAgICAgbm9kZXNUb01vdmUucHVzaChzcGxpdE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50RWxlbWVudCA9IGFuY2hvci5nZXROb2RlKCk7XG5cbiAgICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KGN1cnJlbnRFbGVtZW50KSkge1xuICAgICAgICBjb25zdCBwYXJhZ3JhcGggPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICBjb25zdCBjaGlsZCA9IGN1cnJlbnRFbGVtZW50LmdldENoaWxkQXRJbmRleChhbmNob3JPZmZzZXQpO1xuICAgICAgICBwYXJhZ3JhcGguc2VsZWN0KCk7XG5cbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgY2hpbGQuaW5zZXJ0QmVmb3JlKHBhcmFncmFwaCwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRFbGVtZW50LmFwcGVuZChwYXJhZ3JhcGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2Rlc1RvTW92ZSA9IGN1cnJlbnRFbGVtZW50LmdldENoaWxkcmVuKCkuc2xpY2UoYW5jaG9yT2Zmc2V0KS5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZXNUb01vdmVMZW5ndGggPSBub2Rlc1RvTW92ZS5sZW5ndGg7XG5cbiAgICBpZiAoYW5jaG9yT2Zmc2V0ID09PSAwICYmIG5vZGVzVG9Nb3ZlTGVuZ3RoID4gMCAmJiBjdXJyZW50RWxlbWVudC5pc0lubGluZSgpKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBjdXJyZW50RWxlbWVudC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICBjb25zdCBuZXdFbGVtZW50ID0gcGFyZW50Lmluc2VydE5ld0FmdGVyKHRoaXMsIGZhbHNlKTtcblxuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5ld0VsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50LmdldENoaWxkcmVuKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5ld0VsZW1lbnQuYXBwZW5kKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbmV3RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50Lmluc2VydE5ld0FmdGVyKHRoaXMsIGZhbHNlKTtcblxuICAgIGlmIChuZXdFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBIYW5kbGUgYXMgYSBsaW5lIGJyZWFrIGluc2VydGlvblxuICAgICAgdGhpcy5pbnNlcnRMaW5lQnJlYWsoKTtcbiAgICB9IGVsc2UgaWYgKCRpc0VsZW1lbnROb2RlKG5ld0VsZW1lbnQpKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQsIG1vdmUgdGhlIG5ldyBlbGVtZW50IHRvIGJlIGJlZm9yZSB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudEZpcnN0Q2hpbGQgPSBjdXJyZW50RWxlbWVudC5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBjb25zdCBpc0JlZ2lubmluZyA9IGFuY2hvck9mZnNldCA9PT0gMCAmJiAoY3VycmVudEVsZW1lbnQuaXMoYW5jaG9yLmdldE5vZGUoKSkgfHwgY3VycmVudEVsZW1lbnRGaXJzdENoaWxkICYmIGN1cnJlbnRFbGVtZW50Rmlyc3RDaGlsZC5pcyhhbmNob3IuZ2V0Tm9kZSgpKSk7XG5cbiAgICAgIGlmIChpc0JlZ2lubmluZyAmJiBub2Rlc1RvTW92ZUxlbmd0aCA+IDApIHtcbiAgICAgICAgY3VycmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5ld0VsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBmaXJzdENoaWxkID0gbnVsbDtcbiAgICAgIGNvbnN0IHNpYmxpbmdzVG9Nb3ZlTGVuZ3RoID0gc2libGluZ3NUb01vdmUubGVuZ3RoO1xuICAgICAgY29uc3QgcGFyZW50ID0gbmV3RWxlbWVudC5nZXRQYXJlbnRPclRocm93KCk7IC8vIEZvciBpbmxpbmUgZWxlbWVudHMsIHdlIGFwcGVuZCB0aGUgc2libGluZ3MgdG8gdGhlIHBhcmVudC5cblxuICAgICAgaWYgKHNpYmxpbmdzVG9Nb3ZlTGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpYmxpbmdzVG9Nb3ZlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nVG9Nb3ZlID0gc2libGluZ3NUb01vdmVbaV07XG4gICAgICAgICAgcGFyZW50LmFwcGVuZChzaWJsaW5nVG9Nb3ZlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZXNUb01vdmVMZW5ndGggIT09IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc1RvTW92ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZVRvTW92ZSA9IG5vZGVzVG9Nb3ZlW2ldO1xuXG4gICAgICAgICAgaWYgKGZpcnN0Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld0VsZW1lbnQuYXBwZW5kKG5vZGVUb01vdmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShub2RlVG9Nb3ZlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaXJzdENoaWxkID0gbm9kZVRvTW92ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW5ld0VsZW1lbnQuY2FuQmVFbXB0eSgpICYmIG5ld0VsZW1lbnQuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgICAgbmV3RWxlbWVudC5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICBuZXdFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RWxlbWVudC5zZWxlY3RTdGFydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5zZXJ0cyBhIGxvZ2ljYWwgbGluZWJyZWFrLCB3aGljaCBtYXkgYmUgYSBuZXcgTGluZUJyZWFrTm9kZSBvciBhIG5ldyBQYXJhZ3JhcGhOb2RlLCBpbnRvIHRoZSBFZGl0b3JTdGF0ZSBhdCB0aGVcbiAgICogY3VycmVudCBTZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBzZWxlY3RTdGFydCB3aGV0aGVyIG9yIG5vdCB0byBzZWxlY3QgdGhlIHN0YXJ0IG9mIHRoZSBpbnNlcnRpb24gcmFuZ2UgYWZ0ZXIgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZXMuXG4gICAqL1xuXG5cbiAgaW5zZXJ0TGluZUJyZWFrKHNlbGVjdFN0YXJ0KSB7XG4gICAgY29uc3QgbGluZUJyZWFrTm9kZSA9ICRjcmVhdGVMaW5lQnJlYWtOb2RlKCk7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG5cbiAgICBpZiAoYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGFuY2hvci5nZXROb2RlKCk7XG5cbiAgICAgIGlmICgkaXNSb290Tm9kZShlbGVtZW50KSkge1xuICAgICAgICB0aGlzLmluc2VydFBhcmFncmFwaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RTdGFydCkge1xuICAgICAgdGhpcy5pbnNlcnROb2RlcyhbbGluZUJyZWFrTm9kZV0sIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5pbnNlcnROb2RlcyhbbGluZUJyZWFrTm9kZV0pKSB7XG4gICAgICAgIGxpbmVCcmVha05vZGUuc2VsZWN0TmV4dCgwLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNoYXJhY3Rlci1iYXNlZCBvZmZzZXRzIG9mIHRoZSBTZWxlY3Rpb24sIGFjY291bnRpbmcgZm9yIG5vbi10ZXh0IFBvaW50c1xuICAgKiBieSB1c2luZyB0aGUgY2hpbGRyZW4gc2l6ZSBvciB0ZXh0IGNvbnRlbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBjaGFyYWN0ZXIgb2Zmc2V0cyBmb3IgdGhlIFNlbGVjdGlvblxuICAgKi9cblxuXG4gIGdldENoYXJhY3Rlck9mZnNldHMoKSB7XG4gICAgcmV0dXJuIGdldENoYXJhY3Rlck9mZnNldHModGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBub2RlcyBpbiB0aGUgU2VsZWN0aW9uLCBzcGxpdHRpbmcgbm9kZXMgd2hlcmUgbmVjZXNzYXJ5XG4gICAqIHRvIGdldCBvZmZzZXQtbGV2ZWwgcHJlY2lzaW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgbm9kZXMgaW4gdGhlIFNlbGVjdGlvblxuICAgKi9cblxuXG4gIGV4dHJhY3QoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzTGVuZ3RoID0gc2VsZWN0ZWROb2Rlcy5sZW5ndGg7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gc2VsZWN0ZWROb2Rlc0xlbmd0aCAtIDE7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgIGxldCBmaXJzdE5vZGUgPSBzZWxlY3RlZE5vZGVzWzBdO1xuICAgIGxldCBsYXN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbbGFzdEluZGV4XTtcbiAgICBjb25zdCBbYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldF0gPSBnZXRDaGFyYWN0ZXJPZmZzZXRzKHRoaXMpO1xuXG4gICAgaWYgKHNlbGVjdGVkTm9kZXNMZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKHNlbGVjdGVkTm9kZXNMZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShmaXJzdE5vZGUpICYmICF0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgICAgICBjb25zdCBzcGxpdE5vZGVzID0gZmlyc3ROb2RlLnNwbGl0VGV4dChzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHN0YXJ0T2Zmc2V0ID09PSAwID8gc3BsaXROb2Rlc1swXSA6IHNwbGl0Tm9kZXNbMV07XG4gICAgICAgIHJldHVybiBub2RlICE9IG51bGwgPyBbbm9kZV0gOiBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtmaXJzdE5vZGVdO1xuICAgIH1cblxuICAgIGNvbnN0IGlzQmVmb3JlID0gYW5jaG9yLmlzQmVmb3JlKGZvY3VzKTtcblxuICAgIGlmICgkaXNUZXh0Tm9kZShmaXJzdE5vZGUpKSB7XG4gICAgICBjb25zdCBzdGFydE9mZnNldCA9IGlzQmVmb3JlID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG5cbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICAgIHNlbGVjdGVkTm9kZXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRPZmZzZXQgIT09IDApIHtcbiAgICAgICAgWywgZmlyc3ROb2RlXSA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQpO1xuICAgICAgICBzZWxlY3RlZE5vZGVzWzBdID0gZmlyc3ROb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgkaXNUZXh0Tm9kZShsYXN0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGxhc3ROb2RlVGV4dCA9IGxhc3ROb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCBsYXN0Tm9kZVRleHRMZW5ndGggPSBsYXN0Tm9kZVRleHQubGVuZ3RoO1xuICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gaXNCZWZvcmUgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcblxuICAgICAgaWYgKGVuZE9mZnNldCA9PT0gMCkge1xuICAgICAgICBzZWxlY3RlZE5vZGVzLnBvcCgpO1xuICAgICAgfSBlbHNlIGlmIChlbmRPZmZzZXQgIT09IGxhc3ROb2RlVGV4dExlbmd0aCkge1xuICAgICAgICBbbGFzdE5vZGVdID0gbGFzdE5vZGUuc3BsaXRUZXh0KGVuZE9mZnNldCk7XG4gICAgICAgIHNlbGVjdGVkTm9kZXNbbGFzdEluZGV4XSA9IGxhc3ROb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3RlZE5vZGVzO1xuICB9XG4gIC8qKlxuICAgKiBNb2RpZmllcyB0aGUgU2VsZWN0aW9uIGFjY29yZGluZyB0byB0aGUgcGFyYW1ldGVycyBhbmQgYSBzZXQgb2YgaGV1cmlzdGljcyB0aGF0IGFjY291bnQgZm9yXG4gICAqIHZhcmlvdXMgbm9kZSB0eXBlcy4gQ2FuIGJlIHVzZWQgdG8gc2FmZWx5IG1vdmUgb3IgZXh0ZW5kIHNlbGVjdGlvbiBieSBvbmUgbG9naWNhbCBcInVuaXRcIiB3aXRob3V0XG4gICAqIGRlYWxpbmcgZXhwbGljaXRseSB3aXRoIGFsbCB0aGUgcG9zc2libGUgbm9kZSB0eXBlcy5cbiAgICpcbiAgICogQHBhcmFtIGFsdGVyIHRoZSB0eXBlIG9mIG1vZGlmaWNhdGlvbiB0byBwZXJmb3JtXG4gICAqIEBwYXJhbSBpc0JhY2t3YXJkIHdoZXRoZXIgb3Igbm90IHNlbGVjdGlvbiBpcyBiYWNrd2FyZHNcbiAgICogQHBhcmFtIGdyYW51bGFyaXR5IHRoZSBncmFudWxhcml0eSBhdCB3aGljaCB0byBhcHBseSB0aGUgbW9kaWZpY2F0aW9uXG4gICAqL1xuXG5cbiAgbW9kaWZ5KGFsdGVyLCBpc0JhY2t3YXJkLCBncmFudWxhcml0eSkge1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICBjb25zdCBjb2xsYXBzZSA9IGFsdGVyID09PSAnbW92ZSc7IC8vIEhhbmRsZSB0aGUgc2VsZWN0aW9uIG1vdmVtZW50IGFyb3VuZCBkZWNvcmF0b3JzLlxuXG4gICAgY29uc3QgcG9zc2libGVOb2RlID0gJGdldEFkamFjZW50Tm9kZShmb2N1cywgaXNCYWNrd2FyZCk7XG5cbiAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJc29sYXRlZCgpKSB7XG4gICAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIG1vdmUgc2VsZWN0aW9uIGZyb20gcmFuZ2Ugc2VsZWN0aW9uIHRvXG4gICAgICAvLyBub2RlIHNlbGVjdGlvbiBvbiB0aGUgbm9kZS5cbiAgICAgIGlmIChjb2xsYXBzZSAmJiBwb3NzaWJsZU5vZGUuaXNLZXlib2FyZFNlbGVjdGFibGUoKSkge1xuICAgICAgICBjb25zdCBub2RlU2VsZWN0aW9uID0gJGNyZWF0ZU5vZGVTZWxlY3Rpb24oKTtcbiAgICAgICAgbm9kZVNlbGVjdGlvbi5hZGQocG9zc2libGVOb2RlLl9fa2V5KTtcbiAgICAgICAgJHNldFNlbGVjdGlvbihub2RlU2VsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzaWJsaW5nID0gaXNCYWNrd2FyZCA/IHBvc3NpYmxlTm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IHBvc3NpYmxlTm9kZS5nZXROZXh0U2libGluZygpO1xuXG4gICAgICBpZiAoISRpc1RleHROb2RlKHNpYmxpbmcpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHBvc3NpYmxlTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgIGxldCBvZmZzZXQ7XG4gICAgICAgIGxldCBlbGVtZW50S2V5O1xuXG4gICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgICAgICAgIGVsZW1lbnRLZXkgPSBzaWJsaW5nLl9fa2V5O1xuICAgICAgICAgIG9mZnNldCA9IGlzQmFja3dhcmQgPyBzaWJsaW5nLmdldENoaWxkcmVuU2l6ZSgpIDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZzZXQgPSBwb3NzaWJsZU5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICAgICBlbGVtZW50S2V5ID0gcGFyZW50Ll9fa2V5O1xuXG4gICAgICAgICAgaWYgKCFpc0JhY2t3YXJkKSB7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb2N1cy5zZXQoZWxlbWVudEtleSwgb2Zmc2V0LCAnZWxlbWVudCcpO1xuXG4gICAgICAgIGlmIChjb2xsYXBzZSkge1xuICAgICAgICAgIGFuY2hvci5zZXQoZWxlbWVudEtleSwgb2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2libGluZ0tleSA9IHNpYmxpbmcuX19rZXk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBzaWJsaW5nLmdldFRleHRDb250ZW50KCkubGVuZ3RoIDogMDtcbiAgICAgICAgZm9jdXMuc2V0KHNpYmxpbmdLZXksIG9mZnNldCwgJ3RleHQnKTtcblxuICAgICAgICBpZiAoY29sbGFwc2UpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KHNpYmxpbmdLZXksIG9mZnNldCwgJ3RleHQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuXG4gICAgaWYgKCFkb21TZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBibG9ja0N1cnNvckVsZW1lbnQgPSBlZGl0b3IuX2Jsb2NrQ3Vyc29yRWxlbWVudDtcbiAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5fcm9vdEVsZW1lbnQ7IC8vIFJlbW92ZSB0aGUgYmxvY2sgY3Vyc29yIGVsZW1lbnQgaWYgaXQgZXhpc3RzLiBUaGlzIHdpbGwgZW5zdXJlIHNlbGVjdGlvblxuICAgIC8vIHdvcmtzIGFzIGludGVuZGVkLiBJZiB3ZSBsZWF2ZSBpdCBpbiB0aGUgRE9NIGFsbCBzb3J0cyBvZiBzdHJhbmdlIGJ1Z3NcbiAgICAvLyBvY2N1ci4gOi9cblxuICAgIGlmIChyb290RWxlbWVudCAhPT0gbnVsbCAmJiBibG9ja0N1cnNvckVsZW1lbnQgIT09IG51bGwgJiYgJGlzRWxlbWVudE5vZGUocG9zc2libGVOb2RlKSAmJiAhcG9zc2libGVOb2RlLmlzSW5saW5lKCkgJiYgIXBvc3NpYmxlTm9kZS5jYW5CZUVtcHR5KCkpIHtcbiAgICAgIHJlbW92ZURPTUJsb2NrQ3Vyc29yRWxlbWVudChibG9ja0N1cnNvckVsZW1lbnQsIGVkaXRvciwgcm9vdEVsZW1lbnQpO1xuICAgIH0gLy8gV2UgdXNlIHRoZSBET00gc2VsZWN0aW9uLm1vZGlmeSBBUEkgaGVyZSB0byBcInRlbGxcIiB1cyB3aGF0IHRoZSBzZWxlY3Rpb25cbiAgICAvLyB3aWxsIGJlLiBXZSB0aGVuIHVzZSBpdCB0byB1cGRhdGUgdGhlIExleGljYWwgc2VsZWN0aW9uIGFjY29yZGluZ2x5LiBUaGlzXG4gICAgLy8gaXMgbXVjaCBtb3JlIHJlbGlhYmxlIHRoYW4gd2FpdGluZyBmb3IgYSBiZWZvcmVpbnB1dCBhbmQgdXNpbmcgdGhlIHJhbmdlc1xuICAgIC8vIGZyb20gZ2V0VGFyZ2V0UmFuZ2VzKCksIGFuZCBpcyBhbHNvIGJldHRlciB0aGFuIHRyeWluZyB0byBkbyBpdCBvdXJzZWx2ZXNcbiAgICAvLyB1c2luZyBJbnRsLlNlZ21lbnRlciBvciBvdGhlciB3b3JrYXJvdW5kcyB0aGF0IHN0cnVnZ2xlIHdpdGggd29yZCBzZWdtZW50c1xuICAgIC8vIGFuZCBsaW5lIHNlZ21lbnRzIChlc3BlY2lhbGx5IHdpdGggd29yZCB3cmFwcGluZyBhbmQgbm9uLVJvbWFuIGxhbmd1YWdlcykuXG5cblxuICAgIG1vdmVOYXRpdmVTZWxlY3Rpb24oZG9tU2VsZWN0aW9uLCBhbHRlciwgaXNCYWNrd2FyZCA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCcsIGdyYW51bGFyaXR5KTsgLy8gR3VhcmQgYWdhaW5zdCBubyByYW5nZXNcblxuICAgIGlmIChkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7IC8vIEFwcGx5IHRoZSBET00gc2VsZWN0aW9uIHRvIG91ciBMZXhpY2FsIHNlbGVjdGlvbi5cblxuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHRoaXMuYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IHJvb3QgPSAkaXNSb290Tm9kZShhbmNob3JOb2RlKSA/IGFuY2hvck5vZGUgOiAkZ2V0TmVhcmVzdFJvb3RPclNoYWRvd1Jvb3QoYW5jaG9yTm9kZSk7XG4gICAgICB0aGlzLmFwcGx5RE9NUmFuZ2UocmFuZ2UpO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cbiAgICAgIGlmICghY29sbGFwc2UpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgc2VsZWN0aW9uOyBtYWtlIHN1cmUgdGhhdCB0aGUgbmV3IGV4dGVuZGVkIHNlbGVjdGlvbiByZXNwZWN0cyBzaGFkb3cgcm9vdHNcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gICAgICAgIGNvbnN0IHZhbGlkTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IHNocmlua1NlbGVjdGlvbiA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICAgICAgaWYgKCRoYXNBbmNlc3RvcihuZXh0Tm9kZSwgcm9vdCkpIHtcbiAgICAgICAgICAgIHZhbGlkTm9kZXMucHVzaChuZXh0Tm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNocmlua1NlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNocmlua1NlbGVjdGlvbiAmJiB2YWxpZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyB2YWxpZE5vZGVzIGxlbmd0aCBjaGVjayBpcyBhIHNhZmVndWFyZCBhZ2FpbnN0IGFuIGludmFsaWQgc2VsZWN0aW9uOyBhcyBnZXROb2RlcygpXG4gICAgICAgICAgLy8gd2lsbCByZXR1cm4gYW4gZW1wdHkgYXJyYXkgaW4gdGhpcyBjYXNlXG4gICAgICAgICAgaWYgKGlzQmFja3dhcmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0VmFsaWROb2RlID0gdmFsaWROb2Rlc1swXTtcblxuICAgICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGZpcnN0VmFsaWROb2RlKSkge1xuICAgICAgICAgICAgICBmaXJzdFZhbGlkTm9kZS5zZWxlY3RTdGFydCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmlyc3RWYWxpZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RWYWxpZE5vZGUgPSB2YWxpZE5vZGVzW3ZhbGlkTm9kZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShsYXN0VmFsaWROb2RlKSkge1xuICAgICAgICAgICAgICBsYXN0VmFsaWROb2RlLnNlbGVjdEVuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGFzdFZhbGlkTm9kZS5nZXRQYXJlbnRPclRocm93KCkuc2VsZWN0RW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEJlY2F1c2UgYSByYW5nZSB3b3JrcyBvbiBzdGFydCBhbmQgZW5kLCB3ZSBtaWdodCBuZWVkIHRvIGZsaXBcbiAgICAgICAgLy8gdGhlIGFuY2hvciBhbmQgZm9jdXMgcG9pbnRzIHRvIG1hdGNoIHdoYXQgdGhlIERPTSBoYXMsIG5vdCB3aGF0XG4gICAgICAgIC8vIHRoZSByYW5nZSBoYXMgc3BlY2lmaWNhbGx5LlxuXG5cbiAgICAgICAgaWYgKGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlICE9PSByYW5nZS5zdGFydENvbnRhaW5lciB8fCBkb21TZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ICE9PSByYW5nZS5zdGFydE9mZnNldCkge1xuICAgICAgICAgICRzd2FwUG9pbnRzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBvbmUgbG9naWNhbCBjaGFyYWN0ZXIgZGVsZXRpb24gb3BlcmF0aW9uIG9uIHRoZSBFZGl0b3JTdGF0ZSBiYXNlZCBvbiB0aGUgY3VycmVudCBTZWxlY3Rpb24uXG4gICAqIEhhbmRsZXMgZGlmZmVyZW50IG5vZGUgdHlwZXMuXG4gICAqXG4gICAqIEBwYXJhbSBpc0JhY2t3YXJkIHdoZXRoZXIgb3Igbm90IHRoZSBzZWxlY3Rpb24gaXMgYmFja3dhcmRzLlxuICAgKi9cblxuXG4gIGRlbGV0ZUNoYXJhY3Rlcihpc0JhY2t3YXJkKSB7XG4gICAgY29uc3Qgd2FzQ29sbGFwc2VkID0gdGhpcy5pc0NvbGxhcHNlZCgpO1xuXG4gICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgICBjb25zdCBmb2N1cyA9IHRoaXMuZm9jdXM7XG4gICAgICBsZXQgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG5cbiAgICAgIGlmICghaXNCYWNrd2FyZCAmJiAoIC8vIERlbGV0ZSBmb3J3YXJkIGhhbmRsZSBjYXNlXG4gICAgICBhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmICRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpICYmIGFuY2hvci5vZmZzZXQgPT09IGFuY2hvck5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgfHwgYW5jaG9yLnR5cGUgPT09ICd0ZXh0JyAmJiBhbmNob3Iub2Zmc2V0ID09PSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudCgpO1xuICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IGFuY2hvck5vZGUuZ2V0TmV4dFNpYmxpbmcoKSB8fCAocGFyZW50ID09PSBudWxsID8gbnVsbCA6IHBhcmVudC5nZXROZXh0U2libGluZygpKTtcblxuICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUobmV4dFNpYmxpbmcpICYmIG5leHRTaWJsaW5nLmlzU2hhZG93Um9vdCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IC8vIEhhbmRsZSB0aGUgZGVsZXRpb24gYXJvdW5kIGRlY29yYXRvcnMuXG5cblxuICAgICAgY29uc3QgcG9zc2libGVOb2RlID0gJGdldEFkamFjZW50Tm9kZShmb2N1cywgaXNCYWNrd2FyZCk7XG5cbiAgICAgIGlmICgkaXNEZWNvcmF0b3JOb2RlKHBvc3NpYmxlTm9kZSkgJiYgIXBvc3NpYmxlTm9kZS5pc0lzb2xhdGVkKCkpIHtcbiAgICAgICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byBtb3ZlIHNlbGVjdGlvbiBmcm9tIHJhbmdlIHNlbGVjdGlvbiB0b1xuICAgICAgICAvLyBub2RlIHNlbGVjdGlvbiBvbiB0aGUgbm9kZS5cbiAgICAgICAgaWYgKHBvc3NpYmxlTm9kZS5pc0tleWJvYXJkU2VsZWN0YWJsZSgpICYmICRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpICYmIGFuY2hvck5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgICAgICBhbmNob3JOb2RlLnJlbW92ZSgpO1xuICAgICAgICAgIGNvbnN0IG5vZGVTZWxlY3Rpb24gPSAkY3JlYXRlTm9kZVNlbGVjdGlvbigpO1xuICAgICAgICAgIG5vZGVTZWxlY3Rpb24uYWRkKHBvc3NpYmxlTm9kZS5fX2tleSk7XG4gICAgICAgICAgJHNldFNlbGVjdGlvbihub2RlU2VsZWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwb3NzaWJsZU5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gICAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKCFpc0JhY2t3YXJkICYmICRpc0VsZW1lbnROb2RlKHBvc3NpYmxlTm9kZSkgJiYgJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkgJiYgYW5jaG9yTm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgYW5jaG9yTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgcG9zc2libGVOb2RlLnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tb2RpZnkoJ2V4dGVuZCcsIGlzQmFja3dhcmQsICdjaGFyYWN0ZXInKTtcblxuICAgICAgaWYgKCF0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMudHlwZSA9PT0gJ3RleHQnID8gZm9jdXMuZ2V0Tm9kZSgpIDogbnVsbDtcbiAgICAgICAgYW5jaG9yTm9kZSA9IGFuY2hvci50eXBlID09PSAndGV4dCcgPyBhbmNob3IuZ2V0Tm9kZSgpIDogbnVsbDtcblxuICAgICAgICBpZiAoZm9jdXNOb2RlICE9PSBudWxsICYmIGZvY3VzTm9kZS5pc1NlZ21lbnRlZCgpKSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50U2l6ZSA9IGZvY3VzTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcblxuICAgICAgICAgIGlmIChmb2N1c05vZGUuaXMoYW5jaG9yTm9kZSkgfHwgaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IHRleHRDb250ZW50U2l6ZSB8fCAhaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICRyZW1vdmVTZWdtZW50KGZvY3VzTm9kZSwgaXNCYWNrd2FyZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYW5jaG9yTm9kZSAhPT0gbnVsbCAmJiBhbmNob3JOb2RlLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50U2l6ZSA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG5cbiAgICAgICAgICBpZiAoYW5jaG9yTm9kZS5pcyhmb2N1c05vZGUpIHx8IGlzQmFja3dhcmQgJiYgb2Zmc2V0ICE9PSAwIHx8ICFpc0JhY2t3YXJkICYmIG9mZnNldCAhPT0gdGV4dENvbnRlbnRTaXplKSB7XG4gICAgICAgICAgICAkcmVtb3ZlU2VnbWVudChhbmNob3JOb2RlLCBpc0JhY2t3YXJkLCBvZmZzZXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICR1cGRhdGVDYXJldFNlbGVjdGlvbkZvclVuaWNvZGVDaGFyYWN0ZXIodGhpcywgaXNCYWNrd2FyZCk7XG4gICAgICB9IGVsc2UgaWYgKGlzQmFja3dhcmQgJiYgYW5jaG9yLm9mZnNldCA9PT0gMCkge1xuICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGFyb3VuZCByaWNoIHRleHQgbm9kZXNcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgPyBhbmNob3IuZ2V0Tm9kZSgpIDogYW5jaG9yLmdldE5vZGUoKS5nZXRQYXJlbnRPclRocm93KCk7XG5cbiAgICAgICAgaWYgKGVsZW1lbnQuY29sbGFwc2VBdFN0YXJ0KHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVUZXh0KCk7XG5cbiAgICBpZiAoaXNCYWNrd2FyZCAmJiAhd2FzQ29sbGFwc2VkICYmIHRoaXMuaXNDb2xsYXBzZWQoKSAmJiB0aGlzLmFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgdGhpcy5hbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gdGhpcy5hbmNob3IuZ2V0Tm9kZSgpO1xuXG4gICAgICBpZiAoYW5jaG9yTm9kZS5pc0VtcHR5KCkgJiYgJGlzUm9vdE5vZGUoYW5jaG9yTm9kZS5nZXRQYXJlbnQoKSkgJiYgYW5jaG9yTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpID09PSAwKSB7XG4gICAgICAgIGFuY2hvck5vZGUuY29sbGFwc2VBdFN0YXJ0KHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgb25lIGxvZ2ljYWwgbGluZSBkZWxldGlvbiBvcGVyYXRpb24gb24gdGhlIEVkaXRvclN0YXRlIGJhc2VkIG9uIHRoZSBjdXJyZW50IFNlbGVjdGlvbi5cbiAgICogSGFuZGxlcyBkaWZmZXJlbnQgbm9kZSB0eXBlcy5cbiAgICpcbiAgICogQHBhcmFtIGlzQmFja3dhcmQgd2hldGhlciBvciBub3QgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZHMuXG4gICAqL1xuXG5cbiAgZGVsZXRlTGluZShpc0JhY2t3YXJkKSB7XG4gICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgaWYgKHRoaXMuYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICB0aGlzLm1vZGlmeSgnZXh0ZW5kJywgaXNCYWNrd2FyZCwgJ2xpbmVib3VuZGFyeScpO1xuICAgICAgfSAvLyBJZiBzZWxlY3Rpb24gaXMgZXh0ZW5kZWQgdG8gY292ZXIgdGV4dCBlZGdlIHRoZW4gZXh0ZW5kIGl0IG9uZSBjaGFyYWN0ZXIgbW9yZVxuICAgICAgLy8gdG8gZGVsZXRlIGl0cyBwYXJlbnQgZWxlbWVudC4gT3RoZXJ3aXNlIHRleHQgY29udGVudCB3aWxsIGJlIGRlbGV0ZWQgYnV0IGVtcHR5XG4gICAgICAvLyBwYXJlbnQgbm9kZSB3aWxsIHJlbWFpblxuXG5cbiAgICAgIGNvbnN0IGVuZFBvaW50ID0gaXNCYWNrd2FyZCA/IHRoaXMuZm9jdXMgOiB0aGlzLmFuY2hvcjtcblxuICAgICAgaWYgKGVuZFBvaW50Lm9mZnNldCA9PT0gMCkge1xuICAgICAgICB0aGlzLm1vZGlmeSgnZXh0ZW5kJywgaXNCYWNrd2FyZCwgJ2NoYXJhY3RlcicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlVGV4dCgpO1xuICB9XG4gIC8qKlxuICAgKiBQZXJmb3JtcyBvbmUgbG9naWNhbCB3b3JkIGRlbGV0aW9uIG9wZXJhdGlvbiBvbiB0aGUgRWRpdG9yU3RhdGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKiBIYW5kbGVzIGRpZmZlcmVudCBub2RlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkcy5cbiAgICovXG5cblxuICBkZWxldGVXb3JkKGlzQmFja3dhcmQpIHtcbiAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICB0aGlzLm1vZGlmeSgnZXh0ZW5kJywgaXNCYWNrd2FyZCwgJ3dvcmQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZVRleHQoKTtcbiAgfVxuXG59XG5mdW5jdGlvbiAkaXNOb2RlU2VsZWN0aW9uKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFyYWN0ZXJPZmZzZXQocG9pbnQpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gcG9pbnQub2Zmc2V0O1xuXG4gIGlmIChwb2ludC50eXBlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgY29uc3QgcGFyZW50ID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICByZXR1cm4gb2Zmc2V0ID09PSBwYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCkgPyBwYXJlbnQuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGggOiAwO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFyYWN0ZXJPZmZzZXRzKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcblxuICBpZiAoYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBmb2N1cy50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLmtleSA9PT0gZm9jdXMua2V5ICYmIGFuY2hvci5vZmZzZXQgPT09IGZvY3VzLm9mZnNldCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cblxuICByZXR1cm4gW2dldENoYXJhY3Rlck9mZnNldChhbmNob3IpLCBnZXRDaGFyYWN0ZXJPZmZzZXQoZm9jdXMpXTtcbn1cblxuZnVuY3Rpb24gJHN3YXBQb2ludHMoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBhbmNob3JLZXkgPSBhbmNob3Iua2V5O1xuICBjb25zdCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBhbmNob3JUeXBlID0gYW5jaG9yLnR5cGU7XG4gICRzZXRQb2ludFZhbHVlcyhhbmNob3IsIGZvY3VzLmtleSwgZm9jdXMub2Zmc2V0LCBmb2N1cy50eXBlKTtcbiAgJHNldFBvaW50VmFsdWVzKGZvY3VzLCBhbmNob3JLZXksIGFuY2hvck9mZnNldCwgYW5jaG9yVHlwZSk7XG4gIHNlbGVjdGlvbi5fY2FjaGVkTm9kZXMgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBtb3ZlTmF0aXZlU2VsZWN0aW9uKGRvbVNlbGVjdGlvbiwgYWx0ZXIsIGRpcmVjdGlvbiwgZ3JhbnVsYXJpdHkpIHtcbiAgLy8gU2VsZWN0aW9uLm1vZGlmeSgpIG1ldGhvZCBhcHBsaWVzIGEgY2hhbmdlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBvciBjdXJzb3IgcG9zaXRpb24sXG4gIC8vIGJ1dCBpcyBzdGlsbCBub24tc3RhbmRhcmQgaW4gc29tZSBicm93c2Vycy5cbiAgZG9tU2VsZWN0aW9uLm1vZGlmeShhbHRlciwgZGlyZWN0aW9uLCBncmFudWxhcml0eSk7XG59XG5cbmZ1bmN0aW9uICR1cGRhdGVDYXJldFNlbGVjdGlvbkZvclVuaWNvZGVDaGFyYWN0ZXIoc2VsZWN0aW9uLCBpc0JhY2t3YXJkKSB7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuXG4gIGlmIChhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiYgYW5jaG9yLnR5cGUgPT09ICd0ZXh0JyAmJiBmb2N1cy50eXBlID09PSAndGV4dCcpIHtcbiAgICAvLyBIYW5kbGluZyBvZiBtdWx0aWJ5dGUgY2hhcmFjdGVyc1xuICAgIGNvbnN0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gICAgY29uc3QgaXNCZWZvcmUgPSBhbmNob3JPZmZzZXQgPCBmb2N1c09mZnNldDtcbiAgICBjb25zdCBzdGFydE9mZnNldCA9IGlzQmVmb3JlID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gICAgY29uc3QgZW5kT2Zmc2V0ID0gaXNCZWZvcmUgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICBjb25zdCBjaGFyYWN0ZXJPZmZzZXQgPSBlbmRPZmZzZXQgLSAxO1xuXG4gICAgaWYgKHN0YXJ0T2Zmc2V0ICE9PSBjaGFyYWN0ZXJPZmZzZXQpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50KCkuc2xpY2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG5cbiAgICAgIGlmICghZG9lc0NvbnRhaW5HcmFwaGVtZSh0ZXh0KSkge1xuICAgICAgICBpZiAoaXNCYWNrd2FyZCkge1xuICAgICAgICAgIGZvY3VzLm9mZnNldCA9IGNoYXJhY3Rlck9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmNob3Iub2Zmc2V0ID0gY2hhcmFjdGVyT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uICRyZW1vdmVTZWdtZW50KG5vZGUsIGlzQmFja3dhcmQsIG9mZnNldCkge1xuICBjb25zdCB0ZXh0Tm9kZSA9IG5vZGU7XG4gIGNvbnN0IHRleHRDb250ZW50ID0gdGV4dE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgY29uc3Qgc3BsaXQgPSB0ZXh0Q29udGVudC5zcGxpdCgvKD89XFxzKS9nKTtcbiAgY29uc3Qgc3BsaXRMZW5ndGggPSBzcGxpdC5sZW5ndGg7XG4gIGxldCBzZWdtZW50T2Zmc2V0ID0gMDtcbiAgbGV0IHJlc3RvcmVPZmZzZXQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3BsaXRMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRleHQgPSBzcGxpdFtpXTtcbiAgICBjb25zdCBpc0xhc3QgPSBpID09PSBzcGxpdExlbmd0aCAtIDE7XG4gICAgcmVzdG9yZU9mZnNldCA9IHNlZ21lbnRPZmZzZXQ7XG4gICAgc2VnbWVudE9mZnNldCArPSB0ZXh0Lmxlbmd0aDtcblxuICAgIGlmIChpc0JhY2t3YXJkICYmIHNlZ21lbnRPZmZzZXQgPT09IG9mZnNldCB8fCBzZWdtZW50T2Zmc2V0ID4gb2Zmc2V0IHx8IGlzTGFzdCkge1xuICAgICAgc3BsaXQuc3BsaWNlKGksIDEpO1xuXG4gICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgIHJlc3RvcmVPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5leHRUZXh0Q29udGVudCA9IHNwbGl0LmpvaW4oJycpLnRyaW0oKTtcblxuICBpZiAobmV4dFRleHRDb250ZW50ID09PSAnJykge1xuICAgIHRleHROb2RlLnJlbW92ZSgpO1xuICB9IGVsc2Uge1xuICAgIHRleHROb2RlLnNldFRleHRDb250ZW50KG5leHRUZXh0Q29udGVudCk7XG4gICAgdGV4dE5vZGUuc2VsZWN0KHJlc3RvcmVPZmZzZXQsIHJlc3RvcmVPZmZzZXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZFJlc29sdmVBbmNlc3RvcihyZXNvbHZlZEVsZW1lbnQsIHJlc29sdmVkT2Zmc2V0LCBsYXN0UG9pbnQpIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZWRFbGVtZW50LmdldFBhcmVudCgpO1xuICByZXR1cm4gbGFzdFBvaW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gbnVsbCB8fCAhcGFyZW50LmNhbkJlRW1wdHkoKSB8fCBwYXJlbnQgIT09IGxhc3RQb2ludC5nZXROb2RlKCk7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsUmVzb2x2ZVNlbGVjdGlvblBvaW50KGRvbSwgb2Zmc2V0LCBsYXN0UG9pbnQsIGVkaXRvcikge1xuICBsZXQgcmVzb2x2ZWRPZmZzZXQgPSBvZmZzZXQ7XG4gIGxldCByZXNvbHZlZE5vZGU7IC8vIElmIHdlIGhhdmUgc2VsZWN0aW9uIG9uIGFuIGVsZW1lbnQsIHdlIHdpbGxcbiAgLy8gbmVlZCB0byBmaWd1cmUgb3V0ICh1c2luZyB0aGUgb2Zmc2V0KSB3aGF0IHRleHRcbiAgLy8gbm9kZSBzaG91bGQgYmUgc2VsZWN0ZWQuXG5cbiAgaWYgKGRvbS5ub2RlVHlwZSA9PT0gRE9NX0VMRU1FTlRfVFlQRSkge1xuICAgIC8vIFJlc29sdmUgZWxlbWVudCB0byBhIEVsZW1lbnROb2RlLCBvciBUZXh0Tm9kZSwgb3IgbnVsbFxuICAgIGxldCBtb3ZlU2VsZWN0aW9uVG9FbmQgPSBmYWxzZTsgLy8gR2l2ZW4gd2UncmUgbW92aW5nIHNlbGVjdGlvbiB0byBhbm90aGVyIG5vZGUsIHNlbGVjdGlvbiBpc1xuICAgIC8vIGRlZmluaXRlbHkgZGlydHkuXG4gICAgLy8gV2UgdXNlIHRoZSBhbmNob3IgdG8gZmluZCB3aGljaCBjaGlsZCBub2RlIHRvIHNlbGVjdFxuXG4gICAgY29uc3QgY2hpbGROb2RlcyA9IGRvbS5jaGlsZE5vZGVzO1xuICAgIGNvbnN0IGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aDsgLy8gSWYgdGhlIGFuY2hvciBpcyB0aGUgc2FtZSBhcyBsZW5ndGgsIHRoZW4gdGhpcyBtZWFucyB3ZVxuICAgIC8vIG5lZWQgdG8gc2VsZWN0IHRoZSB2ZXJ5IGxhc3QgdGV4dCBub2RlLlxuXG4gICAgaWYgKHJlc29sdmVkT2Zmc2V0ID09PSBjaGlsZE5vZGVzTGVuZ3RoKSB7XG4gICAgICBtb3ZlU2VsZWN0aW9uVG9FbmQgPSB0cnVlO1xuICAgICAgcmVzb2x2ZWRPZmZzZXQgPSBjaGlsZE5vZGVzTGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICBsZXQgY2hpbGRET00gPSBjaGlsZE5vZGVzW3Jlc29sdmVkT2Zmc2V0XTtcbiAgICBsZXQgaGFzQmxvY2tDdXJzb3IgPSBmYWxzZTtcblxuICAgIGlmIChjaGlsZERPTSA9PT0gZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQpIHtcbiAgICAgIGNoaWxkRE9NID0gY2hpbGROb2Rlc1tyZXNvbHZlZE9mZnNldCArIDFdO1xuICAgICAgaGFzQmxvY2tDdXJzb3IgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHJlc29sdmVkT2Zmc2V0LS07XG4gICAgfVxuXG4gICAgcmVzb2x2ZWROb2RlID0gZ2V0Tm9kZUZyb21ET00oY2hpbGRET00pO1xuXG4gICAgaWYgKCRpc1RleHROb2RlKHJlc29sdmVkTm9kZSkpIHtcbiAgICAgIHJlc29sdmVkT2Zmc2V0ID0gZ2V0VGV4dE5vZGVPZmZzZXQocmVzb2x2ZWROb2RlLCBtb3ZlU2VsZWN0aW9uVG9FbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcmVzb2x2ZWRFbGVtZW50ID0gZ2V0Tm9kZUZyb21ET00oZG9tKTsgLy8gRW5zdXJlIHJlc29sdmVkRWxlbWVudCBpcyBhY3R1YWxseSBhIGVsZW1lbnQuXG5cbiAgICAgIGlmIChyZXNvbHZlZEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShyZXNvbHZlZEVsZW1lbnQpKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IHJlc29sdmVkRWxlbWVudC5nZXRDaGlsZEF0SW5kZXgocmVzb2x2ZWRPZmZzZXQpO1xuXG4gICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkgJiYgc2hvdWxkUmVzb2x2ZUFuY2VzdG9yKGNoaWxkLCByZXNvbHZlZE9mZnNldCwgbGFzdFBvaW50KSkge1xuICAgICAgICAgIGNvbnN0IGRlc2NlbmRhbnQgPSBtb3ZlU2VsZWN0aW9uVG9FbmQgPyBjaGlsZC5nZXRMYXN0RGVzY2VuZGFudCgpIDogY2hpbGQuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG5cbiAgICAgICAgICBpZiAoZGVzY2VuZGFudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzb2x2ZWRFbGVtZW50ID0gY2hpbGQ7XG4gICAgICAgICAgICByZXNvbHZlZE9mZnNldCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gZGVzY2VuZGFudDtcbiAgICAgICAgICAgIHJlc29sdmVkRWxlbWVudCA9ICRpc0VsZW1lbnROb2RlKGNoaWxkKSA/IGNoaWxkIDogY2hpbGQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgICByZXNvbHZlZE5vZGUgPSBjaGlsZDtcbiAgICAgICAgICByZXNvbHZlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0ID0gZ2V0VGV4dE5vZGVPZmZzZXQoY2hpbGQsIG1vdmVTZWxlY3Rpb25Ub0VuZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGQgIT09IHJlc29sdmVkRWxlbWVudCAmJiBtb3ZlU2VsZWN0aW9uVG9FbmQgJiYgIWhhc0Jsb2NrQ3Vyc29yKSB7XG4gICAgICAgICAgcmVzb2x2ZWRPZmZzZXQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSByZXNvbHZlZEVsZW1lbnQuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTsgLy8gV2hlbiBzZWxlY3RpbmcgZGVjb3JhdG9ycywgdGhlcmUgY2FuIGJlIHNvbWUgc2VsZWN0aW9uIGlzc3VlcyB3aGVuIHVzaW5nIHJlc29sdmVkT2Zmc2V0LFxuICAgICAgICAvLyBhbmQgaW5zdGVhZCB3ZSBzaG91bGQgYmUgY2hlY2tpbmcgaWYgd2UncmUgdXNpbmcgdGhlIG9mZnNldFxuXG4gICAgICAgIGlmIChvZmZzZXQgPT09IDAgJiYgJGlzRGVjb3JhdG9yTm9kZShyZXNvbHZlZEVsZW1lbnQpICYmIGdldE5vZGVGcm9tRE9NKGRvbSkgPT09IHJlc29sdmVkRWxlbWVudCkge1xuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0ID0gaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZWRPZmZzZXQgPSBpbmRleCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlZEVsZW1lbnQgPSByZXNvbHZlZEVsZW1lbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUocmVzb2x2ZWRFbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gJGNyZWF0ZVBvaW50KHJlc29sdmVkRWxlbWVudC5fX2tleSwgcmVzb2x2ZWRPZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRleHROb2RlIG9yIG51bGxcbiAgICByZXNvbHZlZE5vZGUgPSBnZXROb2RlRnJvbURPTShkb20pO1xuICB9XG5cbiAgaWYgKCEkaXNUZXh0Tm9kZShyZXNvbHZlZE5vZGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gJGNyZWF0ZVBvaW50KHJlc29sdmVkTm9kZS5fX2tleSwgcmVzb2x2ZWRPZmZzZXQsICd0ZXh0Jyk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTZWxlY3Rpb25Qb2ludE9uQm91bmRhcnkocG9pbnQsIGlzQmFja3dhcmQsIGlzQ29sbGFwc2VkKSB7XG4gIGNvbnN0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgY29uc3Qgbm9kZSA9IHBvaW50LmdldE5vZGUoKTtcblxuICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAoIWlzQmFja3dhcmQpIHtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShwcmV2U2libGluZykgJiYgIWlzQ29sbGFwc2VkICYmIHByZXZTaWJsaW5nLmlzSW5saW5lKCkpIHtcbiAgICAgICAgcG9pbnQua2V5ID0gcHJldlNpYmxpbmcuX19rZXk7XG4gICAgICAgIHBvaW50Lm9mZnNldCA9IHByZXZTaWJsaW5nLmdldENoaWxkcmVuU2l6ZSgpOyAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlbnRpb25hbFxuXG4gICAgICAgIHBvaW50LnR5cGUgPSAnZWxlbWVudCc7XG4gICAgICB9IGVsc2UgaWYgKCRpc1RleHROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgICBwb2ludC5rZXkgPSBwcmV2U2libGluZy5fX2tleTtcbiAgICAgICAgcG9pbnQub2Zmc2V0ID0gcHJldlNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaXNDb2xsYXBzZWQgfHwgIWlzQmFja3dhcmQpICYmIHByZXZTaWJsaW5nID09PSBudWxsICYmICRpc0VsZW1lbnROb2RlKHBhcmVudCkgJiYgcGFyZW50LmlzSW5saW5lKCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cbiAgICAgIGlmICgkaXNUZXh0Tm9kZShwYXJlbnRTaWJsaW5nKSkge1xuICAgICAgICBwb2ludC5rZXkgPSBwYXJlbnRTaWJsaW5nLl9fa2V5O1xuICAgICAgICBwb2ludC5vZmZzZXQgPSBwYXJlbnRTaWJsaW5nLmdldFRleHRDb250ZW50KCkubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChvZmZzZXQgPT09IG5vZGUuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGgpIHtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKGlzQmFja3dhcmQgJiYgJGlzRWxlbWVudE5vZGUobmV4dFNpYmxpbmcpICYmIG5leHRTaWJsaW5nLmlzSW5saW5lKCkpIHtcbiAgICAgIHBvaW50LmtleSA9IG5leHRTaWJsaW5nLl9fa2V5O1xuICAgICAgcG9pbnQub2Zmc2V0ID0gMDsgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZW50aW9uYWxcblxuICAgICAgcG9pbnQudHlwZSA9ICdlbGVtZW50JztcbiAgICB9IGVsc2UgaWYgKChpc0NvbGxhcHNlZCB8fCBpc0JhY2t3YXJkKSAmJiBuZXh0U2libGluZyA9PT0gbnVsbCAmJiAkaXNFbGVtZW50Tm9kZShwYXJlbnQpICYmIHBhcmVudC5pc0lubGluZSgpICYmICFwYXJlbnQuY2FuSW5zZXJ0VGV4dEFmdGVyKCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgaWYgKCRpc1RleHROb2RlKHBhcmVudFNpYmxpbmcpKSB7XG4gICAgICAgIHBvaW50LmtleSA9IHBhcmVudFNpYmxpbmcuX19rZXk7XG4gICAgICAgIHBvaW50Lm9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdGlvblBvaW50c0ZvckJvdW5kYXJpZXMoYW5jaG9yLCBmb2N1cywgbGFzdFNlbGVjdGlvbikge1xuICBpZiAoYW5jaG9yLnR5cGUgPT09ICd0ZXh0JyAmJiBmb2N1cy50eXBlID09PSAndGV4dCcpIHtcbiAgICBjb25zdCBpc0JhY2t3YXJkID0gYW5jaG9yLmlzQmVmb3JlKGZvY3VzKTtcbiAgICBjb25zdCBpc0NvbGxhcHNlZCA9IGFuY2hvci5pcyhmb2N1cyk7IC8vIEF0dGVtcHQgdG8gbm9ybWFsaXplIHRoZSBvZmZzZXQgdG8gdGhlIHByZXZpb3VzIHNpYmxpbmcgaWYgd2UncmUgYXQgdGhlXG4gICAgLy8gc3RhcnQgb2YgYSB0ZXh0IG5vZGUgYW5kIHRoZSBzaWJsaW5nIGlzIGEgdGV4dCBub2RlIG9yIGlubGluZSBlbGVtZW50LlxuXG4gICAgcmVzb2x2ZVNlbGVjdGlvblBvaW50T25Cb3VuZGFyeShhbmNob3IsIGlzQmFja3dhcmQsIGlzQ29sbGFwc2VkKTtcbiAgICByZXNvbHZlU2VsZWN0aW9uUG9pbnRPbkJvdW5kYXJ5KGZvY3VzLCAhaXNCYWNrd2FyZCwgaXNDb2xsYXBzZWQpO1xuXG4gICAgaWYgKGlzQ29sbGFwc2VkKSB7XG4gICAgICBmb2N1cy5rZXkgPSBhbmNob3Iua2V5O1xuICAgICAgZm9jdXMub2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgICAgIGZvY3VzLnR5cGUgPSBhbmNob3IudHlwZTtcbiAgICB9XG5cbiAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcblxuICAgIGlmIChlZGl0b3IuaXNDb21wb3NpbmcoKSAmJiBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5ICE9PSBhbmNob3Iua2V5ICYmICRpc1JhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBsYXN0QW5jaG9yID0gbGFzdFNlbGVjdGlvbi5hbmNob3I7XG4gICAgICBjb25zdCBsYXN0Rm9jdXMgPSBsYXN0U2VsZWN0aW9uLmZvY3VzO1xuICAgICAgJHNldFBvaW50VmFsdWVzKGFuY2hvciwgbGFzdEFuY2hvci5rZXksIGxhc3RBbmNob3Iub2Zmc2V0LCBsYXN0QW5jaG9yLnR5cGUpO1xuICAgICAgJHNldFBvaW50VmFsdWVzKGZvY3VzLCBsYXN0Rm9jdXMua2V5LCBsYXN0Rm9jdXMub2Zmc2V0LCBsYXN0Rm9jdXMudHlwZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGludGVybmFsUmVzb2x2ZVNlbGVjdGlvblBvaW50cyhhbmNob3JET00sIGFuY2hvck9mZnNldCwgZm9jdXNET00sIGZvY3VzT2Zmc2V0LCBlZGl0b3IsIGxhc3RTZWxlY3Rpb24pIHtcbiAgaWYgKGFuY2hvckRPTSA9PT0gbnVsbCB8fCBmb2N1c0RPTSA9PT0gbnVsbCB8fCAhaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET00sIGZvY3VzRE9NKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgcmVzb2x2ZWRBbmNob3JQb2ludCA9IGludGVybmFsUmVzb2x2ZVNlbGVjdGlvblBvaW50KGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0LCAkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSA/IGxhc3RTZWxlY3Rpb24uYW5jaG9yIDogbnVsbCwgZWRpdG9yKTtcblxuICBpZiAocmVzb2x2ZWRBbmNob3JQb2ludCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgcmVzb2x2ZWRGb2N1c1BvaW50ID0gaW50ZXJuYWxSZXNvbHZlU2VsZWN0aW9uUG9pbnQoZm9jdXNET00sIGZvY3VzT2Zmc2V0LCAkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSA/IGxhc3RTZWxlY3Rpb24uZm9jdXMgOiBudWxsLCBlZGl0b3IpO1xuXG4gIGlmIChyZXNvbHZlZEZvY3VzUG9pbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChyZXNvbHZlZEFuY2hvclBvaW50LnR5cGUgPT09ICdlbGVtZW50JyAmJiByZXNvbHZlZEZvY3VzUG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGdldE5vZGVGcm9tRE9NKGFuY2hvckRPTSk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZ2V0Tm9kZUZyb21ET00oZm9jdXNET00pOyAvLyBFbnN1cmUgaWYgd2UncmUgc2VsZWN0aW5nIHRoZSBjb250ZW50IG9mIGEgZGVjb3JhdG9yIHRoYXQgd2VcbiAgICAvLyByZXR1cm4gbnVsbCBmb3IgdGhpcyBwb2ludCwgYXMgaXQncyBub3QgaW4gdGhlIGNvbnRyb2xsZWQgc2NvcGVcbiAgICAvLyBvZiBMZXhpY2FsLlxuXG4gICAgaWYgKCRpc0RlY29yYXRvck5vZGUoYW5jaG9yTm9kZSkgJiYgJGlzRGVjb3JhdG9yTm9kZShmb2N1c05vZGUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gLy8gSGFuZGxlIG5vcm1hbGl6YXRpb24gb2Ygc2VsZWN0aW9uIHdoZW4gaXQgaXMgYXQgdGhlIGJvdW5kYXJpZXMuXG5cblxuICBub3JtYWxpemVTZWxlY3Rpb25Qb2ludHNGb3JCb3VuZGFyaWVzKHJlc29sdmVkQW5jaG9yUG9pbnQsIHJlc29sdmVkRm9jdXNQb2ludCwgbGFzdFNlbGVjdGlvbik7XG4gIHJldHVybiBbcmVzb2x2ZWRBbmNob3JQb2ludCwgcmVzb2x2ZWRGb2N1c1BvaW50XTtcbn1cblxuZnVuY3Rpb24gJGlzQmxvY2tFbGVtZW50Tm9kZShub2RlKSB7XG4gIHJldHVybiAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhbm9kZS5pc0lubGluZSgpO1xufSAvLyBUaGlzIGlzIHVzZWQgdG8gbWFrZSBhIHNlbGVjdGlvbiB3aGVuIHRoZSBleGlzdGluZ1xuLy8gc2VsZWN0aW9uIGlzIG51bGwsIGkuZS4gZm9yY2luZyBzZWxlY3Rpb24gb24gdGhlIGVkaXRvclxuLy8gd2hlbiBpdCBjdXJyZW50IGV4aXN0cyBvdXRzaWRlIHRoZSBlZGl0b3IuXG5cbmZ1bmN0aW9uIGludGVybmFsTWFrZVJhbmdlU2VsZWN0aW9uKGFuY2hvcktleSwgYW5jaG9yT2Zmc2V0LCBmb2N1c0tleSwgZm9jdXNPZmZzZXQsIGFuY2hvclR5cGUsIGZvY3VzVHlwZSkge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IG5ldyBSYW5nZVNlbGVjdGlvbigkY3JlYXRlUG9pbnQoYW5jaG9yS2V5LCBhbmNob3JPZmZzZXQsIGFuY2hvclR5cGUpLCAkY3JlYXRlUG9pbnQoZm9jdXNLZXksIGZvY3VzT2Zmc2V0LCBmb2N1c1R5cGUpLCAwLCAnJyk7XG4gIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gIGVkaXRvclN0YXRlLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gIHJldHVybiBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKSB7XG4gIGNvbnN0IGFuY2hvciA9ICRjcmVhdGVQb2ludCgncm9vdCcsIDAsICdlbGVtZW50Jyk7XG4gIGNvbnN0IGZvY3VzID0gJGNyZWF0ZVBvaW50KCdyb290JywgMCwgJ2VsZW1lbnQnKTtcbiAgcmV0dXJuIG5ldyBSYW5nZVNlbGVjdGlvbihhbmNob3IsIGZvY3VzLCAwLCAnJyk7XG59XG5mdW5jdGlvbiAkY3JlYXRlTm9kZVNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKG5ldyBTZXQoKSk7XG59XG5mdW5jdGlvbiBERVBSRUNBVEVEXyRjcmVhdGVHcmlkU2VsZWN0aW9uKCkge1xuICBjb25zdCBhbmNob3IgPSAkY3JlYXRlUG9pbnQoJ3Jvb3QnLCAwLCAnZWxlbWVudCcpO1xuICBjb25zdCBmb2N1cyA9ICRjcmVhdGVQb2ludCgncm9vdCcsIDAsICdlbGVtZW50Jyk7XG4gIHJldHVybiBuZXcgR3JpZFNlbGVjdGlvbigncm9vdCcsIGFuY2hvciwgZm9jdXMpO1xufVxuZnVuY3Rpb24gaW50ZXJuYWxDcmVhdGVTZWxlY3Rpb24oZWRpdG9yKSB7XG4gIGNvbnN0IGN1cnJlbnRFZGl0b3JTdGF0ZSA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBsYXN0U2VsZWN0aW9uID0gY3VycmVudEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7XG5cbiAgaWYgKCRpc05vZGVTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgfHwgREVQUkVDQVRFRF8kaXNHcmlkU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGxhc3RTZWxlY3Rpb24uY2xvbmUoKTtcbiAgfVxuXG4gIHJldHVybiBpbnRlcm5hbENyZWF0ZVJhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24sIGRvbVNlbGVjdGlvbiwgZWRpdG9yKTtcbn1cbmZ1bmN0aW9uIGludGVybmFsQ3JlYXRlUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbiwgZG9tU2VsZWN0aW9uLCBlZGl0b3IpIHtcbiAgY29uc3Qgd2luZG93T2JqID0gZWRpdG9yLl93aW5kb3c7XG5cbiAgaWYgKHdpbmRvd09iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIFdoZW4gd2UgY3JlYXRlIGEgc2VsZWN0aW9uLCB3ZSB0cnkgdG8gdXNlIHRoZSBwcmV2aW91c1xuICAvLyBzZWxlY3Rpb24gd2hlcmUgcG9zc2libGUsIHVubGVzcyBhbiBhY3R1YWwgdXNlciBzZWxlY3Rpb25cbiAgLy8gY2hhbmdlIGhhcyBvY2N1cnJlZC4gV2hlbiB3ZSBkbyBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBzZWxlY3Rpb25cbiAgLy8gd2UgdmFsaWRhdGUgd2UgY2FuIGhhdmUgdGV4dCBub2RlcyBmb3IgYm90aCBhbmNob3IgYW5kIGZvY3VzXG4gIC8vIG5vZGVzLiBJZiB0aGF0IGhvbGRzIHRydWUsIHdlIHRoZW4gcmV0dXJuIHRoYXQgc2VsZWN0aW9uXG4gIC8vIGFzIGEgbXV0YWJsZSBvYmplY3QgdGhhdCB3ZSB1c2UgZm9yIHRoZSBlZGl0b3Igc3RhdGUgZm9yIHRoaXNcbiAgLy8gdXBkYXRlIGN5Y2xlLiBJZiBhIHNlbGVjdGlvbiBnZXRzIGNoYW5nZWQsIGFuZCByZXF1aXJlcyBhXG4gIC8vIHVwZGF0ZSB0byBuYXRpdmUgRE9NIHNlbGVjdGlvbiwgaXQgZ2V0cyBtYXJrZWQgYXMgXCJkaXJ0eVwiLlxuICAvLyBJZiB0aGUgc2VsZWN0aW9uIGNoYW5nZXMsIGJ1dCBtYXRjaGVzIHdpdGggdGhlIGV4aXN0aW5nXG4gIC8vIERPTSBzZWxlY3Rpb24sIHRoZW4gd2Ugb25seSBuZWVkIHRvIHN5bmMgaXQuIE90aGVyd2lzZSxcbiAgLy8gd2UgZ2VuZXJhbGx5IGJhaWwgb3V0IG9mIGRvaW5nIGFuIHVwZGF0ZSB0byBzZWxlY3Rpb24gZHVyaW5nXG4gIC8vIHJlY29uY2lsaWF0aW9uIHVubGVzcyB0aGVyZSBhcmUgZGlydHkgbm9kZXMgdGhhdCBuZWVkXG4gIC8vIHJlY29uY2lsaW5nLlxuXG5cbiAgY29uc3Qgd2luZG93RXZlbnQgPSB3aW5kb3dPYmouZXZlbnQ7XG4gIGNvbnN0IGV2ZW50VHlwZSA9IHdpbmRvd0V2ZW50ID8gd2luZG93RXZlbnQudHlwZSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgaXNTZWxlY3Rpb25DaGFuZ2UgPSBldmVudFR5cGUgPT09ICdzZWxlY3Rpb25jaGFuZ2UnO1xuICBjb25zdCB1c2VET01TZWxlY3Rpb24gPSAhZ2V0SXNQcm9jZXNzc2luZ011dGF0aW9ucygpICYmIChpc1NlbGVjdGlvbkNoYW5nZSB8fCBldmVudFR5cGUgPT09ICdiZWZvcmVpbnB1dCcgfHwgZXZlbnRUeXBlID09PSAnY29tcG9zaXRpb25zdGFydCcgfHwgZXZlbnRUeXBlID09PSAnY29tcG9zaXRpb25lbmQnIHx8IGV2ZW50VHlwZSA9PT0gJ2NsaWNrJyAmJiB3aW5kb3dFdmVudCAmJiB3aW5kb3dFdmVudC5kZXRhaWwgPT09IDMgfHwgZXZlbnRUeXBlID09PSAnZHJvcCcgfHwgZXZlbnRUeXBlID09PSB1bmRlZmluZWQpO1xuICBsZXQgYW5jaG9yRE9NLCBmb2N1c0RPTSwgYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldDtcblxuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24pIHx8IHVzZURPTVNlbGVjdGlvbikge1xuICAgIGlmIChkb21TZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGFuY2hvckRPTSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgIGZvY3VzRE9NID0gZG9tU2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgICBhbmNob3JPZmZzZXQgPSBkb21TZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICAgIGZvY3VzT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gICAgaWYgKGlzU2VsZWN0aW9uQ2hhbmdlICYmICRpc1JhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24pICYmICFpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pKSB7XG4gICAgICByZXR1cm4gbGFzdFNlbGVjdGlvbi5jbG9uZSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGFzdFNlbGVjdGlvbi5jbG9uZSgpO1xuICB9IC8vIExldCdzIHJlc29sdmUgdGhlIHRleHQgbm9kZXMgZnJvbSB0aGUgb2Zmc2V0cyBhbmQgRE9NIG5vZGVzIHdlIGhhdmUgZnJvbVxuICAvLyBuYXRpdmUgc2VsZWN0aW9uLlxuXG5cbiAgY29uc3QgcmVzb2x2ZWRTZWxlY3Rpb25Qb2ludHMgPSBpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludHMoYW5jaG9yRE9NLCBhbmNob3JPZmZzZXQsIGZvY3VzRE9NLCBmb2N1c09mZnNldCwgZWRpdG9yLCBsYXN0U2VsZWN0aW9uKTtcblxuICBpZiAocmVzb2x2ZWRTZWxlY3Rpb25Qb2ludHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IFtyZXNvbHZlZEFuY2hvclBvaW50LCByZXNvbHZlZEZvY3VzUG9pbnRdID0gcmVzb2x2ZWRTZWxlY3Rpb25Qb2ludHM7XG4gIHJldHVybiBuZXcgUmFuZ2VTZWxlY3Rpb24ocmVzb2x2ZWRBbmNob3JQb2ludCwgcmVzb2x2ZWRGb2N1c1BvaW50LCAhJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgPyAwIDogbGFzdFNlbGVjdGlvbi5mb3JtYXQsICEkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSA/ICcnIDogbGFzdFNlbGVjdGlvbi5zdHlsZSk7XG59XG5mdW5jdGlvbiAkZ2V0U2VsZWN0aW9uKCkge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIHJldHVybiBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJGdldFByZXZpb3VzU2VsZWN0aW9uKCkge1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgcmV0dXJuIGVkaXRvci5fZWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uICR1cGRhdGVFbGVtZW50U2VsZWN0aW9uT25DcmVhdGVEZWxldGVOb2RlKHNlbGVjdGlvbiwgcGFyZW50Tm9kZSwgbm9kZU9mZnNldCwgdGltZXMgPSAxKSB7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuXG4gIGlmICghcGFyZW50Tm9kZS5pcyhhbmNob3JOb2RlKSAmJiAhcGFyZW50Tm9kZS5pcyhmb2N1c05vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgcGFyZW50S2V5ID0gcGFyZW50Tm9kZS5fX2tleTsgLy8gU2luZ2xlIG5vZGUuIFdlIHNoaWZ0IHNlbGVjdGlvbiBidXQgbmV2ZXIgcmVkaW1lbnNpb24gaXRcblxuICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICBjb25zdCBzZWxlY3Rpb25PZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuXG4gICAgaWYgKG5vZGVPZmZzZXQgPD0gc2VsZWN0aW9uT2Zmc2V0ICYmIHRpbWVzID4gMCB8fCBub2RlT2Zmc2V0IDwgc2VsZWN0aW9uT2Zmc2V0ICYmIHRpbWVzIDwgMCkge1xuICAgICAgY29uc3QgbmV3U2VsZWN0aW9uT2Zmc2V0ID0gTWF0aC5tYXgoMCwgc2VsZWN0aW9uT2Zmc2V0ICsgdGltZXMpO1xuICAgICAgYW5jaG9yLnNldChwYXJlbnRLZXksIG5ld1NlbGVjdGlvbk9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgIGZvY3VzLnNldChwYXJlbnRLZXksIG5ld1NlbGVjdGlvbk9mZnNldCwgJ2VsZW1lbnQnKTsgLy8gVGhlIG5ldyBzZWxlY3Rpb24gbWlnaHQgcG9pbnQgdG8gdGV4dCBub2RlcywgdHJ5IHRvIHJlc29sdmUgdGhlbVxuXG4gICAgICAkdXBkYXRlU2VsZWN0aW9uUmVzb2x2ZVRleHROb2RlcyhzZWxlY3Rpb24pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBNdWx0aXBsZSBub2RlcyBzZWxlY3RlZC4gV2Ugc2hpZnQgb3IgcmVkaW1lbnNpb24gc2VsZWN0aW9uXG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGlzQmFja3dhcmQgPyBmb2N1cyA6IGFuY2hvcjtcbiAgICBjb25zdCBmaXJzdFBvaW50Tm9kZSA9IGZpcnN0UG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGlzQmFja3dhcmQgPyBhbmNob3IgOiBmb2N1cztcbiAgICBjb25zdCBsYXN0UG9pbnROb2RlID0gbGFzdFBvaW50LmdldE5vZGUoKTtcblxuICAgIGlmIChwYXJlbnROb2RlLmlzKGZpcnN0UG9pbnROb2RlKSkge1xuICAgICAgY29uc3QgZmlyc3RQb2ludE9mZnNldCA9IGZpcnN0UG9pbnQub2Zmc2V0O1xuXG4gICAgICBpZiAobm9kZU9mZnNldCA8PSBmaXJzdFBvaW50T2Zmc2V0ICYmIHRpbWVzID4gMCB8fCBub2RlT2Zmc2V0IDwgZmlyc3RQb2ludE9mZnNldCAmJiB0aW1lcyA8IDApIHtcbiAgICAgICAgZmlyc3RQb2ludC5zZXQocGFyZW50S2V5LCBNYXRoLm1heCgwLCBmaXJzdFBvaW50T2Zmc2V0ICsgdGltZXMpLCAnZWxlbWVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJlbnROb2RlLmlzKGxhc3RQb2ludE5vZGUpKSB7XG4gICAgICBjb25zdCBsYXN0UG9pbnRPZmZzZXQgPSBsYXN0UG9pbnQub2Zmc2V0O1xuXG4gICAgICBpZiAobm9kZU9mZnNldCA8PSBsYXN0UG9pbnRPZmZzZXQgJiYgdGltZXMgPiAwIHx8IG5vZGVPZmZzZXQgPCBsYXN0UG9pbnRPZmZzZXQgJiYgdGltZXMgPCAwKSB7XG4gICAgICAgIGxhc3RQb2ludC5zZXQocGFyZW50S2V5LCBNYXRoLm1heCgwLCBsYXN0UG9pbnRPZmZzZXQgKyB0aW1lcyksICdlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRoZSBuZXcgc2VsZWN0aW9uIG1pZ2h0IHBvaW50IHRvIHRleHQgbm9kZXMsIHRyeSB0byByZXNvbHZlIHRoZW1cblxuXG4gICR1cGRhdGVTZWxlY3Rpb25SZXNvbHZlVGV4dE5vZGVzKHNlbGVjdGlvbik7XG59XG5cbmZ1bmN0aW9uICR1cGRhdGVTZWxlY3Rpb25SZXNvbHZlVGV4dE5vZGVzKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG5cbiAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgaWYgKCEkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkU2l6ZSA9IGFuY2hvck5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgY29uc3QgYW5jaG9yT2Zmc2V0QXRFbmQgPSBhbmNob3JPZmZzZXQgPj0gY2hpbGRTaXplO1xuICAgIGNvbnN0IGNoaWxkID0gYW5jaG9yT2Zmc2V0QXRFbmQgPyBhbmNob3JOb2RlLmdldENoaWxkQXRJbmRleChjaGlsZFNpemUgLSAxKSA6IGFuY2hvck5vZGUuZ2V0Q2hpbGRBdEluZGV4KGFuY2hvck9mZnNldCk7XG5cbiAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICBsZXQgbmV3T2Zmc2V0ID0gMDtcblxuICAgICAgaWYgKGFuY2hvck9mZnNldEF0RW5kKSB7XG4gICAgICAgIG5ld09mZnNldCA9IGNoaWxkLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgfVxuXG4gICAgICBhbmNob3Iuc2V0KGNoaWxkLl9fa2V5LCBuZXdPZmZzZXQsICd0ZXh0Jyk7XG4gICAgICBmb2N1cy5zZXQoY2hpbGQuX19rZXksIG5ld09mZnNldCwgJ3RleHQnKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICBjb25zdCBjaGlsZFNpemUgPSBhbmNob3JOb2RlLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgIGNvbnN0IGFuY2hvck9mZnNldEF0RW5kID0gYW5jaG9yT2Zmc2V0ID49IGNoaWxkU2l6ZTtcbiAgICBjb25zdCBjaGlsZCA9IGFuY2hvck9mZnNldEF0RW5kID8gYW5jaG9yTm9kZS5nZXRDaGlsZEF0SW5kZXgoY2hpbGRTaXplIC0gMSkgOiBhbmNob3JOb2RlLmdldENoaWxkQXRJbmRleChhbmNob3JPZmZzZXQpO1xuXG4gICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgbGV0IG5ld09mZnNldCA9IDA7XG5cbiAgICAgIGlmIChhbmNob3JPZmZzZXRBdEVuZCkge1xuICAgICAgICBuZXdPZmZzZXQgPSBjaGlsZC5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIH1cblxuICAgICAgYW5jaG9yLnNldChjaGlsZC5fX2tleSwgbmV3T2Zmc2V0LCAndGV4dCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICgkaXNFbGVtZW50Tm9kZShmb2N1c05vZGUpKSB7XG4gICAgY29uc3QgY2hpbGRTaXplID0gZm9jdXNOb2RlLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgIGNvbnN0IGZvY3VzT2Zmc2V0QXRFbmQgPSBmb2N1c09mZnNldCA+PSBjaGlsZFNpemU7XG4gICAgY29uc3QgY2hpbGQgPSBmb2N1c09mZnNldEF0RW5kID8gZm9jdXNOb2RlLmdldENoaWxkQXRJbmRleChjaGlsZFNpemUgLSAxKSA6IGZvY3VzTm9kZS5nZXRDaGlsZEF0SW5kZXgoZm9jdXNPZmZzZXQpO1xuXG4gICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgbGV0IG5ld09mZnNldCA9IDA7XG5cbiAgICAgIGlmIChmb2N1c09mZnNldEF0RW5kKSB7XG4gICAgICAgIG5ld09mZnNldCA9IGNoaWxkLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgfVxuXG4gICAgICBmb2N1cy5zZXQoY2hpbGQuX19rZXksIG5ld09mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlTZWxlY3Rpb25UcmFuc2Zvcm1zKG5leHRFZGl0b3JTdGF0ZSwgZWRpdG9yKSB7XG4gIGNvbnN0IHByZXZFZGl0b3JTdGF0ZSA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBwcmV2U2VsZWN0aW9uID0gcHJldkVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IG5leHRTZWxlY3Rpb24gPSBuZXh0RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcblxuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24obmV4dFNlbGVjdGlvbikpIHtcbiAgICBjb25zdCBhbmNob3IgPSBuZXh0U2VsZWN0aW9uLmFuY2hvcjtcbiAgICBjb25zdCBmb2N1cyA9IG5leHRTZWxlY3Rpb24uZm9jdXM7XG4gICAgbGV0IGFuY2hvck5vZGU7XG5cbiAgICBpZiAoYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBhbmNob3JOb2RlLnNlbGVjdGlvblRyYW5zZm9ybShwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoZm9jdXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG5cbiAgICAgIGlmIChhbmNob3JOb2RlICE9PSBmb2N1c05vZGUpIHtcbiAgICAgICAgZm9jdXNOb2RlLnNlbGVjdGlvblRyYW5zZm9ybShwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1vdmVTZWxlY3Rpb25Qb2ludFRvU2libGluZyhwb2ludCwgbm9kZSwgcGFyZW50LCBwcmV2U2libGluZywgbmV4dFNpYmxpbmcpIHtcbiAgbGV0IHNpYmxpbmdLZXkgPSBudWxsO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgbGV0IHR5cGUgPSBudWxsO1xuXG4gIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgIHNpYmxpbmdLZXkgPSBwcmV2U2libGluZy5fX2tleTtcblxuICAgIGlmICgkaXNUZXh0Tm9kZShwcmV2U2libGluZykpIHtcbiAgICAgIG9mZnNldCA9IHByZXZTaWJsaW5nLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgdHlwZSA9ICd0ZXh0JztcbiAgICB9IGVsc2UgaWYgKCRpc0VsZW1lbnROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgb2Zmc2V0ID0gcHJldlNpYmxpbmcuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgICB0eXBlID0gJ2VsZW1lbnQnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHNpYmxpbmdLZXkgPSBuZXh0U2libGluZy5fX2tleTtcblxuICAgICAgaWYgKCRpc1RleHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgICB0eXBlID0gJ3RleHQnO1xuICAgICAgfSBlbHNlIGlmICgkaXNFbGVtZW50Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgICAgdHlwZSA9ICdlbGVtZW50JztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoc2libGluZ0tleSAhPT0gbnVsbCAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgcG9pbnQuc2V0KHNpYmxpbmdLZXksIG9mZnNldCwgdHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuXG4gICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgIC8vIE1vdmUgc2VsZWN0aW9uIHRvIGVuZCBvZiBwYXJlbnRcbiAgICAgIG9mZnNldCA9IHBhcmVudC5nZXRDaGlsZHJlblNpemUoKTtcbiAgICB9XG5cbiAgICBwb2ludC5zZXQocGFyZW50Ll9fa2V5LCBvZmZzZXQsICdlbGVtZW50Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkanVzdFBvaW50T2Zmc2V0Rm9yTWVyZ2VkU2libGluZyhwb2ludCwgaXNCZWZvcmUsIGtleSwgdGFyZ2V0LCB0ZXh0TGVuZ3RoKSB7XG4gIGlmIChwb2ludC50eXBlID09PSAndGV4dCcpIHtcbiAgICBwb2ludC5rZXkgPSBrZXk7XG5cbiAgICBpZiAoIWlzQmVmb3JlKSB7XG4gICAgICBwb2ludC5vZmZzZXQgKz0gdGV4dExlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAocG9pbnQub2Zmc2V0ID4gdGFyZ2V0LmdldEluZGV4V2l0aGluUGFyZW50KCkpIHtcbiAgICBwb2ludC5vZmZzZXQgLT0gMTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlRE9NU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24sIGVkaXRvciwgZG9tU2VsZWN0aW9uLCB0YWdzLCByb290RWxlbWVudCwgbm9kZUNvdW50KSB7XG4gIGNvbnN0IGFuY2hvckRPTU5vZGUgPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgY29uc3QgZm9jdXNET01Ob2RlID0gZG9tU2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgY29uc3QgZm9jdXNPZmZzZXQgPSBkb21TZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50OyAvLyBUT0RPOiBtYWtlIHRoaXMgbm90IGhhcmQtY29kZWQsIGFuZCBhZGQgYW5vdGhlciBjb25maWcgb3B0aW9uXG4gIC8vIHRoYXQgbWFrZXMgdGhpcyBjb25maWd1cmFibGUuXG5cbiAgaWYgKHRhZ3MuaGFzKCdjb2xsYWJvcmF0aW9uJykgJiYgYWN0aXZlRWxlbWVudCAhPT0gcm9vdEVsZW1lbnQgfHwgYWN0aXZlRWxlbWVudCAhPT0gbnVsbCAmJiBpc1NlbGVjdGlvbkNhcHR1cmVkSW5EZWNvcmF0b3JJbnB1dChhY3RpdmVFbGVtZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24obmV4dFNlbGVjdGlvbikpIHtcbiAgICAvLyBXZSBkb24ndCByZW1vdmUgc2VsZWN0aW9uIGlmIHRoZSBwcmV2U2VsZWN0aW9uIGlzIG51bGwgYmVjYXVzZVxuICAgIC8vIG9mIGVkaXRvci5zZXRSb290RWxlbWVudCgpLiBJZiB0aGlzIG9jY3VycyBvbiBpbml0IHdoZW4gdGhlXG4gICAgLy8gZWRpdG9yIGlzIGFscmVhZHkgZm9jdXNlZCwgdGhlbiB0aGlzIGNhbiBjYXVzZSB0aGUgZWRpdG9yIHRvXG4gICAgLy8gbG9zZSBmb2N1cy5cbiAgICBpZiAocHJldlNlbGVjdGlvbiAhPT0gbnVsbCAmJiBpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTU5vZGUsIGZvY3VzRE9NTm9kZSkpIHtcbiAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBhbmNob3IgPSBuZXh0U2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBuZXh0U2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JLZXkgPSBhbmNob3Iua2V5O1xuICBjb25zdCBmb2N1c0tleSA9IGZvY3VzLmtleTtcbiAgY29uc3QgYW5jaG9yRE9NID0gZ2V0RWxlbWVudEJ5S2V5T3JUaHJvdyhlZGl0b3IsIGFuY2hvcktleSk7XG4gIGNvbnN0IGZvY3VzRE9NID0gZ2V0RWxlbWVudEJ5S2V5T3JUaHJvdyhlZGl0b3IsIGZvY3VzS2V5KTtcbiAgY29uc3QgbmV4dEFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IG5leHRGb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgY29uc3QgbmV4dEZvcm1hdCA9IG5leHRTZWxlY3Rpb24uZm9ybWF0O1xuICBjb25zdCBuZXh0U3R5bGUgPSBuZXh0U2VsZWN0aW9uLnN0eWxlO1xuICBjb25zdCBpc0NvbGxhcHNlZCA9IG5leHRTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKTtcbiAgbGV0IG5leHRBbmNob3JOb2RlID0gYW5jaG9yRE9NO1xuICBsZXQgbmV4dEZvY3VzTm9kZSA9IGZvY3VzRE9NO1xuICBsZXQgYW5jaG9yRm9ybWF0T3JTdHlsZUNoYW5nZWQgPSBmYWxzZTtcblxuICBpZiAoYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIG5leHRBbmNob3JOb2RlID0gZ2V0RE9NVGV4dE5vZGUoYW5jaG9yRE9NKTtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBhbmNob3JGb3JtYXRPclN0eWxlQ2hhbmdlZCA9IGFuY2hvck5vZGUuZ2V0Rm9ybWF0KCkgIT09IG5leHRGb3JtYXQgfHwgYW5jaG9yTm9kZS5nZXRTdHlsZSgpICE9PSBuZXh0U3R5bGU7XG4gIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgcHJldlNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgYW5jaG9yRm9ybWF0T3JTdHlsZUNoYW5nZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGZvY3VzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIG5leHRGb2N1c05vZGUgPSBnZXRET01UZXh0Tm9kZShmb2N1c0RPTSk7XG4gIH0gLy8gSWYgd2UgY2FuJ3QgZ2V0IGFuIHVuZGVybHlpbmcgdGV4dCBub2RlIGZvciBzZWxlY3Rpb24sIHRoZW5cbiAgLy8gd2Ugc2hvdWxkIGF2b2lkIHNldHRpbmcgc2VsZWN0aW9uIHRvIHNvbWV0aGluZyBpbmNvcnJlY3QuXG5cblxuICBpZiAobmV4dEFuY2hvck5vZGUgPT09IG51bGwgfHwgbmV4dEZvY3VzTm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpc0NvbGxhcHNlZCAmJiAocHJldlNlbGVjdGlvbiA9PT0gbnVsbCB8fCBhbmNob3JGb3JtYXRPclN0eWxlQ2hhbmdlZCB8fCAkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiAocHJldlNlbGVjdGlvbi5mb3JtYXQgIT09IG5leHRGb3JtYXQgfHwgcHJldlNlbGVjdGlvbi5zdHlsZSAhPT0gbmV4dFN0eWxlKSkpIHtcbiAgICBtYXJrQ29sbGFwc2VkU2VsZWN0aW9uRm9ybWF0KG5leHRGb3JtYXQsIG5leHRTdHlsZSwgbmV4dEFuY2hvck9mZnNldCwgYW5jaG9yS2V5LCBwZXJmb3JtYW5jZS5ub3coKSk7XG4gIH0gLy8gRGlmZiBhZ2FpbnN0IHRoZSBuYXRpdmUgRE9NIHNlbGVjdGlvbiB0byBlbnN1cmUgd2UgZG9uJ3QgZG9cbiAgLy8gYW4gdW5uZWNlc3Nhcnkgc2VsZWN0aW9uIHVwZGF0ZS4gV2UgYWxzbyBza2lwIHRoaXMgY2hlY2sgaWZcbiAgLy8gd2UncmUgbW92aW5nIHNlbGVjdGlvbiB0byB3aXRoaW4gYW4gZWxlbWVudCwgYXMgdGhpcyBjYW5cbiAgLy8gc29tZXRpbWVzIGJlIHByb2JsZW1hdGljIGFyb3VuZCBzY3JvbGxpbmcuXG5cblxuICBpZiAoYW5jaG9yT2Zmc2V0ID09PSBuZXh0QW5jaG9yT2Zmc2V0ICYmIGZvY3VzT2Zmc2V0ID09PSBuZXh0Rm9jdXNPZmZzZXQgJiYgYW5jaG9yRE9NTm9kZSA9PT0gbmV4dEFuY2hvck5vZGUgJiYgZm9jdXNET01Ob2RlID09PSBuZXh0Rm9jdXNOb2RlICYmIC8vIEJhZGx5IGludGVycHJldGVkIHJhbmdlIHNlbGVjdGlvbiB3aGVuIGNvbGxhcHNlZCAtICMxNDgyXG4gICEoZG9tU2VsZWN0aW9uLnR5cGUgPT09ICdSYW5nZScgJiYgaXNDb2xsYXBzZWQpKSB7XG4gICAgLy8gSWYgdGhlIHJvb3QgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGZvY3VzLCBlbnN1cmUgaXQgaGFzIGZvY3VzXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IG51bGwgfHwgIXJvb3RFbGVtZW50LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICByb290RWxlbWVudC5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhbmNob3IudHlwZSAhPT0gJ2VsZW1lbnQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IC8vIEFwcGx5IHRoZSB1cGRhdGVkIHNlbGVjdGlvbiB0byB0aGUgRE9NLiBOb3RlOiB0aGlzIHdpbGwgdHJpZ2dlclxuICAvLyBhIFwic2VsZWN0aW9uY2hhbmdlXCIgZXZlbnQsIGFsdGhvdWdoIGl0IHdpbGwgYmUgYXN5bmNocm9ub3VzLlxuXG5cbiAgdHJ5IHtcbiAgICBkb21TZWxlY3Rpb24uc2V0QmFzZUFuZEV4dGVudChuZXh0QW5jaG9yTm9kZSwgbmV4dEFuY2hvck9mZnNldCwgbmV4dEZvY3VzTm9kZSwgbmV4dEZvY3VzT2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXJyb3IsIGNvbnRpbnVlLiBUaGlzIGNhbiBzb21ldGltZXNcbiAgICAvLyBvY2N1ciB3aXRoIEZGIGFuZCB0aGVyZSdzIG5vIGdvb2QgcmVhc29uIGFzIHRvIHdoeSBpdFxuICAgIC8vIHNob3VsZCBoYXBwZW4uXG4gIH1cblxuICBpZiAoIXRhZ3MuaGFzKCdza2lwLXNjcm9sbC1pbnRvLXZpZXcnKSAmJiBuZXh0U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgcm9vdEVsZW1lbnQgIT09IG51bGwgJiYgcm9vdEVsZW1lbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICBjb25zdCBzZWxlY3Rpb25UYXJnZXQgPSBuZXh0U2VsZWN0aW9uIGluc3RhbmNlb2YgUmFuZ2VTZWxlY3Rpb24gJiYgbmV4dFNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnID8gbmV4dEFuY2hvck5vZGUuY2hpbGROb2Rlc1tuZXh0QW5jaG9yT2Zmc2V0XSB8fCBudWxsIDogZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwID8gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCkgOiBudWxsO1xuXG4gICAgaWYgKHNlbGVjdGlvblRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgbGV0IHNlbGVjdGlvblJlY3Q7XG5cbiAgICAgIGlmIChzZWxlY3Rpb25UYXJnZXQgaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShzZWxlY3Rpb25UYXJnZXQpO1xuICAgICAgICBzZWxlY3Rpb25SZWN0ID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3Rpb25SZWN0ID0gc2VsZWN0aW9uVGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfVxuXG4gICAgICBzY3JvbGxJbnRvVmlld0lmTmVlZGVkKGVkaXRvciwgc2VsZWN0aW9uUmVjdCwgcm9vdEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIG1hcmtTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlKCk7XG59XG5mdW5jdGlvbiAkaW5zZXJ0Tm9kZXMobm9kZXMsIHNlbGVjdFN0YXJ0KSB7XG4gIGxldCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkgfHwgJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG5cbiAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHNlbGVjdGlvbiA9ICRnZXRSb290KCkuc2VsZWN0RW5kKCk7XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uLmluc2VydE5vZGVzKG5vZGVzLCBzZWxlY3RTdGFydCk7XG59XG5mdW5jdGlvbiAkZ2V0VGV4dENvbnRlbnQoKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoc2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbi5nZXRUZXh0Q29udGVudCgpO1xufVxuZnVuY3Rpb24gREVQUkVDQVRFRF8kY29tcHV0ZUdyaWRNYXAoZ3JpZCwgY2VsbEEsIGNlbGxCKSB7XG4gIGNvbnN0IHRhYmxlTWFwID0gW107XG4gIGxldCBjZWxsQVZhbHVlID0gbnVsbDtcbiAgbGV0IGNlbGxCVmFsdWUgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHdyaXRlKHN0YXJ0Um93LCBzdGFydENvbHVtbiwgY2VsbCkge1xuICAgIGNvbnN0IHZhbHVlID0ge1xuICAgICAgY2VsbCxcbiAgICAgIHN0YXJ0Q29sdW1uLFxuICAgICAgc3RhcnRSb3dcbiAgICB9O1xuICAgIGNvbnN0IHJvd1NwYW4gPSBjZWxsLl9fcm93U3BhbjtcbiAgICBjb25zdCBjb2xTcGFuID0gY2VsbC5fX2NvbFNwYW47XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd1NwYW47IGkrKykge1xuICAgICAgaWYgKHRhYmxlTWFwW3N0YXJ0Um93ICsgaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0YWJsZU1hcFtzdGFydFJvdyArIGldID0gW107XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sU3BhbjsgaisrKSB7XG4gICAgICAgIHRhYmxlTWFwW3N0YXJ0Um93ICsgaV1bc3RhcnRDb2x1bW4gKyBqXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjZWxsQS5pcyhjZWxsKSkge1xuICAgICAgY2VsbEFWYWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChjZWxsQi5pcyhjZWxsKSkge1xuICAgICAgY2VsbEJWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRW1wdHkocm93LCBjb2x1bW4pIHtcbiAgICByZXR1cm4gdGFibGVNYXBbcm93XSA9PT0gdW5kZWZpbmVkIHx8IHRhYmxlTWFwW3Jvd11bY29sdW1uXSA9PT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgZ3JpZENoaWxkcmVuID0gZ3JpZC5nZXRDaGlsZHJlbigpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JpZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgcm93ID0gZ3JpZENoaWxkcmVuW2ldO1xuXG4gICAgaWYgKCFERVBSRUNBVEVEXyRpc0dyaWRSb3dOb2RlKHJvdykpIHtcbiAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBHcmlkTm9kZSBjaGlsZHJlbiB0byBiZSBHcmlkUm93Tm9kZWApO1xuICAgIH1cblxuICAgIGNvbnN0IHJvd0NoaWxkcmVuID0gcm93LmdldENoaWxkcmVuKCk7XG4gICAgbGV0IGogPSAwO1xuXG4gICAgZm9yIChjb25zdCBjZWxsIG9mIHJvd0NoaWxkcmVuKSB7XG4gICAgICBpZiAoIURFUFJFQ0FURURfJGlzR3JpZENlbGxOb2RlKGNlbGwpKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBHcmlkUm93Tm9kZSBjaGlsZHJlbiB0byBiZSBHcmlkQ2VsbE5vZGVgKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCFpc0VtcHR5KGksIGopKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cblxuICAgICAgd3JpdGUoaSwgaiwgY2VsbCk7XG4gICAgICBqICs9IGNlbGwuX19jb2xTcGFuO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKGNlbGxBVmFsdWUgIT09IG51bGwpKSB7XG4gICAgdGhyb3cgRXJyb3IoYEFuY2hvciBub3QgZm91bmQgaW4gR3JpZGApO1xuICB9XG5cbiAgaWYgKCEoY2VsbEJWYWx1ZSAhPT0gbnVsbCkpIHtcbiAgICB0aHJvdyBFcnJvcihgRm9jdXMgbm90IGZvdW5kIGluIEdyaWRgKTtcbiAgfVxuXG4gIHJldHVybiBbdGFibGVNYXAsIGNlbGxBVmFsdWUsIGNlbGxCVmFsdWVdO1xufVxuZnVuY3Rpb24gREVQUkVDQVRFRF8kZ2V0Tm9kZVRyaXBsZXQoc291cmNlKSB7XG4gIGxldCBjZWxsO1xuXG4gIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBERVBSRUNBVEVEX0dyaWRDZWxsTm9kZSkge1xuICAgIGNlbGwgPSBzb3VyY2U7XG4gIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgTGV4aWNhbE5vZGUpIHtcbiAgICBjb25zdCBjZWxsXyA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc291cmNlLCBERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZSk7XG5cbiAgICBpZiAoIURFUFJFQ0FURURfJGlzR3JpZENlbGxOb2RlKGNlbGxfKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRvIGZpbmQgYSBwYXJlbnQgR3JpZENlbGxOb2RlYCk7XG4gICAgfVxuXG4gICAgY2VsbCA9IGNlbGxfO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNlbGxfID0gJGZpbmRNYXRjaGluZ1BhcmVudChzb3VyY2UuZ2V0Tm9kZSgpLCBERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZSk7XG5cbiAgICBpZiAoIURFUFJFQ0FURURfJGlzR3JpZENlbGxOb2RlKGNlbGxfKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYEV4cGVjdGVkIHRvIGZpbmQgYSBwYXJlbnQgR3JpZENlbGxOb2RlYCk7XG4gICAgfVxuXG4gICAgY2VsbCA9IGNlbGxfO1xuICB9XG5cbiAgY29uc3Qgcm93ID0gY2VsbC5nZXRQYXJlbnQoKTtcblxuICBpZiAoIURFUFJFQ0FURURfJGlzR3JpZFJvd05vZGUocm93KSkge1xuICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBHcmlkQ2VsbE5vZGUgdG8gaGF2ZSBhIHBhcmVudCBHcmlkUm93Tm9kZWApO1xuICB9XG5cbiAgY29uc3QgZ3JpZCA9IHJvdy5nZXRQYXJlbnQoKTtcblxuICBpZiAoIURFUFJFQ0FURURfJGlzR3JpZE5vZGUoZ3JpZCkpIHtcbiAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgR3JpZFJvd05vZGUgdG8gaGF2ZSBhIHBhcmVudCBHcmlkTm9kZWApO1xuICB9XG5cbiAgcmV0dXJuIFtjZWxsLCByb3csIGdyaWRdO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5sZXQgYWN0aXZlRWRpdG9yU3RhdGUgPSBudWxsO1xubGV0IGFjdGl2ZUVkaXRvciA9IG51bGw7XG5sZXQgaXNSZWFkT25seU1vZGUgPSBmYWxzZTtcbmxldCBpc0F0dGVtcHRpbmdUb1JlY292ZXJGcm9tUmVjb25jaWxlckVycm9yID0gZmFsc2U7XG5sZXQgaW5maW5pdGVUcmFuc2Zvcm1Db3VudCA9IDA7XG5jb25zdCBvYnNlcnZlck9wdGlvbnMgPSB7XG4gIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gIGNoaWxkTGlzdDogdHJ1ZSxcbiAgc3VidHJlZTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkge1xuICByZXR1cm4gaXNSZWFkT25seU1vZGUgfHwgYWN0aXZlRWRpdG9yU3RhdGUgIT09IG51bGwgJiYgYWN0aXZlRWRpdG9yU3RhdGUuX3JlYWRPbmx5O1xufVxuZnVuY3Rpb24gZXJyb3JPblJlYWRPbmx5KCkge1xuICBpZiAoaXNSZWFkT25seU1vZGUpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgQ2Fubm90IHVzZSBtZXRob2QgaW4gcmVhZC1vbmx5IG1vZGUuYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlcnJvck9uSW5maW5pdGVUcmFuc2Zvcm1zKCkge1xuICBpZiAoaW5maW5pdGVUcmFuc2Zvcm1Db3VudCA+IDk5KSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYE9uZSBvciBtb3JlIHRyYW5zZm9ybXMgYXJlIGVuZGxlc3NseSB0cmlnZ2VyaW5nIGFkZGl0aW9uYWwgdHJhbnNmb3Jtcy4gTWF5IGhhdmUgZW5jb3VudGVyZWQgaW5maW5pdGUgcmVjdXJzaW9uIGNhdXNlZCBieSB0cmFuc2Zvcm1zIHRoYXQgaGF2ZSB0aGVpciBwcmVjb25kaXRpb25zIHRvbyBsb3NlIGFuZC9vciBjb25mbGljdCB3aXRoIGVhY2ggb3RoZXIuYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRBY3RpdmVFZGl0b3JTdGF0ZSgpIHtcbiAgaWYgKGFjdGl2ZUVkaXRvclN0YXRlID09PSBudWxsKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGFuIGFjdGl2ZSBlZGl0b3Igc3RhdGUuIFN0YXRlIGhlbHBlcnMgb3Igbm9kZSBtZXRob2RzIGNhbiBvbmx5IGJlIHVzZWQgc3luY2hyb25vdXNseSBkdXJpbmcgdGhlIGNhbGxiYWNrIG9mIGVkaXRvci51cGRhdGUoKSBvciBlZGl0b3JTdGF0ZS5yZWFkKCkuYCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFjdGl2ZUVkaXRvclN0YXRlO1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlRWRpdG9yKCkge1xuICBpZiAoYWN0aXZlRWRpdG9yID09PSBudWxsKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGFuIGFjdGl2ZSBlZGl0b3IuIFRoaXMgbWV0aG9kIGNhbiBvbmx5IGJlIHVzZWQgc3luY2hyb25vdXNseSBkdXJpbmcgdGhlIGNhbGxiYWNrIG9mIGVkaXRvci51cGRhdGUoKS5gKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYWN0aXZlRWRpdG9yO1xufVxuZnVuY3Rpb24gaW50ZXJuYWxHZXRBY3RpdmVFZGl0b3IoKSB7XG4gIHJldHVybiBhY3RpdmVFZGl0b3I7XG59XG5mdW5jdGlvbiAkYXBwbHlUcmFuc2Zvcm1zKGVkaXRvciwgbm9kZSwgdHJhbnNmb3Jtc0NhY2hlKSB7XG4gIGNvbnN0IHR5cGUgPSBub2RlLl9fdHlwZTtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSBnZXRSZWdpc3RlcmVkTm9kZU9yVGhyb3coZWRpdG9yLCB0eXBlKTtcbiAgbGV0IHRyYW5zZm9ybXNBcnIgPSB0cmFuc2Zvcm1zQ2FjaGUuZ2V0KHR5cGUpO1xuXG4gIGlmICh0cmFuc2Zvcm1zQXJyID09PSB1bmRlZmluZWQpIHtcbiAgICB0cmFuc2Zvcm1zQXJyID0gQXJyYXkuZnJvbShyZWdpc3RlcmVkTm9kZS50cmFuc2Zvcm1zKTtcbiAgICB0cmFuc2Zvcm1zQ2FjaGUuc2V0KHR5cGUsIHRyYW5zZm9ybXNBcnIpO1xuICB9XG5cbiAgY29uc3QgdHJhbnNmb3Jtc0Fyckxlbmd0aCA9IHRyYW5zZm9ybXNBcnIubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmb3Jtc0Fyckxlbmd0aDsgaSsrKSB7XG4gICAgdHJhbnNmb3Jtc0FycltpXShub2RlKTtcblxuICAgIGlmICghbm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiAkaXNOb2RlVmFsaWRGb3JUcmFuc2Zvcm0obm9kZSwgY29tcG9zaXRpb25LZXkpIHtcbiAgcmV0dXJuIG5vZGUgIT09IHVuZGVmaW5lZCAmJiAvLyBXZSBkb24ndCB3YW50IHRvIHRyYW5zZm9ybSBub2RlcyBiZWluZyBjb21wb3NlZFxuICBub2RlLl9fa2V5ICE9PSBjb21wb3NpdGlvbktleSAmJiBub2RlLmlzQXR0YWNoZWQoKTtcbn1cblxuZnVuY3Rpb24gJG5vcm1hbGl6ZUFsbERpcnR5VGV4dE5vZGVzKGVkaXRvclN0YXRlLCBlZGl0b3IpIHtcbiAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG5cbiAgZm9yIChjb25zdCBub2RlS2V5IG9mIGRpcnR5TGVhdmVzKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KG5vZGVLZXkpO1xuXG4gICAgaWYgKCRpc1RleHROb2RlKG5vZGUpICYmIG5vZGUuaXNBdHRhY2hlZCgpICYmIG5vZGUuaXNTaW1wbGVUZXh0KCkgJiYgIW5vZGUuaXNVbm1lcmdlYWJsZSgpKSB7XG4gICAgICAkbm9ybWFsaXplVGV4dE5vZGUobm9kZSk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFRyYW5zZm9ybSBoZXVyaXN0aWM6XG4gKiAxLiBXZSB0cmFuc2Zvcm0gbGVhdmVzIGZpcnN0LiBJZiB0cmFuc2Zvcm1zIGdlbmVyYXRlIGFkZGl0aW9uYWwgZGlydHkgbm9kZXMgd2UgcmVwZWF0IHN0ZXAgMS5cbiAqIFRoZSByZWFzb25pbmcgYmVoaW5kIHRoaXMgaXMgdGhhdCBtYXJraW5nIGEgbGVhZiBhcyBkaXJ0eSBtYXJrcyBhbGwgaXRzIHBhcmVudCBlbGVtZW50cyBhcyBkaXJ0eSB0b28uXG4gKiAyLiBXZSB0cmFuc2Zvcm0gZWxlbWVudHMuIElmIGVsZW1lbnQgdHJhbnNmb3JtcyBnZW5lcmF0ZSBhZGRpdGlvbmFsIGRpcnR5IG5vZGVzIHdlIHJlcGVhdCBzdGVwIDEuXG4gKiBJZiBlbGVtZW50IHRyYW5zZm9ybXMgb25seSBnZW5lcmF0ZSBhZGRpdGlvbmFsIGRpcnR5IGVsZW1lbnRzIHdlIG9ubHkgcmVwZWF0IHN0ZXAgMi5cbiAqXG4gKiBOb3RlIHRoYXQgdG8ga2VlcCB0cmFjayBvZiBuZXdseSBkaXJ0eSBub2RlcyBhbmQgc3VidHJlZXMgd2UgbGV2ZXJhZ2UgdGhlIGVkaXRvci5fZGlydHlOb2RlcyBhbmRcbiAqIGVkaXRvci5fc3VidHJlZXMgd2hpY2ggd2UgcmVzZXQgaW4gZXZlcnkgbG9vcC5cbiAqL1xuXG5cbmZ1bmN0aW9uICRhcHBseUFsbFRyYW5zZm9ybXMoZWRpdG9yU3RhdGUsIGVkaXRvcikge1xuICBjb25zdCBkaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gIGNvbnN0IGRpcnR5RWxlbWVudHMgPSBlZGl0b3IuX2RpcnR5RWxlbWVudHM7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgY29uc3QgY29tcG9zaXRpb25LZXkgPSAkZ2V0Q29tcG9zaXRpb25LZXkoKTtcbiAgY29uc3QgdHJhbnNmb3Jtc0NhY2hlID0gbmV3IE1hcCgpO1xuICBsZXQgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzID0gZGlydHlMZWF2ZXM7XG4gIGxldCB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXNMZW5ndGggPSB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXMuc2l6ZTtcbiAgbGV0IHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzID0gZGlydHlFbGVtZW50cztcbiAgbGV0IHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzTGVuZ3RoID0gdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHMuc2l6ZTtcblxuICB3aGlsZSAodW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzTGVuZ3RoID4gMCB8fCB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50c0xlbmd0aCA+IDApIHtcbiAgICBpZiAodW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzTGVuZ3RoID4gMCkge1xuICAgICAgLy8gV2UgbGV2ZXJhZ2UgZWRpdG9yLl9kaXJ0eUxlYXZlcyB0byB0cmFjayB0aGUgbmV3IGRpcnR5IGxlYXZlcyBhZnRlciB0aGUgdHJhbnNmb3Jtc1xuICAgICAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgZm9yIChjb25zdCBub2RlS2V5IG9mIHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlcykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQobm9kZUtleSk7XG5cbiAgICAgICAgaWYgKCRpc1RleHROb2RlKG5vZGUpICYmIG5vZGUuaXNBdHRhY2hlZCgpICYmIG5vZGUuaXNTaW1wbGVUZXh0KCkgJiYgIW5vZGUuaXNVbm1lcmdlYWJsZSgpKSB7XG4gICAgICAgICAgJG5vcm1hbGl6ZVRleHROb2RlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiAkaXNOb2RlVmFsaWRGb3JUcmFuc2Zvcm0obm9kZSwgY29tcG9zaXRpb25LZXkpKSB7XG4gICAgICAgICAgJGFwcGx5VHJhbnNmb3JtcyhlZGl0b3IsIG5vZGUsIHRyYW5zZm9ybXNDYWNoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXJ0eUxlYXZlcy5hZGQobm9kZUtleSk7XG4gICAgICB9XG5cbiAgICAgIHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gICAgICB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXNMZW5ndGggPSB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXMuc2l6ZTsgLy8gV2Ugd2FudCB0byBwcmlvcml0aXplIG5vZGUgdHJhbnNmb3JtcyBvdmVyIGVsZW1lbnQgdHJhbnNmb3Jtc1xuXG4gICAgICBpZiAodW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzTGVuZ3RoID4gMCkge1xuICAgICAgICBpbmZpbml0ZVRyYW5zZm9ybUNvdW50Kys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gLy8gQWxsIGRpcnR5IGxlYXZlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkLiBMZXQncyBkbyBlbGVtZW50cyFcbiAgICAvLyBXZSBoYXZlIHByZXZpb3VzbHkgcHJvY2Vzc2VkIGRpcnR5IGxlYXZlcywgc28gbGV0J3MgcmVzdGFydCB0aGUgZWRpdG9yIGxlYXZlcyBTZXQgdG8gdHJhY2tcbiAgICAvLyBuZXcgb25lcyBjYXVzZWQgYnkgZWxlbWVudCB0cmFuc2Zvcm1zXG5cblxuICAgIGVkaXRvci5fZGlydHlMZWF2ZXMgPSBuZXcgU2V0KCk7XG4gICAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yIChjb25zdCBjdXJyZW50VW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudCBvZiB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50cykge1xuICAgICAgY29uc3Qgbm9kZUtleSA9IGN1cnJlbnRVbnRyYW5zZm9ybWVkRGlydHlFbGVtZW50WzBdO1xuICAgICAgY29uc3QgaW50ZW50aW9uYWxseU1hcmtlZEFzRGlydHkgPSBjdXJyZW50VW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudFsxXTtcblxuICAgICAgaWYgKG5vZGVLZXkgIT09ICdyb290JyAmJiAhaW50ZW50aW9uYWxseU1hcmtlZEFzRGlydHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcblxuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiAkaXNOb2RlVmFsaWRGb3JUcmFuc2Zvcm0obm9kZSwgY29tcG9zaXRpb25LZXkpKSB7XG4gICAgICAgICRhcHBseVRyYW5zZm9ybXMoZWRpdG9yLCBub2RlLCB0cmFuc2Zvcm1zQ2FjaGUpO1xuICAgICAgfVxuXG4gICAgICBkaXJ0eUVsZW1lbnRzLnNldChub2RlS2V5LCBpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eSk7XG4gICAgfVxuXG4gICAgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzID0gZWRpdG9yLl9kaXJ0eUxlYXZlcztcbiAgICB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXNMZW5ndGggPSB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXMuc2l6ZTtcbiAgICB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50cyA9IGVkaXRvci5fZGlydHlFbGVtZW50cztcbiAgICB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50c0xlbmd0aCA9IHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzLnNpemU7XG4gICAgaW5maW5pdGVUcmFuc2Zvcm1Db3VudCsrO1xuICB9XG5cbiAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IGRpcnR5TGVhdmVzO1xuICBlZGl0b3IuX2RpcnR5RWxlbWVudHMgPSBkaXJ0eUVsZW1lbnRzO1xufVxuXG5mdW5jdGlvbiAkcGFyc2VTZXJpYWxpemVkTm9kZShzZXJpYWxpemVkTm9kZSkge1xuICBjb25zdCBpbnRlcm5hbFNlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplZE5vZGU7XG4gIHJldHVybiAkcGFyc2VTZXJpYWxpemVkTm9kZUltcGwoaW50ZXJuYWxTZXJpYWxpemVkTm9kZSwgZ2V0QWN0aXZlRWRpdG9yKCkuX25vZGVzKTtcbn1cblxuZnVuY3Rpb24gJHBhcnNlU2VyaWFsaXplZE5vZGVJbXBsKHNlcmlhbGl6ZWROb2RlLCByZWdpc3RlcmVkTm9kZXMpIHtcbiAgY29uc3QgdHlwZSA9IHNlcmlhbGl6ZWROb2RlLnR5cGU7XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gcmVnaXN0ZXJlZE5vZGVzLmdldCh0eXBlKTtcblxuICBpZiAocmVnaXN0ZXJlZE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKGBwYXJzZUVkaXRvclN0YXRlOiB0eXBlIFwiJHt0eXBlfVwiICsgbm90IGZvdW5kYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgbm9kZUNsYXNzID0gcmVnaXN0ZXJlZE5vZGUua2xhc3M7XG5cbiAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgIT09IG5vZGVDbGFzcy5nZXRUeXBlKCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgTGV4aWNhbE5vZGU6IE5vZGUgJHtub2RlQ2xhc3MubmFtZX0gZG9lcyBub3QgaW1wbGVtZW50IC5pbXBvcnRKU09OKCkuYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgbm9kZSA9IG5vZGVDbGFzcy5pbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKTtcbiAgY29uc3QgY2hpbGRyZW4gPSBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbjtcblxuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkSlNPTkNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgY2hpbGROb2RlID0gJHBhcnNlU2VyaWFsaXplZE5vZGVJbXBsKHNlcmlhbGl6ZWRKU09OQ2hpbGROb2RlLCByZWdpc3RlcmVkTm9kZXMpO1xuICAgICAgbm9kZS5hcHBlbmQoY2hpbGROb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VFZGl0b3JTdGF0ZShzZXJpYWxpemVkRWRpdG9yU3RhdGUsIGVkaXRvciwgdXBkYXRlRm4pIHtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBjcmVhdGVFbXB0eUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGUgPSBhY3RpdmVFZGl0b3JTdGF0ZTtcbiAgY29uc3QgcHJldmlvdXNSZWFkT25seU1vZGUgPSBpc1JlYWRPbmx5TW9kZTtcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3IgPSBhY3RpdmVFZGl0b3I7XG4gIGNvbnN0IHByZXZpb3VzRGlydHlFbGVtZW50cyA9IGVkaXRvci5fZGlydHlFbGVtZW50cztcbiAgY29uc3QgcHJldmlvdXNEaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gIGNvbnN0IHByZXZpb3VzQ2xvbmVOb3ROZWVkZWQgPSBlZGl0b3IuX2Nsb25lTm90TmVlZGVkO1xuICBjb25zdCBwcmV2aW91c0RpcnR5VHlwZSA9IGVkaXRvci5fZGlydHlUeXBlO1xuICBlZGl0b3IuX2RpcnR5RWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gIGVkaXRvci5fZGlydHlMZWF2ZXMgPSBuZXcgU2V0KCk7XG4gIGVkaXRvci5fY2xvbmVOb3ROZWVkZWQgPSBuZXcgU2V0KCk7XG4gIGVkaXRvci5fZGlydHlUeXBlID0gMDtcbiAgYWN0aXZlRWRpdG9yU3RhdGUgPSBlZGl0b3JTdGF0ZTtcbiAgaXNSZWFkT25seU1vZGUgPSBmYWxzZTtcbiAgYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgcmVnaXN0ZXJlZE5vZGVzID0gZWRpdG9yLl9ub2RlcztcbiAgICBjb25zdCBzZXJpYWxpemVkTm9kZSA9IHNlcmlhbGl6ZWRFZGl0b3JTdGF0ZS5yb290O1xuICAgICRwYXJzZVNlcmlhbGl6ZWROb2RlSW1wbChzZXJpYWxpemVkTm9kZSwgcmVnaXN0ZXJlZE5vZGVzKTtcblxuICAgIGlmICh1cGRhdGVGbikge1xuICAgICAgdXBkYXRlRm4oKTtcbiAgICB9IC8vIE1ha2UgdGhlIGVkaXRvclN0YXRlIGltbXV0YWJsZVxuXG5cbiAgICBlZGl0b3JTdGF0ZS5fcmVhZE9ubHkgPSB0cnVlO1xuXG4gICAge1xuICAgICAgaGFuZGxlREVWT25seVBlbmRpbmdVcGRhdGVHdWFyYW50ZWVzKGVkaXRvclN0YXRlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGVkaXRvci5fb25FcnJvcihlcnJvcik7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGVkaXRvci5fZGlydHlFbGVtZW50cyA9IHByZXZpb3VzRGlydHlFbGVtZW50cztcbiAgICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gcHJldmlvdXNEaXJ0eUxlYXZlcztcbiAgICBlZGl0b3IuX2Nsb25lTm90TmVlZGVkID0gcHJldmlvdXNDbG9uZU5vdE5lZWRlZDtcbiAgICBlZGl0b3IuX2RpcnR5VHlwZSA9IHByZXZpb3VzRGlydHlUeXBlO1xuICAgIGFjdGl2ZUVkaXRvclN0YXRlID0gcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZTtcbiAgICBpc1JlYWRPbmx5TW9kZSA9IHByZXZpb3VzUmVhZE9ubHlNb2RlO1xuICAgIGFjdGl2ZUVkaXRvciA9IHByZXZpb3VzQWN0aXZlRWRpdG9yO1xuICB9XG5cbiAgcmV0dXJuIGVkaXRvclN0YXRlO1xufSAvLyBUaGlzIHRlY2huaWNhbGx5IGlzbid0IGFuIHVwZGF0ZSBidXQgZ2l2ZW4gd2UgbmVlZFxuLy8gZXhwb3N1cmUgdG8gdGhlIG1vZHVsZSdzIGFjdGl2ZSBiaW5kaW5ncywgd2UgaGF2ZSB0aGlzXG4vLyBmdW5jdGlvbiBoZXJlXG5cbmZ1bmN0aW9uIHJlYWRFZGl0b3JTdGF0ZShlZGl0b3JTdGF0ZSwgY2FsbGJhY2tGbikge1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlID0gYWN0aXZlRWRpdG9yU3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUmVhZE9ubHlNb2RlID0gaXNSZWFkT25seU1vZGU7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlRWRpdG9yID0gYWN0aXZlRWRpdG9yO1xuICBhY3RpdmVFZGl0b3JTdGF0ZSA9IGVkaXRvclN0YXRlO1xuICBpc1JlYWRPbmx5TW9kZSA9IHRydWU7XG4gIGFjdGl2ZUVkaXRvciA9IG51bGw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2tGbigpO1xuICB9IGZpbmFsbHkge1xuICAgIGFjdGl2ZUVkaXRvclN0YXRlID0gcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZTtcbiAgICBpc1JlYWRPbmx5TW9kZSA9IHByZXZpb3VzUmVhZE9ubHlNb2RlO1xuICAgIGFjdGl2ZUVkaXRvciA9IHByZXZpb3VzQWN0aXZlRWRpdG9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZURFVk9ubHlQZW5kaW5nVXBkYXRlR3VhcmFudGVlcyhwZW5kaW5nRWRpdG9yU3RhdGUpIHtcbiAgLy8gR2l2ZW4gd2UgY2FuJ3QgT2JqZWN0LmZyZWV6ZSB0aGUgbm9kZU1hcCBhcyBpdCdzIGEgTWFwLFxuICAvLyB3ZSBpbnN0ZWFkIHJlcGxhY2UgaXRzIHNldCwgY2xlYXIgYW5kIGRlbGV0ZSBtZXRob2RzLlxuICBjb25zdCBub2RlTWFwID0gcGVuZGluZ0VkaXRvclN0YXRlLl9ub2RlTWFwO1xuXG4gIG5vZGVNYXAuc2V0ID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgc2V0KCkgb24gYSBmcm96ZW4gTGV4aWNhbCBub2RlIG1hcCcpO1xuICB9O1xuXG4gIG5vZGVNYXAuY2xlYXIgPSAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCBjbGVhcigpIG9uIGEgZnJvemVuIExleGljYWwgbm9kZSBtYXAnKTtcbiAgfTtcblxuICBub2RlTWFwLmRlbGV0ZSA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIGRlbGV0ZSgpIG9uIGEgZnJvemVuIExleGljYWwgbm9kZSBtYXAnKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tbWl0UGVuZGluZ1VwZGF0ZXMoZWRpdG9yLCByZWNvdmVyeUVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IHBlbmRpbmdFZGl0b3JTdGF0ZSA9IGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlO1xuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5fcm9vdEVsZW1lbnQ7XG4gIGNvbnN0IHNob3VsZFNraXBET00gPSBlZGl0b3IuX2hlYWRsZXNzIHx8IHJvb3RFbGVtZW50ID09PSBudWxsO1xuXG4gIGlmIChwZW5kaW5nRWRpdG9yU3RhdGUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gPT09PT09XG4gIC8vIFJlY29uY2lsaWF0aW9uIGhhcyBzdGFydGVkLlxuICAvLyA9PT09PT1cblxuXG4gIGNvbnN0IGN1cnJlbnRFZGl0b3JTdGF0ZSA9IGVkaXRvci5fZWRpdG9yU3RhdGU7XG4gIGNvbnN0IGN1cnJlbnRTZWxlY3Rpb24gPSBjdXJyZW50RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgY29uc3QgcGVuZGluZ1NlbGVjdGlvbiA9IHBlbmRpbmdFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBuZWVkc1VwZGF0ZSA9IGVkaXRvci5fZGlydHlUeXBlICE9PSBOT19ESVJUWV9OT0RFUztcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZSA9IGFjdGl2ZUVkaXRvclN0YXRlO1xuICBjb25zdCBwcmV2aW91c1JlYWRPbmx5TW9kZSA9IGlzUmVhZE9ubHlNb2RlO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvciA9IGFjdGl2ZUVkaXRvcjtcbiAgY29uc3QgcHJldmlvdXNseVVwZGF0aW5nID0gZWRpdG9yLl91cGRhdGluZztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBlZGl0b3IuX29ic2VydmVyO1xuICBsZXQgbXV0YXRlZE5vZGVzID0gbnVsbDtcbiAgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBudWxsO1xuICBlZGl0b3IuX2VkaXRvclN0YXRlID0gcGVuZGluZ0VkaXRvclN0YXRlO1xuXG4gIGlmICghc2hvdWxkU2tpcERPTSAmJiBuZWVkc1VwZGF0ZSAmJiBvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIGFjdGl2ZUVkaXRvciA9IGVkaXRvcjtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHBlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgICBpc1JlYWRPbmx5TW9kZSA9IGZhbHNlOyAvLyBXZSBkb24ndCB3YW50IHVwZGF0ZXMgdG8gc3luYyBibG9jayB0aGUgcmVjb25jaWxpYXRpb24uXG5cbiAgICBlZGl0b3IuX3VwZGF0aW5nID0gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkaXJ0eVR5cGUgPSBlZGl0b3IuX2RpcnR5VHlwZTtcbiAgICAgIGNvbnN0IGRpcnR5RWxlbWVudHMgPSBlZGl0b3IuX2RpcnR5RWxlbWVudHM7XG4gICAgICBjb25zdCBkaXJ0eUxlYXZlcyA9IGVkaXRvci5fZGlydHlMZWF2ZXM7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICBtdXRhdGVkTm9kZXMgPSByZWNvbmNpbGVSb290KGN1cnJlbnRFZGl0b3JTdGF0ZSwgcGVuZGluZ0VkaXRvclN0YXRlLCBlZGl0b3IsIGRpcnR5VHlwZSwgZGlydHlFbGVtZW50cywgZGlydHlMZWF2ZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBSZXBvcnQgZXJyb3JzXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBlZGl0b3IuX29uRXJyb3IoZXJyb3IpO1xuICAgICAgfSAvLyBSZXNldCBlZGl0b3IgYW5kIHJlc3RvcmUgaW5jb21pbmcgZWRpdG9yIHN0YXRlIHRvIHRoZSBET01cblxuXG4gICAgICBpZiAoIWlzQXR0ZW1wdGluZ1RvUmVjb3ZlckZyb21SZWNvbmNpbGVyRXJyb3IpIHtcbiAgICAgICAgcmVzZXRFZGl0b3IoZWRpdG9yLCBudWxsLCByb290RWxlbWVudCwgcGVuZGluZ0VkaXRvclN0YXRlKTtcbiAgICAgICAgaW5pdE11dGF0aW9uT2JzZXJ2ZXIoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgICAgICAgaXNBdHRlbXB0aW5nVG9SZWNvdmVyRnJvbVJlY29uY2lsZXJFcnJvciA9IHRydWU7XG4gICAgICAgIGNvbW1pdFBlbmRpbmdVcGRhdGVzKGVkaXRvciwgY3VycmVudEVkaXRvclN0YXRlKTtcbiAgICAgICAgaXNBdHRlbXB0aW5nVG9SZWNvdmVyRnJvbVJlY29uY2lsZXJFcnJvciA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVG8gYXZvaWQgYSBwb3NzaWJsZSBzaXR1YXRpb24gb2YgaW5maW5pdGUgbG9vcHMsIGxldHMgdGhyb3dcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290RWxlbWVudCwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgIGVkaXRvci5fdXBkYXRpbmcgPSBwcmV2aW91c2x5VXBkYXRpbmc7XG4gICAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgICBpc1JlYWRPbmx5TW9kZSA9IHByZXZpb3VzUmVhZE9ubHlNb2RlO1xuICAgICAgYWN0aXZlRWRpdG9yID0gcHJldmlvdXNBY3RpdmVFZGl0b3I7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFwZW5kaW5nRWRpdG9yU3RhdGUuX3JlYWRPbmx5KSB7XG4gICAgcGVuZGluZ0VkaXRvclN0YXRlLl9yZWFkT25seSA9IHRydWU7XG5cbiAgICB7XG4gICAgICBoYW5kbGVERVZPbmx5UGVuZGluZ1VwZGF0ZUd1YXJhbnRlZXMocGVuZGluZ0VkaXRvclN0YXRlKTtcblxuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHBlbmRpbmdTZWxlY3Rpb24pKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUocGVuZGluZ1NlbGVjdGlvbi5hbmNob3IpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHBlbmRpbmdTZWxlY3Rpb24uZm9jdXMpO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZnJlZXplKHBlbmRpbmdTZWxlY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRpcnR5TGVhdmVzID0gZWRpdG9yLl9kaXJ0eUxlYXZlcztcbiAgY29uc3QgZGlydHlFbGVtZW50cyA9IGVkaXRvci5fZGlydHlFbGVtZW50cztcbiAgY29uc3Qgbm9ybWFsaXplZE5vZGVzID0gZWRpdG9yLl9ub3JtYWxpemVkTm9kZXM7XG4gIGNvbnN0IHRhZ3MgPSBlZGl0b3IuX3VwZGF0ZVRhZ3M7XG4gIGNvbnN0IGRlZmVycmVkID0gZWRpdG9yLl9kZWZlcnJlZDtcblxuICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICBlZGl0b3IuX2RpcnR5VHlwZSA9IE5PX0RJUlRZX05PREVTO1xuXG4gICAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZC5jbGVhcigpO1xuXG4gICAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IG5ldyBTZXQoKTtcbiAgICBlZGl0b3IuX2RpcnR5RWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgZWRpdG9yLl9ub3JtYWxpemVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgZWRpdG9yLl91cGRhdGVUYWdzID0gbmV3IFNldCgpO1xuICB9XG5cbiAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWNvcmF0b3JzKGVkaXRvciwgcGVuZGluZ0VkaXRvclN0YXRlKTsgLy8gPT09PT09XG4gIC8vIFJlY29uY2lsaWF0aW9uIGhhcyBmaW5pc2hlZC4gTm93IHVwZGF0ZSBzZWxlY3Rpb24gYW5kIHRyaWdnZXIgbGlzdGVuZXJzLlxuICAvLyA9PT09PT1cblxuICBjb25zdCBkb21TZWxlY3Rpb24gPSBzaG91bGRTa2lwRE9NID8gbnVsbCA6IGdldERPTVNlbGVjdGlvbihlZGl0b3IuX3dpbmRvdyk7IC8vIEF0dGVtcHQgdG8gdXBkYXRlIHRoZSBET00gc2VsZWN0aW9uLCBpbmNsdWRpbmcgZm9jdXNpbmcgb2YgdGhlIHJvb3QgZWxlbWVudCxcbiAgLy8gYW5kIHNjcm9sbCBpbnRvIHZpZXcgaWYgbmVlZGVkLlxuXG4gIGlmIChlZGl0b3IuX2VkaXRhYmxlICYmIC8vIGRvbVNlbGVjdGlvbiB3aWxsIGJlIG51bGwgaW4gaGVhZGxlc3NcbiAgZG9tU2VsZWN0aW9uICE9PSBudWxsICYmIChuZWVkc1VwZGF0ZSB8fCBwZW5kaW5nU2VsZWN0aW9uID09PSBudWxsIHx8IHBlbmRpbmdTZWxlY3Rpb24uZGlydHkpKSB7XG4gICAgYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuICAgIGFjdGl2ZUVkaXRvclN0YXRlID0gcGVuZGluZ0VkaXRvclN0YXRlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWVkc1VwZGF0ZSB8fCBwZW5kaW5nU2VsZWN0aW9uID09PSBudWxsIHx8IHBlbmRpbmdTZWxlY3Rpb24uZGlydHkpIHtcbiAgICAgICAgY29uc3QgYmxvY2tDdXJzb3JFbGVtZW50ID0gZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKGJsb2NrQ3Vyc29yRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlbW92ZURPTUJsb2NrQ3Vyc29yRWxlbWVudChibG9ja0N1cnNvckVsZW1lbnQsIGVkaXRvciwgcm9vdEVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlRE9NU2VsZWN0aW9uKGN1cnJlbnRTZWxlY3Rpb24sIHBlbmRpbmdTZWxlY3Rpb24sIGVkaXRvciwgZG9tU2VsZWN0aW9uLCB0YWdzLCByb290RWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZURPTUJsb2NrQ3Vyc29yRWxlbWVudChlZGl0b3IsIHJvb3RFbGVtZW50LCBwZW5kaW5nU2VsZWN0aW9uKTtcblxuICAgICAgaWYgKG9ic2VydmVyICE9PSBudWxsKSB7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUocm9vdEVsZW1lbnQsIG9ic2VydmVyT3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGFjdGl2ZUVkaXRvciA9IHByZXZpb3VzQWN0aXZlRWRpdG9yO1xuICAgICAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXRhdGVkTm9kZXMgIT09IG51bGwpIHtcbiAgICB0cmlnZ2VyTXV0YXRpb25MaXN0ZW5lcnMoZWRpdG9yLCBtdXRhdGVkTm9kZXMsIHRhZ3MsIGRpcnR5TGVhdmVzLCBjdXJyZW50RWRpdG9yU3RhdGUpO1xuICB9XG5cbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihwZW5kaW5nU2VsZWN0aW9uKSAmJiBwZW5kaW5nU2VsZWN0aW9uICE9PSBudWxsICYmIChjdXJyZW50U2VsZWN0aW9uID09PSBudWxsIHx8ICFjdXJyZW50U2VsZWN0aW9uLmlzKHBlbmRpbmdTZWxlY3Rpb24pKSkge1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICB9XG4gIC8qKlxuICAgKiBDYXB0dXJlIHBlbmRpbmdEZWNvcmF0b3JzIGFmdGVyIGdhcmJhZ2UgY29sbGVjdGluZyBkZXRhY2hlZCBkZWNvcmF0b3JzXG4gICAqL1xuXG5cbiAgY29uc3QgcGVuZGluZ0RlY29yYXRvcnMgPSBlZGl0b3IuX3BlbmRpbmdEZWNvcmF0b3JzO1xuXG4gIGlmIChwZW5kaW5nRGVjb3JhdG9ycyAhPT0gbnVsbCkge1xuICAgIGVkaXRvci5fZGVjb3JhdG9ycyA9IHBlbmRpbmdEZWNvcmF0b3JzO1xuICAgIGVkaXRvci5fcGVuZGluZ0RlY29yYXRvcnMgPSBudWxsO1xuICAgIHRyaWdnZXJMaXN0ZW5lcnMoJ2RlY29yYXRvcicsIGVkaXRvciwgdHJ1ZSwgcGVuZGluZ0RlY29yYXRvcnMpO1xuICB9IC8vIElmIHJlY29uY2lsZXIgZmFpbHMsIHdlIHJlc2V0IHdob2xlIGVkaXRvciAoc28gY3VycmVudCBlZGl0b3Igc3RhdGUgYmVjb21lcyBlbXB0eSlcbiAgLy8gYW5kIGF0dGVtcHQgdG8gcmUtcmVuZGVyIHBlbmRpbmdFZGl0b3JTdGF0ZS4gSWYgdGhhdCBnb2VzIHRocm91Z2ggd2UgdHJpZ2dlclxuICAvLyBsaXN0ZW5lcnMsIGJ1dCBpbnN0ZWFkIHVzZSByZWNvdmVyRWRpdG9yU3RhdGUgd2hpY2ggaXMgY3VycmVudCBlZGl0b3Igc3RhdGUgYmVmb3JlIHJlc2V0XG4gIC8vIFRoaXMgc3BlY2lmaWNhbGx5IGltcG9ydGFudCBmb3IgY29sbGFiIHRoYXQgcmVsaWVzIG9uIHByZXZFZGl0b3JTdGF0ZSBmcm9tIHVwZGF0ZVxuICAvLyBsaXN0ZW5lciB0byBjYWxjdWxhdGUgZGVsdGEgb2YgY2hhbmdlZCBub2Rlcy9wcm9wZXJ0aWVzXG5cblxuICB0cmlnZ2VyVGV4dENvbnRlbnRMaXN0ZW5lcnMoZWRpdG9yLCByZWNvdmVyeUVkaXRvclN0YXRlIHx8IGN1cnJlbnRFZGl0b3JTdGF0ZSwgcGVuZGluZ0VkaXRvclN0YXRlKTtcbiAgdHJpZ2dlckxpc3RlbmVycygndXBkYXRlJywgZWRpdG9yLCB0cnVlLCB7XG4gICAgZGlydHlFbGVtZW50cyxcbiAgICBkaXJ0eUxlYXZlcyxcbiAgICBlZGl0b3JTdGF0ZTogcGVuZGluZ0VkaXRvclN0YXRlLFxuICAgIG5vcm1hbGl6ZWROb2RlcyxcbiAgICBwcmV2RWRpdG9yU3RhdGU6IHJlY292ZXJ5RWRpdG9yU3RhdGUgfHwgY3VycmVudEVkaXRvclN0YXRlLFxuICAgIHRhZ3NcbiAgfSk7XG4gIHRyaWdnZXJEZWZlcnJlZFVwZGF0ZUNhbGxiYWNrcyhlZGl0b3IsIGRlZmVycmVkKTtcbiAgdHJpZ2dlckVucXVldWVkVXBkYXRlcyhlZGl0b3IpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyVGV4dENvbnRlbnRMaXN0ZW5lcnMoZWRpdG9yLCBjdXJyZW50RWRpdG9yU3RhdGUsIHBlbmRpbmdFZGl0b3JTdGF0ZSkge1xuICBjb25zdCBjdXJyZW50VGV4dENvbnRlbnQgPSBnZXRFZGl0b3JTdGF0ZVRleHRDb250ZW50KGN1cnJlbnRFZGl0b3JTdGF0ZSk7XG4gIGNvbnN0IGxhdGVzdFRleHRDb250ZW50ID0gZ2V0RWRpdG9yU3RhdGVUZXh0Q29udGVudChwZW5kaW5nRWRpdG9yU3RhdGUpO1xuXG4gIGlmIChjdXJyZW50VGV4dENvbnRlbnQgIT09IGxhdGVzdFRleHRDb250ZW50KSB7XG4gICAgdHJpZ2dlckxpc3RlbmVycygndGV4dGNvbnRlbnQnLCBlZGl0b3IsIHRydWUsIGxhdGVzdFRleHRDb250ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmlnZ2VyTXV0YXRpb25MaXN0ZW5lcnMoZWRpdG9yLCBtdXRhdGVkTm9kZXMsIHVwZGF0ZVRhZ3MsIGRpcnR5TGVhdmVzLCBwcmV2RWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgbGlzdGVuZXJzID0gQXJyYXkuZnJvbShlZGl0b3IuX2xpc3RlbmVycy5tdXRhdGlvbik7XG4gIGNvbnN0IGxpc3RlbmVyc0xlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFtsaXN0ZW5lciwga2xhc3NdID0gbGlzdGVuZXJzW2ldO1xuICAgIGNvbnN0IG11dGF0ZWROb2Rlc0J5VHlwZSA9IG11dGF0ZWROb2Rlcy5nZXQoa2xhc3MpO1xuXG4gICAgaWYgKG11dGF0ZWROb2Rlc0J5VHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsaXN0ZW5lcihtdXRhdGVkTm9kZXNCeVR5cGUsIHtcbiAgICAgICAgZGlydHlMZWF2ZXMsXG4gICAgICAgIHByZXZFZGl0b3JTdGF0ZSxcbiAgICAgICAgdXBkYXRlVGFnc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJMaXN0ZW5lcnModHlwZSwgZWRpdG9yLCBpc0N1cnJlbnRseUVucXVldWluZ1VwZGF0ZXMsIC4uLnBheWxvYWQpIHtcbiAgY29uc3QgcHJldmlvdXNseVVwZGF0aW5nID0gZWRpdG9yLl91cGRhdGluZztcbiAgZWRpdG9yLl91cGRhdGluZyA9IGlzQ3VycmVudGx5RW5xdWV1aW5nVXBkYXRlcztcblxuICB0cnkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IEFycmF5LmZyb20oZWRpdG9yLl9saXN0ZW5lcnNbdHlwZV0pO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShudWxsLCBwYXlsb2FkKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgZWRpdG9yLl91cGRhdGluZyA9IHByZXZpb3VzbHlVcGRhdGluZztcbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlckNvbW1hbmRMaXN0ZW5lcnMoZWRpdG9yLCB0eXBlLCBwYXlsb2FkKSB7XG4gIGlmIChlZGl0b3IuX3VwZGF0aW5nID09PSBmYWxzZSB8fCBhY3RpdmVFZGl0b3IgIT09IGVkaXRvcikge1xuICAgIGxldCByZXR1cm5WYWwgPSBmYWxzZTtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIHJldHVyblZhbCA9IHRyaWdnZXJDb21tYW5kTGlzdGVuZXJzKGVkaXRvciwgdHlwZSwgcGF5bG9hZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbDtcbiAgfVxuXG4gIGNvbnN0IGVkaXRvcnMgPSBnZXRFZGl0b3JzVG9Qcm9wYWdhdGUoZWRpdG9yKTtcblxuICBmb3IgKGxldCBpID0gNDsgaSA+PSAwOyBpLS0pIHtcbiAgICBmb3IgKGxldCBlID0gMDsgZSA8IGVkaXRvcnMubGVuZ3RoOyBlKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRFZGl0b3IgPSBlZGl0b3JzW2VdO1xuICAgICAgY29uc3QgY29tbWFuZExpc3RlbmVycyA9IGN1cnJlbnRFZGl0b3IuX2NvbW1hbmRzO1xuICAgICAgY29uc3QgbGlzdGVuZXJJblByaW9yaXR5T3JkZXIgPSBjb21tYW5kTGlzdGVuZXJzLmdldCh0eXBlKTtcblxuICAgICAgaWYgKGxpc3RlbmVySW5Qcmlvcml0eU9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzU2V0ID0gbGlzdGVuZXJJblByaW9yaXR5T3JkZXJbaV07XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyc1NldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gQXJyYXkuZnJvbShsaXN0ZW5lcnNTZXQpO1xuICAgICAgICAgIGNvbnN0IGxpc3RlbmVyc0xlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpc3RlbmVyc0xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2pdKHBheWxvYWQsIGVkaXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyRW5xdWV1ZWRVcGRhdGVzKGVkaXRvcikge1xuICBjb25zdCBxdWV1ZWRVcGRhdGVzID0gZWRpdG9yLl91cGRhdGVzO1xuXG4gIGlmIChxdWV1ZWRVcGRhdGVzLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IHF1ZXVlZFVwZGF0ZSA9IHF1ZXVlZFVwZGF0ZXMuc2hpZnQoKTtcblxuICAgIGlmIChxdWV1ZWRVcGRhdGUpIHtcbiAgICAgIGNvbnN0IFt1cGRhdGVGbiwgb3B0aW9uc10gPSBxdWV1ZWRVcGRhdGU7XG4gICAgICBiZWdpblVwZGF0ZShlZGl0b3IsIHVwZGF0ZUZuLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpZ2dlckRlZmVycmVkVXBkYXRlQ2FsbGJhY2tzKGVkaXRvciwgZGVmZXJyZWQpIHtcbiAgZWRpdG9yLl9kZWZlcnJlZCA9IFtdO1xuXG4gIGlmIChkZWZlcnJlZC5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBwcmV2aW91c2x5VXBkYXRpbmcgPSBlZGl0b3IuX3VwZGF0aW5nO1xuICAgIGVkaXRvci5fdXBkYXRpbmcgPSB0cnVlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVmZXJyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVmZXJyZWRbaV0oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZWRpdG9yLl91cGRhdGluZyA9IHByZXZpb3VzbHlVcGRhdGluZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc05lc3RlZFVwZGF0ZXMoZWRpdG9yLCBpbml0aWFsU2tpcFRyYW5zZm9ybXMpIHtcbiAgY29uc3QgcXVldWVkVXBkYXRlcyA9IGVkaXRvci5fdXBkYXRlcztcbiAgbGV0IHNraXBUcmFuc2Zvcm1zID0gaW5pdGlhbFNraXBUcmFuc2Zvcm1zIHx8IGZhbHNlOyAvLyBVcGRhdGVzIG1pZ2h0IGdyb3cgYXMgd2UgcHJvY2VzcyB0aGVtLCB3ZSBzbyB3ZSdsbCBuZWVkXG4gIC8vIHRvIGhhbmRsZSBlYWNoIHVwZGF0ZSBhcyB3ZSBnbyB1bnRpbCB0aGUgdXBkYXRlcyBhcnJheSBpc1xuICAvLyBlbXB0eS5cblxuICB3aGlsZSAocXVldWVkVXBkYXRlcy5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBxdWV1ZWRVcGRhdGUgPSBxdWV1ZWRVcGRhdGVzLnNoaWZ0KCk7XG5cbiAgICBpZiAocXVldWVkVXBkYXRlKSB7XG4gICAgICBjb25zdCBbbmV4dFVwZGF0ZUZuLCBvcHRpb25zXSA9IHF1ZXVlZFVwZGF0ZTtcbiAgICAgIGxldCBvblVwZGF0ZTtcbiAgICAgIGxldCB0YWc7XG5cbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25VcGRhdGUgPSBvcHRpb25zLm9uVXBkYXRlO1xuICAgICAgICB0YWcgPSBvcHRpb25zLnRhZztcblxuICAgICAgICBpZiAob3B0aW9ucy5za2lwVHJhbnNmb3Jtcykge1xuICAgICAgICAgIHNraXBUcmFuc2Zvcm1zID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvblVwZGF0ZSkge1xuICAgICAgICAgIGVkaXRvci5fZGVmZXJyZWQucHVzaChvblVwZGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgZWRpdG9yLl91cGRhdGVUYWdzLmFkZCh0YWcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHRVcGRhdGVGbigpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBza2lwVHJhbnNmb3Jtcztcbn1cblxuZnVuY3Rpb24gYmVnaW5VcGRhdGUoZWRpdG9yLCB1cGRhdGVGbiwgb3B0aW9ucykge1xuICBjb25zdCB1cGRhdGVUYWdzID0gZWRpdG9yLl91cGRhdGVUYWdzO1xuICBsZXQgb25VcGRhdGU7XG4gIGxldCB0YWc7XG4gIGxldCBza2lwVHJhbnNmb3JtcyA9IGZhbHNlO1xuICBsZXQgZGlzY3JldGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb25VcGRhdGUgPSBvcHRpb25zLm9uVXBkYXRlO1xuICAgIHRhZyA9IG9wdGlvbnMudGFnO1xuXG4gICAgaWYgKHRhZyAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVUYWdzLmFkZCh0YWcpO1xuICAgIH1cblxuICAgIHNraXBUcmFuc2Zvcm1zID0gb3B0aW9ucy5za2lwVHJhbnNmb3JtcyB8fCBmYWxzZTtcbiAgICBkaXNjcmV0ZSA9IG9wdGlvbnMuZGlzY3JldGUgfHwgZmFsc2U7XG4gIH1cblxuICBpZiAob25VcGRhdGUpIHtcbiAgICBlZGl0b3IuX2RlZmVycmVkLnB1c2gob25VcGRhdGUpO1xuICB9XG5cbiAgY29uc3QgY3VycmVudEVkaXRvclN0YXRlID0gZWRpdG9yLl9lZGl0b3JTdGF0ZTtcbiAgbGV0IHBlbmRpbmdFZGl0b3JTdGF0ZSA9IGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlO1xuICBsZXQgZWRpdG9yU3RhdGVXYXNDbG9uZWQgPSBmYWxzZTtcblxuICBpZiAocGVuZGluZ0VkaXRvclN0YXRlID09PSBudWxsIHx8IHBlbmRpbmdFZGl0b3JTdGF0ZS5fcmVhZE9ubHkpIHtcbiAgICBwZW5kaW5nRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IGNsb25lRWRpdG9yU3RhdGUocGVuZGluZ0VkaXRvclN0YXRlIHx8IGN1cnJlbnRFZGl0b3JTdGF0ZSk7XG4gICAgZWRpdG9yU3RhdGVXYXNDbG9uZWQgPSB0cnVlO1xuICB9XG5cbiAgcGVuZGluZ0VkaXRvclN0YXRlLl9mbHVzaFN5bmMgPSBkaXNjcmV0ZTtcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZSA9IGFjdGl2ZUVkaXRvclN0YXRlO1xuICBjb25zdCBwcmV2aW91c1JlYWRPbmx5TW9kZSA9IGlzUmVhZE9ubHlNb2RlO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvciA9IGFjdGl2ZUVkaXRvcjtcbiAgY29uc3QgcHJldmlvdXNseVVwZGF0aW5nID0gZWRpdG9yLl91cGRhdGluZztcbiAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGlzUmVhZE9ubHlNb2RlID0gZmFsc2U7XG4gIGVkaXRvci5fdXBkYXRpbmcgPSB0cnVlO1xuICBhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG5cbiAgdHJ5IHtcbiAgICBpZiAoZWRpdG9yU3RhdGVXYXNDbG9uZWQpIHtcbiAgICAgIGlmIChlZGl0b3IuX2hlYWRsZXNzKSB7XG4gICAgICAgIGlmIChjdXJyZW50RWRpdG9yU3RhdGUuX3NlbGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgcGVuZGluZ0VkaXRvclN0YXRlLl9zZWxlY3Rpb24gPSBjdXJyZW50RWRpdG9yU3RhdGUuX3NlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nRWRpdG9yU3RhdGUuX3NlbGVjdGlvbiA9IGludGVybmFsQ3JlYXRlU2VsZWN0aW9uKGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRpbmdDb21wb3NpdGlvbktleSA9IGVkaXRvci5fY29tcG9zaXRpb25LZXk7XG4gICAgdXBkYXRlRm4oKTtcbiAgICBza2lwVHJhbnNmb3JtcyA9IHByb2Nlc3NOZXN0ZWRVcGRhdGVzKGVkaXRvciwgc2tpcFRyYW5zZm9ybXMpO1xuICAgIGFwcGx5U2VsZWN0aW9uVHJhbnNmb3JtcyhwZW5kaW5nRWRpdG9yU3RhdGUsIGVkaXRvcik7XG5cbiAgICBpZiAoZWRpdG9yLl9kaXJ0eVR5cGUgIT09IE5PX0RJUlRZX05PREVTKSB7XG4gICAgICBpZiAoc2tpcFRyYW5zZm9ybXMpIHtcbiAgICAgICAgJG5vcm1hbGl6ZUFsbERpcnR5VGV4dE5vZGVzKHBlbmRpbmdFZGl0b3JTdGF0ZSwgZWRpdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRhcHBseUFsbFRyYW5zZm9ybXMocGVuZGluZ0VkaXRvclN0YXRlLCBlZGl0b3IpO1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzTmVzdGVkVXBkYXRlcyhlZGl0b3IpO1xuICAgICAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWROb2RlcyhjdXJyZW50RWRpdG9yU3RhdGUsIHBlbmRpbmdFZGl0b3JTdGF0ZSwgZWRpdG9yLl9kaXJ0eUxlYXZlcywgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICBjb25zdCBlbmRpbmdDb21wb3NpdGlvbktleSA9IGVkaXRvci5fY29tcG9zaXRpb25LZXk7XG5cbiAgICBpZiAoc3RhcnRpbmdDb21wb3NpdGlvbktleSAhPT0gZW5kaW5nQ29tcG9zaXRpb25LZXkpIHtcbiAgICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fZmx1c2hTeW5jID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBwZW5kaW5nU2VsZWN0aW9uID0gcGVuZGluZ0VkaXRvclN0YXRlLl9zZWxlY3Rpb247XG5cbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24ocGVuZGluZ1NlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdOb2RlTWFwID0gcGVuZGluZ0VkaXRvclN0YXRlLl9ub2RlTWFwO1xuICAgICAgY29uc3QgYW5jaG9yS2V5ID0gcGVuZGluZ1NlbGVjdGlvbi5hbmNob3Iua2V5O1xuICAgICAgY29uc3QgZm9jdXNLZXkgPSBwZW5kaW5nU2VsZWN0aW9uLmZvY3VzLmtleTtcblxuICAgICAgaWYgKHBlbmRpbmdOb2RlTWFwLmdldChhbmNob3JLZXkpID09PSB1bmRlZmluZWQgfHwgcGVuZGluZ05vZGVNYXAuZ2V0KGZvY3VzS2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgdXBkYXRlRWRpdG9yOiBzZWxlY3Rpb24gaGFzIGJlZW4gbG9zdCBiZWNhdXNlIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIG5vZGVzIGhhdmUgYmVlbiByZW1vdmVkIGFuZCBzZWxlY3Rpb24gd2Fzbid0IG1vdmVkIHRvIGFub3RoZXIgbm9kZS4gRW5zdXJlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIHJlbW92aW5nL3JlcGxhY2luZyBhIHNlbGVjdGVkIG5vZGUuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCRpc05vZGVTZWxlY3Rpb24ocGVuZGluZ1NlbGVjdGlvbikpIHtcbiAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBhbHNvIHZhbGlkYXRlIG5vZGUgc2VsZWN0aW9uP1xuICAgICAgaWYgKHBlbmRpbmdTZWxlY3Rpb24uX25vZGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgcGVuZGluZ0VkaXRvclN0YXRlLl9zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBSZXBvcnQgZXJyb3JzXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGVkaXRvci5fb25FcnJvcihlcnJvcik7XG4gICAgfSAvLyBSZXN0b3JlIGV4aXN0aW5nIGVkaXRvciBzdGF0ZSB0byB0aGUgRE9NXG5cblxuICAgIGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlID0gY3VycmVudEVkaXRvclN0YXRlO1xuICAgIGVkaXRvci5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG5cbiAgICBlZGl0b3IuX2Nsb25lTm90TmVlZGVkLmNsZWFyKCk7XG5cbiAgICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuXG4gICAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzLmNsZWFyKCk7XG5cbiAgICBjb21taXRQZW5kaW5nVXBkYXRlcyhlZGl0b3IpO1xuICAgIHJldHVybjtcbiAgfSBmaW5hbGx5IHtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgaXNSZWFkT25seU1vZGUgPSBwcmV2aW91c1JlYWRPbmx5TW9kZTtcbiAgICBhY3RpdmVFZGl0b3IgPSBwcmV2aW91c0FjdGl2ZUVkaXRvcjtcbiAgICBlZGl0b3IuX3VwZGF0aW5nID0gcHJldmlvdXNseVVwZGF0aW5nO1xuICAgIGluZmluaXRlVHJhbnNmb3JtQ291bnQgPSAwO1xuICB9XG5cbiAgY29uc3Qgc2hvdWxkVXBkYXRlID0gZWRpdG9yLl9kaXJ0eVR5cGUgIT09IE5PX0RJUlRZX05PREVTIHx8IGVkaXRvclN0YXRlSGFzRGlydHlTZWxlY3Rpb24ocGVuZGluZ0VkaXRvclN0YXRlLCBlZGl0b3IpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICBpZiAocGVuZGluZ0VkaXRvclN0YXRlLl9mbHVzaFN5bmMpIHtcbiAgICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fZmx1c2hTeW5jID0gZmFsc2U7XG4gICAgICBjb21taXRQZW5kaW5nVXBkYXRlcyhlZGl0b3IpO1xuICAgIH0gZWxzZSBpZiAoZWRpdG9yU3RhdGVXYXNDbG9uZWQpIHtcbiAgICAgIHNjaGVkdWxlTWljcm9UYXNrKCgpID0+IHtcbiAgICAgICAgY29tbWl0UGVuZGluZ1VwZGF0ZXMoZWRpdG9yKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwZW5kaW5nRWRpdG9yU3RhdGUuX2ZsdXNoU3luYyA9IGZhbHNlO1xuXG4gICAgaWYgKGVkaXRvclN0YXRlV2FzQ2xvbmVkKSB7XG4gICAgICB1cGRhdGVUYWdzLmNsZWFyKCk7XG4gICAgICBlZGl0b3IuX2RlZmVycmVkID0gW107XG4gICAgICBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVkaXRvcihlZGl0b3IsIHVwZGF0ZUZuLCBvcHRpb25zKSB7XG4gIGlmIChlZGl0b3IuX3VwZGF0aW5nKSB7XG4gICAgZWRpdG9yLl91cGRhdGVzLnB1c2goW3VwZGF0ZUZuLCBvcHRpb25zXSk7XG4gIH0gZWxzZSB7XG4gICAgYmVnaW5VcGRhdGUoZWRpdG9yLCB1cGRhdGVGbiwgb3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuLyoqIEBub0luaGVyaXREb2MgKi9cblxuY2xhc3MgRGVjb3JhdG9yTm9kZSBleHRlbmRzIExleGljYWxOb2RlIHtcbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgfVxuXG4gIGRlY29yYXRlKGVkaXRvciwgY29uZmlnKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYGRlY29yYXRlOiBiYXNlIG1ldGhvZCBub3QgZXh0ZW5kZWRgKTtcbiAgICB9XG4gIH1cblxuICBpc0lzb2xhdGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzSW5saW5lKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaXNLZXlib2FyZFNlbGVjdGFibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufVxuZnVuY3Rpb24gJGlzRGVjb3JhdG9yTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgRGVjb3JhdG9yTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgRWxlbWVudE5vZGUgZXh0ZW5kcyBMZXhpY2FsTm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX19maXJzdCA9IG51bGw7XG4gICAgdGhpcy5fX2xhc3QgPSBudWxsO1xuICAgIHRoaXMuX19zaXplID0gMDtcbiAgICB0aGlzLl9fZm9ybWF0ID0gMDtcbiAgICB0aGlzLl9faW5kZW50ID0gMDtcbiAgICB0aGlzLl9fZGlyID0gbnVsbDtcbiAgfVxuXG4gIGdldEZvcm1hdCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2Zvcm1hdDtcbiAgfVxuXG4gIGdldEZvcm1hdFR5cGUoKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRGb3JtYXQoKTtcbiAgICByZXR1cm4gRUxFTUVOVF9GT1JNQVRfVE9fVFlQRVtmb3JtYXRdIHx8ICcnO1xuICB9XG5cbiAgZ2V0SW5kZW50KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9faW5kZW50O1xuICB9XG5cbiAgZ2V0Q2hpbGRyZW4oKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICBsZXQgY2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgZ2V0Q2hpbGRyZW5LZXlzKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgbGV0IGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQuX19rZXkpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5nZXROZXh0U2libGluZygpO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIGdldENoaWxkcmVuU2l6ZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX3NpemU7XG4gIH1cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmdldENoaWxkcmVuU2l6ZSgpID09PSAwO1xuICB9XG5cbiAgaXNEaXJ0eSgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICAgIHJldHVybiBkaXJ0eUVsZW1lbnRzICE9PSBudWxsICYmIGRpcnR5RWxlbWVudHMuaGFzKHRoaXMuX19rZXkpO1xuICB9XG5cbiAgaXNMYXN0Q2hpbGQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgcGFyZW50TGFzdENoaWxkID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuZ2V0TGFzdENoaWxkKCk7XG4gICAgcmV0dXJuIHBhcmVudExhc3RDaGlsZCAhPT0gbnVsbCAmJiBwYXJlbnRMYXN0Q2hpbGQuaXMoc2VsZik7XG4gIH1cblxuICBnZXRBbGxUZXh0Tm9kZXMoKSB7XG4gICAgY29uc3QgdGV4dE5vZGVzID0gW107XG4gICAgbGV0IGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgdGV4dE5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICAgIGNvbnN0IHN1YkNoaWxkcmVuTm9kZXMgPSBjaGlsZC5nZXRBbGxUZXh0Tm9kZXMoKTtcbiAgICAgICAgdGV4dE5vZGVzLnB1c2goLi4uc3ViQ2hpbGRyZW5Ob2Rlcyk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dE5vZGVzO1xuICB9XG5cbiAgZ2V0Rmlyc3REZXNjZW5kYW50KCkge1xuICAgIGxldCBub2RlID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG5cbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZ2V0TGFzdERlc2NlbmRhbnQoKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuZ2V0TGFzdENoaWxkKCk7XG5cbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZ2V0RGVzY2VuZGFudEJ5SW5kZXgoaW5kZXgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDsgLy8gRm9yIG5vbi1lbXB0eSBlbGVtZW50IG5vZGVzLCB3ZSByZXNvbHZlIGl0cyBkZXNjZW5kYW50XG4gICAgLy8gKGVpdGhlciBhIGxlYWYgbm9kZSBvciB0aGUgYm90dG9tLW1vc3QgZWxlbWVudClcblxuICAgIGlmIChpbmRleCA+PSBjaGlsZHJlbkxlbmd0aCkge1xuICAgICAgY29uc3QgcmVzb2x2ZWROb2RlID0gY2hpbGRyZW5bY2hpbGRyZW5MZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiAkaXNFbGVtZW50Tm9kZShyZXNvbHZlZE5vZGUpICYmIHJlc29sdmVkTm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpIHx8IHJlc29sdmVkTm9kZSB8fCBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc29sdmVkTm9kZSA9IGNoaWxkcmVuW2luZGV4XTtcbiAgICByZXR1cm4gJGlzRWxlbWVudE5vZGUocmVzb2x2ZWROb2RlKSAmJiByZXNvbHZlZE5vZGUuZ2V0Rmlyc3REZXNjZW5kYW50KCkgfHwgcmVzb2x2ZWROb2RlIHx8IG51bGw7XG4gIH1cblxuICBnZXRGaXJzdENoaWxkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IGZpcnN0S2V5ID0gc2VsZi5fX2ZpcnN0O1xuICAgIHJldHVybiBmaXJzdEtleSA9PT0gbnVsbCA/IG51bGwgOiAkZ2V0Tm9kZUJ5S2V5KGZpcnN0S2V5KTtcbiAgfVxuXG4gIGdldEZpcnN0Q2hpbGRPclRocm93KCkge1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblxuICAgIGlmIChmaXJzdENoaWxkID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBFeHBlY3RlZCBub2RlICR7dGhpcy5fX2tleX0gdG8gaGF2ZSBhIGZpcnN0IGNoaWxkLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmaXJzdENoaWxkO1xuICB9XG5cbiAgZ2V0TGFzdENoaWxkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IGxhc3RLZXkgPSBzZWxmLl9fbGFzdDtcbiAgICByZXR1cm4gbGFzdEtleSA9PT0gbnVsbCA/IG51bGwgOiAkZ2V0Tm9kZUJ5S2V5KGxhc3RLZXkpO1xuICB9XG5cbiAgZ2V0TGFzdENoaWxkT3JUaHJvdygpIHtcbiAgICBjb25zdCBsYXN0Q2hpbGQgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuXG4gICAgaWYgKGxhc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgRXhwZWN0ZWQgbm9kZSAke3RoaXMuX19rZXl9IHRvIGhhdmUgYSBsYXN0IGNoaWxkLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsYXN0Q2hpbGQ7XG4gIH1cblxuICBnZXRDaGlsZEF0SW5kZXgoaW5kZXgpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy5nZXRDaGlsZHJlblNpemUoKTtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgaTtcblxuICAgIGlmIChpbmRleCA8IHNpemUgLyAyKSB7XG4gICAgICBub2RlID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpID0gMDtcblxuICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgaSA8PSBpbmRleCkge1xuICAgICAgICBpZiAoaSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbm9kZSA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG4gICAgaSA9IHNpemUgLSAxO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwgJiYgaSA+PSBpbmRleCkge1xuICAgICAgaWYgKGkgPT09IGluZGV4KSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIGktLTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIGxldCB0ZXh0Q29udGVudCA9ICcnO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgdGV4dENvbnRlbnQgKz0gY2hpbGQuZ2V0VGV4dENvbnRlbnQoKTtcblxuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSAmJiBpICE9PSBjaGlsZHJlbkxlbmd0aCAtIDEgJiYgIWNoaWxkLmlzSW5saW5lKCkpIHtcbiAgICAgICAgdGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHRDb250ZW50O1xuICB9XG5cbiAgZ2V0VGV4dENvbnRlbnRTaXplKCkge1xuICAgIGxldCB0ZXh0Q29udGVudFNpemUgPSAwO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgdGV4dENvbnRlbnRTaXplICs9IGNoaWxkLmdldFRleHRDb250ZW50U2l6ZSgpO1xuXG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpICYmIGkgIT09IGNoaWxkcmVuTGVuZ3RoIC0gMSAmJiAhY2hpbGQuaXNJbmxpbmUoKSkge1xuICAgICAgICB0ZXh0Q29udGVudFNpemUgKz0gRE9VQkxFX0xJTkVfQlJFQUsubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0ZXh0Q29udGVudFNpemU7XG4gIH1cblxuICBnZXREaXJlY3Rpb24oKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19kaXI7XG4gIH1cblxuICBoYXNGb3JtYXQodHlwZSkge1xuICAgIGlmICh0eXBlICE9PSAnJykge1xuICAgICAgY29uc3QgZm9ybWF0RmxhZyA9IEVMRU1FTlRfVFlQRV9UT19GT1JNQVRbdHlwZV07XG4gICAgICByZXR1cm4gKHRoaXMuZ2V0Rm9ybWF0KCkgJiBmb3JtYXRGbGFnKSAhPT0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gTXV0YXRvcnNcblxuXG4gIHNlbGVjdChfYW5jaG9yT2Zmc2V0LCBfZm9jdXNPZmZzZXQpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgbGV0IGFuY2hvck9mZnNldCA9IF9hbmNob3JPZmZzZXQ7XG4gICAgbGV0IGZvY3VzT2Zmc2V0ID0gX2ZvY3VzT2Zmc2V0O1xuICAgIGNvbnN0IGNoaWxkcmVuQ291bnQgPSB0aGlzLmdldENoaWxkcmVuU2l6ZSgpO1xuXG4gICAgaWYgKCF0aGlzLmNhbkJlRW1wdHkoKSkge1xuICAgICAgaWYgKF9hbmNob3JPZmZzZXQgPT09IDAgJiYgX2ZvY3VzT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblxuICAgICAgICBpZiAoJGlzVGV4dE5vZGUoZmlyc3RDaGlsZCkgfHwgJGlzRWxlbWVudE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gZmlyc3RDaGlsZC5zZWxlY3QoMCwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKF9hbmNob3JPZmZzZXQgPT09IHVuZGVmaW5lZCB8fCBfYW5jaG9yT2Zmc2V0ID09PSBjaGlsZHJlbkNvdW50KSAmJiAoX2ZvY3VzT2Zmc2V0ID09PSB1bmRlZmluZWQgfHwgX2ZvY3VzT2Zmc2V0ID09PSBjaGlsZHJlbkNvdW50KSkge1xuICAgICAgICBjb25zdCBsYXN0Q2hpbGQgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuXG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShsYXN0Q2hpbGQpIHx8ICRpc0VsZW1lbnROb2RlKGxhc3RDaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gbGFzdENoaWxkLnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFuY2hvck9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbmNob3JPZmZzZXQgPSBjaGlsZHJlbkNvdW50O1xuICAgIH1cblxuICAgIGlmIChmb2N1c09mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb2N1c09mZnNldCA9IGNoaWxkcmVuQ291bnQ7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gdGhpcy5fX2tleTtcblxuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGludGVybmFsTWFrZVJhbmdlU2VsZWN0aW9uKGtleSwgYW5jaG9yT2Zmc2V0LCBrZXksIGZvY3VzT2Zmc2V0LCAnZWxlbWVudCcsICdlbGVtZW50Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi5hbmNob3Iuc2V0KGtleSwgYW5jaG9yT2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgc2VsZWN0aW9uLmZvY3VzLnNldChrZXksIGZvY3VzT2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uO1xuICB9XG5cbiAgc2VsZWN0U3RhcnQoKSB7XG4gICAgY29uc3QgZmlyc3ROb2RlID0gdGhpcy5nZXRGaXJzdERlc2NlbmRhbnQoKTtcblxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpIHx8ICRpc1RleHROb2RlKGZpcnN0Tm9kZSkpIHtcbiAgICAgIHJldHVybiBmaXJzdE5vZGUuc2VsZWN0KDAsIDApO1xuICAgIH0gLy8gRGVjb3JhdG9yIG9yIExpbmVCcmVha1xuXG5cbiAgICBpZiAoZmlyc3ROb2RlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmlyc3ROb2RlLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0KDAsIDApO1xuICB9XG5cbiAgc2VsZWN0RW5kKCkge1xuICAgIGNvbnN0IGxhc3ROb2RlID0gdGhpcy5nZXRMYXN0RGVzY2VuZGFudCgpO1xuXG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGxhc3ROb2RlKSB8fCAkaXNUZXh0Tm9kZShsYXN0Tm9kZSkpIHtcbiAgICAgIHJldHVybiBsYXN0Tm9kZS5zZWxlY3QoKTtcbiAgICB9IC8vIERlY29yYXRvciBvciBMaW5lQnJlYWtcblxuXG4gICAgaWYgKGxhc3ROb2RlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbGFzdE5vZGUuc2VsZWN0TmV4dCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNlbGVjdCgpO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQucmVtb3ZlKCkpO1xuICAgIHJldHVybiB3cml0YWJsZVNlbGY7XG4gIH1cblxuICBhcHBlbmQoLi4ubm9kZXNUb0FwcGVuZCkge1xuICAgIHJldHVybiB0aGlzLnNwbGljZSh0aGlzLmdldENoaWxkcmVuU2l6ZSgpLCAwLCBub2Rlc1RvQXBwZW5kKTtcbiAgfVxuXG4gIHNldERpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19kaXIgPSBkaXJlY3Rpb247XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICBzZXRGb3JtYXQodHlwZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2Zvcm1hdCA9IHR5cGUgIT09ICcnID8gRUxFTUVOVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXSA6IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRJbmRlbnQoaW5kZW50TGV2ZWwpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19pbmRlbnQgPSBpbmRlbnRMZXZlbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIG5vZGVzVG9JbnNlcnQpIHtcbiAgICBjb25zdCBub2Rlc1RvSW5zZXJ0TGVuZ3RoID0gbm9kZXNUb0luc2VydC5sZW5ndGg7XG4gICAgY29uc3Qgb2xkU2l6ZSA9IHRoaXMuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHdyaXRhYmxlU2VsZktleSA9IHdyaXRhYmxlU2VsZi5fX2tleTtcbiAgICBjb25zdCBub2Rlc1RvSW5zZXJ0S2V5cyA9IFtdO1xuICAgIGNvbnN0IG5vZGVzVG9SZW1vdmVLZXlzID0gW107XG4gICAgY29uc3Qgbm9kZUFmdGVyUmFuZ2UgPSB0aGlzLmdldENoaWxkQXRJbmRleChzdGFydCArIGRlbGV0ZUNvdW50KTtcbiAgICBsZXQgbm9kZUJlZm9yZVJhbmdlID0gbnVsbDtcbiAgICBsZXQgbmV3U2l6ZSA9IG9sZFNpemUgLSBkZWxldGVDb3VudCArIG5vZGVzVG9JbnNlcnRMZW5ndGg7XG5cbiAgICBpZiAoc3RhcnQgIT09IDApIHtcbiAgICAgIGlmIChzdGFydCA9PT0gb2xkU2l6ZSkge1xuICAgICAgICBub2RlQmVmb3JlUmFuZ2UgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Q2hpbGRBdEluZGV4KHN0YXJ0KTtcblxuICAgICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGVCZWZvcmVSYW5nZSA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVsZXRlQ291bnQgPiAwKSB7XG4gICAgICBsZXQgbm9kZVRvRGVsZXRlID0gbm9kZUJlZm9yZVJhbmdlID09PSBudWxsID8gdGhpcy5nZXRGaXJzdENoaWxkKCkgOiBub2RlQmVmb3JlUmFuZ2UuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWxldGVDb3VudDsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlVG9EZWxldGUgPT09IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgc3BsaWNlOiBzaWJsaW5nIG5vdCBmb3VuZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gbm9kZVRvRGVsZXRlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIGNvbnN0IG5vZGVLZXlUb0RlbGV0ZSA9IG5vZGVUb0RlbGV0ZS5fX2tleTtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVOb2RlVG9EZWxldGUgPSBub2RlVG9EZWxldGUuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgcmVtb3ZlRnJvbVBhcmVudCh3cml0YWJsZU5vZGVUb0RlbGV0ZSk7XG4gICAgICAgIG5vZGVzVG9SZW1vdmVLZXlzLnB1c2gobm9kZUtleVRvRGVsZXRlKTtcbiAgICAgICAgbm9kZVRvRGVsZXRlID0gbmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHByZXZOb2RlID0gbm9kZUJlZm9yZVJhbmdlO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc1RvSW5zZXJ0TGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGVUb0luc2VydCA9IG5vZGVzVG9JbnNlcnRbaV07XG5cbiAgICAgIGlmIChwcmV2Tm9kZSAhPT0gbnVsbCAmJiBub2RlVG9JbnNlcnQuaXMocHJldk5vZGUpKSB7XG4gICAgICAgIG5vZGVCZWZvcmVSYW5nZSA9IHByZXZOb2RlID0gcHJldk5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHdyaXRhYmxlTm9kZVRvSW5zZXJ0ID0gbm9kZVRvSW5zZXJ0LmdldFdyaXRhYmxlKCk7XG5cbiAgICAgIGlmICh3cml0YWJsZU5vZGVUb0luc2VydC5fX3BhcmVudCA9PT0gd3JpdGFibGVTZWxmS2V5KSB7XG4gICAgICAgIG5ld1NpemUtLTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlRnJvbVBhcmVudCh3cml0YWJsZU5vZGVUb0luc2VydCk7XG4gICAgICBjb25zdCBub2RlS2V5VG9JbnNlcnQgPSBub2RlVG9JbnNlcnQuX19rZXk7XG5cbiAgICAgIGlmIChwcmV2Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICB3cml0YWJsZVNlbGYuX19maXJzdCA9IG5vZGVLZXlUb0luc2VydDtcbiAgICAgICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19wcmV2ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlUHJldk5vZGUgPSBwcmV2Tm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZVByZXZOb2RlLl9fbmV4dCA9IG5vZGVLZXlUb0luc2VydDtcbiAgICAgICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19wcmV2ID0gd3JpdGFibGVQcmV2Tm9kZS5fX2tleTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVUb0luc2VydC5fX2tleSA9PT0gd3JpdGFibGVTZWxmS2V5KSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihgYXBwZW5kOiBhdHRlbXB0aW5nIHRvIGFwcGVuZCBzZWxmYCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gU2V0IGNoaWxkIHBhcmVudCB0byBzZWxmXG5cblxuICAgICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19wYXJlbnQgPSB3cml0YWJsZVNlbGZLZXk7XG4gICAgICBub2Rlc1RvSW5zZXJ0S2V5cy5wdXNoKG5vZGVLZXlUb0luc2VydCk7XG4gICAgICBwcmV2Tm9kZSA9IG5vZGVUb0luc2VydDtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgKyBkZWxldGVDb3VudCA9PT0gb2xkU2l6ZSkge1xuICAgICAgaWYgKHByZXZOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlUHJldk5vZGUgPSBwcmV2Tm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZVByZXZOb2RlLl9fbmV4dCA9IG51bGw7XG4gICAgICAgIHdyaXRhYmxlU2VsZi5fX2xhc3QgPSBwcmV2Tm9kZS5fX2tleTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGVBZnRlclJhbmdlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB3cml0YWJsZU5vZGVBZnRlclJhbmdlID0gbm9kZUFmdGVyUmFuZ2UuZ2V0V3JpdGFibGUoKTtcblxuICAgICAgaWYgKHByZXZOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlUHJldk5vZGUgPSBwcmV2Tm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZU5vZGVBZnRlclJhbmdlLl9fcHJldiA9IHByZXZOb2RlLl9fa2V5O1xuICAgICAgICB3cml0YWJsZVByZXZOb2RlLl9fbmV4dCA9IG5vZGVBZnRlclJhbmdlLl9fa2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVOb2RlQWZ0ZXJSYW5nZS5fX3ByZXYgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRhYmxlU2VsZi5fX3NpemUgPSBuZXdTaXplOyAvLyBJbiBjYXNlIG9mIGRlbGV0aW9uIHdlIG5lZWQgdG8gYWRqdXN0IHNlbGVjdGlvbiwgdW5saW5rIHJlbW92ZWQgbm9kZXNcbiAgICAvLyBhbmQgY2xlYW4gdXAgbm9kZSBpdHNlbGYgaWYgaXQgYmVjb21lcyBlbXB0eS4gTm9uZSBvZiB0aGVzZSBuZWVkZWRcbiAgICAvLyBmb3IgaW5zZXJ0aW9uLW9ubHkgY2FzZXNcblxuICAgIGlmIChub2Rlc1RvUmVtb3ZlS2V5cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkanVzdGluZyBzZWxlY3Rpb24sIGluIGNhc2Ugbm9kZSB0aGF0IHdhcyBhbmNob3IvZm9jdXMgd2lsbCBiZSBkZWxldGVkXG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzVG9SZW1vdmVLZXlTZXQgPSBuZXcgU2V0KG5vZGVzVG9SZW1vdmVLZXlzKTtcbiAgICAgICAgY29uc3Qgbm9kZXNUb0luc2VydEtleVNldCA9IG5ldyBTZXQobm9kZXNUb0luc2VydEtleXMpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgIGZvY3VzXG4gICAgICAgIH0gPSBzZWxlY3Rpb247XG5cbiAgICAgICAgaWYgKGlzUG9pbnRSZW1vdmVkKGFuY2hvciwgbm9kZXNUb1JlbW92ZUtleVNldCwgbm9kZXNUb0luc2VydEtleVNldCkpIHtcbiAgICAgICAgICBtb3ZlU2VsZWN0aW9uUG9pbnRUb1NpYmxpbmcoYW5jaG9yLCBhbmNob3IuZ2V0Tm9kZSgpLCB0aGlzLCBub2RlQmVmb3JlUmFuZ2UsIG5vZGVBZnRlclJhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1BvaW50UmVtb3ZlZChmb2N1cywgbm9kZXNUb1JlbW92ZUtleVNldCwgbm9kZXNUb0luc2VydEtleVNldCkpIHtcbiAgICAgICAgICBtb3ZlU2VsZWN0aW9uUG9pbnRUb1NpYmxpbmcoZm9jdXMsIGZvY3VzLmdldE5vZGUoKSwgdGhpcywgbm9kZUJlZm9yZVJhbmdlLCBub2RlQWZ0ZXJSYW5nZSk7XG4gICAgICAgIH0gLy8gQ2xlYW51cCBpZiBub2RlIGNhbid0IGJlIGVtcHR5XG5cblxuICAgICAgICBpZiAobmV3U2l6ZSA9PT0gMCAmJiAhdGhpcy5jYW5CZUVtcHR5KCkgJiYgISRpc1Jvb3RPclNoYWRvd1Jvb3QodGhpcykpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdyaXRhYmxlU2VsZjtcbiAgfSAvLyBKU09OIHNlcmlhbGl6YXRpb25cblxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5nZXREaXJlY3Rpb24oKSxcbiAgICAgIGZvcm1hdDogdGhpcy5nZXRGb3JtYXRUeXBlKCksXG4gICAgICBpbmRlbnQ6IHRoaXMuZ2V0SW5kZW50KCksXG4gICAgICB0eXBlOiAnZWxlbWVudCcsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfSAvLyBUaGVzZSBhcmUgaW50ZW5kZWQgdG8gYmUgZXh0ZW5kcyBmb3Igc3BlY2lmaWMgZWxlbWVudCBoZXVyaXN0aWNzLlxuXG5cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLypcbiAgICogVGhpcyBtZXRob2QgY29udHJvbHMgdGhlIGJlaGF2aW9yIG9mIGEgdGhlIG5vZGUgZHVyaW5nIGJhY2t3YXJkc1xuICAgKiBkZWxldGlvbiAoaS5lLiwgYmFja3NwYWNlKSB3aGVuIHNlbGVjdGlvbiBpcyBhdCB0aGUgYmVnaW5uaW5nIG9mXG4gICAqIHRoZSBub2RlIChvZmZzZXQgMClcbiAgICovXG5cblxuICBjb2xsYXBzZUF0U3RhcnQoc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZXhjbHVkZUZyb21Db3B5KGRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRPRE8gMC4xMCBkZXByZWNhdGVcblxuXG4gIGNhbkV4dHJhY3RDb250ZW50cygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNhblJlcGxhY2VXaXRoKHJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjYW5JbnNlcnRBZnRlcihub2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNhbkluc2VydFRleHRBZnRlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlzSW5saW5lKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBBIHNoYWRvdyByb290IGlzIGEgTm9kZSB0aGF0IGJlaGF2ZXMgbGlrZSBSb290Tm9kZS4gVGhlIHNoYWRvdyByb290IChhbmQgUm9vdE5vZGUpIG1hcmsgdGhlXG4gIC8vIGVuZCBvZiB0aGUgaGllcmNoYXJjaHksIG1vc3QgaW1wbGVtZW50YXRpb25zIHNob3VsZCB0cmVhdCBpdCBhcyB0aGVyZSdzIG5vdGhpbmcgKHVwd2FyZHMpXG4gIC8vIGJleW9uZCB0aGlzIHBvaW50LiBGb3IgZXhhbXBsZSwgbm9kZS5nZXRUb3BMZXZlbEVsZW1lbnQoKSwgd2hlbiBwZXJmb3JtZWQgaW5zaWRlIGEgVGFibGVDZWxsTm9kZVxuICAvLyB3aWxsIHJldHVybiB0aGUgaW1tZWRpYXRlIGZpcnN0IGNoaWxkIHVuZGVybmVhdGggVGFibGVDZWxsTm9kZSBpbnN0ZWFkIG9mIFJvb3ROb2RlLlxuXG5cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNhbk1lcmdlV2l0aChub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZXh0cmFjdFdpdGhDaGlsZChjaGlsZCwgc2VsZWN0aW9uLCBkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59XG5mdW5jdGlvbiAkaXNFbGVtZW50Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgRWxlbWVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGlzUG9pbnRSZW1vdmVkKHBvaW50LCBub2Rlc1RvUmVtb3ZlS2V5U2V0LCBub2Rlc1RvSW5zZXJ0S2V5U2V0KSB7XG4gIGxldCBub2RlID0gcG9pbnQuZ2V0Tm9kZSgpO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgY29uc3Qgbm9kZUtleSA9IG5vZGUuX19rZXk7XG5cbiAgICBpZiAobm9kZXNUb1JlbW92ZUtleVNldC5oYXMobm9kZUtleSkgJiYgIW5vZGVzVG9JbnNlcnRLZXlTZXQuaGFzKG5vZGVLZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgUm9vdE5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdyb290JztcbiAgfVxuXG4gIHN0YXRpYyBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFJvb3ROb2RlKCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigncm9vdCcpO1xuICAgIHRoaXMuX19jYWNoZWRUZXh0ID0gbnVsbDtcbiAgfVxuXG4gIGdldFRvcExldmVsRWxlbWVudE9yVGhyb3coKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYGdldFRvcExldmVsRWxlbWVudE9yVGhyb3c6IHJvb3Qgbm9kZXMgYXJlIG5vdCB0b3AgbGV2ZWwgZWxlbWVudHNgKTtcbiAgICB9XG4gIH1cblxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBjYWNoZWRUZXh0ID0gdGhpcy5fX2NhY2hlZFRleHQ7XG5cbiAgICBpZiAoaXNDdXJyZW50bHlSZWFkT25seU1vZGUoKSB8fCBnZXRBY3RpdmVFZGl0b3IoKS5fZGlydHlUeXBlID09PSBOT19ESVJUWV9OT0RFUykge1xuICAgICAgaWYgKGNhY2hlZFRleHQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFRleHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmdldFRleHRDb250ZW50KCk7XG4gIH1cblxuICByZW1vdmUoKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYHJlbW92ZTogY2Fubm90IGJlIGNhbGxlZCBvbiByb290IG5vZGVzYCk7XG4gICAgfVxuICB9XG5cbiAgcmVwbGFjZShub2RlKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYHJlcGxhY2U6IGNhbm5vdCBiZSBjYWxsZWQgb24gcm9vdCBub2Rlc2ApO1xuICAgIH1cbiAgfVxuXG4gIGluc2VydEJlZm9yZShub2RlVG9JbnNlcnQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0QmVmb3JlOiBjYW5ub3QgYmUgY2FsbGVkIG9uIHJvb3Qgbm9kZXNgKTtcbiAgICB9XG4gIH1cblxuICBpbnNlcnRBZnRlcihub2RlVG9JbnNlcnQpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvcihgaW5zZXJ0QWZ0ZXI6IGNhbm5vdCBiZSBjYWxsZWQgb24gcm9vdCBub2Rlc2ApO1xuICAgIH1cbiAgfSAvLyBWaWV3XG5cblxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBNdXRhdGVcblxuXG4gIGFwcGVuZCguLi5ub2Rlc1RvQXBwZW5kKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc1RvQXBwZW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNUb0FwcGVuZFtpXTtcblxuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhJGlzRGVjb3JhdG9yTm9kZShub2RlKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoYHJvb3ROb2RlLmFwcGVuZDogT25seSBlbGVtZW50IG9yIGRlY29yYXRvciBub2RlcyBjYW4gYmUgYXBwZW5kZWQgdG8gdGhlIHJvb3Qgbm9kZWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmFwcGVuZCguLi5ub2Rlc1RvQXBwZW5kKTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgLy8gV2UgZG9uJ3QgY3JlYXRlIGEgcm9vdCwgYW5kIGluc3RlYWQgdXNlIHRoZSBleGlzdGluZyByb290LlxuICAgIGNvbnN0IG5vZGUgPSAkZ2V0Um9vdCgpO1xuICAgIG5vZGUuc2V0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLmZvcm1hdCk7XG4gICAgbm9kZS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KTtcbiAgICBub2RlLnNldERpcmVjdGlvbihzZXJpYWxpemVkTm9kZS5kaXJlY3Rpb24pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgZGlyZWN0aW9uOiB0aGlzLmdldERpcmVjdGlvbigpLFxuICAgICAgZm9ybWF0OiB0aGlzLmdldEZvcm1hdFR5cGUoKSxcbiAgICAgIGluZGVudDogdGhpcy5nZXRJbmRlbnQoKSxcbiAgICAgIHR5cGU6ICdyb290JyxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9O1xuICB9XG5cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn1cbmZ1bmN0aW9uICRjcmVhdGVSb290Tm9kZSgpIHtcbiAgcmV0dXJuIG5ldyBSb290Tm9kZSgpO1xufVxuZnVuY3Rpb24gJGlzUm9vdE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFJvb3ROb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5mdW5jdGlvbiBlZGl0b3JTdGF0ZUhhc0RpcnR5U2VsZWN0aW9uKGVkaXRvclN0YXRlLCBlZGl0b3IpIHtcbiAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLl9zZWxlY3Rpb247XG5cbiAgY29uc3QgcGVuZGluZ1NlbGVjdGlvbiA9IGVkaXRvclN0YXRlLl9zZWxlY3Rpb247IC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gdXBkYXRlIGJlY2F1c2Ugb2YgY2hhbmdlcyBpbiBzZWxlY3Rpb25cblxuICBpZiAocGVuZGluZ1NlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIGlmIChwZW5kaW5nU2VsZWN0aW9uLmRpcnR5IHx8ICFwZW5kaW5nU2VsZWN0aW9uLmlzKGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY3VycmVudFNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2xvbmVFZGl0b3JTdGF0ZShjdXJyZW50KSB7XG4gIHJldHVybiBuZXcgRWRpdG9yU3RhdGUobmV3IE1hcChjdXJyZW50Ll9ub2RlTWFwKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eUVkaXRvclN0YXRlKCkge1xuICByZXR1cm4gbmV3IEVkaXRvclN0YXRlKG5ldyBNYXAoW1sncm9vdCcsICRjcmVhdGVSb290Tm9kZSgpXV0pKTtcbn1cblxuZnVuY3Rpb24gZXhwb3J0Tm9kZVRvSlNPTihub2RlKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gbm9kZS5leHBvcnRKU09OKCk7XG4gIGNvbnN0IG5vZGVDbGFzcyA9IG5vZGUuY29uc3RydWN0b3I7IC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETyBSZXBsYWNlIENsYXNzIHV0aWxpdHkgdHlwZSB3aXRoIEluc3RhbmNlVHlwZVxuXG4gIGlmIChzZXJpYWxpemVkTm9kZS50eXBlICE9PSBub2RlQ2xhc3MuZ2V0VHlwZSgpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGRvZXMgbm90IG1hdGNoIHRoZSBzZXJpYWxpemVkIHR5cGUuIENoZWNrIGlmIC5leHBvcnRKU09OKCkgaXMgaW1wbGVtZW50ZWQgYW5kIGl0IGlzIHJldHVybmluZyB0aGUgY29ycmVjdCB0eXBlLmApO1xuICAgIH1cbiAgfSAvLyBAdHMtZXhwZWN0LWVycm9yIFRPRE8gUmVwbGFjZSBDbGFzcyB1dGlsaXR5IHR5cGUgd2l0aCBJbnN0YW5jZVR5cGVcblxuXG4gIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZHJlbiA9IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuO1xuXG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzZXJpYWxpemVkQ2hpbGRyZW4pKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBMZXhpY2FsTm9kZTogTm9kZSAke25vZGVDbGFzcy5uYW1lfSBpcyBhbiBlbGVtZW50IGJ1dCAuZXhwb3J0SlNPTigpIGRvZXMgbm90IGhhdmUgYSBjaGlsZHJlbiBhcnJheS5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGROb2RlID0gZXhwb3J0Tm9kZVRvSlNPTihjaGlsZCk7XG4gICAgICBzZXJpYWxpemVkQ2hpbGRyZW4ucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcbiAgICB9XG4gIH0gLy8gQHRzLWV4cGVjdC1lcnJvclxuXG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWROb2RlO1xufVxuXG5jbGFzcyBFZGl0b3JTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKG5vZGVNYXAsIHNlbGVjdGlvbikge1xuICAgIHRoaXMuX25vZGVNYXAgPSBub2RlTWFwO1xuICAgIHRoaXMuX3NlbGVjdGlvbiA9IHNlbGVjdGlvbiB8fCBudWxsO1xuICAgIHRoaXMuX2ZsdXNoU3luYyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRPbmx5ID0gZmFsc2U7XG4gIH1cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlTWFwLnNpemUgPT09IDEgJiYgdGhpcy5fc2VsZWN0aW9uID09PSBudWxsO1xuICB9XG5cbiAgcmVhZChjYWxsYmFja0ZuKSB7XG4gICAgcmV0dXJuIHJlYWRFZGl0b3JTdGF0ZSh0aGlzLCBjYWxsYmFja0ZuKTtcbiAgfVxuXG4gIGNsb25lKHNlbGVjdGlvbikge1xuICAgIGNvbnN0IGVkaXRvclN0YXRlID0gbmV3IEVkaXRvclN0YXRlKHRoaXMuX25vZGVNYXAsIHNlbGVjdGlvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5fc2VsZWN0aW9uIDogc2VsZWN0aW9uKTtcbiAgICBlZGl0b3JTdGF0ZS5fcmVhZE9ubHkgPSB0cnVlO1xuICAgIHJldHVybiBlZGl0b3JTdGF0ZTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gcmVhZEVkaXRvclN0YXRlKHRoaXMsICgpID0+ICh7XG4gICAgICByb290OiBleHBvcnROb2RlVG9KU09OKCRnZXRSb290KCkpXG4gICAgfSkpO1xuICB9XG5cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgUGFyYWdyYXBoTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdwYXJhZ3JhcGgnO1xuICB9XG5cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFBhcmFncmFwaE5vZGUobm9kZS5fX2tleSk7XG4gIH0gLy8gVmlld1xuXG5cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gZ2V0Q2FjaGVkQ2xhc3NOYW1lQXJyYXkoY29uZmlnLnRoZW1lLCAncGFyYWdyYXBoJyk7XG5cbiAgICBpZiAoY2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBkb21DbGFzc0xpc3QgPSBkb20uY2xhc3NMaXN0O1xuICAgICAgZG9tQ2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tO1xuICB9XG5cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHA6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFBhcmFncmFwaEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cblxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcblxuICAgIGlmIChlbGVtZW50ICYmIHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICBlbGVtZW50LmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgY29uc3QgZm9ybWF0VHlwZSA9IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpO1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBmb3JtYXRUeXBlO1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcblxuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICBlbGVtZW50LmRpciA9IGRpcmVjdGlvbjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZW50ID0gdGhpcy5nZXRJbmRlbnQoKTtcblxuICAgICAgaWYgKGluZGVudCA+IDApIHtcbiAgICAgICAgLy8gcGFkZGluZy1pbmxpbmUtc3RhcnQgaXMgbm90IHdpZGVseSBzdXBwb3J0ZWQgaW4gZW1haWwgSFRNTCwgYnV0XG4gICAgICAgIC8vIExleGljYWwgUmVjb25jaWxlciB1c2VzIHBhZGRpbmctaW5saW5lLXN0YXJ0LiBVc2luZyB0ZXh0LWluZGVudCBpbnN0ZWFkLlxuICAgICAgICBlbGVtZW50LnN0eWxlLnRleHRJbmRlbnQgPSBgJHtpbmRlbnQgKiAyMH1weGA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICBjb25zdCBub2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBub2RlLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpO1xuICAgIG5vZGUuc2V0SW5kZW50KHNlcmlhbGl6ZWROb2RlLmluZGVudCk7XG4gICAgbm9kZS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHsgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICB2ZXJzaW9uOiAxXG4gICAgfTtcbiAgfSAvLyBNdXRhdGlvblxuXG5cbiAgaW5zZXJ0TmV3QWZ0ZXIoXywgcmVzdG9yZVNlbGVjdGlvbikge1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCk7XG4gICAgbmV3RWxlbWVudC5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKG5ld0VsZW1lbnQsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpOyAvLyBJZiB3ZSBoYXZlIGFuIGVtcHR5ICh0cmltbWVkKSBmaXJzdCBwYXJhZ3JhcGggYW5kIHRyeSBhbmQgcmVtb3ZlIGl0LFxuICAgIC8vIGRlbGV0ZSB0aGUgcGFyYWdyYXBoIGFzIGxvbmcgYXMgd2UgaGF2ZSBhbm90aGVyIHNpYmxpbmcgdG8gZ28gdG9cblxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgJGlzVGV4dE5vZGUoY2hpbGRyZW5bMF0pICYmIGNoaWxkcmVuWzBdLmdldFRleHRDb250ZW50KCkudHJpbSgpID09PSAnJykge1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSB0aGlzLmdldE5leHRTaWJsaW5nKCk7XG5cbiAgICAgIGlmIChuZXh0U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNlbGVjdE5leHQoKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblxuICAgICAgaWYgKHByZXZTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gY29udmVydFBhcmFncmFwaEVsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCBub2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcblxuICBpZiAoZWxlbWVudC5zdHlsZSkge1xuICAgIG5vZGUuc2V0Rm9ybWF0KGVsZW1lbnQuc3R5bGUudGV4dEFsaWduKTtcbiAgICBjb25zdCBpbmRlbnQgPSBwYXJzZUludChlbGVtZW50LnN0eWxlLnRleHRJbmRlbnQsIDEwKSAvIDIwO1xuXG4gICAgaWYgKGluZGVudCA+IDApIHtcbiAgICAgIG5vZGUuc2V0SW5kZW50KGluZGVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlXG4gIH07XG59XG5cbmZ1bmN0aW9uICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBQYXJhZ3JhcGhOb2RlKCkpO1xufVxuZnVuY3Rpb24gJGlzUGFyYWdyYXBoTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgUGFyYWdyYXBoTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY29uc3QgQ09NTUFORF9QUklPUklUWV9FRElUT1IgPSAwO1xuY29uc3QgQ09NTUFORF9QUklPUklUWV9MT1cgPSAxO1xuY29uc3QgQ09NTUFORF9QUklPUklUWV9OT1JNQUwgPSAyO1xuY29uc3QgQ09NTUFORF9QUklPUklUWV9ISUdIID0gMztcbmNvbnN0IENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwgPSA0OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5cbmZ1bmN0aW9uIHJlc2V0RWRpdG9yKGVkaXRvciwgcHJldlJvb3RFbGVtZW50LCBuZXh0Um9vdEVsZW1lbnQsIHBlbmRpbmdFZGl0b3JTdGF0ZSkge1xuICBjb25zdCBrZXlOb2RlTWFwID0gZWRpdG9yLl9rZXlUb0RPTU1hcDtcbiAga2V5Tm9kZU1hcC5jbGVhcigpO1xuICBlZGl0b3IuX2VkaXRvclN0YXRlID0gY3JlYXRlRW1wdHlFZGl0b3JTdGF0ZSgpO1xuICBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IHBlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgZWRpdG9yLl9jb21wb3NpdGlvbktleSA9IG51bGw7XG4gIGVkaXRvci5fZGlydHlUeXBlID0gTk9fRElSVFlfTk9ERVM7XG5cbiAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZC5jbGVhcigpO1xuXG4gIGVkaXRvci5fZGlydHlMZWF2ZXMgPSBuZXcgU2V0KCk7XG5cbiAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzLmNsZWFyKCk7XG5cbiAgZWRpdG9yLl9ub3JtYWxpemVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gIGVkaXRvci5fdXBkYXRlVGFncyA9IG5ldyBTZXQoKTtcbiAgZWRpdG9yLl91cGRhdGVzID0gW107XG4gIGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50ID0gbnVsbDtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBlZGl0b3IuX29ic2VydmVyO1xuXG4gIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBlZGl0b3IuX29ic2VydmVyID0gbnVsbDtcbiAgfSAvLyBSZW1vdmUgYWxsIHRoZSBET00gbm9kZXMgZnJvbSB0aGUgcm9vdCBlbGVtZW50XG5cblxuICBpZiAocHJldlJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgcHJldlJvb3RFbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gIH1cblxuICBpZiAobmV4dFJvb3RFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgbmV4dFJvb3RFbGVtZW50LnRleHRDb250ZW50ID0gJyc7XG4gICAga2V5Tm9kZU1hcC5zZXQoJ3Jvb3QnLCBuZXh0Um9vdEVsZW1lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVDb252ZXJzaW9uQ2FjaGUobm9kZXMpIHtcbiAgY29uc3QgY29udmVyc2lvbkNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdCBoYW5kbGVkQ29udmVyc2lvbnMgPSBuZXcgU2V0KCk7XG4gIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgY29uc3QgaW1wb3J0RE9NID0gbm9kZS5rbGFzcy5pbXBvcnRET00gIT0gbnVsbCA/IG5vZGUua2xhc3MuaW1wb3J0RE9NLmJpbmQobm9kZS5rbGFzcykgOiBudWxsO1xuXG4gICAgaWYgKGltcG9ydERPTSA9PSBudWxsIHx8IGhhbmRsZWRDb252ZXJzaW9ucy5oYXMoaW1wb3J0RE9NKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhhbmRsZWRDb252ZXJzaW9ucy5hZGQoaW1wb3J0RE9NKTtcbiAgICBjb25zdCBtYXAgPSBpbXBvcnRET00oKTtcblxuICAgIGlmIChtYXAgIT09IG51bGwpIHtcbiAgICAgIE9iamVjdC5rZXlzKG1hcCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBsZXQgY3VycmVudENhY2hlID0gY29udmVyc2lvbkNhY2hlLmdldChrZXkpO1xuXG4gICAgICAgIGlmIChjdXJyZW50Q2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGN1cnJlbnRDYWNoZSA9IFtdO1xuICAgICAgICAgIGNvbnZlcnNpb25DYWNoZS5zZXQoa2V5LCBjdXJyZW50Q2FjaGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudENhY2hlLnB1c2gobWFwW2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNvbnZlcnNpb25DYWNoZTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBMZXhpY2FsRWRpdG9yIGF0dGFjaGVkIHRvIGEgc2luZ2xlIGNvbnRlbnRFZGl0YWJsZSAocHJvdmlkZWQgaW4gdGhlIGNvbmZpZykuIFRoaXMgaXNcbiAqIHRoZSBsb3dlc3QtbGV2ZWwgaW5pdGlhbGl6YXRpb24gQVBJIGZvciBhIExleGljYWxFZGl0b3IuIElmIHlvdSdyZSB1c2luZyBSZWFjdCBvciBhbm90aGVyIGZyYW1ld29yayxcbiAqIGNvbnNpZGVyIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBhYnN0cmFjdGlvbnMsIHN1Y2ggYXMgTGV4aWNhbENvbXBvc2VyXG4gKiBAcGFyYW0gZWRpdG9yQ29uZmlnIC0gdGhlIGVkaXRvciBjb25maWd1cmF0aW9uLlxuICogQHJldHVybnMgYSBMZXhpY2FsRWRpdG9yIGluc3RhbmNlXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVFZGl0b3IoZWRpdG9yQ29uZmlnKSB7XG4gIGNvbnN0IGNvbmZpZyA9IGVkaXRvckNvbmZpZyB8fCB7fTtcbiAgY29uc3QgYWN0aXZlRWRpdG9yID0gaW50ZXJuYWxHZXRBY3RpdmVFZGl0b3IoKTtcbiAgY29uc3QgdGhlbWUgPSBjb25maWcudGhlbWUgfHwge307XG4gIGNvbnN0IHBhcmVudEVkaXRvciA9IGVkaXRvckNvbmZpZyA9PT0gdW5kZWZpbmVkID8gYWN0aXZlRWRpdG9yIDogY29uZmlnLnBhcmVudEVkaXRvciB8fCBudWxsO1xuICBjb25zdCBkaXNhYmxlRXZlbnRzID0gY29uZmlnLmRpc2FibGVFdmVudHMgfHwgZmFsc2U7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gY3JlYXRlRW1wdHlFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBuYW1lc3BhY2UgPSBjb25maWcubmFtZXNwYWNlIHx8IChwYXJlbnRFZGl0b3IgIT09IG51bGwgPyBwYXJlbnRFZGl0b3IuX2NvbmZpZy5uYW1lc3BhY2UgOiBjcmVhdGVVSUQoKSk7XG4gIGNvbnN0IGluaXRpYWxFZGl0b3JTdGF0ZSA9IGNvbmZpZy5lZGl0b3JTdGF0ZTtcbiAgY29uc3Qgbm9kZXMgPSBbUm9vdE5vZGUsIFRleHROb2RlLCBMaW5lQnJlYWtOb2RlLCBUYWJOb2RlLCBQYXJhZ3JhcGhOb2RlLCAuLi4oY29uZmlnLm5vZGVzIHx8IFtdKV07XG4gIGNvbnN0IG9uRXJyb3IgPSBjb25maWcub25FcnJvcjtcbiAgY29uc3QgaXNFZGl0YWJsZSA9IGNvbmZpZy5lZGl0YWJsZSAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmVkaXRhYmxlIDogdHJ1ZTtcbiAgbGV0IHJlZ2lzdGVyZWROb2RlcztcblxuICBpZiAoZWRpdG9yQ29uZmlnID09PSB1bmRlZmluZWQgJiYgYWN0aXZlRWRpdG9yICE9PSBudWxsKSB7XG4gICAgcmVnaXN0ZXJlZE5vZGVzID0gYWN0aXZlRWRpdG9yLl9ub2RlcztcbiAgfSBlbHNlIHtcbiAgICByZWdpc3RlcmVkTm9kZXMgPSBuZXcgTWFwKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQga2xhc3MgPSBub2Rlc1tpXTtcbiAgICAgIGxldCByZXBsYWNlbWVudENsYXNzID0gbnVsbDtcbiAgICAgIGxldCByZXBsYWNlbWVudEtsYXNzID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiBrbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ga2xhc3M7XG4gICAgICAgIGtsYXNzID0gb3B0aW9ucy5yZXBsYWNlO1xuICAgICAgICByZXBsYWNlbWVudENsYXNzID0gb3B0aW9ucy53aXRoO1xuICAgICAgICByZXBsYWNlbWVudEtsYXNzID0gb3B0aW9ucy53aXRoS2xhc3MgPyBvcHRpb25zLndpdGhLbGFzcyA6IG51bGw7XG4gICAgICB9IC8vIEVuc3VyZSBjdXN0b20gbm9kZXMgaW1wbGVtZW50IHJlcXVpcmVkIG1ldGhvZHMuXG5cblxuICAgICAge1xuICAgICAgICBjb25zdCBuYW1lID0ga2xhc3MubmFtZTtcblxuICAgICAgICBpZiAobmFtZSAhPT0gJ1Jvb3ROb2RlJykge1xuICAgICAgICAgIGNvbnN0IHByb3RvID0ga2xhc3MucHJvdG90eXBlO1xuICAgICAgICAgIFsnZ2V0VHlwZScsICdjbG9uZSddLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkobWV0aG9kKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gbXVzdCBpbXBsZW1lbnQgc3RhdGljIFwiJHttZXRob2R9XCIgbWV0aG9kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICAha2xhc3MuaGFzT3duUHJvcGVydHkoJ2ltcG9ydERPTScpICYmIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgICBrbGFzcy5oYXNPd25Qcm9wZXJ0eSgnZXhwb3J0RE9NJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtuYW1lfSBzaG91bGQgaW1wbGVtZW50IFwiaW1wb3J0RE9NXCIgaWYgdXNpbmcgYSBjdXN0b20gXCJleHBvcnRET01cIiBtZXRob2QgdG8gZW5zdXJlIEhUTUwgc2VyaWFsaXphdGlvbiAoaW1wb3J0YW50IGZvciBjb3B5ICYgcGFzdGUpIHdvcmtzIGFzIGV4cGVjdGVkYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHByb3RvIGluc3RhbmNlb2YgRGVjb3JhdG9yTm9kZSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICAgaWYgKCFwcm90by5oYXNPd25Qcm9wZXJ0eSgnZGVjb3JhdGUnKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7cHJvdG8uY29uc3RydWN0b3IubmFtZX0gbXVzdCBpbXBsZW1lbnQgXCJkZWNvcmF0ZVwiIG1ldGhvZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICggLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICFrbGFzcy5oYXNPd25Qcm9wZXJ0eSgnaW1wb3J0SlNPTicpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gc2hvdWxkIGltcGxlbWVudCBcImltcG9ydEpTT05cIiBtZXRob2QgdG8gZW5zdXJlIEpTT04gYW5kIGRlZmF1bHQgSFRNTCBzZXJpYWxpemF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgICAgIXByb3RvLmhhc093blByb3BlcnR5KCdleHBvcnRKU09OJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtuYW1lfSBzaG91bGQgaW1wbGVtZW50IFwiZXhwb3J0SlNPTlwiIG1ldGhvZCB0byBlbnN1cmUgSlNPTiBhbmQgZGVmYXVsdCBIVE1MIHNlcmlhbGl6YXRpb24gd29ya3MgYXMgZXhwZWN0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgdHlwZSA9IGtsYXNzLmdldFR5cGUoKTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGtsYXNzLnRyYW5zZm9ybSgpO1xuICAgICAgY29uc3QgdHJhbnNmb3JtcyA9IG5ldyBTZXQoKTtcblxuICAgICAgaWYgKHRyYW5zZm9ybSAhPT0gbnVsbCkge1xuICAgICAgICB0cmFuc2Zvcm1zLmFkZCh0cmFuc2Zvcm0pO1xuICAgICAgfVxuXG4gICAgICByZWdpc3RlcmVkTm9kZXMuc2V0KHR5cGUsIHtcbiAgICAgICAga2xhc3MsXG4gICAgICAgIHJlcGxhY2U6IHJlcGxhY2VtZW50Q2xhc3MsXG4gICAgICAgIHJlcGxhY2VXaXRoS2xhc3M6IHJlcGxhY2VtZW50S2xhc3MsXG4gICAgICAgIHRyYW5zZm9ybXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVkaXRvciA9IG5ldyBMZXhpY2FsRWRpdG9yKGVkaXRvclN0YXRlLCBwYXJlbnRFZGl0b3IsIHJlZ2lzdGVyZWROb2Rlcywge1xuICAgIGRpc2FibGVFdmVudHMsXG4gICAgbmFtZXNwYWNlLFxuICAgIHRoZW1lXG4gIH0sIG9uRXJyb3IgPyBvbkVycm9yIDogY29uc29sZS5lcnJvciwgaW5pdGlhbGl6ZUNvbnZlcnNpb25DYWNoZShyZWdpc3RlcmVkTm9kZXMpLCBpc0VkaXRhYmxlKTtcblxuICBpZiAoaW5pdGlhbEVkaXRvclN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IGluaXRpYWxFZGl0b3JTdGF0ZTtcbiAgICBlZGl0b3IuX2RpcnR5VHlwZSA9IEZVTExfUkVDT05DSUxFO1xuICB9XG5cbiAgcmV0dXJuIGVkaXRvcjtcbn1cbmNsYXNzIExleGljYWxFZGl0b3Ige1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IoZWRpdG9yU3RhdGUsIHBhcmVudEVkaXRvciwgbm9kZXMsIGNvbmZpZywgb25FcnJvciwgaHRtbENvbnZlcnNpb25zLCBlZGl0YWJsZSkge1xuICAgIHRoaXMuX3BhcmVudEVkaXRvciA9IHBhcmVudEVkaXRvcjsgLy8gVGhlIHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBlZGl0b3JcblxuICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gbnVsbDsgLy8gVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlXG5cbiAgICB0aGlzLl9lZGl0b3JTdGF0ZSA9IGVkaXRvclN0YXRlOyAvLyBIYW5kbGluZyBvZiBkcmFmdHMgYW5kIHVwZGF0ZXNcblxuICAgIHRoaXMuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IG51bGw7IC8vIFVzZWQgdG8gaGVscCBjby1vcmRpbmF0ZSBzZWxlY3Rpb24gYW5kIGV2ZW50c1xuXG4gICAgdGhpcy5fY29tcG9zaXRpb25LZXkgPSBudWxsO1xuICAgIHRoaXMuX2RlZmVycmVkID0gW107IC8vIFVzZWQgZHVyaW5nIHJlY29uY2lsaWF0aW9uXG5cbiAgICB0aGlzLl9rZXlUb0RPTU1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl91cGRhdGVzID0gW107XG4gICAgdGhpcy5fdXBkYXRpbmcgPSBmYWxzZTsgLy8gTGlzdGVuZXJzXG5cbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7XG4gICAgICBkZWNvcmF0b3I6IG5ldyBTZXQoKSxcbiAgICAgIGVkaXRhYmxlOiBuZXcgU2V0KCksXG4gICAgICBtdXRhdGlvbjogbmV3IE1hcCgpLFxuICAgICAgcm9vdDogbmV3IFNldCgpLFxuICAgICAgdGV4dGNvbnRlbnQ6IG5ldyBTZXQoKSxcbiAgICAgIHVwZGF0ZTogbmV3IFNldCgpXG4gICAgfTsgLy8gQ29tbWFuZHNcblxuICAgIHRoaXMuX2NvbW1hbmRzID0gbmV3IE1hcCgpOyAvLyBFZGl0b3IgY29uZmlndXJhdGlvbiBmb3IgdGhlbWUvY29udGV4dC5cblxuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZzsgLy8gTWFwcGluZyBvZiB0eXBlcyB0byB0aGVpciBub2Rlc1xuXG4gICAgdGhpcy5fbm9kZXMgPSBub2RlczsgLy8gUmVhY3Qgbm9kZSBkZWNvcmF0b3JzIGZvciBwb3J0YWxzXG5cbiAgICB0aGlzLl9kZWNvcmF0b3JzID0ge307XG4gICAgdGhpcy5fcGVuZGluZ0RlY29yYXRvcnMgPSBudWxsOyAvLyBVc2VkIHRvIG9wdGltaXplIHJlY29uY2lsaWF0aW9uXG5cbiAgICB0aGlzLl9kaXJ0eVR5cGUgPSBOT19ESVJUWV9OT0RFUztcbiAgICB0aGlzLl9jbG9uZU5vdE5lZWRlZCA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9kaXJ0eUxlYXZlcyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9kaXJ0eUVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX25vcm1hbGl6ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl91cGRhdGVUYWdzID0gbmV3IFNldCgpOyAvLyBIYW5kbGluZyBvZiBET00gbXV0YXRpb25zXG5cbiAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7IC8vIFVzZWQgZm9yIGlkZW50aWZ5aW5nIG93bmluZyBlZGl0b3JzXG5cbiAgICB0aGlzLl9rZXkgPSBjcmVhdGVVSUQoKTtcbiAgICB0aGlzLl9vbkVycm9yID0gb25FcnJvcjtcbiAgICB0aGlzLl9odG1sQ29udmVyc2lvbnMgPSBodG1sQ29udmVyc2lvbnM7XG4gICAgdGhpcy5fZWRpdGFibGUgPSBlZGl0YWJsZTtcbiAgICB0aGlzLl9oZWFkbGVzcyA9IHBhcmVudEVkaXRvciAhPT0gbnVsbCAmJiBwYXJlbnRFZGl0b3IuX2hlYWRsZXNzO1xuICAgIHRoaXMuX3dpbmRvdyA9IG51bGw7XG4gICAgdGhpcy5fYmxvY2tDdXJzb3JFbGVtZW50ID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZWRpdG9yIGlzIGN1cnJlbnRseSBpbiBcImNvbXBvc2l0aW9uXCIgbW9kZSBkdWUgdG8gcmVjZWl2aW5nIGlucHV0XG4gICAqIHRocm91Z2ggYW4gSU1FLCBvciAzUCBleHRlbnNpb24sIGZvciBleGFtcGxlLiBSZXR1cm5zIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG5cblxuICBpc0NvbXBvc2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9zaXRpb25LZXkgIT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgZm9yIEVkaXRvciB1cGRhdGUgZXZlbnQuIFdpbGwgdHJpZ2dlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2tcbiAgICogZWFjaCB0aW1lIHRoZSBlZGl0b3IgZ29lcyB0aHJvdWdoIGFuIHVwZGF0ZSAodmlhIHtAbGluayBMZXhpY2FsRWRpdG9yLnVwZGF0ZX0pIHVudGlsIHRoZVxuICAgKiB0ZWFyZG93biBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVhcmRvd24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhbnVwIHRoZSBsaXN0ZW5lci5cbiAgICovXG5cblxuICByZWdpc3RlclVwZGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJTZXRPck1hcCA9IHRoaXMuX2xpc3RlbmVycy51cGRhdGU7XG4gICAgbGlzdGVuZXJTZXRPck1hcC5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lclNldE9yTWFwLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgZm9yIGZvciB3aGVuIHRoZSBlZGl0b3IgY2hhbmdlcyBiZXR3ZWVuIGVkaXRhYmxlIGFuZCBub24tZWRpdGFibGUgc3RhdGVzLlxuICAgKiBXaWxsIHRyaWdnZXIgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGVhY2ggdGltZSB0aGUgZWRpdG9yIHRyYW5zaXRpb25zIGJldHdlZW4gdGhlc2Ugc3RhdGVzIHVudGlsIHRoZVxuICAgKiB0ZWFyZG93biBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVhcmRvd24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhbnVwIHRoZSBsaXN0ZW5lci5cbiAgICovXG5cblxuICByZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lclNldE9yTWFwID0gdGhpcy5fbGlzdGVuZXJzLmVkaXRhYmxlO1xuICAgIGxpc3RlbmVyU2V0T3JNYXAuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJTZXRPck1hcC5kZWxldGUobGlzdGVuZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciB3aGVuIHRoZSBlZGl0b3IncyBkZWNvcmF0b3Igb2JqZWN0IGNoYW5nZXMuIFRoZSBkZWNvcmF0b3Igb2JqZWN0IGNvbnRhaW5zXG4gICAqIGFsbCBEZWNvcmF0b3JOb2RlIGtleXMgLT4gdGhlaXIgZGVjb3JhdGVkIHZhbHVlLiBUaGlzIGlzIHByaW1hcmlseSB1c2VkIHdpdGggZXh0ZXJuYWwgVUkgZnJhbWV3b3Jrcy5cbiAgICpcbiAgICogV2lsbCB0cmlnZ2VyIHRoZSBwcm92aWRlZCBjYWxsYmFjayBlYWNoIHRpbWUgdGhlIGVkaXRvciB0cmFuc2l0aW9ucyBiZXR3ZWVuIHRoZXNlIHN0YXRlcyB1bnRpbCB0aGVcbiAgICogdGVhcmRvd24gZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuXG5cbiAgcmVnaXN0ZXJEZWNvcmF0b3JMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVyU2V0T3JNYXAgPSB0aGlzLl9saXN0ZW5lcnMuZGVjb3JhdG9yO1xuICAgIGxpc3RlbmVyU2V0T3JNYXAuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJTZXRPck1hcC5kZWxldGUobGlzdGVuZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciB3aGVuIExleGljYWwgY29tbWl0cyBhbiB1cGRhdGUgdG8gdGhlIERPTSBhbmQgdGhlIHRleHQgY29udGVudCBvZlxuICAgKiB0aGUgZWRpdG9yIGNoYW5nZXMgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUgb2YgdGhlIGVkaXRvci4gSWYgdGhlIHRleHQgY29udGVudCBpcyB0aGVcbiAgICogc2FtZSBiZXR3ZWVuIHVwZGF0ZXMsIG5vIG5vdGlmaWNhdGlvbnMgdG8gdGhlIGxpc3RlbmVycyB3aWxsIGhhcHBlbi5cbiAgICpcbiAgICogV2lsbCB0cmlnZ2VyIHRoZSBwcm92aWRlZCBjYWxsYmFjayBlYWNoIHRpbWUgdGhlIGVkaXRvciB0cmFuc2l0aW9ucyBiZXR3ZWVuIHRoZXNlIHN0YXRlcyB1bnRpbCB0aGVcbiAgICogdGVhcmRvd24gZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuXG5cbiAgcmVnaXN0ZXJUZXh0Q29udGVudExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJTZXRPck1hcCA9IHRoaXMuX2xpc3RlbmVycy50ZXh0Y29udGVudDtcbiAgICBsaXN0ZW5lclNldE9yTWFwLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVyU2V0T3JNYXAuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciBmb3Igd2hlbiB0aGUgZWRpdG9yJ3Mgcm9vdCBET00gZWxlbWVudCAodGhlIGNvbnRlbnQgZWRpdGFibGVcbiAgICogTGV4aWNhbCBhdHRhY2hlcyB0bykgY2hhbmdlcy4gVGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byBhdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSByb290XG4gICAqICBlbGVtZW50LiBUaGUgcm9vdCBsaXN0ZW5lciBmdW5jdGlvbiBpcyBleGVjdXRlZCBkaXJlY3RseSB1cG9uIHJlZ2lzdHJhdGlvbiBhbmQgdGhlbiBvblxuICAgKiBhbnkgc3Vic2VxdWVudCB1cGRhdGUuXG4gICAqXG4gICAqIFdpbGwgdHJpZ2dlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZWFjaCB0aW1lIHRoZSBlZGl0b3IgdHJhbnNpdGlvbnMgYmV0d2VlbiB0aGVzZSBzdGF0ZXMgdW50aWwgdGhlXG4gICAqIHRlYXJkb3duIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cblxuXG4gIHJlZ2lzdGVyUm9vdExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJTZXRPck1hcCA9IHRoaXMuX2xpc3RlbmVycy5yb290O1xuICAgIGxpc3RlbmVyKHRoaXMuX3Jvb3RFbGVtZW50LCBudWxsKTtcbiAgICBsaXN0ZW5lclNldE9yTWFwLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVyKG51bGwsIHRoaXMuX3Jvb3RFbGVtZW50KTtcbiAgICAgIGxpc3RlbmVyU2V0T3JNYXAuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgdHJpZ2dlciBhbnl0aW1lIHRoZSBwcm92aWRlZCBjb21tYW5kXG4gICAqIGlzIGRpc3BhdGNoZWQsIHN1YmplY3QgdG8gcHJpb3JpdHkuIExpc3RlbmVycyB0aGF0IHJ1biBhdCBhIGhpZ2hlciBwcmlvcml0eSBjYW4gXCJpbnRlcmNlcHRcIlxuICAgKiBjb21tYW5kcyBhbmQgcHJldmVudCB0aGVtIGZyb20gcHJvcGFnYXRpbmcgdG8gb3RoZXIgaGFuZGxlcnMgYnkgcmV0dXJuaW5nIHRydWUuXG4gICAqXG4gICAqIExpc3RlbmVycyByZWdpc3RlcmVkIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIHdpbGwgcnVuIGRldGVybWluaXN0aWNhbGx5IGluIHRoZSBvcmRlciBvZiByZWdpc3RyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBjb21tYW5kIC0gdGhlIGNvbW1hbmQgdGhhdCB3aWxsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgd2hlbiB0aGUgY29tbWFuZCBpcyBkaXNwYXRjaGVkLlxuICAgKiBAcGFyYW0gcHJpb3JpdHkgLSB0aGUgcmVsYXRpdmUgcHJpb3JpdHkgb2YgdGhlIGxpc3RlbmVyLiAwIHwgMSB8IDIgfCAzIHwgNFxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuXG5cbiAgcmVnaXN0ZXJDb21tYW5kKGNvbW1hbmQsIGxpc3RlbmVyLCBwcmlvcml0eSkge1xuICAgIGlmIChwcmlvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKGBMaXN0ZW5lciBmb3IgdHlwZSBcImNvbW1hbmRcIiByZXF1aXJlcyBhIFwicHJpb3JpdHlcIi5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBjb21tYW5kc01hcCA9IHRoaXMuX2NvbW1hbmRzO1xuXG4gICAgaWYgKCFjb21tYW5kc01hcC5oYXMoY29tbWFuZCkpIHtcbiAgICAgIGNvbW1hbmRzTWFwLnNldChjb21tYW5kLCBbbmV3IFNldCgpLCBuZXcgU2V0KCksIG5ldyBTZXQoKSwgbmV3IFNldCgpLCBuZXcgU2V0KCldKTtcbiAgICB9XG5cbiAgICBjb25zdCBsaXN0ZW5lcnNJblByaW9yaXR5T3JkZXIgPSBjb21tYW5kc01hcC5nZXQoY29tbWFuZCk7XG5cbiAgICBpZiAobGlzdGVuZXJzSW5Qcmlvcml0eU9yZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYHJlZ2lzdGVyQ29tbWFuZDogQ29tbWFuZCAke1N0cmluZyhjb21tYW5kKX0gbm90IGZvdW5kIGluIGNvbW1hbmQgbWFwYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdGVuZXJzID0gbGlzdGVuZXJzSW5Qcmlvcml0eU9yZGVyW3ByaW9yaXR5XTtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG5cbiAgICAgIGlmIChsaXN0ZW5lcnNJblByaW9yaXR5T3JkZXIuZXZlcnkobGlzdGVuZXJzU2V0ID0+IGxpc3RlbmVyc1NldC5zaXplID09PSAwKSkge1xuICAgICAgICBjb21tYW5kc01hcC5kZWxldGUoY29tbWFuZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIHJ1biB3aGVuIGEgTGV4aWNhbCBub2RlIG9mIHRoZSBwcm92aWRlZCBjbGFzcyBpc1xuICAgKiBtdXRhdGVkLiBUaGUgbGlzdGVuZXIgd2lsbCByZWNlaXZlIGEgbGlzdCBvZiBub2RlcyBhbG9uZyB3aXRoIHRoZSB0eXBlIG9mIG11dGF0aW9uXG4gICAqIHRoYXQgd2FzIHBlcmZvcm1lZCBvbiBlYWNoOiBjcmVhdGVkLCBkZXN0cm95ZWQsIG9yIHVwZGF0ZWQuXG4gICAqXG4gICAqIE9uZSBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdG8gYXR0YWNoIERPTSBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGVzIGFzIExleGljYWwgbm9kZXMgYXJlIGNyZWF0ZWQuXG4gICAqIHtAbGluayBMZXhpY2FsRWRpdG9yLmdldEVsZW1lbnRCeUtleX0gY2FuIGJlIHVzZWQgZm9yIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSBrbGFzcyAtIFRoZSBjbGFzcyBvZiB0aGUgbm9kZSB0aGF0IHlvdSB3YW50IHRvIGxpc3RlbiB0byBtdXRhdGlvbnMgb24uXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIFRoZSBsb2dpYyB5b3Ugd2FudCB0byBydW4gd2hlbiB0aGUgbm9kZSBpcyBtdXRhdGVkLlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuXG5cbiAgcmVnaXN0ZXJNdXRhdGlvbkxpc3RlbmVyKGtsYXNzLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gdGhpcy5fbm9kZXMuZ2V0KGtsYXNzLmdldFR5cGUoKSk7XG5cbiAgICBpZiAocmVnaXN0ZXJlZE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTm9kZSAke2tsYXNzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLiBFbnN1cmUgbm9kZSBoYXMgYmVlbiBwYXNzZWQgdG8gY3JlYXRlRWRpdG9yLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG11dGF0aW9ucyA9IHRoaXMuX2xpc3RlbmVycy5tdXRhdGlvbjtcbiAgICBtdXRhdGlvbnMuc2V0KGxpc3RlbmVyLCBrbGFzcyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG11dGF0aW9ucy5kZWxldGUobGlzdGVuZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG5cbiAgcmVnaXN0ZXJOb2RlVHJhbnNmb3JtVG9LbGFzcyhrbGFzcywgbGlzdGVuZXIpIHtcbiAgICBjb25zdCB0eXBlID0ga2xhc3MuZ2V0VHlwZSgpO1xuXG4gICAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSB0aGlzLl9ub2Rlcy5nZXQodHlwZSk7XG5cbiAgICBpZiAocmVnaXN0ZXJlZE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgTm9kZSAke2tsYXNzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLiBFbnN1cmUgbm9kZSBoYXMgYmVlbiBwYXNzZWQgdG8gY3JlYXRlRWRpdG9yLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zZm9ybXMgPSByZWdpc3RlcmVkTm9kZS50cmFuc2Zvcm1zO1xuICAgIHRyYW5zZm9ybXMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gcmVnaXN0ZXJlZE5vZGU7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBydW4gd2hlbiBhIExleGljYWwgbm9kZSBvZiB0aGUgcHJvdmlkZWQgY2xhc3MgaXNcbiAgICogbWFya2VkIGRpcnR5IGR1cmluZyBhbiB1cGRhdGUuIFRoZSBsaXN0ZW5lciB3aWxsIGNvbnRpbnVlIHRvIHJ1biBhcyBsb25nIGFzIHRoZSBub2RlXG4gICAqIGlzIG1hcmtlZCBkaXJ0eS4gVGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgYXJvdW5kIHRoZSBvcmRlciBvZiB0cmFuc2Zvcm0gZXhlY3V0aW9uIVxuICAgKlxuICAgKiBXYXRjaCBvdXQgZm9yIGluZmluaXRlIGxvb3BzLiBTZWUgW05vZGUgVHJhbnNmb3Jtc10oaHR0cHM6Ly9sZXhpY2FsLmRldi9kb2NzL2NvbmNlcHRzL3RyYW5zZm9ybXMpXG4gICAqIEBwYXJhbSBrbGFzcyAtIFRoZSBjbGFzcyBvZiB0aGUgbm9kZSB0aGF0IHlvdSB3YW50IHRvIHJ1biB0cmFuc2Zvcm1zIG9uLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgbG9naWMgeW91IHdhbnQgdG8gcnVuIHdoZW4gdGhlIG5vZGUgaXMgdXBkYXRlZC5cbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cblxuXG4gIHJlZ2lzdGVyTm9kZVRyYW5zZm9ybShrbGFzcywgbGlzdGVuZXIpIHtcbiAgICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IHRoaXMucmVnaXN0ZXJOb2RlVHJhbnNmb3JtVG9LbGFzcyhrbGFzcywgbGlzdGVuZXIpO1xuICAgIGNvbnN0IHJlZ2lzdGVyZWROb2RlcyA9IFtyZWdpc3RlcmVkTm9kZV07XG4gICAgY29uc3QgcmVwbGFjZVdpdGhLbGFzcyA9IHJlZ2lzdGVyZWROb2RlLnJlcGxhY2VXaXRoS2xhc3M7XG5cbiAgICBpZiAocmVwbGFjZVdpdGhLbGFzcyAhPSBudWxsKSB7XG4gICAgICBjb25zdCByZWdpc3RlcmVkUmVwbGFjZVdpdGhOb2RlID0gdGhpcy5yZWdpc3Rlck5vZGVUcmFuc2Zvcm1Ub0tsYXNzKHJlcGxhY2VXaXRoS2xhc3MsIGxpc3RlbmVyKTtcbiAgICAgIHJlZ2lzdGVyZWROb2Rlcy5wdXNoKHJlZ2lzdGVyZWRSZXBsYWNlV2l0aE5vZGUpO1xuICAgIH1cblxuICAgIG1hcmtBbGxOb2Rlc0FzRGlydHkodGhpcywga2xhc3MuZ2V0VHlwZSgpKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVnaXN0ZXJlZE5vZGVzLmZvckVhY2gobm9kZSA9PiBub2RlLnRyYW5zZm9ybXMuZGVsZXRlKGxpc3RlbmVyKSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogVXNlZCB0byBhc3NlcnQgdGhhdCBhIGNlcnRhaW4gbm9kZSBpcyByZWdpc3RlcmVkLCB1c3VhbGx5IGJ5IHBsdWdpbnMgdG8gZW5zdXJlIG5vZGVzIHRoYXQgdGhleVxuICAgKiBkZXBlbmQgb24gaGF2ZSBiZWVuIHJlZ2lzdGVyZWQuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGVkaXRvciBoYXMgcmVnaXN0ZXJlZCB0aGUgcHJvdmlkZWQgbm9kZSB0eXBlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgaGFzTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzLmhhcyhub2RlLmdldFR5cGUoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFVzZWQgdG8gYXNzZXJ0IHRoYXQgY2VydGFpbiBub2RlcyBhcmUgcmVnaXN0ZXJlZCwgdXN1YWxseSBieSBwbHVnaW5zIHRvIGVuc3VyZSBub2RlcyB0aGF0IHRoZXlcbiAgICogZGVwZW5kIG9uIGhhdmUgYmVlbiByZWdpc3RlcmVkLlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBlZGl0b3IgaGFzIHJlZ2lzdGVyZWQgYWxsIG9mIHRoZSBwcm92aWRlZCBub2RlIHR5cGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cbiAgaGFzTm9kZXMobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMuZXZlcnkodGhpcy5oYXNOb2RlLmJpbmQodGhpcykpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGEgY29tbWFuZCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgd2l0aCB0aGUgc3BlY2lmaWVkIHBheWxvYWQuXG4gICAqIFRoaXMgdHJpZ2dlcnMgYWxsIGNvbW1hbmQgbGlzdGVuZXJzIChzZXQgYnkge0BsaW5rIExleGljYWxFZGl0b3IucmVnaXN0ZXJDb21tYW5kfSlcbiAgICogZm9yIHRoaXMgdHlwZSwgcGFzc2luZyB0aGVtIHRoZSBwcm92aWRlZCBwYXlsb2FkLlxuICAgKiBAcGFyYW0gdHlwZSAtIHRoZSB0eXBlIG9mIGNvbW1hbmQgbGlzdGVuZXJzIHRvIHRyaWdnZXIuXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gdGhlIGRhdGEgdG8gcGFzcyBhcyBhbiBhcmd1bWVudCB0byB0aGUgY29tbWFuZCBsaXN0ZW5lcnMuXG4gICAqL1xuXG5cbiAgZGlzcGF0Y2hDb21tYW5kKHR5cGUsIHBheWxvYWQpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hDb21tYW5kKHRoaXMsIHR5cGUsIHBheWxvYWQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgbWFwIG9mIGFsbCBkZWNvcmF0b3JzIGluIHRoZSBlZGl0b3IuXG4gICAqIEByZXR1cm5zIEEgbWFwcGluZyBvZiBjYWxsIGRlY29yYXRvciBrZXlzIHRvIHRoZWlyIGRlY29yYXRlZCBjb250ZW50XG4gICAqL1xuXG5cbiAgZ2V0RGVjb3JhdG9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVjb3JhdG9ycztcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgcm9vdCBlbGVtZW50IG9mIHRoZSBlZGl0b3IuIElmIHlvdSB3YW50IHRvIHJlZ2lzdGVyXG4gICAqIGFuIGV2ZW50IGxpc3RlbmVyLCBkbyBpdCB2aWEge0BsaW5rIExleGljYWxFZGl0b3IucmVnaXN0ZXJSb290TGlzdGVuZXJ9LCBzaW5jZVxuICAgKiB0aGlzIHJlZmVyZW5jZSBtYXkgbm90IGJlIHN0YWJsZS5cbiAgICovXG5cblxuICBnZXRSb290RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGtleSBvZiB0aGUgZWRpdG9yXG4gICAqIEByZXR1cm5zIFRoZSBlZGl0b3Iga2V5XG4gICAqL1xuXG5cbiAgZ2V0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLl9rZXk7XG4gIH1cbiAgLyoqXG4gICAqIEltcGVyYXRpdmVseSBzZXQgdGhlIHJvb3QgY29udGVudGVkaXRhYmxlIGVsZW1lbnQgdGhhdCBMZXhpY2FsIGxpc3RlbnNcbiAgICogZm9yIGV2ZW50cyBvbi5cbiAgICovXG5cblxuICBzZXRSb290RWxlbWVudChuZXh0Um9vdEVsZW1lbnQpIHtcbiAgICBjb25zdCBwcmV2Um9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcblxuICAgIGlmIChuZXh0Um9vdEVsZW1lbnQgIT09IHByZXZSb290RWxlbWVudCkge1xuICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KHRoaXMuX2NvbmZpZy50aGVtZSwgJ3Jvb3QnKTtcbiAgICAgIGNvbnN0IHBlbmRpbmdFZGl0b3JTdGF0ZSA9IHRoaXMuX3BlbmRpbmdFZGl0b3JTdGF0ZSB8fCB0aGlzLl9lZGl0b3JTdGF0ZTtcbiAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gbmV4dFJvb3RFbGVtZW50O1xuICAgICAgcmVzZXRFZGl0b3IodGhpcywgcHJldlJvb3RFbGVtZW50LCBuZXh0Um9vdEVsZW1lbnQsIHBlbmRpbmdFZGl0b3JTdGF0ZSk7XG5cbiAgICAgIGlmIChwcmV2Um9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgZmxhZyBvbmNlIHdlIG5vIGxvbmdlciB1c2UgVUV2MiBpbnRlcm5hbGx5XG4gICAgICAgIGlmICghdGhpcy5fY29uZmlnLmRpc2FibGVFdmVudHMpIHtcbiAgICAgICAgICByZW1vdmVSb290RWxlbWVudEV2ZW50cyhwcmV2Um9vdEVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsYXNzTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICAgIHByZXZSb290RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0Um9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd2luZG93T2JqID0gZ2V0RGVmYXVsdFZpZXcobmV4dFJvb3RFbGVtZW50KTtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBuZXh0Um9vdEVsZW1lbnQuc3R5bGU7XG4gICAgICAgIHN0eWxlLnVzZXJTZWxlY3QgPSAndGV4dCc7XG4gICAgICAgIHN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICAgICAgICBzdHlsZS53b3JkQnJlYWsgPSAnYnJlYWstd29yZCc7XG4gICAgICAgIG5leHRSb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1lZGl0b3InLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLl93aW5kb3cgPSB3aW5kb3dPYmo7XG4gICAgICAgIHRoaXMuX2RpcnR5VHlwZSA9IEZVTExfUkVDT05DSUxFO1xuICAgICAgICBpbml0TXV0YXRpb25PYnNlcnZlcih0aGlzKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVUYWdzLmFkZCgnaGlzdG9yeS1tZXJnZScpO1xuXG4gICAgICAgIGNvbW1pdFBlbmRpbmdVcGRhdGVzKHRoaXMpOyAvLyBUT0RPOiByZW1vdmUgdGhpcyBmbGFnIG9uY2Ugd2Ugbm8gbG9uZ2VyIHVzZSBVRXYyIGludGVybmFsbHlcblxuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5kaXNhYmxlRXZlbnRzKSB7XG4gICAgICAgICAgYWRkUm9vdEVsZW1lbnRFdmVudHMobmV4dFJvb3RFbGVtZW50LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbGFzc05hbWVzICE9IG51bGwpIHtcbiAgICAgICAgICBuZXh0Um9vdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgY29udGVudCBlZGl0YWJsZSBpcyB1bm1vdW50ZWQgd2UnbGwgcmVzZXQgZWRpdG9yIHN0YXRlIGJhY2sgdG8gb3JpZ2luYWxcbiAgICAgICAgLy8gKG9yIHBlbmRpbmcpIGVkaXRvciBzdGF0ZSBzaW5jZSB0aGVyZSB3aWxsIGJlIG5vIHJlY29uY2lsaWF0aW9uXG4gICAgICAgIHRoaXMuX2VkaXRvclN0YXRlID0gcGVuZGluZ0VkaXRvclN0YXRlO1xuICAgICAgICB0aGlzLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl93aW5kb3cgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0cmlnZ2VyTGlzdGVuZXJzKCdyb290JywgdGhpcywgZmFsc2UsIG5leHRSb290RWxlbWVudCwgcHJldlJvb3RFbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVuZGVybHlpbmcgSFRNTEVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBMZXhpY2FsTm9kZSBmb3IgdGhlIGdpdmVuIGtleS5cbiAgICogQHJldHVybnMgdGhlIEhUTUxFbGVtZW50IHJlbmRlcmVkIGJ5IHRoZSBMZXhpY2FsTm9kZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleS5cbiAgICogQHBhcmFtIGtleSAtIHRoZSBrZXkgb2YgdGhlIExleGljYWxOb2RlLlxuICAgKi9cblxuXG4gIGdldEVsZW1lbnRCeUtleShrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5VG9ET01NYXAuZ2V0KGtleSkgfHwgbnVsbDtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgYWN0aXZlIGVkaXRvciBzdGF0ZS5cbiAgICogQHJldHVybnMgVGhlIGVkaXRvciBzdGF0ZVxuICAgKi9cblxuXG4gIGdldEVkaXRvclN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9lZGl0b3JTdGF0ZTtcbiAgfVxuICAvKipcbiAgICogSW1wZXJhdGl2ZWx5IHNldCB0aGUgRWRpdG9yU3RhdGUuIFRyaWdnZXJzIHJlY29uY2lsaWF0aW9uIGxpa2UgYW4gdXBkYXRlLlxuICAgKiBAcGFyYW0gZWRpdG9yU3RhdGUgLSB0aGUgc3RhdGUgdG8gc2V0IHRoZSBlZGl0b3JcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBvcHRpb25zIGZvciB0aGUgdXBkYXRlLlxuICAgKi9cblxuXG4gIHNldEVkaXRvclN0YXRlKGVkaXRvclN0YXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKGVkaXRvclN0YXRlLmlzRW1wdHkoKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvcihgc2V0RWRpdG9yU3RhdGU6IHRoZSBlZGl0b3Igc3RhdGUgaXMgZW1wdHkuIEVuc3VyZSB0aGUgZWRpdG9yIHN0YXRlJ3Mgcm9vdCBub2RlIG5ldmVyIGJlY29tZXMgZW1wdHkuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmx1c2hSb290TXV0YXRpb25zKHRoaXMpO1xuICAgIGNvbnN0IHBlbmRpbmdFZGl0b3JTdGF0ZSA9IHRoaXMuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgICBjb25zdCB0YWdzID0gdGhpcy5fdXBkYXRlVGFncztcbiAgICBjb25zdCB0YWcgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRhZyA6IG51bGw7XG5cbiAgICBpZiAocGVuZGluZ0VkaXRvclN0YXRlICE9PSBudWxsICYmICFwZW5kaW5nRWRpdG9yU3RhdGUuaXNFbXB0eSgpKSB7XG4gICAgICBpZiAodGFnICE9IG51bGwpIHtcbiAgICAgICAgdGFncy5hZGQodGFnKTtcbiAgICAgIH1cblxuICAgICAgY29tbWl0UGVuZGluZ1VwZGF0ZXModGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGVuZGluZ0VkaXRvclN0YXRlID0gZWRpdG9yU3RhdGU7XG4gICAgdGhpcy5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG5cbiAgICB0aGlzLl9kaXJ0eUVsZW1lbnRzLnNldCgncm9vdCcsIGZhbHNlKTtcblxuICAgIHRoaXMuX2NvbXBvc2l0aW9uS2V5ID0gbnVsbDtcblxuICAgIGlmICh0YWcgIT0gbnVsbCkge1xuICAgICAgdGFncy5hZGQodGFnKTtcbiAgICB9XG5cbiAgICBjb21taXRQZW5kaW5nVXBkYXRlcyh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgU2VyaWFsaXplZEVkaXRvclN0YXRlICh1c3VhbGx5IHByb2R1Y2VkIGJ5IHtAbGluayBFZGl0b3JTdGF0ZS50b0pTT059KSBhbmQgcmV0dXJuc1xuICAgKiBhbmQgRWRpdG9yU3RhdGUgb2JqZWN0IHRoYXQgY2FuIGJlLCBmb3IgZXhhbXBsZSwgcGFzc2VkIHRvIHtAbGluayBMZXhpY2FsRWRpdG9yLnNldEVkaXRvclN0YXRlfS4gVHlwaWNhbGx5LFxuICAgKiBkZXNlcmxpYXphdGlvbiBmcm9tIEpTT04gc3RvcmVkIGluIGEgZGF0YWJhc2UgdXNlcyB0aGlzIG1ldGhvZC5cbiAgICogQHBhcmFtIG1heWJlU3RyaW5naWZpZWRFZGl0b3JTdGF0ZVxuICAgKiBAcGFyYW0gdXBkYXRlRm5cbiAgICogQHJldHVybnNcbiAgICovXG5cblxuICBwYXJzZUVkaXRvclN0YXRlKG1heWJlU3RyaW5naWZpZWRFZGl0b3JTdGF0ZSwgdXBkYXRlRm4pIHtcbiAgICBjb25zdCBzZXJpYWxpemVkRWRpdG9yU3RhdGUgPSB0eXBlb2YgbWF5YmVTdHJpbmdpZmllZEVkaXRvclN0YXRlID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UobWF5YmVTdHJpbmdpZmllZEVkaXRvclN0YXRlKSA6IG1heWJlU3RyaW5naWZpZWRFZGl0b3JTdGF0ZTtcbiAgICByZXR1cm4gcGFyc2VFZGl0b3JTdGF0ZShzZXJpYWxpemVkRWRpdG9yU3RhdGUsIHRoaXMsIHVwZGF0ZUZuKTtcbiAgfVxuICAvKipcbiAgICogRXhlY3V0ZXMgYW4gdXBkYXRlIHRvIHRoZSBlZGl0b3Igc3RhdGUuIFRoZSB1cGRhdGVGbiBjYWxsYmFjayBpcyB0aGUgT05MWSBwbGFjZVxuICAgKiB3aGVyZSBMZXhpY2FsIGVkaXRvciBzdGF0ZSBjYW4gYmUgc2FmZWx5IG11dGF0ZWQuXG4gICAqIEBwYXJhbSB1cGRhdGVGbiAtIEEgZnVuY3Rpb24gdGhhdCBoYXMgYWNjZXNzIHRvIHdyaXRhYmxlIGVkaXRvciBzdGF0ZS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBIGJhZyBvZiBvcHRpb25zIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yIG9mIHRoZSB1cGRhdGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLm9uVXBkYXRlIC0gQSBmdW5jdGlvbiB0byBydW4gb25jZSB0aGUgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICAgKiBVc2VmdWwgZm9yIHN5bmNocm9uaXppbmcgdXBkYXRlcyBpbiBzb21lIGNhc2VzLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5za2lwVHJhbnNmb3JtcyAtIFNldHRpbmcgdGhpcyB0byB0cnVlIHdpbGwgc3VwcHJlc3MgYWxsIG5vZGVcbiAgICogdHJhbnNmb3JtcyBmb3IgdGhpcyB1cGRhdGUgY3ljbGUuXG4gICAqIEBwYXJhbSBvcHRpb25zLnRhZyAtIEEgdGFnIHRvIGlkZW50aWZ5IHRoaXMgdXBkYXRlLCBpbiBhbiB1cGRhdGUgbGlzdGVuZXIsIGZvciBpbnN0YW5jZS5cbiAgICogU29tZSB0YWdzIGFyZSByZXNlcnZlZCBieSB0aGUgY29yZSBhbmQgY29udHJvbCB1cGRhdGUgYmVoYXZpb3IgaW4gZGlmZmVyZW50IHdheXMuXG4gICAqIEBwYXJhbSBvcHRpb25zLmRpc2NyZXRlIC0gSWYgdHJ1ZSwgcHJldmVudHMgdGhpcyB1cGRhdGUgZnJvbSBiZWluZyBiYXRjaGVkLCBmb3JjaW5nIGl0IHRvXG4gICAqIHJ1biBzeW5jaHJvbm91c2x5LlxuICAgKi9cblxuXG4gIHVwZGF0ZSh1cGRhdGVGbiwgb3B0aW9ucykge1xuICAgIHVwZGF0ZUVkaXRvcih0aGlzLCB1cGRhdGVGbiwgb3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIEZvY3VzZXMgdGhlIGVkaXRvclxuICAgKiBAcGFyYW0gY2FsbGJhY2tGbiAtIEEgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBIGJhZyBvZiBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25zLmRlZmF1bHRTZWxlY3Rpb24gLSBXaGVyZSB0byBtb3ZlIHNlbGVjdGlvbiB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICogZm9jdXNlZC4gQ2FuIGJlIHJvb3RTdGFydCwgcm9vdEVuZCwgb3IgdW5kZWZpbmVkLiBEZWZhdWx0cyB0byByb290RW5kLlxuICAgKi9cblxuXG4gIGZvY3VzKGNhbGxiYWNrRm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gdGhpcy5fcm9vdEVsZW1lbnQ7XG5cbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGlPUyBkb2VzIG5vdCB0cmlnZ2VyIGNhcHMgbG9jayB1cG9uIGZvY3VzXG4gICAgICByb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F1dG9jYXBpdGFsaXplJywgJ29mZicpO1xuICAgICAgdXBkYXRlRWRpdG9yKHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gTWFya2luZyB0aGUgc2VsZWN0aW9uIGRpcnR5IHdpbGwgZm9yY2UgdGhlIHNlbGVjdGlvbiBiYWNrIHRvIGl0XG4gICAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChyb290LmdldENoaWxkcmVuU2l6ZSgpICE9PSAwKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdFNlbGVjdGlvbiA9PT0gJ3Jvb3RTdGFydCcpIHtcbiAgICAgICAgICAgIHJvb3Quc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm9vdC5zZWxlY3RFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgb25VcGRhdGU6ICgpID0+IHtcbiAgICAgICAgICByb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2F1dG9jYXBpdGFsaXplJyk7XG5cbiAgICAgICAgICBpZiAoY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgY2FsbGJhY2tGbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdGFnOiAnZm9jdXMnXG4gICAgICB9KTsgLy8gSW4gdGhlIGNhc2Ugd2hlcmUgb25VcGRhdGUgZG9lc24ndCBmaXJlIChkdWUgdG8gdGhlIGZvY3VzIHVwZGF0ZSBub3RcbiAgICAgIC8vIG9jY3VyaW5nKS5cblxuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2F1dG9jYXBpdGFsaXplJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGZvY3VzIGZyb20gdGhlIGVkaXRvci5cbiAgICovXG5cblxuICBibHVyKCkge1xuICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gdGhpcy5fcm9vdEVsZW1lbnQ7XG5cbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHJvb3RFbGVtZW50LmJsdXIoKTtcbiAgICB9XG5cbiAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24odGhpcy5fd2luZG93KTtcblxuICAgIGlmIChkb21TZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGVkaXRvciBpcyBlZGl0YWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cblxuXG4gIGlzRWRpdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRhYmxlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBlZGl0YWJsZSBwcm9wZXJ0eSBvZiB0aGUgZWRpdG9yLiBXaGVuIGZhbHNlLCB0aGVcbiAgICogZWRpdG9yIHdpbGwgbm90IGxpc3RlbiBmb3IgdXNlciBldmVudHMgb24gdGhlIHVuZGVybGluZyBjb250ZW50ZWRpdGFibGUuXG4gICAqIEBwYXJhbSBlZGl0YWJsZSAtIHRoZSB2YWx1ZSB0byBzZXQgdGhlIGVkaXRhYmxlIG1vZGUgdG8uXG4gICAqL1xuXG5cbiAgc2V0RWRpdGFibGUoZWRpdGFibGUpIHtcbiAgICBpZiAodGhpcy5fZWRpdGFibGUgIT09IGVkaXRhYmxlKSB7XG4gICAgICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xuICAgICAgdHJpZ2dlckxpc3RlbmVycygnZWRpdGFibGUnLCB0aGlzLCB0cnVlLCBlZGl0YWJsZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgamF2YXNjcmlwdCBvYmplY3QgTk9UIGEgSlNPTiBzdHJpbmcuXG4gICAqIFlvdSBzdGlsbCBtdXN0IGNhbGwgSlNPTi5zdHJpbmdpZnkgKG9yIHNvbWV0aGluZyBlbHNlKSB0byB0dXJuIHRoZVxuICAgKiBzdGF0ZSBpbnRvIGEgc3RyaW5nIHlvdSBjYW4gdHJhbnNmZXIgb3ZlciB0aGUgd2lyZSBhbmQgc3RvcmUgaW4gYSBkYXRhYmFzZS5cbiAgICpcbiAgICogU2VlIHtAbGluayBMZXhpY2FsTm9kZS5leHBvcnRKU09OfVxuICAgKlxuICAgKiBAcmV0dXJucyBBIEpTT04tc2VyaWFsaXphYmxlIGphdmFzY3JpcHQgb2JqZWN0XG4gICAqL1xuXG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlZGl0b3JTdGF0ZTogdGhpcy5fZWRpdG9yU3RhdGUudG9KU09OKClcbiAgICB9O1xuICB9XG5cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgREVQUkVDQVRFRF9HcmlkQ2VsbE5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3IoY29sU3Bhbiwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fY29sU3BhbiA9IGNvbFNwYW47XG4gICAgdGhpcy5fX3Jvd1NwYW4gPSAxO1xuICB9XG5cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4geyAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBjb2xTcGFuOiB0aGlzLl9fY29sU3BhbixcbiAgICAgIHJvd1NwYW46IHRoaXMuX19yb3dTcGFuXG4gICAgfTtcbiAgfVxuXG4gIGdldENvbFNwYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19jb2xTcGFuO1xuICB9XG5cbiAgc2V0Q29sU3Bhbihjb2xTcGFuKSB7XG4gICAgdGhpcy5nZXRXcml0YWJsZSgpLl9fY29sU3BhbiA9IGNvbFNwYW47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRSb3dTcGFuKCkge1xuICAgIHJldHVybiB0aGlzLl9fcm93U3BhbjtcbiAgfVxuXG4gIHNldFJvd1NwYW4ocm93U3Bhbikge1xuICAgIHRoaXMuZ2V0V3JpdGFibGUoKS5fX3Jvd1NwYW4gPSByb3dTcGFuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn1cbmZ1bmN0aW9uIERFUFJFQ0FURURfJGlzR3JpZENlbGxOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBERVBSRUNBVEVEX0dyaWRDZWxsTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuY2xhc3MgREVQUkVDQVRFRF9HcmlkTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHt9XG5mdW5jdGlvbiBERVBSRUNBVEVEXyRpc0dyaWROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBERVBSRUNBVEVEX0dyaWROb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5jbGFzcyBERVBSRUNBVEVEX0dyaWRSb3dOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge31cbmZ1bmN0aW9uIERFUFJFQ0FURURfJGlzR3JpZFJvd05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIERFUFJFQ0FURURfR3JpZFJvd05vZGU7XG59XG5cbmV4cG9ydHMuJGFkZFVwZGF0ZVRhZyA9ICRhZGRVcGRhdGVUYWc7XG5leHBvcnRzLiRhcHBseU5vZGVSZXBsYWNlbWVudCA9ICRhcHBseU5vZGVSZXBsYWNlbWVudDtcbmV4cG9ydHMuJGNvcHlOb2RlID0gJGNvcHlOb2RlO1xuZXhwb3J0cy4kY3JlYXRlTGluZUJyZWFrTm9kZSA9ICRjcmVhdGVMaW5lQnJlYWtOb2RlO1xuZXhwb3J0cy4kY3JlYXRlTm9kZVNlbGVjdGlvbiA9ICRjcmVhdGVOb2RlU2VsZWN0aW9uO1xuZXhwb3J0cy4kY3JlYXRlUGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlO1xuZXhwb3J0cy4kY3JlYXRlUmFuZ2VTZWxlY3Rpb24gPSAkY3JlYXRlUmFuZ2VTZWxlY3Rpb247XG5leHBvcnRzLiRjcmVhdGVUYWJOb2RlID0gJGNyZWF0ZVRhYk5vZGU7XG5leHBvcnRzLiRjcmVhdGVUZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZTtcbmV4cG9ydHMuJGdldEFkamFjZW50Tm9kZSA9ICRnZXRBZGphY2VudE5vZGU7XG5leHBvcnRzLiRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGU7XG5leHBvcnRzLiRnZXROZWFyZXN0Um9vdE9yU2hhZG93Um9vdCA9ICRnZXROZWFyZXN0Um9vdE9yU2hhZG93Um9vdDtcbmV4cG9ydHMuJGdldE5vZGVCeUtleSA9ICRnZXROb2RlQnlLZXk7XG5leHBvcnRzLiRnZXRQcmV2aW91c1NlbGVjdGlvbiA9ICRnZXRQcmV2aW91c1NlbGVjdGlvbjtcbmV4cG9ydHMuJGdldFJvb3QgPSAkZ2V0Um9vdDtcbmV4cG9ydHMuJGdldFNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb247XG5leHBvcnRzLiRnZXRUZXh0Q29udGVudCA9ICRnZXRUZXh0Q29udGVudDtcbmV4cG9ydHMuJGhhc0FuY2VzdG9yID0gJGhhc0FuY2VzdG9yO1xuZXhwb3J0cy4kaGFzVXBkYXRlVGFnID0gJGhhc1VwZGF0ZVRhZztcbmV4cG9ydHMuJGluc2VydE5vZGVzID0gJGluc2VydE5vZGVzO1xuZXhwb3J0cy4kaXNCbG9ja0VsZW1lbnROb2RlID0gJGlzQmxvY2tFbGVtZW50Tm9kZTtcbmV4cG9ydHMuJGlzRGVjb3JhdG9yTm9kZSA9ICRpc0RlY29yYXRvck5vZGU7XG5leHBvcnRzLiRpc0VsZW1lbnROb2RlID0gJGlzRWxlbWVudE5vZGU7XG5leHBvcnRzLiRpc0lubGluZUVsZW1lbnRPckRlY29yYXRvck5vZGUgPSAkaXNJbmxpbmVFbGVtZW50T3JEZWNvcmF0b3JOb2RlO1xuZXhwb3J0cy4kaXNMZWFmTm9kZSA9ICRpc0xlYWZOb2RlO1xuZXhwb3J0cy4kaXNMaW5lQnJlYWtOb2RlID0gJGlzTGluZUJyZWFrTm9kZTtcbmV4cG9ydHMuJGlzTm9kZVNlbGVjdGlvbiA9ICRpc05vZGVTZWxlY3Rpb247XG5leHBvcnRzLiRpc1BhcmFncmFwaE5vZGUgPSAkaXNQYXJhZ3JhcGhOb2RlO1xuZXhwb3J0cy4kaXNSYW5nZVNlbGVjdGlvbiA9ICRpc1JhbmdlU2VsZWN0aW9uO1xuZXhwb3J0cy4kaXNSb290Tm9kZSA9ICRpc1Jvb3ROb2RlO1xuZXhwb3J0cy4kaXNSb290T3JTaGFkb3dSb290ID0gJGlzUm9vdE9yU2hhZG93Um9vdDtcbmV4cG9ydHMuJGlzVGFiTm9kZSA9ICRpc1RhYk5vZGU7XG5leHBvcnRzLiRpc1RleHROb2RlID0gJGlzVGV4dE5vZGU7XG5leHBvcnRzLiRub2Rlc09mVHlwZSA9ICRub2Rlc09mVHlwZTtcbmV4cG9ydHMuJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMID0gJG5vcm1hbGl6ZVNlbGVjdGlvbjtcbmV4cG9ydHMuJHBhcnNlU2VyaWFsaXplZE5vZGUgPSAkcGFyc2VTZXJpYWxpemVkTm9kZTtcbmV4cG9ydHMuJHNldENvbXBvc2l0aW9uS2V5ID0gJHNldENvbXBvc2l0aW9uS2V5O1xuZXhwb3J0cy4kc2V0U2VsZWN0aW9uID0gJHNldFNlbGVjdGlvbjtcbmV4cG9ydHMuJHNwbGl0Tm9kZSA9ICRzcGxpdE5vZGU7XG5leHBvcnRzLkJMVVJfQ09NTUFORCA9IEJMVVJfQ09NTUFORDtcbmV4cG9ydHMuQ0FOX1JFRE9fQ09NTUFORCA9IENBTl9SRURPX0NPTU1BTkQ7XG5leHBvcnRzLkNBTl9VTkRPX0NPTU1BTkQgPSBDQU5fVU5ET19DT01NQU5EO1xuZXhwb3J0cy5DTEVBUl9FRElUT1JfQ09NTUFORCA9IENMRUFSX0VESVRPUl9DT01NQU5EO1xuZXhwb3J0cy5DTEVBUl9ISVNUT1JZX0NPTU1BTkQgPSBDTEVBUl9ISVNUT1JZX0NPTU1BTkQ7XG5leHBvcnRzLkNMSUNLX0NPTU1BTkQgPSBDTElDS19DT01NQU5EO1xuZXhwb3J0cy5DT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMID0gQ09NTUFORF9QUklPUklUWV9DUklUSUNBTDtcbmV4cG9ydHMuQ09NTUFORF9QUklPUklUWV9FRElUT1IgPSBDT01NQU5EX1BSSU9SSVRZX0VESVRPUjtcbmV4cG9ydHMuQ09NTUFORF9QUklPUklUWV9ISUdIID0gQ09NTUFORF9QUklPUklUWV9ISUdIO1xuZXhwb3J0cy5DT01NQU5EX1BSSU9SSVRZX0xPVyA9IENPTU1BTkRfUFJJT1JJVFlfTE9XO1xuZXhwb3J0cy5DT01NQU5EX1BSSU9SSVRZX05PUk1BTCA9IENPTU1BTkRfUFJJT1JJVFlfTk9STUFMO1xuZXhwb3J0cy5DT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQgPSBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQ7XG5leHBvcnRzLkNPUFlfQ09NTUFORCA9IENPUFlfQ09NTUFORDtcbmV4cG9ydHMuQ1VUX0NPTU1BTkQgPSBDVVRfQ09NTUFORDtcbmV4cG9ydHMuREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5EID0gREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5EO1xuZXhwb3J0cy5ERUxFVEVfTElORV9DT01NQU5EID0gREVMRVRFX0xJTkVfQ09NTUFORDtcbmV4cG9ydHMuREVMRVRFX1dPUkRfQ09NTUFORCA9IERFTEVURV9XT1JEX0NPTU1BTkQ7XG5leHBvcnRzLkRFUFJFQ0FURURfJGNvbXB1dGVHcmlkTWFwID0gREVQUkVDQVRFRF8kY29tcHV0ZUdyaWRNYXA7XG5leHBvcnRzLkRFUFJFQ0FURURfJGNyZWF0ZUdyaWRTZWxlY3Rpb24gPSBERVBSRUNBVEVEXyRjcmVhdGVHcmlkU2VsZWN0aW9uO1xuZXhwb3J0cy5ERVBSRUNBVEVEXyRnZXROb2RlVHJpcGxldCA9IERFUFJFQ0FURURfJGdldE5vZGVUcmlwbGV0O1xuZXhwb3J0cy5ERVBSRUNBVEVEXyRpc0dyaWRDZWxsTm9kZSA9IERFUFJFQ0FURURfJGlzR3JpZENlbGxOb2RlO1xuZXhwb3J0cy5ERVBSRUNBVEVEXyRpc0dyaWROb2RlID0gREVQUkVDQVRFRF8kaXNHcmlkTm9kZTtcbmV4cG9ydHMuREVQUkVDQVRFRF8kaXNHcmlkUm93Tm9kZSA9IERFUFJFQ0FURURfJGlzR3JpZFJvd05vZGU7XG5leHBvcnRzLkRFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbiA9IERFUFJFQ0FURURfJGlzR3JpZFNlbGVjdGlvbjtcbmV4cG9ydHMuREVQUkVDQVRFRF9HcmlkQ2VsbE5vZGUgPSBERVBSRUNBVEVEX0dyaWRDZWxsTm9kZTtcbmV4cG9ydHMuREVQUkVDQVRFRF9HcmlkTm9kZSA9IERFUFJFQ0FURURfR3JpZE5vZGU7XG5leHBvcnRzLkRFUFJFQ0FURURfR3JpZFJvd05vZGUgPSBERVBSRUNBVEVEX0dyaWRSb3dOb2RlO1xuZXhwb3J0cy5EUkFHRU5EX0NPTU1BTkQgPSBEUkFHRU5EX0NPTU1BTkQ7XG5leHBvcnRzLkRSQUdPVkVSX0NPTU1BTkQgPSBEUkFHT1ZFUl9DT01NQU5EO1xuZXhwb3J0cy5EUkFHU1RBUlRfQ09NTUFORCA9IERSQUdTVEFSVF9DT01NQU5EO1xuZXhwb3J0cy5EUk9QX0NPTU1BTkQgPSBEUk9QX0NPTU1BTkQ7XG5leHBvcnRzLkRlY29yYXRvck5vZGUgPSBEZWNvcmF0b3JOb2RlO1xuZXhwb3J0cy5FbGVtZW50Tm9kZSA9IEVsZW1lbnROb2RlO1xuZXhwb3J0cy5GT0NVU19DT01NQU5EID0gRk9DVVNfQ09NTUFORDtcbmV4cG9ydHMuRk9STUFUX0VMRU1FTlRfQ09NTUFORCA9IEZPUk1BVF9FTEVNRU5UX0NPTU1BTkQ7XG5leHBvcnRzLkZPUk1BVF9URVhUX0NPTU1BTkQgPSBGT1JNQVRfVEVYVF9DT01NQU5EO1xuZXhwb3J0cy5JTkRFTlRfQ09OVEVOVF9DT01NQU5EID0gSU5ERU5UX0NPTlRFTlRfQ09NTUFORDtcbmV4cG9ydHMuSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCA9IElOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQ7XG5leHBvcnRzLklOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCA9IElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORDtcbmV4cG9ydHMuSU5TRVJUX1RBQl9DT01NQU5EID0gSU5TRVJUX1RBQl9DT01NQU5EO1xuZXhwb3J0cy5LRVlfQVJST1dfRE9XTl9DT01NQU5EID0gS0VZX0FSUk9XX0RPV05fQ09NTUFORDtcbmV4cG9ydHMuS0VZX0FSUk9XX0xFRlRfQ09NTUFORCA9IEtFWV9BUlJPV19MRUZUX0NPTU1BTkQ7XG5leHBvcnRzLktFWV9BUlJPV19SSUdIVF9DT01NQU5EID0gS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQ7XG5leHBvcnRzLktFWV9BUlJPV19VUF9DT01NQU5EID0gS0VZX0FSUk9XX1VQX0NPTU1BTkQ7XG5leHBvcnRzLktFWV9CQUNLU1BBQ0VfQ09NTUFORCA9IEtFWV9CQUNLU1BBQ0VfQ09NTUFORDtcbmV4cG9ydHMuS0VZX0RFTEVURV9DT01NQU5EID0gS0VZX0RFTEVURV9DT01NQU5EO1xuZXhwb3J0cy5LRVlfRE9XTl9DT01NQU5EID0gS0VZX0RPV05fQ09NTUFORDtcbmV4cG9ydHMuS0VZX0VOVEVSX0NPTU1BTkQgPSBLRVlfRU5URVJfQ09NTUFORDtcbmV4cG9ydHMuS0VZX0VTQ0FQRV9DT01NQU5EID0gS0VZX0VTQ0FQRV9DT01NQU5EO1xuZXhwb3J0cy5LRVlfTU9ESUZJRVJfQ09NTUFORCA9IEtFWV9NT0RJRklFUl9DT01NQU5EO1xuZXhwb3J0cy5LRVlfU1BBQ0VfQ09NTUFORCA9IEtFWV9TUEFDRV9DT01NQU5EO1xuZXhwb3J0cy5LRVlfVEFCX0NPTU1BTkQgPSBLRVlfVEFCX0NPTU1BTkQ7XG5leHBvcnRzLkxpbmVCcmVha05vZGUgPSBMaW5lQnJlYWtOb2RlO1xuZXhwb3J0cy5NT1ZFX1RPX0VORCA9IE1PVkVfVE9fRU5EO1xuZXhwb3J0cy5NT1ZFX1RPX1NUQVJUID0gTU9WRV9UT19TVEFSVDtcbmV4cG9ydHMuT1VUREVOVF9DT05URU5UX0NPTU1BTkQgPSBPVVRERU5UX0NPTlRFTlRfQ09NTUFORDtcbmV4cG9ydHMuUEFTVEVfQ09NTUFORCA9IFBBU1RFX0NPTU1BTkQ7XG5leHBvcnRzLlBhcmFncmFwaE5vZGUgPSBQYXJhZ3JhcGhOb2RlO1xuZXhwb3J0cy5SRURPX0NPTU1BTkQgPSBSRURPX0NPTU1BTkQ7XG5leHBvcnRzLlJFTU9WRV9URVhUX0NPTU1BTkQgPSBSRU1PVkVfVEVYVF9DT01NQU5EO1xuZXhwb3J0cy5Sb290Tm9kZSA9IFJvb3ROb2RlO1xuZXhwb3J0cy5TRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQgPSBTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQ7XG5leHBvcnRzLlRhYk5vZGUgPSBUYWJOb2RlO1xuZXhwb3J0cy5UZXh0Tm9kZSA9IFRleHROb2RlO1xuZXhwb3J0cy5VTkRPX0NPTU1BTkQgPSBVTkRPX0NPTU1BTkQ7XG5leHBvcnRzLmNyZWF0ZUNvbW1hbmQgPSBjcmVhdGVDb21tYW5kO1xuZXhwb3J0cy5jcmVhdGVFZGl0b3IgPSBjcmVhdGVFZGl0b3I7XG5leHBvcnRzLmdldE5lYXJlc3RFZGl0b3JGcm9tRE9NTm9kZSA9IGdldE5lYXJlc3RFZGl0b3JGcm9tRE9NTm9kZTtcbmV4cG9ydHMuaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9ySW5wdXQgPSBpc1NlbGVjdGlvbkNhcHR1cmVkSW5EZWNvcmF0b3JJbnB1dDtcbmV4cG9ydHMuaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IgPSBpc1NlbGVjdGlvbldpdGhpbkVkaXRvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lexical/Lexical.dev.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/lexical/Lexical.js":
/*!*****************************************!*\
  !*** ./node_modules/lexical/Lexical.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst Lexical =  true ? __webpack_require__(/*! ./Lexical.dev.js */ \"(ssr)/./node_modules/lexical/Lexical.dev.js\") : 0\nmodule.exports = Lexical;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGV4aWNhbC9MZXhpY2FsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNZO0FBQ1osZ0JBQWdCLEtBQXNDLEdBQUcsbUJBQU8sQ0FBQyxxRUFBa0IsSUFBSSxDQUE0QjtBQUNuSCIsInNvdXJjZXMiOlsid2VicGFjazovL2Ntc19jcmVhdG9yLy4vbm9kZV9tb2R1bGVzL2xleGljYWwvTGV4aWNhbC5qcz9jZTQ2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuJ3VzZSBzdHJpY3QnXG5jb25zdCBMZXhpY2FsID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgPyByZXF1aXJlKCcuL0xleGljYWwuZGV2LmpzJykgOiByZXF1aXJlKCcuL0xleGljYWwucHJvZC5qcycpXG5tb2R1bGUuZXhwb3J0cyA9IExleGljYWw7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lexical/Lexical.js\n");

/***/ })

};
;